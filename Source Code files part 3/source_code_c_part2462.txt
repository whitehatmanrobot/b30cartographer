CreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPGetCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetCapsDPNMessageHandler()"
//==================================================================================
// ParmVPSetCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPSetCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetSPCapsDPNMessageHandler()"
//==================================================================================
// ParmVPGetSPCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetSPCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPGetSPCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetSPCapsDPNMessageHandler()"
//==================================================================================
// ParmVPSetSPCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetSPCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPSetSPCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetConnInfoDPNMessageHandler()"
//==================================================================================
// ParmVPGetConnInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetConnInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPGETCONNINFOCONTEXT	pContext = (PPARMVPGETCONNINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetConnInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPTerminateDPNMessageHandler()"
//==================================================================================
// ParmVPTerminateDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPTerminateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPTERMINATECONTEXT		pContext = (PPARMVPTERMINATECONTEXT) pvContext;
	DWORD						dwPlayer;

	DPTEST_TRACE(pContext->hLog, "Callback entered with context 0x%08x", 1, pvContext);

	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			dwPlayer = (pCreatePlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectCreatePlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate create player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Save the player ID.
			pContext->adpnidPlayers[dwPlayer] = pCreatePlayerMsg->dpnidPlayer;

			// Alert the test thread, if we have to.
			if (pContext->hLastPlayerMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hLastPlayerMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hLastPlayerMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (have event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			dwPlayer = (pDestroyPlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectDestroyPlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_DESTROY_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate destroy player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Zero out the player ID.
			pContext->adpnidPlayers[dwPlayer] = 0;

			if (InterlockedDecrement((LPLONG) (&pContext->dwNumDestroyPlayersRemaining)) == 0)
			{
				// Alert the test thread, if we have to.
				if (pContext->hLastPlayerMsgEvent != NULL)
				{
					if (! SetEvent(pContext->hLastPlayerMsgEvent))
					{
						hr = GetLastError();
						DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
							1, pContext->hLastPlayerMsgEvent);

						DEBUGBREAK();

						if (hr == S_OK)
							hr = E_FAIL;

						break;
					} // end if (couldn't set event)
				} // end if (have event)
			} // end if (no more destroy players expected)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION	pTerminateSessionMsg;


			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pTerminateSessionMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = %x", 1, pTerminateSessionMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvTerminateData = %x", 1, pTerminateSessionMsg->pvTerminateData);
			DPTEST_TRACE(pContext->hLog, "    dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);


			// Make sure we expect the message.
			if (! pContext->fExpectTerminateSession)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_TERMINATE_SESSION (%x)!  DEBUGBREAK()-ing.",
					1, pTerminateSessionMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the indication.
			if (pTerminateSessionMsg->dwSize != sizeof (DPNMSG_TERMINATE_SESSION))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_TERMINATE_SESSION is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pTerminateSessionMsg->dwSize, sizeof (DPNMSG_TERMINATE_SESSION));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if ((pTerminateSessionMsg->pvTerminateData != NULL) ||
				(pTerminateSessionMsg->dwTerminateDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Terminate session indicated with unexpected data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pTerminateSessionMsg->pvTerminateData,
					pTerminateSessionMsg->dwTerminateDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected data)


			// Make sure this isn't a double indication.
			if (pContext->fGotTerminateSession)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate indication of terminate session (msg = %x)!  DEBUGBREAK()-ing.",
					1, pTerminateSessionMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotTerminateSession = TRUE;
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPTerminateDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\parmvclient.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Structures
//==================================================================================
typedef struct tagPARMVCGETSENDQINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVCGETSENDQINFOCONTEXT, * PPARMVCGETSENDQINFOCONTEXT;

typedef struct tagPARMVCSETCLIENTINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fCanGetClientInfoUpdate; // whether the peer info indication can arrive or not
	BOOL					fGotClientInfoUpdate; // whether the peer info indication did arrive
	HANDLE					hGotClientInfoUpdateEvent; // event to set when peer info message is received
	PWRAPDP8SERVER			pDP8Server; // pointer to DP8Server wrapper object to use
	WCHAR*					pwszExpectedClientInfoName; // expected client info name
	PVOID*					pvExpectedClientInfoData; // expected client info data
	DWORD					dwExpectedClientInfoDataSize; // expected client info data size
	DWORD					dwExpectedClientInfoPlayerFlags; // expected client info player flags
} PARMVCSETCLIENTINFOCONTEXT, * PPARMVCSETCLIENTINFOCONTEXT;

typedef struct tagPARMVCGETSERVERINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVCGETSERVERINFOCONTEXT, * PPARMVCGETSERVERINFOCONTEXT;

typedef struct tagPARMVCGETSERVERADDRESSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVCGETSERVERADDRESSCONTEXT, * PPARMVCGETSERVERADDRESSCONTEXT;

typedef struct tagPARMVCGETCONNINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVCGETCONNINFOCONTEXT, * PPARMVCGETCONNINFOCONTEXT;





//==================================================================================
// Prototypes
//==================================================================================
//HRESULT ParmVClientExec_CreateQI(HANDLE hLog);
//HRESULT ParmVClientExec_Init(HANDLE hLog);
//HRESULT ParmVClientExec_EnumSPs(HANDLE hLog);
//HRESULT ParmVClientExec_EnumHosts(HANDLE hLog);
//HRESULT ParmVClientExec_Cancel(HANDLE hLog);
//HRESULT ParmVClientExec_Connect(HANDLE hLog);
//HRESULT ParmVClientExec_Send(HANDLE hLog);
HRESULT ParmVClientExec_GetSendQInfo(HANDLE hLog);
//HRESULT ParmVClientExec_GetAppDesc(HANDLE hLog);
HRESULT ParmVClientExec_SetClientInfo(HANDLE hLog);
HRESULT ParmVClientExec_GetServerInfo(HANDLE hLog);
HRESULT ParmVClientExec_GetServerAddress(HANDLE hLog);
//HRESULT ParmVClientExec_Close(HANDLE hLog);
//HRESULT ParmVClientExec_Return(HANDLE hLog);
//HRESULT ParmVClientExec_GetCaps(HANDLE hLog);
//HRESULT ParmVClientExec_SetCaps(HANDLE hLog);
//HRESULT ParmVClientExec_SetSPCaps(HANDLE hLog);
//HRESULT ParmVClientExec_GetSPCaps(HANDLE hLog);
HRESULT ParmVClientExec_GetConnInfo(HANDLE hLog);
//HRESULT ParmVClientExec_RegLobby(HANDLE hLog);




HRESULT ParmVCGetSendQInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

HRESULT ParmVCSetClientInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVCGetServerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVCGetServerAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

HRESULT ParmVCGetConnInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);






/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientLoadTestTable()"
//==================================================================================
// ParmVClientLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.1.3		Client interface parameter validation tests
//				2.1.3.1		Client DirectPlay8Create and QueryInterface parameter validation
//				2.1.3.2		Client Initialize parameter validation
//				2.1.3.3		Client EnumServiceProviders parameter validation
//
//				2.1.3.8		Client GetSendQueueInfo parameter validation
//
//				2.1.3.10	Client SetClientInfo parameter validation
//				2.1.3.11	Client GetServerInfo parameter validation
//				2.1.3.12	Client GetServerAddress parameter validation
//
//				2.1.3.19	Client GetConnectionInfo parameter validation
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVClientLoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	PTNTESTTABLEGROUP	pSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.3	Client interface parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTNlttd->pBase,
				"2.1.3", "Client interface parameter validation tests",
				&pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.3.8	Client GetSendQueueInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.3.8";
	tnatd.pszName			= "Client GetSendQueueInfo parameter validation";
	tnatd.pszDescription	= "Client GetSendQueueInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVClientExec_GetSendQInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.3.10	Client SetClientInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.3.10";
	tnatd.pszName			= "Client SetClientInfo parameter validation";
	tnatd.pszDescription	= "Client SetClientInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVClientExec_SetClientInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.3.11	Client GetServerInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.3.11";
	tnatd.pszName			= "Client GetServerInfo parameter validation";
	tnatd.pszDescription	= "Client GetServerInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVClientExec_GetServerInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.3.12	Client GetServerAddress parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.3.12";
	tnatd.pszName			= "Client GetServerAddress parameter validation";
	tnatd.pszDescription	= "Client GetServerAddress parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVClientExec_GetServerAddress;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.3.19	Client GetConnectionInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.3.19";
	tnatd.pszName			= "Client GetConnectionInfo parameter validation";
	tnatd.pszDescription	= "Client GetConnectionInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVClientExec_GetConnInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);

	
	
	return (S_OK);
} // ParmVClientLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_CreateQI()"
//==================================================================================
// ParmVClientExec_CreateQI
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.1 - Client DirectPlay8Create and QueryInterface parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_CreateQI(HANDLE hLog)
{
	return (S_OK);
} // ParmVClientExec_CreateQI
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_Init()"
//==================================================================================
// ParmVClientExec_Init
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.2 - Client Initialize parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_Init(HANDLE hLog)
{
	return (S_OK);
} // ParmVClientExec_Init
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_EnumSPs()"
//==================================================================================
// ParmVClientExec_EnumSPs
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.3 - Client EnumServiceProviders parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_EnumSPs(HANDLE hLog)
{
	return (S_OK);
} // ParmVClientExec_EnumSPs
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_GetSendQInfo()"
//==================================================================================
// ParmVClientExec_GetSendQInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.8 - Client GetSendQueueInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_GetSendQInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DWORD						dwNumMsgs = 666;
	DWORD						dwNumBytes = 666;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVCGETSENDQINFOCONTEXT	servercontext;
	PARMVCGETSENDQINFOCONTEXT	clientcontext;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hConnectComplete = NULL;


	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&servercontext, sizeof (PARMVCGETSENDQINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVCGETSENDQINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Client->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with all NULLs and 0 using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Client_GetSendQueueInfo(pDP8Client->m_pDP8Client, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with all NULLs and 0 using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with all NULLs and 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetSendQueueInfo(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with all NULLs and 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting send queue info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		clientcontext.hLog = hLog;

		tr = pDP8Client->DP8C_Initialize(&clientcontext,
										ParmVCGetSendQInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting send queue info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_CLIENT_GETSENDQINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		servercontext.hLog = hLog;

		tr = ParmVCreateServer(hLog,
								ParmVCGetSendQInfoDPNMessageHandler,
								&servercontext,
								&dpnad,
								&(servercontext.dpnidServer),
								&pDP8Server,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating server failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create server)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hConnectComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		clientcontext.fConnectCanComplete = TRUE;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									hConnectComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;
		
		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect completion to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;
		
		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		clientcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! clientcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		clientcontext.fConnectCompleted = FALSE;

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info on client with NULL num msgs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification value.
		dwNumBytes = 666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(NULL, &dwNumBytes, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info on client with NULL num msgs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info on client with NULL num bytes");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification value.
		dwNumMsgs = 666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info on client with NULL num bytes failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting low priority send queue info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes,
												DPNGETSENDQUEUEINFO_PRIORITY_LOW);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting low priority send queue info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting normal priority send queue info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes,
												DPNGETSENDQUEUEINFO_PRIORITY_NORMAL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting normal priority send queue info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting high priority send queue info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes,
												DPNGETSENDQUEUEINFO_PRIORITY_HIGH);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting high priority send queue info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting all priority send queues' info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes,
												(DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_HIGH));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting all priority send queues' info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	ClearDoWorkList(&DoWorkList);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);
	SAFE_CLOSEHANDLE(hConnectComplete);


	return (sr);
} // ParmVClientExec_GetSendQInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_SetClientInfo()"
//==================================================================================
// ParmVClientExec_SetClientInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.10 - Client SetClientInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_SetClientInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVCSETCLIENTINFOCONTEXT	servercontext;
	PARMVCSETCLIENTINFOCONTEXT	clientcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_PLAYER_INFO				dpnpi;
	DPN_PLAYER_INFO				dpnpiCompare;
	DPNHANDLE					dpnhSetClientInfo;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hConnectComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&servercontext, sizeof (PARMVCSETCLIENTINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVCSETCLIENTINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Client->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Client_SetClientInfo(pDP8Client->m_pDP8Client, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting client info with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting client info with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)
*/


		dpnhSetClientInfo = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info with NULL player info structure");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(NULL, NULL, &dpnhSetClientInfo, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting client info with NULL player info structure didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (dpnhSetClientInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetClientInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		//dpnpi.dwInfoFlags = 0;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		//dpnpi.dwPlayerFlags = 0;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info with NULL async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting client info with NULL async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &dpnhSetClientInfo, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting client info with invalid flags structure didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetClientInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetClientInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/


/* XBOX - No support for synchronous
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info synchronously with async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &dpnhSetClientInfo,
											DPNSETCLIENTINFO_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting client info synchronously with async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetClientInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetClientInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &dpnhSetClientInfo, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting client info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetClientInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetClientInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		clientcontext.hLog = hLog;

		tr = pDP8Client->DP8C_Initialize(&clientcontext,
										ParmVCSetClientInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &dpnhSetClientInfo, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting client info prior to connection failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetClientInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetClientInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_CLIENT_SETCLIENTINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		servercontext.hLog = hLog;

		tr = ParmVCreateServer(hLog,
								ParmVCSetClientInfoDPNMessageHandler,
								&servercontext,
								&dpnad,
								&(servercontext.dpnidServer),
								&(servercontext.pDP8Server),
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating server failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create server)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,	NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hConnectComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		clientcontext.fConnectCanComplete = TRUE;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									hConnectComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = servercontext.pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect completion to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = servercontext.pDP8Server->m_pDP8Server;
		
		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		clientcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! clientcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		clientcontext.fConnectCompleted = FALSE;

		ClearDoWorkList(&DoWorkList);

/* XBOX - Synchornous calls not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the client info message on the server.
		servercontext.fCanGetClientInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(servercontext.hGotClientInfoUpdateEvent,
							NULL, FALSE, FALSE, NULL);
		//servercontext.pwszExpectedClientInfoName = NULL;
		//servercontext.pvExpectedClientInfoData = NULL;
		//servercontext.dwExpectedClientInfoDataSize = 0;
		//servercontext.dwExpectedClientInfoPlayerFlags = 0;

#pragma BUGBUG(vanceo, "No local message")

//		// Expect the client info message on client.
//		clientcontext.fCanGetClientInfoUpdate = TRUE;
//		//clientcontext.pwszExpectedClientInfoName = NULL;
//		//clientcontext.pvExpectedClientInfoData = NULL;
//		//clientcontext.dwExpectedClientInfoDataSize = 0;
//		clientcontext.dwExpectedClientInfoPlayerFlags = DPNPLAYER_LOCAL;

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, NULL, DPNSETCLIENTINFO_SYNC);

#pragma BUGBUG(vanceo, "No local message")
		// The client info message should have arrived by now.
		//clientcontext.fCanGetClientInfoUpdate = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting client info synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

#pragma BUGBUG(vanceo, "No local message")

//		// Make sure we got the client info message.
//		if (! clientcontext.fGotClientInfoUpdate)
//		{
//			DPTEST_FAIL(hLog, "Didn't get client info message on server!", 0);
//			SETTHROW_TESTRESULT(ERROR_NO_DATA);
//		} // end if (didn't get client info)
//
//		// Reset the context.
//		clientcontext.fGotClientInfoUpdate = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for client info to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = servercontext.pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hGotClientInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird client info indications.
		servercontext.fCanGetClientInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! servercontext.fGotClientInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get client info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get client info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(servercontext.hGotClientInfoUpdateEvent);
		servercontext.hGotClientInfoUpdateEvent = NULL;
		servercontext.fGotClientInfoUpdate = FALSE;

*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting client info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhSetClientInfo = (DPNHANDLE) 0x666;

		// Expect the client info message on the server.
		servercontext.fCanGetClientInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(servercontext.hGotClientInfoUpdateEvent,
							NULL, FALSE, FALSE, NULL);
		//servercontext.pwszExpectedClientInfoName = NULL;
		//servercontext.pvExpectedClientInfoData = NULL;
		//servercontext.dwExpectedClientInfoDataSize = 0;
		//servercontext.dwExpectedClientInfoPlayerFlags = 0;

#pragma BUGBUG(vanceo, "No local message")
		/*
		// Expect the client info message and async op completion on the client.
		clientcontext.fCanGetClientInfoUpdate = TRUE;
		//clientcontext.pwszExpectedClientInfoName = NULL;
		//clientcontext.pvExpectedClientInfoData = 0;
		//clientcontext.dwExpectedClientInfoDataSize = 0;
		//clientcontext.dwExpectedClientInfoPlayerFlags = DPNPLAYER_LOCAL;
		*/
		CREATEEVENT_OR_THROW(clientcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		clientcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &dpnhSetClientInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting client info didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set client info)

		if (dpnhSetClientInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetClientInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = servercontext.pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, clientcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

#pragma BUGBUG(vanceo, "No local message")
		// The client info message should have arrived by now.
		//clientcontext.fCanGetClientInfoUpdate = FALSE;

		// Prevent any weird async op completions.
		clientcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! clientcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (clientcontext.dpnhCompletedAsyncOp != dpnhSetClientInfo)
		{
			DPTEST_FAIL(hLog, "Set client info completed with different async op handle (%x != %x)!",
				2, clientcontext.dpnhCompletedAsyncOp, dpnhSetClientInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		clientcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(clientcontext.hAsyncOpCompletedEvent);
		clientcontext.hAsyncOpCompletedEvent = NULL;


#pragma BUGBUG(vanceo, "No local message")
		/*
		// Make sure we got the client info message.
		if (! clientcontext.fGotClientInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get client info message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get client info)

		// Reset the context.
		clientcontext.fGotClientInfoUpdate = FALSE;
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for client info to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = servercontext.pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hGotClientInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird client info indications.
		servercontext.fCanGetClientInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! servercontext.fGotClientInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get client info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get client info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(servercontext.hGotClientInfoUpdateEvent);
		servercontext.hGotClientInfoUpdateEvent = NULL;
		servercontext.fGotClientInfoUpdate = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = servercontext.pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = servercontext.pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (servercontext.pDP8Server);
		servercontext.pDP8Server = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (servercontext.pDP8Server != NULL)
	{
		delete (servercontext.pDP8Server);
		servercontext.pDP8Server = NULL;
	} // end if (have server object)

	ClearDoWorkList(&DoWorkList);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(clientcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(servercontext.hGotClientInfoUpdateEvent);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);
	SAFE_CLOSEHANDLE(hConnectComplete);


	return (sr);
} // ParmVClientExec_SetClientInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_GetServerInfo()"
//==================================================================================
// ParmVClientExec_GetServerInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.11 - Client GetServerInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_GetServerInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVCGETSERVERINFOCONTEXT	servercontext;
	PARMVCGETSERVERINFOCONTEXT	clientcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PDPN_PLAYER_INFO			pdpnpi = NULL;
	DPN_PLAYER_INFO				dpnpi;
	DWORD						dwSize;
	DWORD						dwExpectedSize;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hConnectComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&servercontext, sizeof (PARMVCGETSERVERINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVCGETSERVERINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Client->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Client_GetServerInfo(pDP8Client->m_pDP8Client, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting server info with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server 0 info with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerInfo(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting server 0 info with NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info with NULL buffer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSize = 666;

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting server info with NULL buffer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		if (dwSize != 666)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 666)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size was touched)
*/

		dwSize = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwSize, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting server info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwSize, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting server info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		clientcontext.hLog = hLog;

		tr = pDP8Client->DP8C_Initialize(&clientcontext,
										ParmVCGetServerInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwSize, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting server info prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_CLIENT_GETSERVERINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		servercontext.hLog = hLog;

		tr = ParmVCreateServer(hLog,
								ParmVCGetServerInfoDPNMessageHandler,
								&servercontext,
								&dpnad,
								&(servercontext.dpnidServer),
								&pDP8Server,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating server failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create server)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,	NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hConnectComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		clientcontext.fConnectCanComplete = TRUE;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									hConnectComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect completion to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;
		
		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		clientcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! clientcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		clientcontext.fConnectCompleted = FALSE;

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwExpectedSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting server info with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size was not expected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpi, dwSize + BUFFERPADDING_SIZE);

		FillWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Client->DP8C_GetServerInfo(pdpnpi, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting server info failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.

		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		dpnpi.dwPlayerFlags = DPNPLAYER_HOST;

		tr = ParmVComparePlayerInfo(hLog, pdpnpi, &dpnpi);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing player info buffer %x with expected %x failed!",
				2, pdpnpi, &dpnpi);
			THROW_TESTRESULT;
		} // end if (failed comparison)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	ClearDoWorkList(&DoWorkList);
	SAFE_LOCALFREE(pdpnpi);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);
	SAFE_CLOSEHANDLE(hConnectComplete);


	return (sr);
} // ParmVClientExec_GetServerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_GetServerAddress()"
//==================================================================================
// ParmVClientExec_GetServerAddress
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.3.12 - Client GetServerAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_GetServerAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8CLIENT					pDP8Client = NULL;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PDIRECTPLAY8ADDRESS				pDP8ServerAddress = NULL;
	PDIRECTPLAY8ADDRESS				pDP8ServerAddressCompare = NULL;
	PDIRECTPLAY8ADDRESS				pDP8ReturnedAddress = NULL;
	PARMVCGETSERVERADDRESSCONTEXT	servercontext;
	PARMVCGETSERVERADDRESSCONTEXT	clientcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hConnectComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&servercontext, sizeof (PARMVCGETSERVERADDRESSCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVCGETSERVERADDRESSCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Client->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server address with NULL and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Client_GetServerAddress(pDP8Client->m_pDP8Client, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting server address with NULL and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server address)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server address with NULL and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerAddress(NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting server address with NULL and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server address)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server address with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerAddress(&pDP8ReturnedAddress, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting server address with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server address before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerAddress(&pDP8ReturnedAddress, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting server address before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		clientcontext.hLog = hLog;

		tr = pDP8Client->DP8C_Initialize(&clientcontext,
										ParmVCGetServerAddressDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server address prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerAddress(&pDP8ReturnedAddress, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting server address prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_CLIENT_GETSERVERADDRESS;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		servercontext.hLog = hLog;

		tr = ParmVCreateServer(hLog,
								ParmVCGetServerAddressDPNMessageHandler,
								&servercontext,
								&dpnad,
								&(servercontext.dpnidServer),
								&pDP8Server,
								&pDP8ServerAddress);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating server failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create server)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving new server address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8ServerAddress->Duplicate(&pDP8ServerAddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate server address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate address object)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,	NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hConnectComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		clientcontext.fConnectCanComplete = TRUE;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8ServerAddress,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									hConnectComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8ServerAddress->IsEqual(pDP8ServerAddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Host address object was modified (0x%08x != 0x%08x)!",
				2, pDP8ServerAddress, pDP8ServerAddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect completion to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;
		
		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		clientcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! clientcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		clientcontext.fConnectCompleted = FALSE;

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting server address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetServerAddress(&pDP8ReturnedAddress, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting server address failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server address)

		if (pDP8ReturnedAddress == NULL)
		{
			DPTEST_FAIL(hLog, "No address was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no address returned)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Ensuring returned server address is expected");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8ReturnedAddress->IsEqual(pDP8ServerAddress);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Server's address returned doesn't match expected (0x%08x != 0x%08x)!",
				2, pDP8ReturnedAddress, pDP8ServerAddress);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (addresses don't match)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	ClearDoWorkList(&DoWorkList);
	SAFE_RELEASE(pDP8ServerAddress);
	SAFE_RELEASE(pDP8ServerAddressCompare);
	SAFE_RELEASE(pDP8ReturnedAddress);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);
	SAFE_CLOSEHANDLE(hConnectComplete);

	return (sr);
} // ParmVClientExec_GetServerAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVClientExec_GetConnInfo()"
//==================================================================================
// ParmVClientExec_GetConnInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.19 - Client GetConnectionInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVClientExec_GetConnInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DPN_CONNECTION_INFO			dpnci;
	DPN_CONNECTION_INFO			dpnciCompare;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVCGETCONNINFOCONTEXT	servercontext;
	PARMVCGETCONNINFOCONTEXT	clientcontext;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hConnectComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&servercontext, sizeof (PARMVCGETCONNINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVCGETCONNINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Client->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with NULL pointer using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Client_GetConnectionInfo(pDP8Client->m_pDP8Client, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting connection info with NULL pointer using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetConnectionInfo(NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting connection info with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		//dpnci.dwSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting connection info with 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with too-large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof (DPN_CONNECTION_INFO) + 1;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting connection info with too-large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)

*/

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof (DPN_CONNECTION_INFO);

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting connection info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting connection info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		clientcontext.hLog = hLog;

		tr = pDP8Client->DP8C_Initialize(&clientcontext,
										ParmVCGetConnInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting connection info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_CLIENT_GETCONNINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		servercontext.hLog = hLog;

		tr = ParmVCreateServer(hLog,
								ParmVCGetConnInfoDPNMessageHandler,
								&servercontext,
								&dpnad,
								&(servercontext.dpnidServer),
								&pDP8Server,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating server failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create server)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,	NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hConnectComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		clientcontext.fConnectCanComplete = TRUE;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									hConnectComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect completion to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;
		
		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		clientcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! clientcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		clientcontext.fConnectCompleted = FALSE;

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting connection info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

#pragma TODO(vanceo, "Validate returned structure")
		/*
		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	ClearDoWorkList(&DoWorkList);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);
	SAFE_CLOSEHANDLE(hConnectComplete);


	return (sr);
} // ParmVClientExec_GetConnInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCGetSendQInfoDPNMessageHandler()"
//==================================================================================
// ParmVCGetSendQInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVCGetSendQInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVCGETSENDQINFOCONTEXT	pContext = (PPARMVCGETSENDQINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);

			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVCGetSendQInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCSetClientInfoDPNMessageHandler()"
//==================================================================================
// ParmVCSetClientInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVCSetClientInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVCSETCLIENTINFOCONTEXT		pContext = (PPARMVCSETCLIENTINFOCONTEXT) pvContext;
	PDPN_PLAYER_INFO				pdpnpi = NULL;
	DWORD							dwSize = 0;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CLIENT_INFO:
			PDPNMSG_CLIENT_INFO		pClientInfoMsg;


			pClientInfoMsg = (PDPNMSG_CLIENT_INFO) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CLIENT_INFO", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pClientInfoMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidClient = %u/%x", 2, pClientInfoMsg->dpnidClient, pClientInfoMsg->dpnidClient);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pClientInfoMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetClientInfoUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CLIENT_INFO!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the indication.
			if (pClientInfoMsg->dwSize != sizeof (DPNMSG_CLIENT_INFO))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CLIENT_INFO is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pClientInfoMsg->dwSize, sizeof (DPNMSG_CLIENT_INFO));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pClientInfoMsg->dpnidClient != pContext->dpnidClient)
			{
				DPTEST_TRACE(pContext->hLog, "Client ID is not expected (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pClientInfoMsg->dpnidClient, pClientInfoMsg->dpnidClient,
					pContext->dpnidClient, pContext->dpnidClient);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is available)

			if (pClientInfoMsg->pvPlayerContext != &(pContext->dpnidClient))
			{
				DPTEST_TRACE(pContext->hLog, "Player context is not expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pClientInfoMsg->pvPlayerContext, &(pContext->dpnidClient));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player context is wrong)


			// Retrieve the client info.
			hr = pContext->pDP8Server->DP8S_GetClientInfo(pClientInfoMsg->dpnidClient,
														NULL, &dwSize, 0);
			if (hr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_TRACE(pContext->hLog, "Getting client info size didn't return expected error BUFFERTOOSMALL!  DEBUGBREAK()-ing.  0x%08x",
					1, hr);
				DEBUGBREAK();
				goto DONE;
			} // end if (couldn't get client info)

			pdpnpi = (PDPN_PLAYER_INFO) MemAlloc(dwSize);
			if (pdpnpi == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

			hr = pContext->pDP8Server->DP8S_GetClientInfo(pClientInfoMsg->dpnidClient,
														pdpnpi, &dwSize, 0);
			if (hr != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Getting client info failed!  DEBUGBREAK()-ing.  0x%08x",
					1, hr);
				DEBUGBREAK();
				goto DONE;
			} // end if (couldn't get client info)

			// Validate the client info.
			if (pdpnpi->dwSize != sizeof (DPN_PLAYER_INFO))
			{
				DPTEST_TRACE(pContext->hLog, "Player info structure size modified (%u != %u)!  DEBUGBREAK()-ing.",
					2, pdpnpi->dwSize, sizeof (DPN_PLAYER_INFO));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player structure size modified)

			if (pdpnpi->dwInfoFlags != (DPNINFO_NAME | DPNINFO_DATA))
			{
				DPTEST_TRACE(pContext->hLog, "Player info info flags don't match expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pdpnpi->dwInfoFlags, (DPNINFO_NAME | DPNINFO_DATA));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player info info flags unexpected)

			if (pContext->pwszExpectedClientInfoName == NULL)
			{
				if (pdpnpi->pwszName != NULL)
				{
					DPTEST_TRACE(pContext->hLog, "Player info contains an unexpected name string \"%S\"!  DEBUGBREAK()-ing.",
						1, pdpnpi->pwszName);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (name was returned)
			} // end if (no name is expected)
			else
			{
				if ((pdpnpi->pwszName == NULL) ||
					(wcscmp(pdpnpi->pwszName, pContext->pwszExpectedClientInfoName) != 0))
				{
					DPTEST_TRACE(pContext->hLog, "Player info name string doesn't match expected (\"%S\" != \"%S\")!  DEBUGBREAK()-ing.",
						2, pdpnpi->pwszName, pContext->pwszExpectedClientInfoName);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player info name doesn't match)
			} // end else (name is expected)

			if (pContext->pvExpectedClientInfoData == NULL)
			{
				if (pdpnpi->pvData != NULL)
				{
					DPTEST_TRACE(pContext->hLog, "Player info contains unexpected data %x (size = %u)!  DEBUGBREAK()-ing.",
						2, pdpnpi->pvData, pdpnpi->dwDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (name was returned)
			} // end if (no name is expected)
			else
			{
				if ((pdpnpi->pvData == NULL) ||
					(pdpnpi->dwDataSize != pContext->dwExpectedClientInfoDataSize) ||
					(memcmp(pdpnpi->pvData, pContext->pvExpectedClientInfoData, pdpnpi->dwDataSize) != 0))
				{
					DPTEST_TRACE(pContext->hLog, "Player info data doesn't match expected (%u bytes at %x != %u bytes at %x)!  DEBUGBREAK()-ing.",
						4, pdpnpi->pvData,
						pdpnpi->dwDataSize,
						pContext->pvExpectedClientInfoData,
						pContext->dwExpectedClientInfoDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player data doesn't match)
			} // end else (name is expected)

			if (pdpnpi->dwPlayerFlags != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Player info player flags are unexpected (%x)!  DEBUGBREAK()-ing.",
					1, pdpnpi->dwInfoFlags);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player info player flags unexpected)


			// Make sure this isn't a double indication.
			if (pContext->fGotClientInfoUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Client info update was indicated twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotClientInfoUpdate = TRUE;

			if (! SetEvent(pContext->hGotClientInfoUpdateEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set got client info update event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hGotClientInfoUpdateEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	SAFE_LOCALFREE(pdpnpi);

	return (hr);
} // ParmVCSetClientInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCGetServerInfoDPNMessageHandler()"
//==================================================================================
// ParmVCGetServerInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVCGetServerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVCGETSERVERINFOCONTEXT		pContext = (PPARMVCGETSERVERINFOCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = 0x%08x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				hr = E_FAIL;
				goto DONE;
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVCGetServerInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCGetServerAddressDPNMessageHandler()"
//==================================================================================
// ParmVCGetServerAddressDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVCGetServerAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVCGETSERVERADDRESSCONTEXT	pContext = (PPARMVCGETSERVERADDRESSCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;

	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVCGetServerAddressDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCGetConnInfoDPNMessageHandler()"
//==================================================================================
// ParmVCGetConnInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVCGetConnInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVCGETCONNINFOCONTEXT	pContext = (PPARMVCGETCONNINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVCGetConnInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\simplehost.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"
#include "simpletests.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

#undef DEBUG_SECTION
#define DEBUG_SECTION	"DirectPlayExec_SimpleHost()"
//==================================================================================
// DirectPlayExec_SimpleHost
//----------------------------------------------------------------------------------
//
// Description: Implements the DirectPlay simple host test
//
// Arguments:
//     HANDLE hLog                     Handle to the logging subsystem
//     PDP_HOSTINFO pHostInfo          Pointer to info on which machine is host
//     WORD LowPort                    Port that session will be hosted on 
//                                     and which are clients
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT DirectPlayExec_SimpleHost(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8DeviceAddress = NULL;
	DPN_APPLICATION_DESC	dpnad, *pdpnad = NULL;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_BUFFER_DESC			dpnbd;
	DPN_BUFFER_DESC			dpnbdCompare;
	DPN_PLAYER_INFO			dpnpi, *pdpnpiPeer;
	DPN_PLAYER_INFO			dpnpiCompare;
	DPN_CONNECTION_INFO		dpnci;
	DPN_SP_CAPS				dpnspc;
	DPN_CAPS				dpnc;
	DP_DOWORKLIST			DoWorkList;
	SIMPLEHOSTCONTEXT		SimpleHostContext;
	DWORD					dwPort, i, dwNumIDs, dwPeerDataSize, dwChecksum, dwAppDescSize, dwNumMsgs, dwNumBytes;
	PPLAYERCONTEXT			pLocalPlayerContext = NULL, pTempContext = NULL;
	DPNID					SendTarget, OldSendTarget, *pCurrentPlayers = NULL;
	MESSAGEDATA				MessageData, *pPeerData = NULL;
	DPNHANDLE				dpnhSendTo;
	PVOID					pCurrentPlayerContext = NULL;

	ZeroMemory(&SimpleHostContext, sizeof (SIMPLEHOSTCONTEXT));
	InitializeCriticalSection(&(SimpleHostContext.Lock));

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8PeerHost = new CWrapDP8Peer(hLog);
		if (pDP8PeerHost == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8PeerHost->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating first DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (CoCreate failed)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SimpleHostContext.hLog = hLog;
		SimpleHostContext.fVerbose = FALSE;
		SimpleHostContext.LocalPlayerID = 0;
		CREATEEVENT_OR_THROW(SimpleHostContext.hIndicateConnect, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleHostContext.hIndicateRemotePlayer, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleHostContext.hReceiveData, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleHostContext.hAsyncOpCompleted, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleHostContext.hPeerInfoChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleHostContext.hAppDescChanged, NULL, FALSE, FALSE, NULL);

		tr = pDP8PeerHost->DP8P_Initialize(&SimpleHostContext, SimpleHostMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting port for hosted session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
//		dwPort = (DWORD) LowPort;
		dwPort = 2302;

		if(pDP8DeviceAddress->AddComponent(DPNA_KEY_PORT, &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD) != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set port for host", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting initial host information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, HOST_DATA1, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = HOST_PLAYER_NAME1;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		SimpleHostContext.fAsyncOpCanComplete = TRUE;
		SimpleHostContext.fAsyncOpCompleted = FALSE;
		SimpleHostContext.hrAsyncOpExpectedResult = S_OK;
		SimpleHostContext.dpnhAsyncOp = (DPNHANDLE) 0x666;

		tr = pDP8PeerHost->DP8P_SetPeerInfo(&dpnpi, NULL, &(SimpleHostContext.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetPeerInfo completed synchronously", 0);
			SetEvent(SimpleHostContext.hAsyncOpCompleted);
			SimpleHostContext.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimpleHostContext.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimpleHostContext.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for initial set host info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Set up DoWork time parameters
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = TRUE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;
		DoWorkList.apdwPeerCallbackTimes = (DWORD **) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apdwPeerCallbackTimes[0] = &(SimpleHostContext.dwCallbackTime);

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing asychronous operation completions
		SimpleHostContext.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimpleHostContext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set peer info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimpleHostContext.fAsyncOpCompleted = FALSE;
		SimpleHostContext.dpnhAsyncOp = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 1 device");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Allocate a local player context.  Callback will deallocate on destroy player message
		pLocalPlayerContext = NULL;
		LOCALALLOC_OR_THROW(PPLAYERCONTEXT, pLocalPlayerContext, sizeof(PLAYERCONTEXT));

		SimpleHostContext.fVerbose ?
			DPTEST_TRACE(hLog, "Buffer at 0x%08x allocated for local player context.", 1, pLocalPlayerContext) : 0;

		// Allow incoming connections
		SimpleHostContext.fCanAcceptConnect = TRUE;
		SimpleHostContext.fAcceptedConnect = FALSE;
		
		// Allow remote player creations
		SimpleHostContext.dwExpectedRemotePlayers = 1;
		SimpleHostContext.dwCurrentRemotePlayers = 0;

		tr = pDP8PeerHost->DP8P_Host(&dpnad, &pDP8DeviceAddress, 1, NULL, NULL, pLocalPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Hosting with 1 device failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for incoming connection to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hIndicateConnect))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing connections
		SimpleHostContext.fCanAcceptConnect = FALSE;

		// If we didn't get a connection, then we're in trouble
		if(!SimpleHostContext.fAcceptedConnect)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection accepted)
	
		SimpleHostContext.fAcceptedConnect = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for remote player to be created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hIndicateRemotePlayer))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get a remote player creation, then we're in trouble
		if(SimpleHostContext.dwCurrentRemotePlayers != SimpleHostContext.dwExpectedRemotePlayers)
		{
			DPTEST_FAIL(hLog, "Only %u remote players connected, %u were expected!",
				2, SimpleHostContext.dwCurrentRemotePlayers, SimpleHostContext.dwExpectedRemotePlayers);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerate players");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwNumIDs = 0;

		tr = pDP8PeerHost->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming players with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		LOCALALLOC_OR_THROW(PDPNID, pCurrentPlayers, dwNumIDs * sizeof(DPNID));

		tr = pDP8PeerHost->DP8P_EnumPlayersAndGroups(pCurrentPlayers, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players with valid buffer didn't return success!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify player contexts");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Validate each player in the enumeration
		for(i = 0; i < dwNumIDs; ++i)
		{
			for(pTempContext = SimpleHostContext.pPlayerList; pTempContext; pTempContext = pTempContext->pNext)
			{
				if(pTempContext->PlayerID == pCurrentPlayers[i])
					break;
			}

			if(!pTempContext)
			{
				DPTEST_FAIL(hLog, "Enumerated player 0x%08x wasn't found in our local list", 0, pCurrentPlayers[i]);
				THROW_TESTRESULT;
			}

			tr = pDP8PeerHost->DP8P_GetPlayerContext(pCurrentPlayers[i], &pCurrentPlayerContext, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get player context for player 0x%08x",
					1, pCurrentPlayers[i]);
				THROW_TESTRESULT;
			} // end if (couldn't enum players and groups)

			if(pTempContext != pCurrentPlayerContext)
			{
				DPTEST_FAIL(hLog, "Context returned for player 0x%08x was incorrect (0x%08x != 0x%08x)",
					3, pCurrentPlayers[i], pTempContext, pCurrentPlayerContext);
				THROW_TESTRESULT;
			}

			DPTEST_TRACE(hLog, "Successfully retreived player context for player 0x%08x",
				1, pCurrentPlayers[i]);
		}

		DPTEST_TRACE(hLog, "Found all %u players in our local list", 0, dwNumIDs);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Pick a send target");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		EnterCriticalSection(&(SimpleHostContext.Lock));

		// Find the first non-local player and set them as the send target
		SendTarget = 0;
		for(pTempContext = SimpleHostContext.pPlayerList; pTempContext && !SendTarget; pTempContext = pTempContext->pNext)
		{
			if(pTempContext->PlayerID != SimpleHostContext.LocalPlayerID)
				SendTarget = pTempContext->PlayerID;
		}

		DPTEST_TRACE(hLog, "Picked player 0x%08x as the first send target", 0, SendTarget);

		LeaveCriticalSection(&(SimpleHostContext.Lock));

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check send queue before sending");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumMsgs = dwNumBytes = 0x666;

		tr = pDP8PeerHost->DP8P_GetSendQueueInfo(SendTarget, &dwNumMsgs, &dwNumBytes, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get send queue info!", 0);
			THROW_TESTRESULT;
		}

		// Verify that no data is in the send queue
		if(dwNumMsgs || dwNumBytes)
		{
			DPTEST_FAIL(hLog, "Send queue shows backlog, but no data has been sent (%u/%u)",
				2, dwNumMsgs, dwNumBytes);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info with new player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8PeerHost->DP8P_GetConnectionInfo(SendTarget, &dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the service provider");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnspc, sizeof(DPN_SP_CAPS));
		dpnspc.dwSize = sizeof(DPN_SP_CAPS);

		tr = pDP8PeerHost->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "Service provider caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnspc.dwFlags);
		DPTEST_TRACE(hLog, "     Number of threads: %u", 1, dpnspc.dwNumThreads);
		DPTEST_TRACE(hLog, "     Enum count: %u", 1, dpnspc.dwDefaultEnumCount);
		DPTEST_TRACE(hLog, "     Enum retry interval: %u", 1, dpnspc.dwDefaultEnumRetryInterval);
		DPTEST_TRACE(hLog, "     Enum timeout: %u", 1, dpnspc.dwDefaultEnumTimeout);
		DPTEST_TRACE(hLog, "     Max enum payload: %u", 1, dpnspc.dwMaxEnumPayloadSize);
		DPTEST_TRACE(hLog, "     Buffers per thread: %u", 1, dpnspc.dwBuffersPerThread);
		DPTEST_TRACE(hLog, "     System buffer size: %u", 1, dpnspc.dwSystemBufferSize);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of the service provider with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the DirectPlay");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnc, sizeof(DPN_CAPS));
		dpnc.dwSize = sizeof(DPN_CAPS);

		tr = pDP8PeerHost->DP8P_GetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "DirectPlay caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnc.dwFlags);
		DPTEST_TRACE(hLog, "     Connect timeout: %u", 1, dpnc.dwConnectTimeout);
		DPTEST_TRACE(hLog, "     Connect retries: %u", 1, dpnc.dwConnectRetries);
		DPTEST_TRACE(hLog, "     Keepalive timeout: %u", 1, dpnc.dwTimeoutUntilKeepAlive);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of DirectPlay with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_SetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send messages to the newly connected player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;

		SimpleHostContext.dwCurrentReceives = 0;
		SimpleHostContext.dwExpectedReceives = SEND_COUNT;

		// Do SEND_COUNT sends
		for(i = 0; i < SEND_COUNT; ++i)
		{
			// Init these variables so we can see if they were modified
			dpnhSendTo = 0x666;
			CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
						
			tr = pDP8PeerHost->DP8P_SendTo(SendTarget, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_GUARANTEED);
			
			if (tr != DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't send message!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't send message to self)
			
			if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			{
				DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
					2, &dpnbdCompare, &dpnbd);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (buffer desc changed)
			
			if (dpnhSendTo == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (dpnhSendTo == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)			
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for messages from first remote player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get an incoming message, then we're in trouble
		if(SimpleHostContext.dwCurrentReceives != SimpleHostContext.dwExpectedReceives)
		{
			DPTEST_FAIL(hLog, "Only received %u messages, %u were expected!",
				2, SimpleHostContext.dwCurrentReceives, SimpleHostContext.dwExpectedReceives);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		// Stop allowing incoming messages
		SimpleHostContext.dwCurrentReceives = 0;
		SimpleHostContext.dwExpectedReceives = 0;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify peer info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwPeerDataSize = 0;
		pdpnpiPeer = NULL;

		tr = pDP8PeerHost->DP8P_GetPeerInfo(SendTarget, NULL, &dwPeerDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting peer info with NULL buffer on peer-host didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if(dwPeerDataSize < sizeof(DPN_PLAYER_INFO))
		{
				DPTEST_FAIL(hLog, "Buffer allocation is too small for structure", 0);
				SETTHROW_TESTRESULT(E_FAIL);
		}

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiPeer, dwPeerDataSize);
		pdpnpiPeer->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8PeerHost->DP8P_GetPeerInfo(SendTarget, pdpnpiPeer, &dwPeerDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting peer info with valid buffer on peer-host didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiPeer->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiPeer->pwszName, PEER_PLAYER_NAME1))
		{
			DPTEST_FAIL(hLog, "Unexpected peer player name! (\"%S\" != \"%S\")",
				2, pdpnpiPeer->pwszName, PEER_PLAYER_NAME1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiPeer->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received peer data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiPeer->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pPeerData = NULL;
		if(!(pPeerData = (PMESSAGEDATA) pdpnpiPeer->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pPeerData->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the data checksum
		dwChecksum = 0;
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pPeerData->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pPeerData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received peer info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pPeerData->szData, PEER_DATA1))
		{
			DPTEST_FAIL(hLog, "Unexpected peer player data! (\"%s\" != \"%s\")",
				2, pPeerData->szData, PEER_DATA1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiPeer);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Change host information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, HOST_DATA2, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = HOST_PLAYER_NAME2;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		// Be ready for asynchronous completion
		SimpleHostContext.fAsyncOpCanComplete = TRUE;
		SimpleHostContext.fAsyncOpCompleted = FALSE;
		SimpleHostContext.hrAsyncOpExpectedResult = S_OK;
		SimpleHostContext.dpnhAsyncOp = (DPNHANDLE) 0x666;

		// Be ready for peer changing info in response to host info change
		SimpleHostContext.fPeerInfoCanChange = TRUE;
		SimpleHostContext.fPeerInfoChanged = FALSE;

		tr = pDP8PeerHost->DP8P_SetPeerInfo(&dpnpi, NULL, &(SimpleHostContext.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetPeerInfo completed synchronously", 0);
			SetEvent(SimpleHostContext.hAsyncOpCompleted);
			SimpleHostContext.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimpleHostContext.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimpleHostContext.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for set host info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 600004, SimpleHostContext.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing asynchronous operation completions
		SimpleHostContext.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimpleHostContext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set peer info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimpleHostContext.fAsyncOpCompleted = FALSE;
		SimpleHostContext.dpnhAsyncOp = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for peer to change information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hPeerInfoChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing peer info changes
		SimpleHostContext.fPeerInfoCanChange = FALSE;

		// If we didn't get a peer info change, then we're in trouble
		if(!SimpleHostContext.fPeerInfoChanged)
		{
			DPTEST_FAIL(hLog, "Peer info didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (peer info didn't change)
	
		SimpleHostContext.fPeerInfoChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify new peer info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwPeerDataSize = 0;
		pdpnpiPeer = NULL;

		tr = pDP8PeerHost->DP8P_GetPeerInfo(SendTarget, NULL, &dwPeerDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting peer info with NULL buffer on peer-host didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if(dwPeerDataSize < sizeof(DPN_PLAYER_INFO))
		{
				DPTEST_FAIL(hLog, "Buffer allocation is too small for structure", 0);
				SETTHROW_TESTRESULT(E_FAIL);
		}

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiPeer, dwPeerDataSize);
		pdpnpiPeer->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8PeerHost->DP8P_GetPeerInfo(SendTarget, pdpnpiPeer, &dwPeerDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting peer info with valid buffer on peer-host didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiPeer->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiPeer->pwszName, PEER_PLAYER_NAME2))
		{
			DPTEST_FAIL(hLog, "Unexpected peer player name! (\"%S\" != \"%S\")",
				2, pdpnpiPeer->pwszName, PEER_PLAYER_NAME2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiPeer->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received peer data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiPeer->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pPeerData = NULL;
		if(!(pPeerData = (PMESSAGEDATA) pdpnpiPeer->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pPeerData->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pPeerData->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pPeerData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received peer info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pPeerData->szData, PEER_DATA2))
		{
			DPTEST_FAIL(hLog, "Unexpected peer player data! (\"%s\" != \"%s\")",
				2, pPeerData->szData, PEER_DATA2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiPeer);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify current application description");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		dwAppDescSize = 0;
		pdpnad = NULL;

		tr = pDP8PeerHost->DP8P_GetApplicationDesc(NULL, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer on host didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if(dwAppDescSize < sizeof(DPN_APPLICATION_DESC))
		{
				DPTEST_FAIL(hLog, "Buffer allocation is too small for structure", 0);
				SETTHROW_TESTRESULT(E_FAIL);
		}

		LOCALALLOC_OR_THROW(PDPN_APPLICATION_DESC, pdpnad, dwAppDescSize);
		pdpnad->dwSize = sizeof(DPN_APPLICATION_DESC);

		tr = pDP8PeerHost->DP8P_GetApplicationDesc(pdpnad, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc with valid buffer on host didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if(dpnadCompare.guidApplication != pdpnad->guidApplication)
		{
			DPTEST_FAIL(hLog, "Retreived app desc structure has different app GUID!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pdpnad->pwszSessionName)
		{
			DPTEST_FAIL(hLog, "Retreived app desc structure has session name!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pdpnad->guidInstance == GUID_NULL)
		{
			DPTEST_FAIL(hLog, "Retreived app desc structure has NULL instance GUID", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

// BUGBUG - Later, add more data to the original application descriptor...
// then validate that data here

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Change current application description");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, HOST_APP_DATA2, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = APP_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up new app desc structure
		pdpnad->dwSize = sizeof(DPN_APPLICATION_DESC);
		pdpnad->dwMaxPlayers = 3;
		pdpnad->dwFlags = DPNSESSION_REQUIREPASSWORD;
		pdpnad->pwszSessionName = HOST_SESSION_NAME2;
		pdpnad->pwszPassword = HOST_PASSWORD2;
		pdpnad->pvApplicationReservedData = &MessageData;
		pdpnad->dwApplicationReservedDataSize = sizeof(MESSAGEDATA);

		// Be ready for app desc change completion
		SimpleHostContext.fAppDescCanChange = TRUE;
		SimpleHostContext.fAppDescChanged = FALSE;

		// Also, be ready for connection from second player
		SimpleHostContext.fCanAcceptConnect = TRUE;
		SimpleHostContext.fAcceptedConnect = FALSE;

		// Also, be ready for creation of second player
		SimpleHostContext.dwExpectedRemotePlayers = 2;

		tr = pDP8PeerHost->DP8P_SetApplicationDesc(pdpnad, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Setting app desc with valid buffer on host didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		SAFE_LOCALFREE(pdpnad);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc change indication");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hAppDescChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing app desc changes
		SimpleHostContext.fAppDescCanChange = FALSE;

		// If we didn't get an app desc change, then we're in trouble
		if(!SimpleHostContext.fAppDescChanged)
		{
			DPTEST_FAIL(hLog, "App desc didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (app desc didn't change)
	
		SimpleHostContext.fAppDescChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second incoming connection to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hIndicateConnect))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing connections
		SimpleHostContext.fCanAcceptConnect = FALSE;

		// If we didn't get a connection, then we're in trouble
		if(!SimpleHostContext.fAcceptedConnect)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection accepted)
	
		SimpleHostContext.fAcceptedConnect = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second remote player to be created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hIndicateRemotePlayer))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get a remote player creation, then we're in trouble
		if(SimpleHostContext.dwCurrentRemotePlayers != SimpleHostContext.dwExpectedRemotePlayers)
		{
			DPTEST_FAIL(hLog, "Only %u remote players connected, %u were expected!",
				2, SimpleHostContext.dwCurrentRemotePlayers, SimpleHostContext.dwExpectedRemotePlayers);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Pick second player as send target");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		EnterCriticalSection(&(SimpleHostContext.Lock));

		// Keep track of the player ID of the player who connected first
		OldSendTarget = SendTarget;

		// Find the new non-local player and set them as the send target
		SendTarget = 0;
		for(pTempContext = SimpleHostContext.pPlayerList; pTempContext && !SendTarget; pTempContext = pTempContext->pNext)
		{
			// If this isn't the local player and it isn't the old remote player
			if((pTempContext->PlayerID != SimpleHostContext.LocalPlayerID) &&
				(pTempContext->PlayerID != SendTarget))
			{
				// Store the player ID of the player who connected second
				SendTarget = pTempContext->PlayerID;
			}
		}

		DPTEST_TRACE(hLog, "Picked player 0x%08x as the second send target", 0, SendTarget);

		LeaveCriticalSection(&(SimpleHostContext.Lock));

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send messages to the second player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;
		
		SimpleHostContext.dwCurrentReceives = 0;
		SimpleHostContext.dwExpectedReceives = SEND_COUNT;

		// Do SEND_COUNT sends
		for(i = 0; i < SEND_COUNT; ++i)
		{
			// Init these variables so we can see if they were modified
			dpnhSendTo = 0x666;
			CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
						
			tr = pDP8PeerHost->DP8P_SendTo(SendTarget, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_GUARANTEED);
			
			if (tr != DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't send message!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't send message to self)
			
			if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			{
				DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
					2, &dpnbdCompare, &dpnbd);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (buffer desc changed)
			
			if (dpnhSendTo == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (dpnhSendTo == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for messages from second remote player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleHostContext.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
	
		// If we didn't get an incoming message, then we're in trouble
		if(SimpleHostContext.dwCurrentReceives != SimpleHostContext.dwExpectedReceives)
		{
			DPTEST_FAIL(hLog, "Only received %u messages, %u were expected!",
				2, SimpleHostContext.dwCurrentReceives, SimpleHostContext.dwExpectedReceives);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		// Stop allowing incoming messages
		SimpleHostContext.dwCurrentReceives = 0;
		SimpleHostContext.dwExpectedReceives = 0;

/* BUGBUG - take this out and see what happens
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroy first peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, DESTROY_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = TERMINATE_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		DPTEST_TRACE(hLog, "Destroying first peer: 0x%08x", 1, OldSendTarget);

		tr = pDP8PeerHost->DP8P_DestroyPeer(OldSendTarget, &MessageData, sizeof(MESSAGEDATA), 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't destroy peer!", 0);
			THROW_TESTRESULT;
		}

*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminate session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, TERMINATE_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = TERMINATE_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		tr = pDP8PeerHost->DP8P_TerminateSession(&MessageData, sizeof(MESSAGEDATA), 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't destroy peer!", 0);
			THROW_TESTRESULT;
		}

		//
		// Wait for 5 seconds
		//

		Sleep(5000);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		DPTEST_TRACE(hLog, "Releasing host wrapper", 0);
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;

		FINAL_SUCCESS;
	}
	END_TESTCASE

	if (pDP8PeerHost != NULL)
	{
		DPTEST_TRACE(hLog, "Releasing host wrapper", 0);
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	DPTEST_TRACE(hLog, "Cleaning up test variables", 0);
	SAFE_RELEASE(pDP8DeviceAddress);
	SAFE_LOCALFREE(pCurrentPlayers);
	SAFE_LOCALFREE(pdpnpiPeer);
	SAFE_LOCALFREE(pdpnad);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(SimpleHostContext.hIndicateConnect);
	SAFE_CLOSEHANDLE(SimpleHostContext.hIndicateRemotePlayer);
	SAFE_CLOSEHANDLE(SimpleHostContext.hReceiveData);
	SAFE_CLOSEHANDLE(SimpleHostContext.hAsyncOpCompleted);
	SAFE_CLOSEHANDLE(SimpleHostContext.hPeerInfoChanged);
	SAFE_CLOSEHANDLE(SimpleHostContext.hAppDescChanged);
	DeleteCriticalSection(&(SimpleHostContext.Lock));

	return (sr);
} // DirectPlayExec_SimpleHost
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SimpleHostMessageHandler()"
//==================================================================================
// SimpleHostMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT SimpleHostMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT				hr = DPN_OK;
	PSIMPLEHOSTCONTEXT	pContext = (PSIMPLEHOSTCONTEXT) pvContext;
	BOOL				fLocalPlayer = TRUE;
	DWORD				dwStartTime = 0, dwEndTime = 0;

	dwStartTime = GetTickCount();

	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;
			PPLAYERCONTEXT			pNewPlayerContext;

			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pCreatePlayerMsg->pvPlayerContext);
			}

			// If this is a local player, then take the buffer that we allocated when we hosted
			// or connected
			if(pCreatePlayerMsg->pvPlayerContext)
			{
				fLocalPlayer = TRUE;

				pContext->LocalPlayerID = pCreatePlayerMsg->dpnidPlayer;
				pNewPlayerContext = ((PPLAYERCONTEXT) pCreatePlayerMsg->pvPlayerContext);
			}
			// Otherwise this is a remote player.  Create a new buffer.
			else
			{
				fLocalPlayer = FALSE;

				pNewPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
				if(!pNewPlayerContext)
				{
					DPTEST_TRACE(pContext->hLog, "Not enough memory to allocate player context!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}

				pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Buffer at 0x%08x allocated for remote player context.", 1, pNewPlayerContext) : 0;

				if(pContext->dwCurrentRemotePlayers >= pContext->dwExpectedRemotePlayers)
				{
					DPTEST_TRACE(pContext->hLog, "Unexpected remote player creation!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					break;
				}
				
				++(pContext->dwCurrentRemotePlayers);

				pCreatePlayerMsg->pvPlayerContext = pNewPlayerContext;
			}

			// Initialize the player information
			pNewPlayerContext->fLocalPlayer = fLocalPlayer;
			pNewPlayerContext->PlayerID = pCreatePlayerMsg->dpnidPlayer;
			pNewPlayerContext->TotalBytesReceived = 0;
			pNewPlayerContext->TotalMessagesReceived = 0;

			// BUGBUG - figure out why this player will be destroyed.  Need cases for the following
			// DPNDESTROYPLAYERREASON_NORMAL  - The player is being deleted for normal reasons. 
			// DPNDESTROYPLAYERREASON_CONNECTIONLOST - The connection was lost. 
			// DPNDESTROYPLAYERREASON_SESSIONTERMINATED - The session was terminated. 
			// DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER - The host called DestroyPeer
			pNewPlayerContext->dwExpectedDestroyReason = 0;

			// Add info on this player to our global player list
			EnterCriticalSection(&(pContext->Lock));

			pNewPlayerContext->pPrev = NULL;
			if(pContext->pPlayerList)
				pContext->pPlayerList->pPrev = pNewPlayerContext->pNext;
			pNewPlayerContext->pNext = pContext->pPlayerList;
			pContext->pPlayerList = pNewPlayerContext;

			++pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));
			
			if(!fLocalPlayer)
			{
				if(pContext->dwCurrentRemotePlayers == pContext->dwExpectedRemotePlayers)
				{					
					// Signal the main thread that a player was created
					if (! SetEvent(pContext->hIndicateRemotePlayer))
					{
						hr = GetLastError();
						DPTEST_TRACE(pContext->hLog, "Couldn't set remote player indication event (%x)!  DEBUGBREAK()-ing.",
							1, pContext->hIndicateRemotePlayer);
						
						DEBUGBREAK();
						
						if (hr == S_OK)
							hr = E_FAIL;
						
						break;
					} // end if (couldn't set event)
				}
			}

		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;
			PPLAYERCONTEXT			pPlayerContext;
			CHAR					szReason[64];
			
			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pDestroyPlayerMsg->pvPlayerContext);
				
				switch(pDestroyPlayerMsg->dwReason)
				{
				case DPNDESTROYPLAYERREASON_NORMAL:
					strcpy(szReason, "NORMAL");
					break;
				case DPNDESTROYPLAYERREASON_CONNECTIONLOST:
					strcpy(szReason, "CONNECTIONLOST");
					break;
				case DPNDESTROYPLAYERREASON_SESSIONTERMINATED:
					strcpy(szReason, "SESSIONTERMINATED");
					break;
				case DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER:
					strcpy(szReason, "HOSTDESTROYEDPLAYER");
					break;
				default:
					DPTEST_TRACE(pContext->hLog, "Unknown player destroy reason! DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					break;
				}
				
				DPTEST_TRACE(pContext->hLog, "     dwReason = %s", 1, szReason);
				
			}
			
			pPlayerContext = (PPLAYERCONTEXT) pDestroyPlayerMsg->pvPlayerContext;

			if(!pPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "No player context received!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			// If this isn't the local player, then decrement the current number of remote players
			if(!pPlayerContext->fLocalPlayer)
			{
				if(!pContext->dwCurrentRemotePlayers)
				{
					DPTEST_TRACE(pContext->hLog, "Unexpected remote player destruction!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					break;
				}

				--(pContext->dwCurrentRemotePlayers);
			}

			// If we knew how the player was supposed to be destroyed
			if(pPlayerContext->dwExpectedDestroyReason &&
				(pPlayerContext->dwExpectedDestroyReason != pDestroyPlayerMsg->dwReason))
			{
				// Then verify that the way they were destroyed
				DPTEST_TRACE(pContext->hLog, "Player destroyed for unexpected reason! DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			// Remove this player from our global player list
			EnterCriticalSection(&(pContext->Lock));

			if(pPlayerContext->pNext)
				pPlayerContext->pNext->pPrev = pPlayerContext->pPrev;
			if(pPlayerContext->pPrev)
				pPlayerContext->pPrev->pNext = pPlayerContext->pNext;
			else
				pContext->pPlayerList = pPlayerContext->pNext;

			--pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));

			pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Freeing player context buffer: 0x%08x", 1, pPlayerContext) : 0;

			// Release the player context
			MemFree(pPlayerContext);

		break;
		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT pIndicateConnectMsg;
			PMESSAGEDATA pConnectData, pConnectReplyData;
			CHAR *pszTempURL;
			HRESULT hrTemp;
			DWORD dwTempURLSize, i;
			DWORD dwChecksum;

			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pIndicateConnectMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     pvUserConnectData = 0x%08x", 1, pIndicateConnectMsg->pvUserConnectData);
				DPTEST_TRACE(pContext->hLog, "     dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			}
			
			// Parse any connect data if present
			if(!(pConnectData = (PMESSAGEDATA) pIndicateConnectMsg->pvUserConnectData))
			{
				pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "No incoming connection data was provided. Reject connection.", 0) : 0;
				hr = E_FAIL;
				break;
			}
			else
			{
				
				dwChecksum = 0;
				
				// Make sure we received enough data
				if(pIndicateConnectMsg->dwUserConnectDataSize < sizeof(MESSAGEDATA))
				{
					DPTEST_TRACE(pContext->hLog, "Received connect data was too small!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				// If the message is of valid size
				else
				{
					if(pConnectData->dwMessageType != CONNECT_DATA)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data of invalid type!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}
					
					// Calculate the checksum from the message
					for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
						dwChecksum += pConnectData->szData[i];
					
					// Compare it to the checksum listed in the message
					if(dwChecksum != pConnectData->dwChecksum)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data failed checksum!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}
					
					pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Connect data was : \"%s\"", 1, pConnectData->szData) : 0;
					
					pIndicateConnectMsg->dwReplyDataSize = sizeof(MESSAGEDATA);
					pConnectReplyData = (PMESSAGEDATA) MemAlloc(pIndicateConnectMsg->dwReplyDataSize);

					pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Buffer at 0x%08x allocated for connect reply data.", 1, pConnectReplyData) : 0;

					// Copy the player buffer
					strncpy(pConnectReplyData->szData, CONNECT_REPLY_MESSAGE, MAX_MESSAGEDATA_DATA);
					pConnectReplyData->szData[MAX_MESSAGEDATA_DATA - 1] = 0;
					pConnectReplyData->dwMessageType = CONNECT_REPLY_DATA;
					pConnectReplyData->dwChecksum = 0;
					
					// Calculate the checksum
					for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
						pConnectReplyData->dwChecksum += pConnectReplyData->szData[i];
					
					pIndicateConnectMsg->pvReplyData = pConnectReplyData;
				}
			}

			// BUGBUG - set some reply data and verify that it is returned later with the provided context
//			    PVOID     pvReplyContext;
			
			if(pContext->fVerbose)
			{
				
				// BUGBUG - try setting player context value indirectly through this value
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pIndicateConnectMsg->pvPlayerContext);
				
				//
				// Get the DPlay URL of the incoming connection address and display it
				//
				
				// Find out how big the URL is
				dwTempURLSize = 0;
				hrTemp = pIndicateConnectMsg->pAddressPlayer->GetURLA(NULL, &dwTempURLSize);
				if(hrTemp != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't query size of incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Allocate a buffer for it
				pszTempURL = (CHAR *) MemAlloc(dwTempURLSize);
				if(!pszTempURL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't create URL buffer!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Retrieve the URL
				hrTemp = pIndicateConnectMsg->pAddressPlayer->GetURLA(pszTempURL, &dwTempURLSize);
				if(hrTemp != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't retrieve incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Log the URL
				DPTEST_TRACE(pContext->hLog, "     pAddressPlayer = %s", 1, pszTempURL);
				
				// Release the URL
				MemFree(pszTempURL);
				
				//
				// Get the DPlay URL of the incoming connection address and display it
				//
				
				// Find out how big the URL is
				dwTempURLSize = 0;
				hrTemp = pIndicateConnectMsg->pAddressDevice->GetURLA(NULL, &dwTempURLSize);
				if(hrTemp != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't query size of incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Allocate a buffer for it
				pszTempURL = (CHAR *) MemAlloc(dwTempURLSize);
				if(!pszTempURL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't create URL buffer!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Retrieve the URL
				hrTemp = pIndicateConnectMsg->pAddressDevice->GetURLA(pszTempURL, &dwTempURLSize);
				if(hrTemp != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't retrieve incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Log the URL
				DPTEST_TRACE(pContext->hLog, "     pAddressDevice = %s", 1, pszTempURL);
				
				// Release the URL
				MemFree(pszTempURL);
			}

			if(!pContext->fCanAcceptConnect)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected connection indication!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fAcceptedConnect = TRUE;
			
			// Signal the main thread that a connection was indicated
			if (! SetEvent(pContext->hIndicateConnect))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set connection indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hIndicateConnect);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE pReceiveMsg;

			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReceiveMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pReceiveMsg->pvPlayerContext);
				// BUGBUG - create a common message format that contains the sender information
				// so that we can verify that this data is accurate
				DPTEST_TRACE(pContext->hLog, "     pReceiveData = 0x%08x", 1, pReceiveMsg->pReceiveData);
				DPTEST_TRACE(pContext->hLog, "     dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
				// BUGBUG - try holding onto this buffer and returning it on subsequent calls to receive
				// Use the buffer handle to return it later.  Maybe store the last buffer handle received
				// in the players context.
				DPTEST_TRACE(pContext->hLog, "     hBufferHandle = 0x%08x", 1, pReceiveMsg->hBufferHandle);
			}
			
			if(pContext->dwCurrentReceives >= pContext->dwExpectedReceives)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected incoming message!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}
			
			++(pContext->dwCurrentReceives);
			
			if(pContext->dwCurrentReceives == pContext->dwExpectedReceives)
			{
				// Signal the main thread that data was received
				if (! SetEvent(pContext->hReceiveData))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hReceiveData);
					
					DEBUGBREAK();
					
					if (hr == S_OK)
						hr = E_FAIL;
					
					break;
				} // end if (couldn't set event)
			}

			break;
		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE pSendCompleteMsg;

			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pSendCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of a send
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = 0x%08x", 1, pSendCompleteMsg->hAsyncOp);
				// BUGBUG - again check with the context and verify that this is the context that we
				// supplied with a call to send
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pSendCompleteMsg->pvUserContext);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pSendCompleteMsg->hResultCode);
				// BUGBUG - do lots of sends and see if this increases, what about guaranteed?
				DPTEST_TRACE(pContext->hLog, "     dwSendTime = %u ms", 1, pSendCompleteMsg->dwSendTime);
			}

			break;
		case DPN_MSGID_APPLICATION_DESC:
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_APPLICATION_DESC", 0);
			}

			if(!pContext->fAppDescCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected app desc change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fAppDescChanged = TRUE;
			
			// Signal the main thread that the app desc changed
			if (! SetEvent(pContext->hAppDescChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set app desc change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAppDescChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;

			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of an operation
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);
			}
			
			if(!pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected asynchronous operation completion!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			if(pContext->dpnhAsyncOp != pAsyncOpCompleteMsg->hAsyncOp)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completion has unexpected handle (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->dpnhAsyncOp, pAsyncOpCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			}

			if(pContext->hrAsyncOpExpectedResult != pAsyncOpCompleteMsg->hResultCode)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completed with unexpected result (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->hrAsyncOpExpectedResult, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			}

			pContext->fAsyncOpCompleted = TRUE;
			
			// Signal the main thread that an asynchronous operation completed
			if (! SetEvent(pContext->hAsyncOpCompleted))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompleted);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_PEER_INFO:
			PDPNMSG_PEER_INFO pPeerInfoMsg;

			pPeerInfoMsg = (PDPNMSG_PEER_INFO) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_PEER_INFO", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pPeerInfoMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPeer = %u/%x", 2, pPeerInfoMsg->dpnidPeer, pPeerInfoMsg->dpnidPeer);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pPeerInfoMsg->pvPlayerContext);
			}
			
			if(pContext->LocalPlayerID == pPeerInfoMsg->dpnidPeer)
			{
				DPTEST_TRACE(pContext->hLog, "Local players info changed", 0);
				break;
			}

			if(!pContext->fPeerInfoCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected peer info change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fPeerInfoChanged = TRUE;
			
			// Signal the main thread that the peer info changed
			if (! SetEvent(pContext->hPeerInfoChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set peer info change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hPeerInfoChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;

			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pTerminateSessionMsg->dwSize);
				// BUGBUG - check the context and verify the difference between the host calling\
				// close and the host calling terminate session.
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pTerminateSessionMsg->hResultCode);
				// BUGBUG - check with the context and verify whether or not data should have been provided
				DPTEST_TRACE(pContext->hLog, "     pvTerminateData = 0x%08x", 1, pTerminateSessionMsg->pvTerminateData);
				DPTEST_TRACE(pContext->hLog, "     dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);
			}
			
			break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER pReturnBufferMsg;

			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RETURN_BUFFER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReturnBufferMsg->dwSize);
				// BUGBUG - in enum cases, this could be an error, otherwise, should be success
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
				DPTEST_TRACE(pContext->hLog, "     pvBuffer = 0x%08x", 1, pReturnBufferMsg->pvBuffer);
				// BUGBUG - this should probably only be set in concurrent enumeration cases
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pReturnBufferMsg->pvUserContext);
			}
			
			if(!pReturnBufferMsg->pvBuffer)
			{
				DPTEST_TRACE(pContext->hLog, "Return buffer message with invalid buffer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			MemFree(pReturnBufferMsg->pvBuffer);

			break;
		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	dwEndTime = GetTickCount();

	pContext->dwCallbackTime += (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

	return (hr);
} // SimpleHostMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\sends.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Defines
//==================================================================================
#define THROTTLECHECK_CHECKPOINTPERIOD		1000
#define THROTTLECHECK_NUMHITSTHRESHOLD		25

#define QUEUEEMPTY_CHECKPOINTPERIOD			4000


#define SENDFILLPATTERN						0x0711F00D
#define PENDINGSENDS_CS_DESTROYPLAYER_ID	(~SENDFILLPATTERN)





//==================================================================================
// Structures
//==================================================================================
typedef struct tagSENDSSIMPLECONTEXT : public BASESESSIONCREATECONTEXT
{
	HANDLE				hLog;  // handle to event logging subsystem
	BOOL				fCancelling; // whether we're cancelling sends or not
	bool*				pabSendsCompleted; // array for completions of each message
	DWORD				dwNumSendsNotCompleted; // number of sends not yet completed
	DWORD				dwReceives; // number of packets received
	HANDLE				hAllSendsCompletedEvent; // event to set when all sends have completed
} SENDSSIMPLECONTEXT, * PSENDSSIMPLECONTEXT;

typedef struct tagSENDSPENDINGCONTEXT : public BASESESSIONCREATECONTEXT
{
	HANDLE				hLog; // handle to event logging subsystem
	DPNID*				padpnidTesters; // array of player IDs, in tester number order
	BOOL				fClosingPlayer; // whether we're a leaving/dropping player or not
	//BOOL				fSelfIndicate; // TRUE if we expect our player ID to be destroyed, too
	int					iNumClosers; // number of closing players
	volatile BOOL		fPlayersLeftOrDropped; // TRUE if all the expected players have left or dropped actually have
	volatile BOOL		fGotTerminateSession; // TRUE if we've gotten the terminate session
	BOOL*				pafTesterIndicated; // pointer to array to use to remember whether an indication has already arrived for the testers
	CRITICAL_SECTION	csStatsLock; // lock protecting the statistics
	DWORD				dwMsgSize; // expected message size for incoming messages
	DWORD				dwNumRelevantSends; // number of sends to/from leaving/dropping player that have been submitted
	DWORD				dwNumIrrelevantSends; // number of sends not to/from leaving/dropping player that have been submitted
	DWORD				dwNumRelevantSendsCompletedSuccess; // number of sends to/from leaving/dropping player that have completed successfully
	DWORD				dwNumRelevantSendsCompletedFailure; // number of sends to/from leaving/dropping player that have completed with a failure
	DWORD				dwNumIrrelevantSendsCompleted; // number of sends not to/from leaving/dropping player that have completed
} SENDSPENDINGCONTEXT, * PSENDSPENDINGCONTEXT;


//==================================================================================
// Prototypes
//==================================================================================
HRESULT SendsSimpleDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
//HRESULT SendsPendingDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);


#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendsExec_SimplePeer()"
//==================================================================================
// SendsExec_SimplePeer
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.1 - Simple peer-to-peer sends test
//
// Arguments:
//	HANDLE				hLog			Handle to logging subsystem
//	DP_SENDTESTPARAM	*pSendTestParam	Pointer to params for this test
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT SendsExec_SimplePeer(HANDLE hLog, DP_SENDTESTPARAM *pSendTestParam)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	HRESULT						temphr;
	SENDSSIMPLECONTEXT			context;
	DPN_APPLICATION_DESC		dpnad;
	PWRAPDP8PEER				pDP8Peer = NULL;
	DPN_BUFFER_DESC				dpnbd;
	DPNID						*padpnidTesters = NULL;
//	BOOL						fEatingCPU = FALSE;
	DWORD						dwTemp;
	DWORD						dwCurrentTarget;
	DWORD						dwNextCancel;
	DWORD						dwStartTime;
	DWORD						dwMessagesOutstanding = 0;
	DWORD						dwSuccessfulCancels = 0;
	DPNHANDLE					dpnhAsyncHandle;

	ZeroMemory(&context, sizeof (SENDSSIMPLECONTEXT));
	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));

	context.hLog = hLog;

	BEGIN_TESTCASE
	{
		// Setup completion items if we're not sending synchronously
		if (! (pSendTestParam->dwFlags & DPNSEND_SYNC))
		{
			if (pSendTestParam->dwCancelInterval != 0)
				context.fCancelling = TRUE;

			context.dwNumSendsNotCompleted = pSendTestParam->dwNumMsgs;

			LOCALALLOC_OR_THROW(bool*, context.pabSendsCompleted,
								(pSendTestParam->dwNumMsgs * sizeof (bool)));

			context.hAllSendsCompletedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (context.hAllSendsCompletedEvent == NULL)
			{
				sr = GetLastError();
				DPTEST_FAIL(hLog,  "Couldn't create all sends completed event!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't create event)
		} // end if (asynchronous sends)




		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		if(pSendTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating session host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid peer and an array of tester DPNID's
			if(!CreateHostAndWaitForPlayers(hLog, &pDP8Peer, &context, &dpnad, SendsSimpleDPNMessageHandler,
				&padpnidTesters, pSendTestParam->dwNumMachines, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't create host and receive correct number of players", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to session host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid peer and an array of tester DPNID's
			if(!ConnectNonHostAndWaitForPlayers(hLog, &pDP8Peer, &context, pSendTestParam->dwHostAddr, &dpnad, SendsSimpleDPNMessageHandler,
				&padpnidTesters, pSendTestParam->dwNumMachines, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't create host and receive correct number of players", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}

		dpnbd.dwBufferSize = pSendTestParam->dwMsgSize;
		LOCALALLOC_OR_THROW(PBYTE, dpnbd.pBufferData, dpnbd.dwBufferSize);

		FillWithDWord(dpnbd.pBufferData, dpnbd.dwBufferSize, SENDFILLPATTERN);

// BUGBUG - may add CPU eating later
//		if (pSendTestParam->dwPercentEatCPU != 0)
//		{
//			sr = StartEatingCPUTime(0, pSendTestParam->dwPercentEatCPU);
//			if (sr != S_OK)
//			{
//				DPTEST_FAIL(hLog, "Couldn't start eating CPU time!", 0);
//				THROW_SYSTEMRESULT;
//			} // end if (failed starting to eat CPU time)
//
//			fEatingCPU = TRUE;
//		} // end if (should eat CPU time)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready to begin");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pSendTestParam->hNetsyncObject, SEND_BEGIN_EVENT, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, SEND_BEGIN_EVENT);
			SETTHROW_TESTRESULT(E_ABORT);
		}
		

		DPTEST_TRACE(hLog,  "Sending %u %u byte messages every %u ms.",
			3, pSendTestParam->dwNumMsgs, pSendTestParam->dwMsgSize, pSendTestParam->dwInterval);

		dwCurrentTarget = 0;

		// Remember when we're next cancelling sends.
		dwNextCancel = pSendTestParam->dwCancelInterval;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Begin sends");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwStartTime = GetTickCount();

		for(dwTemp = 0; dwTemp < pSendTestParam->dwNumMsgs; dwTemp++)
		{
			// Find the next person to send to (this will not actually be used if
			// sending to All Players group).
			dwCurrentTarget++;
			if (dwCurrentTarget >= pSendTestParam->dwNumMachines)
				dwCurrentTarget = 0;

#pragma TODO(vanceo, "Handle NOLOOPBACK yet sending to self")


			if (! (pSendTestParam->dwFlags & DPNSEND_SYNC))
				InterlockedIncrement((LPLONG) (&dwMessagesOutstanding));

			// Use the API directly so we don't have tons of our wrapper spew.
			tr = pDP8Peer->m_pDP8Peer->SendTo(((pSendTestParam->fSendToAllPlayersGroup) ? DPNID_ALL_PLAYERS_GROUP : padpnidTesters[dwCurrentTarget]),
												&dpnbd,
												1,
												pSendTestParam->dwTimeout,
												(PVOID) ((DWORD_PTR) dwTemp),
												&dpnhAsyncHandle,
												pSendTestParam->dwFlags);
			if (pSendTestParam->dwFlags & DPNSEND_SYNC)
			{
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog,  "SendTo failed!", 0);
					THROW_TESTRESULT;
				} // end if (sendto failed)
			} // end if (synchronous send)
			else
			{
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPTEST_FAIL(hLog,  "SendTo didn't return expected PENDING success code!", 0);
					THROW_TESTRESULT;
				} // end if (didn't get pending error)

			
				// If we're supposed to cancel things, and it's time to do so, try.
				if (pSendTestParam->dwCancelInterval != 0)
				{
					dwNextCancel--;
					if (dwNextCancel == 0)
					{
						// Reset the cancel interval counter.
						dwNextCancel = pSendTestParam->dwCancelInterval;

						tr = pDP8Peer->DP8P_CancelAsyncOperation(((pSendTestParam->dwCancelFlags == 0) ? dpnhAsyncHandle : NULL),
																pSendTestParam->dwCancelFlags);
						if (tr != DPN_OK)
						{
							if (pSendTestParam->dwCancelFlags == 0)
							{
								if ((tr != DPNERR_CANNOTCANCEL) && (tr != DPNERR_INVALIDHANDLE))
								{
									DPTEST_FAIL(hLog,  "Cancelling send %x failed!",
										1, dpnhAsyncHandle);
									THROW_TESTRESULT;
								} // end if (not expected cannotcancel or invalidhandler errors)
								

								DPTEST_TRACE(hLog,  "Couldn't cancel async send %x, assuming it is completing/completed.  0x%08x",
									2, dpnhAsyncHandle, (HRESULT) tr);
							} // end if (cancelling individual send)
							else
							{
								if (tr != DPNERR_CANNOTCANCEL)
								{
									DPTEST_FAIL(hLog,  "CancelAsyncOperation (flags %x) failed!",
										1, pSendTestParam->dwCancelFlags);
									THROW_TESTRESULT;
								} // end if (not expected cannotcancel error)
								

								DPTEST_TRACE(hLog,  "Couldn't cancel async operations with flags %x, assuming the sends are completing/completed.  0x%08x",
									2, pSendTestParam->dwCancelFlags, (HRESULT) tr);
							} // end else (cancelling mutiple operations)
						} // end if (cancel failed)
						else
						{
							dwSuccessfulCancels++;

							if (pSendTestParam->dwCancelFlags == 0)
							{
								DPTEST_TRACE(hLog, "Cancelling async send %x succeeded.",
									1, dpnhAsyncHandle);
							} // end if (cancelling individual send)
							else
							{
								DPTEST_TRACE(hLog, "CancelAsyncOperation (flags %x) succeeded.",
									1, pSendTestParam->dwCancelFlags);
							} // end else (cancelling mutiple operations)
						} // end else (cancel succeeded)
					} // end if (time to cancel)
				} // end if (cancelling sends)
			} // end else (asynchronous send)


			// Sleep for the requested interval.  We don't use TNSLEEP because that
			// puts spew out and we sort of want to send as fast as possible.
			Sleep(pSendTestParam->dwInterval);
		} // end for (each send)
		
		
		DPTEST_TRACE(hLog, "Spent %u ms sending %u %u byte messages every %u ms, %u successful cancel attempts.",
			5, (GetTickCount() - dwStartTime), pSendTestParam->dwNumMsgs, pSendTestParam->dwMsgSize,
			pSendTestParam->dwInterval, dwSuccessfulCancels);


		if(! (pSendTestParam->dwFlags & DPNSEND_SYNC))
		{
			dwStartTime = GetTickCount();

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for all asynchronous sends to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			if(WaitForSingleObject(context.hAllSendsCompletedEvent, 120000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Completion of all sends wasn't indicated within 2 minutes", 0);
				
				THROW_SYSTEMRESULT;
			}

			DPTEST_TRACE(hLog, "Spent %u ms waiting for all sends to complete.",
				1, (GetTickCount() - dwStartTime));

		} // end if (asynchronous sends)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready to close");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pSendTestParam->hNetsyncObject, SEND_END_EVENT, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, SEND_END_EVENT);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		DPTEST_TRACE(hLog, "Received %u messages during test.", 1, context.dwReceives);

// BUGBUG - may add CPU eating later
//		if (fEatingCPU)
//		{
//			sr = StopEatingCPUTime();
//			if (sr != S_OK)
//			{
//				DPTEST_FAIL(hLog,  "Couldn't stop eating CPU time!", 0);
//				THROW_SYSTEMRESULT;
//			} // end if (couldn't stop eating CPU time)
//
//			fEatingCPU = FALSE;
//		} // end if (ate CPU time)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Releaseing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		DPTEST_TRACE(hLog, "Releasing peer wrapper", 0);
		delete (pDP8Peer);
		pDP8Peer = NULL;

		SAFE_LOCALFREE(padpnidTesters);

		FINAL_SUCCESS;
	}
	END_TESTCASE


//	// If we're still eating CPU time, be sure to stop it.
//	if (fEatingCPU)
//	{
//		temphr = StopEatingCPUTime();
//		if (temphr != S_OK)
//		{
//			DPTEST_FAIL(hLog,  "Couldn't stop eating CPU time!", 0);
//			OVERWRITE_SR_IF_OK(temphr);
//		} // end if (couldn't stop eating CPU time)
//
//		fEatingCPU = FALSE;
//	} // end if (ate CPU time)

	if (pDP8Peer != NULL)
	{
		temphr = pDP8Peer->DP8P_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing peer interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing peer interface failed)

		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(padpnidTesters);
	SAFE_CLOSEHANDLE(context.hbsccAllPlayersCreated);
	SAFE_CLOSEHANDLE(context.hAllSendsCompletedEvent);
	SAFE_LOCALFREE(context.pabSendsCompleted);
	SAFE_LOCALFREE(dpnbd.pBufferData);

	return (sr);
} // SendsExec_SimplePeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendsExec_SimpleCS()"
//==================================================================================
// SendsExec_SimpleCS
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.2 - Simple client/server sends test
//
// Arguments:
//	HANDLE				hLog			Handle to logging subsystem
//	DP_SENDTESTPARAM	*pSendTestParam	Pointer to params for this test
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT SendsExec_SimpleCS(HANDLE hLog, DP_SENDTESTPARAM *pSendTestParam)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	SENDSSIMPLECONTEXT				context;
	DPN_APPLICATION_DESC			dpnad;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PWRAPDP8CLIENT					pDP8Client = NULL;
	DPNID*							padpnidTesters = NULL;
	DPN_BUFFER_DESC					dpnbd;
//	BOOL							fEatingCPU = FALSE;
	DWORD							dwTemp;
	DWORD							dwCurrentTarget;
	DWORD							dwNextCancel;
	DWORD							dwStartTime;
	DWORD							dwMessagesOutstanding = 0;
	DWORD							dwSuccessfulCancels = 0;
	DPNHANDLE						dpnhAsyncHandle;


	ZeroMemory(&context, sizeof (SENDSSIMPLECONTEXT));
	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));

	context.hLog = hLog;

	BEGIN_TESTCASE
	{

		// Setup completion items if we're not sending synchronously
		if (! (pSendTestParam->dwFlags & DPNSEND_SYNC))
		{
			if (pSendTestParam->dwCancelInterval != 0)
				context.fCancelling = TRUE;

			context.dwNumSendsNotCompleted = pSendTestParam->dwNumMsgs;

			LOCALALLOC_OR_THROW(bool*, context.pabSendsCompleted,
								(pSendTestParam->dwNumMsgs * sizeof (bool)));

			context.hAllSendsCompletedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (context.hAllSendsCompletedEvent == NULL)
			{
				sr = GetLastError();
				DPTEST_FAIL(hLog,  "Couldn't create all sends completed event!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't create event)
		} // end if (asynchronous sends)

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		if(pSendTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating session server");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid server and an array of tester DPNID's
			if(!CreateServerAndWaitForPlayers(hLog, &pDP8Server, &context, &dpnad, SendsSimpleDPNMessageHandler,
				&padpnidTesters, pSendTestParam->dwNumMachines, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't create server and receive correct number of players", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to session server");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid client
			if(!ConnectClient(hLog, &pDP8Client, &context, pSendTestParam->dwHostAddr, &dpnad,
				SendsSimpleDPNMessageHandler, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't connect client", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}

		dpnbd.dwBufferSize = pSendTestParam->dwMsgSize;
		LOCALALLOC_OR_THROW(PBYTE, dpnbd.pBufferData, dpnbd.dwBufferSize);

		FillWithDWord(dpnbd.pBufferData, dpnbd.dwBufferSize, SENDFILLPATTERN);

// BUGBUG - may add CPU eating later
//		if (pSendTestParam->dwPercentEatCPU != 0)
//		{
//			sr = StartEatingCPUTime(0, pSendTestParam->dwPercentEatCPU);
//			if (sr != S_OK)
//			{
//				DPTEST_FAIL(hLog,  "Couldn't start eating CPU time!", 0);
//				THROW_SYSTEMRESULT;
//			} // end if (failed starting to eat CPU time)
//
//			fEatingCPU = TRUE;
//		} // end if (should eat CPU time)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready to begin");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pSendTestParam->hNetsyncObject, SEND_BEGIN_EVENT, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, SEND_BEGIN_EVENT);
			SETTHROW_TESTRESULT(E_ABORT);
		}
		
		DPTEST_TRACE(hLog,  "Sending %u %u byte messages every %u ms.",
			3, pSendTestParam->dwNumMsgs, pSendTestParam->dwMsgSize, pSendTestParam->dwInterval);

		dwCurrentTarget = 0;

		// Remember when we're next cancelling sends.
		dwNextCancel = pSendTestParam->dwCancelInterval;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Begin sends");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwStartTime = GetTickCount();

		for(dwTemp = 0; dwTemp < pSendTestParam->dwNumMsgs; dwTemp++)
		{

			// Find the next person to send to (this will not actually be used if
			// not tester 0 or sending to All Players group).
			dwCurrentTarget++;
			if (dwCurrentTarget >= pSendTestParam->dwNumMachines)
				dwCurrentTarget = 0;

#pragma TODO(vanceo, "Handle NOLOOPBACK yet sending to self")


			if (! (pSendTestParam->dwFlags & DPNSEND_SYNC))
				InterlockedIncrement((LPLONG) (&dwMessagesOutstanding));

			// Use the API directly so we don't have tons of our wrapper spew.
			if (pSendTestParam->fHostTest == 0)
			{
				tr = pDP8Server->m_pDP8Server->SendTo(((pSendTestParam->fSendToAllPlayersGroup) ? DPNID_ALL_PLAYERS_GROUP : padpnidTesters[dwCurrentTarget]),
													&dpnbd,
													1,
													pSendTestParam->dwTimeout,
													(PVOID) ((DWORD_PTR) dwTemp),
													&dpnhAsyncHandle,
													pSendTestParam->dwFlags);
			} // end if (tester 0)
			else
			{
				tr = pDP8Client->m_pDP8Client->Send(&dpnbd,
													1,
													pSendTestParam->dwTimeout,
													(PVOID) ((DWORD_PTR) dwTemp),
													&dpnhAsyncHandle,
													pSendTestParam->dwFlags);
			} // end else (not tester 0)

			if (pSendTestParam->dwFlags & DPNSEND_SYNC)
			{
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog,  "SendTo failed!", 0);
					THROW_TESTRESULT;
				} // end if (sendto failed)
			} // end if (synchronous send)
			else
			{
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPTEST_FAIL(hLog,  "SendTo didn't return expected PENDING success code!", 0);
					THROW_TESTRESULT;
				} // end if (didn't get pending error)

			
				// If we're supposed to cancel things, and it's time to do so, try.
				if (pSendTestParam->dwCancelInterval != 0)
				{
					dwNextCancel--;
					if (dwNextCancel == 0)
					{
						// Reset the cancel interval counter.
						dwNextCancel = pSendTestParam->dwCancelInterval;

						if (pSendTestParam->fHostTest)
						{
							tr = pDP8Server->DP8S_CancelAsyncOperation(((pSendTestParam->dwCancelFlags == 0) ? dpnhAsyncHandle : NULL),
																		pSendTestParam->dwCancelFlags);
						} // end if (tester 0)
						else
						{
							tr = pDP8Client->DP8C_CancelAsyncOperation(((pSendTestParam->dwCancelFlags == 0) ? dpnhAsyncHandle : NULL),
																		pSendTestParam->dwCancelFlags);
						} // end else (not tester 0)

						if (tr != DPN_OK)
						{
							if (pSendTestParam->dwCancelFlags == 0)
							{
								if ((tr != DPNERR_CANNOTCANCEL) && (tr != DPNERR_INVALIDHANDLE))
								{
									DPTEST_FAIL(hLog,  "Cancelling send %x failed!",
										1, dpnhAsyncHandle);
									THROW_TESTRESULT;
								} // end if (not expected cannotcancel error)
								

								DPTEST_TRACE(hLog,  "Couldn't cancel async send %x, assuming it is completing/completed.  0x%08x",
									2, dpnhAsyncHandle, (HRESULT) tr);
							} // end if (cancelling individual send)
							else
							{
								if (tr != DPNERR_CANNOTCANCEL)
								{
									DPTEST_FAIL(hLog,  "CancelAsyncOperation (flags %x) failed!",
										1, pSendTestParam->dwCancelFlags);
									THROW_TESTRESULT;
								} // end if (not expected cannotcancel error)
								

								DPTEST_TRACE(hLog,  "Couldn't cancel async operations with flags %x, assuming the sends are completing/completed.  0x%08x",
									2, pSendTestParam->dwCancelFlags, (HRESULT) tr);
							} // end else (cancelling mutiple operations)
						} // end if (cancel failed)
						else
						{
							dwSuccessfulCancels++;

							if (pSendTestParam->dwCancelFlags == 0)
							{
								DPTEST_TRACE(hLog, "Cancelling async send %x succeeded.",
									1, dpnhAsyncHandle);
							} // end if (cancelling individual send)
							else
							{
								DPTEST_TRACE(hLog, "CancelAsyncOperation (flags %x) succeeded.",
									1, pSendTestParam->dwCancelFlags);
							} // end else (cancelling mutiple operations)
						} // end else (cancel succeeded)
					} // end if (time to cancel)
				} // end if (cancelling sends)
			} // end else (asynchronous send)
			
			
			// Sleep for the requested interval.  We don't use TNSLEEP because that
			// puts spew out and we sort of want to send as fast as possible.
			Sleep(pSendTestParam->dwInterval);
		} // end for (each send)
		
		
		DPTEST_TRACE(hLog, "Spent %u ms sending %u %u byte messages every %u ms, %u successful cancel attempts.",
			5, (GetTickCount() - dwStartTime), pSendTestParam->dwNumMsgs, pSendTestParam->dwMsgSize,
			pSendTestParam->dwInterval, dwSuccessfulCancels);
	
		if(! (pSendTestParam->dwFlags & DPNSEND_SYNC))
		{
			dwStartTime = GetTickCount();
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for all asynchronous sends to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			if(WaitForSingleObject(context.hAllSendsCompletedEvent, 120000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Completion of all sends wasn't indicated within 2 minutes", 0);
				
				THROW_SYSTEMRESULT;
			}
			
			DPTEST_TRACE(hLog, "Spent %u ms waiting for all sends to complete.",
				1, (GetTickCount() - dwStartTime));

		} // end if (asynchronous sends)
				
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready to close");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		if(!SyncWithOtherTesters(hLog, pSendTestParam->hNetsyncObject, SEND_END_EVENT, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, SEND_BEGIN_EVENT);
			SETTHROW_TESTRESULT(E_ABORT);
		}
		
		DPTEST_TRACE(hLog, "Received %u messages during test.", 1, context.dwReceives);

// BUGBUG - may add CPU eating later
//		if (fEatingCPU)
//		{
//			sr = StopEatingCPUTime();
//			if (sr != S_OK)
//			{
//				DPTEST_FAIL(hLog,  "Couldn't stop eating CPU time!", 0);
//				THROW_SYSTEMRESULT;
//			} // end if (couldn't stop eating CPU time)
//
//			fEatingCPU = FALSE;
//		} // end if (ate CPU time)
		
		if (pSendTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Server->DP8S_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing server object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
		
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Server->Release();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Releaseing server object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
		
			DPTEST_TRACE(hLog, "Releasing server wrapper", 0);
			delete (pDP8Server);
			pDP8Server = NULL;
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Client->DP8C_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing client object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
		
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Client->Release();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Releaseing client object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
		
			DPTEST_TRACE(hLog, "Releasing client wrapper", 0);
			delete (pDP8Client);
			pDP8Client = NULL;
		} // end else (not tester 0)

		FINAL_SUCCESS;
	}
	END_TESTCASE

// BUGBUG - may add CPU eating later
//	// If we're still eating CPU time, be sure to stop it.
//	if (fEatingCPU)
//	{
//		temphr = StopEatingCPUTime();
//		if (temphr != S_OK)
//		{
//			DPTEST_FAIL(hLog,  "Couldn't stop eating CPU time!", 0);
//			OVERWRITE_SR_IF_OK(temphr);
//		} // end if (couldn't stop eating CPU time)
//
//		fEatingCPU = FALSE;
//	} // end if (ate CPU time)

	if (pDP8Server != NULL)
	{
		temphr = pDP8Server->DP8S_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing server interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing server interface failed)

		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		temphr = pDP8Client->DP8C_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing client interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing client interface failed)

		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	SAFE_LOCALFREE(padpnidTesters);
	SAFE_CLOSEHANDLE(context.hbsccAllPlayersCreated);
	SAFE_CLOSEHANDLE(context.hAllSendsCompletedEvent);
	SAFE_LOCALFREE(context.pabSendsCompleted);
	SAFE_LOCALFREE(dpnbd.pBufferData);

	return (sr);
} // SendsExec_SimpleCS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



/* BUGBUG - No support for software disconnects
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendsExec_PendingPeer()"
//==================================================================================
// SendsExec_PendingPeer
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.2.1 - Pending peer-to-peer sends while leaving test
//				2.2.2.2 - Pending peer-to-peer sends while dropping test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT SendsExec_PendingPeer(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	HRESULT						temphr;
	PTID_PSENDS_PENDING			pInput = (PTID_PSENDS_PENDING) pTNecd->pvInputData;
	PTNRESULT					pSubResult;
	PVOID						pvSubInputData = NULL;
	PTOD_BBLDDP8_PEER_CREATE	pBldDP8PeerCreateOutput = NULL;
	DWORD						dwSubOutputDataSize;
	SENDSPENDINGCONTEXT			context;
	DPN_APPLICATION_DESC		dpnad;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PTNFAULTSIM					pFaultSim = NULL;
	DPN_BUFFER_DESC				dpnbd;
	int							dwCurrentTarget;
	int							i;
	DWORD						dwLeaveDropTime = 0;
	BOOL						fThrottle;
	BOOL						fRelevantSend;
	DPNHANDLE					dpnhAsyncHandle;
	DWORD						dwTotalThrottleHits = 0;
	DWORD						dwLastCheckpointTime;
	DWORD						dwValueAtLastCheckpoint;
	DWORD						dwSleepInterval = 0;
	int*						paiDestroyTesters = NULL;
	DPNID*						padpnidDestroyTesters = NULL;



	ZeroMemory(&context, sizeof (SENDSPENDINGCONTEXT));
	context.pTNecd = pTNecd;

	InitializeCriticalSection(&(context.csStatsLock));


	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));


	BEGIN_TESTCASE
	{
		REQUIRE_INPUT_DATA(sizeof (TID_PSENDS_PENDING));


#ifdef DEBUG
		// We had better not be send synchronously
		if (pInput->dwFlags & DPNSEND_SYNC)
		{
			DPTEST_FAIL(hLog,  "Can't specify synchronous as a send flag for this test case (flags = %x)!",
				1, pInput->dwFlags);
			THROW_SYSTEMRESULT;
		} // end if (synchronous sends)

		if (pInput->iNumClosers > (pTNecd->dwNumMachines - 2))
		{
			DPTEST_FAIL(hLog,  "Can't specify %i closers when only %i machines are running the test (need host and one client to remain in session)!",
				2, pInput->iNumClosers, pTNecd->dwNumMachines);
			THROW_SYSTEMRESULT;
		} // end if (too many closers)
#endif // DEBUG


		// Determine how many leaving/dropping players there will be.
		context.iNumClosers = pInput->iNumClosers;
		if (pInput->iNumClosers <= 0)
			context.iNumClosers = pTNecd->dwNumMachines / 2;

		DPTEST_TRACE(hLog, "This test will have %i peers leave/drop while sends are pending.",
			1, context.iNumClosers);




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating peer-to-peer session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.pfnDPNMessageHandler = SendsPendingDPNMessageHandler;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = 0; // no host migration
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_ALL_CREATE));
#pragma TODO(vanceo, "Allow SP to be selected")
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

		sr = pTNecd->pExecutor->ExecSubTestCase("3.1.1.1",
												pvSubInputData,
												sizeof (TID_BBLDDP8_ALL_CREATE),
												0);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog,  "Couldn't execute sub test case BldSsn:BldPeer:Create!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.1",
									"Creating peer-to-peer session failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pBldDP8PeerCreateOutput,
									dwSubOutputDataSize,
									(sizeof (TOD_BBLDDP8_PEER_CREATE) + (pTNecd->dwNumMachines * sizeof (DPNID))));

		pDP8Peer = pBldDP8PeerCreateOutput->pDP8Peer;
		pDP8Peer->m_dwRefCount++; // we're using it during this function

		context.padpnidTesters = (DPNID*) (pBldDP8PeerCreateOutput + 1);




		context.dwMsgSize = pInput->dwMsgSize;
		dpnbd.dwBufferSize = pInput->dwMsgSize;
		LOCALALLOC_OR_THROW(PBYTE, dpnbd.pBufferData, dpnbd.dwBufferSize);

		FillWithDWord(dpnbd.pBufferData, dpnbd.dwBufferSize, SENDFILLPATTERN);


		LOCALALLOC_OR_THROW(BOOL*, context.pafTesterIndicated,
							(pTNecd->dwNumMachines * sizeof (BOOL)));


		TESTSECTION_IF((pTNecd->iTesterNum != 0) && (pTNecd->iTesterNum <= context.iNumClosers))
		{
			context.fClosingPlayer = TRUE;

			// Set the fault simulator up now so that we have less to do after the
			// queue is filled.  This gives us a better chance of keeping the queue
			// full while we drop from the session.

			TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.2.2.2"))
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating IMTest fault simulator for future use");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->CreateNewFaultSim(&pFaultSim,
														TN_FAULTSIM_IMTEST,
														NULL,
														0);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't create IMTest fault simulator!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create fault simulator)
			} // end if (drop test case)
			TESTSECTION_ENDIF
		} // end if (leaving/dropping tester)
		TESTSECTION_ENDIF



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for all testers to be ready to fill queue");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		sr = pTNecd->pExecutor->SyncWithTesters("Ready to send", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		DPTEST_TRACE(hLog,  "Trying to fill queue with %u byte messages.",
			1, pInput->dwMsgSize);
		//Ignore error
		pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
								"Trying to fill queue with %u byte messages.",
								1, pInput->dwMsgSize);

		dwCurrentTarget = pTNecd->iTesterNum;



		dwValueAtLastCheckpoint = 0;
		dwLastCheckpointTime = timeGetTime();

		// Figure out when to leave session if we're the leaving/dropping player.
		if (context.fClosingPlayer)
			dwLeaveDropTime = dwLastCheckpointTime + pInput->dwQueueTime;


		TESTSECTION_DO
		{
			// Keep the control layer from thinking we're deadlocked.
			pTNecd->pExecutor->NoteTestIsStillRunning();


			if (pInput->fSendToAllPlayersGroup)
			{
				fRelevantSend = TRUE;
			} // end if (sending to all players)
			else
			{
				// Find the next person to send to.
				dwCurrentTarget++;
				if (dwCurrentTarget >= pTNecd->dwNumMachines)
					dwCurrentTarget = 0;

#pragma TODO(vanceo, "Handle NOLOOPBACK yet sending to self")


				if ((context.fClosingPlayer) ||
					((dwCurrentTarget != 0) && (dwCurrentTarget <= context.iNumClosers)))
				{
					fRelevantSend = TRUE;
				} // end if (leaving player or sending to leaving player)
				else
				{
					fRelevantSend = FALSE;
				} // end else (not leaving player or sending to him)
			} // end else (not sending to all players)


			// Check to see if we hit the throttle limit frequently.  If we did,
			// let's sleep a little between each send. 
			if (timeGetTime() > (dwLastCheckpointTime + THROTTLECHECK_CHECKPOINTPERIOD))
			{
				if ((dwValueAtLastCheckpoint - dwTotalThrottleHits) > THROTTLECHECK_NUMHITSTHRESHOLD)
				{
					dwSleepInterval += 10;
					DPTEST_TRACE(hLog, "Increasing sleep interval to %u.", 1, dwSleepInterval);
				} // end if (hit the throttle limit frequently)

				dwValueAtLastCheckpoint = dwTotalThrottleHits;
				dwLastCheckpointTime =  timeGetTime();
			} // end if (time to check throttle again)

			// Sleep some if necessary.
			if (dwSleepInterval != 0)
			{
				Sleep(dwSleepInterval);
			} // end if (should sleep)


			fThrottle = FALSE;

			// Lock the stats while we verify/update them.
			EnterCriticalSection(&(context.csStatsLock));

			if (fRelevantSend)
			{
				if ((context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)) > pInput->dwMaxQueueSize)
					fThrottle = TRUE;
				else
					context.dwNumRelevantSends++;
			} // end if (relevant send)
			else
			{
				if ((context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted) > pInput->dwMaxQueueSize)
					fThrottle = TRUE;
				else
					context.dwNumIrrelevantSends++;
			} // end else (irrelevant send)

			// Drop the stats lock.
			LeaveCriticalSection(&(context.csStatsLock));


			
			if (fThrottle)
			{
				dwTotalThrottleHits++;
			} // end if (throttle)
			else
			{
				// Use the API directly so we don't have tons of our wrapper spew.
				tr = pDP8Peer->m_pDP8Peer->SendTo(((pInput->fSendToAllPlayersGroup) ? DPNID_ALL_PLAYERS_GROUP : context.padpnidTesters[dwCurrentTarget]),
													&dpnbd,
													1,
													pInput->dwTimeout,
													(PVOID) ((INT_PTR) fRelevantSend),
													&dpnhAsyncHandle,
													pInput->dwFlags);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					// INVALIDPLAYER is allowed because we may still be calling Send
					// after we've returned from the DESTROYPLAYER indication.
					// NOCONNECTION is allowed if we're the leaving player and we
					// called Close(), because that's what it's spec'd to do.

#pragma TODO(vanceo, "Be more specific about allowing the INVALIDPLAYER and NOCONNECTION error codes")

					if ((tr != DPNERR_CONNECTIONLOST) && (tr != DPNERR_INVALIDPLAYER) && (tr != DPNERR_NOCONNECTION))
					{
						DPTEST_FAIL(hLog,  "SendTo didn't return expected PENDING, CONNECTIONLOST, INVALIDPLAYER, or NOCONNECTION!  DEBUGBREAK()-ing.  0x%08x",
							1, (HRESULT) tr);
						DEBUGBREAK();
						THROW_TESTRESULT;
					} // end if (didn't returned expected error)

					if (! fRelevantSend)
					{
						DPTEST_FAIL(hLog,  "SendTo to irrelevant tester %i (player ID %u/%u) failed!",
							3, dwCurrentTarget, context.padpnidTesters[dwCurrentTarget],
							context.padpnidTesters[dwCurrentTarget]);
						THROW_TESTRESULT;
					} // end if (not relevant send)


					//DPTEST_TRACE(hLog, "SendTo %x failed.", 1, dpnhAsyncHandle);


					// Lock the stats while we update them.
					EnterCriticalSection(&(context.csStatsLock));

					context.dwNumRelevantSendsCompletedFailure++;

					if ((int) (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)) < 0)
					{
						DPTEST_FAIL(hLog,  "Immediate relevant failure is a duplicate ((%u - (%u + %u)) < 0)!  DEBUGBREAK()-ing.",
							3, context.dwNumRelevantSends,
							context.dwNumRelevantSendsCompletedSuccess,
							context.dwNumRelevantSendsCompletedFailure);
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
												"Immediate relevant failure is a duplicate ((%u - (%u + %u)) < 0)!  DEBUGBREAK()-ing.",
												3, context.dwNumRelevantSends,
												context.dwNumRelevantSendsCompletedSuccess,
												context.dwNumRelevantSendsCompletedFailure);
						DEBUGBREAK();
					} // end if (got too many completions)

					// Drop the stats lock.
					LeaveCriticalSection(&(context.csStatsLock));
				} // end if (didn't get pending)
			} // end else (not throttled)

			
			// If we're the dropping player, we haven't done so yet, and it's time,
			// do so.
			TESTSECTION_IF((dwLeaveDropTime != 0) && ((int) (dwLeaveDropTime - timeGetTime()) < 0))
			{
#ifdef DEBUG
				char	szTemp[32];


				// Lock the stats while we work with them.
				EnterCriticalSection(&(context.csStatsLock));

				wsprintf(szTemp, "%i messages out of %u sent",
						(int) (context.dwNumRelevantSends - context.dwNumRelevantSendsCompletedSuccess),
						context.dwNumRelevantSends);

				if (context.dwNumIrrelevantSends != 0)
				{
					DPTEST_FAIL(hLog,  "Somehow %u irrelevant sends were submitted!  DEBUGBREAK()-ing.",
						1, context.dwNumIrrelevantSends);
					DEBUGBREAK();
				} // end if (any irrelevant sends submitted)

				if (context.dwNumIrrelevantSendsCompleted != 0)
				{
					DPTEST_FAIL(hLog,  "Somehow %u irrelevant sends were completed!  DEBUGBREAK()-ing.",
						1, context.dwNumIrrelevantSendsCompleted);
					DEBUGBREAK();
				} // end if (any irrelevant sends submitted)

				if (context.dwNumRelevantSendsCompletedFailure != 0)
				{
					DPTEST_FAIL(hLog,  "Somehow %u sends failed!  DEBUGBREAK()-ing.",
						1, context.dwNumRelevantSendsCompletedFailure);
					DEBUGBREAK();
				} // end if (any failed sends already)

				// Drop the stats lock.
				LeaveCriticalSection(&(context.csStatsLock));


				DPTEST_TRACE(hLog, "Approximately %s are still outstanding after %u ms of queueing.",
					2, szTemp, pInput->dwQueueTime);
#endif // DEBUG


				TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.2.2.2"))
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Disconnecting sends and receives, will drop from session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPTEST_FAIL(hLog,  "Couldn't disconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPTEST_FAIL(hLog,  "Couldn't disconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)


					// Prevent us from trying to leave/drop again, because we're
					// going to keep looping (and queueing sends).
					dwLeaveDropTime = 0;
				} // end if (drop test case)
				TESTSECTION_ELSE
				{
					// Leave the session right now.

					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Closing DPlay");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					tr = pDP8Peer->DP8P_Close(0);
					if (tr != DPN_OK)
					{
						DPTEST_FAIL(hLog,  "Failed closing DPlay8Peer object!", 0);
						THROW_TESTRESULT;
					} // end if (failed closing)


					// Make sure the nametable unwound correctly.
					for(i = 0; i < pTNecd->dwNumMachines; i++)
					{
						if (! context.pafTesterIndicated[i])
						{
							DPTEST_FAIL(hLog,  "Didn't get DESTROY_PLAYER indication for tester %i!",
								1, i);
							SETTHROW_TESTRESULT(ERROR_NO_DATA);
						} // end if (tester not indicated)
					} // end for (each tester)

					// Stop looping.
					TESTSECTION_BREAK;
				} // end else (not drop test case)
				TESTSECTION_ENDIF
			} // end if (time to close)
			TESTSECTION_ELSEIF(context.fPlayersLeftOrDropped)
			{
				// The above else-if condition is for when:
				//
				// a) we're the leaving player in the drop case and we have started
				//    the disconnection.  We need to keep trying to send until we
				//    get booted from the session.
				// b) we're not a player that leaves/drops from the session.  We
				//    need to keep trying to send until we see that player go away.
				//
				// Either way, context.fPlayerLeftOrDropped will be set to TRUE when
				// the condition is met.  Once that happens, we can bail out of the
				// loop to do the final cleanup stuff.
				TESTSECTION_BREAK;
			} // end else (dropping player after disconnecting or not leaving)
			TESTSECTION_ENDIF
		} // end do (while time hasn't been exceeded yet)
		TESTSECTION_DOWHILE(TRUE);
		


		DPTEST_TRACE(hLog, "Hit the queue throttle limit of %u a total of %u times.",
			2, pInput->dwMaxQueueSize, dwTotalThrottleHits);



		// Note that we're not taking the lock to check the stats since
		// a) we're only reading the values
		// b) the values should stop changing shortly
		// c) we're polling the values quite regularly.
		dwLastCheckpointTime = timeGetTime();
		dwValueAtLastCheckpoint = context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure);


		// Wait for all outstanding sends to be completed.
		while ((context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)) != 0)
		{
			// See if it's time to monitor the completion rate again.
			if ((int) (timeGetTime() - (dwLastCheckpointTime + QUEUEEMPTY_CHECKPOINTPERIOD)) > 0)
			{
				// Make sure the completions are still coming in.  If we ever hit
				// the steady state of no-completions, something's bad.
				if ((dwValueAtLastCheckpoint - (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure))) == 0)
				{
					DPTEST_FAIL(hLog,  "No relevant completions came in over the last %u ms, approximately %i remain!",
						2, QUEUEEMPTY_CHECKPOINTPERIOD,
						(int) (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)));
					SETTHROW_TESTRESULT(ERROR_MORE_DATA);
				} // end if (no completions came in)
				
				dwLastCheckpointTime = timeGetTime();
				dwValueAtLastCheckpoint = context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure);
			} // end if (time for next checkpoint)


			DPTEST_TRACE(hLog, "Waiting for approximately %i relevant sends to complete.",
				1, (int) (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)));
			

			// Use TNSLEEP to keep the control layer alert so it doesn't think
			// we're deadlocked.
			TNSLEEP(500);
		} // end if (sends still outstanding)


		// Print the stats for reference.  No lock necessary since
		// the count should no longer be changing.
		DPTEST_TRACE(hLog,  "%u relevant sends were submitted, %u succeeded and %u failed.",
			3, context.dwNumRelevantSends,
			context.dwNumRelevantSendsCompletedSuccess,
			context.dwNumRelevantSendsCompletedFailure);


		TESTSECTION_IF(context.fClosingPlayer)
		{
			// If this is a drop case, we still should close DPlay.
			TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.2.2.2"))
			{
				// Make sure we got the TERMINATE_SESSION indication.
				if (! context.fGotTerminateSession)
				{
					DPTEST_FAIL(hLog,  "Didn't get terminate session indication!", 0);
					SETTHROW_TESTRESULT(ERROR_NO_DATA);
				} // end if (didn't get terminate session)


				// Make sure the nametable unwound correctly (how else would we
				// get here?).
				for(i = 0; i < pTNecd->dwNumMachines; i++)
				{
					if (! context.pafTesterIndicated[i])
					{
						DPTEST_FAIL(hLog,  "Didn't get DESTROY_PLAYER indication for tester %i!",
							1, i);
						SETTHROW_TESTRESULT(ERROR_NO_DATA);
					} // end if (tester not indicated)
				} // end for (each tester)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Restoring send and receive traffic");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, TRUE);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't reconnect sends!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't reconnect)

				sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, FALSE);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't reconnect receives!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't reconnect)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing IMTest fault simulator");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't release fault simulator %x!", 1, pFaultSim);
					THROW_SYSTEMRESULT;
				} // end if (couldn't release fault simulator)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Closing DPlay");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->DP8P_Close(0);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog,  "Failed closing DPlay8Peer object!", 0);
					THROW_TESTRESULT;
				} // end if (failed closing)
			} // end if (drop case)
			TESTSECTION_ENDIF




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other testers to finish");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			sr = pTNecd->pExecutor->SyncWithTesters("Ready to destroy session",
													NULL, 0, NULL, 0);
			HANDLE_SYNC_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer wrapper");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->Release();
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog,  "Couldn't release DirectPlay8Peer object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)


			sr = g_pDP8PeersList->RemoveFirstReference(pDP8Peer);
			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog,  "Couldn't remove DirectPlay8Peer wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)


			pDP8Peer->m_dwRefCount--; // release our reference
			if (pDP8Peer->m_dwRefCount == 0)
			{
				DPTEST_TRACE(hLog, "Deleting DirectPlay8Peer wrapper object %x.",
					1, pDP8Peer);
				delete (pDP8Peer);
			} // end if (can delete the object)
			else
			{
				DPTEST_TRACE(hLog, "Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u.",
					2, pDP8Peer,
					pDP8Peer->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Peer = NULL;
		} // end if (closing player)
		TESTSECTION_ELSE
		{
			// Note that we're not taking the lock to check the stats since
			// a) we're only reading the values
			// b) the values should stop changing shortly
			// c) we're polling the values quite regularly.
			dwLastCheckpointTime = timeGetTime();
			dwValueAtLastCheckpoint = context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted;


			// Wait for all outstanding sends to be completed.
			while ((context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted) != 0)
			{
				// See if it's time to monitor the completion rate again.
				if ((int) (timeGetTime() - (dwLastCheckpointTime + QUEUEEMPTY_CHECKPOINTPERIOD)) > 0)
				{
					// Make sure the completions are still coming in.  If we ever
					// hit the steady state of no-completions, something's bad.
					if ((dwValueAtLastCheckpoint - (context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted)) == 0)
					{
						DPTEST_FAIL(hLog,  "No irrelevant completions came in over the last %u ms, approximately %i remain!",
							2, QUEUEEMPTY_CHECKPOINTPERIOD,
							(int) (context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted));
						SETTHROW_TESTRESULT(ERROR_MORE_DATA);
					} // end if (no completions came in)
					
					dwLastCheckpointTime = timeGetTime();
					dwValueAtLastCheckpoint = context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted;
				} // end if (time for next checkpoint)


				DPTEST_TRACE(hLog, "Waiting for approximately %i irrelevant sends to complete.",
					1, (int) (context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted));
				

				// Use TNSLEEP to keep the control layer alert so it doesn't think
				// we're deadlocked.
				TNSLEEP(500);
			} // end if (sends still outstanding)




			LOCALALLOC_OR_THROW(int*, paiDestroyTesters,
								((pTNecd->dwNumMachines - context.iNumClosers) * sizeof (int)));

			LOCALALLOC_OR_THROW(DPNID*, padpnidDestroyTesters,
								((pTNecd->dwNumMachines - context.iNumClosers) * sizeof (DPNID)));

			// Store hosting tester.
			//paiDestroyTesters[0] = 0;
			padpnidDestroyTesters[0] = context.padpnidTesters[0];

			// Store non-host testers still in session.
			for(i = 1; i < (pTNecd->dwNumMachines - context.iNumClosers); i++)
			{
				paiDestroyTesters[i] = context.iNumClosers + i;
				padpnidDestroyTesters[i] = context.padpnidTesters[context.iNumClosers + i];
			} // end for (each non-host tester still in session)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other testers to finish");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			sr = pTNecd->pExecutor->SyncWithTesters("Ready to destroy session",
													NULL, 0, NULL, 0);
			HANDLE_SYNC_RESULT;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Destroying peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_PEER_DESTROY));
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pDP8Peer = pDP8Peer;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pHandlerContext = &context;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->padpnidTesters = padpnidDestroyTesters;

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.1.2", pvSubInputData,
														sizeof (TID_BBLDDP8_PEER_DESTROY),
														(pTNecd->dwNumMachines - context.iNumClosers),
														paiDestroyTesters);

			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			LocalFree(padpnidDestroyTesters);
			padpnidDestroyTesters = NULL;

			LocalFree(paiDestroyTesters);
			paiDestroyTesters = NULL;

			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog,  "Couldn't execute sub test case BldSsn:BldPeer:Destroy!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.2",
										"Destroying peer-to-peer session failed!");



			pDP8Peer->m_dwRefCount--;
			if (pDP8Peer->m_dwRefCount == 0)
			{
				DPTEST_TRACE(hLog, "Deleting peer wrapper object %x.", 1, pDP8Peer);
				delete (pDP8Peer);
			} // end if (can delete the object)
			else
			{
				DPTEST_TRACE(hLog,  "WARNING: Can't delete peer wrapper object %x, it's refcount is %u!?",
					2, pDP8Peer, pDP8Peer->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Peer = NULL;
		} // end else (not closing player)
		TESTSECTION_ENDIF



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pFaultSim != NULL)
	{
		temphr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
		if (temphr != S_OK)
		{
			DPTEST_FAIL(hLog,  "Couldn't release fault sim %x!  0x%08x", 2, pFaultSim, temphr);
			
			OVERWRITE_SR_IF_OK(temphr);

			pFaultSim = NULL;
		} // end if (couldn't remove handler)
	} // end if (have fault sim)

	if (pDP8Peer != NULL)
	{
		temphr = pDP8Peer->DP8P_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing peer interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing peer interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8PeersList->RemoveFirstReference(pDP8Peer);


		pDP8Peer->m_dwRefCount--;
		if (pDP8Peer->m_dwRefCount == 0)
		{
			DPTEST_TRACE(hLog, "Deleting DirectPlay8Peer wrapper object %x.", 1, pDP8Peer);
			delete (pDP8Peer);
		} // end if (can delete the object)
		else
		{
			DPTEST_TRACE(hLog,  "WARNING: Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u!?",
				2, pDP8Peer, pDP8Peer->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(padpnidDestroyTesters);
	SAFE_LOCALFREE(paiDestroyTesters);
	SAFE_LOCALFREE(context.pafTesterIndicated);
	SAFE_LOCALFREE(dpnbd.pBufferData);
	SAFE_LOCALFREE(pvSubInputData);

	DeleteCriticalSection(&(context.csStatsLock));

	return (sr);
} // SendsExec_PendingPeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/




/* BUGBUG - No support for software disconnects
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendsExec_PendingCS()"
//==================================================================================
// SendsExec_PendingCS
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.2.3 - Pending client/server sends while leaving test
//				2.2.2.4 - Pending client/server sends while dropping test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT SendsExec_PendingCS(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTID_PSENDS_PENDING				pInput = (PTID_PSENDS_PENDING) pTNecd->pvInputData;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PTOD_BBLDDP8_CS_CREATE_0		pBldDP8CSCreateOutput0 = NULL;
	PTOD_BBLDDP8_CS_CREATE_NOT0		pBldDP8CSCreateOutputNot0 = NULL;
	DWORD							dwSubInputDataSize;
	DWORD							dwSubOutputDataSize;
	SENDSPENDINGCONTEXT				context;
	DPN_APPLICATION_DESC			dpnad;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PWRAPDP8CLIENT					pDP8Client = NULL;
	PTNFAULTSIM						pFaultSim = NULL;
	DPN_BUFFER_DESC					dpnbd;
	int								dwCurrentTarget;
	int								i;
	DWORD							dwLeaveDropTime = 0;
	BOOL							fThrottle;
	BOOL							fRelevantSend;
	DPNHANDLE						dpnhAsyncHandle;
	DWORD							dwTotalThrottleHits = 0;
	DWORD							dwLastCheckpointTime;
	DWORD							dwValueAtLastCheckpoint;
	DWORD							dwSleepInterval = 0;
	int*							paiDestroyTesters = NULL;
	DPNID*							padpnidDestroyTesters = NULL;



	ZeroMemory(&context, sizeof (SENDSPENDINGCONTEXT));
	context.pTNecd = pTNecd;

	InitializeCriticalSection(&(context.csStatsLock));


	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));


	BEGIN_TESTCASE
	{
		REQUIRE_INPUT_DATA(sizeof (TID_PSENDS_PENDING));


#ifdef DEBUG
		// We had better not be send synchronously
		if (pInput->dwFlags & DPNSEND_SYNC)
		{
			DPTEST_FAIL(hLog,  "Can't specify synchronous as a send flag for this test case (flags = %x)!",
				1, pInput->dwFlags);
			THROW_SYSTEMRESULT;
		} // end if (synchronous sends)

		if (pInput->iNumClosers > (pTNecd->dwNumMachines - 2))
		{
			DPTEST_FAIL(hLog,  "Can't specify %i closers when only %i machines are running the test (need host and one client to remain in session)!",
				2, pInput->iNumClosers, pTNecd->dwNumMachines);
			THROW_SYSTEMRESULT;
		} // end if (too many closers)
#endif // DEBUG


		// Determine how many leaving/dropping players there will be.
		context.iNumClosers = pInput->iNumClosers;
		if (pInput->iNumClosers <= 0)
			context.iNumClosers = pTNecd->dwNumMachines / 2;

		DPTEST_TRACE(hLog, "This test will have %i peers leave/drop while sends are pending.",
			1, context.iNumClosers);




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating client/server session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		//if (pTNecd->iTesterNum == 0)
			context.pfnDPNMessageHandler = SendsPendingDPNMessageHandler;
		//else
		//	context.pfnDPNMessageHandler = SendsPendingDPNMessageHandler;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_ALL_CREATE));
#pragma TODO(vanceo, "Allow SP to be selected")
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

		sr = pTNecd->pExecutor->ExecSubTestCase("3.1.2.1",
												pvSubInputData,
												sizeof (TID_BBLDDP8_ALL_CREATE),
												0);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog,  "Couldn't execute sub test case BldSsn:BldCS:Create!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.1",
									"Creating client/server session failed!");

		// Otherwise get the object created.
		if (pTNecd->iTesterNum == 0)
		{
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutput0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_CS_CREATE_0) + (pTNecd->dwNumMachines * sizeof (DPNID))));

			pDP8Server = pBldDP8CSCreateOutput0->pDP8Server;
			pDP8Server->m_dwRefCount++; // we're using it during this function
			context.padpnidTesters = (DPNID*) (pBldDP8CSCreateOutput0 + 1);
		} // end if (tester 0)
		else
		{
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutputNot0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_CS_CREATE_NOT0) + (pTNecd->dwNumMachines * sizeof (DPNID))));

			pDP8Client = pBldDP8CSCreateOutputNot0->pDP8Client;
			pDP8Client->m_dwRefCount++; // we're using it during this function
			context.padpnidTesters = (DPNID*) (pBldDP8CSCreateOutputNot0 + 1);
		} // end else (not tester 0)



		context.dwMsgSize = pInput->dwMsgSize;
		dpnbd.dwBufferSize = pInput->dwMsgSize;
		LOCALALLOC_OR_THROW(PBYTE, dpnbd.pBufferData, dpnbd.dwBufferSize);

		FillWithDWord(dpnbd.pBufferData, dpnbd.dwBufferSize, SENDFILLPATTERN);


		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			LOCALALLOC_OR_THROW(BOOL*, context.pafTesterIndicated,
								(pTNecd->dwNumMachines * sizeof (BOOL)));
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			TESTSECTION_IF(pTNecd->iTesterNum <= context.iNumClosers)
			{
				context.fClosingPlayer = TRUE;

				// Set junk up now so that we have less to do after the queue is filled.
				// This gives us a better chance of keeping the queue full while we drop
				// from the session.

				TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.2.2.2"))
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Creating IMTest fault simulator for future use");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->CreateNewFaultSim(&pFaultSim,
															TN_FAULTSIM_IMTEST,
															NULL,
															0);
					if (sr != S_OK)
					{
						DPTEST_FAIL(hLog,  "Couldn't create IMTest fault simulator!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't create fault simulator)
				} // end if (drop test case)
				TESTSECTION_ENDIF
			} // end if (leaving/dropping tester)
			TESTSECTION_ENDIF
		} // end else (not tester 0)
		TESTSECTION_ENDIF



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for all testers to be ready to fill queue");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		sr = pTNecd->pExecutor->SyncWithTesters("Ready to send", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		DPTEST_TRACE(hLog,  "Trying to fill queue with %u byte messages.",
			1, pInput->dwMsgSize);
		//Ignore error
		pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
								"Trying to fill queue with %u byte messages.",
								1, pInput->dwMsgSize);

		dwCurrentTarget = pTNecd->iTesterNum;



		dwValueAtLastCheckpoint = 0;
		dwLastCheckpointTime = timeGetTime();

		// Figure out when to leave session if we're a leaving/dropping player.
		if (context.fClosingPlayer)
			dwLeaveDropTime = dwLastCheckpointTime + pInput->dwQueueTime;


		TESTSECTION_DO
		{
			// Keep the control layer from thinking we're deadlocked.
			pTNecd->pExecutor->NoteTestIsStillRunning();


			if (pTNecd->iTesterNum == 0)
			{
				if (pInput->fSendToAllPlayersGroup)
				{
					fRelevantSend = TRUE;
				} // end if (sending to all players)
				else
				{
					// Find the next person to send to.
					dwCurrentTarget++;
					if (dwCurrentTarget >= pTNecd->dwNumMachines)
					{
						dwCurrentTarget = 0;

#pragma TODO(vanceo, "Handle NOLOOPBACK yet sending to self")
					} // end if (sending to self)
					else
					{
						if (dwCurrentTarget <= context.iNumClosers)
						{
							fRelevantSend = TRUE;
						} // end if (leaving player or sending to leaving player)
						else
						{
							fRelevantSend = FALSE;
						} // end else (not leaving player or sending to him)
					} // end else (not sending to self)
				} // end else (not sending to all players)
			} // end if (tester 0)
			else
			{
				dwCurrentTarget = 0; // we always send to the server

				if (context.fClosingPlayer)
				{
					fRelevantSend = TRUE;
				} // end if (leaving player)
				else
				{
					fRelevantSend = FALSE;
				} // end else (not leaving player)
			} // end else (not tester 0)


			// Check to see if we hit the throttle limit frequently.  If we did,
			// let's sleep a little between each send. 
			if (timeGetTime() > (dwLastCheckpointTime + THROTTLECHECK_CHECKPOINTPERIOD))
			{
				if ((dwValueAtLastCheckpoint - dwTotalThrottleHits) > THROTTLECHECK_NUMHITSTHRESHOLD)
				{
					dwSleepInterval += 10;
					DPTEST_TRACE(hLog, "Increasing sleep interval to %u.", 1, dwSleepInterval);
				} // end if (hit the throttle limit frequently)

				dwValueAtLastCheckpoint = dwTotalThrottleHits;
				dwLastCheckpointTime =  timeGetTime();
			} // end if (time to check throttle again)

			// Sleep some if necessary.
			if (dwSleepInterval != 0)
			{
				Sleep(dwSleepInterval);
			} // end if (should sleep)


			fThrottle = FALSE;

			// Lock the stats while we verify/update them.
			EnterCriticalSection(&(context.csStatsLock));

			if (fRelevantSend)
			{
				if ((context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)) > pInput->dwMaxQueueSize)
					fThrottle = TRUE;
				else
					context.dwNumRelevantSends++;
			} // end if (relevant send)
			else
			{
				if ((context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted) > pInput->dwMaxQueueSize)
					fThrottle = TRUE;
				else
					context.dwNumIrrelevantSends++;
			} // end else (irrelevant send)

			// Drop the stats lock.
			LeaveCriticalSection(&(context.csStatsLock));


			
			if (fThrottle)
			{
				dwTotalThrottleHits++;
			} // end if (throttle)
			else
			{
				// Use the API directly so we don't have tons of our wrapper spew.
				if (pTNecd->iTesterNum == 0)
				{
					tr = pDP8Server->m_pDP8Server->SendTo(((pInput->fSendToAllPlayersGroup) ? DPNID_ALL_PLAYERS_GROUP : context.padpnidTesters[dwCurrentTarget]),
														&dpnbd,
														1,
														pInput->dwTimeout,
														(PVOID) ((INT_PTR) fRelevantSend),
														&dpnhAsyncHandle,
														pInput->dwFlags);
				} // end if (tester 0)
				else
				{
					tr = pDP8Client->m_pDP8Client->Send(&dpnbd,
														1,
														pInput->dwTimeout,
														(PVOID) ((INT_PTR) fRelevantSend),
														&dpnhAsyncHandle,
														pInput->dwFlags);
				} // end else (not tester 0)

				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					// INVALIDPLAYER is allowed because we may still be calling Send
					// after we've returned from the DESTROYPLAYER indication.
					// NOCONNECTION is allowed if we're the leaving player and we
					// called Close(), because that's what it's spec'd to do.

#pragma TODO(vanceo, "Be more specific about allowing the INVALIDPLAYER and NOCONNECTION error codes")

					if ((tr != DPNERR_CONNECTIONLOST) && (tr != DPNERR_INVALIDPLAYER) && (tr != DPNERR_NOCONNECTION))
					{
						DPTEST_FAIL(hLog,  "Send(To) didn't return expected PENDING, CONNECTIONLOST, INVALIDPLAYER, or NOCONNECTION!  DEBUGBREAK()-ing.  0x%08x",
							1, (HRESULT) tr);
						DEBUGBREAK();
						THROW_TESTRESULT;
					} // end if (didn't returned expected error)

					if (! fRelevantSend)
					{
						DPTEST_FAIL(hLog,  "SendTo to irrelevant tester %i (player ID %u/%u) failed!",
							3, dwCurrentTarget, context.padpnidTesters[dwCurrentTarget],
							context.padpnidTesters[dwCurrentTarget]);
						THROW_TESTRESULT;
					} // end if (not relevant send)


					//DPTEST_TRACE(hLog, "Send(To) %x failed.", 1, dpnhAsyncHandle);


					// Lock the stats while we update them.
					EnterCriticalSection(&(context.csStatsLock));

					context.dwNumRelevantSendsCompletedFailure++;

					if ((int) (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)) < 0)
					{
						DPTEST_FAIL(hLog,  "Immediate relevant failure is a duplicate ((%u - (%u + %u)) < 0)!  DEBUGBREAK()-ing.",
							3, context.dwNumRelevantSends,
							context.dwNumRelevantSendsCompletedSuccess,
							context.dwNumRelevantSendsCompletedFailure);
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
												"Immediate relevant failure is a duplicate ((%u - (%u + %u)) < 0)!  DEBUGBREAK()-ing.",
												3, context.dwNumRelevantSends,
												context.dwNumRelevantSendsCompletedSuccess,
												context.dwNumRelevantSendsCompletedFailure);
						DEBUGBREAK();
					} // end if (got too many completions)

					// Drop the stats lock.
					LeaveCriticalSection(&(context.csStatsLock));
				} // end if (didn't get pending)
			} // end else (not throttled)

			
			// If we're the dropping player, we haven't done so yet, and it's time,
			// do so.
			TESTSECTION_IF((dwLeaveDropTime != 0) && ((int) (dwLeaveDropTime - timeGetTime()) < 0))
			{
#ifdef DEBUG
				char	szTemp[32];


				// Lock the stats while we work with them.
				EnterCriticalSection(&(context.csStatsLock));

				wsprintf(szTemp, "%i messages out of %u sent",
						(int) (context.dwNumRelevantSends - context.dwNumRelevantSendsCompletedSuccess),
						context.dwNumRelevantSends);

				if (context.dwNumIrrelevantSends != 0)
				{
					DPTEST_FAIL(hLog,  "Somehow %u irrelevant sends were submitted!  DEBUGBREAK()-ing.",
						1, context.dwNumIrrelevantSends);
					DEBUGBREAK();
				} // end if (any irrelevant sends submitted)

				if (context.dwNumIrrelevantSendsCompleted != 0)
				{
					DPTEST_FAIL(hLog,  "Somehow %u irrelevant sends were completed!  DEBUGBREAK()-ing.",
						1, context.dwNumIrrelevantSendsCompleted);
					DEBUGBREAK();
				} // end if (any irrelevant sends submitted)

				if (context.dwNumRelevantSendsCompletedFailure != 0)
				{
					DPTEST_FAIL(hLog,  "Somehow %u sends failed!  DEBUGBREAK()-ing.",
						1, context.dwNumRelevantSendsCompletedFailure);
					DEBUGBREAK();
				} // end if (any failed sends already)

				// Drop the stats lock.
				LeaveCriticalSection(&(context.csStatsLock));


				DPTEST_TRACE(hLog, "Approximately %s are still outstanding after %u ms of queueing.",
					2, szTemp, pInput->dwQueueTime);
#endif // DEBUG


				TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.2.2.2"))
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Disconnecting sends and receives, will drop from session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPTEST_FAIL(hLog,  "Couldn't disconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPTEST_FAIL(hLog,  "Couldn't disconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)


					// Prevent us from trying to leave/drop again, because we're
					// going to keep looping (and queueing sends).
					dwLeaveDropTime = 0;
				} // end if (drop test case)
				TESTSECTION_ELSE
				{
					// Leave the session right now.

					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Closing DPlay");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					tr = pDP8Client->DP8C_Close(0);
					if (tr != DPN_OK)
					{
						DPTEST_FAIL(hLog,  "Failed closing DPlay8Client object!", 0);
						THROW_TESTRESULT;
					} // end if (failed closing)


					// Stop looping.
					TESTSECTION_BREAK;
				} // end else (not drop test case)
				TESTSECTION_ENDIF
			} // end if (time to close)
			TESTSECTION_ELSEIF(context.fPlayersLeftOrDropped)
			{
				// The above else-if condition is for when:
				//
				// a) we're the leaving player in the drop case and we have started
				//    the disconnection.  We need to keep trying to send until we
				//    get booted from the session.
				// b) we're not a player that leaves/drops from the session.  We
				//    need to keep trying to send until we see that player go away.
				//    Unfortunately if we're another client, the only way to tell
				//    that the dropping client is gone is to have the server send us
				//    a specially constructed message via DPlay that the other
				//    client has now gone away... ugly.
				//
				// Either way, context.fPlayerLeftOrDropped will be set to TRUE when
				// the condition is met.  Once that happens, we can bail out of the
				// loop to do the final cleanup stuff.
				//
				// A server needs to send that special message to everyone.
				if (pTNecd->iTesterNum == 0)
				{
					DPN_BUFFER_DESC		dpnbdTemp;
					DWORD				dwMsg;


					dwMsg = PENDINGSENDS_CS_DESTROYPLAYER_ID; 

					dpnbdTemp.dwBufferSize = sizeof (DWORD);
					dpnbdTemp.pBufferData = (PBYTE) (&dwMsg);


					// Lock the stats while we update them.
					EnterCriticalSection(&(context.csStatsLock));

					context.dwNumIrrelevantSends++;

					// Drop the stats lock.
					LeaveCriticalSection(&(context.csStatsLock));


					tr = pDP8Server->DP8S_SendTo(DPNID_ALL_PLAYERS_GROUP,
												&dpnbdTemp,
												1,
												0,
												FALSE,
												&dpnhAsyncHandle,
												DPNSEND_GUARANTEED);
					if (tr != (HRESULT) DPNSUCCESS_PENDING)
					{
						DPTEST_FAIL(hLog,  "SendTo didn't return expected PENDING success code!  DEBUGBREAK()-ing.  0x%08x",
							1, (HRESULT) tr);
						DEBUGBREAK();
						THROW_TESTRESULT;
					} // end if (not pending)
				} // end if (tester 0)
				TESTSECTION_BREAK;
			} // end else (dropping player after disconnecting or not leaving)
			TESTSECTION_ENDIF
		} // end do (while time hasn't been exceeded yet)
		TESTSECTION_DOWHILE(TRUE);
		


		DPTEST_TRACE(hLog, "Hit the queue throttle limit of %u a total of %u times.",
			2, pInput->dwMaxQueueSize, dwTotalThrottleHits);



		// Note that we're not taking the lock to check the stats since
		// a) we're only reading the values
		// b) the values should stop changing shortly
		// c) we're polling the values quite regularly.
		dwLastCheckpointTime = timeGetTime();
		dwValueAtLastCheckpoint = context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure);


		// Wait for all outstanding sends to be completed.
		while ((context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)) != 0)
		{
			// See if it's time to monitor the completion rate again.
			if ((int) (timeGetTime() - (dwLastCheckpointTime + QUEUEEMPTY_CHECKPOINTPERIOD)) > 0)
			{
				// Make sure the completions are still coming in.  If we ever hit
				// the steady state of no-completions, something's bad.
				if ((dwValueAtLastCheckpoint - (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure))) == 0)
				{
					DPTEST_FAIL(hLog,  "No relevant completions came in over the last %u ms, approximately %i remain!",
						2, QUEUEEMPTY_CHECKPOINTPERIOD,
						(int) (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)));
					SETTHROW_TESTRESULT(ERROR_MORE_DATA);
				} // end if (no completions came in)
				
				dwLastCheckpointTime = timeGetTime();
				dwValueAtLastCheckpoint = context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure);
			} // end if (time for next checkpoint)


			DPTEST_TRACE(hLog, "Waiting for approximately %i relevant sends to complete.",
				1, (int) (context.dwNumRelevantSends - (context.dwNumRelevantSendsCompletedSuccess + context.dwNumRelevantSendsCompletedFailure)));
			

			// Use TNSLEEP to keep the control layer alert so it doesn't think
			// we're deadlocked.
			TNSLEEP(500);
		} // end if (sends still outstanding)


		// Print the stats for reference.  No lock necessary since
		// the count should no longer be changing.
		DPTEST_TRACE(hLog,  "%u relevant sends were submitted, %u succeeded and %u failed.",
			3, context.dwNumRelevantSends,
			context.dwNumRelevantSendsCompletedSuccess,
			context.dwNumRelevantSendsCompletedFailure);


		TESTSECTION_IF(context.fClosingPlayer)
		{
			// If this is a drop case, we still need to close DPlay.
			TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.2.2.2"))
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Restoring send and receive traffic");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, TRUE);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't reconnect sends!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't reconnect)

				sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, FALSE);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't reconnect receives!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't reconnect)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing IMTest fault simulator");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
				if (sr != S_OK)
				{
					DPTEST_FAIL(hLog,  "Couldn't release fault simulator %x!", 1, pFaultSim);
					THROW_SYSTEMRESULT;
				} // end if (couldn't release fault simulator)


				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Closing DPlay");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->DP8C_Close(0);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog,  "Failed closing DPlay8Client object!", 0);
					THROW_TESTRESULT;
				} // end if (failed closing)
			} // end if (drop case)
			TESTSECTION_ENDIF




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other testers to finish");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			sr = pTNecd->pExecutor->SyncWithTesters("Ready to destroy session",
													NULL, 0, NULL, 0);
			HANDLE_SYNC_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->Release();
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog,  "Couldn't release DirectPlay8Client object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)


			sr = g_pDP8ClientsList->RemoveFirstReference(pDP8Client);
			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog,  "Couldn't remove DirectPlay8Client wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)


			pDP8Client->m_dwRefCount--; // release our reference
			if (pDP8Client->m_dwRefCount == 0)
			{
				DPTEST_TRACE(hLog, "Deleting DirectPlay8Client wrapper object %x.",
					1, pDP8Client);
				delete (pDP8Client);
			} // end if (can delete the object)
			else
			{
				DPTEST_TRACE(hLog, "Can't delete DirectPlay8Client wrapper object %x, it's refcount is %u.",
					2, pDP8Client,
					pDP8Client->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Client = NULL;
		} // end if (tester 1)
		TESTSECTION_ELSE
		{
			// Note that we're not taking the lock to check the stats since
			// a) we're only reading the values
			// b) the values should stop changing shortly
			// c) we're polling the values quite regularly.
			dwLastCheckpointTime = timeGetTime();
			dwValueAtLastCheckpoint = context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted;


			// Wait for all outstanding sends to be completed.
			while ((context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted) != 0)
			{
				// See if it's time to monitor the completion rate again.
				if ((int) (timeGetTime() - (dwLastCheckpointTime + QUEUEEMPTY_CHECKPOINTPERIOD)) > 0)
				{
					// Make sure the completions are still coming in.  If we ever
					// hit the steady state of no-completions, something's bad.
					if ((dwValueAtLastCheckpoint - (context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted)) == 0)
					{
						DPTEST_FAIL(hLog,  "No irrelevant completions came in over the last %u ms, approximately %i remain!",
							2, QUEUEEMPTY_CHECKPOINTPERIOD,
							(int) (context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted));
						SETTHROW_TESTRESULT(ERROR_MORE_DATA);
					} // end if (no completions came in)
					
					dwLastCheckpointTime = timeGetTime();
					dwValueAtLastCheckpoint = context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted;
				} // end if (time for next checkpoint)


				DPTEST_TRACE(hLog, "Waiting for approximately %i irrelevant sends to complete.",
					1, (int) (context.dwNumIrrelevantSends - context.dwNumIrrelevantSendsCompleted));
				

				// Use TNSLEEP to keep the control layer alert so it doesn't think
				// we're deadlocked.
				TNSLEEP(500);
			} // end if (sends still outstanding)




			LOCALALLOC_OR_THROW(int*, paiDestroyTesters,
								((pTNecd->dwNumMachines - context.iNumClosers) * sizeof (int)));

			// Only tester 0 will actually use this array.
			LOCALALLOC_OR_THROW(DPNID*, padpnidDestroyTesters,
								((pTNecd->dwNumMachines - context.iNumClosers) * sizeof (DPNID)));

			// Store hosting tester.
			//paiDestroyTesters[0] = 0;
			padpnidDestroyTesters[0] = context.padpnidTesters[0];

			// Store non-host testers still in session.
			for(i = 1; i < (pTNecd->dwNumMachines - context.iNumClosers); i++)
			{
				paiDestroyTesters[i] = context.iNumClosers + i;
				padpnidDestroyTesters[i] = context.padpnidTesters[context.iNumClosers + i];
			} // end for (each non-host tester still in session)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other testers to finish");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			sr = pTNecd->pExecutor->SyncWithTesters("Ready to destroy session",
													NULL, 0, NULL, 0);
			HANDLE_SYNC_RESULT;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Destroying client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (pTNecd->iTesterNum == 0)
			{
				dwSubInputDataSize = sizeof (TID_BBLDDP8_CS_DESTROY_0);
				LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->pDP8Server = pDP8Server;
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->pHandlerContext = &context;
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->padpnidTesters = padpnidDestroyTesters;
			} // end if (tester 0)
			else
			{
				dwSubInputDataSize = sizeof (TID_BBLDDP8_CS_DESTROY_NOT0);
				LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
				((PTID_BBLDDP8_CS_DESTROY_NOT0) pvSubInputData)->pDP8Client = pDP8Client;
			} // end else (not tester 0)

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.2.2",
														pvSubInputData,
														dwSubInputDataSize,
														(pTNecd->dwNumMachines - context.iNumClosers),
														paiDestroyTesters);

			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			SAFE_LOCALFREE(padpnidDestroyTesters);

			LocalFree(paiDestroyTesters);
			paiDestroyTesters = NULL;

			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog,  "Couldn't execute sub test case BldSsn:BldCS:Destroy!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.2",
										"Destroying client/server session failed!");



			if (pTNecd->iTesterNum == 0)
			{
				pDP8Server->m_dwRefCount--;
				if (pDP8Server->m_dwRefCount == 0)
				{
					DPTEST_TRACE(hLog, "Deleting server wrapper object %x.", 1, pDP8Server);
					delete (pDP8Server);
				} // end if (can delete the object)
				else
				{
					DPTEST_TRACE(hLog,  "WARNING: Can't delete server wrapper object %x, it's refcount is %u!?",
						2, pDP8Server, pDP8Server->m_dwRefCount);
				} // end else (can't delete the object)
				pDP8Server = NULL;
			} // end if (tester 0)
			else
			{
				pDP8Client->m_dwRefCount--;
				if (pDP8Client->m_dwRefCount == 0)
				{
					DPTEST_TRACE(hLog, "Deleting client wrapper object %x.", 1, pDP8Client);
					delete (pDP8Client);
				} // end if (can delete the object)
				else
				{
					DPTEST_TRACE(hLog,  "WARNING: Can't delete client wrapper object %x, it's refcount is %u!?",
						2, pDP8Client, pDP8Client->m_dwRefCount);
				} // end else (can't delete the object)
				pDP8Client = NULL;
			} // end else (not tester 0)
		} // end else (not tester 1)
		TESTSECTION_ENDIF



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pFaultSim != NULL)
	{
		temphr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
		if (temphr != S_OK)
		{
			DPTEST_FAIL(hLog,  "Couldn't release fault sim %x!  0x%08x", 2, pFaultSim, temphr);
			
			OVERWRITE_SR_IF_OK(temphr);

			pFaultSim = NULL;
		} // end if (couldn't remove handler)
	} // end if (have fault sim)

	if (pDP8Server != NULL)
	{
		temphr = pDP8Server->DP8S_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing DirectPlay8Server interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing server interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8ServersList->RemoveFirstReference(pDP8Server);


		pDP8Server->m_dwRefCount--;
		if (pDP8Server->m_dwRefCount == 0)
		{
			DPTEST_TRACE(hLog, "Deleting DirectPlay8Server wrapper object %x.", 1, pDP8Server);
			delete (pDP8Server);
		} // end if (can delete the object)
		else
		{
			DPTEST_TRACE(hLog,  "WARNING: Can't delete DirectPlay8Server wrapper object %x, it's refcount is %u!?",
				2, pDP8Server, pDP8Server->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		temphr = pDP8Client->DP8C_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing DirectPlay8Client interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing client interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8ClientsList->RemoveFirstReference(pDP8Client);


		pDP8Client->m_dwRefCount--;
		if (pDP8Client->m_dwRefCount == 0)
		{
			DPTEST_TRACE(hLog, "Deleting DirectPlay8Client wrapper object %x.", 1, pDP8Client);
			delete (pDP8Client);
		} // end if (can delete the object)
		else
		{
			DPTEST_TRACE(hLog,  "WARNING: Can't delete DirectPlay8Client wrapper object %x, it's refcount is %u!?",
				2, pDP8Client, pDP8Client->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Client = NULL;
	} // end if (have client object)

	SAFE_LOCALFREE(padpnidDestroyTesters);
	SAFE_LOCALFREE(paiDestroyTesters);
	SAFE_LOCALFREE(context.pafTesterIndicated);
	SAFE_LOCALFREE(dpnbd.pBufferData);
	SAFE_LOCALFREE(pvSubInputData);

	DeleteCriticalSection(&(context.csStatsLock));

	return (sr);
} // SendsExec_PendingCS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/




#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendsSimpleDPNMessageHandler()"
//==================================================================================
// SendsSimpleDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT SendsSimpleDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PSENDSSIMPLECONTEXT		pContext = (PSENDSSIMPLECONTEXT) pvContext;
	DWORD					dwMsgNum, dwTemp;


	switch (dwMsgType)
	{
		case DPN_MSGID_RECEIVE:
			dwTemp = InterlockedIncrement((LPLONG) (&pContext->dwReceives));

#pragma TODO(vanceo, "Validate and count receives")
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			// Safely increment the number of player create messages we've received
			dwTemp = InterlockedIncrement((LPLONG) (&pContext->dwPlayersCreated));

			// If all the expected players have connected, then signal the main thread
			if(dwTemp == pContext->dwPlayersExpected)
			{
				if(!SetEvent(pContext->hbsccAllPlayersCreated))
				{
					DPTEST_TRACE(pContext->hLog,  "SetEvent failed!  DEBUGBREAK()-ing.  0x%08x", 0);
					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				}
				DPTEST_TRACE(pContext->hLog,  "All %u expected players created", 1, dwTemp);
			}
			break;

		case DPN_MSGID_DESTROY_PLAYER:
			// Indicate that some players have left
			pContext->fPlayersHaveLeft = TRUE;
			break;

		case DPN_MSGID_ENUM_HOSTS_QUERY:
			DPTEST_TRACE(pContext->hLog,  "DPN_MSGID_ENUM_HOSTS_QUERY", 0);

#pragma TODO(vanceo, "Verify that we're tester 0, and then tell DNet to not respond")
		  break;

		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE	pSendCompleteMsg;


			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;

			dwMsgNum = (DWORD) ((DWORD_PTR) (pSendCompleteMsg->pvUserContext));


			if (pSendCompleteMsg->hResultCode != DPN_OK)
			{
				if ((! (pContext->fCancelling)) ||
					(pSendCompleteMsg->hResultCode != DPNERR_USERCANCEL))
				{
					DPTEST_TRACE(pContext->hLog,  "Send %u failed!  DEBUGBREAK()-ing.  0x%08x",
						2, dwMsgNum, pSendCompleteMsg->hResultCode);
					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				} // end if (not cancelling)

				// This is just a cancelled send, we're okay.
				DPTEST_TRACE(pContext->hLog, "Send %u was cancelled.  0x%08x",
					2, dwMsgNum, pSendCompleteMsg->hResultCode);
			} // end if (send failed)


			if (pContext->pabSendsCompleted[dwMsgNum])
			{
				DPTEST_TRACE(pContext->hLog,  "Getting duplicate send completion for send number %u!  DEBUGBREAK()-ing.",
					1, dwMsgNum);

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (send already completed)

			dwMsgNum = InterlockedDecrement((LPLONG) (&pContext->dwNumSendsNotCompleted));
			if (dwMsgNum == 0)
			{
				DPTEST_TRACE(pContext->hLog,  "All sends have completed notifying main thread.", 0);
				
				if (! SetEvent(pContext->hAllSendsCompletedEvent))
				{
					hr = GetLastError();

					DPTEST_TRACE(pContext->hLog,  "Couldn't set all sends completed event %x!  0x%08x",
						2, pContext->hAllSendsCompletedEvent, hr);
					
					if (hr == S_OK)
						hr = E_FAIL;

					//goto DONE;
				} // end if (couldn't set event)

				goto DONE;
			} // end if (last send)


			// Every 5 messages or so print out this update.
			if ((dwMsgNum % 25) == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Still %u messages remaining to be completed, not notifying main thread.",
					1, dwMsgNum);
				goto DONE;
			} // end if (not last message)
		  break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION	pTerminateSessionMsg;


			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;

			DPTEST_TRACE(pContext->hLog,  "WARNING: Ignoring unexpected TERMINATE_SESSION, this had better be because of a test failure!  0x%08x",
				1, pTerminateSessionMsg->hResultCode);
		  break;

		default:
//			DPTEST_TRACE(pContext->hLog,  "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);
			DPTEST_TRACE(pContext->hLog,  "Unexpected message type %x!  Do we need to handle this?", 1, dwMsgType);
//			DEBUGBREAK();

//			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // SendsSimpleDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




/* BUGBUG - no support for software disconnects
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendsPendingDPNMessageHandler()"
//==================================================================================
// SendsPendingDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT SendsPendingDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PSENDSPENDINGCONTEXT	pContext = (PSENDSPENDINGCONTEXT) pvContext;
	BOOL					fFound = FALSE;
	int						iNeedDestroyPlayer = -1;
	int						i;
	int						iLastTesterToCheck;


	switch (dwMsgType)
	{
		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER		pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			// Make sure it's an expected destroy player message.  Loop through
			// everyone if we're the closing player, or all the closing players if
			// we're remaining in the session.
			if (pContext->fClosingPlayer)
				iLastTesterToCheck = pContext->pTNecd->dwNumMachines - 1;
			else
				iLastTesterToCheck = pContext->iNumClosers;

			for(i = ((pContext->fClosingPlayer) ? 0 : 1); i <= iLastTesterToCheck; i++)
			{
				if (pDestroyPlayerMsg->dpnidPlayer == pContext->padpnidTesters[i])
				{
					if (pContext->pafTesterIndicated[i])
					{
						DPTEST_TRACE(pContext->hLog,  "Got duplicate DESTROY_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
							3, i, pDestroyPlayerMsg->dpnidPlayer,
							pDestroyPlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got duplicate DESTROY_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
														3, i, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (got duplicate indication)

					// Mark the player as gone now.
					pContext->pafTesterIndicated[i] = TRUE;
					fFound = TRUE;

					DPTEST_TRACE(pContext->hLog,  "Got DESTROY_PLAYER for expected ID %u/%x (tester %i), approximately %i relevant messages out of %u sent are still outstanding.",
						5, pDestroyPlayerMsg->dpnidPlayer,
						pDestroyPlayerMsg->dpnidPlayer,
						i,
						(int) (pContext->dwNumRelevantSends - (pContext->dwNumRelevantSendsCompletedSuccess + pContext->dwNumRelevantSendsCompletedFailure)),
						pContext->dwNumRelevantSends);
				} // end if (found destroy player target)
				else
				{
					// Keep track of all the indications so far so we can tell
					// if that's the last one necessary.
					if (! pContext->pafTesterIndicated[i])
						iNeedDestroyPlayer = i;
				} // end else (didn't find destroy player target)
			} // end for (each closing player)

			if (! fFound)
			{
				DPTEST_TRACE(pContext->hLog,  "WARNING: Ignoring unexpected DESTROY_PLAYER for ID %u/%x (expecting %u/%x), this had better be because of a test failure!",
					4, pDestroyPlayerMsg->dpnidPlayer,
					pDestroyPlayerMsg->dpnidPlayer,
					pContext->padpnidTesters[1],
					pContext->padpnidTesters[1]);
				goto DONE;
			} // end if (destroy player message wrong)

			if (iNeedDestroyPlayer > 0)
			{
				DPTEST_TRACE(pContext->hLog, "Still expecting tester %i (player ID %u/%x) to be destroyed, not notifying main thread.",
					2, iNeedDestroyPlayer, pDestroyPlayerMsg->dpnidPlayer,
					pDestroyPlayerMsg->dpnidPlayer);
				goto DONE;
			} // end if (got duplicate)


			DPTEST_TRACE(pContext->hLog,  "Got all expected DESTROY_PLAYERs, approximately %i relevant messages out of %u sent are still outstanding.",
				2, (int) (pContext->dwNumRelevantSends - (pContext->dwNumRelevantSendsCompletedSuccess + pContext->dwNumRelevantSendsCompletedFailure)),
				pContext->dwNumRelevantSends);

			pContext->fPlayersLeftOrDropped = TRUE;
		  break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			//pReceiveMsg->dwSize;
			//pReceiveMsg->dpnidSender;
			//pReceiveMsg->pvPlayerContext;
			//pReceiveMsg->hBufferHandle;

			pReceiveMsg->pReceiveData;

			// Make sure the size is right.
			if (pReceiveMsg->dwReceiveDataSize != pContext->dwMsgSize)
			{
				// Check to see if it's the special client/server destroy player
				// alert message.
				if ((pReceiveMsg->dwReceiveDataSize != sizeof (DWORD)) ||
					(*((DWORD*) pReceiveMsg->pReceiveData) != PENDINGSENDS_CS_DESTROYPLAYER_ID))
				{
					DPTEST_FAIL(pContext->hLog,  "Received incorrectly sized message from ID %u/%x (ptr = %x, size = %u, expected size = %u)!  DEBUGBREAK()-ing.",
						5, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender,
						pReceiveMsg->pReceiveData, pReceiveMsg->dwReceiveDataSize,
						pContext->dwMsgSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (not special message)


				// If it is the special message, act on it.

				DPTEST_TRACE(pContext->hLog,  "Server indicated leaving client(s) have left.", 0);
				pContext->fPlayersLeftOrDropped = TRUE;

				goto DONE;
			} // end if (size is not expected)

			// The size is right, make sure the data is too.
			if (! IsFilledWithDWord(pReceiveMsg->pReceiveData, pReceiveMsg->dwReceiveDataSize, SENDFILLPATTERN))
			{
				DPTEST_FAIL(pContext->hLog,  "Received invalid message from ID %u/%x (ptr = %x, size = %u)!  DEBUGBREAK()-ing.",
					4, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender,
					pReceiveMsg->pReceiveData, pReceiveMsg->dwReceiveDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not filled with DWORD)

			// If we got here, it's an expected message.  Cool.
		  break;

		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE	pSendCompleteMsg;


			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;


			// Lock the stats while we update them.
			EnterCriticalSection(&(pContext->csStatsLock));

			// The context was a boolean describing whether it's a relevant send or not.
			if (((BOOL) (INT_PTR) pSendCompleteMsg->pvUserContext))
			{
				if (pSendCompleteMsg->hResultCode != DPN_OK)
				{
//					DPTEST_TRACE(pContext->hLog, "Completion %x failure.  0x%08x",
//						2, pSendCompleteMsg->hAsyncOp, pSendCompleteMsg->hResultCode);

					pContext->dwNumRelevantSendsCompletedFailure++;
				} // end if (send failed)
				else
				{
					pContext->dwNumRelevantSendsCompletedSuccess++;
				} // end else (send succeeded)

				if ((int) (pContext->dwNumRelevantSends - (pContext->dwNumRelevantSendsCompletedSuccess + pContext->dwNumRelevantSendsCompletedFailure)) < 0)
				{
					DPTEST_TRACE(pContext->hLog,  "Got extra relevant completion ((%u - (%u + %u)) < 0)!  DEBUGBREAK()-ing.",
						3, pContext->dwNumRelevantSends,
						pContext->dwNumRelevantSendsCompletedSuccess,
						pContext->dwNumRelevantSendsCompletedFailure);
					// Ignore error
					pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
													"Got extra relevant completion ((%u - (%u + %u)) < 0)!  DEBUGBREAK()-ing.",
													3, pContext->dwNumRelevantSends,
													pContext->dwNumRelevantSendsCompletedSuccess,
													pContext->dwNumRelevantSendsCompletedFailure);
					DEBUGBREAK();
				} // end if (got too many completions)
			} // end if (relevant message)
			else
			{
				if (pSendCompleteMsg->hResultCode != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog,  "Irrelevant send failed!  DEBUGBREAK()-ing.  0x%08x",
						1, pSendCompleteMsg->hResultCode);
					// Ignore error
					pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
													"Send failed!  DEBUGBREAK()-ing.  0x%08x",
													1, pSendCompleteMsg->hResultCode);
					DEBUGBREAK();
				} // end if (send failed)
				else
				{
					pContext->dwNumIrrelevantSendsCompleted++;

					if ((int) (pContext->dwNumIrrelevantSends - pContext->dwNumIrrelevantSendsCompleted) < 0)
					{
						DPTEST_TRACE(pContext->hLog,  "Got extra irrelevant completion (%u - %u) < 0)!  DEBUGBREAK()-ing.",
							2, pContext->dwNumIrrelevantSends,
							pContext->dwNumIrrelevantSendsCompleted);
						// Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got extra irrelevant completion (%u - %u) < 0)!  DEBUGBREAK()-ing.",
														2, pContext->dwNumIrrelevantSends,
														pContext->dwNumIrrelevantSendsCompleted);
						DEBUGBREAK();
					} // end if (got too many completions)
				} // end else (send succeeded)
			} // end else (not relevant message)

			// Drop the stats lock.
			LeaveCriticalSection(&(pContext->csStatsLock));
		  break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION	pTerminateSessionMsg;


			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;

			if (! pContext->fClosingPlayer)
			{
				DPTEST_TRACE(pContext->hLog,  "WARNING: Ignoring unexpected TERMINATE_SESSION, this had better be because of a test failure!  0x%08x",
					1, pTerminateSessionMsg->hResultCode);
				goto DONE;
			} // end if (not dropping tester)
			else
			{
				if (pContext->fGotTerminateSession)
				{
					DPTEST_FAIL(pContext->hLog,  "Got duplicate TERMINATE_SESSION message!  DEBUGBREAK()-ing.", 0);

					//Ignore error
					pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
													"Got duplicate TERMINATE_SESSION message!  DEBUGBREAK()-ing.",
													0);

					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				} // end if (got duplicate)

				pContext->fGotTerminateSession = TRUE;


				// Client/server clients can only key off of TERMINATE_SESSION
				// messages (they won't get any DESTROY_PLAYERs).
				if ((pContext->pTNecd->pExecutor->IsCase("2.2.2.3")) ||
					(pContext->pTNecd->pExecutor->IsCase("2.2.2.4")))
				{
					pContext->fPlayersLeftOrDropped = TRUE;
				} // end if (client/server)
			} // end else (dropping tester)
		  break;

		default:
//			DPTEST_FAIL(pContext->hLog,  "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);
			DPTEST_TRACE(pContext->hLog,  "Unexpected message type %x!  Do we need to handle this?", 1, dwMsgType);
//			DEBUGBREAK();

//			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // SendsPendingDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\simpleconn.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"
#include "simpletests.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

#undef DEBUG_SECTION
#define DEBUG_SECTION	"DirectPlayExec_SimpleConnect()"

//==================================================================================
// DirectPlayExec_SimpleConnect
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//
// Arguments:
//     HANDLE hLog                     Handle to the logging subsystem
//     PDP_HOSTINFO pHostInfo          Pointer to info on which machine is host
//     WORD LowPort                    Port that session will be hosted on 
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT DirectPlayExec_SimpleConnect(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer1 = NULL, pDP8Peer2 = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	DPN_APPLICATION_DESC	dpnad, *pdpnad = NULL;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_BUFFER_DESC			dpnbd;
	DPN_BUFFER_DESC			dpnbdCompare;
	DPN_PLAYER_INFO			dpnpi, *pdpnpiHost;
	DPN_PLAYER_INFO			dpnpiCompare;
	DPN_CONNECTION_INFO		dpnci;
	DPN_SP_CAPS				dpnspc;
	DPN_CAPS				dpnc;
	DP_DOWORKLIST			DoWorkList;
	SIMPLEPEERCONTEXT		SimplePeerContext1, SimplePeerContext2;
	DWORD					i, dwNumIDs, dwHostDataSize, dwChecksum, dwAppDescSize, dwNumMsgs, dwNumBytes, dwTemp;
	PPLAYERCONTEXT			pLocalPlayerContext = NULL, pTempContext = NULL;
	DPNHANDLE				dpnhSendTo;
	DPNID					SendTarget, *pCurrentPlayers = NULL;
	MESSAGEDATA				MessageData, *pHostData = NULL, *pAppReservedData = NULL;
	SOCKADDR_IN				HostAddress;
	PVOID					pCurrentPlayerContext = NULL;

	// Initialize the two peer contexts
	ZeroMemory(&SimplePeerContext1, sizeof(SIMPLEPEERCONTEXT));
	InitializeCriticalSection(&(SimplePeerContext1.Lock));
	ZeroMemory(&SimplePeerContext2, sizeof(SIMPLEPEERCONTEXT));
	InitializeCriticalSection(&(SimplePeerContext2.Lock));

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer1 = new CWrapDP8Peer(hLog);
		if (pDP8Peer1 == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer1->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating host DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressHost, NULL);

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate host DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (CoCreate failed)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating device DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate device DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (CoCreate failed)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SimplePeerContext1.hLog = hLog;
		strcpy(SimplePeerContext1.szContextDescription, "LocalPlayer1");
		SimplePeerContext1.fVerbose = FALSE;
		SimplePeerContext1.LocalPlayerID = 0;
		CREATEEVENT_OR_THROW(SimplePeerContext1.hConnectComplete, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext1.hIndicateRemotePlayer, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext1.hReceiveData, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext1.hAsyncOpCompleted, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext1.hHostInfoChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext1.hAppDescChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext1.hSessionTerminated, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer1->DP8P_Initialize(&SimplePeerContext1, SimplePeerMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting remote address and port to host machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		HostAddress.sin_family = AF_INET;
//		HostAddress.sin_port = htons(LowPort);
		HostAddress.sin_port = htons(2302);
		HostAddress.sin_addr.S_un.S_addr = pHostInfo->dwHostAddr;

		// BUGBUG - hardcode address of host machine
		tr = pDP8AddressHost->BuildFromSockAddr((SOCKADDR *) &HostAddress);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set port for non-host.", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting initial peer information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		// Copy the player buffer
		strncpy(MessageData.szData, PEER_DATA1, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = PEER_PLAYER_NAME1;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		SimplePeerContext1.fAsyncOpCanComplete = TRUE;
		SimplePeerContext1.fAsyncOpCompleted = FALSE;
		SimplePeerContext1.hrAsyncOpExpectedResult = S_OK;
		SimplePeerContext1.dpnhAsyncOp = (DPNHANDLE) 0x666;

		tr = pDP8Peer1->DP8P_SetPeerInfo(&dpnpi, NULL, &(SimplePeerContext1.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetPeerInfo completed synchronously", 0);
			SetEvent(SimplePeerContext1.hAsyncOpCompleted);
			SimplePeerContext1.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimplePeerContext1.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimplePeerContext1.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for initial set peer info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Set up DoWork time parameters
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = TRUE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer1->m_pDP8Peer;
		DoWorkList.apdwPeerCallbackTimes = (DWORD **) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apdwPeerCallbackTimes[0] = &(SimplePeerContext1.dwCallbackTime);

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing asynchronous operation completion
		SimplePeerContext1.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimplePeerContext1.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set peer info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimplePeerContext1.fAsyncOpCompleted = FALSE;
		SimplePeerContext1.dpnhAsyncOp = NULL;

/*		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to host w/o connect data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// BUGBUG - if connection fails, will buffer be released?

		// Allocate a local player context
		LOCALALLOC_OR_THROW(PPLAYERCONTEXT, pLocalPlayerContext, sizeof(PLAYERCONTEXT));

		// Allow connection completions but only for host rejection
		SimplePeerContext1.fConnectCanComplete = TRUE;
		SimplePeerContext1.fConnectCompleted = FALSE;
		SimplePeerContext1.hrExpectedConnectResult = DPNERR_HOSTREJECTEDCONNECTION;
		
		// The host should reject this connection so we shouldn't
		// get remote player creations or incoming messages
		SimplePeerContext1.dwExpectedRemotePlayers = 0;
		SimplePeerContext1.dwCurrentRemotePlayers = 0;

		SimplePeerContext1.dpnhConnect = 0x666;

		tr = pDP8Peer1->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									NULL,
									0,
									pLocalPlayerContext,
									NULL,
									&(SimplePeerContext1.dpnhConnect),
									0);

		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (SimplePeerContext1.dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (SimplePeerContext1.dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connection completion to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Since this connection should have failed, we can release the local player context
		SAFE_LOCALFREE(pLocalPlayerContext);

		// Stop allowing connections
		SimplePeerContext1.fConnectCanComplete = FALSE;

		// If the connection didn't complete, then we're in trouble
		if(!SimplePeerContext1.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection completed)
	
		SimplePeerContext1.fConnectCompleted = FALSE;

// BUGBUG - For now, we have to all DoWork until it returns S_FALSE
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Calling DoWork to clean up failed connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		dwTemp = 0;
		while(dwTemp < 50)
		{
			++dwTemp;
			if(pDP8Peer1->m_pDP8Peer->DoWork(0) == S_FALSE)
				break;
		}
		
		if(dwTemp >= 50)
		{
			DPTEST_FAIL(hLog, "Couldn't clear failed connection with %u DoWork calls!", 1, dwTemp);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		else
		{
			DPTEST_TRACE(hLog, "Cleared failed connection with %u DoWork calls!", 1, dwTemp);
		}
*/
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to host machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Allocate a local player context.  Callback will deallocate on destroy player message
		pLocalPlayerContext = NULL;
		LOCALALLOC_OR_THROW(PPLAYERCONTEXT, pLocalPlayerContext, sizeof(PLAYERCONTEXT));

		SimplePeerContext1.fVerbose ?
			DPTEST_TRACE(hLog, "Buffer at 0x%08x allocated for local player context.", 1, pLocalPlayerContext) : 0;

		// Copy the player buffer
		strncpy(MessageData.szData, CONNECT_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = CONNECT_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Allow successful connection completions
		SimplePeerContext1.fConnectCanComplete = TRUE;
		SimplePeerContext1.fConnectCompleted = FALSE;
		SimplePeerContext1.hrExpectedConnectResult = S_OK;
		
		// Allow remote player creations
		SimplePeerContext1.dwExpectedRemotePlayers = 1;
		SimplePeerContext1.dwCurrentRemotePlayers = 0;

		// Allow incoming messages
		SimplePeerContext1.dwCurrentReceives = 0;
		SimplePeerContext1.dwExpectedReceives = SEND_COUNT;

		SimplePeerContext1.dpnhConnect = 0x666;

		tr = pDP8Peer1->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									&MessageData,
									sizeof(MESSAGEDATA),
									pLocalPlayerContext,
									NULL,
									&(SimplePeerContext1.dpnhConnect),
									0);

		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (SimplePeerContext1.dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (SimplePeerContext1.dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connection completion to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing connections
		SimplePeerContext1.fConnectCanComplete = FALSE;

		// If the connection didn't complete, then we're in trouble
		if(!SimplePeerContext1.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection completed)
	
		SimplePeerContext1.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for remote player to be created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hIndicateRemotePlayer))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get a remote player creation, then we're in trouble
		if(SimplePeerContext1.dwCurrentRemotePlayers != SimplePeerContext1.dwExpectedRemotePlayers)
		{
			DPTEST_FAIL(hLog, "Only %u remote players connected, %u were expected!",
				2, SimplePeerContext1.dwCurrentRemotePlayers, SimplePeerContext1.dwExpectedRemotePlayers);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for messages from remote player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get an incoming message, then we're in trouble
		if(SimplePeerContext1.dwCurrentReceives != SimplePeerContext1.dwExpectedReceives)
		{
			DPTEST_FAIL(hLog, "Only received %u messages, %u were expected!",
				2, SimplePeerContext1.dwCurrentReceives, SimplePeerContext1.dwExpectedReceives);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		// Stop allowing incoming messages
		SimplePeerContext1.dwCurrentReceives = 0;
		SimplePeerContext1.dwExpectedReceives = 0;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerate players");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwNumIDs = 0;

		tr = pDP8Peer1->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming players with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		LOCALALLOC_OR_THROW(PDPNID, pCurrentPlayers, dwNumIDs * sizeof(DPNID));

		tr = pDP8Peer1->DP8P_EnumPlayersAndGroups(pCurrentPlayers, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players with valid buffer didn't return success!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify player contexts");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Validate each player in the enumeration
		for(i = 0; i < dwNumIDs; ++i)
		{
			for(pTempContext = SimplePeerContext1.pPlayerList; pTempContext; pTempContext = pTempContext->pNext)
			{
				if(pTempContext->PlayerID == pCurrentPlayers[i])
					break;
			}

			if(!pTempContext)
			{
				DPTEST_FAIL(hLog, "Enumerated player 0x%08x wasn't found in our local list", 0, pCurrentPlayers[i]);
				THROW_TESTRESULT;
			}

			tr = pDP8Peer1->DP8P_GetPlayerContext(pCurrentPlayers[i], &pCurrentPlayerContext, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get player context for player 0x%08x",
					1, pCurrentPlayers[i]);
				THROW_TESTRESULT;
			} // end if (couldn't enum players and groups)

			if(pTempContext != pCurrentPlayerContext)
			{
				DPTEST_FAIL(hLog, "Context returned for player 0x%08x was incorrect (0x%08x != 0x%08x)",
					3, pCurrentPlayers[i], pTempContext, pCurrentPlayerContext);
				THROW_TESTRESULT;
			}

			DPTEST_TRACE(hLog, "Successfully retreived player context for player 0x%08x",
				1, pCurrentPlayers[i]);
		}

		DPTEST_TRACE(hLog, "Found all %u players in our local list", 0, dwNumIDs);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Identify the host player as the send target");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		EnterCriticalSection(&(SimplePeerContext1.Lock));

		// Find the first non-local player and set them as the send target
		SendTarget = 0;
		for(pTempContext = SimplePeerContext1.pPlayerList; pTempContext && !SendTarget; pTempContext = pTempContext->pNext)
		{
			if(pTempContext->PlayerID != SimplePeerContext1.LocalPlayerID)
				SendTarget = pTempContext->PlayerID;
		}

		LeaveCriticalSection(&(SimplePeerContext1.Lock));

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify host info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwHostDataSize = 0;
		pdpnpiHost = NULL;

		tr = pDP8Peer1->DP8P_GetPeerInfo(SendTarget, NULL, &dwHostDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting host info with NULL buffer on peer-non-host didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get host info)

		if(dwHostDataSize < sizeof(DPN_PLAYER_INFO))
		{
				DPTEST_FAIL(hLog, "Buffer allocation is too small for structure", 0);
				SETTHROW_TESTRESULT(E_FAIL);
		}

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiHost, dwHostDataSize);
		pdpnpiHost->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8Peer1->DP8P_GetPeerInfo(SendTarget, pdpnpiHost, &dwHostDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting host info with valid buffer on peer-non-host didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get host info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiHost->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiHost->pwszName, HOST_PLAYER_NAME1))
		{
			DPTEST_FAIL(hLog, "Unexpected host player name! (\"%S\" != \"%S\")",
				2, pdpnpiHost->pwszName, HOST_PLAYER_NAME1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiHost->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received host data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiHost->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pHostData = NULL;
		if(!(pHostData = (PMESSAGEDATA) pdpnpiHost->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pHostData->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pHostData->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pHostData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received host info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pHostData->szData, HOST_DATA1))
		{
			DPTEST_FAIL(hLog, "Unexpected host player data! (\"%s\" != \"%s\")",
				2, pHostData->szData, HOST_DATA1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiHost);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check send queue before sending");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumMsgs = dwNumBytes = 0x666;

		tr = pDP8Peer1->DP8P_GetSendQueueInfo(SendTarget, &dwNumMsgs, &dwNumBytes, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get send queue info!", 0);
			THROW_TESTRESULT;
		}

		// Verify that no data is in the send queue
		if(dwNumMsgs || dwNumBytes)
		{
			DPTEST_FAIL(hLog, "Send queue shows backlog, but no data has been sent (%u/%u)",
				2, dwNumMsgs, dwNumBytes);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info with new player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8Peer1->DP8P_GetConnectionInfo(SendTarget, &dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the service provider");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnspc, sizeof(DPN_SP_CAPS));
		dpnspc.dwSize = sizeof(DPN_SP_CAPS);

		tr = pDP8Peer1->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "Service provider caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnspc.dwFlags);
		DPTEST_TRACE(hLog, "     Number of threads: %u", 1, dpnspc.dwNumThreads);
		DPTEST_TRACE(hLog, "     Enum count: %u", 1, dpnspc.dwDefaultEnumCount);
		DPTEST_TRACE(hLog, "     Enum retry interval: %u", 1, dpnspc.dwDefaultEnumRetryInterval);
		DPTEST_TRACE(hLog, "     Enum timeout: %u", 1, dpnspc.dwDefaultEnumTimeout);
		DPTEST_TRACE(hLog, "     Max enum payload: %u", 1, dpnspc.dwMaxEnumPayloadSize);
		DPTEST_TRACE(hLog, "     Buffers per thread: %u", 1, dpnspc.dwBuffersPerThread);
		DPTEST_TRACE(hLog, "     System buffer size: %u", 1, dpnspc.dwSystemBufferSize);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of the service provider with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer1->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the DirectPlay");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnc, sizeof(DPN_CAPS));
		dpnc.dwSize = sizeof(DPN_CAPS);

		tr = pDP8Peer1->DP8P_GetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "DirectPlay caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnc.dwFlags);
		DPTEST_TRACE(hLog, "     Connect timeout: %u", 1, dpnc.dwConnectTimeout);
		DPTEST_TRACE(hLog, "     Connect retries: %u", 1, dpnc.dwConnectRetries);
		DPTEST_TRACE(hLog, "     Keepalive timeout: %u", 1, dpnc.dwTimeoutUntilKeepAlive);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of DirectPlay with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer1->DP8P_SetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send messages to the host player from first player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;

		SimplePeerContext1.fHostInfoCanChange = TRUE;
		SimplePeerContext1.fHostInfoChanged = FALSE;
		
		// Do SEND_COUNT sends
		for(i = 0; i < SEND_COUNT; ++i)
		{
			// Init these variables so we can see if they were modified
			dpnhSendTo = 0x666;
			CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
			
			tr = pDP8Peer1->DP8P_SendTo(SendTarget, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_GUARANTEED);
			
			if (tr != DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't send message!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't send message to self)
			
			if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			{
				DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
					2, &dpnbdCompare, &dpnbd);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (buffer desc changed)
			
			if (dpnhSendTo == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (dpnhSendTo == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for host to change information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hHostInfoChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing host info changes
		SimplePeerContext1.fHostInfoCanChange = FALSE;

		// If we didn't get a host info change, then we're in trouble
		if(!SimplePeerContext1.fHostInfoChanged)
		{
			DPTEST_FAIL(hLog, "Host info didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (host info didn't change)
	
		SimplePeerContext1.fHostInfoChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify new host info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwHostDataSize = 0;
		pdpnpiHost = NULL;

		tr = pDP8Peer1->DP8P_GetPeerInfo(SendTarget, NULL, &dwHostDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting host info with NULL buffer on peer-non-host didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get host info)

		if(dwHostDataSize < sizeof(DPN_PLAYER_INFO))
		{
				DPTEST_FAIL(hLog, "Buffer allocation is too small for structure", 0);
				SETTHROW_TESTRESULT(E_FAIL);
		}

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiHost, dwHostDataSize);
		pdpnpiHost->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8Peer1->DP8P_GetPeerInfo(SendTarget, pdpnpiHost, &dwHostDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting host info with valid buffer on peer-non-host didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get host info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiHost->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiHost->pwszName, HOST_PLAYER_NAME2))
		{
			DPTEST_FAIL(hLog, "Unexpected host player name! (\"%S\" != \"%S\")",
				2, pdpnpiHost->pwszName, HOST_PLAYER_NAME2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiHost->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received host data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiHost->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pHostData = NULL;
		if(!(pHostData = (PMESSAGEDATA) pdpnpiHost->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pHostData->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pHostData->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pHostData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received host info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pHostData->szData, HOST_DATA2))
		{
			DPTEST_FAIL(hLog, "Unexpected host player data! (\"%s\" != \"%s\")",
				2, pHostData->szData, HOST_DATA2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiHost);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Change peer information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, PEER_DATA2, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = PEER_PLAYER_NAME2;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		SimplePeerContext1.fAsyncOpCanComplete = TRUE;
		SimplePeerContext1.fAsyncOpCompleted = FALSE;
		SimplePeerContext1.hrAsyncOpExpectedResult = S_OK;
		SimplePeerContext1.dpnhAsyncOp = (DPNHANDLE) 0x666;

		// Be ready for incoming app desc change message
		// Because host will change it after non-host peer changes player info
		SimplePeerContext1.fAppDescCanChange = TRUE;
		SimplePeerContext1.fAppDescChanged = FALSE;

		tr = pDP8Peer1->DP8P_SetPeerInfo(&dpnpi, NULL, &(SimplePeerContext1.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetPeerInfo completed synchronously", 0);
			SetEvent(SimplePeerContext1.hAsyncOpCompleted);
			SimplePeerContext1.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimplePeerContext1.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimplePeerContext1.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for set peer info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing asynchronous operation completions
		SimplePeerContext1.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimplePeerContext1.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set peer info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimplePeerContext1.fAsyncOpCompleted = FALSE;
		SimplePeerContext1.dpnhAsyncOp = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc change indication");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hAppDescChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// If we didn't get an app desc change, then we're in trouble
		if(!SimplePeerContext1.fAppDescChanged)
		{
			DPTEST_FAIL(hLog, "App desc didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (app desc didn't change)
	
		SimplePeerContext1.fAppDescChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify current application description");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		dwAppDescSize = 0;
		pdpnad = NULL;

		tr = pDP8Peer1->DP8P_GetApplicationDesc(NULL, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer on non-host peer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if(dwAppDescSize < sizeof(DPN_APPLICATION_DESC))
		{
				DPTEST_FAIL(hLog, "Buffer allocation is too small for structure", 0);
				SETTHROW_TESTRESULT(E_FAIL);
		}

		LOCALALLOC_OR_THROW(PDPN_APPLICATION_DESC, pdpnad, dwAppDescSize);
		pdpnad->dwSize = sizeof(DPN_APPLICATION_DESC);

		tr = pDP8Peer1->DP8P_GetApplicationDesc(pdpnad, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc with valid buffer on non-host peer didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		//
		// Verify the data in the new app desc
		//

		if(pdpnad->dwMaxPlayers != 3)
		{
			DPTEST_FAIL(hLog, "New app desc has unexpected max player limit", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(!pdpnad->pwszSessionName)
		{
			DPTEST_FAIL(hLog, "Session name field wasn't set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(wcscmp(pdpnad->pwszSessionName, HOST_SESSION_NAME2))
		{
			DPTEST_FAIL(hLog, "New app desc has unexpected session name: %S",
				1, pdpnad->pwszSessionName);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pdpnad->pwszPassword)
			DPTEST_TRACE(hLog, "Password field was set as %S", 1, pdpnad->pwszPassword);
		else
			DPTEST_TRACE(hLog, "Password field wasn't set", 0);

		// Make sure we received enough data
		if(pdpnad->dwApplicationReservedDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received host data is too small! (\"%u\" < \"%u\")",
				2, pdpnad->dwApplicationReservedDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(!(pAppReservedData = (PMESSAGEDATA) pdpnad->pvApplicationReservedData))
		{
			DPTEST_FAIL(hLog, "No reserved data was provided with app desc", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pAppReservedData->dwMessageType != APP_DATA)
		{
			DPTEST_FAIL(hLog, "Received app desc data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		dwChecksum = 0;

		// Calculate the checksum from the message
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pAppReservedData->szData[i];
		
		// Compare it to the checksum listed in the message
		if(dwChecksum != pAppReservedData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received app desc data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(strcmp(pAppReservedData->szData, HOST_APP_DATA2))
		{
			DPTEST_FAIL(hLog, "Received app desc data has unexpected value", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnad);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8Peer1->DP8P_GetConnectionInfo(SendTarget, &dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating second local DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer2 = new CWrapDP8Peer(hLog);
		if (pDP8Peer2 == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer2->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing second peer with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SimplePeerContext2.hLog = hLog;
		strcpy(SimplePeerContext2.szContextDescription, "LocalPlayer2");
		SimplePeerContext2.fVerbose = FALSE;
		SimplePeerContext2.LocalPlayerID = 0;
		CREATEEVENT_OR_THROW(SimplePeerContext2.hConnectComplete, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext2.hIndicateRemotePlayer, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext2.hReceiveData, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext2.hAsyncOpCompleted, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext2.hHostInfoChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext2.hAppDescChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimplePeerContext2.hSessionTerminated, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer2->DP8P_Initialize(&SimplePeerContext2, SimplePeerMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting second async connect to host machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		dpnad.pwszPassword = HOST_PASSWORD2;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Allocate a local player context.  Callback will deallocate on destroy player message
		pLocalPlayerContext = NULL;
		LOCALALLOC_OR_THROW(PPLAYERCONTEXT, pLocalPlayerContext, sizeof(PLAYERCONTEXT));

		SimplePeerContext2.fVerbose ?
			DPTEST_TRACE(hLog, "Buffer at 0x%08x allocated for local player context.", 1, pLocalPlayerContext) : 0;

		// Copy the player buffer
		strncpy(MessageData.szData, CONNECT_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = CONNECT_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Allow successful connection completions
		SimplePeerContext2.fConnectCanComplete = TRUE;
		SimplePeerContext2.fConnectCompleted = FALSE;
		SimplePeerContext2.hrExpectedConnectResult = S_OK;
		
		// Allow remote player creations on both players
		SimplePeerContext2.dwExpectedRemotePlayers = 2;
		SimplePeerContext2.dwCurrentRemotePlayers = 0;
		SimplePeerContext1.dwExpectedRemotePlayers = 2;

		// Allow incoming messages
		SimplePeerContext2.dwCurrentReceives = 0;
		SimplePeerContext2.dwExpectedReceives = SEND_COUNT;

		SimplePeerContext2.dpnhConnect = 0x666;

		tr = pDP8Peer2->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									&MessageData,
									sizeof(MESSAGEDATA),
									pLocalPlayerContext,
									NULL,
									&(SimplePeerContext2.dpnhConnect),
									0);

		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start second async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (SimplePeerContext2.dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (SimplePeerContext2.dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connection completion to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Need to re-allocate the DoWork parameters
		ClearDoWorkList(&DoWorkList);

		// Set up new DoWork time parameters
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = TRUE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer1->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8Peer2->m_pDP8Peer;
		DoWorkList.apdwPeerCallbackTimes = (DWORD **) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apdwPeerCallbackTimes[0] = &(SimplePeerContext1.dwCallbackTime);
		DoWorkList.apdwPeerCallbackTimes[1] = &(SimplePeerContext2.dwCallbackTime);

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext2.hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing connections
		SimplePeerContext2.fConnectCanComplete = FALSE;

		// If the connection didn't complete, then we're in trouble
		if(!SimplePeerContext2.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection completed)
	
		SimplePeerContext2.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for new player to see remote players created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext2.hIndicateRemotePlayer))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get a remote player creation, then we're in trouble
		if(SimplePeerContext2.dwCurrentRemotePlayers != SimplePeerContext2.dwExpectedRemotePlayers)
		{
			DPTEST_FAIL(hLog, "Only %u remote players connected, %u were expected!",
				2, SimplePeerContext2.dwCurrentRemotePlayers, SimplePeerContext2.dwExpectedRemotePlayers);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for old player to see remote player created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hIndicateRemotePlayer))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get a remote player creation, then we're in trouble
		if(SimplePeerContext1.dwCurrentRemotePlayers != SimplePeerContext1.dwExpectedRemotePlayers)
		{
			DPTEST_FAIL(hLog, "Only %u remote players connected, %u were expected!",
				2, SimplePeerContext1.dwCurrentRemotePlayers, SimplePeerContext1.dwExpectedRemotePlayers);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for messages to second player from host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext2.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// If we didn't get an incoming message, then we're in trouble
		if(SimplePeerContext2.dwCurrentReceives != SimplePeerContext2.dwExpectedReceives)
		{
			DPTEST_FAIL(hLog, "Only received %u messages, %u were expected!",
				2, SimplePeerContext2.dwCurrentReceives, SimplePeerContext2.dwExpectedReceives);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		// Stop allowing incoming messages
		SimplePeerContext2.dwCurrentReceives = 0;
		SimplePeerContext2.dwExpectedReceives = 0;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send messages to the host player from the second player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;

		// Be ready for session termination because the host will do a DestroyPeer
		// on the first player when it receives this message from the second player
		SimplePeerContext1.fSessionCanTerminate = TRUE;
		SimplePeerContext1.fSessionTerminated = FALSE;

		// Also, be ready for session termination on second player because the host
		// will call terminate session after it destroys the first player
		SimplePeerContext2.fSessionCanTerminate = TRUE;
		SimplePeerContext2.fSessionTerminated = FALSE;

		// Do SEND_COUNT sends
		for(i = 0; i < SEND_COUNT; ++i)
		{
			// Init these variables so we can see if they were modified
			dpnhSendTo = 0x666;
			CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
			
			tr = pDP8Peer2->DP8P_SendTo(SendTarget, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_GUARANTEED);
			
			if (tr != DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't send message!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't send message to self)
			
			if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			{
				DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
					2, &dpnbdCompare, &dpnbd);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (buffer desc changed)
			
			if (dpnhSendTo == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (dpnhSendTo == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for first player to see session terminated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext1.hSessionTerminated))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing session termination messages
		SimplePeerContext1.fSessionCanTerminate = FALSE;

		// If we didn't get a session termination message, then we're in trouble
		if(!SimplePeerContext1.fSessionTerminated)
		{
			DPTEST_FAIL(hLog, "Session didn't terminate!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (session didn't terminate)
	
		SimplePeerContext1.fSessionTerminated = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second player to see session terminated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimplePeerContext2.hSessionTerminated))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing session termination messages
		SimplePeerContext2.fSessionCanTerminate = FALSE;

		// If we didn't get a session termination message, then we're in trouble
		if(!SimplePeerContext2.fSessionTerminated)
		{
			DPTEST_FAIL(hLog, "Session didn't terminate!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (session didn't terminate)
	
		SimplePeerContext2.fSessionTerminated = FALSE;

		//
		// Wait for 5 seconds
		//

		Sleep(5000);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing second peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer2->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing second DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer2->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		DPTEST_TRACE(hLog, "Releasing second peer wrapper", 0);
		delete (pDP8Peer2);
		pDP8Peer2 = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing first peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer1->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing first peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer1->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		DPTEST_TRACE(hLog, "Releasing first peer wrapper", 0);
		delete (pDP8Peer1);
		pDP8Peer1 = NULL;


		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer1 != NULL)
	{
		DPTEST_TRACE(hLog, "Releasing first peer wrapper", 0);
		delete (pDP8Peer1);
		pDP8Peer1 = NULL;
	} // end if (have peer object)

	if (pDP8Peer2 != NULL)
	{
		DPTEST_TRACE(hLog, "Releasing second peer wrapper", 0);
		delete (pDP8Peer2);
		pDP8Peer2 = NULL;
	} // end if (have peer object)

	DPTEST_TRACE(hLog, "Cleaning up test variables", 0);
	SAFE_RELEASE(pDP8AddressHost);
	SAFE_RELEASE(pDP8AddressDevice);
	SAFE_LOCALFREE(pCurrentPlayers);
	SAFE_LOCALFREE(pdpnpiHost);
	SAFE_LOCALFREE(pdpnad);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hConnectComplete);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hIndicateRemotePlayer);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hReceiveData);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hAsyncOpCompleted);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hHostInfoChanged);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hAppDescChanged);
	SAFE_CLOSEHANDLE(SimplePeerContext1.hSessionTerminated);
	DeleteCriticalSection(&(SimplePeerContext1.Lock));
	SAFE_CLOSEHANDLE(SimplePeerContext2.hConnectComplete);
	SAFE_CLOSEHANDLE(SimplePeerContext2.hIndicateRemotePlayer);
	SAFE_CLOSEHANDLE(SimplePeerContext2.hReceiveData);
	SAFE_CLOSEHANDLE(SimplePeerContext2.hAsyncOpCompleted);
	SAFE_CLOSEHANDLE(SimplePeerContext2.hHostInfoChanged);
	SAFE_CLOSEHANDLE(SimplePeerContext2.hAppDescChanged);
	SAFE_CLOSEHANDLE(SimplePeerContext2.hSessionTerminated);
	DeleteCriticalSection(&(SimplePeerContext2.Lock));


	return (sr);
} // DirectPlayExec_SimpleConnect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SimplePeerMessageHandler()"
//==================================================================================
// SimplePeerMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT SimplePeerMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT				hr = DPN_OK;
	PSIMPLEPEERCONTEXT	pContext = (PSIMPLEPEERCONTEXT) pvContext;
	BOOL				fLocalPlayer = TRUE;
	DWORD				dwStartTime = 0, dwEndTime = 0;

	dwStartTime = GetTickCount();
	
	if(pContext->fVerbose)
		DPTEST_TRACE(pContext->hLog, "Starting callback on %s's context", 1, pContext->szContextDescription);

	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;
			PPLAYERCONTEXT			pNewPlayerContext;

			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
			}

			// If this is a local player, then take the buffer that we allocated when we hosted
			// or connected
			if(pCreatePlayerMsg->pvPlayerContext)
			{
				fLocalPlayer = TRUE;

				pContext->LocalPlayerID = pCreatePlayerMsg->dpnidPlayer;
				pNewPlayerContext = ((PPLAYERCONTEXT) pCreatePlayerMsg->pvPlayerContext);
			}
			// Otherwise this is a remote player.  Create a new buffer.
			else
			{
				fLocalPlayer = FALSE;

				pNewPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
				if(!pNewPlayerContext)
				{
					DPTEST_TRACE(pContext->hLog, "Not enough memory to allocate player context!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}

				pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Buffer at 0x%08x allocated for remote player context.", 1, pNewPlayerContext) : 0;

				if(pContext->dwCurrentRemotePlayers >= pContext->dwExpectedRemotePlayers)
				{
					DPTEST_TRACE(pContext->hLog, "Unexpected remote player creation!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					break;
				}
				
				++(pContext->dwCurrentRemotePlayers);
			
				pCreatePlayerMsg->pvPlayerContext = pNewPlayerContext;
			}

			// Initialize the player information
			pNewPlayerContext->fLocalPlayer = fLocalPlayer;
			pNewPlayerContext->PlayerID = pCreatePlayerMsg->dpnidPlayer;
			pNewPlayerContext->TotalBytesReceived = 0;
			pNewPlayerContext->TotalMessagesReceived = 0;

			// BUGBUG - figure out why this player will be destroyed.  Need cases for the following
			// DPNDESTROYPLAYERREASON_NORMAL  - The player is being deleted for normal reasons. 
			// DPNDESTROYPLAYERREASON_CONNECTIONLOST - The connection was lost. 
			// DPNDESTROYPLAYERREASON_SESSIONTERMINATED - The session was terminated. 
			// DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER - The host called DestroyPeer
			pNewPlayerContext->dwExpectedDestroyReason = 0;

			// Add info on this player to our global player list
			EnterCriticalSection(&(pContext->Lock));

			pNewPlayerContext->pPrev = NULL;
			if(pContext->pPlayerList)
				pContext->pPlayerList->pPrev = pNewPlayerContext->pNext;
			pNewPlayerContext->pNext = pContext->pPlayerList;
			pContext->pPlayerList = pNewPlayerContext;

			++(pContext->dwPlayersConnected);

			LeaveCriticalSection(&(pContext->Lock));

			if(!fLocalPlayer)
			{
				if(pContext->dwCurrentRemotePlayers == pContext->dwExpectedRemotePlayers)
				{	
					// Signal the main thread that a player was created
					if (! SetEvent(pContext->hIndicateRemotePlayer))
					{
						hr = GetLastError();
						DPTEST_TRACE(pContext->hLog, "Couldn't set remote player indication event (%x)!  DEBUGBREAK()-ing.",
							1, pContext->hIndicateRemotePlayer);
						
						DEBUGBREAK();
						
						if (hr == S_OK)
							hr = E_FAIL;
						
						break;
					} // end if (couldn't set event)
				}
			}

		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;
			PPLAYERCONTEXT			pPlayerContext;
			CHAR					szReason[64];
			
			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pDestroyPlayerMsg->pvPlayerContext);
				
				switch(pDestroyPlayerMsg->dwReason)
				{
				case DPNDESTROYPLAYERREASON_NORMAL:
					strcpy(szReason, "NORMAL");
					break;
				case DPNDESTROYPLAYERREASON_CONNECTIONLOST:
					strcpy(szReason, "CONNECTIONLOST");
					break;
				case DPNDESTROYPLAYERREASON_SESSIONTERMINATED:
					strcpy(szReason, "SESSIONTERMINATED");
					break;
				case DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER:
					strcpy(szReason, "HOSTDESTROYEDPLAYER");
					break;
				default:
					DPTEST_TRACE(pContext->hLog, "Unknown player destroy reason! DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					break;
				}
				
				DPTEST_TRACE(pContext->hLog, "     dwReason = %s", 1, szReason);
			}
			
			pPlayerContext = (PPLAYERCONTEXT) pDestroyPlayerMsg->pvPlayerContext;

			if(!pPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "No player context received!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			// If this isn't the local player, then decrement the current number of remote players
			if(!pPlayerContext->fLocalPlayer)
			{
				if(!pContext->dwCurrentRemotePlayers)
				{
					DPTEST_TRACE(pContext->hLog, "Unexpected remote player destruction!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					break;
				}

				--(pContext->dwCurrentRemotePlayers);
			}

			// If we knew how the player was supposed to be destroyed
			if(pPlayerContext->dwExpectedDestroyReason &&
				(pPlayerContext->dwExpectedDestroyReason != pDestroyPlayerMsg->dwReason))
			{
				// Then verify that the way they were destroyed
				DPTEST_TRACE(pContext->hLog, "Player destroyed for unexpected reason! DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			// Remove this player from our global player list
			EnterCriticalSection(&(pContext->Lock));

			if(pPlayerContext->pNext)
				pPlayerContext->pNext->pPrev = pPlayerContext->pPrev;
			if(pPlayerContext->pPrev)
				pPlayerContext->pPrev->pNext = pPlayerContext->pNext;
			else
				pContext->pPlayerList = pPlayerContext->pNext;

			--pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));

			pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Freeing player context buffer: 0x%08x", 1, pPlayerContext) : 0;

			// Release the player context
			MemFree(pPlayerContext);

		break;
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
			PMESSAGEDATA pReplyData;
			DWORD dwChecksum;

			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = 0x%08x", 1, pConnectCompleteMsg->hAsyncOp);
				// BUGBUG - compare this with what was passed in to connect
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pConnectCompleteMsg->pvUserContext);
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
				DPTEST_TRACE(pContext->hLog, "     pvApplicationReplyData = 0x%08x", 1, pConnectCompleteMsg->pvApplicationReplyData);
				DPTEST_TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);
			}
			
			if(pConnectCompleteMsg->hAsyncOp != pContext->dpnhConnect)
			{
				DPTEST_TRACE(pContext->hLog, "Connection completed with different async handle!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			// Parse any reply data if present
			if(pReplyData = (PMESSAGEDATA) pConnectCompleteMsg->pvApplicationReplyData)
			{
				DWORD dwChecksum = 0;

				// Make sure we received enough data
				if(pConnectCompleteMsg->dwApplicationReplyDataSize < sizeof(MESSAGEDATA))
				{
					DPTEST_FAIL(pContext->hLog, "Received application reply data is too small! (\"%u\" < \"%u\")",
						2, pConnectCompleteMsg->dwApplicationReplyDataSize, sizeof(MESSAGEDATA));
					DEBUGBREAK();
					hr = E_FAIL;
				}
				// If the message is of valid size
				else
				{
					if(pReplyData->dwMessageType != CONNECT_REPLY_DATA)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data of invalid type!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}

					// Calculate the checksum from the message
					for(DWORD i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
						dwChecksum += pReplyData->szData[i];

					// Compare it to the checksum listed in the message
					if(dwChecksum != pReplyData->dwChecksum)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data failed checksum!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}

					pContext->fVerbose ?
						DPTEST_TRACE(pContext->hLog, "Connect reply data was : \"%s\"", 0, pReplyData->szData) : 0;
				}

			}

			if(!pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected connection indication!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			// Check to see if we got the expected result value
			if(pContext->hrExpectedConnectResult != pConnectCompleteMsg->hResultCode)
			{
				DPTEST_TRACE(pContext->hLog, "Received unexpected connection result (0x%08x != 0x%08x)  DEBUGBREAK()-ing.", 2,
					pContext->hrExpectedConnectResult, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
			}
			else
				pContext->fConnectCompleted = TRUE;

			
			// Signal the main thread that connection completed
			if (! SetEvent(pContext->hConnectComplete))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set connection indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hConnectComplete);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE pReceiveMsg;

			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReceiveMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pReceiveMsg->pvPlayerContext);
				// BUGBUG - create a common message format that contains the sender information
				// so that we can verify that this data is accurate
				DPTEST_TRACE(pContext->hLog, "     pReceiveData = 0x%08x", 1, pReceiveMsg->pReceiveData);
				DPTEST_TRACE(pContext->hLog, "     dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
				// BUGBUG - try holding onto this buffer and returning it on subsequent calls to receive
				// Use the buffer handle to return it later.  Maybe store the last buffer handle received
				// in the players context.
				DPTEST_TRACE(pContext->hLog, "     hBufferHandle = 0x%08x", 1, pReceiveMsg->hBufferHandle);
			}
			
			if(pContext->dwCurrentReceives >= pContext->dwExpectedReceives)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected incoming message!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			++(pContext->dwCurrentReceives);
			
			if(pContext->dwCurrentReceives == pContext->dwExpectedReceives)
			{
				// Signal the main thread that data was received
				if (! SetEvent(pContext->hReceiveData))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hReceiveData);
					
					DEBUGBREAK();
					
					if (hr == S_OK)
						hr = E_FAIL;
					
					break;
				} // end if (couldn't set event)
			}
			break;
		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE pSendCompleteMsg;

			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pSendCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of a send
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = 0x%08x", 1, pSendCompleteMsg->hAsyncOp);
				// BUGBUG - again check with the context and verify that this is the context that we
				// supplied with a call to send
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pSendCompleteMsg->pvUserContext);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pSendCompleteMsg->hResultCode);
				// BUGBUG - do lots of sends and see if this increases, what about guaranteed?
				DPTEST_TRACE(pContext->hLog, "     dwSendTime = %u ms", 1, pSendCompleteMsg->dwSendTime);
			}

			break;
		case DPN_MSGID_APPLICATION_DESC:
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_APPLICATION_DESC", 0);
			}

			if(!pContext->fAppDescCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected app desc change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fAppDescChanged = TRUE;
			
			// Signal the main thread that the app desc changed
			if (! SetEvent(pContext->hAppDescChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set app desc change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAppDescChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;

			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of an operation
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);
			}

			if(!pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected asynchronous operation completion!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			if(pContext->dpnhAsyncOp != pAsyncOpCompleteMsg->hAsyncOp)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completion has unexpected handle (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->dpnhAsyncOp, pAsyncOpCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			}

			if(pContext->hrAsyncOpExpectedResult != pAsyncOpCompleteMsg->hResultCode)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completed with unexpected result (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->hrAsyncOpExpectedResult, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			}

			pContext->fAsyncOpCompleted = TRUE;
			
			// Signal the main thread that an asynchronous operation completed
			if (! SetEvent(pContext->hAsyncOpCompleted))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompleted);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_PEER_INFO:
			PDPNMSG_PEER_INFO pPeerInfoMsg;

			pPeerInfoMsg = (PDPNMSG_PEER_INFO) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_PEER_INFO", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pPeerInfoMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPeer = %u/%x", 2, pPeerInfoMsg->dpnidPeer, pPeerInfoMsg->dpnidPeer);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pPeerInfoMsg->pvPlayerContext);
			}

			if(pContext->LocalPlayerID == pPeerInfoMsg->dpnidPeer)
			{
				DPTEST_TRACE(pContext->hLog, "Local players info changed", 0);
				break;
			}

			if(!pContext->fHostInfoCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected host info change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fHostInfoChanged = TRUE;
			
			// Signal the main thread that the host info changed
			if (! SetEvent(pContext->hHostInfoChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set host info change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hHostInfoChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;

			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pTerminateSessionMsg->dwSize);
				// BUGBUG - check the context and verify the difference between the host calling\
				// close and the host calling terminate session.
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pTerminateSessionMsg->hResultCode);
				// BUGBUG - check with the context and verify whether or not data should have been provided
				DPTEST_TRACE(pContext->hLog, "     pvTerminateData = 0x%08x", 1, pTerminateSessionMsg->pvTerminateData);
				DPTEST_TRACE(pContext->hLog, "     dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);
			}

			if(!pContext->fSessionCanTerminate)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected session termination!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fSessionTerminated = TRUE;
			
			// Signal the main thread that the session terminated
			if (! SetEvent(pContext->hSessionTerminated))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set session termination event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAppDescChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER pReturnBufferMsg;

			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RETURN_BUFFER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReturnBufferMsg->dwSize);
				// BUGBUG - in enum cases, this could be an error, otherwise, should be success
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
				DPTEST_TRACE(pContext->hLog, "     pvBuffer = 0x%08x", 1, pReturnBufferMsg->pvBuffer);
				// BUGBUG - this should probably only be set in concurrent enumeration cases
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pReturnBufferMsg->pvUserContext);
			}

			if(!pReturnBufferMsg->pvBuffer)
			{
				DPTEST_TRACE(pContext->hLog, "Return buffer message with invalid buffer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			MemFree(pReturnBufferMsg->pvBuffer);

			break;
		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	if(pContext->fVerbose)
		DPTEST_TRACE(pContext->hLog, "Ending callback on %s's context", 1, pContext->szContextDescription);

	dwEndTime = GetTickCount();

	pContext->dwCallbackTime += (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

	return (hr);
} // SimpleHostMessageHandler
#undef DEBUG_SECTION

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\simpleclient.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"
#include "simpletests.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

#undef DEBUG_SECTION
#define DEBUG_SECTION	"DirectPlayExec_SimpleClient()"

//==================================================================================
// DirectPlayExec_SimpleClient
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//
// Arguments:
//     HANDLE hLog                     Handle to the logging subsystem
//     PDP_HOSTINFO pHostInfo          Pointer to info on which machine is host
//                                     and which are clients
//     WORD LowPort                    Port that session will be hosted on 
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT DirectPlayExec_SimpleClient(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8CLIENT			pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	DPN_APPLICATION_DESC	dpnad, *pdpnad = NULL;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_BUFFER_DESC			dpnbd;
	DPN_BUFFER_DESC			dpnbdCompare;
	DPN_PLAYER_INFO			dpnpi, *pdpnpiServer = NULL;
	DPN_PLAYER_INFO			dpnpiCompare;
	DPN_CONNECTION_INFO		dpnci;
	DPN_SP_CAPS				dpnspc;
	DPN_CAPS				dpnc;
	DP_DOWORKLIST			DoWorkList;
	SIMPLECLIENTCONTEXT		SimpleClientContext;
	DWORD					i, dwNumIDs	,dwChecksum, dwAppDescSize, dwNumMsgs, dwNumBytes, dwServerDataSize;
	DPNHANDLE				dpnhSendTo;
	DPNID					SendTarget, *pCurrentPlayers = NULL;
	MESSAGEDATA				MessageData, *pServerData = NULL, *pAppReservedData = NULL;
	SOCKADDR_IN				ServerAddress;

	ZeroMemory(&SimpleClientContext, sizeof(SIMPLECLIENTCONTEXT));
	InitializeCriticalSection(&(SimpleClientContext.Lock));

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Client->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating host DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressHost, NULL);

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate host DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (CoCreate failed)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating device DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate device DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (CoCreate failed)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SimpleClientContext.hLog = hLog;
		SimpleClientContext.fVerbose = FALSE;
		SimpleClientContext.LocalPlayerID = 0;
		CREATEEVENT_OR_THROW(SimpleClientContext.hConnectComplete, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleClientContext.hIndicateRemotePlayer, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleClientContext.hReceiveData, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleClientContext.hAsyncOpCompleted, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleClientContext.hServerInfoChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleClientContext.hAppDescChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleClientContext.hSessionTerminated, NULL, FALSE, FALSE, NULL);

		tr = pDP8Client->DP8C_Initialize(&SimpleClientContext, SimpleClientMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DoWork on newly initialized client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->m_pDP8Client->DoWork(0);
		if((tr != S_OK) && (tr != S_FALSE))
		{
			DPTEST_FAIL(hLog, "DoWork on client just after initialization returned 0x%08x", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting remote address and port to host machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ServerAddress.sin_family = AF_INET;
//		ServerAddress.sin_port = htons(LowPort);
		ServerAddress.sin_port = htons(2302);
		ServerAddress.sin_addr.S_un.S_addr = pHostInfo->dwHostAddr;

		// BUGBUG - hardcode address of host machine
		tr = pDP8AddressHost->BuildFromSockAddr((SOCKADDR *) &ServerAddress);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set port for non-host.", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting initial client information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, CLIENT_DATA1, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = CLIENT_PLAYER_NAME1;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		SimpleClientContext.fAsyncOpCanComplete = TRUE;
		SimpleClientContext.fAsyncOpCompleted = FALSE;
		SimpleClientContext.hrAsyncOpExpectedResult = S_OK;
		SimpleClientContext.dpnhAsyncOp = (DPNHANDLE) 0x666;

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &(SimpleClientContext.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetClientInfo completed synchronously", 0);
			SetEvent(SimpleClientContext.hAsyncOpCompleted);
			SimpleClientContext.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimpleClientContext.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimpleClientContext.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for initial set client info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Set up DoWork time parameters
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = TRUE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = pDP8Client->m_pDP8Client;
		DoWorkList.apdwClientCallbackTimes = (DWORD **) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apdwClientCallbackTimes[0] = &(SimpleClientContext.dwCallbackTime);

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing asynchronous operation completions
		SimpleClientContext.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimpleClientContext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set client info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimpleClientContext.fAsyncOpCompleted = FALSE;
		SimpleClientContext.dpnhAsyncOp = NULL;

/* BUGBUG - remove until connect data and connect reply data are working
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to host w/o connect data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Allow connection completions but only for host rejection
		SimpleClientContext.fConnectCanComplete = TRUE;
		SimpleClientContext.fConnectCompleted = FALSE;
		SimpleClientContext.hrExpectedConnectResult = DPNERR_HOSTREJECTEDCONNECTION;
		
		// The host should reject this connection so we shouldn't
		// get remote player creations or incoming messages
		SimpleClientContext.fCanAcceptRemotePlayer = FALSE;
		SimpleClientContext.fAcceptedRemotePlayer = FALSE;
		SimpleClientContext.fCanReceive = TRUE;
		SimpleClientContext.fReceived = FALSE;

		SimpleClientContext.dpnhConnect = 0x666;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									&(SimpleClientContext.dpnhConnect),
									0);

		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (SimpleClientContext.dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (SimpleClientContext.dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connection completion to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing connections
		SimpleClientContext.fConnectCanComplete = FALSE;

		// If the connection didn't complete, then we're in trouble
		if(!SimpleClientContext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection completed)
	
		SimpleClientContext.fConnectCompleted = FALSE;

*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to host machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Copy the player buffer
		strncpy(MessageData.szData, CONNECT_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = CONNECT_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Allow successful connection completions
		SimpleClientContext.fConnectCanComplete = TRUE;
		SimpleClientContext.fConnectCompleted = FALSE;
		SimpleClientContext.hrExpectedConnectResult = S_OK;
		
		// Since this is a client, we don't get player indications
		// so we should give an error if we receive one
		SimpleClientContext.fCanAcceptRemotePlayer = FALSE;
		SimpleClientContext.fAcceptedRemotePlayer = FALSE;

		// Allow incoming messages
		SimpleClientContext.fCanReceive = TRUE;
		SimpleClientContext.fReceived = FALSE;

		SimpleClientContext.dpnhConnect = 0x666;

		tr = pDP8Client->DP8C_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									&MessageData,
									sizeof(MESSAGEDATA),
									NULL,
									&(SimpleClientContext.dpnhConnect),
									0);


		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (SimpleClientContext.dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (SimpleClientContext.dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connection completion to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hConnectComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing connections
		SimpleClientContext.fConnectCanComplete = FALSE;

		// If the connection didn't complete, then we're in trouble
		if(!SimpleClientContext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection completed)
	
		SimpleClientContext.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify server info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwServerDataSize = 0;
		pdpnpiServer = NULL;

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwServerDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting server info with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiServer, dwServerDataSize);
		pdpnpiServer->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8Client->DP8C_GetServerInfo(pdpnpiServer, &dwServerDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting server info with valid buffer on client didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiServer->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiServer->pwszName, SERVER_PLAYER_NAME1))
		{
			DPTEST_FAIL(hLog, "Unexpected server player name! (\"%S\" != \"%S\")",
				2, pdpnpiServer->pwszName, SERVER_PLAYER_NAME1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiServer->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received server data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiServer->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pServerData = NULL;
		if(!(pServerData = (PMESSAGEDATA) pdpnpiServer->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pServerData->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pServerData->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pServerData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received server info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pServerData->szData, SERVER_DATA1))
		{
			DPTEST_FAIL(hLog, "Unexpected server player data! (\"%s\" != \"%s\")",
				2, pServerData->szData, SERVER_DATA1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiServer);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for message from remote player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing incoming messages
		SimpleClientContext.fCanReceive = FALSE;

		// If we didn't get an incoming message, then we're in trouble
		if(!SimpleClientContext.fReceived)
		{
			DPTEST_FAIL(hLog, "No messages received!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		SimpleClientContext.fCanReceive = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check send queue before sending");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumMsgs = dwNumBytes = 0x666;

		tr = pDP8Client->DP8C_GetSendQueueInfo(&dwNumMsgs, &dwNumBytes, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get send queue info!", 0);
			THROW_TESTRESULT;
		}

		// Verify that no data is in the send queue
		if(dwNumMsgs || dwNumBytes)
		{
			DPTEST_FAIL(hLog, "Send queue shows backlog, but no data has been sent (%u/%u)",
				2, dwNumMsgs, dwNumBytes);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info with new player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the service provider");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnspc, sizeof(DPN_SP_CAPS));
		dpnspc.dwSize = sizeof(DPN_SP_CAPS);

		tr = pDP8Client->DP8C_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "Service provider caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnspc.dwFlags);
		DPTEST_TRACE(hLog, "     Number of threads: %u", 1, dpnspc.dwNumThreads);
		DPTEST_TRACE(hLog, "     Enum count: %u", 1, dpnspc.dwDefaultEnumCount);
		DPTEST_TRACE(hLog, "     Enum retry interval: %u", 1, dpnspc.dwDefaultEnumRetryInterval);
		DPTEST_TRACE(hLog, "     Enum timeout: %u", 1, dpnspc.dwDefaultEnumTimeout);
		DPTEST_TRACE(hLog, "     Max enum payload: %u", 1, dpnspc.dwMaxEnumPayloadSize);
		DPTEST_TRACE(hLog, "     Buffers per thread: %u", 1, dpnspc.dwBuffersPerThread);
		DPTEST_TRACE(hLog, "     System buffer size: %u", 1, dpnspc.dwSystemBufferSize);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of the service provider with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the DirectPlay");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnc, sizeof(DPN_CAPS));
		dpnc.dwSize = sizeof(DPN_CAPS);

		tr = pDP8Client->DP8C_GetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "DirectPlay caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnc.dwFlags);
		DPTEST_TRACE(hLog, "     Connect timeout: %u", 1, dpnc.dwConnectTimeout);
		DPTEST_TRACE(hLog, "     Connect retries: %u", 1, dpnc.dwConnectRetries);
		DPTEST_TRACE(hLog, "     Keepalive timeout: %u", 1, dpnc.dwTimeoutUntilKeepAlive);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of DirectPlay with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_SetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send a message to the host player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;

		// Init these variables so we can see if they were modified
		dpnhSendTo = 0x666;
		CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));

		// Once we send data to the server, it will change its player info
		// so be ready for that
		SimpleClientContext.fServerInfoCanChange = TRUE;
		SimpleClientContext.fServerInfoChanged = FALSE;

		tr = pDP8Client->DP8C_Send(&dpnbd, 1, 0, NULL, &dpnhSendTo, 0);

		if (tr != DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for server to change information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hServerInfoChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing server info changes
		SimpleClientContext.fServerInfoCanChange = FALSE;

		// If we didn't get a server info change, then we're in trouble
		if(!SimpleClientContext.fServerInfoChanged)
		{
			DPTEST_FAIL(hLog, "Server info didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (server info didn't change)
	
		SimpleClientContext.fServerInfoChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify new server info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwServerDataSize = 0;
		pdpnpiServer = NULL;

		tr = pDP8Client->DP8C_GetServerInfo(NULL, &dwServerDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting server info with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiServer, dwServerDataSize);
		pdpnpiServer->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8Client->DP8C_GetServerInfo(pdpnpiServer, &dwServerDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting server info with valid buffer on client didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get server info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiServer->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiServer->pwszName, SERVER_PLAYER_NAME2))
		{
			DPTEST_FAIL(hLog, "Unexpected server player name! (\"%S\" != \"%S\")",
				2, pdpnpiServer->pwszName, SERVER_PLAYER_NAME2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiServer->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received server data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiServer->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pServerData = NULL;
		if(!(pServerData = (PMESSAGEDATA) pdpnpiServer->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pServerData->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pServerData->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pServerData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received server info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pServerData->szData, SERVER_DATA2))
		{
			DPTEST_FAIL(hLog, "Unexpected server player data! (\"%s\" != \"%s\")",
				2, pServerData->szData, SERVER_DATA2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiServer);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Change client information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, CLIENT_DATA2, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = CLIENT_PLAYER_NAME2;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		SimpleClientContext.fAsyncOpCanComplete = TRUE;
		SimpleClientContext.fAsyncOpCompleted = FALSE;
		SimpleClientContext.hrAsyncOpExpectedResult = S_OK;
		SimpleClientContext.dpnhAsyncOp = (DPNHANDLE) 0x666;

		// Be ready for incoming app desc change message
		// Because server will change it after client changes player info
		SimpleClientContext.fAppDescCanChange = TRUE;
		SimpleClientContext.fAppDescChanged = FALSE;

		tr = pDP8Client->DP8C_SetClientInfo(&dpnpi, NULL, &(SimpleClientContext.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetClientInfo completed synchronously", 0);
			SetEvent(SimpleClientContext.hAsyncOpCompleted);
			SimpleClientContext.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimpleClientContext.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimpleClientContext.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for set client info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing asynchronous operation completions
		SimpleClientContext.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimpleClientContext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set client info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimpleClientContext.fAsyncOpCompleted = FALSE;
		SimpleClientContext.dpnhAsyncOp = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc change indication");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hAppDescChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing app desc changes
		SimpleClientContext.fAppDescCanChange = FALSE;

		// If we didn't get an app desc change, then we're in trouble
		if(!SimpleClientContext.fAppDescChanged)
		{
			DPTEST_FAIL(hLog, "App desc didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (app desc didn't change)
	
		SimpleClientContext.fAppDescChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify current application description");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		dwAppDescSize = 0;
		pdpnad = NULL;

		tr = pDP8Client->DP8C_GetApplicationDesc(NULL, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		LOCALALLOC_OR_THROW(PDPN_APPLICATION_DESC, pdpnad, dwAppDescSize);
		pdpnad->dwSize = sizeof(DPN_APPLICATION_DESC);

		tr = pDP8Client->DP8C_GetApplicationDesc(pdpnad, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc with valid buffer on client didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		//
		// Verify the data in the new app desc
		//

		if(pdpnad->dwMaxPlayers != 3)
		{
			DPTEST_FAIL(hLog, "New app desc has unexpected max player limit", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(!pdpnad->pwszSessionName)
		{
			DPTEST_FAIL(hLog, "Session name field wasn't set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(wcscmp(pdpnad->pwszSessionName, SERVER_SESSION_NAME2))
		{
			DPTEST_FAIL(hLog, "New app desc has unexpected session name: %S",
				1, pdpnad->pwszSessionName);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pdpnad->pwszPassword)
			DPTEST_TRACE(hLog, "Password field was set as %S", 1, pdpnad->pwszPassword);
		else
			DPTEST_TRACE(hLog, "Password field wasn't set", 0);

		// Make sure we received enough data
		if(pdpnad->dwApplicationReservedDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received application data is too small! (\"%u\" < \"%u\")",
				2, pdpnad->dwApplicationReservedDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(!(pAppReservedData = (PMESSAGEDATA) pdpnad->pvApplicationReservedData))
		{
			DPTEST_FAIL(hLog, "No reserved data was provided with app desc", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pAppReservedData->dwMessageType != APP_DATA)
		{
			DPTEST_FAIL(hLog, "Received app desc data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		dwChecksum = 0;

		// Calculate the checksum from the message
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pAppReservedData->szData[i];
		
		// Compare it to the checksum listed in the message
		if(dwChecksum != pAppReservedData->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received app desc data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(strcmp(pAppReservedData->szData, SERVER_APP_DATA2))
		{
			DPTEST_FAIL(hLog, "Received app desc data has unexpected value", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnad);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8Client->DP8C_GetConnectionInfo(&dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send second message to the host player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;

		// Init these variables so we can see if they were modified
		dpnhSendTo = 0x666;
		CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));

		// Be ready for session termination because the server will do a DestroyClient
		// on us when it receives this message
		SimpleClientContext.fSessionCanTerminate = TRUE;
		SimpleClientContext.fSessionTerminated = FALSE;

		tr = pDP8Client->DP8C_Send(&dpnbd, 1, 0, NULL, &dpnhSendTo, 0);

		if (tr != DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for session to be terminated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleClientContext.hSessionTerminated))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing session termination messages
		SimpleClientContext.fSessionCanTerminate = FALSE;

		// If we didn't get a session termination message, then we're in trouble
		if(!SimpleClientContext.fSessionTerminated)
		{
			DPTEST_FAIL(hLog, "Session didn't terminate!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (session didn't terminate)
	
		SimpleClientContext.fSessionTerminated = FALSE;

		//
		// Wait for 5 seconds
		//

		Sleep(5000);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		DPTEST_TRACE(hLog, "Releasing client wrapper", 0);
		delete (pDP8Client);
		pDP8Client = NULL;


		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		DPTEST_TRACE(hLog, "Releasing client wrapper", 0);
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	DPTEST_TRACE(hLog, "Cleaning up test variables", 0);
	SAFE_RELEASE(pDP8AddressHost);
	SAFE_RELEASE(pDP8AddressDevice);
	SAFE_LOCALFREE(pCurrentPlayers);
	SAFE_LOCALFREE(pdpnpiServer);
	SAFE_LOCALFREE(pdpnad);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(SimpleClientContext.hConnectComplete);
	SAFE_CLOSEHANDLE(SimpleClientContext.hIndicateRemotePlayer);
	SAFE_CLOSEHANDLE(SimpleClientContext.hReceiveData);
	SAFE_CLOSEHANDLE(SimpleClientContext.hAsyncOpCompleted);
	SAFE_CLOSEHANDLE(SimpleClientContext.hServerInfoChanged);
	SAFE_CLOSEHANDLE(SimpleClientContext.hAppDescChanged);
	SAFE_CLOSEHANDLE(SimpleClientContext.hSessionTerminated);
	DeleteCriticalSection(&(SimpleClientContext.Lock));


	return (sr);
} // DirectPlayExec_SimpleClient
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SimpleClientMessageHandler()"
//==================================================================================
// SimpleClientMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT SimpleClientMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT				hr = DPN_OK;
	PSIMPLECLIENTCONTEXT	pContext = (PSIMPLECLIENTCONTEXT) pvContext;
	BOOL				fLocalPlayer = TRUE;
	DWORD				dwStartTime = 0, dwEndTime = 0;

	dwStartTime = GetTickCount();

	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;
			PPLAYERCONTEXT			pNewPlayerContext;

			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
			}

			// If this is a local player, then take the buffer that we allocated when we hosted
			// or connected
			if(pCreatePlayerMsg->pvPlayerContext)
			{
				fLocalPlayer = TRUE;

				pContext->LocalPlayerID = pCreatePlayerMsg->dpnidPlayer;
				pNewPlayerContext = ((PPLAYERCONTEXT) pCreatePlayerMsg->pvPlayerContext);
			}
			// Otherwise this is a remote player.  Create a new buffer.
			else
			{
				fLocalPlayer = FALSE;

				pNewPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
				if(!pNewPlayerContext)
				{
					DPTEST_TRACE(pContext->hLog, "Not enough memory to allocate player context!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}

				if(!pContext->fCanAcceptRemotePlayer)
				{
					DPTEST_TRACE(pContext->hLog, "Unexpected remote player creation!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					break;
				}

				pCreatePlayerMsg->pvPlayerContext = pNewPlayerContext;
			}

			// Initialize the player information
			pNewPlayerContext->PlayerID = pCreatePlayerMsg->dpnidPlayer;
			pNewPlayerContext->TotalBytesReceived = 0;
			pNewPlayerContext->TotalMessagesReceived = 0;

			// BUGBUG - figure out why this player will be destroyed.  Need cases for the following
			// DPNDESTROYPLAYERREASON_NORMAL  - The player is being deleted for normal reasons. 
			// DPNDESTROYPLAYERREASON_CONNECTIONLOST - The connection was lost. 
			// DPNDESTROYPLAYERREASON_SESSIONTERMINATED - The session was terminated. 
			// DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER - The host called DestroyPeer
			pNewPlayerContext->dwExpectedDestroyReason = 0;

			// Add info on this player to our global player list
			EnterCriticalSection(&(pContext->Lock));

			pNewPlayerContext->pPrev = NULL;
			if(pContext->pPlayerList)
				pContext->pPlayerList->pPrev = pNewPlayerContext->pNext;
			pNewPlayerContext->pNext = pContext->pPlayerList;
			pContext->pPlayerList = pNewPlayerContext;

			++pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));

			if(!fLocalPlayer)
			{
				pContext->fAcceptedRemotePlayer = TRUE;
				
				// Signal the main thread that a player was created
				if (! SetEvent(pContext->hIndicateRemotePlayer))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set remote player indication event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hIndicateRemotePlayer);
					
					DEBUGBREAK();
					
					if (hr == S_OK)
						hr = E_FAIL;
					
					break;
				} // end if (couldn't set event)
				
			}

		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;
			PPLAYERCONTEXT			pPlayerContext;
			CHAR					szReason[64];

			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pDestroyPlayerMsg->pvPlayerContext);
				
				switch(pDestroyPlayerMsg->dwReason)
				{
				case DPNDESTROYPLAYERREASON_NORMAL:
					strcpy(szReason, "NORMAL");
					break;
				case DPNDESTROYPLAYERREASON_CONNECTIONLOST:
					strcpy(szReason, "CONNECTIONLOST");
					break;
				case DPNDESTROYPLAYERREASON_SESSIONTERMINATED:
					strcpy(szReason, "SESSIONTERMINATED");
					break;
				case DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER:
					strcpy(szReason, "HOSTDESTROYEDPLAYER");
					break;
				default:
					DPTEST_TRACE(pContext->hLog, "Unknown player destroy reason! DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					break;
				}
				
				DPTEST_TRACE(pContext->hLog, "     dwReason = %s", 1, szReason);
			}
			
			pPlayerContext = (PPLAYERCONTEXT) pDestroyPlayerMsg->pvPlayerContext;

			if(!pPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "No player context received!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			// If we knew how the player was supposed to be destroyed
			if(pPlayerContext->dwExpectedDestroyReason &&
				(pPlayerContext->dwExpectedDestroyReason != pDestroyPlayerMsg->dwReason))
			{
				// Then verify that the way they were destroyed
				DPTEST_TRACE(pContext->hLog, "Player destroyed for unexpected reason! DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			// Remove this player from our global player list
			EnterCriticalSection(&(pContext->Lock));

			if(pPlayerContext->pNext)
				pPlayerContext->pNext->pPrev = pPlayerContext->pPrev;
			if(pPlayerContext->pPrev)
				pPlayerContext->pPrev->pNext = pPlayerContext->pNext;
			else
				pContext->pPlayerList = pPlayerContext->pNext;

			--pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));

			// Clear the context value for the local player
			if(pDestroyPlayerMsg->dpnidPlayer == pContext->LocalPlayerID)
				pContext->LocalPlayerID = 0;
			// Only free the context buffer if this isn't a local player
			// otherwise, the main app thread will do it
			else
				MemFree(pPlayerContext);

		break;
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
			PMESSAGEDATA pReplyData;
			DWORD dwChecksum;

			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = 0x%08x", 1, pConnectCompleteMsg->hAsyncOp);
				// BUGBUG - compare this with what was passed in to connect
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pConnectCompleteMsg->pvUserContext);
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
				DPTEST_TRACE(pContext->hLog, "     pvApplicationReplyData = 0x%08x", 1, pConnectCompleteMsg->pvApplicationReplyData);
				DPTEST_TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);
			}

			if(pConnectCompleteMsg->hAsyncOp != pContext->dpnhConnect)
			{
				DPTEST_TRACE(pContext->hLog, "Connection completed with different async handle!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			// Parse any reply data if present
			if(pReplyData = (PMESSAGEDATA) pConnectCompleteMsg->pvApplicationReplyData)
			{
				DWORD dwChecksum = 0;

				// Make sure we received enough data
				if(pConnectCompleteMsg->dwApplicationReplyDataSize < sizeof(MESSAGEDATA))
				{
					DPTEST_FAIL(pContext->hLog, "Received application reply data is too small! (\"%u\" < \"%u\")",
						2, pConnectCompleteMsg->dwApplicationReplyDataSize, sizeof(MESSAGEDATA));
					DEBUGBREAK();
					hr = E_FAIL;
				}
				// If the message is of valid size
				else
				{
					if(pReplyData->dwMessageType != CONNECT_REPLY_DATA)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data of invalid type!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}

					// Calculate the checksum from the message
					for(DWORD i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
						dwChecksum += pReplyData->szData[i];

					// Compare it to the checksum listed in the message
					if(dwChecksum != pReplyData->dwChecksum)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data failed checksum!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}

					pContext->fVerbose ?
						DPTEST_TRACE(pContext->hLog, "Connect reply data was : \"%s\"", 0, pReplyData->szData) : 0;
				}

			}

			if(!pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected connection indication!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			// Check to see if we got the expected result value
			if(pContext->hrExpectedConnectResult != pConnectCompleteMsg->hResultCode)
			{
				DPTEST_TRACE(pContext->hLog, "Received unexpected connection result (0x%08x != 0x%08x)  DEBUGBREAK()-ing.", 2,
					pContext->hrExpectedConnectResult, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
			}
			else
				pContext->fConnectCompleted = TRUE;

			
			// Signal the main thread that connection completed
			if (! SetEvent(pContext->hConnectComplete))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set connection indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hConnectComplete);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE pReceiveMsg;

			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReceiveMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pReceiveMsg->pvPlayerContext);
				// BUGBUG - create a common message format that contains the sender information
				// so that we can verify that this data is accurate
				DPTEST_TRACE(pContext->hLog, "     pReceiveData = 0x%08x", 1, pReceiveMsg->pReceiveData);
				DPTEST_TRACE(pContext->hLog, "     dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
				// BUGBUG - try holding onto this buffer and returning it on subsequent calls to receive
				// Use the buffer handle to return it later.  Maybe store the last buffer handle received
				// in the players context.
				DPTEST_TRACE(pContext->hLog, "     hBufferHandle = 0x%08x", 1, pReceiveMsg->hBufferHandle);
			}

			if(!pContext->fCanReceive)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected incoming message!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fReceived = TRUE;
			
			// Signal the main thread that data was received
			if (! SetEvent(pContext->hReceiveData))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hReceiveData);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE pSendCompleteMsg;

			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pSendCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of a send
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = 0x%08x", 1, pSendCompleteMsg->hAsyncOp);
				// BUGBUG - again check with the context and verify that this is the context that we
				// supplied with a call to send
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pSendCompleteMsg->pvUserContext);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pSendCompleteMsg->hResultCode);
				// BUGBUG - do lots of sends and see if this increases, what about guaranteed?
				DPTEST_TRACE(pContext->hLog, "     dwSendTime = %u ms", 1, pSendCompleteMsg->dwSendTime);
			}

			break;
		case DPN_MSGID_APPLICATION_DESC:
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_APPLICATION_DESC", 0);
			}

			if(!pContext->fAppDescCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected app desc change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fAppDescChanged = TRUE;
			
			// Signal the main thread that the app desc changed
			if (! SetEvent(pContext->hAppDescChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set app desc change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAppDescChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;

			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of an operation
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);
			}

			if(!pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected asynchronous operation completion!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			if(pContext->dpnhAsyncOp != pAsyncOpCompleteMsg->hAsyncOp)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completion has unexpected handle (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->dpnhAsyncOp, pAsyncOpCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			}

			if(pContext->hrAsyncOpExpectedResult != pAsyncOpCompleteMsg->hResultCode)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completed with unexpected result (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->hrAsyncOpExpectedResult, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			}

			pContext->fAsyncOpCompleted = TRUE;
			
			// Signal the main thread that an async op completed
			if (! SetEvent(pContext->hAsyncOpCompleted))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompleted);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_SERVER_INFO:
			PDPNMSG_SERVER_INFO pServerInfoMsg;

			pServerInfoMsg = (PDPNMSG_SERVER_INFO) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SERVER_INFO", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pServerInfoMsg->dwSize);
				// BUGBUG - Not sure why DPlay does this...  The whole concept of a client
				// is supposed to be free of the notion of DPNID's and player contexts
				// So why are we provided one here?
				DPTEST_TRACE(pContext->hLog, "     dpnidServer = %u/%x", 2, pServerInfoMsg->dpnidServer, pServerInfoMsg->dpnidServer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pServerInfoMsg->pvPlayerContext);
			}

			if(!pContext->fServerInfoCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected server info change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fServerInfoChanged = TRUE;
			
			// Signal the main thread that the server info changed
			if (! SetEvent(pContext->hServerInfoChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set server info change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hServerInfoChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;

			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pTerminateSessionMsg->dwSize);
				// BUGBUG - check the context and verify the difference between the host calling\
				// close and the host calling terminate session.
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pTerminateSessionMsg->hResultCode);
				// BUGBUG - check with the context and verify whether or not data should have been provided
				DPTEST_TRACE(pContext->hLog, "     pvTerminateData = 0x%08x", 1, pTerminateSessionMsg->pvTerminateData);
				DPTEST_TRACE(pContext->hLog, "     dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);
			}

			if(!pContext->fSessionCanTerminate)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected session termination!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fSessionTerminated = TRUE;
			
			// Signal the main thread that the session terminated
			if (! SetEvent(pContext->hSessionTerminated))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set session termination event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAppDescChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER pReturnBufferMsg;

			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RETURN_BUFFER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReturnBufferMsg->dwSize);
				// BUGBUG - in enum cases, this could be an error, otherwise, should be success
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
				DPTEST_TRACE(pContext->hLog, "     pvBuffer = 0x%08x", 1, pReturnBufferMsg->pvBuffer);
				// BUGBUG - this should probably only be set in concurrent enumeration cases
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pReturnBufferMsg->pvUserContext);
			}

			if(!pReturnBufferMsg->pvBuffer)
			{
				DPTEST_TRACE(pContext->hLog, "Return buffer message with invalid buffer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			MemFree(pReturnBufferMsg->pvBuffer);

			break;
		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	dwEndTime = GetTickCount();

	pContext->dwCallbackTime += (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

	return (hr);
} // SimpleClientMessageHandler
#undef DEBUG_SECTION

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\simpletests.h ===
#ifndef __SIMPLETESTS__
#define __SIMPLETESTS__

namespace DPlayCoreNamespace {

#define CONNECT_DATA			0
#define CONNECT_REPLY_DATA		1
#define SEND_DATA				2
#define PLAYER_DATA				3
#define APP_DATA				4
#define TERMINATE_DATA			5

#define MAX_MESSAGEDATA_DATA	32

#define SEND_COUNT				10

#define SEND_MESSAGE "Send message"
#define CONNECT_MESSAGE "Connect message"
#define CONNECT_REPLY_MESSAGE "Connect reply message"
#define DESTROY_MESSAGE "Destroy message"
#define TERMINATE_MESSAGE "Terminate message"
#define SERVER_DATA1 "First server data buffer"
#define SERVER_DATA2 "Second server data buffer"
#define CLIENT_DATA1 "First client data buffer"
#define CLIENT_DATA2 "Second client data buffer"
#define PEER_DATA1 "First peer data buffer"
#define PEER_DATA2 "Second peer data buffer"
#define HOST_DATA1 "First host data buffer"
#define HOST_DATA2 "Second host data buffer"

#define SERVER_PLAYER_NAME1 L"Server1"
#define SERVER_PLAYER_NAME2	L"Server2"
#define CLIENT_PLAYER_NAME1 L"Client1"
#define CLIENT_PLAYER_NAME2	L"Client2"
#define HOST_PLAYER_NAME1 L"Host1"
#define HOST_PLAYER_NAME2 L"Host2"
#define PEER_PLAYER_NAME1 L"Peer1"
#define PEER_PLAYER_NAME2 L"Peer2"

#define SERVER_SESSION_NAME1 L"ServerSession1"
#define SERVER_SESSION_NAME2 L"ServerSession2"
#define HOST_SESSION_NAME1 L"HostSession1"
#define HOST_SESSION_NAME2 L"HostSession2"

#define SERVER_PASSWORD1 L"ServerPassword1"
#define SERVER_PASSWORD2 L"ServerPassword2"
#define HOST_PASSWORD1 L"HostPassword1"
#define HOST_PASSWORD2 L"HostPassword2"

#define SERVER_APP_DATA1 "ServerAppData1"
#define SERVER_APP_DATA2 "ServerAppData2"
#define HOST_APP_DATA1 "HostAppData1"
#define HOST_APP_DATA2 "HostAppData2"

//==================================================================================
// Structure
//==================================================================================
typedef struct tagPLAYERCONTEXT
{
	BOOL					fLocalPlayer;
	DPNID					PlayerID;
	DWORD					TotalMessagesReceived;
	DWORD					TotalBytesReceived;
	DWORD					dwExpectedDestroyReason;
	struct tagPLAYERCONTEXT	*pPrev;
	struct tagPLAYERCONTEXT	*pNext;
} PLAYERCONTEXT, * PPLAYERCONTEXT;

typedef struct tagSIMPLEHOSTCONTEXT
{
	BOOL					fVerbose;
	CRITICAL_SECTION		Lock;
	PPLAYERCONTEXT			pPlayerList;
	HANDLE					hLog; // Handle to logging subsystem
	DPNID					LocalPlayerID;
	DWORD					dwCallbackTime;

	// Variables for handling incoming connections
	HANDLE					hIndicateConnect;
	BOOL					fCanAcceptConnect;
	BOOL					fAcceptedConnect;

	// Variables for handling player creation events
	HANDLE					hIndicateRemotePlayer;
	DWORD					dwExpectedRemotePlayers;
	DWORD					dwCurrentRemotePlayers;

	// Variables for handling incoming data
	HANDLE					hReceiveData;
	DWORD					dwExpectedReceives;
	DWORD					dwCurrentReceives;

	// Variables for handling random async operations
	HANDLE					hAsyncOpCompleted;
	BOOL					fAsyncOpCanComplete;
	BOOL					fAsyncOpCompleted;
	DPNHANDLE				dpnhAsyncOp;
	HRESULT					hrAsyncOpExpectedResult;

	// Variables for handling peer information changes
	HANDLE					hPeerInfoChanged;
	BOOL					fPeerInfoCanChange;
	BOOL					fPeerInfoChanged;

	// Variables for handling app desc changes
	HANDLE					hAppDescChanged;
	BOOL					fAppDescCanChange;
	BOOL					fAppDescChanged;

	DWORD					dwPlayersConnected;
} SIMPLEHOSTCONTEXT, * PSIMPLEHOSTCONTEXT;

typedef struct tagSIMPLEPEERCONTEXT
{
	// BUGBUG - make sure to add to other test's contexts later
	CHAR					szContextDescription[20];

	BOOL					fVerbose;
	CRITICAL_SECTION		Lock;
	PPLAYERCONTEXT			pPlayerList;
	HANDLE					hLog; // Handle to logging subsystem
	DPNID					LocalPlayerID;
	DWORD					dwCallbackTime;

	// Variables for handling incoming connections
	HANDLE					hConnectComplete;
	BOOL					fConnectCanComplete;
	BOOL					fConnectCompleted;
	DPNHANDLE				dpnhConnect;
	HRESULT					hrExpectedConnectResult;

	// Variables for handling player creation events
	HANDLE					hIndicateRemotePlayer;
	DWORD					dwExpectedRemotePlayers;
	DWORD					dwCurrentRemotePlayers;

	// Variables for handling incoming data
	HANDLE					hReceiveData;
	DWORD					dwExpectedReceives;
	DWORD					dwCurrentReceives;

	// Variables for handling random async operations
	HANDLE					hAsyncOpCompleted;
	BOOL					fAsyncOpCanComplete;
	BOOL					fAsyncOpCompleted;
	DPNHANDLE				dpnhAsyncOp;
	HRESULT					hrAsyncOpExpectedResult;

	// Variables for handling host information changes
	HANDLE					hHostInfoChanged;
	BOOL					fHostInfoCanChange;
	BOOL					fHostInfoChanged;

	// Variables for handling app desc changes
	HANDLE					hAppDescChanged;
	BOOL					fAppDescCanChange;
	BOOL					fAppDescChanged;

	// Variables for handling session termination
	HANDLE					hSessionTerminated;
	BOOL					fSessionCanTerminate;
	BOOL					fSessionTerminated;

	DWORD					dwPlayersConnected;
} SIMPLEPEERCONTEXT, * PSIMPLEPEERCONTEXT;

typedef struct tagSIMPLESERVERCONTEXT
{
	BOOL					fVerbose;
	CRITICAL_SECTION		Lock;
	PPLAYERCONTEXT			pPlayerList;
	HANDLE					hLog; // Handle to logging subsystem
	DPNID					LocalPlayerID;
	DWORD					dwCallbackTime;

	// Variables for handling incoming connections
	HANDLE					hIndicateConnect;
	BOOL					fCanAcceptConnect;
	BOOL					fAcceptedConnect;

	// Variables for handling player creation events
	HANDLE					hIndicateRemotePlayer;
	BOOL					fCanAcceptRemotePlayer;
	BOOL					fAcceptedRemotePlayer;

	// Variables for handling incoming data
	HANDLE					hReceiveData;
	BOOL					fCanReceive;
	BOOL					fReceived;

	// Variables for handling random async operations
	HANDLE					hAsyncOpCompleted;
	BOOL					fAsyncOpCanComplete;
	BOOL					fAsyncOpCompleted;
	DPNHANDLE				dpnhAsyncOp;
	HRESULT					hrAsyncOpExpectedResult;

	// Variables for handling client information changes
	HANDLE					hClientInfoChanged;
	BOOL					fClientInfoCanChange;
	BOOL					fClientInfoChanged;

	// Variables for handling app desc changes
	HANDLE					hAppDescChanged;
	BOOL					fAppDescCanChange;
	BOOL					fAppDescChanged;

	DWORD					dwPlayersConnected;
} SIMPLESERVERCONTEXT, * PSIMPLESERVERCONTEXT;

typedef struct tagSIMPLECLIENTCONTEXT
{
	BOOL					fVerbose;
	CRITICAL_SECTION		Lock;
	PPLAYERCONTEXT			pPlayerList;
	HANDLE					hLog; // Handle to logging subsystem
	DPNID					LocalPlayerID;
	DWORD					dwCallbackTime;

	// Variables for handling incoming connections
	HANDLE					hConnectComplete;
	BOOL					fConnectCanComplete;
	BOOL					fConnectCompleted;
	DPNHANDLE				dpnhConnect;
	HRESULT					hrExpectedConnectResult;

	// Variables for handling player creation events
	HANDLE					hIndicateRemotePlayer;
	BOOL					fCanAcceptRemotePlayer;
	BOOL					fAcceptedRemotePlayer;

	// Variables for handling incoming data
	HANDLE					hReceiveData;
	BOOL					fCanReceive;
	BOOL					fReceived;

	// Variables for handling random async operations
	HANDLE					hAsyncOpCompleted;
	BOOL					fAsyncOpCanComplete;
	BOOL					fAsyncOpCompleted;
	DPNHANDLE				dpnhAsyncOp;
	HRESULT					hrAsyncOpExpectedResult;

	// Variables for handling server information changes
	HANDLE					hServerInfoChanged;
	BOOL					fServerInfoCanChange;
	BOOL					fServerInfoChanged;

	// Variables for handling app desc changes
	HANDLE					hAppDescChanged;
	BOOL					fAppDescCanChange;
	BOOL					fAppDescChanged;

	// Variables for handling session termination
	HANDLE					hSessionTerminated;
	BOOL					fSessionCanTerminate;
	BOOL					fSessionTerminated;

	DWORD					dwPlayersConnected;
} SIMPLECLIENTCONTEXT, * PSIMPLECLIENTCONTEXT;

typedef struct tagMESSAGEDATA
{
	DWORD					dwMessageType;
	DWORD					dwChecksum;
	CHAR					szData[MAX_MESSAGEDATA_DATA];					
} MESSAGEDATA, * PMESSAGEDATA;

//==================================================================================
// Callbacks
//==================================================================================
HRESULT SimpleHostMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT SimplePeerMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT SimpleServerMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT SimpleClientMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

} // namespace DPlayCoreNamespace

#endif // __SIMPLETESTS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\simpleserver.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"
#include "simpletests.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

#undef DEBUG_SECTION
#define DEBUG_SECTION	"DirectPlayExec_SimpleServer()"
//==================================================================================
// DirectPlayExec_SimpleServer
//----------------------------------------------------------------------------------
//
// Description: Implements the DirectPlay simple server test
//
// Arguments:
//     HANDLE hLog                     Handle to the logging subsystem
//     PDP_HOSTINFO pHostInfo          Pointer to info on which machine is host
//                                     and which are clients
//     WORD LowPort                    Port that session will be hosted on 
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT DirectPlayExec_SimpleServer(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8SERVER			pDP8Server = NULL;
	PDIRECTPLAY8ADDRESS		pDP8DeviceAddress = NULL;
	DPN_APPLICATION_DESC	dpnad, *pdpnad = NULL;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_BUFFER_DESC			dpnbd;
	DPN_BUFFER_DESC			dpnbdCompare;
	DPN_PLAYER_INFO			dpnpi, *pdpnpiClient = NULL;
	DPN_PLAYER_INFO			dpnpiCompare;
	DPN_CONNECTION_INFO		dpnci;
	DPN_SP_CAPS				dpnspc;
	DPN_CAPS				dpnc;
	DP_DOWORKLIST			DoWorkList;
	SIMPLESERVERCONTEXT		SimpleServerContext;
	DWORD					dwPort, i, dwNumIDs, dwChecksum, dwAppDescSize, dwNumMsgs, dwNumBytes, dwClientDataSize;
	PPLAYERCONTEXT			pLocalPlayerContext = NULL, pTempContext = NULL;
	DPNID					SendTarget, *pCurrentPlayers = NULL;
	MESSAGEDATA				MessageData, *pClientInfo = NULL;
	DPNHANDLE				dpnhSendTo;
	PVOID					pCurrentPlayerContext = NULL;

	ZeroMemory(&SimpleServerContext, sizeof (SIMPLESERVERCONTEXT));
	InitializeCriticalSection(&(SimpleServerContext.Lock));

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating first DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (CoCreate failed)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SimpleServerContext.hLog = hLog;
		SimpleServerContext.fVerbose = FALSE;
		SimpleServerContext.LocalPlayerID = 0;
		CREATEEVENT_OR_THROW(SimpleServerContext.hIndicateConnect, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleServerContext.hIndicateRemotePlayer, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleServerContext.hReceiveData, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleServerContext.hAsyncOpCompleted, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleServerContext.hClientInfoChanged, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(SimpleServerContext.hAppDescChanged, NULL, FALSE, FALSE, NULL);

		tr = pDP8Server->DP8S_Initialize(&SimpleServerContext, SimpleServerMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DoWork on newly initialized server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->m_pDP8Server->DoWork(0);
		if((tr != S_OK) && (tr != S_FALSE))
		{
			DPTEST_FAIL(hLog, "DoWork on server just after initialization returned 0x%08x", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting port for hosted session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
//		dwPort = (DWORD) LowPort;
		dwPort = 2302;

		if(pDP8DeviceAddress->AddComponent(DPNA_KEY_PORT, &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD) != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set port for host", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting initial server information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SERVER_DATA1, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];
		
		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = SERVER_PLAYER_NAME1;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		SimpleServerContext.fAsyncOpCanComplete = TRUE;
		SimpleServerContext.fAsyncOpCompleted = FALSE;
		SimpleServerContext.hrAsyncOpExpectedResult = S_OK;
		SimpleServerContext.dpnhAsyncOp = (DPNHANDLE) 0x666;

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &(SimpleServerContext.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetServerInfo completed synchronously", 0);
			SetEvent(SimpleServerContext.hAsyncOpCompleted);
			SimpleServerContext.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimpleServerContext.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimpleServerContext.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for initial set server info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Set up DoWork time parameters
		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = TRUE;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;
		DoWorkList.apdwServerCallbackTimes = (DWORD **) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apdwServerCallbackTimes[0] = &(SimpleServerContext.dwCallbackTime);

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Stop allowing asynchronous operation completions
		SimpleServerContext.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimpleServerContext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set server info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimpleServerContext.fAsyncOpCompleted = FALSE;
		SimpleServerContext.dpnhAsyncOp = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 1 device");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Allocate a local player context.  Callback will deallocate on destroy player message
		pLocalPlayerContext = NULL;
		LOCALALLOC_OR_THROW(PPLAYERCONTEXT, pLocalPlayerContext, sizeof(PLAYERCONTEXT));

		// Allow incoming connections
		SimpleServerContext.fCanAcceptConnect = TRUE;
		SimpleServerContext.fAcceptedConnect = FALSE;
		
		// Allow remote player creations
		SimpleServerContext.fCanAcceptRemotePlayer = TRUE;
		SimpleServerContext.fAcceptedRemotePlayer = FALSE;

		tr = pDP8Server->DP8S_Host(&dpnad, &pDP8DeviceAddress, 1, NULL, NULL, pLocalPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Hosting with 1 device failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for incoming connection to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hIndicateConnect))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing connections
		SimpleServerContext.fCanAcceptConnect = FALSE;

		// If we didn't get a connection, then we're in trouble
		if(!SimpleServerContext.fAcceptedConnect)
		{
			DPTEST_FAIL(hLog, "No connection indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no connection accepted)
	
		SimpleServerContext.fAcceptedConnect = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for remote player to be created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hIndicateRemotePlayer))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing remote player creations
		SimpleServerContext.fCanAcceptRemotePlayer = FALSE;

		// If we didn't get a remote player creation, then we're in trouble
		if(!SimpleServerContext.fAcceptedRemotePlayer)
		{
			DPTEST_FAIL(hLog, "No remote player creations indicated!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no remote player accepted)
	
		SimpleServerContext.fAcceptedRemotePlayer = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerate players");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwNumIDs = 0;

		tr = pDP8Server->DP8S_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming players with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		LOCALALLOC_OR_THROW(PDPNID, pCurrentPlayers, dwNumIDs * sizeof(DPNID));

		tr = pDP8Server->DP8S_EnumPlayersAndGroups(pCurrentPlayers, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players with valid buffer didn't return success!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify player contexts");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Validate each player in the enumeration
		for(i = 0; i < dwNumIDs; ++i)
		{
			for(pTempContext = SimpleServerContext.pPlayerList; pTempContext; pTempContext = pTempContext->pNext)
			{
				if(pTempContext->PlayerID == pCurrentPlayers[i])
					break;
			}

			if(!pTempContext)
			{
				DPTEST_FAIL(hLog, "Enumerated player 0x%08x wasn't found in our local list", 0, pCurrentPlayers[i]);
				THROW_TESTRESULT;
			}

			tr = pDP8Server->DP8S_GetPlayerContext(pCurrentPlayers[i], &pCurrentPlayerContext, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get player context for player 0x%08x",
					1, pCurrentPlayers[i]);
				THROW_TESTRESULT;
			} // end if (couldn't enum players and groups)

			if(pTempContext != pCurrentPlayerContext)
			{
				DPTEST_FAIL(hLog, "Context returned for player 0x%08x was incorrect (0x%08x != 0x%08x)",
					3, pCurrentPlayers[i], pTempContext, pCurrentPlayerContext);
				THROW_TESTRESULT;
			}

			DPTEST_TRACE(hLog, "Successfully retreived player context for player 0x%08x",
				1, pCurrentPlayers[i]);
		}

		DPTEST_TRACE(hLog, "Found all %u players in our local list", 0, dwNumIDs);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Pick a send target");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		EnterCriticalSection(&(SimpleServerContext.Lock));

		// Find the first non-local player and set them as the send target
		SendTarget = 0;
		for(pTempContext = SimpleServerContext.pPlayerList; pTempContext && !SendTarget; pTempContext = pTempContext->pNext)
		{
			if(pTempContext->PlayerID != SimpleServerContext.LocalPlayerID)
				SendTarget = pTempContext->PlayerID;
		}
		LeaveCriticalSection(&(SimpleServerContext.Lock));

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check send queue before sending");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumMsgs = dwNumBytes = 0x666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(SendTarget, &dwNumMsgs, &dwNumBytes, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get send queue info!", 0);
			THROW_TESTRESULT;
		}

		// Verify that no data is in the send queue
		if(dwNumMsgs || dwNumBytes)
		{
			DPTEST_FAIL(hLog, "Send queue shows backlog, but no data has been sent (%u/%u)",
				2, dwNumMsgs, dwNumBytes);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info with new player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8Server->DP8S_GetConnectionInfo(SendTarget, &dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the service provider");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnspc, sizeof(DPN_SP_CAPS));
		dpnspc.dwSize = sizeof(DPN_SP_CAPS);

		tr = pDP8Server->DP8S_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "Service provider caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnspc.dwFlags);
		DPTEST_TRACE(hLog, "     Number of threads: %u", 1, dpnspc.dwNumThreads);
		DPTEST_TRACE(hLog, "     Enum count: %u", 1, dpnspc.dwDefaultEnumCount);
		DPTEST_TRACE(hLog, "     Enum retry interval: %u", 1, dpnspc.dwDefaultEnumRetryInterval);
		DPTEST_TRACE(hLog, "     Enum timeout: %u", 1, dpnspc.dwDefaultEnumTimeout);
		DPTEST_TRACE(hLog, "     Max enum payload: %u", 1, dpnspc.dwMaxEnumPayloadSize);
		DPTEST_TRACE(hLog, "     Buffers per thread: %u", 1, dpnspc.dwBuffersPerThread);
		DPTEST_TRACE(hLog, "     System buffer size: %u", 1, dpnspc.dwSystemBufferSize);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of the service provider with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set service provider caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the capabilities of the DirectPlay");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnc, sizeof(DPN_CAPS));
		dpnc.dwSize = sizeof(DPN_CAPS);

		tr = pDP8Server->DP8S_GetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// Output the service provider capabilities
		DPTEST_TRACE(hLog, "DirectPlay caps:", 0);
		DPTEST_TRACE(hLog, "     Flags: 0x%08x", 1, dpnc.dwFlags);
		DPTEST_TRACE(hLog, "     Connect timeout: %u", 1, dpnc.dwConnectTimeout);
		DPTEST_TRACE(hLog, "     Connect retries: %u", 1, dpnc.dwConnectRetries);
		DPTEST_TRACE(hLog, "     Keepalive timeout: %u", 1, dpnc.dwTimeoutUntilKeepAlive);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set the capabilities of DirectPlay with indentical info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetCaps(&dpnc, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set DirectPlay caps!", 0);
			THROW_TESTRESULT;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send a message to the newly connected player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SEND_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = SEND_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Package up the buffer
		dpnbd.dwBufferSize = sizeof(MESSAGEDATA);
		dpnbd.pBufferData = (BYTE *) &MessageData;

		// Init these variables so we can see if they were modified
		dpnhSendTo = 0x666;
		CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));

		SimpleServerContext.fCanReceive = TRUE;
		SimpleServerContext.fReceived = FALSE;

		tr = pDP8Server->DP8S_SendTo(SendTarget, &dpnbd, 1, 0, NULL, &dpnhSendTo, 0);

		if (tr != DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for message from remote player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing incoming messages
		SimpleServerContext.fCanReceive = FALSE;

		// If we didn't get an incoming message, then we're in trouble
		if(!SimpleServerContext.fReceived)
		{
			DPTEST_FAIL(hLog, "No messages received!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		SimpleServerContext.fCanReceive = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify client info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwClientDataSize = 0;
		pdpnpiClient = NULL;

		tr = pDP8Server->DP8S_GetClientInfo(SendTarget, NULL, &dwClientDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting client info with NULL buffer on server didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiClient, dwClientDataSize);
		pdpnpiClient->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8Server->DP8S_GetClientInfo(SendTarget, pdpnpiClient, &dwClientDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting client info with valid buffer on server didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiClient->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiClient->pwszName, CLIENT_PLAYER_NAME1))
		{
			DPTEST_FAIL(hLog, "Unexpected client player name! (\"%S\" != \"%S\")",
				2, pdpnpiClient->pwszName, CLIENT_PLAYER_NAME1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiClient->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received client data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiClient->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pClientInfo = NULL;
		if(!(pClientInfo = (PMESSAGEDATA) pdpnpiClient->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pClientInfo->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pClientInfo->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pClientInfo->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received client info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pClientInfo->szData, CLIENT_DATA1))
		{
			DPTEST_FAIL(hLog, "Unexpected client player data! (\"%s\" != \"%s\")",
				2, pClientInfo->szData, CLIENT_DATA1);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiClient);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Change server information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SERVER_DATA2, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = PLAYER_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up the player info structure
		ZeroMemory(&dpnpi, sizeof(DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof(DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		dpnpi.dwPlayerFlags = 0;
		dpnpi.dwDataSize = sizeof(MESSAGEDATA);
		dpnpi.pvData = &MessageData;
		dpnpi.pwszName = SERVER_PLAYER_NAME2;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

		// Be ready for asychronous completion
		SimpleServerContext.fAsyncOpCanComplete = TRUE;
		SimpleServerContext.fAsyncOpCompleted = FALSE;
		SimpleServerContext.hrAsyncOpExpectedResult = S_OK;
		SimpleServerContext.dpnhAsyncOp = (DPNHANDLE) 0x666;

		// Be ready for client changing info in response to server info change
		SimpleServerContext.fClientInfoCanChange = TRUE;
		SimpleServerContext.fClientInfoChanged = FALSE;

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &(SimpleServerContext.dpnhAsyncOp), 0);

		// This function can return synchronously even when called
		// as an async function, so be prepared for that
		if(tr == S_OK)
		{
			DPTEST_TRACE(hLog, "SetServerInfo completed synchronously", 0);
			SetEvent(SimpleServerContext.hAsyncOpCompleted);
			SimpleServerContext.fAsyncOpCompleted = TRUE;
		}
		// If this operation is completing asynchronously we should have a handle
		else if (tr == DPNSUCCESS_PENDING)
		{
			if (SimpleServerContext.dpnhAsyncOp == (DPNHANDLE) 0x666)
			{
				DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (handle was not set)
			
			if (SimpleServerContext.dpnhAsyncOp == NULL)
			{
				DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (handle was set to NULL)
		}
		// Otherwise, we got an unexpected error
		else
		{
			DPTEST_FAIL(hLog, "Couldn't send message!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for set server info operation to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hAsyncOpCompleted))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing async operations to complete
		SimpleServerContext.fAsyncOpCanComplete = FALSE;

		// If we didn't get an asynchronous operation completion, then we're in trouble
		if(!SimpleServerContext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't receive asynchronous completion for set server info!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (async operation didn't complete)
	
		SimpleServerContext.fAsyncOpCompleted = FALSE;
		SimpleServerContext.dpnhAsyncOp = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for client to change information");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hClientInfoChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing client info changes
		SimpleServerContext.fClientInfoCanChange = FALSE;

		// If we didn't get a client info change, then we're in trouble
		if(!SimpleServerContext.fClientInfoChanged)
		{
			DPTEST_FAIL(hLog, "Client info didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (client info didn't change)
	
		SimpleServerContext.fClientInfoChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify new client info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwClientDataSize = 0;
		pdpnpiClient = NULL;

		tr = pDP8Server->DP8S_GetClientInfo(SendTarget, NULL, &dwClientDataSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting client info with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpiClient, dwClientDataSize);
		pdpnpiClient->dwSize = sizeof(DPN_PLAYER_INFO);

		tr = pDP8Server->DP8S_GetClientInfo(SendTarget, pdpnpiClient, &dwClientDataSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting client info with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		//
		// Now validate the info received
		//

		// First validate that the dwInfoFlags parameter is correctly set
		if(pdpnpiClient->dwInfoFlags ^ (DPNINFO_NAME | DPNINFO_DATA))
		{
			DPTEST_FAIL(hLog, "Info flags didn't have both DPNINFO_NAME and DPNINFO_DATA set!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Next validate the player name
		if(wcscmp(pdpnpiClient->pwszName, CLIENT_PLAYER_NAME2))
		{
			DPTEST_FAIL(hLog, "Unexpected client player name! (\"%S\" != \"%S\")",
				2, pdpnpiClient->pwszName, CLIENT_PLAYER_NAME2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make sure we received enough data
		if(pdpnpiClient->dwDataSize < sizeof(MESSAGEDATA))
		{
			DPTEST_FAIL(hLog, "Received client data is too small! (\"%u\" < \"%u\")",
				2, pdpnpiClient->dwDataSize, sizeof(MESSAGEDATA));
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player data
		pClientInfo = NULL;
		if(!(pClientInfo = (PMESSAGEDATA) pdpnpiClient->pvData))
		{
			DPTEST_FAIL(hLog, "No player data was provided.", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the type of data
		if(pClientInfo->dwMessageType != PLAYER_DATA)
		{
			DPTEST_FAIL(hLog, "Received player info data of invalid type!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		dwChecksum = 0;

		// Verify the data checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			dwChecksum += pClientInfo->szData[i];
		
		// Compare it to the checksum listed in the info structure
		if(dwChecksum != pClientInfo->dwChecksum)
		{
			DPTEST_FAIL(hLog, "Received client info data failed checksum!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Verify the player name is what we expect
		if(strcmp(pClientInfo->szData, CLIENT_DATA2))
		{
			DPTEST_FAIL(hLog, "Unexpected client player data! (\"%s\" != \"%s\")",
				2, pClientInfo->szData, CLIENT_DATA2);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		SAFE_LOCALFREE(pdpnpiClient);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify current application description");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		dwAppDescSize = 0;
		pdpnad = NULL;

		tr = pDP8Server->DP8S_GetApplicationDesc(NULL, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer on server didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		LOCALALLOC_OR_THROW(PDPN_APPLICATION_DESC, pdpnad, dwAppDescSize);
		pdpnad->dwSize = sizeof(DPN_APPLICATION_DESC);

		tr = pDP8Server->DP8S_GetApplicationDesc(pdpnad, &dwAppDescSize, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc with valid buffer on server didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if(dpnadCompare.guidApplication != pdpnad->guidApplication)
		{
			DPTEST_FAIL(hLog, "Retreived app desc structure has different app GUID!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pdpnad->pwszSessionName)
		{
			DPTEST_FAIL(hLog, "Retreived app desc structure has session name!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		if(pdpnad->guidInstance == GUID_NULL)
		{
			DPTEST_FAIL(hLog, "Retreived app desc structure has NULL instance GUID", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

// BUGBUG - Later, add more data to the original application descriptor...
// then validate that data here

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Change current application description");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, SERVER_APP_DATA2, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = APP_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		// Set up new app desc structure
		pdpnad->dwSize = sizeof(DPN_APPLICATION_DESC);
		pdpnad->dwFlags = DPNSESSION_CLIENT_SERVER | DPNSESSION_REQUIREPASSWORD;
		pdpnad->dwMaxPlayers = 3;
		pdpnad->pwszSessionName = SERVER_SESSION_NAME2;
		pdpnad->pwszPassword = SERVER_PASSWORD2;
		pdpnad->pvApplicationReservedData = &MessageData;
		pdpnad->dwApplicationReservedDataSize = sizeof(MESSAGEDATA);

		// Be ready for incoming app desc change message
		SimpleServerContext.fAppDescCanChange = TRUE;
		SimpleServerContext.fAppDescChanged = FALSE;

		// Be ready for the client to send a message in response to the app change 
		SimpleServerContext.fCanReceive = TRUE;
		SimpleServerContext.fReceived = FALSE;

		tr = pDP8Server->DP8S_SetApplicationDesc(pdpnad, 0);

		// This function always returns synchronously
		if(tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Setting app desc with valid buffer on server didn't return S_OK!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		SAFE_LOCALFREE(pdpnad);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc change indication");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hAppDescChanged))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing app desc changes
		SimpleServerContext.fAppDescCanChange = FALSE;

		// If we didn't get an app desc change, then we're in trouble
		if(!SimpleServerContext.fAppDescChanged)
		{
			DPTEST_FAIL(hLog, "App desc didn't change!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (app desc didn't change)
	
		SimpleServerContext.fAppDescChanged = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second message from remote player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, SimpleServerContext.hReceiveData))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Stop allowing incoming messages
		SimpleServerContext.fCanReceive = FALSE;

		// If we didn't get an incoming message, then we're in trouble
		if(!SimpleServerContext.fReceived)
		{
			DPTEST_FAIL(hLog, "No messages received!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (no message received)
	
		SimpleServerContext.fCanReceive = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check connection info again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		ZeroMemory(&dpnci, sizeof(DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof(DPN_CONNECTION_INFO);

		tr = pDP8Server->DP8S_GetConnectionInfo(SendTarget, &dpnci, 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't get connection info!", 0);
			THROW_TESTRESULT;
		}

		// Output the connection statistics
		DPTEST_TRACE(hLog, "Connection statistics:", 0);
		DPTEST_TRACE(hLog, "     Latency: %u", 1, dpnci.dwRoundTripLatencyMS);
		DPTEST_TRACE(hLog, "     Throughput: %u", 1, dpnci.dwThroughputBPS);
		DPTEST_TRACE(hLog, "     Peak Throughput: %u", 1, dpnci.dwPeakThroughputBPS);
		DPTEST_TRACE(hLog, "     Guaranteed sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsSentGuaranteed, dpnci.dwBytesSentGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed sends: %u pkts/%u bytes",
			2, dpnci.dwPacketsSentNonGuaranteed, dpnci.dwBytesSentNonGuaranteed);
		DPTEST_TRACE(hLog, "     Retried sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsRetried, dpnci.dwBytesRetried);
		DPTEST_TRACE(hLog, "     Dropped sends : %u pkts/%u bytes",
			2, dpnci.dwPacketsDropped, dpnci.dwBytesDropped);
		DPTEST_TRACE(hLog, "     High-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedHighPriority, dpnci.dwMessagesTimedOutHighPriority);
		DPTEST_TRACE(hLog, "     Normal-priority sends : %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedNormalPriority, dpnci.dwMessagesTimedOutNormalPriority);
		DPTEST_TRACE(hLog, "     Low-priority sends: %u xmited/%u timed-out",
			2, dpnci.dwMessagesTransmittedLowPriority, dpnci.dwMessagesTimedOutLowPriority);
		DPTEST_TRACE(hLog, "     Messages received: %u",
			1, dpnci.dwMessagesReceived);
		DPTEST_TRACE(hLog, "     Guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedGuaranteed, dpnci.dwBytesReceivedGuaranteed);
		DPTEST_TRACE(hLog, "     Non-guaranteed recvs: %u pkts/%u bytes",
			2, dpnci.dwPacketsReceivedNonGuaranteed, dpnci.dwBytesReceivedGuaranteed);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroy connected client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Copy the player buffer
		strncpy(MessageData.szData, DESTROY_MESSAGE, MAX_MESSAGEDATA_DATA);
		MessageData.szData[MAX_MESSAGEDATA_DATA - 1] = 0;
		MessageData.dwMessageType = TERMINATE_DATA;
		MessageData.dwChecksum = 0;

		// Calculate the checksum
		for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
			MessageData.dwChecksum += MessageData.szData[i];

		tr = pDP8Server->DP8S_DestroyClient(SendTarget, &MessageData, sizeof(MESSAGEDATA), 0);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't destroy client!", 0);
			THROW_TESTRESULT;
		}

		//
		// Wait for 5 seconds
		//

		Sleep(5000);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		DPTEST_TRACE(hLog, "Releasing server wrapper", 0);
		delete (pDP8Server);
		pDP8Server = NULL;

		FINAL_SUCCESS;
	}
	END_TESTCASE

	if (pDP8Server != NULL)
	{
		DPTEST_TRACE(hLog, "Releasing server wrapper", 0);
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	DPTEST_TRACE(hLog, "Cleaning up test variables", 0);
	SAFE_RELEASE(pDP8DeviceAddress);
	SAFE_LOCALFREE(pCurrentPlayers);
	SAFE_LOCALFREE(pdpnpiClient);
	SAFE_LOCALFREE(pdpnad);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(SimpleServerContext.hIndicateConnect);
	SAFE_CLOSEHANDLE(SimpleServerContext.hIndicateRemotePlayer);
	SAFE_CLOSEHANDLE(SimpleServerContext.hReceiveData);
	SAFE_CLOSEHANDLE(SimpleServerContext.hAsyncOpCompleted);
	SAFE_CLOSEHANDLE(SimpleServerContext.hClientInfoChanged);
	SAFE_CLOSEHANDLE(SimpleServerContext.hAppDescChanged);
	DeleteCriticalSection(&(SimpleServerContext.Lock));

	return (sr);
} // DirectPlayExec_SimpleServer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SimpleServerMessageHandler()"
//==================================================================================
// SimpleServerMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT SimpleServerMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PSIMPLESERVERCONTEXT	pContext = (PSIMPLESERVERCONTEXT) pvContext;
	BOOL					fLocalPlayer = TRUE;
	DWORD					dwStartTime = 0, dwEndTime = 0;

	dwStartTime = GetTickCount();

	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;
			PPLAYERCONTEXT			pNewPlayerContext;

			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pCreatePlayerMsg->pvPlayerContext);
			}
			
			// If this is a local player, then take the buffer that we allocated when we hosted
			// or connected
			if(pCreatePlayerMsg->pvPlayerContext)
			{
				fLocalPlayer = TRUE;

				pContext->LocalPlayerID = pCreatePlayerMsg->dpnidPlayer;
				pNewPlayerContext = ((PPLAYERCONTEXT) pCreatePlayerMsg->pvPlayerContext);
			}
			// Otherwise this is a remote player.  Create a new buffer.
			else
			{
				fLocalPlayer = FALSE;

				pNewPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
				if(!pNewPlayerContext)
				{
					DPTEST_TRACE(pContext->hLog, "Not enough memory to allocate player context!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}

				if(!pContext->fCanAcceptRemotePlayer)
				{
					DPTEST_TRACE(pContext->hLog, "Unexpected remote player creation!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					break;
				}

				pCreatePlayerMsg->pvPlayerContext = pNewPlayerContext;
			}

			// Initialize the player information
			pNewPlayerContext->PlayerID = pCreatePlayerMsg->dpnidPlayer;
			pNewPlayerContext->TotalBytesReceived = 0;
			pNewPlayerContext->TotalMessagesReceived = 0;

			// BUGBUG - figure out why this player will be destroyed.  Need cases for the following
			// DPNDESTROYPLAYERREASON_NORMAL  - The player is being deleted for normal reasons. 
			// DPNDESTROYPLAYERREASON_CONNECTIONLOST - The connection was lost. 
			// DPNDESTROYPLAYERREASON_SESSIONTERMINATED - The session was terminated. 
			// DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER - The host called DestroyPeer
			pNewPlayerContext->dwExpectedDestroyReason = 0;

			// Add info on this player to our global player list
			EnterCriticalSection(&(pContext->Lock));

			pNewPlayerContext->pPrev = NULL;
			if(pContext->pPlayerList)
				pContext->pPlayerList->pPrev = pNewPlayerContext->pNext;
			pNewPlayerContext->pNext = pContext->pPlayerList;
			pContext->pPlayerList = pNewPlayerContext;

			++pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));

			if(!fLocalPlayer)
			{
				pContext->fAcceptedRemotePlayer = TRUE;
				
				// Signal the main thread that a player was created
				if (! SetEvent(pContext->hIndicateRemotePlayer))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set remote player indication event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hIndicateRemotePlayer);
					
					DEBUGBREAK();
					
					if (hr == S_OK)
						hr = E_FAIL;
					
					break;
				} // end if (couldn't set event)
				
			}

		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;
			PPLAYERCONTEXT			pPlayerContext;
			CHAR					szReason[64];

			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pDestroyPlayerMsg->pvPlayerContext);
				
				switch(pDestroyPlayerMsg->dwReason)
				{
				case DPNDESTROYPLAYERREASON_NORMAL:
					strcpy(szReason, "NORMAL");
					break;
				case DPNDESTROYPLAYERREASON_CONNECTIONLOST:
					strcpy(szReason, "CONNECTIONLOST");
					break;
				case DPNDESTROYPLAYERREASON_SESSIONTERMINATED:
					strcpy(szReason, "SESSIONTERMINATED");
					break;
				case DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER:
					strcpy(szReason, "HOSTDESTROYEDPLAYER");
					break;
				default:
					DPTEST_TRACE(pContext->hLog, "Unknown player destroy reason! DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					break;
				}
				
				DPTEST_TRACE(pContext->hLog, "     dwReason = %s", 1, szReason);
			}
			
			pPlayerContext = (PPLAYERCONTEXT) pDestroyPlayerMsg->pvPlayerContext;

			if(!pPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "No player context received!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			// If we knew how the player was supposed to be destroyed
			if(pPlayerContext->dwExpectedDestroyReason &&
				(pPlayerContext->dwExpectedDestroyReason != pDestroyPlayerMsg->dwReason))
			{
				// Then verify that the way they were destroyed
				DPTEST_TRACE(pContext->hLog, "Player destroyed for unexpected reason! DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			// Remove this player from our global player list
			EnterCriticalSection(&(pContext->Lock));

			if(pPlayerContext->pNext)
				pPlayerContext->pNext->pPrev = pPlayerContext->pPrev;
			if(pPlayerContext->pPrev)
				pPlayerContext->pPrev->pNext = pPlayerContext->pNext;
			else
				pContext->pPlayerList = pPlayerContext->pNext;

			--pContext->dwPlayersConnected;

			LeaveCriticalSection(&(pContext->Lock));

			// Release the player context
			MemFree(pPlayerContext);

		break;
		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT pIndicateConnectMsg;
			PMESSAGEDATA pConnectData, pConnectReplyData;
			CHAR *pszTempURL;
			HRESULT hrTemp;
			DWORD dwTempURLSize, i;
			DWORD dwChecksum;

			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pIndicateConnectMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     pvUserConnectData = 0x%08x", 1, pIndicateConnectMsg->pvUserConnectData);
				DPTEST_TRACE(pContext->hLog, "     dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			}
			
			// Parse any connect data if present
			if(!(pConnectData = (PMESSAGEDATA) pIndicateConnectMsg->pvUserConnectData))
			{
					DPTEST_TRACE(pContext->hLog, "No incoming connection data was provided.  Reject connection.", 0);
					hr = E_FAIL;
					break;
			}
			else
			{
				
				dwChecksum = 0;
				
				// Make sure we received enough data
				if(pIndicateConnectMsg->dwUserConnectDataSize < sizeof(MESSAGEDATA))
				{
					DPTEST_TRACE(pContext->hLog, "Received connect data was too small!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				// If the message is of valid size
				else
				{
					if(pConnectData->dwMessageType != CONNECT_DATA)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data of invalid type!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}
					
					// Calculate the checksum from the message
					for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
						dwChecksum += pConnectData->szData[i];
					
					// Compare it to the checksum listed in the message
					if(dwChecksum != pConnectData->dwChecksum)
					{
						DPTEST_TRACE(pContext->hLog, "Received connect data failed checksum!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
					}
					
					pContext->fVerbose ? DPTEST_TRACE(pContext->hLog, "Connect data was : \"%s\"", 0, pConnectData->szData) : 0;
					
					pIndicateConnectMsg->dwReplyDataSize = sizeof(MESSAGEDATA);
					pConnectReplyData = (PMESSAGEDATA) MemAlloc(pIndicateConnectMsg->dwReplyDataSize);
				
					// Copy the player buffer
					strncpy(pConnectReplyData->szData, CONNECT_REPLY_MESSAGE, MAX_MESSAGEDATA_DATA);
					pConnectReplyData->szData[MAX_MESSAGEDATA_DATA - 1] = 0;
					pConnectReplyData->dwMessageType = CONNECT_REPLY_DATA;
					pConnectReplyData->dwChecksum = 0;
					
					// Calculate the checksum
					for(i = 0; i < MAX_MESSAGEDATA_DATA; ++i)
						pConnectReplyData->dwChecksum += pConnectReplyData->szData[i];
					
					pIndicateConnectMsg->pvReplyData = pConnectReplyData;
					
				}
			}

			// BUGBUG - set some reply data and verify that it is returned later with the provided context
//			    PVOID     pvReplyContext;
			
			if(pContext->fVerbose)
			{
				
				// BUGBUG - try setting player context value indirectly through this value
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pIndicateConnectMsg->pvPlayerContext);
				
				//
				// Get the DPlay URL of the incoming connection address and display it
				//
				
				// Find out how big the URL is
				dwTempURLSize = 0;
				hrTemp = pIndicateConnectMsg->pAddressPlayer->GetURLA(NULL, &dwTempURLSize);
				if(hrTemp != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't query size of incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Allocate a buffer for it
				pszTempURL = (CHAR *) MemAlloc(dwTempURLSize);
				if(!pszTempURL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't create URL buffer!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Retrieve the URL
				hrTemp = pIndicateConnectMsg->pAddressPlayer->GetURLA(pszTempURL, &dwTempURLSize);
				if(hrTemp != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't retrieve incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Log the URL
				DPTEST_TRACE(pContext->hLog, "     pAddressPlayer = %s", 1, pszTempURL);
				
				// Release the URL
				MemFree(pszTempURL);
				
				//
				// Get the DPlay URL of the incoming connection address and display it
				//
				
				// Find out how big the URL is
				dwTempURLSize = 0;
				hrTemp = pIndicateConnectMsg->pAddressDevice->GetURLA(NULL, &dwTempURLSize);
				if(hrTemp != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't query size of incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Allocate a buffer for it
				pszTempURL = (CHAR *) MemAlloc(dwTempURLSize);
				if(!pszTempURL)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't create URL buffer!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Retrieve the URL
				hrTemp = pIndicateConnectMsg->pAddressDevice->GetURLA(pszTempURL, &dwTempURLSize);
				if(hrTemp != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog, "Couldn't retrieve incoming connection address!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
				}
				
				// Log the URL
				DPTEST_TRACE(pContext->hLog, "     pAddressDevice = %s", 1, pszTempURL);
				
				// Release the URL
				MemFree(pszTempURL);
			}
			
			if(!pContext->fCanAcceptConnect)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected connection indication!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fAcceptedConnect = TRUE;
			
			// Signal the main thread that a connection was indicated
			if (! SetEvent(pContext->hIndicateConnect))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set connection indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hIndicateConnect);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE pReceiveMsg;

			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReceiveMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pReceiveMsg->pvPlayerContext);
				// BUGBUG - create a common message format that contains the sender information
				// so that we can verify that this data is accurate
				DPTEST_TRACE(pContext->hLog, "     pReceiveData = 0x%08x", 1, pReceiveMsg->pReceiveData);
				DPTEST_TRACE(pContext->hLog, "     dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
				// BUGBUG - try holding onto this buffer and returning it on subsequent calls to receive
				// Use the buffer handle to return it later.  Maybe store the last buffer handle received
				// in the players context.
				DPTEST_TRACE(pContext->hLog, "     hBufferHandle = 0x%08x", 1, pReceiveMsg->hBufferHandle);
			}
			
			if(!pContext->fCanReceive)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected incoming message!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fReceived = TRUE;
			
			// Signal the main thread that data was received
			if (! SetEvent(pContext->hReceiveData))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hReceiveData);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE pSendCompleteMsg;

			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;

			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pSendCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of a send
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = 0x%08x", 1, pSendCompleteMsg->hAsyncOp);
				// BUGBUG - again check with the context and verify that this is the context that we
				// supplied with a call to send
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pSendCompleteMsg->pvUserContext);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pSendCompleteMsg->hResultCode);
				// BUGBUG - do lots of sends and see if this increases, what about guaranteed?
				DPTEST_TRACE(pContext->hLog, "     dwSendTime = %u ms", 1, pSendCompleteMsg->dwSendTime);
			}
			
			break;
		case DPN_MSGID_APPLICATION_DESC:
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_APPLICATION_DESC", 0);
			}
			
			if(!pContext->fAppDescCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected app desc change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fAppDescChanged = TRUE;
			
			// Signal the main thread that the app desc changed
			if (! SetEvent(pContext->hAppDescChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set app desc change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAppDescChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;

			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of an operation
				// that we have outstanding
				DPTEST_TRACE(pContext->hLog, "     hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
				// BUGBUG - are there ways to get this value to be a failure?
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);
			}
			
			if(!pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected asynchronous operation completion!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			if(pContext->dpnhAsyncOp != pAsyncOpCompleteMsg->hAsyncOp)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completion has unexpected handle (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->dpnhAsyncOp, pAsyncOpCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			}

			if(pContext->hrAsyncOpExpectedResult != pAsyncOpCompleteMsg->hResultCode)
			{
				DPTEST_TRACE(pContext->hLog, "Asynchronous operation completed with unexpected result (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.", 2,
					pContext->hrAsyncOpExpectedResult, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			}

			pContext->fAsyncOpCompleted = TRUE;
			
			// Signal the main thread that an asynchronous operation completed
			if (! SetEvent(pContext->hAsyncOpCompleted))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set incoming message indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompleted);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;
		case DPN_MSGID_CLIENT_INFO:
			PDPNMSG_CLIENT_INFO pClientInfoMsg;

			pClientInfoMsg = (PDPNMSG_CLIENT_INFO) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CLIENT_INFO", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pClientInfoMsg->dwSize);
				DPTEST_TRACE(pContext->hLog, "     dpnidClient = %u/%x", 2, pClientInfoMsg->dpnidClient, pClientInfoMsg->dpnidClient);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				DPTEST_TRACE(pContext->hLog, "     pvPlayerContext = 0x%08x", 1, pClientInfoMsg->pvPlayerContext);
			}
			
			if(!pContext->fClientInfoCanChange)
			{
				DPTEST_TRACE(pContext->hLog, "Unexpected client info change!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			}

			pContext->fClientInfoChanged = TRUE;
			
			// Signal the main thread that the client info changed
			if (! SetEvent(pContext->hClientInfoChanged))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set client info change indication event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hClientInfoChanged);
				
				DEBUGBREAK();
				
				if (hr == S_OK)
					hr = E_FAIL;
				
				break;
			} // end if (couldn't set event)

			break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;

			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;
			
			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pTerminateSessionMsg->dwSize);
				// BUGBUG - check the context and verify the difference between the host calling\
				// close and the host calling terminate session.
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pTerminateSessionMsg->hResultCode);
				// BUGBUG - check with the context and verify whether or not data should have been provided
				DPTEST_TRACE(pContext->hLog, "     pvTerminateData = 0x%08x", 1, pTerminateSessionMsg->pvTerminateData);
				DPTEST_TRACE(pContext->hLog, "     dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);
			}
			
			break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER pReturnBufferMsg;

			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;

			if(pContext->fVerbose)
			{
				DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RETURN_BUFFER", 0);
				DPTEST_TRACE(pContext->hLog, "     dwSize = %u", 1, pReturnBufferMsg->dwSize);
				// BUGBUG - in enum cases, this could be an error, otherwise, should be success
				DPTEST_TRACE(pContext->hLog, "     hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
				DPTEST_TRACE(pContext->hLog, "     pvBuffer = 0x%08x", 1, pReturnBufferMsg->pvBuffer);
				// BUGBUG - this should probably only be set in concurrent enumeration cases
				DPTEST_TRACE(pContext->hLog, "     pvUserContext = 0x%08x", 1, pReturnBufferMsg->pvUserContext);
			}
			
			if(!pReturnBufferMsg->pvBuffer)
			{
				DPTEST_TRACE(pContext->hLog, "Return buffer message with invalid buffer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
			}

			MemFree(pReturnBufferMsg->pvBuffer);

			break;
		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	dwEndTime = GetTickCount();

	pContext->dwCallbackTime += (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

	return (hr);
} // SimpleServerMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\dpwrap\wraputil.h ===
#ifndef __WRAPUTIL__
#define __WRAPUTIL__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>

//==================================================================================
// Prototypes
//==================================================================================
DWORD DpWrapDisplayException(DWORD dwExceptionType);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\dpwrap\wrapbase.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>

#include <dplay8.h>
#include <dpaddr.h>

#include "macros.h"
#include "wraputil.h"
#include "wrapbase.h"

//==================================================================================
// Class Definitions for the DP8Address Class
//==================================================================================



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::CWrapDP8Address()"
//==================================================================================
// CWrapDP8Address constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CWrapDP8Address object.
//
// Arguments: None.
//
// Returns: None (the object).
//==================================================================================
CWrapDP8Address::CWrapDP8Address(HANDLE hLog):
	m_pDP8Address(NULL),
	m_hLog(hLog)
{
} // CWrapDP8Address::CWrapDP8Address
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::~CWrapDP8Address()"
//==================================================================================
// CWrapDP8Address destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CWrapDP8Address object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CWrapDP8Address::~CWrapDP8Address(void)
{
	HRESULT			hr;

	if (this->m_pDP8Address != NULL)
	{
		hr = this->Release();
		if (hr != S_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed releasing DirectPlay8Address object!  0x%08x", hr);
		} // end if (failed releasing object)
	} // end if (we have an object pointer)
} // CWrapDP8Address::~CWrapDP8Address
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::CoCreate()"
//==================================================================================
// CWrapDP8Address::CoCreate
//----------------------------------------------------------------------------------
//
// Description: Calls CoCreateInstance for a new DirectPlay8Address object.
//
// Arguments: None.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Address::CoCreate(void)
{
	HRESULT		hr;

	if (this->m_pDP8Address != NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't create a DirectPlay8Address object because one already exists (%x)!",
			this->m_pDP8Address);
		hr = ERROR_ALREADY_EXISTS;
	} // end if (already have an object)
	else
	{
		hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &this->m_pDP8Address, NULL);
	} // end else (don't have an object)

	return (hr);
} // CWrapDP8Address::CoCreate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::Release()"
//==================================================================================
// CWrapDP8Address::Release
//----------------------------------------------------------------------------------
//
// Description: Releases the DirectPlay8Address object.
//
// Arguments: None.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Address::Release(void)
{
	HRESULT		hr = DPN_OK;

	if (this->m_pDP8Address == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't release DirectPlay8Address object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no object yet)
	else
	{
		this->m_pDP8Address->Release();
		this->m_pDP8Address = NULL;
		
		//this->m_fInitialized = FALSE;
		//this->m_fConnected = FALSE;
	} // end else (there's an object)

	return (hr);
} // CWrapDP8Address::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_BuildFromURLW()"
//==================================================================================
// CWrapDP8Address::DPA_BuildFromURLW
//----------------------------------------------------------------------------------
//
// Description: Builds this DNAddress object given a Unicode URL.
//
// Arguments:
//	WCHAR* wszSourceURL		Unicode string with URL from which to build.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_BuildFromURLW(WCHAR* wszSourceURL)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->BuildFromURLW(wszSourceURL);

	return (hr);
} // CWrapDP8Address::DPA_BuildFromURLW
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_BuildFromURLA()"
//==================================================================================
// CWrapDP8Address::DPA_BuildFromURLA
//----------------------------------------------------------------------------------
//
// Description: Builds this DNAddress object given an ANSI URL.
//
// Arguments:
//	CHAR* szSourceURL	ANSI string with URL from which to build.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_BuildFromURLA(CHAR* szSourceURL)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->BuildFromURLA(szSourceURL);
	
	return (hr);
} // CWrapDP8Address::DPA_BuildFromURLA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_Duplicate()"
//==================================================================================
// CWrapDP8Address::DPA_Duplicate
//----------------------------------------------------------------------------------
//
// Description: Duplicates this address into a new object.
//
// Arguments:
//	PDIRECTPLAY8ADDRESS* ppdpaNewAddress	Place to store new object created.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_Duplicate(PDIRECTPLAY8ADDRESS* ppdpaNewAddress)
{
	HRESULT			hr;

	hr = this->m_pDP8Address->Duplicate(ppdpaNewAddress);

	return (hr);
} // CWrapDP8Address::DPA_Duplicate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_SetEqual()"
//==================================================================================
// CWrapDP8Address::DPA_Duplicate
//----------------------------------------------------------------------------------
//
// Description: Duplicates this address into a new object.
//
// Arguments:
//	PDIRECTPLAY8ADDRESS* ppdpaNewAddress	Place to store new object created.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_SetEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress)
{
	HRESULT			hr;

	hr = this->m_pDP8Address->SetEqual(pdpaNewAddress);

	return (hr);
} // CWrapDP8Address::DPA_SetEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_IsEqual()"
//==================================================================================
// CWrapDP8Address::DPA_Duplicate
//----------------------------------------------------------------------------------
//
// Description: Duplicates this address into a new object.
//
// Arguments:
//	PDIRECTPLAY8ADDRESS* ppdpaNewAddress	Place to store new object created.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_IsEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress)
{
	HRESULT			hr;

	hr = this->m_pDP8Address->IsEqual(pdpaNewAddress);

	return (hr);
} // CWrapDP8Address::DPA_IsEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_Clear()"
//==================================================================================
// CWrapDP8Address::DPA_Clear
//----------------------------------------------------------------------------------
//
// Description: Duplicates this address into a new object.
//
// Arguments: None.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_Clear(void)
{
	HRESULT			hr;

	hr = this->m_pDP8Address->Clear();

	return (hr);
} // CWrapDP8Address::DPA_Clear
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetURLW()"
//==================================================================================
// CWrapDP8Address::DPA_GetURLW
//----------------------------------------------------------------------------------
//
// Description: Retrieves a Unicode URL corresponding to the object's current stored
//				information.
//				If the buffer is NULL or too small, the size required (in
//				characters, including NULL terminator) is returned in the DWORD
//				pointed to by pdwNumChars.
//
// Arguments:
//	WCHAR* pwszURL		Pointer to buffer to store results.
//	PDWORD pdwNumChars	Pointer to length of buffer, or place to store length
//						required.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetURLW(WCHAR* pwszURL, PDWORD pdwNumChars)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetURLW(pwszURL, pdwNumChars);

	return (hr);
} // CWrapDP8Address::DPA_GetURLW
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetURLA()"
//==================================================================================
// CWrapDP8Address::DPA_GetURLA
//----------------------------------------------------------------------------------
//
// Description: Retrieves an ANSI URL corresponding to the object's current stored
//				information.
//				If the buffer is NULL or too small, the size required (in
//				characters, including NULL terminator) is returned in the DWORD
//				pointed to by pdwNumChars.
//
// Arguments:
//	CHAR* pszURL		Pointer to buffer to store results.
//	PDWORD pdwNumChars	Pointer to length of buffer, or place to store size length
//						required.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetURLA(CHAR* pszURL, PDWORD pdwNumChars)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetURLA(pszURL, pdwNumChars);

	return (hr);
} // CWrapDP8Address::DPA_GetURLA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetSP()"
//==================================================================================
// CWrapDP8Address::DPA_GetSP
//----------------------------------------------------------------------------------
//
// Description: Retrieves the GUID of the SP currently indicated in the object.
//
// Arguments:
//	GUID* pguidSP	Pointer to buffer to store GUID.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetSP(GUID* pguidSP)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetSP(pguidSP);

	return (hr);
} // CWrapDP8Address::DPA_GetSP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetUserData()"
//==================================================================================
// CWrapDP8Address::DPA_GetUserData
//----------------------------------------------------------------------------------
//
// Description: Retrieves the current user data stored with the object.
//				If the buffer is NULL or too small, the size required (in bytes) is
//				returned in the DWORD pointed to by pdwDataSize.
//
// Arguments:
//	void* pvData			Pointer to buffer to store results.
//	PDWORD pdwBufferSize	Pointer to size of buffer, or place to store size required.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetUserData(void* pvUserData, PDWORD pdwBufferSize)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetUserData(pvUserData, pdwBufferSize);

	return (hr);
} // CWrapDP8Address::DPA_GetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_SetSP()"
//==================================================================================
// CWrapDP8Address::DPA_SetSP
//----------------------------------------------------------------------------------
//
// Description: Sets the GUID of the SP for the object.
//
// Arguments:
//	GUID* pguidSP	Pointer to GUID to set the provider to.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_SetSP(const GUID * const pguidSP)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->SetSP(pguidSP);

	return (hr);
} // CWrapDP8Address::DPA_SetSP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_SetUserData()"
//==================================================================================
// CWrapDP8Address::DPA_SetUserData
//----------------------------------------------------------------------------------
//
// Description: Sets the current user data associated with the object.
//
// Arguments:
//	void* pvUserData	Pointer to buffer with data to store.
//	DWORD dwDataSize	Size of user data buffer.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_SetUserData(const void * const pvUserData,
											const DWORD dwDataSize)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->SetUserData(pvUserData, dwDataSize);

	return (hr);
} // CWrapDP8Address::DPA_SetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetNumComponents()"
//==================================================================================
// CWrapDP8Address::DPA_GetNumComponents
//----------------------------------------------------------------------------------
//
// Description: Retrieves the number of elements stored in the address.
//
// Arguments:
//	PDWORD pdwNumComponents		Place to store number of components associated with
//								object.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetNumComponents(PDWORD pdwNumComponents)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetNumComponents(pdwNumComponents);

	return (hr);
} // CWrapDP8Address::DPA_GetNumComponents
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetComponentByName()"
//==================================================================================
// CWrapDP8Address::DPA_GetComponentByName
//----------------------------------------------------------------------------------
//
// Description: Retrieves the element with the given name.
//
// Arguments:
//	WCHAR* wszName			Unicode string holding name of element to retrieve.
//	void* pvBuffer			Pointer to buffer to hold value.
//	PDWORD pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//	PDWORD pdwDataType		Place to store data type of value.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetComponentByName(const WCHAR * const wszName,
													void* pvBuffer,
													PDWORD pdwBufferSize,
													PDWORD pdwDataType)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetComponentByName(wszName, pvBuffer, pdwBufferSize, pdwDataType);

	return (hr);
} // CWrapDP8Address::DPA_GetComponentByName
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetComponentByIndex()"
//==================================================================================
// CWrapDP8Address::DPA_GetComponentByIndex
//----------------------------------------------------------------------------------
//
// Description: Retrieves the element with the given name.
//
// Arguments:
//	DWORD dwComponentID		Index of component to retrieve.
//	WCHAR* pwszName			Place to store Unicode name of element.
//	PDWORD pdwNameLen		Pointer to length of string, or place to store length
//							required.
//	void* pvBuffer			Pointer to buffer to hold value.
//	PDWORD pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//	PDWORD pdwDataType		Place to store data type of value.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetComponentByIndex(const DWORD dwComponentID,
													WCHAR* pwszName,
													PDWORD pdwNameLen,
													void* pvBuffer,
													PDWORD pdwBufferSize,
													PDWORD pdwDataType)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetComponentByIndex(dwComponentID, pwszName, pdwNameLen, pvBuffer, pdwBufferSize, pdwDataType);

	return (hr);
} // CWrapDP8Address::DPA_GetComponentByIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_AddComponent()"
//==================================================================================
// CWrapDP8Address::DPA_AddComponent
//----------------------------------------------------------------------------------
//
// Description: Adds an element with the given name and value.
//
// Arguments:
//	WCHAR* wszName		Unicode name of element.
//	void* pvData		Pointer to data for element.
//	DWORD dwDataSize	Size of data.
//	DWORD dwDataType	Type of data.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_AddComponent(const WCHAR * const wszName,
												const void * const pvData,
												const DWORD dwDataSize,
												const DWORD dwDataType)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->AddComponent(wszName, pvData, dwDataSize, dwDataType);

	return (hr);
} // CWrapDP8Address::DPA_AddComponent
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_GetDevice()"
//==================================================================================
// CWrapDP8Address::DPA_GetDevice
//----------------------------------------------------------------------------------
//
// Description: Retrieves the GUID of the device currently indicated in the object.
//
// Arguments:
//	GUID* pguidSP	Pointer to buffer to store GUID.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_GetDevice(GUID* pguidSP)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->GetDevice(pguidSP);

	return (hr);
} // CWrapDP8Address::DPA_GetDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_SetDevice()"
//==================================================================================
// CWrapDP8Address::DPA_SetDevice
//----------------------------------------------------------------------------------
//
// Description: Sets the GUID of the device for the object.
//
// Arguments:
//	GUID* pguidSP	Pointer to GUID to set the evice to.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_SetDevice(const GUID * const pguidSP)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->SetDevice(pguidSP);

	return (hr);
} // CWrapDP8Address::DPA_SetDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_BuildFromSockAddr()"
//==================================================================================
// CWrapDP8Address::DPA_BuildFromSockAddr
//----------------------------------------------------------------------------------
//
// Description: Sets the GUID of the device for the object.
//
// Arguments:
//	SOCKADDR* pSockAddr		Pointer to SOCKADDR to set the address to
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_BuildFromSockAddr(const SOCKADDR * const pSockAddr)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->BuildFromSockAddr(pSockAddr);

	return (hr);
} // CWrapDP8Address::DPA_BuildFromSockAddr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





// TODO - No legacy support for Xbox
/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Address::DPA_BuildFromDPADDRESS()"
//==================================================================================
// CWrapDP8Address::DPA_BuildFromDPADDRESS
//----------------------------------------------------------------------------------
//
// Description: Builds this DNAddress object given a DPlay7 Address.
//
// Arguments:
//	PVOID pvAddress		DPlay7 Address to convert.
//	DWORD dwDataSize	Size of DPlay7 buffer to convert
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Address::DPA_BuildFromDPADDRESS(void* pvAddress, DWORD dwDataSize)
{
	HRESULT		hr;

	hr = this->m_pDP8Address->BuildFromDPADDRESS(pvAddress, dwDataSize);

	return (hr);
} // CWrapDP8Address::DPA_BuildFromDPADDRESS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/


/*************************************************************************************

  
//==================================================================================
// Class Definitions for the DP8AddressIP Class
//==================================================================================


**************************************************************************************/

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::CWrapDP8AddressIP()"
//==================================================================================
// CWrapDP8AddressIP constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CWrapDP8AddressIP object.
//
// Arguments: None.
//
// Returns: None (the object).
//==================================================================================
CWrapDP8AddressIP::CWrapDP8AddressIP(HANDLE hLog):
	m_pDP8AddressIP(NULL),
	m_hLog(hLog)
{
} // CWrapDP8AddressIP::CWrapDP8AddressIP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::~CWrapDP8AddressIP()"
//==================================================================================
// CWrapDP8Address destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CWrapDP8AddressIP object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CWrapDP8AddressIP::~CWrapDP8AddressIP(void)
{
	HRESULT			hr;

	if (this->m_pDP8AddressIP != NULL)
	{
		hr = this->Release();
		if (hr != S_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed releasing DirectPlay8AddressIP object!  0x%08x", hr);
		} // end if (failed releasing object)
	} // end if (we have an object pointer)
} // CWrapDP8AddressIP::~CWrapDP8AddressIP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::CoCreate()"
//==================================================================================
// CWrapDP8AddressIP::CoCreate
//----------------------------------------------------------------------------------
//
// Description: Calls CoCreateInstance for a new DirectPlay8AddressIP object.
//
// Arguments: None.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8AddressIP::CoCreate(void)
{
	HRESULT		hr;

	if (this->m_pDP8AddressIP != NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't create a DirectPlay8AddressIP object because one already exists (%x)!",
			this->m_pDP8AddressIP);
		hr = ERROR_ALREADY_EXISTS;
	} // end if (already have an object)
	else
	{
		hr = DirectPlay8AddressCreate(IID_IDirectPlay8AddressIP, (LPVOID *) &this->m_pDP8AddressIP, NULL);
	} // end else (don't have an object)

	return (hr);
} // CWrapDP8AddressIP::CoCreate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::Release()"
//==================================================================================
// CWrapDP8AddressIP::Release
//----------------------------------------------------------------------------------
//
// Description: Releases the DirectPlay8AddressIP object.
//
// Arguments: None.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8AddressIP::Release(void)
{
	HRESULT		hr = DPN_OK;

	if (this->m_pDP8AddressIP == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't release DirectPlay8AddressIP object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no object yet)
	else
	{
		this->m_pDP8AddressIP->Release();
		this->m_pDP8AddressIP = NULL;
		
		//this->m_fInitialized = FALSE;
		//this->m_fConnected = FALSE;
	} // end else (there's an object)

	return (hr);
} // CWrapDP8AddressIP::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_Duplicate()"
//==================================================================================
// CWrapDP8AddressIP::DPA_Duplicate
//----------------------------------------------------------------------------------
//
// Description: Duplicates this address into a new object.
//
// Arguments:
//	PDIRECTPLAY8ADDRESS* ppdpaNewAddress	Place to store new object created.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_Duplicate(PDIRECTPLAY8ADDRESS* ppdpaNewAddress)
{
	HRESULT			hr;

	hr = this->m_pDP8AddressIP->Duplicate(ppdpaNewAddress);

	return (hr);
} // CWrapDP8AddressIP::DPA_Duplicate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_SetEqual()"
//==================================================================================
// CWrapDP8AddressIP::DPA_SetEqual
//----------------------------------------------------------------------------------
//
// Description: Sets the this object equal to the one being passed in.
//
// Arguments:
//	PDIRECTPLAY8ADDRESS pdpaNewAddress	Object we are setting equal to.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_SetEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress)
{
	HRESULT			hr;

	hr = this->m_pDP8AddressIP->SetEqual(pdpaNewAddress);

	return (hr);
} // CWrapDP8AddressIP::DPA_SetEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_IsEqual()"
//==================================================================================
// CWrapDP8AddressIP::DPA_Duplicate
//----------------------------------------------------------------------------------
//
// Description:	Compares this address into a new object.
//
// Arguments:
//	PDIRECTPLAY8ADDRESS* ppdpaNewAddress	Place to store new object created.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_IsEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress)
{
	HRESULT			hr;

	hr = this->m_pDP8AddressIP->IsEqual(pdpaNewAddress);

	return (hr);
} // CWrapDP8AddressIP::DPA_IsEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_GetURLW()"
//==================================================================================
// CWrapDP8AddressIP::DPA_GetURLW
//----------------------------------------------------------------------------------
//
// Description: Retrieves a Unicode URL corresponding to the object's current stored
//				information.
//				If the buffer is NULL or too small, the size required (in
//				characters, including NULL terminator) is returned in the DWORD
//				pointed to by pdwNumChars.
//
// Arguments:
//	WCHAR* pwszURL		Pointer to buffer to store results.
//	PDWORD pdwNumChars	Pointer to length of buffer, or place to store length
//						required.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_GetURLW(WCHAR* pwszURL, PDWORD pdwNumChars)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->GetURLW(pwszURL, pdwNumChars);

	return (hr);
} // CWrapDP8AddressIP::DPA_GetURLW
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_GetURLA()"
//==================================================================================
// CWrapDP8AddressIP::DPA_GetURLA
//----------------------------------------------------------------------------------
//
// Description: Retrieves an ANSI URL corresponding to the object's current stored
//				information.
//				If the buffer is NULL or too small, the size required (in
//				characters, including NULL terminator) is returned in the DWORD
//				pointed to by pdwNumChars.
//
// Arguments:
//	CHAR* pszURL		Pointer to buffer to store results.
//	PDWORD pdwNumChars	Pointer to length of buffer, or place to store size length
//						required.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_GetURLA(CHAR* pszURL, PDWORD pdwNumChars)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->GetURLA(pszURL, pdwNumChars);

	return (hr);
} // CWrapDP8AddressIP::DPA_GetURLA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_GetUserData()"
//==================================================================================
// CWrapDP8AddressIP::DPA_GetUserData
//----------------------------------------------------------------------------------
//
// Description: Retrieves the current user data stored with the object.
//				If the buffer is NULL or too small, the size required (in bytes) is
//				returned in the DWORD pointed to by pdwDataSize.
//
// Arguments:
//	void* pvData			Pointer to buffer to store results.
//	PDWORD pdwBufferSize	Pointer to size of buffer, or place to store size required.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_GetUserData(void* pvUserData, PDWORD pdwBufferSize)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->GetUserData(pvUserData, pdwBufferSize);

	return (hr);
} // CWrapDP8AddressIP::DPA_GetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_SetUserData()"
//==================================================================================
// CWrapDP8AddressIP::DPA_SetUserData
//----------------------------------------------------------------------------------
//
// Description: Sets the current user data associated with the object.
//
// Arguments:
//	void* pvUserData	Pointer to buffer with data to store.
//	DWORD dwDataSize	Size of user data buffer.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_SetUserData(const void * const pvUserData,
											    const DWORD dwDataSize)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->SetUserData(pvUserData, dwDataSize);

	return (hr);
} // CWrapDP8AddressIP::DPA_SetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_BuildFromSockAddr()"
//==================================================================================
// CWrapDP8AddressIP::DPA_BuildFromSockAddr
//----------------------------------------------------------------------------------
//
// Description: Retrieves the number of elements stored in the address.
//
// Arguments:
//	SOCKADDR pSockAddr	Sock address to build from.
//								
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_BuildFromSockAddr(SOCKADDR* pSockAddr)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->BuildFromSockAddr(pSockAddr);

	return (hr);
} // CWrapDP8AddressIP::DPA_BuildFromSockAddr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_GetSockAddress()"
//==================================================================================
// CWrapDP8AddressIP::DPA_GetSockAddress
//----------------------------------------------------------------------------------
//
// Description: Retrieves the element with the given name.
//
// Arguments:
//	SOCKADDR* psockAddress. Sock address pointer of SOCKAddr retrieved
//	PDWORD pdwAddressBufferSize		Size of Sock Address Buffer Recieved.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_GetSockAddress(SOCKADDR* psockAddress,
													PDWORD pdwAddressBufferSize)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->GetSockAddress(psockAddress, pdwAddressBufferSize);

	return (hr);
} // CWrapDP8Address::DPA_GetComponentByName
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_BuildAddress()"
//==================================================================================
// CWrapDP8AddressIP::DPA_BuildAddress
//----------------------------------------------------------------------------------
//
// Description: Retrieves the element with the given name.
//
// Arguments:
//	WCHAR* pwszAddress		Remote address to build Address from.
//	USHORT usPort			Port on remote host to connect.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_BuildAddress(WCHAR* pwszAddress,
												 USHORT usPort)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->BuildAddress(pwszAddress, usPort);

	return (hr);
} // CWrapDP8AddressIP::DPA_BuildAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_GetAddress()"
//==================================================================================
// CWrapDP8AddressIP::DPA_GetAddress
//----------------------------------------------------------------------------------
//
// Description: Adds an element with the given name and value.
//
// Arguments:
//	WCHAR* pwszAddress		Buffer to receive hostname.
//	PDWORD pdwAddressLength Size of address buffer.
//	USHORT*	psPort			Port specified in the address structure.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_GetAddress(WCHAR* pwszAddress,
											   PDWORD pdwAddressLength,
											   USHORT* pusPort)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->GetAddress(pwszAddress, pdwAddressLength, pusPort);

	return (hr);
} // CWrapDP8AddressIP::DPA_GetAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_BuildLocalAddress()"
//==================================================================================
// CWrapDP8AddressIP::DPA_BuildLocalAddress
//----------------------------------------------------------------------------------
//
// Description: Retrieves the element with the given name.
//
// Arguments:
//	GUID* pguidAdapter		GUID of adapter to build address from.
//	USHORT usPort			Port on local device to host from.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_BuildLocalAddress(GUID* pguidAdapter,
													  USHORT usPort)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->BuildLocalAddress(pguidAdapter, usPort);

	return (hr);
} // CWrapDP8AddressIP::DPA_BuildLocalAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8AddressIP::DPA_GetLocalAddress()"
//==================================================================================
// CWrapDP8AddressIP::DPA_GetLocalAddress
//----------------------------------------------------------------------------------
//
// Description: Adds an element with the given name and value.
//
// Arguments:
//	GUID* pguidAdapter		Buffer to receive hostname.
//	USHORT*	pusPort			Port specified in the address structure.
//
// Returns: DN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8AddressIP::DPA_GetLocalAddress(GUID* pguidAdapter,
													USHORT* pusPort)
{
	HRESULT		hr;

	hr = this->m_pDP8AddressIP->GetLocalAddress(pguidAdapter, pusPort);

	return (hr);
} // CWrapDP8AddressIP::DPA_GetLocalAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\dpwrap\wrappeer.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>

#include <dplay8.h>
#include <dpaddr.h>

#include "macros.h"
#include "wraputil.h"
#include "wrappeer.h"

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::CWrapDP8Peer()"
//==================================================================================
// CWrapDP8Peer constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CWrapDP8Peer object.
//
// Arguments: None.
//
// Returns: None (the object).
//==================================================================================
CWrapDP8Peer::CWrapDP8Peer(HANDLE hLog):
#ifndef REMOVE_DPLAY_IMPORTS
	m_pDP8Peer(NULL),
#endif
	m_hLog(hLog),
	m_fInitialized(FALSE)
{
} // CWrapDP8Peer::CWrapDP8Peer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::~CWrapDP8Peer()"
//==================================================================================
// CWrapDP8Peer destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CWrapDP8Peer object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CWrapDP8Peer::~CWrapDP8Peer(void)
{
#ifndef REMOVE_DPLAY_IMPORTS
	HRESULT			hr;

	if (this->m_fInitialized)
	{
		hr = this->DP8P_Close(0);
		if (hr != DPN_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed closing!  0x%08x", hr);
		} // end if (failed closing)
	} // end if (initialized object)

	if (this->m_pDP8Peer != NULL)
	{
		hr = this->Release();
		if (hr != S_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed releasing DirectPlay8Peer object!  0x%08x", hr);
		} // end if (failed releasing object)
	} // end if (we have an object pointer)
#endif

	m_hLog = NULL;
} // CWrapDP8Peer::~CWrapDP8Peer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::CoCreate()"
//==================================================================================
// CWrapDP8Peer::CoCreate
//----------------------------------------------------------------------------------
//
// Description: Calls CoCreateInstance for a new DirectPlay8Peer object.
//
// Arguments: None.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Peer::CoCreate(void)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	if (this->m_pDP8Peer != NULL)
	{
		xLog(m_hLog, XLL_WARN,  "Can't create a DirectPlay8Peer object because one already exists (%x)!", this->m_pDP8Peer);
		hr = ERROR_ALREADY_EXISTS;
	} // end if (already have an object)
	else
	{
		hr = DirectPlay8Create(IID_IDirectPlay8Peer, (LPVOID *) &this->m_pDP8Peer, NULL);
	} // end else (don't have an object)
#endif

	return (hr);
} // CWrapDP8Peer::CoCreate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::Release()"
//==================================================================================
// CWrapDP8Peer::Release
//----------------------------------------------------------------------------------
//
// Description: Releases the DirectPlay8Peer object.
//
// Arguments: None.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Peer::Release(void)
{
	HRESULT		hr = DPN_OK;
	
#ifndef REMOVE_DPLAY_IMPORTS
	if (this->m_pDP8Peer == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't release DirectPlay8Peer object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no object yet)
	else
	{
		this->m_pDP8Peer->Release();
		this->m_pDP8Peer = NULL;
		
		this->m_fInitialized = FALSE;
	} // end else (there's an object)
#endif

	return (hr);
} // CWrapDP8Peer::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_Initialize()"
//==================================================================================
// CWrapDP8Peer::DP8P_Initialize
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PVOID pvUserContext			?
//	PFNDPNMESSAGEHANDLER pfn	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_Initialize(PVOID const pvUserContext,
											const PFNDPNMESSAGEHANDLER pfn,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;
	
#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->Initialize(pvUserContext, pfn, dwFlags);

	if (hr == DPN_OK)
	{
		this->m_fInitialized = TRUE;
	} // end if (successfully initialized object)

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DoWork()"
//==================================================================================
// CWrapDP8Peer::DP8P_DoWork
//----------------------------------------------------------------------------------
//
// Description: Pump function that causes DirectPlay to do some processing
//
// Arguments:
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_DoWork(const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->DoWork(dwFlags);
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_DoWork
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_EnumServiceProviders()"
//==================================================================================
// CWrapDP8Peer::DP8P_EnumServiceProviders
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	GUID* pguidServiceProvider					?
//	GUID* pguidApplication						?
//	DPN_SERVICE_PROVIDER_INFO* pSPInfoBuffer	?
//	DWORD* pcbEnumData							?
//	DWORD* pcReturned							?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_EnumServiceProviders(const GUID * const pguidServiceProvider,
													const GUID * const pguidApplication,
													DPN_SERVICE_PROVIDER_INFO * const pSPInfoBuffer,
													DWORD * const pcbEnumData,
													DWORD * const pcReturned,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->EnumServiceProviders(pguidServiceProvider,
		pguidApplication,
		pSPInfoBuffer,
		pcbEnumData,
		pcReturned,
		dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_EnumServiceProviders
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_CancelAsyncOperation()"
//==================================================================================
// CWrapDP8Peer::DP8P_CancelAsyncOperation
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNHANDLE hAsyncHandle	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_CancelAsyncOperation(const DPNHANDLE hAsyncHandle,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->CancelAsyncOperation(hAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_CancelAsyncOperation
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_Connect()"
//==================================================================================
// CWrapDP8Peer::DP8P_Connect
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pdnAppDesc			?
//	IDirectPlay8Address* pHostAddr				?
//	IDirectPlay8Address* pDeviceInfo			?
//	DPN_SECURITY_DESC* pdnSecurity				?
//	DPN_SECURITY_CREDENTIALS* pdnCredentials	?
//	void* pvUserConnectData						?
//	DWORD dwUserConnectDataSize					?
//	void* pvPlayerContext						?
//	void* pvAsyncContext						?
//	DPNHANDLE* phAsyncHandle					?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_Connect(const DPN_APPLICATION_DESC * const pdnAppDesc,
										IDirectPlay8Address * const pHostAddr,
										IDirectPlay8Address * const pDeviceInfo,
										const DPN_SECURITY_DESC * const pdnSecurity,
										const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
										const void * const pvUserConnectData,
										const DWORD dwUserConnectDataSize,
										void * const pvPlayerContext,
										void * const pvAsyncContext,
										DPNHANDLE * const phAsyncHandle,
										const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->Connect(pdnAppDesc, pHostAddr, pDeviceInfo,
		pdnSecurity, pdnCredentials,
		pvUserConnectData, dwUserConnectDataSize,
		pvPlayerContext, pvAsyncContext,
		phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_Connect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_SendTo()"
//==================================================================================
// CWrapDP8Peer::DP8P_SendTo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid						?
//	DPN_BUFFER_DESC* prgBufferDesc	?
//	DWORD cBufferDesc				?
//	DWORD dwTimeOut					?
//	void* pvAsyncContext			?
//	DPNHANDLE* phAsyncHandle		?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_SendTo(const DPNID dpnid,
										const DPN_BUFFER_DESC * const prgBufferDesc,
										const DWORD cBufferDesc,
										const DWORD dwTimeOut,
										void * const pvAsyncContext,
										DPNHANDLE * const phAsyncHandle,
										const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->SendTo(dpnid, prgBufferDesc, cBufferDesc, dwTimeOut,
								pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_SendTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetSendQueueInfo()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetSendQueueInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid			?
//	DWORD* pdwNumMsgs	?
//	DWORD* pdwNumBytes	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetSendQueueInfo(const DPNID dpnid,
												DWORD * const pdwNumMsgs,
												DWORD * const pdwNumBytes,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;
	
#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetSendQueueInfo(dpnid, pdwNumMsgs, pdwNumBytes,
		dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetSendQueueInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_Host()"
//==================================================================================
// CWrapDP8Peer::DP8P_Host
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pdnAppDesc			?
//	IDirectPlay8Address** prgpDeviceInfo		?
//	DWORD cDeviceInfo							?
//	DPN_SECURITY_DESC* pdnSecurity				?
//	DPN_SECURITY_CREDENTIALS* pdnCredentials	?
//	void * pvPlayerContext						?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
// BUGBUG - working around requirement for host to have a session name
STDMETHODIMP CWrapDP8Peer::DP8P_Host(const DPN_APPLICATION_DESC * const pdnAppDesc,
									 IDirectPlay8Address ** const prgpDeviceInfo,
									const DWORD cDeviceInfo,
									const DPN_SECURITY_DESC * const pdnSecurity,
									const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
									void * const pvPlayerContext,
									const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->Host(pdnAppDesc, prgpDeviceInfo, cDeviceInfo,
								pdnSecurity, pdnCredentials, pvPlayerContext,
								dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_Host
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetApplicationDesc()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetApplicationDesc
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pAppDescBuffer	?
//	DWORD* pcbDataSize						?
//	DWORD dwFlags							?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetApplicationDesc(DPN_APPLICATION_DESC * const pAppDescBuffer,
													DWORD * const pcbDataSize,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetApplicationDesc(pAppDescBuffer, pcbDataSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetApplicationDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_SetApplicationDesc()"
//==================================================================================
// CWrapDP8Peer::DP8P_SetApplicationDesc
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_SetApplicationDesc(const DPN_APPLICATION_DESC * const pad,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->SetApplicationDesc(pad, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_SetApplicationDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_CreateGroup()"
//==================================================================================
// CWrapDP8Peer::DP8P_CreateGroup
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_GROUP_INFO* pdpnGroupInfo	?
//	PVOID pvGroupContext			?
//	PVOID pvAsyncContext			?
//	DPNHANDLE* phAsyncHandle		?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_CreateGroup(const DPN_GROUP_INFO * const pdpnGroupInfo,
											PVOID const pvGroupContext,
											PVOID const pvAsyncContext,
											DPNHANDLE * const phAsyncHandle,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->CreateGroup(pdpnGroupInfo, pvGroupContext,
									pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_CreateGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_DestroyGroup()"
//==================================================================================
// CWrapDP8Peer::DP8P_DestroyGroup
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID idGroup				?
//	PVOID pvAsyncContext		?
//	DPNHANDLE * phAsyncHandle	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_DestroyGroup(const DPNID idGroup,
											PVOID const pvAsyncContext,
											DPNHANDLE * const phAsyncHandle,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->DestroyGroup(idGroup, pvAsyncContext,
									phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_DestroyGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_AddPlayerToGroup()"
//==================================================================================
// CWrapDP8Peer::DP8P_AddPlayerToGroup
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID idGroup				?
//	DPNID idClient				?
//	PVOID pvAsyncContext		?
//	DPNHANDLE * phAsyncHandle	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_AddPlayerToGroup(const DPNID idGroup,
												const DPNID idClient,
												PVOID const pvAsyncContext,
												DPNHANDLE * const phAsyncHandle,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->AddPlayerToGroup(idGroup, idClient, pvAsyncContext,
									phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_AddPlayerToGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_RemovePlayerFromGroup()"
//==================================================================================
// CWrapDP8Peer::DP8P_RemovePlayerFromGroup
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID idGroup				?
//	DPNID idClient				?
//	PVOID pvAsyncContext		?
//	DPNHANDLE * phAsyncHandle	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_RemovePlayerFromGroup(const DPNID idGroup,
													const DPNID idClient,
													PVOID const pvAsyncContext,
													DPNHANDLE * const phAsyncHandle,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->RemovePlayerFromGroup(idGroup, idClient, pvAsyncContext,
											phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_RemovePlayerFromGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_SetGroupInfo()"
//==================================================================================
// CWrapDP8Peer::DP8P_SetGroupInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid						?
//	DPN_GROUP_INFO* pdpnGroupInfo	?
//	PVOID pvAsyncContext			?
//	DPNHANDLE * phAsyncHandle		?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_SetGroupInfo(const DPNID dpnid,
											DPN_GROUP_INFO * const pdpnGroupInfo,
											PVOID const pvAsyncContext,
											DPNHANDLE * const phAsyncHandle,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->SetGroupInfo(dpnid, pdpnGroupInfo, pvAsyncContext,
									phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_SetGroupInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetGroupInfo()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetGroupInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid						?
//	DPN_GROUP_INFO* pdpnGroupInfo	?
//	DWORD* pdwSize					?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetGroupInfo(const DPNID dpnid,
											DPN_GROUP_INFO * const pdpnGroupInfo,
											DWORD * const pdwSize,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetGroupInfo(dpnid, pdpnGroupInfo, pdwSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetGroupInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_EnumPlayersAndGroups()"
//==================================================================================
// CWrapDP8Peer::DP8P_EnumPlayersAndGroups
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID* prgdpid	?
//	DWORD* pcdpid	?
//	DWORD dwFlags	?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_EnumPlayersAndGroups(DPNID * const prgdpid,
													DWORD * const pcdpid,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->EnumPlayersAndGroups(prgdpid, pcdpid, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_EnumPlayersAndGroups
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_EnumGroupMembers()"
//==================================================================================
// CWrapDP8Peer::DP8P_EnumGroupMembers
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpid		?
//	DPNID* prgdpid	?
//	DWORD* pcdpid	?
//	DWORD dwFlags	?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_EnumGroupMembers(const DPNID dpid,
												DPNID * const prgdpid,
												DWORD * const pcdpid,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->EnumGroupMembers(dpid, prgdpid, pcdpid, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_EnumGroupMembers
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_SetPeerInfo()"
//==================================================================================
// CWrapDP8Peer::DP8P_SetPeerInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_PLAYER_INFO* pdpnGroupInfo	?
//	PVOID pvAsyncContext			?
//	DPNHANDLE * phAsyncHandle		?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_SetPeerInfo(const DPN_PLAYER_INFO * const pdpnPlayerInfo,
											PVOID const pvAsyncContext,
											DPNHANDLE * const phAsyncHandle,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->SetPeerInfo(pdpnPlayerInfo, pvAsyncContext,
									phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_SetPeerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetPeerInfo()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetPeerInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid							?
//	DPN_PLAYER_INFO* pdpnPlayerInfo		?
//	DWORD* pdwSize						?
//	DWORD dwFlags						?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetPeerInfo(const DPNID dpnid,
											DPN_PLAYER_INFO * const pdpnPlayerInfo,
											DWORD * const pdwSize,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetPeerInfo(dpnid, pdpnPlayerInfo, pdwSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetPeerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetPeerAddress()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetPeerAddress
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid							ID of player whose address should be
//										retrieved
//	IDirectPlay8Address ** pAddress		Place to store address object of player.
//	DWORD dwFlags						Unused.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetPeerAddress(const DPNID dpnid,
												IDirectPlay8Address ** const pAddress,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetPeerAddress(dpnid, pAddress, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetPeerAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetLocalHostAddresses()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetLocalHostAddresses
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	IDirectPlay8Address** prgpAddress	?
//	DWORD* pcAddress					?
//	DWORD dwFlags						?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetLocalHostAddresses(IDirectPlay8Address ** const prgpAddress,
													DWORD * const pcAddress,
													const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetLocalHostAddresses(prgpAddress, pcAddress, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetLocalHostAddresses
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_Close()"
//==================================================================================
// CWrapDP8Peer::DP8P_Close
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DWORD dwFlags	?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_Close(const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	if (this->m_pDP8Peer == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't close DirectPlay8Peer object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no real object)
	else
	{
		hr = this->m_pDP8Peer->Close(dwFlags);

		if (hr == DPN_OK)
		{
			this->m_fInitialized = FALSE;
		} // end if (successfully closed)
	} // end else (real object)
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_Close
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_EnumHosts()"
//==================================================================================
// CWrapDP8Peer::DP8P_EnumHosts
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PDPN_APPLICATION_DESC pApplicationDesc	?
//	IDirectPlay8Address* pAddrHost			?
//	IDirectPlay8Address* pDeviceInfo		?
//	PVOID pUserEnumData						?
//	DWORD dwUserEnumDataSize				?
//	DWORD dwEnumCount						?
//	DWORD dwRetryInterval					?
//	DWORD dwTimeOut							?
//	PVOID pvUserContext						?
//	DPNHANDLE* pAsyncHandle					?
//	DWORD dwFlags							?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,
										IDirectPlay8Address * const pAddrHost,
										IDirectPlay8Address * const pDeviceInfo,
										PVOID const pUserEnumData,
										const DWORD dwUserEnumDataSize,
										const DWORD dwEnumCount,
										const DWORD dwRetryInterval,
										const DWORD dwTimeOut,
										PVOID const pvUserContext,
										DPNHANDLE * const pAsyncHandle,
										const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->EnumHosts(pApplicationDesc, pAddrHost, pDeviceInfo,
								pUserEnumData, dwUserEnumDataSize,
								dwEnumCount, dwRetryInterval, dwTimeOut,
								pvUserContext, pAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_EnumHosts
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_DestroyPeer()"
//==================================================================================
// CWrapDP8Peer::DP8P_DestroyPeer
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpidClient			?
//	BYTE* pDestroyInfo			?
//	DWORD dwDestroyInfoSize		?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_DestroyPeer(const DPNID dpidClient,
											const void * const pDestroyInfo,
											const DWORD dwDestroyInfoSize,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->DestroyPeer(dpidClient,
									pDestroyInfo, dwDestroyInfoSize,
									dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_DestroyPeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_ReturnBuffer()"
//==================================================================================
// CWrapDP8Peer::DP8P_ReturnBuffer
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNHANDLE hBufferHandle	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_ReturnBuffer(const DPNHANDLE hBufferHandle,
											const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->ReturnBuffer(hBufferHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_ReturnBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetPlayerContext()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetPlayerContext
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid					?
//	PVOID* ppvPlayerContext		?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetPlayerContext(const DPNID dpnid,
												PVOID * const ppvPlayerContext,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetPlayerContext(dpnid, ppvPlayerContext, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetPlayerContext
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetGroupContext()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetGroupContext
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid				?
//	PVOID* ppvGroupContext	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetGroupContext(const DPNID dpnid,
												PVOID * const ppvGroupContext,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetGroupContext(dpnid, ppvGroupContext, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetGroupContext
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetCaps()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_CAPS* pdpCaps	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetCaps(DPN_CAPS * const pdpCaps, const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetCaps(pdpCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_SetCaps()"
//==================================================================================
// CWrapDP8Peer::DP8P_SetCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_CAPS* pdpCaps	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_SetCaps(const DPN_CAPS * const pdpCaps,
										const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->SetCaps(pdpCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_SetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_SetSPCaps()"
//==================================================================================
// CWrapDP8Peer::DP8P_SetSPCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	GUID* pguidSP			?
//	DPN_SP_CAPS* pdpspCaps	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_SetSPCaps(const GUID * const pguidSP,
										const DPN_SP_CAPS * const pdpspCaps,
										const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->SetSPCaps(pguidSP, pdpspCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_SetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetSPCaps()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetSPCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	GUID* pguidSP			?
//	DPN_SP_CAPS* pdpspCaps	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetSPCaps(const GUID * const pguidSP,
										DPN_SP_CAPS *const pdpspCaps,
										const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetSPCaps(pguidSP, pdpspCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_GetConnectionInfo()"
//==================================================================================
// CWrapDP8Peer::DP8P_GetConnectionInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid								?
//	DPN_CONNECTION_INFO* pdpConnectionInfo	?
//	DWORD dwFlags							?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_GetConnectionInfo(const DPNID dpnid,
												DPN_CONNECTION_INFO * const pdpConnectionInfo,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->GetConnectionInfo(dpnid, pdpConnectionInfo, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_GetConnectionInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Peer::DP8P_TerminateSession()"
//==================================================================================
// CWrapDP8Peer::DP8P_TerminateSession
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	void* pvTerminateData		?
//	DWORD dwTerminateDataSize	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Peer::DP8P_TerminateSession(void * const pvTerminateData,
												const DWORD dwTerminateDataSize,
												const DWORD dwFlags)
{
	HRESULT		hr = DPN_OK;

#ifndef REMOVE_DPLAY_IMPORTS
	hr = this->m_pDP8Peer->TerminateSession(pvTerminateData, dwTerminateDataSize,
										dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Peer->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
#endif

	return (hr);
} // CWrapDP8Peer::DP8P_TerminateSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\dpwrap\wrapserver.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>

#include <dplay8.h>
#include <dpaddr.h>

#include "macros.h"
#include "wraputil.h"
#include "wrapserver.h"

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::CWrapDP8Server()"
//==================================================================================
// CWrapDP8Server constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CWrapDP8Server object.
//
// Arguments: None.
//
// Returns: None (the object).
//==================================================================================
CWrapDP8Server::CWrapDP8Server(HANDLE hLog):
	m_pDP8Server(NULL),
	m_hLog(hLog),
	m_fInitialized(FALSE)
{
} // CWrapDP8Server::CWrapDP8Server
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::~CWrapDP8Server()"
//==================================================================================
// CWrapDP8Server destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CWrapDP8Server object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CWrapDP8Server::~CWrapDP8Server(void)
{
	HRESULT			hr;

//#pragma BUGBUG(vanceo, "make these an option (graceful or un)")

	if (this->m_fInitialized)
	{
		hr = this->DP8S_Close(0);
		if (hr != DPN_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed closing!  0x%08x", hr);
		} // end if (failed closing)
	} // end if (initialized object)

	if (this->m_pDP8Server != NULL)
	{
		hr = this->Release();
		if (hr != S_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed releasing DirectPlay8Server object!  0x%08x", hr);
		} // end if (failed releasing object)
	} // end if (we have an object pointer)
} // CWrapDP8Server::~CWrapDP8Server
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::CoCreate()"
//==================================================================================
// CWrapDP8Server::CoCreate
//----------------------------------------------------------------------------------
//
// Description: Calls CoCreateInstance for a new DirectPlay8Server object.
//
// Arguments: None.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Server::CoCreate(void)
{
	HRESULT		hr;

	if (this->m_pDP8Server != NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't create a DirectPlay8Server object because one already exists (%x)!",
			this->m_pDP8Server);
		hr = ERROR_ALREADY_EXISTS;
	} // end if (already have an object)
	else
	{
		hr = DirectPlay8Create(IID_IDirectPlay8Server, (LPVOID *) &this->m_pDP8Server, NULL);
	} // end else (don't have an object)

	return (hr);
} // CWrapDP8Server::CoCreate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::Release()"
//==================================================================================
// CWrapDP8Server::Release
//----------------------------------------------------------------------------------
//
// Description: Releases the DirectPlay8Server object.
//
// Arguments: None.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Server::Release(void)
{
	HRESULT		hr = DPN_OK;

	if (this->m_pDP8Server == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't release DirectPlay8Server object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no object yet)
	else
	{
		this->m_pDP8Server->Release();
		this->m_pDP8Server = NULL;
		
		this->m_fInitialized = FALSE;
	} // end else (there's an object)

	return (hr);
} // CWrapDP8Server::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_Initialize()"
//==================================================================================
// CWrapDP8Server::DP8S_Initialize
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PVOID pvUserContext			?
//	PFNDPNMESSAGEHANDLER pfn	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_Initialize(PVOID const pvUserContext,
											const PFNDPNMESSAGEHANDLER pfn,
											const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->Initialize(pvUserContext, pfn, dwFlags);

	if (hr == DPN_OK)
	{
		this->m_fInitialized = TRUE;
	} // end if (successfully initialized object)

	return (hr);
} // CWrapDP8Server::DP8S_Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DoWork()"
//==================================================================================
// CWrapDP8Server::DP8S_DoWork
//----------------------------------------------------------------------------------
//
// Description: Pump function that causes DirectPlay to do some processing
//
// Arguments:
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_DoWork(const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->DoWork(dwFlags);

	return (hr);
} // CWrapDP8Server::DP8S_DoWork
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_EnumServiceProviders()"
//==================================================================================
// CWrapDP8Server::DP8S_EnumServiceProviders
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	GUID* pguidServiceProvider					?
//	GUID* pguidApplication						?
//	DPN_SERVICE_PROVIDER_INFO* pSPInfoBuffer	?
//	DWORD* pcbEnumData							?
//	DWORD* pcReturned							?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_EnumServiceProviders(const GUID * const pguidServiceProvider,
													const GUID * const pguidApplication,
													DPN_SERVICE_PROVIDER_INFO * const pSPInfoBuffer,
													DWORD * const pcbEnumData,
													DWORD * const pcReturned,
													const DWORD dwFlags)
{
	HRESULT		hr;
	
	hr = this->m_pDP8Server->EnumServiceProviders(pguidServiceProvider,
		pguidApplication,
		pSPInfoBuffer,
		pcbEnumData,
		pcReturned,
		dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_EnumServiceProviders
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


HRESULT EnumPlayersAndGroups(
DPNID *const prgdpnid,
DWORD *const pcdpnid,
const DWORD dwFlags
);
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_EnumPlayersAndGroups()"
//==================================================================================
// CWrapDP8Server::DP8S_EnumPlayersAndGroups
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	GUID* pguidServiceProvider					?
//	GUID* pguidApplication						?
//	DPN_SERVICE_PROVIDER_INFO* pSPInfoBuffer	?
//	DWORD* pcbEnumData							?
//	DWORD* pcReturned							?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_EnumPlayersAndGroups(DPNID *const prgdpnid,
													   DWORD *const pcdpnid,
													   const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->EnumPlayersAndGroups(prgdpnid, pcdpnid, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_EnumPlayersAndGroups
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_CancelAsyncOperation()"
//==================================================================================
// CWrapDP8Server::DP8S_CancelAsyncOperation
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNHANDLE hAsyncHandle	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_CancelAsyncOperation(const DPNHANDLE hAsyncHandle,
													const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->CancelAsyncOperation(hAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_CancelAsyncOperation
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetSendQueueInfo()"
//==================================================================================
// CWrapDP8Server::DP8S_GetSendQueueInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid			?
//	DWORD* pdwNumMsgs	?
//	DWORD* pdwNumBytes	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetSendQueueInfo(const DPNID dpnid,
												DWORD * const pdwNumMsgs,
												DWORD * const pdwNumBytes,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetSendQueueInfo(dpnid, pdwNumMsgs, pdwNumBytes, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetSendQueueInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetClientAddress()"
//==================================================================================
// CWrapDP8Server::DP8S_GetClientAddress
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid							ID of player whose address should be
//										retrieved
//	IDirectPlay8Address ** pAddress		Place to store address object of player.
//	DWORD dwFlags						Unused.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetClientAddress(const DPNID dpnid,
												IDirectPlay8Address ** const pAddress,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetClientAddress(dpnid, pAddress, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetClientAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetClientInfo()"
//==================================================================================
// CWrapDP8Server::DP8S_GetClientInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetClientInfo(const DPNID dpnid,
												DPN_PLAYER_INFO *const pdpnPlayerInfo,
												DWORD *const pdwSize,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetClientInfo(dpnid, pdpnPlayerInfo, pdwSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetClientInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetLocalHostAddresses()"
//==================================================================================
// CWrapDP8Server::DP8S_GetLocalHostAddresses
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	IDirectPlay8Address** prgpAddress	?
//	DWORD* pcAddress					?
//	DWORD dwFlags						?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetLocalHostAddresses(IDirectPlay8Address ** const prgpAddress,
														DWORD * const pcAddress,
														const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetLocalHostAddresses(prgpAddress, pcAddress, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetLocalHostAddresses
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetConnectionInfo()"
//==================================================================================
// CWrapDP8Server::DP8S_GetConnectionInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetConnectionInfo(const DPNID dpnidEndPoint,
													DPN_CONNECTION_INFO *const pdnConnectInfo,
													const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetConnectionInfo(dpnidEndPoint, pdnConnectInfo, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::GetConnectionInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetApplicationDesc()"
//==================================================================================
// CWrapDP8Server::DP8S_GetApplicationDesc
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer,
													 DWORD *const pcbDataSize,
													 const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetApplicationDesc(pAppDescBuffer, pcbDataSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::GetApplicationDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_SetApplicationDesc()"
//==================================================================================
// CWrapDP8Server::DP8S_SetApplicationDesc
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_SetApplicationDesc(const DPN_APPLICATION_DESC * const pad,
													const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->SetApplicationDesc(pad, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_SetApplicationDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_SetServerInfo()"
//==================================================================================
// CWrapDP8Server::DP8S_SetServerInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_SetServerInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,
													 PVOID const pvAsyncContext,
													 DPNHANDLE *const phAsyncHandle,
													 const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->SetServerInfo(pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_SetServerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_SetSPCaps()"
//==================================================================================
// CWrapDP8Server::DP8S_SetSPCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_SetSPCaps(const GUID *const pguidSP,
											const DPN_SP_CAPS *const pdpSPCaps,
											const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->SetSPCaps(pguidSP, pdpSPCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_SetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetSPCaps()"
//==================================================================================
// CWrapDP8Server::DP8S_GetSPCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetSPCaps(const GUID *const pguidSP,
											DPN_SP_CAPS *const pdpnSPCaps,
											const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetSPCaps(pguidSP, pdpnSPCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetCaps()"
//==================================================================================
// CWrapDP8Server::DP8S_GetCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_CAPS* pdpCaps	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetCaps(DPN_CAPS * const pdpCaps, const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetCaps(pdpCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_SetCaps()"
//==================================================================================
// CWrapDP8Server::DP8S_SetCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_CAPS* pdpCaps	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_SetCaps(const DPN_CAPS * const pdpCaps,
										const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->SetCaps(pdpCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_SetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_Host()"
//==================================================================================
// CWrapDP8Server::DP8S_Host
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pdnAppDesc			?
//	IDirectPlay8Address** prgpDeviceInfo		?
//	DWORD cDeviceInfo							?
//	DPN_SECURITY_DESC* pdnSecurity				?
//	DPN_SECURITY_CREDENTIALS* pdnCredentials	?
//	void * pvPlayerContext						?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_Host(const DPN_APPLICATION_DESC * const pdnAppDesc,
									IDirectPlay8Address ** const prgpDeviceInfo,
									const DWORD cDeviceInfo,
									const DPN_SECURITY_DESC * const pdnSecurity,
									const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
									void * const pvPlayerContext,
									const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->Host(pdnAppDesc, prgpDeviceInfo, cDeviceInfo,
							pdnSecurity, pdnCredentials, pvPlayerContext,
							dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_Host
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_SendTo()"
//==================================================================================
// CWrapDP8Server::DP8S_SendTo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid						?
//	DPN_BUFFER_DESC* prgBufferDesc	?
//	DWORD cBufferDesc				?
//	DWORD dwTimeOut					?
//	void* pvAsyncContext			?
//	DPNHANDLE* phAsyncHandle		?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_SendTo(const DPNID dpnid,
										const DPN_BUFFER_DESC * const prgBufferDesc,
										const DWORD cBufferDesc,
										const DWORD dwTimeOut,
										void * const pvAsyncContext,
										DPNHANDLE * const phAsyncHandle,
										const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->SendTo(dpnid, prgBufferDesc, cBufferDesc, dwTimeOut,
								pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_SendTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_DestroyClient()"
//==================================================================================
// CWrapDP8Server::DP8S_DestroyClient
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid						?
//	DPN_BUFFER_DESC* prgBufferDesc	?
//	DWORD cBufferDesc				?
//	DWORD dwTimeOut					?
//	void* pvAsyncContext			?
//	DPNHANDLE* phAsyncHandle		?
//	DWORD dwFlags					?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_DestroyClient(const DPNID dpnidClient,
												const VOID *const pDestroyInfo,
												const DWORD dwDestroyInfoSize,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->DestroyClient(dpnidClient, pDestroyInfo, dwDestroyInfoSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_DestroyClient
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_CreateGroup()"
//==================================================================================
// CWrapDP8Server::DP8S_CreateGroup
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_GROUP_INFO	*pdpnGroupInfo,
//	VOID			*pvGroupContext,
//	VOID			*pvAsyncContext,
//	DPNHANDLE		*phAsyncHandle,
//	DWORD			dwFlags
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_CreateGroup(const DPN_GROUP_INFO *const pdpnGroupInfo,
											  VOID *const pvGroupContext,VOID *const pvAsyncContext,
											  DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->CreateGroup(pdpnGroupInfo, pvGroupContext, pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_CreateGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_AddPlayerToGroup()"
//==================================================================================
// CWrapDP8Server::DP8S_AddPlayerToGroup
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID idGroup,
//	DPNID idClient,
//	PVOID pvAsyncContext,
//	DPNHANDLE *phAsyncHandle,
//	DWORD dwFlags
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_AddPlayerToGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext,
												   DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->AddPlayerToGroup(idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_AddPlayerToGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_GetPlayerContext()"
//==================================================================================
// CWrapDP8Server::DP8S_GetPlayerContext
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNID dpnid					?
//	PVOID* ppvPlayerContext		?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_GetPlayerContext(const DPNID dpnid,
												PVOID * const ppvPlayerContext,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Server->GetPlayerContext(dpnid, ppvPlayerContext, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Server->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Server::DP8S_GetPlayerContext
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Server::DP8S_Close()"
//==================================================================================
// CWrapDP8Server::DP8S_Close
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DWORD dwFlags	?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Server::DP8S_Close(const DWORD dwFlags)
{
	HRESULT		hr;
	
	if (this->m_pDP8Server == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't close DirectPlay8Server object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no real object)
	else
	{
		hr = this->m_pDP8Server->Close(dwFlags);
		
		if (hr == DPN_OK)
		{
			this->m_fInitialized = FALSE;
		} // end if (successfully closed)
	} // end else (real object)

	return (hr);
} // CWrapDP8Server::DP8S_Close
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\dpwrap\wraputil.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>

#undef DEBUG_SECTION
#define DEBUG_SECTION	"DpWrapDisplayException()"
//==================================================================================
// DpWrapDisplayException
//----------------------------------------------------------------------------------
//
// DpWrapDisplayException: Displays a message indicating type of exception that occurred
//
// Arguments:
//	DWORD	dwExceptionType		Type of exception that occurred
//
// Returns: Value indicating whether to handle the exception or not
//==================================================================================
DWORD DpWrapDisplayException(DWORD dwExceptionType)
{
	DWORD dwExceptAction = EXCEPTION_EXECUTE_HANDLER;
	LPSTR szExceptName = NULL;

	switch(dwExceptionType)
	{
	case EXCEPTION_ACCESS_VIOLATION:
		szExceptName = "EXCEPTION_ACCESS_VIOLATION";
		break;
	case EXCEPTION_BREAKPOINT:
		szExceptName = "EXCEPTION_BREAKPOINT";
		break;
	case EXCEPTION_SINGLE_STEP:
		szExceptName = "EXCEPTION_SINGLE_STEP";
		break;
	case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
		szExceptName = "EXCEPTION_ARRAY_BOUNDS_EXCEEDED";
		break;
	case EXCEPTION_FLT_DENORMAL_OPERAND:
		szExceptName = "EXCEPTION_FLT_DENORMAL_OPERAND";
		break;
	case EXCEPTION_FLT_DIVIDE_BY_ZERO:
		szExceptName = "EXCEPTION_FLT_DIVIDE_BY_ZERO";
		break;
	case EXCEPTION_FLT_INEXACT_RESULT:
		szExceptName = "EXCEPTION_FLT_INEXACT_RESULT";
		break;
	case EXCEPTION_FLT_INVALID_OPERATION:
		szExceptName = "EXCEPTION_FLT_INVALID_OPERATION";
		break;
	case EXCEPTION_FLT_OVERFLOW:
		szExceptName = "EXCEPTION_FLT_OVERFLOW";
		break;
	case EXCEPTION_FLT_STACK_CHECK:
		szExceptName = "EXCEPTION_FLT_STACK_CHECK";
		break;
	case EXCEPTION_FLT_UNDERFLOW:
		szExceptName = "EXCEPTION_FLT_UNDERFLOW";
		break;
	case EXCEPTION_INT_DIVIDE_BY_ZERO:
		szExceptName = "EXCEPTION_INT_DIVIDE_BY_ZERO";
		break;
	case EXCEPTION_INT_OVERFLOW:
		szExceptName = "EXCEPTION_INT_OVERFLOW";
		break;
	case EXCEPTION_NONCONTINUABLE_EXCEPTION:
		szExceptName = "EXCEPTION_NONCONTINUABLE_EXCEPTION";
		break;
	default:
		szExceptName = "UNKNOWN";
		break;
	}

//	DbgPrint("Exception occured in DirectPlay: %s\n", szExceptName);

	return dwExceptAction;
}
#undef DEBUG_SECTION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\dpwrap\wrapclient.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>

#include <dplay8.h>
#include <dpaddr.h>

#include "macros.h"
#include "wraputil.h"
#include "wrapclient.h"

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::CWrapDP8Client()"
//==================================================================================
// CWrapDP8Client constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CWrapDP8Client object.
//
// Arguments: None.
//
// Returns: None (the object).
//==================================================================================
CWrapDP8Client::CWrapDP8Client(HANDLE hLog):
	m_pDP8Client(NULL),
	m_hLog(hLog),
	m_fInitialized(FALSE)
{
} // CWrapDP8Client::CWrapDP8Client
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::~CWrapDP8Client()"
//==================================================================================
// CWrapDP8Client destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CWrapDP8Client object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CWrapDP8Client::~CWrapDP8Client(void)
{
	HRESULT			hr;

//#pragma BUGBUG(vanceo, "make these an option (graceful or un)")

	if (this->m_fInitialized)
	{
		hr = this->DP8C_Close(0);
		if (hr != DPN_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed closing!  0x%08x", hr);
		} // end if (failed closing)
	} // end if (initialized object)

	if (this->m_pDP8Client != NULL)
	{
		hr = this->Release();
		if (hr != S_OK)
		{
			xLog(m_hLog, XLL_WARN, "Failed releasing DirectPlay8Client object!  0x%08x", hr);
		} // end if (failed releasing object)
	} // end if (we have an object pointer)
} // CWrapDP8Client::~CWrapDP8Client
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::CoCreate()"
//==================================================================================
// CWrapDP8Client::CoCreate
//----------------------------------------------------------------------------------
//
// Description: Calls CoCreateInstance for a new DirectPlay8Client object.
//
// Arguments: None.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Client::CoCreate(void)
{
	HRESULT		hr;


	if (this->m_pDP8Client != NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't create a DirectPlay8Client object because one already exists (%x)!",
			this->m_pDP8Client);
		hr = ERROR_ALREADY_EXISTS;
	} // end if (already have an object)
	else
	{
		hr = DirectPlay8Create(IID_IDirectPlay8Client, (LPVOID *) &this->m_pDP8Client, NULL);
	} // end else (don't have an object)

	return (hr);
} // CWrapDP8Client::CoCreate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::Release()"
//==================================================================================
// CWrapDP8Client::Release
//----------------------------------------------------------------------------------
//
// Description: Releases the DirectPlay8Client object.
//
// Arguments: None.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT CWrapDP8Client::Release(void)
{
	HRESULT		hr = DPN_OK;

	if (this->m_pDP8Client == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't release DirectPlay8Client object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no object yet)
	else
	{
		this->m_pDP8Client->Release();
		this->m_pDP8Client = NULL;
		
		this->m_fInitialized = FALSE;
	} // end else (there's an object)

	return (hr);
} // CWrapDP8Client::Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_Initialize()"
//==================================================================================
// CWrapDP8Client::DP8C_Initialize
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PVOID pvUserContext			?
//	PFNDPNMESSAGEHANDLER pfn	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_Initialize(PVOID const pvUserContext,
											const PFNDPNMESSAGEHANDLER pfn,
											const DWORD dwFlags)
{
	HRESULT		hr;
	
	hr = this->m_pDP8Client->Initialize(pvUserContext, pfn, dwFlags);

	if (hr == DPN_OK)
	{
		this->m_fInitialized = TRUE;
	} // end if (successfully initialized object)

	return (hr);
} // CWrapDP8Client::DP8C_Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DoWork()"
//==================================================================================
// CWrapDP8Client::DP8C_DoWork
//----------------------------------------------------------------------------------
//
// Description: Pump function that causes DirectPlay to do some processing
//
// Arguments:
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_DoWork(const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->DoWork(dwFlags);

	return (hr);
} // CWrapDP8Client::DP8C_DoWork
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_EnumServiceProviders()"
//==================================================================================
// CWrapDP8Client::DP8C_EnumServiceProviders
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	GUID* pguidServiceProvider					?
//	GUID* pguidApplication						?
//	DPN_SERVICE_PROVIDER_INFO* pSPInfoBuffer	?
//	DWORD* pcbEnumData							?
//	DWORD* pcReturned							?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_EnumServiceProviders(const GUID * const pguidServiceProvider,
														const GUID * const pguidApplication,
														DPN_SERVICE_PROVIDER_INFO * const pSPInfoBuffer,
														DWORD * const pcbEnumData,
														DWORD * const pcReturned,
														const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->EnumServiceProviders(pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData,
		pcReturned, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}
	
	return (hr);
} // CWrapDP8Client::DP8C_EnumServiceProviders
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_EnumHosts()"
//==================================================================================
// CWrapDP8Client::DP8C_EnumHosts
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PDPN_APPLICATION_DESC pApplicationDesc	?
//	IDirectPlay8Address* pAddrHost			?
//	IDirectPlay8Address* pDeviceInfo		?
//	PVOID pUserEnumData						?
//	DWORD dwUserEnumDataSize				?
//	DWORD dwEnumCount						?
//	DWORD dwRetryInterval					?
//	DWORD dwTimeOut							?
//	PVOID pvUserContext						?
//	DPNHANDLE* pAsyncHandle					?
//	DWORD dwFlags							?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,
										IDirectPlay8Address * const pAddrHost,
										IDirectPlay8Address * const pDeviceInfo,
										PVOID const pUserEnumData,
										const DWORD dwUserEnumDataSize,
										const DWORD dwEnumCount,
										const DWORD dwRetryInterval,
										const DWORD dwTimeOut,
										PVOID const pvUserContext,
										DPNHANDLE * const pAsyncHandle,
										const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->EnumHosts(pApplicationDesc, pAddrHost, pDeviceInfo, pUserEnumData, dwUserEnumDataSize,
								dwEnumCount, dwRetryInterval, dwTimeOut, pvUserContext, pAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_EnumHosts
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_CancelAsyncOperation()"
//==================================================================================
// CWrapDP8Client::DP8C_CancelAsyncOperation
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPNHANDLE hAsyncHandle	?
//	DWORD dwFlags			?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_CancelAsyncOperation(const DPNHANDLE hAsyncHandle,
														const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->CancelAsyncOperation(hAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_CancelAsyncOperation
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_Connect()"
//==================================================================================
// CWrapDP8Client::DP8C_Connect
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pdnAppDesc			?
//	IDirectPlay8Address* pHostAddr				?
//	IDirectPlay8Address* pDeviceInfo			?
//	DPN_SECURITY_DESC* pdnSecurity				?
//	DPN_SECURITY_CREDENTIALS* pdnCredentials	?
//	void* pvUserConnectData						?
//	DWORD dwUserConnectDataSize					?
//	void* pvAsyncContext						?
//	DPNHANDLE* phAsyncHandle					?
//	DWORD dwFlags								?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_Connect(const DPN_APPLICATION_DESC * const pdnAppDesc,
										IDirectPlay8Address * const pHostAddr,
										IDirectPlay8Address * const pDeviceInfo,
										const DPN_SECURITY_DESC * const pdnSecurity,
										const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
										const void * const pvUserConnectData,
										const DWORD dwUserConnectDataSize,
										void * const pvAsyncContext,
										DPNHANDLE * const phAsyncHandle,
										const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->Connect(pdnAppDesc, pHostAddr, pDeviceInfo, pdnSecurity, pdnCredentials, pvUserConnectData,
								dwUserConnectDataSize, pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_Connect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetSendQueueInfo()"
//==================================================================================
// CWrapDP8Client::DP8C_GetSendQueueInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DWORD* pdwNumMsgs	?
//	DWORD* pdwNumBytes	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetSendQueueInfo(DWORD * const pdwNumMsgs,
												DWORD * const pdwNumBytes,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetSendQueueInfo(pdwNumMsgs, pdwNumBytes, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_GetSendQueueInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_Send()"
//==================================================================================
// CWrapDP8Client::DP8C_Send
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DWORD* pdwNumMsgs	?
//	DWORD* pdwNumBytes	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_Send(const DPN_BUFFER_DESC *const pBufferDesc,
									   const DWORD cBufferDesc, const DWORD dwTimeOut,
									   void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle,
									   const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->Send(pBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext,
		phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_Send
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_SetClientInfo()"
//==================================================================================
// CWrapDP8Client::DP8C_SetClientInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_SetClientInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,
													 PVOID const pvAsyncContext,
													 DPNHANDLE *const phAsyncHandle,
													 const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->SetClientInfo(pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_SetClientInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_SetSPCaps()"
//==================================================================================
// CWrapDP8Client::DP8C_SetSPCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_SetSPCaps(const GUID *const pguidSP,
											const DPN_SP_CAPS *const pdpSPCaps,
											const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->SetSPCaps(pguidSP, pdpSPCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_SetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetCaps()"
//==================================================================================
// CWrapDP8Client::DP8C_GetCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_CAPS* pdpCaps	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetCaps(DPN_CAPS * const pdpCaps, const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetCaps(pdpCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_GetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_SetCaps()"
//==================================================================================
// CWrapDP8Client::DP8C_SetCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_CAPS* pdpCaps	?
//	DWORD dwFlags		?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_SetCaps(const DPN_CAPS * const pdpCaps,
										const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->SetCaps(pdpCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_SetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetServerInfo()"
//==================================================================================
// CWrapDP8Client::DP8C_GetServerInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetServerInfo(DPN_PLAYER_INFO *const pdpnPlayerInfo,
												DWORD *const pdwSize,
												const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetServerInfo(pdpnPlayerInfo, pdwSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_GetServerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetConnectionInfo()"
//==================================================================================
// CWrapDP8Client::DP8C_GetConnectionInfo
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetConnectionInfo(DPN_CONNECTION_INFO *const pdnConnectInfo,
													const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetConnectionInfo(pdnConnectInfo, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::GetConnectionInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetApplicationDesc()"
//==================================================================================
// CWrapDP8Client::DP8C_GetApplicationDesc
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DPN_APPLICATION_DESC* pad	?
//	DWORD dwFlags				?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer,
													 DWORD *const pcbDataSize,
													 const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetApplicationDesc(pAppDescBuffer, pcbDataSize, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::GetApplicationDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetServerAddress()"
//==================================================================================
// CWrapDP8Client::DP8C_GetServerAddress
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	IDirectPlay8Address ** pAddress		?
//	DWORD dwFlags						?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetServerAddress(IDirectPlay8Address ** const pAddress,
													const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetServerAddress(pAddress, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_GetServerAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_GetSPCaps()"
//==================================================================================
// CWrapDP8Client::DP8C_GetSPCaps
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_GetSPCaps(const GUID *const pguidSP,
											DPN_SP_CAPS *const pdpnSPCaps,
											const DWORD dwFlags)
{
	HRESULT		hr;

	hr = this->m_pDP8Client->GetSPCaps(pguidSP, pdpnSPCaps, dwFlags);

	DWORD dwTemp = 0;
	while(dwTemp < 50)
	{
		++dwTemp;
		if(this->m_pDP8Client->DoWork(0) == S_FALSE)
			break;
	}

	if(dwTemp >= 50)
	{
//		DbgPrint("DoWork didn't return S_FALSE after %u calls", dwTemp);
		hr = S_FALSE;
	}

	return (hr);
} // CWrapDP8Client::DP8C_GetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CWrapDP8Client::DP8C_Close()"
//==================================================================================
// CWrapDP8Client::DP8C_Close
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	DWORD dwFlags	?
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
STDMETHODIMP CWrapDP8Client::DP8C_Close(const DWORD dwFlags)
{
	HRESULT		hr;

	if (this->m_pDP8Client == NULL)
	{
		xLog(m_hLog, XLL_WARN, "Can't close DirectPlay8Client object because one doesn't exist!");
		hr = ERROR_BAD_ENVIRONMENT;
	} // end if (no real object)
	else
	{
		hr = this->m_pDP8Client->Close(dwFlags);

		if (hr == DPN_OK)
		{
			this->m_fInitialized = FALSE;
		} // end if (successfully closed)
	} // end else (real object)

	return (hr);
} // CWrapDP8Client::DP8C_Close
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\dpmsg.h ===
#ifndef __DPMSG_H__
#define __DPMSG_H__

//***************
//*** Defines ***
//***************

#define DPMSG_SYNCWAIT		NETSYNC_MSG_USER + 1
#define DPMSG_SYNCSIGNAL	NETSYNC_MSG_USER + 2
#define DPMSG_HOSTINFO		NETSYNC_MSG_USER + 3
#define DPMSG_DONE			NETSYNC_MSG_USER + 4
#define DPMSG_NEWHOST		NETSYNC_MSG_USER + 5
#define DPMSG_HOSTKEEPALIVE	NETSYNC_MSG_USER + 6

#define MAX_DPTEST_CLIENTS	10

//****************
//*** Typedefs ***
//****************

// DP test case IDs
typedef enum _DPMSG_NET_TESTTYPES
{

	DPMSG_NET_MAXTEST
} DPMSG_NET_TESTTYPES, *PDPMSG_NET_TESTTYPES;


// Generic message header
typedef struct _DP_GENERIC {
    DWORD				dwMessageId;	// Specifies the message id
} DP_GENERIC, *PDP_GENERIC;

// Message from a machine connected to this session that indicates it is waiting for the named "event"
// If data needs to be exchanged along with this synchronization event, it is provided.  Only one connected
// (presumably the host or server) machine is allowed to send data with its wait message
typedef struct _DP_SYNCWAIT {
	DWORD				dwMessageId;
	DWORD				dwSyncDataSize;				// Size of the variable data provided at the end of the message
	DWORD				dwMinMachinesRequired;		// Number of machines that must be waiting before the server sends
													// a "signal" message.  If this is 0, then all machines must "wait"
	CHAR				szSyncDataName[16];			// Unique name of event that is
} DP_SYNCWAIT, *PDP_SYNCWAIT;

// Message from the netsync server indicating that all connected machines have signalled that are waiting
// for the specified message
typedef struct _DP_SYNCSIGNAL {
	DWORD				dwMessageId;
	DWORD				dwSyncDataSize;
	CHAR				szSyncDataName[16];
} DP_SYNCSIGNAL, *PDP_SYNCSIGNAL;

// Message from the netsync server with information on which machine has been selected to be the
// host-peer or server and which has been seletect to be the non-host-peer or client
typedef struct _DP_HOSTINFO {
    DWORD				dwMessageId;		// Specifies the message id
	DWORD				dwTotalMachines;	// Number of machines in the test
	DWORD				dwHostAddr;			// Address of the machine chosen as host
	DWORD				dwNonHostAddrs[1];	// Addresses of the machines chosen as non-hosts
} DP_HOSTINFO, *PDP_HOSTINFO;

// Message from the netsync client indicating that the host migrated in a peer-to-peer session
// Sent from the new host so that the Netsync server will send the correct information to new
// peers as the try to connect
typedef struct _DP_NEWHOST {
    DWORD				dwMessageId;		// Specifies the message id
	DWORD				dwHostAddr;			// Address of the new machine chosen as host
} DP_NEWHOST, *PDP_NEWHOST;

// Message from the netsync client that is acting as DirectPlay host.  This is necessary so that the
// Netsync server can be sure that the current host is still alive.
typedef struct _DP_HOSTKEEPALIVE {
    DWORD				dwMessageId;		// Specifies the message id
} DP_HOSTKEEPALIVE, *PDP_HOSTKEEPALIVE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\guids.h ===
#ifndef __DNETRSLT_GUIDS__
#define __DNETRSLT_GUIDS__

namespace DPlayCoreNamespace {




//==================================================================================
// GUIDS
//==================================================================================
// {FDFEFF00-FBFC-F9fA-F8F7-F6F5F4F3F2F1}
DEFINE_GUID(GUID_UNKNOWN, 
0xFDFEFF00, 0xFBFC, 0xF9FA, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1);


// {415D4636-C9E9-4c25-88A5-9E36B7865514}
DEFINE_GUID(GUID_PARMV_PEER_CANCEL, 
0x415d4636, 0xc9e9, 0x4c25, 0x88, 0xa5, 0x9e, 0x36, 0xb7, 0x86, 0x55, 0x14);

// {04D33BBA-9613-4487-B45A-282B1390CDC2}
DEFINE_GUID(GUID_PARMV_PEER_CONNECT, 
0x4d33bba, 0x9613, 0x4487, 0xb4, 0x5a, 0x28, 0x2b, 0x13, 0x90, 0xcd, 0xc2);

// {D084167E-9814-4a86-85E6-8BF83C6142C8}
DEFINE_GUID(GUID_PARMV_PEER_SENDTO, 
0xd084167e, 0x9814, 0x4a86, 0x85, 0xe6, 0x8b, 0xf8, 0x3c, 0x61, 0x42, 0xc8);

// {E184D56B-6DCA-41c2-AC82-33FB95ECBA9B}
DEFINE_GUID(GUID_PARMV_PEER_HOST, 
0xe184d56b, 0x6dca, 0x41c2, 0xac, 0x82, 0x33, 0xfb, 0x95, 0xec, 0xba, 0x9b);

// {0306B3DD-3BA2-4e0b-A977-F74104093A70}
DEFINE_GUID(GUID_PARMV_PEER_GETAPPDESC, 
0x306b3dd, 0x3ba2, 0x4e0b, 0xa9, 0x77, 0xf7, 0x41, 0x4, 0x9, 0x3a, 0x70);

// {B9D88616-2537-4df5-AFF3-23E1E2132335}
DEFINE_GUID(GUID_PARMV_PEER_SETAPPDESC, 
0xb9d88616, 0x2537, 0x4df5, 0xaf, 0xf3, 0x23, 0xe1, 0xe2, 0x13, 0x23, 0x35);

// {35627567-CA19-4c87-9607-D1C155C70178}
DEFINE_GUID(GUID_PARMV_PEER_ENUMHOSTSBASE1, 
0x35627567, 0xca19, 0x4c87, 0x96, 0x7, 0xd1, 0xc1, 0x55, 0xc7, 0x1, 0x78);

// {52E7B2D5-1986-400b-802A-E1E0EB42A301}
DEFINE_GUID(GUID_PARMV_PEER_ENUMHOSTSBASE2, 
0x52e7b2d5, 0x1986, 0x400b, 0x80, 0x2a, 0xe1, 0xe0, 0xeb, 0x42, 0xa3, 0x1);



// {37ADC7E3-2C9D-44e6-82B2-9535188D05FC}
DEFINE_GUID(GUID_PARMV_SERVER_GETSENDQINFO, 
0x37adc7e3, 0x2c9d, 0x44e6, 0x82, 0xb2, 0x95, 0x35, 0x18, 0x8d, 0x5, 0xfc);

// {27DE9C59-6B9C-4ed2-B014-DA48706DFD89}
DEFINE_GUID(GUID_PARMV_SERVER_GETAPPDESC, 
0x27de9c59, 0x6b9c, 0x4ed2, 0xb0, 0x14, 0xda, 0x48, 0x70, 0x6d, 0xfd, 0x89);

// {5DB2EC59-D587-424a-BFDA-BDFF6E43CE66}
DEFINE_GUID(GUID_PARMV_SERVER_SETSERVERINFO, 
0x5db2ec59, 0xd587, 0x424a, 0xbf, 0xda, 0xbd, 0xff, 0x6e, 0x43, 0xce, 0x66);

// {C6418011-38DE-4594-BB55-F2F53F818BB6}
DEFINE_GUID(GUID_PARMV_SERVER_GETCLIENTINFO, 
0xc6418011, 0x38de, 0x4594, 0xbb, 0x55, 0xf2, 0xf5, 0x3f, 0x81, 0x8b, 0xb6);

// {1162543B-267C-4b80-AC4C-C979E0137A15}
DEFINE_GUID(GUID_PARMV_SERVER_GETCLIENTADDRESS, 
0x1162543b, 0x267c, 0x4b80, 0xac, 0x4c, 0xc9, 0x79, 0xe0, 0x13, 0x7a, 0x15);



// {56EFDE85-16A2-4c86-83DD-406FF410C2B2}
DEFINE_GUID(GUID_PARMV_CLIENT_GETSENDQINFO, 
0x56efde85, 0x16a2, 0x4c86, 0x83, 0xdd, 0x40, 0x6f, 0xf4, 0x10, 0xc2, 0xb2);

// {F283B5CA-4C5A-4302-97B0-B516FAE178DB}
DEFINE_GUID(GUID_PARMV_CLIENT_SETCLIENTINFO, 
0xf283b5ca, 0x4c5a, 0x4302, 0x97, 0xb0, 0xb5, 0x16, 0xfa, 0xe1, 0x78, 0xdb);

// {02CCF0F0-9FB8-4d89-B4BD-826D4AD04E09}
DEFINE_GUID(GUID_PARMV_CLIENT_GETSERVERINFO, 
0x2ccf0f0, 0x9fb8, 0x4d89, 0xb4, 0xbd, 0x82, 0x6d, 0x4a, 0xd0, 0x4e, 0x9);

// {A1728639-0B7A-4862-8B27-EDEC77EE441E}
DEFINE_GUID(GUID_PARMV_CLIENT_GETSERVERADDRESS, 
0xa1728639, 0xb7a, 0x4862, 0x8b, 0x27, 0xed, 0xec, 0x77, 0xee, 0x44, 0x1e);

// {B73CC2CF-B48C-42d9-BB71-39DA78456A33}
DEFINE_GUID(GUID_PARMV_CLIENT_GETCONNINFO, 
0xb73cc2cf, 0xb48c, 0x42d9, 0xbb, 0x71, 0x39, 0xda, 0x78, 0x45, 0x6a, 0x33);



// {D41399BD-A772-4ca3-B2E0-94B0EE2F1155}
DEFINE_GUID(GUID_HOSTMIGRATE_SIMPLE3PNORMAL, 
0xd41399bd, 0xa772, 0x4ca3, 0xb2, 0xe0, 0x94, 0xb0, 0xee, 0x2f, 0x11, 0x55);

// {FF5B7A79-40B0-421a-B65C-272A02DEDA1C}
DEFINE_GUID(GUID_HOSTMIGRATE_ROUNDROBINNORMAL, 
0xff5b7a79, 0x40b0, 0x421a, 0xb6, 0x5c, 0x27, 0x2a, 0x2, 0xde, 0xda, 0x1c);

// {115ADF23-A791-483a-A52D-16568C5A50A8}
DEFINE_GUID(GUID_HOSTMIGRATE_SIMPLE3PDROP, 
0x115adf23, 0xa791, 0x483a, 0xa5, 0x2d, 0x16, 0x56, 0x8c, 0x5a, 0x50, 0xa8);

// {716AD4AB-E195-4506-B130-EB9704B664AC}
DEFINE_GUID(GUID_HOSTMIGRATE_ROUNDROBINDROP, 
0x716ad4ab, 0xe195, 0x4506, 0xb1, 0x30, 0xeb, 0x97, 0x4, 0xb6, 0x64, 0xac);


// {0CA4DD9B-A268-4d06-8A41-2ADD8FE03AAC}
DEFINE_GUID(GUID_ENUMS_SIMPLE, 
0xca4dd9b, 0xa268, 0x4d06, 0x8a, 0x41, 0x2a, 0xdd, 0x8f, 0xe0, 0x3a, 0xac);

// {1B2D2897-D312-4664-A9FE-2F2130CCA1E0}
DEFINE_GUID(GUID_ENUMS_VALIDATE, 
0x1b2d2897, 0xd312, 0x4664, 0xa9, 0xfe, 0x2f, 0x21, 0x30, 0xcc, 0xa1, 0xe0);

// {F8AA37AF-E86E-4e50-8D3F-FB2E2A1A19CF}
DEFINE_GUID(GUID_ENUMS_STARTUPDOWN, 
0xf8aa37af, 0xe86e, 0x4e50, 0x8d, 0x3f, 0xfb, 0x2e, 0x2a, 0x1a, 0x19, 0xcf);



// {4F82F94B-A8DF-4ef9-B00E-785CA58F8698}
DEFINE_GUID(GUID_MULTISSN_SIMPLE_PEER, 
0x4f82f94b, 0xa8df, 0x4ef9, 0xb0, 0xe, 0x78, 0x5c, 0xa5, 0x8f, 0x86, 0x98);

// {9464843C-90B6-47e7-B944-541048C80377}
DEFINE_GUID(GUID_MULTISSN_SIMPLE_CS, 
0x9464843c, 0x90b6, 0x47e7, 0xb9, 0x44, 0x54, 0x10, 0x48, 0xc8, 0x3, 0x77);



// {BAFE034F-1611-470e-B925-463948E76F71}
DEFINE_GUID(GUID_CONNEX_LEAVEWHILEJOIN_PEER, 
0xbafe034f, 0x1611, 0x470e, 0xb9, 0x25, 0x46, 0x39, 0x48, 0xe7, 0x6f, 0x71);

// {857A49F9-C960-45fe-A122-257847C0C475}
DEFINE_GUID(GUID_CONNEX_LEAVEWHILEJOIN_CS, 
0x857a49f9, 0xc960, 0x45fe, 0xa1, 0x22, 0x25, 0x78, 0x47, 0xc0, 0xc4, 0x75);


// {33947342-4E7C-4ee6-A012-DBFD00679938}
DEFINE_GUID(GUID_CONNEX_MANY_PEER, 
0x33947342, 0x4e7c, 0x4ee6, 0xa0, 0x12, 0xdb, 0xfd, 0x0, 0x67, 0x99, 0x38);

// {711E8F5A-17DD-4276-913F-F6083EA01230}
DEFINE_GUID(GUID_CONNEX_MANY_CS, 
0x711e8f5a, 0x17dd, 0x4276, 0x91, 0x3f, 0xf6, 0x8, 0x3e, 0xa0, 0x12, 0x30);

} // namespace DPlayCoreNamespace

#endif // __DNETRSLT_GUIDS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\macros.h ===
#ifndef __TESTNET_MACROS__
#define __TESTNET_MACROS__

namespace DPlayCoreNamespace {

//==================================================================================
// Pragma messages
//==================================================================================

#define __TODO(user, msgstr, n)								message("TODO: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __BUGBUG(user, msgstr, n)							message("BUGBUG: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)	message("WAITFORDEVFIX: " #user ": " __FILE__ "(" #n ") : " #bugdb " bug #" #bugnum" : " titlestr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message("PRINTVALUE: " __FILE__ "(" #n ") : " itemnamestr " = " itemvaluestr)


#define _TODO(user, msgstr, n)								__TODO(user, msgstr, n)
#define _BUGBUG(user, msgstr, n)							__BUGBUG(user, msgstr, n)
#define _WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)	__WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)
#define _PRINTVALUE(itemstr, item, n)						__PRINTVALUE(itemstr, #item, n)


#ifdef TODO_OFF
#define TODO(user, msgstr)
#else
#define TODO(user, msgstr)									_TODO(user, msgstr, __LINE__)
#endif

#ifdef BUGBUG_OFF
#define BUGBUG(user, msgstr)
#else
#define BUGBUG(user, msgstr)								_BUGBUG(user, msgstr, __LINE__)
#endif

#ifdef WAITFORDEVFIX_OFF
#define WAITFORDEVFIX(user, bugdb, bugnum, titlestr)
#else
#define WAITFORDEVFIX(user, bugdb, bugnum, titlestr)		_WAITFORDEVFIX(user, bugdb, bugnum, titlestr, __LINE__)
#endif

#ifdef PRINTVALUE_OFF
#define PRINTVALUE(item)
#else
#define PRINTVALUE(item)					_PRINTVALUE(#item, item, __LINE__)
#endif

//==================================================================================
// Macros
//==================================================================================
#define CopyAndMoveDestPointer(pPointer, pSource, dwSize)\
												{ memcpy(pPointer, pSource, dwSize);\
												  pPointer += dwSize; }

#define CopyAndMoveSrcPointer(pDest, pPointer, dwSize)\
												{ memcpy(pDest, pPointer, dwSize);\
												  pPointer += dwSize; }

#define DEBUGBREAK() { _asm int 3 }

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define OVERWRITE_SR_IF_OK(hresult)		{\
											if (sr == S_OK)\
												sr = hresult;\
										}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define DO_FINAL_REPORT(log, success)	//xLog(log, XLL_INFO, "%s test reported %s", DEBUG_SECTION, success ? "SUCCESS" : "FAILURE");

#define FINAL_SUCCESS					DO_FINAL_REPORT(hLog, TRUE)

#define FINAL_FAILURE					DO_FINAL_REPORT(hLog, FALSE)

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#define THROW_ANY_SYSTEMRESULT(hr)	srThrown = hr;\
									goto SYSTEMFAILURE
#define THROW_ANY_TESTRESULT(hr)	trThrown = hr;\
									goto TESTFAILURE

#define BEGIN_TESTCASE				{\
										HRESULT		srThrown = S_OK;\
										HRESULT		trThrown = S_OK;\
										BOOL		fInVariation = FALSE;\
										BOOL		fPassed = TRUE;


#define HANDLE_TESTFAILURE(log)		{\
										TESTFAILURE:\
										\
										tr = trThrown;\
										xLog(log, XLL_INFO, "Test result failure!  0x%08x.", ((HRESULT) tr));\
										fPassed = FALSE;\
										FINAL_FAILURE;\
										\
										goto ENDTESTCASE;\
									}

#define HANDLE_SYSTEMFAILURE(log)	{\
										SYSTEMFAILURE:\
										\
										sr = srThrown;\
										xLog(log, XLL_INFO, "System result failure!  0x%08x.", ((HRESULT) sr));\
										fPassed = FALSE;\
										\
										if (sr == S_OK)\
										{\
											xLog(log, XLL_WARN, "Got a system result failure of S_OK, converting to E_FAIL!");\
											sr = E_FAIL;\
										}\
										\
										goto ENDTESTCASE;\
									}


#define END_TESTCASE				goto ENDTESTCASE;\
										\
										HANDLE_TESTFAILURE(hLog)\
										HANDLE_SYSTEMFAILURE(hLog)\
										\
										ENDTESTCASE:\
										\
										if(fInVariation)\
										{\
											if(fPassed)\
												xLog(hLog, XLL_PASS, "Test passed!");\
											else\
												xLog(hLog, XLL_FAIL, "Test failed!");\
											\
											fInVariation = FALSE;\
											xEndVariation(hLog);\
										}\
										\
										xLog(hLog, XLL_INFO, "Leaving testcase.");\
									}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#define TEST_SECTION(name)			if(fInVariation)\
									{\
										if(fPassed)\
											xLog(hLog, XLL_PASS, "Test passed!");\
										else\
											xLog(hLog, XLL_FAIL, "Test failed!");\
										\
										xEndVariation(hLog);\
										fInVariation = FALSE;\
									}\
									fPassed = TRUE;\
									xStartVariation(hLog, name);\
									fInVariation = TRUE

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#define SETTHROW_ANY_SYSTEMRESULT(hr, value)	{\
													hr = (HRESULT) value;\
													THROW_ANY_SYSTEMRESULT(hr);\
												}
#define SETTHROW_ANY_TESTRESULT(hr, value)		{\
													hr = (HRESULT) value;\
													THROW_ANY_TESTRESULT(hr);\
												}

#define THROW_SYSTEMRESULT						THROW_ANY_SYSTEMRESULT(sr)
#define THROW_TESTRESULT						THROW_ANY_TESTRESULT(tr)

#define SETTHROW_SYSTEMRESULT(value)			SETTHROW_ANY_SYSTEMRESULT(sr, value)
#define SETTHROW_TESTRESULT(value)				SETTHROW_ANY_TESTRESULT(tr, value)




// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define LOCALALLOC_OR_THROW(type, ptr, size)	{\
														if (ptr != NULL)\
														{\
															xLog(hLog, XLL_WARN, "Pointer %X is not NULL at line %i, DEBUGBREAK()-ing.", ptr, __LINE__);\
															DEBUGBREAK();\
														}\
														ptr = (type) MemAlloc(size);\
														if (ptr == NULL)\
														{\
															SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);\
														}\
													}

#define CREATEEVENT_OR_THROW(handle, lpEventAttributes, fManualReset, fInitialState, pszName)\
												{\
													if (handle != NULL)\
													{\
														xLog(hLog, XLL_WARN, "Handle %x is not NULL at line %i, DEBUGBREAK()-ing.", handle, __LINE__);\
														DEBUGBREAK();\
													}\
													handle = CreateEvent(lpEventAttributes, fManualReset, fInitialState, pszName);\
													if (handle == NULL)\
													{\
														sr = GetLastError();\
														xLog(hLog, XLL_FAIL, "Couldn't create event!");\
														THROW_SYSTEMRESULT;\
													}\
												}

#define SAFE_LOCALFREE(ptr)						{\
													if (ptr != NULL)\
													{\
														MemFree(ptr);\
														ptr = NULL;\
													}\
												}

#define IS_VALID_HANDLE(x)      				(x && (INVALID_HANDLE_VALUE != x))

#define SAFE_CLOSEHANDLE(h)						{\
													if (IS_VALID_HANDLE(h))\
													{\
														CloseHandle(h);\
														h = NULL;\
													}\
												}												

#define SAFE_RELEASE(p)						    {\
													if (p)\
													{\
														p->Release();\
														p = NULL;\
													}\
												}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

inline BOOL IsZero(PVOID pvPointer, DWORD dwSize)
{
	LPBYTE	lpCurrent = (LPBYTE) pvPointer;
	LPBYTE	lpEnd = lpCurrent + dwSize;
	

	while (lpCurrent < lpEnd)
	{
		if ((*lpCurrent) != 0)
			return (FALSE);

		lpCurrent++;
	} // end while (haven't hit end of buffer)

	return (TRUE);
};

inline void FillWithDWord(PVOID pvPointer, DWORD dwSize, DWORD dwPattern)
{
	LPBYTE	lpCurrent = (LPBYTE) pvPointer;
	DWORD	dwPatternByteIndex = 0;
	LPBYTE	lpEnd = lpCurrent + dwSize;
	

	while (lpCurrent < lpEnd)
	{
		(*lpCurrent) = ((LPBYTE) (&dwPattern))[dwPatternByteIndex];

		lpCurrent++;
		dwPatternByteIndex++;
		if (dwPatternByteIndex >= sizeof (DWORD))
			dwPatternByteIndex = 0;
	} // end while (haven't hit end of buffer)
};

inline BOOL IsFilledWithDWord(PVOID pvPointer, DWORD dwSize, DWORD dwPattern)
{
	LPBYTE	lpCurrent = (LPBYTE) pvPointer;
	DWORD	dwPatternByteIndex = 0;
	LPBYTE	lpEnd = lpCurrent + dwSize;
	

	while (lpCurrent < lpEnd)
	{
		if ((*lpCurrent) != ((LPBYTE) (&dwPattern))[dwPatternByteIndex])
			return (FALSE);

		lpCurrent++;
		dwPatternByteIndex++;
		if (dwPatternByteIndex >= sizeof (DWORD))
			dwPatternByteIndex = 0;
	} // end while (haven't hit end of buffer)

	return (TRUE);
};

} // namespace DPlayCoreNamespace

#endif //__TESTNET_MACROS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\server\dpserv.h ===
#ifndef __DPSERV_H__
#define __DPSERV_H__

//==================================================================================
// Includes
//==================================================================================

#include <netsync.h>
#include "dpmsg.h"

#define LOST_HOST_TIME  (180000)

//==================================================================================
// Typedefs
//==================================================================================
typedef struct _DPSYNC_LIST_ENTRY {
	DWORD dwMinMachinesRequired;
	DWORD dwCurrentMachines;
	CHAR szSyncDataName[16];
	DWORD dwSyncDataSize;
	PBYTE pbSyncData;
	BOOL *pWaitStatus;
	struct _DPSYNC_LIST_ENTRY		*pNext;
} DPSYNC_LIST_ENTRY, *PDPSYNC_LIST_ENTRY;

// Session info structure
typedef struct _DPCORE_SESSION_INFO
{
	PDPSYNC_LIST_ENTRY pSyncListHead;
	HANDLE hNetsyncObject;
	DP_HOSTINFO *pHostInfo;
	BYTE byClientCount;
	DWORD *ClientAddrs;
	BOOL *pTestStatus;
	CHAR szServerIPAddr[16];
	WORD LowPort;
	WORD HighPort;
} DPCORE_SESSION_INFO, *PDPCORE_SESSION_INFO;

// Session info structure
typedef struct _DPSTRESS_SESSION_INFO
{
	HANDLE hNetsyncObject;
	DP_HOSTINFO *pHostInfo;
	BYTE byClientCount;
	DWORD *ClientAddrs;
	DWORD dwLastHostPing;
	WORD LowPort;
	WORD HighPort;
} DPSTRESS_SESSION_INFO, *PDPSTRESS_SESSION_INFO;

// DP test function type
typedef BOOL (*PDP_SERV_FUNCTION) (DWORD FromAddr, PDPCORE_SESSION_INFO pSessionInfo);

//==================================================================================
// Prototypes 
//==================================================================================

// Test case functions
//BOOL DPSourceMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\server\dpserv.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <tchar.h>

#include "dpserv.h"

//PDP_SERV_FUNCTION	g_ServerFunctions[DPMSG_NET_MAXTEST] = 
//{
//	DPSourceMaxServ,			// DPMSG_SOURCEPORT_MAX
//};

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: Global entry point
//
// Arguments:
//	HINSTANCE	hInstance	Handle to calling instance
//	DWORD		dwReason	Reason for calling entry point
//	LPVOID		lpContext	
//
// Returns:
//	TRUE on successful attach or detach, FALSE otherwise
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}

//==================================================================================
// Helper functions
//==================================================================================

//==================================================================================
// FindEvent
//----------------------------------------------------------------------------------
//
// Description: Finds the event structure (if present) for the given named event
//
// Arguments:
//	PDPSYNC_LIST_ENTRY	pListHead		Points to the head of the list of outstanding events
//	LPCSTR				szSyncDataName	ANSI name of the event
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
PDPSYNC_LIST_ENTRY FindEvent(PDPSYNC_LIST_ENTRY pListHead, LPCSTR szSyncDataName)
{
	PDPSYNC_LIST_ENTRY pCurrentEvent = pListHead;

	while(pCurrentEvent)
	{
		if(strcmp(pCurrentEvent->szSyncDataName, szSyncDataName) == 0)
			break;

		pCurrentEvent = pCurrentEvent->pNext;
	}

	return pCurrentEvent;
}

//==================================================================================
// AddEvent
//----------------------------------------------------------------------------------
//
// Description: Adds the given event structure to the current session info
//
// Arguments:
//	PDPCORE_SESSION_INFO		pSessionInfo	Points to the current session info
//	PDPSYNC_LIST_ENTRY	pNewEntry		Points to the new event entry to be added to the session info
//
// Returns:
//	Returns TRUE
//==================================================================================
BOOL AddEvent(PDPCORE_SESSION_INFO pSessionInfo, PDPSYNC_LIST_ENTRY pNewEntry)
{
	if(!pSessionInfo || !pNewEntry)
		return FALSE;

	pNewEntry->pNext = pSessionInfo->pSyncListHead;
	pSessionInfo->pSyncListHead = pNewEntry;

	return TRUE;
}

//==================================================================================
// RemoveEvent
//----------------------------------------------------------------------------------
//
// Description: Removes the given event structure to the current session info
//
// Arguments:
//	PDPCORE_SESSION_INFO		pSessionInfo	Points to the current session info
//	PDPSYNC_LIST_ENTRY	pEntryToRemove	Points to the entry to be removed from the sesion info
//
// Returns:
//	Returns TRUE
//==================================================================================
BOOL RemoveEvent(PDPCORE_SESSION_INFO pSessionInfo, PDPSYNC_LIST_ENTRY pEntryToRemove)
{
	PDPSYNC_LIST_ENTRY pCurrentEvent = pSessionInfo->pSyncListHead;

	if(!pSessionInfo || !pEntryToRemove)
		return FALSE;

	if(pSessionInfo->pSyncListHead == pEntryToRemove)
	{
		pSessionInfo->pSyncListHead = pEntryToRemove->pNext;
		goto RemoveItem;
	}

	while(pCurrentEvent)
	{
		if(pCurrentEvent->pNext == pEntryToRemove)
		{
			pCurrentEvent->pNext = pEntryToRemove->pNext;
			goto RemoveItem;
		}

		pCurrentEvent = pCurrentEvent->pNext;
	}

	return FALSE;

RemoveItem:
	
	pEntryToRemove->pbSyncData ? LocalFree(pEntryToRemove->pbSyncData) : 0;
	LocalFree(pEntryToRemove);
	return TRUE;
}


//==================================================================================
// DpProcessServerMessage
//----------------------------------------------------------------------------------
//
// Description: Function that handles server callbacks
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL DpProcessServerMessage(HANDLE hNetsyncObject, DWORD FromAddr, CHAR *ReceiveMessage, LPVOID lpContext)
{
	PDPCORE_SESSION_INFO pSessionInfo = (PDPCORE_SESSION_INFO) lpContext;
	BYTE nClient;

	DbgPrint("Processing server message\n");

	switch(((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId)
	{
	case NETSYNC_MSG_STOPSESSION:
		DbgPrint("Stopping session due to message received from 0x%08x!\n", FromAddr);
		return FALSE;
	case NETSYNC_MSG_ADDCLIENT:
		DbgPrint("Ignoring added client: 0x%08x\n", FromAddr);
		return TRUE;
	case NETSYNC_MSG_DELETECLIENT:
		// Client is signalling that this test is done
		DbgPrint("Machine at address 0x%08x is signalling that it is done.\n", FromAddr);
		
		// Find which client sent this message
		for(nClient = 0; nClient < pSessionInfo->byClientCount; ++nClient)
		{
			if(pSessionInfo->ClientAddrs[nClient] == FromAddr)
				break;
		}

		// If we don't recogize the sender as one of our connected machines, then ignore the message and
		// print a warning
		if(nClient >= pSessionInfo->byClientCount)
		{
			DbgPrint("Received DELETECLIENT message from unknown machine 0x%08x\n", FromAddr);
			return TRUE;
		}

		// Otherwise, mark this client as no longer running the test
		pSessionInfo->pTestStatus[nClient] = FALSE;

		for(nClient = 0; nClient < pSessionInfo->byClientCount; ++nClient)
		{
			if(pSessionInfo->pTestStatus[nClient])
				break;
		}

		// If all the machines are now disconnected, then signal the session to close by returning FALSE
		if(nClient >= pSessionInfo->byClientCount)
		{
			DbgPrint("All machines have left the session.\n");
			return FALSE;
		}
		break;
	default:
		DbgPrint("WARINING: Unknown server message received 0x%08x\n",
			((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId);
		break;
	}

	return TRUE;
}

//==================================================================================
// DpProcessClientMessage
//----------------------------------------------------------------------------------
//
// Description: Function that handles client callbacks
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL DpProcessClientMessage(HANDLE hNetsyncObject, DWORD FromAddr, CHAR *ReceiveMessage, LPVOID lpContext)
{
	PDPSYNC_LIST_ENTRY pCurrentEvent;
	PDPCORE_SESSION_INFO pSessionInfo = (PDPCORE_SESSION_INFO) lpContext;
	PDP_SYNCWAIT pSyncWaitMsg;
	BYTE nClient;

	DbgPrint("Processing client message\n");

	switch(((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId)
	{
	case DPMSG_SYNCWAIT:
		pSyncWaitMsg = (PDP_SYNCWAIT) ReceiveMessage;

		// Scan the list of client machines to see if any have already left the test
		for(nClient = 0; nClient < pSessionInfo->byClientCount; ++nClient)
		{
			if(!pSessionInfo->pTestStatus[nClient])
				break;
		}

		// If any of the machines have already left the test, then ignore the message (the client
		// will eventually timeout
		if(nClient < pSessionInfo->byClientCount)
		{
			DbgPrint("Received SYNCWAIT message but some machines have already left the session!\n");
			return TRUE;
		}

		// Quick sanity check on the sync data name
		if(strlen(pSyncWaitMsg->szSyncDataName) >= 16)
			return TRUE;

		// Find which client sent this message
		for(nClient = 0; nClient < pSessionInfo->byClientCount; ++nClient)
		{
			if(pSessionInfo->ClientAddrs[nClient] == FromAddr)
				break;
		}

		// If we don't recogize the sender as one of our connected machines, then ignore the message and
		// print a warning
		if(nClient >= pSessionInfo->byClientCount)
		{
			DbgPrint("Received SYNCWAIT message from unknown machine 0x%08x\n", FromAddr);
			return TRUE;
		}

		// Find the data on this event if it is present
		pCurrentEvent = FindEvent(pSessionInfo->pSyncListHead, pSyncWaitMsg->szSyncDataName);

		// If we've already received wait requests for this event, update the existing block
		if(pCurrentEvent)
		{
			++(pCurrentEvent->dwCurrentMachines);
			pCurrentEvent->pWaitStatus[nClient] = TRUE;
		}
		// If this is the first time we've received a wait request for this event...
		// Then create a new block to track it
		else
		{
			// Structure must be large enough for the DPSYNC_LIST_ENTRY followed by the variable length
			// list of BOOLs for tracking which machines are waiting for this event
			pCurrentEvent = (DPSYNC_LIST_ENTRY *) LocalAlloc(LPTR, sizeof(DPSYNC_LIST_ENTRY) + pSessionInfo->byClientCount * sizeof(BOOL));
			memset(pCurrentEvent, 0, sizeof(DPSYNC_LIST_ENTRY) + pSessionInfo->byClientCount * sizeof(BOOL));

			pCurrentEvent->dwCurrentMachines = 1;
			pCurrentEvent->dwMinMachinesRequired = pSyncWaitMsg->dwMinMachinesRequired;

			// Set up the wait status pointer to point to the end of the structure
			pCurrentEvent->pWaitStatus = (int *) ((BYTE *) pCurrentEvent + sizeof(DPSYNC_LIST_ENTRY));

			// Mark that the machine sending the message is waiting for the event
			pCurrentEvent->pWaitStatus[nClient] = TRUE;

			// Copy the event name
			strcpy(pCurrentEvent->szSyncDataName, pSyncWaitMsg->szSyncDataName);

			pCurrentEvent->pNext = NULL;
			
			if(!AddEvent(pSessionInfo, pCurrentEvent))
			{
				DbgPrint("Failed adding new event to event list\n");
				return TRUE;
			}
		}

		// If no previous machine has left any data with this event, then see if data was provided
		// this this message.  If so, then allocate a buffer for it and copy it.
		if(!pCurrentEvent->dwSyncDataSize)
		{
			// Set up the sync data size and pointer
			if(pCurrentEvent->dwSyncDataSize = pSyncWaitMsg->dwSyncDataSize)
			{
				pCurrentEvent->pbSyncData = (LPBYTE) LocalAlloc(LPTR, pSyncWaitMsg->dwSyncDataSize);
				memcpy(pCurrentEvent->pbSyncData, (BYTE *) pSyncWaitMsg + sizeof(DP_SYNCWAIT), pSyncWaitMsg->dwSyncDataSize);
			}
			else
				pCurrentEvent->pbSyncData = NULL;
		}		

		// If we've reached the minimum number of machines necessary to signal this event...
		// Or we're requiring all machines to wait before signalling and they have all signalled
		// Then send the signal to all machines that were waiting and release the tracking block.
		if((pCurrentEvent->dwMinMachinesRequired && (pCurrentEvent->dwCurrentMachines >= pCurrentEvent->dwMinMachinesRequired)) ||
			(pCurrentEvent->dwCurrentMachines >= pSessionInfo->byClientCount))
		{
			PDP_SYNCSIGNAL pSyncSignal;

			DbgPrint("Signalling event: %s\n", pCurrentEvent->szSyncDataName);

			// Allocate the sync signal message to send to clients to indicate that the event has been triggered
			pSyncSignal = (PDP_SYNCSIGNAL) LocalAlloc(LPTR, sizeof(DP_SYNCSIGNAL) + pCurrentEvent->dwSyncDataSize);
			pSyncSignal->dwMessageId = DPMSG_SYNCSIGNAL;
			strcpy(pSyncSignal->szSyncDataName, pCurrentEvent->szSyncDataName);
			if(pSyncSignal->dwSyncDataSize = pCurrentEvent->dwSyncDataSize)
				memcpy((BYTE *) pSyncSignal + sizeof(DP_SYNCSIGNAL), pCurrentEvent->pbSyncData, pCurrentEvent->dwSyncDataSize);

			// Cycle through the clients and determine which were waiting
			for(nClient = 0; nClient < pSessionInfo->byClientCount; ++nClient)
			{
				if(pCurrentEvent->pWaitStatus[nClient])
				{
					NetsyncSendClientMessage(hNetsyncObject,
						pSessionInfo->ClientAddrs[nClient], 
						sizeof(DP_SYNCSIGNAL) + pCurrentEvent->dwSyncDataSize,
						(char *) pSyncSignal);
				}
			}

			LocalFree(pSyncSignal);

			// The event was signalled, remove the event from our list.
			RemoveEvent(pSessionInfo, pCurrentEvent);
		}
		else
		{
			DbgPrint("Not signalling event %s: %u of %u machines waiting\n",
				pCurrentEvent->szSyncDataName,
				pCurrentEvent->dwCurrentMachines,
				pCurrentEvent->dwMinMachinesRequired ?
				pCurrentEvent->dwMinMachinesRequired : pSessionInfo->byClientCount);
		}

		break;

	default:
		// Unknown message received
		DbgPrint("WARINING: Unknown client message received 0x%08x\n",
			((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId);
		break;
	}

	return TRUE;
}

//==================================================================================
// DpServerCallbackFunction
//----------------------------------------------------------------------------------
//
// Description: Function exported for Netsync callbacks
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	DWORD		dwMessageType	Parameter indicating if this is a client or server message
//	DWORD		dwMessageSize	Parameter indicating the size of the message
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL DpServerCallbackFunction(HANDLE hNetsyncObject, DWORD FromAddr, DWORD dwMessageType, DWORD dwMessageSize, CHAR *ReceiveMessage, LPVOID lpContext)
{
	DbgPrint("Callback entered!\n");

	switch(dwMessageType)
	{
	case NETSYNC_MSGTYPE_SERVER:
		return DpProcessServerMessage(hNetsyncObject, FromAddr, ReceiveMessage, lpContext);
	case NETSYNC_MSGTYPE_CLIENT:
		return DpProcessClientMessage(hNetsyncObject, FromAddr, ReceiveMessage, lpContext);
	default:
		DbgPrint("Unknown message type received: 0x%08x\n", dwMessageType);
		break;
	}

	return TRUE;
}

//==================================================================================
// DpServerStartFunction
//----------------------------------------------------------------------------------
//
// Description: Funtion called once for each session that is created
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	BYTE		byClientCount	Number of clients this test is being started with
//	DWORD		*ClientAddrs	List of client addresses (number of addresses indicated by byClientCount)
//	WORD		LowPort			The lowest port to use for this test
//	WORD		HighPort		The higest port to use for this test
//
// Returns:
//	Returns a pointer to the session information that is being stored for this session
//==================================================================================
LPVOID DpServerStartFunction(HANDLE hNetsyncObject, BYTE byClientCount, DWORD *ClientAddrs, WORD LowPort, WORD HighPort)
{
	PDPCORE_SESSION_INFO pCurrentSession = NULL;
	IN_ADDR ServerAddr;
	DWORD dwHostInfoSize;
	CHAR szServerAddr[16];
	BYTE n;

	// Check for too few clients in session.  Doesn't make sense to use the DP test layer with
	// only 1 client connected
	if(byClientCount < 2)
	{
		DbgPrint("Can't start session with only %u client\n", byClientCount);
		return NULL;
	}

	// Check for too many clients in session.  We have to limit this because the size of the
	// HOST_INFO message has to have an upper bound for the receiver to be able to allocate
	// a receive buffer that will always be adequate.  Besides, this many should be fine
	if(byClientCount > MAX_DPTEST_CLIENTS)
	{
		DbgPrint("Can't start session with only %u client\n", byClientCount);
		return NULL;
	}

	pCurrentSession = (PDPCORE_SESSION_INFO) LocalAlloc(LPTR, sizeof(DPCORE_SESSION_INFO));
	DbgPrint("Starting session: 0x%08x\n", pCurrentSession);

	pCurrentSession->pTestStatus = (BOOL *) LocalAlloc(LPTR, byClientCount * sizeof(BOOL));
	memset(pCurrentSession->pTestStatus, TRUE, byClientCount * sizeof(BOOL));

	// Fill the session info structure
	pCurrentSession->hNetsyncObject = hNetsyncObject;
	pCurrentSession->byClientCount = byClientCount;
	pCurrentSession->ClientAddrs = ClientAddrs;
	pCurrentSession->LowPort = LowPort;
	pCurrentSession->HighPort = HighPort;
	pCurrentSession->pSyncListHead = NULL;

	// Calculate the server address string
// BUGBUG - doesn't work this way anymore.  If we need the server address, we'll have to get
//     it the old fashioned way
//	ServerAddr.S_un.S_addr = ClientAddrs[0];
//	strcpy(pCurrentSession->szServerIPAddr, inet_ntoa(ServerAddr));

	// By default the DP_HOSTINFO structure has room for 2 clients, the elected host and the
	// first of the clients in the list.  So if there are more than 2 clients, we need to
	// allocate space for the extra ones
	dwHostInfoSize = sizeof(DP_HOSTINFO) + ((byClientCount < 3) ? 0 : (byClientCount - 2 * sizeof(DWORD)));

	pCurrentSession->pHostInfo = (DP_HOSTINFO *) LocalAlloc(LPTR, dwHostInfoSize);

	// Initialize the host info message
	memset(pCurrentSession->pHostInfo, 0, dwHostInfoSize);
	pCurrentSession->pHostInfo->dwMessageId = DPMSG_HOSTINFO;
	pCurrentSession->pHostInfo->dwTotalMachines = (DWORD) byClientCount;
	pCurrentSession->pHostInfo->dwHostAddr = ClientAddrs[0];

	// Fill in the non-host addresses
	for(n = 1; n < byClientCount; ++n)
		pCurrentSession->pHostInfo->dwNonHostAddrs[n - 1] = ClientAddrs[n];

	for(n = 0; n < byClientCount; ++n)
		NetsyncSendClientMessage(hNetsyncObject, ClientAddrs[n], dwHostInfoSize, (char *) (pCurrentSession->pHostInfo));

	// If anything needs to be setup for all the tests or if the currently
	// connected clients need to be tracked, it will be done here
	return (LPVOID) pCurrentSession;
}

//==================================================================================
// DpServerStopFunction
//----------------------------------------------------------------------------------
//
// Description: Function called once when each session is closed
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
VOID DpServerStopFunction(HANDLE hNetsyncObject, LPVOID lpContext)
{
	PDPCORE_SESSION_INFO pCurrentSession = (PDPCORE_SESSION_INFO) lpContext;

	DbgPrint("Stopping session: 0x%08x\n", pCurrentSession);

	LocalFree(pCurrentSession->pTestStatus);
	LocalFree(pCurrentSession->pHostInfo);
	LocalFree(pCurrentSession);

	// If anything needs to be cleaned up, it will be done here.
	return;
}

//==================================================================================
// DpProcessServerStressMessage
//----------------------------------------------------------------------------------
//
// Description: Function that handles server stress callbacks
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL DpProcessServerStressMessage(HANDLE hNetsyncObject, DWORD FromAddr, CHAR *ReceiveMessage, LPVOID lpContext)
{
	PDPSTRESS_SESSION_INFO pSessionInfo = (PDPSTRESS_SESSION_INFO) lpContext;
	IN_ADDR ClientAddress, HostAddress;
	DWORD dwCurrentTime = 0, dwTimeElapsed = 0, dwSendStatus = 0;

	ClientAddress.S_un.S_addr = FromAddr;
	HostAddress.S_un.S_addr = pSessionInfo->pHostInfo->dwHostAddr;

	DbgPrint("Processing server stress message\n");

	switch(((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId)
	{
	case NETSYNC_MSG_STOPSESSION:
		DbgPrint("Stopping session due to message received from %s!\n", inet_ntoa(ClientAddress));
		return FALSE;
	case NETSYNC_MSG_ADDCLIENT:
		// Get the current time
		dwCurrentTime = GetTickCount();
		
		// Calculate the amount of time that has elapsed since the last keepalive
		if(dwCurrentTime < pSessionInfo->dwLastHostPing)
			dwTimeElapsed = ((DWORD) 0xffffffff) - pSessionInfo->dwLastHostPing + dwCurrentTime;
		else
			dwTimeElapsed = dwCurrentTime - pSessionInfo->dwLastHostPing;
		
		// Check to see if the last known host has responded recently
		if(dwTimeElapsed > LOST_HOST_TIME)
		{
			// If not, the we have a bad session...
			// The session probably dwindled down to just the host and then the host died.
			// So there was no one around to which to be migrated.  Need to kill the entire session.
			// Clients can then resync

			DbgPrint("Tried to add new machine %s, but host %s hasn't responded in %u ms\n",
				inet_ntoa(ClientAddress), inet_ntoa(HostAddress), dwTimeElapsed);
			return FALSE;
		}
		
		dwSendStatus = NetsyncSendClientMessage(hNetsyncObject, FromAddr, sizeof(DP_HOSTINFO), (char *) (pSessionInfo->pHostInfo));
		if(dwSendStatus != WAIT_OBJECT_0)
		{
			DbgPrint("Tried to add new machine %s, but Netsync send failed! (error 0x%08x)\n",
				inet_ntoa(ClientAddress), dwSendStatus);
			return FALSE;
		}

		DbgPrint("Added new machine %s to DirectPlay stress session 0x%08x\n", inet_ntoa(ClientAddress), pSessionInfo);

		break;
	case NETSYNC_MSG_DELETECLIENT:
		// If the host is exiting, set the host info message's host address to 0...
		// New clients that connect will recognize that a host address of 0 means that there is
		// no know host at this time.  These clients will then leave the session and try again later.
		// We'll also update the ping time to indicate when the host left.  If clients get added later
		// and we haven't gotten a new host within a resonable amount of time (LOST_HOST_TIME), then
		// the session will kill itself
		if(FromAddr == pSessionInfo->pHostInfo->dwHostAddr)
		{
			DbgPrint("Removed host %s from DirectPlay stress session 0x%08x\n", inet_ntoa(ClientAddress), pSessionInfo);
			pSessionInfo->pHostInfo->dwHostAddr = 0;
			pSessionInfo->dwLastHostPing = GetTickCount();
		}
		// Not that complicated when a non-host leaves.  The netsync server only needs to know who the host is.
		else
		{
			DbgPrint("Removed machine %s from DirectPlay stress session 0x%08x\n", inet_ntoa(ClientAddress), pSessionInfo);
		}

		break;
	default:
		DbgPrint("WARINING: Unknown server message received 0x%08x\n",
			((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId);
		break;
	}

	return TRUE;
}

//==================================================================================
// DpProcessClientStressMessage
//----------------------------------------------------------------------------------
//
// Description: Function that handles client stress callbacks
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL DpProcessClientStressMessage(HANDLE hNetsyncObject, DWORD FromAddr, CHAR *ReceiveMessage, LPVOID lpContext)
{
	NETSYNC_GENERIC_MESSAGE StopSessionMsg;
	PDPSTRESS_SESSION_INFO pSessionInfo = (PDPSTRESS_SESSION_INFO) lpContext;
	IN_ADDR ClientAddress, HostAddress, NewHostAddress;
	PDP_NEWHOST pNewHost = NULL;
	CHAR szTemp[20] = "";

	ClientAddress.S_un.S_addr = FromAddr;
	HostAddress.S_un.S_addr = pSessionInfo->pHostInfo->dwHostAddr;

	switch(((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId)
	{
	case DPMSG_HOSTKEEPALIVE:
		// If the sender of the keepalive has a different address than our recorded address for the host
		// there are two possiblities...
		if(FromAddr != pSessionInfo->pHostInfo->dwHostAddr)
		{

			// The first possiblity is that the host left earlier and we haven't received a NEWHOST
			// message... it's minimally possible that this message was lost.  But since we got our
			// currently listed host address is 0, we know that the original host must have told us
			// they were leaving.  So we at least know that we don't have two machines that both think
			// they are the host.  Mark the machine that sent this keepalive as the new host.
			if(!pSessionInfo->pHostInfo->dwHostAddr)
			{
				pSessionInfo->pHostInfo->dwHostAddr = FromAddr;
			}
			// The remaining possibilities are that either...
			// 1) The original host left the session in a non-graceful way so we never got a
			// notification that they were gone, and then we never received the NEWHOST message from
			// the machine that the host migrated to.  While it's possible that the NEWHOST message
			// was lost on the network, it is pretty unlikely.  So just kill the whole session.
			// 2) There is another machine on the network that thinks its the host and is sending us
			// keepalives.  This could have happened if we had to kill the server app.  It's possible
			// that this rogue host is not a part of this Netsync session anymore so we'll have to manually
			// send a STOPSESSION message to this machine and then return FALSE from this function to
			// tell Netsync to kill everyone else.
			else
			{
				strcpy(szTemp, inet_ntoa(ClientAddress));
				DbgPrint("Received a keepalive from %s but current host is listed as %s\n",
					szTemp, inet_ntoa(HostAddress));
				DbgPrint("Sending STOPSESSION to rogue server and ending this session\n");

				StopSessionMsg.dwMessageId = NETSYNC_MSG_STOPSESSION;
				NetsyncSendClientMessage(hNetsyncObject, FromAddr, sizeof(NETSYNC_GENERIC_MESSAGE), (char *) &StopSessionMsg);

				return FALSE;
			}
		}

		pSessionInfo->dwLastHostPing = GetTickCount();
		break;

	case DPMSG_NEWHOST:
		pNewHost = (PDP_NEWHOST) ReceiveMessage;

		NewHostAddress.S_un.S_addr = pNewHost->dwHostAddr;

		// This should never happen... a machine is sending a new host message
		// with another machine's IP address... Fail and check this out...
		if(pNewHost->dwHostAddr != FromAddr)
		{
			DbgPrint("Received new host message for %s from %s\n",
				inet_ntoa(NewHostAddress), inet_ntoa(ClientAddress));
			return FALSE;
		}

		// This shouldn't happen either... a machine is sending a new host message
		// when its already known to be the host...  Go ahead and let this slide,
		// but log it...
		if(pNewHost->dwHostAddr == pSessionInfo->pHostInfo->dwHostAddr)
		{
			DbgPrint("Received new host message for %s from %s\n",
				inet_ntoa(NewHostAddress), inet_ntoa(ClientAddress));;
		}

		DbgPrint("Host has migrated to %s\n", inet_ntoa(NewHostAddress));;

		// Update the new server and reset its ping time
		pSessionInfo->pHostInfo->dwHostAddr = pNewHost->dwHostAddr;
		pSessionInfo->dwLastHostPing = GetTickCount();
		break;

	default:
		// Unknown message received
		DbgPrint("WARINING: Unknown client message received 0x%08x\n",
			((PNETSYNC_GENERIC_MESSAGE) ReceiveMessage)->dwMessageId);
		break;
	}

	return TRUE;
}

//==================================================================================
// DpStressCallbackFunction
//----------------------------------------------------------------------------------
//
// Description: Function exported for Netsync callbacks
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	DWORD		dwMessageType	Parameter indicating if this is a client or server message
//	DWORD		dwMessageSize	Parameter indicating the size of the message
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL DpStressCallbackFunction(HANDLE hNetsyncObject, DWORD FromAddr, DWORD dwMessageType, DWORD dwMessageSize, CHAR *ReceiveMessage, LPVOID lpContext)
{
	switch(dwMessageType)
	{
	case NETSYNC_MSGTYPE_SERVER:
		return DpProcessServerStressMessage(hNetsyncObject, FromAddr, ReceiveMessage, lpContext);
	case NETSYNC_MSGTYPE_CLIENT:
		return DpProcessClientStressMessage(hNetsyncObject, FromAddr, ReceiveMessage, lpContext);
	default:
		DbgPrint("Unknown message type received: 0x%08x\n", dwMessageType);
		break;
	}

	return TRUE;
}

//==================================================================================
// DpStressStartFunction
//----------------------------------------------------------------------------------
//
// Description: Funtion called once for each stress session that is created
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	BYTE		byClientCount	Number of clients this test is being started with
//	DWORD		*ClientAddrs	List of client addresses (number of addresses indicated by byClientCount)
//	WORD		LowPort			The lowest port to use for this test
//	WORD		HighPort		The higest port to use for this test
//
// Returns:
//	Returns a pointer to the session information that is being stored for this session
//==================================================================================
LPVOID DpStressStartFunction(HANDLE hNetsyncObject, BYTE byClientCount, DWORD *ClientAddrs, WORD LowPort, WORD HighPort)
{
	PDPSTRESS_SESSION_INFO pCurrentSession = NULL;
	IN_ADDR CurrentAddr;
	BYTE n;

	pCurrentSession = (PDPSTRESS_SESSION_INFO) LocalAlloc(LPTR, sizeof(DPSTRESS_SESSION_INFO));
	if(!pCurrentSession)
	{
		DbgPrint("Couldn't allocate session info structure! (error %u)\n", GetLastError());
		return NULL;
	}

	DbgPrint("Starting stress session: 0x%08x\n", pCurrentSession);

	// Fill the session info structure
	pCurrentSession->hNetsyncObject = hNetsyncObject;
	pCurrentSession->byClientCount = byClientCount;
	pCurrentSession->ClientAddrs = ClientAddrs;
	pCurrentSession->dwLastHostPing = GetTickCount();
	pCurrentSession->LowPort = LowPort;
	pCurrentSession->HighPort = HighPort;

	// Stress sessions ignore the client addresses provided in the host info message
	// so the size of the DP_HOSTINFO structure is constant for this case

	// Allocate and initialize the host info message
	pCurrentSession->pHostInfo = (DP_HOSTINFO *) LocalAlloc(LPTR, sizeof(DP_HOSTINFO));
	if(!pCurrentSession->pHostInfo)
	{
		DbgPrint("Couldn't allocate host info message! (error %u)\n", GetLastError());
		return NULL;
	}

	memset(pCurrentSession->pHostInfo, 0, sizeof(DP_HOSTINFO));
	pCurrentSession->pHostInfo->dwMessageId = DPMSG_HOSTINFO;
	pCurrentSession->pHostInfo->dwTotalMachines = (DWORD) byClientCount;
	pCurrentSession->pHostInfo->dwHostAddr = ClientAddrs[0];

	// Send the host info message to all machines that started the test
	for(n = 0; n < byClientCount; ++n)
	{
		CurrentAddr.S_un.S_addr = ClientAddrs[n];

		if(n == 0)
		{
			DbgPrint("  Host is %s\n", inet_ntoa(CurrentAddr));
		}
		else
		{
			DbgPrint("  Client %u is %s\n", n, inet_ntoa(CurrentAddr));
		}

		NetsyncSendClientMessage(hNetsyncObject, ClientAddrs[n], sizeof(DP_HOSTINFO), (char *) (pCurrentSession->pHostInfo));
	}

	return (LPVOID) pCurrentSession;
}

//==================================================================================
// DpStressStopFunction
//----------------------------------------------------------------------------------
//
// Description: Function called once when each stress session is closed
//
// Arguments:
//	HANDLE		hNetsyncObject	Handle to calling instance
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
VOID DpStressStopFunction(HANDLE hNetsyncObject, LPVOID lpContext)
{
	PDPSTRESS_SESSION_INFO pCurrentSession = (PDPSTRESS_SESSION_INFO) lpContext;

	DbgPrint("Stopping stress session: 0x%08x\n", pCurrentSession);

	LocalFree(pCurrentSession->pHostInfo);
	LocalFree(pCurrentSession);

	return;
}

//==================================================================================
// Test functions
//==================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\wrappeer.h ===
#ifndef __DNETRSLT_WRAPPEER__
#define __DNETRSLT_WRAPPEER__

//==================================================================================
// Classes
//==================================================================================
class CWrapDP8Peer
{
	private:
		HANDLE				m_hLog;
		BOOL				m_fInitialized; // has Initialize been successfully called?
		//BOOL				m_fConnected; // has Connect been successfully called?


	public:
#ifdef REMOVE_DPLAY_IMPORTS
		LPVOID				m_pDP8Peer;
#else
		PDIRECTPLAY8PEER	m_pDP8Peer; // pointer to real DirectPlay8Peer object
#endif

		CWrapDP8Peer(HANDLE hLog);
		virtual ~CWrapDP8Peer(void);


		// DirectPlay8Peer object maintenance functions
		HRESULT CoCreate(void);
		HRESULT Release(void);


		// IDirectPlay8Peer methods
		STDMETHODIMP DP8P_Initialize(PVOID const pvUserContext,
									const PFNDPNMESSAGEHANDLER pfn,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_DoWork(const DWORD dwFlags);

		STDMETHODIMP DP8P_EnumServiceProviders(const GUID * const pguidServiceProvider,
												const GUID * const pguidApplication,
												DPN_SERVICE_PROVIDER_INFO * const pSPInfoBuffer,
												DWORD * const pcbEnumData,
												DWORD * const pcReturned,
												const DWORD dwFlags);

		STDMETHODIMP DP8P_CancelAsyncOperation(const DPNHANDLE hAsyncHandle,
												const DWORD dwFlags);

		STDMETHODIMP DP8P_Connect(const DPN_APPLICATION_DESC * const pdnAppDesc,
								IDirectPlay8Address * const pHostAddr,
								IDirectPlay8Address * const pDeviceInfo,
								const DPN_SECURITY_DESC * const pdnSecurity,
								const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
								const void * const pvUserConnectData,
								const DWORD dwUserConnectDataSize,
								void * const pvPlayerContext,
								void * const pvAsyncContext,
								DPNHANDLE * const phAsyncHandle,
								const DWORD dwFlags);

		STDMETHODIMP DP8P_SendTo(const DPNID dpnid,
								const DPN_BUFFER_DESC * const prgBufferDesc,
								const DWORD cBufferDesc,
								const DWORD dwTimeOut,
								void * const pvAsyncContext,
								DPNHANDLE * const phAsyncHandle,
								const DWORD dwFlags);

		STDMETHODIMP DP8P_GetSendQueueInfo(const DPNID dpnid,
											DWORD * const pdwNumMsgs,
											DWORD * const pdwNumBytes,
											const DWORD dwFlags);

		STDMETHODIMP DP8P_Host(const DPN_APPLICATION_DESC * const pdnAppDesc,
								IDirectPlay8Address ** const prgpDeviceInfo,
								const DWORD cDeviceInfo,
								const DPN_SECURITY_DESC * const pdnSecurity,
								const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
								void * const pvPlayerContext,
								const DWORD dwFlags);

		STDMETHODIMP DP8P_GetApplicationDesc(DPN_APPLICATION_DESC * const pAppDescBuffer,
											DWORD * const pcbDataSize,
											const DWORD dwFlags);

		STDMETHODIMP DP8P_SetApplicationDesc(const DPN_APPLICATION_DESC * const pad,
											const DWORD dwFlags);

		STDMETHODIMP DP8P_CreateGroup(const DPN_GROUP_INFO * const pdpnGroupInfo,
									PVOID const pvGroupContext,
									PVOID const pvAsyncContext,
									DPNHANDLE * const phAsyncHandle,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_DestroyGroup(const DPNID idGroup,
									PVOID const pvAsyncContext,
									DPNHANDLE * const phAsyncHandle,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_AddPlayerToGroup(const DPNID idGroup,
										const DPNID idClient,
										PVOID const pvAsyncContext,
										DPNHANDLE * const phAsyncHandle,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_RemovePlayerFromGroup(const DPNID idGroup,
												const DPNID idClient,
												PVOID const pvAsyncContext,
												DPNHANDLE * const phAsyncHandle,
												const DWORD dwFlags);

		STDMETHODIMP DP8P_SetGroupInfo(const DPNID dpnid,
										DPN_GROUP_INFO * const pdpnGroupInfo,
										PVOID const pvAsyncContext,
										DPNHANDLE * const phAsyncHandle,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_GetGroupInfo(const DPNID dpnid,
										DPN_GROUP_INFO * const pdpnGroupInfo,
										DWORD * const pdwSize,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_EnumPlayersAndGroups(DPNID * const prgdpid,
												DWORD * const pcdpid,
												const DWORD dwFlags);

		STDMETHODIMP DP8P_EnumGroupMembers(const DPNID dpid,
										DPNID * const prgdpid,
										DWORD * const pcdpid,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_SetPeerInfo(const DPN_PLAYER_INFO * const pdpnPlayerInfo,
									PVOID const pvAsyncContext,
									DPNHANDLE * const phAsyncHandle,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_GetPeerInfo(const DPNID dpnid,
									DPN_PLAYER_INFO * const pdpnPlayerInfo,
									DWORD * const pdwSize,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_GetPeerAddress(const DPNID dpnid,
										IDirectPlay8Address ** const pAddress,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_GetLocalHostAddresses(IDirectPlay8Address ** const prgpAddress,
												DWORD * const pcAddress,
												const DWORD dwFlags);
		STDMETHODIMP DP8P_Close(const DWORD dwFlags);

		STDMETHODIMP DP8P_EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,
									IDirectPlay8Address * const pAddrHost,
									IDirectPlay8Address * const pDeviceInfo,
									PVOID const pUserEnumData,
									const DWORD dwUserEnumDataSize,
									const DWORD dwEnumCount,
									const DWORD dwRetryInterval,
									const DWORD dwTimeOut,
									PVOID const pvUserContext,
									DPNHANDLE * const pAsyncHandle,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_DestroyPeer(const DPNID dpidClient,
										const void * const pDestroyInfo,
										const DWORD dwDestroyInfoSize,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_ReturnBuffer(const DPNHANDLE hBufferHandle,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_GetPlayerContext(const DPNID dpnid,
											PVOID * const ppvPlayerContext,
											const DWORD dwFlags);

		STDMETHODIMP DP8P_GetGroupContext(const DPNID dpnid,
										PVOID * const ppvGroupContext,
										const DWORD dwFlags);

		STDMETHODIMP DP8P_GetCaps(DPN_CAPS * const pdpCaps,
								const DWORD dwFlags);

		STDMETHODIMP DP8P_SetCaps(const DPN_CAPS * const pdpCaps,
								const DWORD dwFlags);

		STDMETHODIMP DP8P_SetSPCaps(const GUID * const pguidSP,
									const DPN_SP_CAPS * const pdpspCaps,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_GetSPCaps(const GUID * const pguidSP,
									DPN_SP_CAPS *const pdpspCaps,
									const DWORD dwFlags);

		STDMETHODIMP DP8P_GetConnectionInfo(const DPNID dpnid,
											DPN_CONNECTION_INFO * const pdpConnectionInfo,
											const DWORD dwFlags);

		STDMETHODIMP DP8P_TerminateSession(void * const pvTerminateData,
											const DWORD dwTerminateDataSize,
											const DWORD dwFlags);



		// Returns whether this object has been initialized or not.
		inline BOOL IsInitialized(void) { return (this->m_fInitialized); };
};

//==================================================================================
// Class type definitions
//==================================================================================
typedef class CWrapDP8Peer			CWrapDP8Peer,			* PWRAPDP8PEER;

#endif //__DNETRSLT_WRAPPEER__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\wrapbase.h ===
#ifndef __DNGURL_WRAPBASE__
#define __DNGURL_WRAPBASE__

//==================================================================================
// Classes
//==================================================================================
class CWrapDP8Address
{
	private:
		HANDLE m_hLog;
		PDIRECTPLAY8ADDRESS		m_pDP8Address; // pointer to real DirectPlay8Address object


	public:
		CWrapDP8Address(HANDLE hLog);
		virtual ~CWrapDP8Address(void);


		// DirectPlay8Address object maintenance functions
		HRESULT CoCreate(void);
		HRESULT Release(void);


		// IDirectPlay8Address methods
		STDMETHODIMP DPA_QueryInterface(REFIID riid, PVOID* ppvObj);
		STDMETHODIMP DPA_BuildFromURLW(WCHAR* wszSourceURL);
		STDMETHODIMP DPA_BuildFromURLA(CHAR* szSourceURL);
		STDMETHODIMP DPA_Duplicate(PDIRECTPLAY8ADDRESS* ppdpaNewAddress);
		STDMETHODIMP DPA_SetEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress);
		STDMETHODIMP DPA_IsEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress);
		STDMETHODIMP DPA_Clear(void);
		STDMETHODIMP DPA_GetURLW(WCHAR* pwszURL, PDWORD pdwNumChars);
		STDMETHODIMP DPA_GetURLA(CHAR* pszURL, PDWORD pdwNumChars);
		STDMETHODIMP DPA_GetSP(GUID* pguidSP);
		STDMETHODIMP DPA_GetUserData(void* pvUserData, PDWORD pdwBufferSize);
		STDMETHODIMP DPA_SetSP(const GUID * const pguidSP);
		STDMETHODIMP DPA_SetUserData(const void * const pvUserData,
									const DWORD dwDataSize);
		STDMETHODIMP DPA_GetNumComponents(PDWORD pdwNumComponents);
		STDMETHODIMP DPA_GetComponentByName(const WCHAR * const wszName,
											void* pvBuffer, PDWORD pdwBufferSize,
											PDWORD pdwDataType);
		STDMETHODIMP DPA_GetComponentByIndex(const DWORD dwComponentID,
											WCHAR* pwszName, PDWORD pdwNameLen,
											void* pvBuffer, PDWORD pdwBufferSize,
											PDWORD pdwDataType);
		STDMETHODIMP DPA_AddComponent(const WCHAR * const wszName,
										const void * const pvData,
										const DWORD dwDataSize,
										const DWORD dwDataType);
		STDMETHODIMP DPA_GetDevice(GUID* pguidDevice);
		STDMETHODIMP DPA_SetDevice(const GUID * const pguidDevice);
		STDMETHODIMP DPA_BuildFromSockAddr(const SOCKADDR * const pSockAddr);

//		STDMETHODIMP DPA_BuildFromDPADDRESS(void* pvAddress, DWORD dwDataSize);

};

class CWrapDP8AddressIP
{
	private:
		HANDLE m_hLog;
/* XBOX - IP functions are merged with address object for now
		PDIRECTPLAY8ADDRESSIP		m_pDP8AddressIP; // pointer to real DirectPlay8AddressIP object
*/

	public:
		PDIRECTPLAY8ADDRESS			m_pDP8AddressIP; // pointer to real DirectPlay8Address object

		CWrapDP8AddressIP(HANDLE hLog);
		virtual ~CWrapDP8AddressIP(void);


		// DirectPlay8AddressIP object maintenance functions
		HRESULT CoCreate(void);
		HRESULT Release(void);


		// IDirectPlay8Address methods
//		STDMETHODIMP DPA_QueryInterface(REFIID riid, PVOID* ppvObj);
		STDMETHODIMP DPA_Duplicate(PDIRECTPLAY8ADDRESS* ppdpaNewAddress);
		STDMETHODIMP DPA_SetEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress);
		STDMETHODIMP DPA_IsEqual(PDIRECTPLAY8ADDRESS pdpaNewAddress);
		STDMETHODIMP DPA_GetURLW(WCHAR* pwszURL, PDWORD pdwNumChars);
		STDMETHODIMP DPA_GetURLA(CHAR* pszURL, PDWORD pdwNumChars);
		STDMETHODIMP DPA_GetUserData(void* pvUserData, PDWORD pdwBufferSize);
		STDMETHODIMP DPA_SetUserData(const void * const pvUserData, const DWORD dwDataSize);
		STDMETHODIMP DPA_BuildFromSockAddr(SOCKADDR* psockAddr);
		STDMETHODIMP DPA_GetSockAddress(SOCKADDR* psockAddress, PDWORD pwdAddressBufferSize);
		STDMETHODIMP DPA_BuildAddress(WCHAR* wszAddress, USHORT usPort);
		STDMETHODIMP DPA_GetAddress(WCHAR* wszAddress, PDWORD pdwAddressLength, USHORT* psPort);
		STDMETHODIMP DPA_BuildLocalAddress(GUID* pguidAdapter, USHORT usPort);
		STDMETHODIMP DPA_GetLocalAddress(GUID* pguidAdapter, USHORT* pusPort);
		

};

//==================================================================================
// Class type definitions
//==================================================================================
typedef class CWrapDP8Address			CWrapDP8Address,			* PWRAPDP8ADDRESS;
typedef class CWrapDP8AddressIP			CWrapDP8AddressIP,			* PWRAPDP8ADDRESSIP;

#endif //__DNGURL_WRAPBASE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\wrapclient.h ===
#ifndef __DNETRSLT_WRAPCLIENT__
#define __DNETRSLT_WRAPCLIENT__

//==================================================================================
// Classes
//==================================================================================
class CWrapDP8Client
{
	private:
		HANDLE				m_hLog;
		BOOL				m_fInitialized; // has Initialize been successfully called?
		//BOOL				m_fConnected; // has Connect been successfully called?


	public:
		PDIRECTPLAY8CLIENT	m_pDP8Client; // pointer to real DirectPlay8Client object


		CWrapDP8Client(HANDLE hLog);
		virtual ~CWrapDP8Client(void);


		// DirectPlay8Client object maintenance functions
		HRESULT CoCreate(void);
		HRESULT Release(void);


		// IDirectPlay8Client methods
		STDMETHODIMP DP8C_Initialize(PVOID const pvUserContext,
									const PFNDPNMESSAGEHANDLER pfn,
									const DWORD dwFlags);

		STDMETHODIMP DP8C_DoWork(const DWORD dwFlags);

		STDMETHODIMP DP8C_EnumServiceProviders(const GUID * const pguidServiceProvider,
												const GUID * const pguidApplication,
												DPN_SERVICE_PROVIDER_INFO * const pSPInfoBuffer,
												DWORD * const pcbEnumData,
												DWORD * const pcReturned,
												const DWORD dwFlags);

		STDMETHODIMP DP8C_EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,
									IDirectPlay8Address * const pAddrHost,
									IDirectPlay8Address * const pDeviceInfo,
									PVOID const pUserEnumData,
									const DWORD dwUserEnumDataSize,
									const DWORD dwEnumCount,
									const DWORD dwRetryInterval,
									const DWORD dwTimeOut,
									PVOID const pvUserContext,
									DPNHANDLE * const pAsyncHandle,
									const DWORD dwFlags);

		STDMETHODIMP DP8C_CancelAsyncOperation(const DPNHANDLE hAsyncHandle,
												const DWORD dwFlags);

		STDMETHODIMP DP8C_Connect(const DPN_APPLICATION_DESC * const pdnAppDesc,
								IDirectPlay8Address * const pHostAddr,
								IDirectPlay8Address * const pDeviceInfo,
								const DPN_SECURITY_DESC * const pdnSecurity,
								const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
								const void * const pvUserConnectData,
								const DWORD dwUserConnectDataSize,
								void * const pvAsyncContext,
								DPNHANDLE * const phAsyncHandle,
								const DWORD dwFlags);


		STDMETHODIMP DP8C_GetSendQueueInfo(DWORD * const pdwNumMsgs,
											DWORD * const pdwNumBytes,
											const DWORD dwFlags);


		STDMETHODIMP DP8C_Send(const DPN_BUFFER_DESC *const pBufferDesc,
									   const DWORD cBufferDesc, const DWORD dwTimeOut,
									   void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle,
									   const DWORD dwFlags);

		STDMETHODIMP DP8C_SetClientInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,
													 PVOID const pvAsyncContext,
													 DPNHANDLE *const phAsyncHandle,
													 const DWORD dwFlags);

		STDMETHODIMP DP8C_SetSPCaps(const GUID *const pguidSP,
											const DPN_SP_CAPS *const pdpSPCaps,
											const DWORD dwFlags);

		STDMETHODIMP DP8C_GetCaps(DPN_CAPS * const pdpCaps, const DWORD dwFlags);
		
		STDMETHODIMP DP8C_SetCaps(const DPN_CAPS * const pdpCaps, const DWORD dwFlags);

		STDMETHODIMP DP8C_GetServerInfo(DPN_PLAYER_INFO *const pdpnPlayerInfo,
												DWORD *const pdwSize,
												const DWORD dwFlags);

		STDMETHODIMP DP8C_GetConnectionInfo(DPN_CONNECTION_INFO *const pdnConnectInfo,
													const DWORD dwFlags);

		STDMETHODIMP DP8C_GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer,
													 DWORD *const pcbDataSize,
													 const DWORD dwFlags);

		STDMETHODIMP DP8C_GetSPCaps(const GUID *const pguidSP,
											DPN_SP_CAPS *const pdpnSPCaps,
											const DWORD dwFlags);

		STDMETHODIMP DP8C_GetServerAddress(IDirectPlay8Address ** const pAddress,
											const DWORD dwFlags);

		STDMETHODIMP DP8C_Close(const DWORD dwFlags);



		// Returns whether this object has been initialized or not.
		inline BOOL IsInitialized(void) { return (this->m_fInitialized); };
};

//==================================================================================
// Class type definitions
//==================================================================================
typedef class CWrapDP8Client			CWrapDP8Client,			* PWRAPDP8CLIENT;

#endif //__DNETRSLT_WRAPCLIENT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\inc\wrapserver.h ===
#ifndef __DNETRSLT_WRAPSERVER__
#define __DNETRSLT_WRAPSERVER__

//==================================================================================
// Classes
//==================================================================================
class CWrapDP8Server
{
	private:
		HANDLE				m_hLog;
		BOOL				m_fInitialized; // has Initialize been successfully called?
		//BOOL				m_fConnected; // has Connect been successfully called?


	public:
		PDIRECTPLAY8SERVER	m_pDP8Server; // pointer to real DirectPlay8Server object


		CWrapDP8Server(HANDLE hLog);
		virtual ~CWrapDP8Server(void);


		// DirectPlay8Server object maintenance functions
		HRESULT CoCreate(void);
		HRESULT Release(void);


		// IDirectPlay8Server methods
		STDMETHODIMP DP8S_Initialize(PVOID const pvUserContext,
									const PFNDPNMESSAGEHANDLER pfn,
									const DWORD dwFlags);

		STDMETHODIMP DP8S_DoWork(const DWORD dwFlags);

		STDMETHODIMP DP8S_EnumServiceProviders(const GUID * const pguidServiceProvider,
												const GUID * const pguidApplication,
												DPN_SERVICE_PROVIDER_INFO * const pSPInfoBuffer,
												DWORD * const pcbEnumData,
												DWORD * const pcReturned,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_EnumPlayersAndGroups(DPNID *const prgdpnid,
												DWORD *const pcdpnid,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_CancelAsyncOperation(const DPNHANDLE hAsyncHandle,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_GetSendQueueInfo(const DPNID dpnid,
											DWORD * const pdwNumMsgs,
											DWORD * const pdwNumBytes,
											const DWORD dwFlags);


		STDMETHODIMP DP8S_GetClientAddress(const DPNID dpnid,
										IDirectPlay8Address ** const pAddress,
										const DWORD dwFlags);

		STDMETHODIMP DP8S_GetClientInfo(const DPNID dpnid,
												DPN_PLAYER_INFO *const pdpnPlayerInfo,
												DWORD *const pdwSize,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_GetLocalHostAddresses(IDirectPlay8Address ** const prgpAddress,
												DWORD * const pcAddress,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_GetConnectionInfo(const DPNID dpnidEndPoint,
													DPN_CONNECTION_INFO *const pdnConnectInfo,
													const DWORD dwFlags);

		STDMETHODIMP DP8S_GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer,
													 DWORD *const pcbDataSize,
													 const DWORD dwFlags);

		STDMETHODIMP DP8S_SetApplicationDesc(const DPN_APPLICATION_DESC * const pad,
											const DWORD dwFlags);

		STDMETHODIMP DP8S_SetServerInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,
													 PVOID const pvAsyncContext,
													 DPNHANDLE *const phAsyncHandle,
													 const DWORD dwFlags);

		STDMETHODIMP DP8S_SetSPCaps(const GUID *const pguidSP,
											const DPN_SP_CAPS *const pdpSPCaps,
											const DWORD dwFlags);

		STDMETHODIMP DP8S_GetSPCaps(const GUID *const pguidSP,
											DPN_SP_CAPS *const pdpnSPCaps,
											const DWORD dwFlags);

		STDMETHODIMP DP8S_GetCaps(DPN_CAPS * const pdpCaps, const DWORD dwFlags);
		
		STDMETHODIMP DP8S_SetCaps(const DPN_CAPS * const pdpCaps, const DWORD dwFlags);

		STDMETHODIMP DP8S_Host(const DPN_APPLICATION_DESC * const pdnAppDesc,
								IDirectPlay8Address ** const prgpDeviceInfo,
								const DWORD cDeviceInfo,
								const DPN_SECURITY_DESC * const pdnSecurity,
								const DPN_SECURITY_CREDENTIALS * const pdnCredentials,
								void * const pvPlayerContext,
								const DWORD dwFlags);

		STDMETHODIMP DP8S_SendTo(const DPNID dpnid,
								const DPN_BUFFER_DESC * const prgBufferDesc,
								const DWORD cBufferDesc,
								const DWORD dwTimeOut,
								void * const pvAsyncContext,
								DPNHANDLE * const phAsyncHandle,
								const DWORD dwFlags);

		STDMETHODIMP DP8S_DestroyClient(const DPNID dpnidClient,
												const VOID *const pDestroyInfo,
												const DWORD dwDestroyInfoSize,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_GetPlayerContext(const DPNID dpnid,
												PVOID * const ppvPlayerContext,
												const DWORD dwFlags);

		STDMETHODIMP DP8S_CreateGroup(const DPN_GROUP_INFO *const pdpnGroupInfo,
											  VOID *const pvGroupContext,VOID *const pvAsyncContext,
											  DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);

		STDMETHODIMP DP8S_AddPlayerToGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext,
												   DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);

		STDMETHODIMP DP8S_Close(const DWORD dwFlags);



		// Returns whether this object has been initialized or not.
		inline BOOL IsInitialized(void) { return (this->m_fInitialized); };
};

//==================================================================================
// Class type definitions
//==================================================================================
typedef class CWrapDP8Server			CWrapDP8Server,			* PWRAPDP8SERVER;

#endif //__DNETRSLT_WRAPSERVER__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\repro\peeraddressclose2\peeraddressclose2.cpp ===
//-----------------------------------------------------------------------------
// File: peeraddressclose2.cpp
//
// Desc: Repro case for blocking close after peer address call
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <dplay8.h>
#include <dpaddr.h>

//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------
#define TEST_SECTION	OutputDebugString
#define CREATEEVENT_OR_THROW(handle, lpEventAttributes, fManualReset, fInitialState, pszName)\
										{\
											if (handle != NULL)\
											{\
												OutputDebugString("Handle is not NULL!\n");\
												__asm int 3\
											}\
											handle = CreateEvent(lpEventAttributes, fManualReset, fInitialState, pszName);\
											if (handle == NULL)\
											{\
												OutputDebugString("Couldn't create event!\n");\
												__asm int 3\
											}\
										}
#define IS_VALID_HANDLE(x)  			(x && (INVALID_HANDLE_VALUE != x))
#define SAFE_CLOSEHANDLE(h)				{\
											if (IS_VALID_HANDLE(h))\
											{\
												CloseHandle(h);\
												h = NULL;\
											}\
										}												

//-----------------------------------------------------------------------------
// Structures
//-----------------------------------------------------------------------------
typedef struct tagPARMVPGETPEERADDRESSCONTEXT
{
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETPEERADDRESSCONTEXT, * PPARMVPGETPEERADDRESSCONTEXT;

typedef struct _DP_DOWORKLIST {
	DWORD					dwNumPeers;					// Number of peer objects present
	PDIRECTPLAY8PEER		*apDP8Peers;				// An array of pointers to peer objects
	DWORD					**apdwPeerCallbackTimes;	// An array of pointers to DWORDS that track the
														// amount of time spent in callbacks per peer
} DP_DOWORKLIST, *PDP_DOWORKLIST;

//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
GUID g_guidApp = { 0x2ae835d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 } };

//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------
HRESULT ParmVPGetPeerAddressDPNMessageHandler(PVOID, DWORD, PVOID);
HRESULT ParmVCreatePeerHost(PFNDPNMESSAGEHANDLER, PVOID, PDPN_APPLICATION_DESC, PVOID,
							LPDIRECTPLAY8PEER*, PDIRECTPLAY8ADDRESS*);
BOOL PollUntilEventSignalled(PDP_DOWORKLIST, DWORD, HANDLE);
VOID ClearDoWorkList(DP_DOWORKLIST *);

void __cdecl main()
{
	LPDIRECTPLAY8PEER				pDP8Peer = NULL, pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8HostAddress = NULL;
	PDIRECTPLAY8ADDRESS				pDP8HostAddressCompare = NULL;
	PDIRECTPLAY8ADDRESS				pDP8ReturnedAddress = NULL;
	PARMVPGETPEERADDRESSCONTEXT		hostcontext;
	PARMVPGETPEERADDRESSCONTEXT		nonhostcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HRESULT							hr = DPN_OK;
	HANDLE							hAsyncOpComplete = NULL;
	
	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETPEERADDRESSCONTEXT));
	hostcontext.fHost = TRUE;
	
	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETPEERADDRESSCONTEXT));
	
    if (XnetInitialize(NULL, TRUE) != NO_ERROR)
    {
        __asm int 3;
        goto Exit;
    }

    if (FAILED(DPlayInitialize(1024 * 200)))
    {
        __asm int 3;
        goto Exit;
    }

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Creating DirectPlay8Peer object\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) &pDP8Peer, NULL);
	if( FAILED(hr) )
	{
		__asm int 3;
	}
	
	ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
	dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpnad.guidApplication = g_guidApp;
	
	// Save what we're passing in to make sure it's not touched.
	CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Initializing peer object with nonhost context\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = pDP8Peer->Initialize(&nonhostcontext, ParmVPGetPeerAddressDPNMessageHandler, 0);
	if (hr != DPN_OK)
	{
		OutputDebugString("Initializing peer object with context, 0 flags failed!\n");
		__asm int 3;
		goto Exit;
	}
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Creating new peer host object\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = ParmVCreatePeerHost(ParmVPGetPeerAddressDPNMessageHandler, &hostcontext, &dpnad, &(hostcontext.dpnidHost),
		&pDP8PeerHost, &pDP8HostAddress);
	if (hr != DPN_OK)
	{
		OutputDebugString("Creating peer host failed!\n");
		__asm int 3;
		goto Exit;
	}
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Connecting peer\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	// Host should get the create player now.
	CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
	CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);
	
	// Even though it's synchronous, we'll still get a completion.  The async op
	// handle will be NULL, though.
	nonhostcontext.fConnectCanComplete = TRUE;
	
	hr = pDP8Peer->Connect(&dpnad, pDP8HostAddress, NULL, NULL, NULL, NULL, 0,
		&(nonhostcontext.dpnidClient), hAsyncOpComplete, &hAsyncOp, 0);
	
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
	{
		OutputDebugString("Couldn't connect!\n");
		__asm int 3;
		goto Exit;
	} // end if (couldn't connect)
	
	if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
	{
		OutputDebugString("Application desc structure was modified!\n");
		__asm int 3;
		goto Exit;
	} // end if (app desc changed)
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Waiting for connect to complete on non-host\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
	DoWorkList.dwNumPeers = 2;
	DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) LocalAlloc(LPTR, sizeof(LPVOID) * 2);
	DoWorkList.apDP8Peers[0] = pDP8Peer;
	DoWorkList.apDP8Peers[1] = pDP8PeerHost;
	
	if(!PollUntilEventSignalled(&DoWorkList, 60000, hAsyncOpComplete))
	{
		OutputDebugString("Polling for asynchronous operation failed!\n");
		__asm int 3;
		goto Exit;
	}
	
	ClearDoWorkList(&DoWorkList);
	
	// Prevent any weird connects from completing.
	nonhostcontext.fConnectCanComplete = FALSE;
	
	// Make sure we saw the connect completion indication.
	if (! nonhostcontext.fConnectCompleted)
	{
		OutputDebugString("Didn't get connect complete indication!\n");
		__asm int 3;
		goto Exit;
	} // end if (connect didn't complete)
	
	// Reset the context.
	nonhostcontext.fConnectCompleted = FALSE;
	
	// Make sure we got the create player messages.
	if (nonhostcontext.dpnidHost == 0)
	{
		OutputDebugString("Didn't get CREATE_PLAYER indication for host on client!\n");
		__asm int 3;
		goto Exit;
	} // end if (didn't get create player)
	
	if (nonhostcontext.dpnidClient == 0)
	{
		OutputDebugString("Didn't get CREATE_PLAYER indication for client on client!\n");
		__asm int 3;
		goto Exit;
	} // end if (didn't get create player)
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Waiting for create player to be indicated on host\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
	DoWorkList.dwNumPeers = 2;
	DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) LocalAlloc(LPTR, sizeof(LPVOID) * 2);
	DoWorkList.apDP8Peers[0] = pDP8Peer;
	DoWorkList.apDP8Peers[1] = pDP8PeerHost;
	
	if(!PollUntilEventSignalled(&DoWorkList, 60000, hostcontext.hClientCreatedEvent))
	{
		OutputDebugString("Polling for asynchronous operation failed!\n");
		__asm int 3;
		goto Exit;
	}
	
	ClearDoWorkList(&DoWorkList);
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Getting client's peer address on host\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = pDP8PeerHost->GetPeerAddress(hostcontext.dpnidClient, &pDP8ReturnedAddress, 0);
	if (hr != DPN_OK)
	{
		OutputDebugString("Getting client's peer address on host failed!\n");
		__asm int 3;
		goto Exit;
	} // end if (couldn't get peer address)
	
	if (pDP8ReturnedAddress == NULL)
	{
		OutputDebugString("No address was returned)!\n");
		__asm int 3;
		goto Exit;
	} // end if (no address returned)
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Closing peer client object\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = pDP8Peer->Close(0);
	if (hr != DPN_OK)
	{
		OutputDebugString("Closing peer client object failed!\n");
		__asm int 3;
		goto Exit;
	} // end if (couldn't close)
	
	// Make sure we got the destroy player messages.
	if (nonhostcontext.dpnidHost != 0)
	{
		OutputDebugString("Didn't get DESTROY_PLAYER indication for host on client!\n");
		__asm int 3;
		goto Exit;
	} // end if (didn't get destroy player)
	
	if (nonhostcontext.dpnidClient != 0)
	{
		OutputDebugString("Didn't get DESTROY_PLAYER indication for client on client!\n");
		__asm int 3;
		goto Exit;
	} // end if (didn't get destroy player)
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Closing host object\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = pDP8PeerHost->Close(0);
	if (hr != DPN_OK)
	{
		OutputDebugString("Closing host object failed!\n");
		__asm int 3;
		goto Exit;
	} // end if (couldn't close)
	
	// Make sure we got the destroy player messages.
	if (hostcontext.dpnidHost != 0)
	{
		OutputDebugString("Didn't get DESTROY_PLAYER indication for host on host!\n");
		__asm int 3;
		goto Exit;
	} // end if (didn't get destroy player)
	
	if (hostcontext.dpnidClient != 0)
	{
		OutputDebugString("Didn't get DESTROY_PLAYER indication for client on host!\n");
		__asm int 3;
		goto Exit;
	} // end if (didn't get destroy player)
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Releasing hosting DirectPlay8Peer object\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = pDP8PeerHost->Release();
	if (hr != S_OK)
	{
		OutputDebugString("Couldn't release hosting DirectPlay8Peer object!\n");
		__asm int 3;
		goto Exit;
	} // end if (couldn't release object)
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TEST_SECTION("Releasing DirectPlay8Peer object\n");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	hr = pDP8Peer->Release();
	if (hr != S_OK)
	{
		OutputDebugString("Couldn't release DirectPlay8Peer object!\n");
		__asm int 3;
		goto Exit;
	} // end if (couldn't release object)
	
	
Exit:
	
	if (pDP8Peer != NULL)
	{
		pDP8Peer->Release();
		pDP8Peer = NULL;
	} // end if (have peer object)
	
	if (pDP8PeerHost != NULL)
	{
		pDP8PeerHost->Release();
		pDP8PeerHost = NULL;
	} // end if (have peer object)
	
	pDP8HostAddress ? pDP8HostAddress->Release() : 0;
	pDP8HostAddressCompare ? pDP8HostAddressCompare->Release() : 0;
	pDP8ReturnedAddress ? pDP8ReturnedAddress->Release() : 0;
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	while(TRUE);

	return;
}

HRESULT ParmVPGetPeerAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVPGETPEERADDRESSCONTEXT	pContext = (PPARMVPGETPEERADDRESSCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;

//			OutputDebugString("DPN_MSGID_CONNECT_COMPLETE\n");

			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				__asm int 3;
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;

//			OutputDebugString("DPN_MSGID_CREATE_PLAYER\n");

			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();

					__asm int 3;

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;

//			OutputDebugString("DPN_MSGID_DESTROY_PLAYER\n");

			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				__asm int 3;
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;

//			OutputDebugString("DPN_MSGID_INDICATE_CONNECT\n");

			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

		  break;

		default:

//			OutputDebugString("Unhandled message!\n");

			__asm int 3;
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

DONE:

	return (hr);
}

HRESULT ParmVCreatePeerHost(PFNDPNMESSAGEHANDLER pfn, PVOID pvContext, PDPN_APPLICATION_DESC pdpnad,
							PVOID pvPlayerContext, LPDIRECTPLAY8PEER* ppDP8PeerHost, PDIRECTPLAY8ADDRESS* ppDP8AddressHost)
{
	HRESULT					hr;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	PDIRECTPLAY8ADDRESS*	paDP8HostAddresses = NULL;
	DWORD					dwNumAddresses = 0;



	if ((*ppDP8PeerHost) != NULL)
	{
		OutputDebugString("Already have peer object!");
		return (ERROR_INVALID_PARAMETER);
	} // end if (already have object)


	hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) ppDP8PeerHost, NULL);
	if( FAILED(hr) )
	{
		__asm int 3;
	}

	hr = (*ppDP8PeerHost)->Initialize(pvContext, pfn, 0);
	if (hr != DPN_OK)
	{
		OutputDebugString("Initializing DP8Peer object failed!\n");
		goto ERROR_EXIT;
	} // end if (function failed)

	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);
	if (hr != S_OK)
	{
		OutputDebugString("Couldn't DirectPlay8AddressCreate host DirectPlay8Address object!\n");
		goto ERROR_EXIT;
	} // end if (DirectPlay8AddressCreate failed)

	hr = (*ppDP8PeerHost)->Host(pdpnad, &pDP8AddressDevice, 1, NULL, NULL, pvPlayerContext, 0);
	if (hr != DPN_OK)
	{
		OutputDebugString("Hosting failed!\n");
		goto ERROR_EXIT;
	} // end if (function failed)

	pDP8AddressDevice->Release();
	pDP8AddressDevice = NULL;

	// If the caller wants an address, give one to him.
	if (ppDP8AddressHost != NULL)
	{
		// Ignore error
		hr = (*ppDP8PeerHost)->GetLocalHostAddresses(NULL, &dwNumAddresses, 0);


		paDP8HostAddresses = (PDIRECTPLAY8ADDRESS*) LocalAlloc(LPTR, dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));
		if (paDP8HostAddresses == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)


		hr = (*ppDP8PeerHost)->GetLocalHostAddresses(paDP8HostAddresses, &dwNumAddresses, 0);
		if (hr != DPN_OK)
		{
			OutputDebugString("Getting local addresses failed!\n");
			goto ERROR_EXIT;
		} // end if (getting addresses failed)


		// Move the first address to the caller's pointer.
		(*ppDP8AddressHost) = paDP8HostAddresses[0];
		paDP8HostAddresses[0] = NULL;


		// Release all the other addresses.
		while (dwNumAddresses > 1)
		{
			dwNumAddresses--;
			paDP8HostAddresses[dwNumAddresses]->Release();
			paDP8HostAddresses[dwNumAddresses] = NULL;
		} // end while (more addresses)


		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (caller wants address)

	return (DPN_OK);


ERROR_EXIT:


	if (paDP8HostAddresses != NULL)
	{
		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (allocated address array)

	if (pDP8AddressDevice != NULL)
	{
		pDP8AddressDevice->Release();
		pDP8AddressDevice = NULL;
	} // end if (allocated address object)

	if ((*ppDP8PeerHost) != NULL)
	{
		(*ppDP8PeerHost)->Release();
		(*ppDP8PeerHost) = NULL;
	} // end if (have wrapper object)

	return (hr);
}

BOOL PollUntilEventSignalled(PDP_DOWORKLIST pDoWorkList, DWORD dwMaxTime, HANDLE hEvent)
{
	HRESULT	hr = S_OK;
	DWORD	dwWaitResult, dwTotalTime, dwStartTime, dwEndTime, dwCurrentObject;
	BOOL	fRet = TRUE, fRunDoWorkLoop = TRUE;

	// Need to get the start time to determine later if too much time has been
	// spent doing work and waiting
	if(dwMaxTime != INFINITE)
	{
		dwStartTime = GetTickCount();
		dwTotalTime = 0;
	}

	// Wait to see if the event has completed.  May not even require a DoWork call
	dwWaitResult = WaitForSingleObject(hEvent, 0);
	switch(dwWaitResult)
	{
	case WAIT_OBJECT_0:
		OutputDebugString("Event completed without needing to call DoWork!\n");
		fRunDoWorkLoop = FALSE;
		break;
	case WAIT_TIMEOUT:
		break;
	default:
		OutputDebugString("Error occurred while waiting on event handle\n");
		fRet = FALSE;
		goto Exit;
	}

	while(fRunDoWorkLoop)
	{
		// Cycle through peer objects and perform DoWork processing
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumPeers; ++dwCurrentObject)
		{
			// Do work on this object
			pDoWorkList->apDP8Peers[dwCurrentObject]->DoWork(0);

			if(hr != DPN_OK)
			{
				OutputDebugString("Couldn't do DirectPlay work on a peer object!\n");
				fRet = FALSE;
				goto Exit;
			}

			// Wait for the desired result
			dwWaitResult = WaitForSingleObject(hEvent, 0);

			// Event completed.  Exit the loop
			if(dwWaitResult == WAIT_OBJECT_0)
				goto Exit;

			// If there's an upper bound on the amount of time that can be spent waiting for is event
			// See if that amount of time has already passed
			if(dwMaxTime != INFINITE)
			{
				dwEndTime = GetTickCount();
				dwTotalTime = (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

				// If time has expired... bail
				if(dwTotalTime > dwMaxTime)
				{
					OutputDebugString("Event wasn't signalled within allowable time!\n");
					fRet = FALSE;
					goto Exit;
				}
			}
		} // End of loop for doing work over peer objects

	}

Exit:

	return fRet;
}

VOID ClearDoWorkList(DP_DOWORKLIST *pDoWorkList)
{
	if(pDoWorkList->apDP8Peers)
	{
		LocalFree(pDoWorkList->apDP8Peers);
		pDoWorkList->apDP8Peers = NULL;
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\stress\dpstress\csstress.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dpstress.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\repro\multithread\multithread.cpp ===
//-----------------------------------------------------------------------------
// File: dpmemtest.cpp
//
// Desc: Basic executable to measure dynamic DirectPlay memory usage
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define INITGUID
#include <xtl.h>

DWORD WINAPI MyThreadProc(LPVOID *pParam)
{
	SOCKET	LocalSock = (SOCKET) pParam;
	CHAR	LocalBuff[100];

	while(TRUE)
	{
		recv(LocalSock, LocalBuff, sizeof(LocalBuff), 0);
	}

}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: everyone knows what main does...
//-----------------------------------------------------------------------------
void __cdecl main()
{
    SOCKADDR_IN				MySockAddr = { AF_INET };
	WSADATA					WSAData;
	HANDLE					MyThread;
	SOCKET					MySock;
	CHAR					MyBuff[100];

	XnetInitialize(NULL, TRUE);

	WSAStartup(MAKEWORD(2, 2), &WSAData);

	MySock = 0;
	MySock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    MySockAddr.sin_port        = htons(12345);
    MySockAddr.sin_addr.s_addr = INADDR_ANY;
	
    bind(MySock, (const struct sockaddr *) &MySockAddr, sizeof(SOCKADDR_IN));

	MyThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) MyThreadProc, (LPVOID) MySock, 0, NULL);

	while(TRUE)
	{
		recv(MySock, MyBuff, sizeof(MyBuff), 0);
	}

	WSACleanup();

	XnetCleanup();

	while(TRUE)
	{
		// Loop to infinity
	}
	
	__asm int 3;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\footprint\peerfoot\peerfoot.cpp ===
//-----------------------------------------------------------------------------
// File: peerfoot.cpp
//
// Desc: Basic executable to measure static and dynamic DirectPlay memory footprint
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <dplay8.h>
#include <dpaddr.h>

// Define only one of the following
#define NONETWORKING
//#define XNETONLY
//#define DIRECTPLAY_BASE
//#define DIRECTPLAY_PEERBASE
//#define DIRECTPLAY_PEERGROUP
//#define DIRECTPLAY_PEERFULL
//#define DIRECTPLAY_CLIENTBASE
//#define DIRECTPLAY_CLIENTFULL
//#define DIRECTPLAY_SERVERBASE
//#define DIRECTPLAY_SERVERGROUP
//#define DIRECTPLAY_SERVERFULL
//#define DIRECTPLAY_ADDRESS
//#define DIRECTPLAY_ADDRESSIP
//#define DIRECTPLAY_ALLYOURBASE
//#define DIRECTPLAY_ALLYOURGROUP
//#define DIRECTPLAY_ALLYOURFULL


#if defined(NONETWORKING)
#elif defined(XNETONLY)
#define INCLUDE_XNET_IMPORTS
#elif defined(DIRECTPLAY_BASE)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#elif defined(DIRECTPLAY_PEERBASE)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_PEER_BASE
#elif defined(DIRECTPLAY_PEERGROUP)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_PEER_GROUPS
#elif defined(DIRECTPLAY_PEERFULL)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_PEER_FULL
#elif defined(DIRECTPLAY_CLIENTBASE)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_CLIENT_BASE
#elif defined(DIRECTPLAY_CLIENTFULL)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_CLIENT_FULL
#elif defined(DIRECTPLAY_SERVERBASE)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_SERVER_BASE
#elif defined(DIRECTPLAY_SERVERGROUP)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_SERVER_GROUPS
#elif defined(DIRECTPLAY_SERVERFULL)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_SERVER_FULL
#elif defined(DIRECTPLAY_ADDRESS)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_ADDRESS_FULL
#elif defined(DIRECTPLAY_ADDRESSIP)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_ADDRESSIP_FULL
#elif defined(DIRECTPLAY_ALLYOURBASE)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_PEER_BASE
#define INCLUDE_DPLAY_CLIENT_BASE
#define INCLUDE_DPLAY_SERVER_BASE
#define INCLUDE_DPLAY_ADDRESS_FULL
#define INCLUDE_DPLAY_ADDRESSIP_FULL
#elif defined(DIRECTPLAY_ALLYOURGROUP)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_PEER_GROUPS
#define INCLUDE_DPLAY_CLIENT_BASE
#define INCLUDE_DPLAY_SERVER_GROUPS
#define INCLUDE_DPLAY_ADDRESS_FULL
#define INCLUDE_DPLAY_ADDRESSIP_FULL
#elif defined(DIRECTPLAY_ALLYOURFULL)
#define INCLUDE_XNET_IMPORTS
#define INCLUDE_DPLAY_GENERAL_IMPORTS
#define INCLUDE_DPLAY_PEER_FULL
#define INCLUDE_DPLAY_CLIENT_FULL
#define INCLUDE_DPLAY_SERVER_FULL
#define INCLUDE_DPLAY_ADDRESS_FULL
#define INCLUDE_DPLAY_ADDRESSIP_FULL
#else // default to NONETWORKING
#endif

//-----------------------------------------------------------------------------
// Name: main()
// Desc: everyone knows what main does...
//-----------------------------------------------------------------------------
void __cdecl main()
{
	HRESULT				hr = DPN_OK;
	INT					n = 0;

#ifdef INCLUDE_XNET_IMPORTS
	XnetInitialize(NULL, TRUE);
#endif

#ifdef INCLUDE_DPLAY_GENERAL_IMPORTS
	hr = DPlayInitialize(1024 * 200);
	if(hr != DPN_OK)
		goto Exit;
#endif

#if (defined(INCLUDE_DPLAY_PEER_BASE) || defined(INCLUDE_DPLAY_PEER_GROUPS) || defined(INCLUDE_DPLAY_PEER_FULL))
	IDirectPlay8Peer *pPeer = NULL;
	hr = DirectPlay8Create(IID_IDirectPlay8Peer, (LPVOID *) &pPeer, NULL);
	if(hr != DPN_OK)
		goto Exit;

	// These functions are considered essential since almost every DirectPlay peer app will use them.
	IDirectPlay8Peer_AddRef(pPeer);
	IDirectPlay8Peer_Release(pPeer);
	IDirectPlay8Peer_Initialize(pPeer, NULL, NULL, 0);
	IDirectPlay8Peer_Connect(pPeer, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_SendTo(pPeer, 0, NULL, 0, 0, NULL, NULL, 0);
	IDirectPlay8Peer_GetSendQueueInfo(pPeer, 0, NULL, NULL, 0);
	IDirectPlay8Peer_Host(pPeer, NULL, NULL, 0, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_GetApplicationDesc(pPeer, NULL, NULL, 0);
	IDirectPlay8Peer_SetApplicationDesc(pPeer, NULL, 0);
	IDirectPlay8Peer_SetPeerInfo(pPeer, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_GetPeerInfo(pPeer, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_Close(pPeer, 0);
	IDirectPlay8Peer_EnumHosts(pPeer, NULL, NULL, NULL, NULL, 0, 0, 0, 0, NULL, NULL, 0);
	IDirectPlay8Peer_DestroyPeer(pPeer, 0, NULL, 0, 0);
	IDirectPlay8Peer_ReturnBuffer(pPeer, NULL, 0);
	IDirectPlay8Peer_TerminateSession(pPeer, NULL, 0, 0);
	IDirectPlay8Peer_DoWork(pPeer, 0);

	// These functions are only included if groups are necessary
#if (defined(INCLUDE_DPLAY_PEER_GROUPS) || defined(INCLUDE_DPLAY_PEER_FULL))
	IDirectPlay8Peer_CreateGroup(pPeer, NULL, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_DestroyGroup(pPeer, 0, NULL, NULL, 0);
	IDirectPlay8Peer_AddPlayerToGroup(pPeer, 0, 0, NULL, NULL, 0);
	IDirectPlay8Peer_RemovePlayerFromGroup(pPeer, 0, 0, NULL, NULL, 0);
	IDirectPlay8Peer_SetGroupInfo(pPeer, 0, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_GetGroupInfo(pPeer, 0, NULL, NULL, 0);
	IDirectPlay8Peer_EnumPlayersAndGroups(pPeer, NULL, NULL, 0);
	IDirectPlay8Peer_EnumGroupMembers(pPeer, 0, NULL, NULL, 0);
	IDirectPlay8Peer_GetGroupContext(pPeer, 0, NULL, 0);
#endif
	// These functions are considered non-essential since many DirectPlay apps can be written not to use them.
#if defined(INCLUDE_DPLAY_PEER_FULL)
	IDirectPlay8Peer_EnumServiceProviders(pPeer, NULL, NULL, NULL, NULL, NULL, 0);
	IDirectPlay8Peer_CancelAsyncOperation(pPeer, NULL, 0);
	IDirectPlay8Peer_GetPeerAddress(pPeer, 0, NULL, 0);
	IDirectPlay8Peer_GetLocalHostAddresses(pPeer, NULL, NULL, 0);
	IDirectPlay8Peer_GetPlayerContext(pPeer, 0, NULL, 0);
	IDirectPlay8Peer_GetCaps(pPeer, NULL, 0);
	IDirectPlay8Peer_SetCaps(pPeer, NULL, 0);
	IDirectPlay8Peer_SetSPCaps(pPeer, NULL, NULL, 0);
	IDirectPlay8Peer_GetSPCaps(pPeer, NULL, NULL, 0);
	IDirectPlay8Peer_GetConnectionInfo(pPeer, 0, NULL,0);
	IDirectPlay8Peer_RegisterLobby(pPeer, NULL, NULL, 0);
#endif
#endif

#if (defined(INCLUDE_DPLAY_CLIENT_BASE) || defined(INCLUDE_DPLAY_CLIENT_GROUPS) || defined(INCLUDE_DPLAY_CLIENT_FULL))
	IDirectPlay8Client *pClient = NULL;
	hr = DirectPlay8Create(IID_IDirectPlay8Client, (LPVOID *) &pClient, NULL);
	if(hr != DPN_OK)
		goto Exit;

	// These functions are considered essential since almost every DirectPlay peer app will use them.
	IDirectPlay8Client_AddRef(pClient);
	IDirectPlay8Client_Release(pClient);
	IDirectPlay8Client_Initialize(pClient, NULL, NULL, 0);
	IDirectPlay8Client_EnumHosts(pClient, NULL, NULL, NULL, NULL, 0, 0, 0, 0, NULL, NULL, 0);
	IDirectPlay8Client_Connect(pClient, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, 0);
	IDirectPlay8Client_Send(pClient, NULL, 0, 0, NULL, NULL, 0);
	IDirectPlay8Client_GetSendQueueInfo(pClient, NULL, NULL, 0);
	IDirectPlay8Client_GetApplicationDesc(pClient, NULL, NULL, 0);
	IDirectPlay8Client_SetClientInfo(pClient, NULL, NULL, NULL, 0);
	IDirectPlay8Client_GetServerInfo(pClient, NULL, NULL, 0);
	IDirectPlay8Client_Close(pClient, 0);
	IDirectPlay8Client_ReturnBuffer(pClient, NULL, 0);
	IDirectPlay8Client_DoWork(pClient, 0);

	// These functions are considered non-essential since many DirectPlay apps can be written not to use them.
#if defined(INCLUDE_DPLAY_CLIENT_FULL)
	IDirectPlay8Client_EnumServiceProviders(pClient, NULL, NULL, NULL, NULL, NULL, 0);
	IDirectPlay8Client_CancelAsyncOperation(pClient, NULL, 0);
	IDirectPlay8Client_GetServerAddress(pClient, NULL, 0);
	IDirectPlay8Client_GetCaps(pClient, NULL, 0);
	IDirectPlay8Client_SetCaps(pClient, NULL, 0);
	IDirectPlay8Client_SetSPCaps(pClient, NULL, NULL, 0);
	IDirectPlay8Client_GetSPCaps(pClient, NULL, NULL, 0);
	IDirectPlay8Client_GetConnectionInfo(pClient, NULL, 0);
	IDirectPlay8Client_RegisterLobby(pClient, NULL, NULL, 0);
#endif
#endif

#if (defined(INCLUDE_DPLAY_SERVER_BASE) || defined(INCLUDE_DPLAY_SERVER_GROUPS) || defined(INCLUDE_DPLAY_SERVER_FULL))
	IDirectPlay8Server *pServer = NULL;
	hr = DirectPlay8Create(IID_IDirectPlay8Server, (LPVOID *) &pServer, NULL);
	if(hr != DPN_OK)
		goto Exit;

	// These functions are considered essential since almost every DirectPlay peer app will use them.
	IDirectPlay8Server_AddRef(pServer);
	IDirectPlay8Server_Release(pServer);
	IDirectPlay8Server_Initialize(pServer, NULL, NULL, 0);
	IDirectPlay8Server_GetSendQueueInfo(pServer, 0, NULL, NULL, 0);
	IDirectPlay8Server_GetApplicationDesc(pServer, NULL, NULL, 0);
	IDirectPlay8Server_SetServerInfo(pServer, NULL, NULL, NULL, 0);
	IDirectPlay8Server_GetClientInfo(pServer, NULL, NULL, NULL, 0);
	IDirectPlay8Server_SetApplicationDesc(pServer, NULL, 0);
	IDirectPlay8Server_Host(pServer, NULL, NULL, 0, NULL, NULL, NULL, 0);
	IDirectPlay8Server_SendTo(pServer, 0, NULL, 0, 0, NULL, NULL, 0);
	IDirectPlay8Server_Close(pServer, 0);
	IDirectPlay8Server_DestroyClient(pServer, 0, NULL, 0, 0);
	IDirectPlay8Server_ReturnBuffer(pServer, NULL, 0);
	IDirectPlay8Server_DoWork(pServer, NULL);

		// These functions are only included if groups are necessary
#if (defined(INCLUDE_DPLAY_SERVER_GROUPS) || defined(INCLUDE_DPLAY_SERVER_FULL))
	IDirectPlay8Server_CreateGroup(pServer, NULL, NULL, NULL, NULL, 0);
	IDirectPlay8Server_DestroyGroup(pServer, 0, NULL, NULL, 0);
	IDirectPlay8Server_AddPlayerToGroup(pServer, 0, 0, NULL, NULL, 0);
	IDirectPlay8Server_RemovePlayerFromGroup(pServer, 0, 0, NULL, NULL, 0);
	IDirectPlay8Server_SetGroupInfo(pServer, 0, NULL, NULL, NULL, 0);
	IDirectPlay8Server_GetGroupInfo(pServer, 0, NULL, NULL, 0);
	IDirectPlay8Server_EnumPlayersAndGroups(pServer, NULL, NULL, 0);
	IDirectPlay8Server_EnumGroupMembers(pServer, 0, NULL, NULL, 0);
	IDirectPlay8Server_GetGroupContext(pServer, 0, NULL, 0);
#endif

		// These functions are considered non-essential since many DirectPlay apps can be written not to use them.
#if defined(INCLUDE_DPLAY_SERVER_FULL)
	IDirectPlay8Server_GetPlayerContext(pServer, 0, NULL, 0);
	IDirectPlay8Server_EnumServiceProviders(pServer, NULL, NULL, NULL, NULL, NULL, 0);
	IDirectPlay8Server_CancelAsyncOperation(pServer, NULL, 0);
	IDirectPlay8Server_GetClientAddress(pServer, 0, NULL, 0);
	IDirectPlay8Server_GetLocalHostAddresses(pServer, NULL, NULL, 0);
	IDirectPlay8Server_GetCaps(pServer, NULL, 0);
	IDirectPlay8Server_SetCaps(pServer, NULL, 0);
	IDirectPlay8Server_SetSPCaps(pServer, NULL, NULL, 0);
	IDirectPlay8Server_GetSPCaps(pServer, NULL, NULL, 0);
	IDirectPlay8Server_GetConnectionInfo(pServer, 0, NULL, 0);
	IDirectPlay8Server_RegisterLobby,(pServer, NULL, NULL, 0);
#endif
#endif

#if (defined(INCLUDE_DPLAY_ADDRESS_BASE) || defined(INCLUDE_DPLAY_ADDRESS_FULL) || defined(INCLUDE_DPLAY_ADDRESSIP_FULL))
	IDirectPlay8Address *pAddress = NULL;
	hr = DirectPlay8AddressCreate(NULL, NULL, NULL);

	if(hr != DPN_OK)
		goto Exit;
	
	IDirectPlay8Address_AddRef(pAddress);
	IDirectPlay8Address_Release(pAddress);

#if defined(INCLUDE_DPLAY_ADDRESS_FULL)
	// IDirectPlay8Address methods
	IDirectPlay8Address_BuildFromURLW(pAddress, NULL);
	IDirectPlay8Address_BuildFromURLA(pAddress, NULL);
	IDirectPlay8Address_Duplicate(pAddress, NULL);
	IDirectPlay8Address_SetEqual(pAddress, NULL);
	IDirectPlay8Address_IsEqual(pAddress, NULL);
	IDirectPlay8Address_Clear(pAddress);
	IDirectPlay8Address_GetURLW(pAddress, NULL, NULL);
	IDirectPlay8Address_GetURLA(pAddress, NULL, NULL);
	IDirectPlay8Address_GetSP(pAddress, NULL);
	IDirectPlay8Address_GetUserData(pAddress, NULL, NULL);
	IDirectPlay8Address_SetSP(pAddress, NULL);
	IDirectPlay8Address_SetUserData(pAddress, NULL, 0);
	IDirectPlay8Address_GetNumComponents(pAddress, NULL);
	IDirectPlay8Address_GetComponentByName(pAddress, NULL, NULL, NULL, NULL);
	IDirectPlay8Address_GetComponentByIndex(pAddress, 0, NULL, NULL, NULL, NULL, NULL);
	IDirectPlay8Address_AddComponent(pAddress, NULL, NULL, 0, 0);
	IDirectPlay8Address_GetDevice(pAddress, NULL);
	IDirectPlay8Address_SetDevice(pAddress, NULL);
#endif

#if defined(INCLUDE_DPLAY_ADDRESSIP_FULL)
	// IDirectPlay8AddressIP methods
	IDirectPlay8Address_BuildFromSockAddr(pAddress, NULL);
	IDirectPlay8Address_BuildAddress(pAddress, NULL, 0);
	IDirectPlay8Address_BuildLocalAddress(pAddress, NULL, 0);
	IDirectPlay8Address_GetSockAddress(pAddress, NULL, NULL);
	IDirectPlay8Address_GetLocalAddress(pAddress, NULL, NULL);
	IDirectPlay8Address_GetAddress(pAddress, NULL, NULL, NULL);
#endif
#endif

	while(TRUE)
	{
		// Loop to infinity
	}
	
	goto Exit;

Exit:

	__asm int 3;

#if (defined(INCLUDE_DPLAY_PEER_BASE) || defined(INCLUDE_DPLAY_PEER_GROUPS) || defined(INCLUDE_DPLAY_PEER_FULL))
	pPeer->Release();
	pPeer = NULL;
#endif

#if (defined(INCLUDE_DPLAY_CLIENT_BASE) || defined(INCLUDE_DPLAY_CLIENT_GROUPS) || defined(INCLUDE_DPLAY_CLIENT_FULL))
	pClient->Release();
	pClient = NULL;
#endif

#if (defined(INCLUDE_DPLAY_SERVER_BASE) || defined(INCLUDE_DPLAY_SERVER_GROUPS) || defined(INCLUDE_DPLAY_SERVER_FULL))
	pServer->Release();
	pServer = NULL;
#endif

#ifdef INCLUDE_DPLAY_GENERAL_IMPORTS
	DPlayCleanup();
#endif

#ifdef INCLUDE_XNET_IMPORTS
	XnetCleanup();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\repro\peeraddressclose\peeraddressclose.cpp ===
//-----------------------------------------------------------------------------
// File: dpmemtest.cpp
//
// Desc: Basic executable to measure dynamic DirectPlay memory usage
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <dplay8.h>
#include <dpaddr.h>

GUID g_guidApp = { 0x2ae835d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 } };
BOOL g_fThreadRun = FALSE;

#define LOCALADDRESS L"157.56.11.67"
#define HOSTPORT 2350

#define PEER_TYPE_HOST 1
#define PEER_TYPE_JOIN 2

typedef struct _APP_DP_PEER
{
	LPDIRECTPLAY8PEER pDP;
	DWORD dwPeerType;
	DPNID dpnidLocalPlayer;
	DPNID dpnidSecondPlayer;
	LONG lNumPlayers;
	HANDLE hEvent1;
	HANDLE hEvent2;
	HANDLE hEvent3;
	HANDLE hEvent4;
} APP_DP_PEER, *LPAPP_DP_PEER;

LPAPP_DP_PEER g_pDPPeer1;
LPAPP_DP_PEER g_pDPPeer2;

#define GAME_MSGID_WAVE        1

struct GAMEMSG_GENERIC
{
    DWORD dwType;
    CHAR blah[32];
};

BOOL GlobalInit(BOOL fThreadEnabled);
BOOL InitDPlayPeer(LPAPP_DP_PEER pDirectPlay8Peer);
BOOL CloseDPlayPeer(LPAPP_DP_PEER pDirectPlay8Peer);
BOOL ReleaseDPlayPeer(LPAPP_DP_PEER pDirectPlay8Peer);
BOOL HostGame(LPAPP_DP_PEER pDirectPlay8Peer);
BOOL JoinGame(LPAPP_DP_PEER pDirectPlay8Peer);
BOOL SendMessage(LPAPP_DP_PEER pDirectPlay8Peer);
DWORD WINAPI WorkerThread( void *pParam );
VOID WorkForAwhile( HANDLE hEvent, DWORD dwIterations );

HRESULT DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );

void __cdecl main()
{
    LPDIRECTPLAY8ADDRESS pPeerAddress;

    __asm int 3;

    if(GlobalInit(FALSE) == FALSE)
		OutputDebugString("GlobalInit failure\n");
	else
		OutputDebugString("GlobalInit success\n");

/*
    if (InitDPlayPeer(g_pDPPeer1) == FALSE)
		OutputDebugString("InitDPlayPeer failure\n");
	else
		OutputDebugString("InitDPlayPeer success\n");

    if (FAILED(g_pDPPeer1->pDP->GetPeerAddress(1, &pPeerAddress, 0)))
		OutputDebugString("GetPeerAddress failure\n");
	else
		OutputDebugString("GetPeerAddress success\n");

    if (HostGame(g_pDPPeer1) == FALSE)
		OutputDebugString("HostGame failure\n");
	else
		OutputDebugString("HostGame success\n");

    if (FAILED(g_pDPPeer1->pDP->GetPeerAddress(222, &pPeerAddress, 0)))
		OutputDebugString("GetPeerAddress failure\n");
	else
		OutputDebugString("GetPeerAddress success\n");

	OutputDebugString("WorkForAwhile\n");
    WorkForAwhile(g_pDPPeer1->hEvent1, 0);
	OutputDebugString("WorkForAwhile\n");
    WorkForAwhile(NULL, 100000);

    if (FAILED(g_pDPPeer1->pDP->GetPeerAddress(g_pDPPeer1->dpnidLocalPlayer, &pPeerAddress, 0)))
		OutputDebugString("GetPeerAddress failure\n");
	else
		OutputDebugString("GetPeerAddress success\n");

    if (CloseDPlayPeer(g_pDPPeer1) == FALSE)
		OutputDebugString("CloseDPlayPeer failure\n");
	else
		OutputDebugString("CloseDPlayPeer success\n");
*/

    if (InitDPlayPeer(g_pDPPeer1) == FALSE)
		OutputDebugString("InitDPlayPeer failure\n");
	else
		OutputDebugString("InitDPlayPeer success\n");

    if (InitDPlayPeer(g_pDPPeer2) == FALSE)
		OutputDebugString("InitDPlayPeer failure\n");
	else
		OutputDebugString("InitDPlayPeer success\n");

    if (HostGame(g_pDPPeer2) == FALSE)
		OutputDebugString("HostGame failure\n");
	else
		OutputDebugString("HostGame success\n");

	if (JoinGame(g_pDPPeer1) == FALSE)
		OutputDebugString("JoinGame failure\n");
	else
		OutputDebugString("JoinGame success\n");

 	OutputDebugString("WorkForAwhile\n");
    WorkForAwhile(g_pDPPeer1->hEvent2, 0);
 	OutputDebugString("WorkForAwhile\n");
    WorkForAwhile(g_pDPPeer2->hEvent3, 0);

// NOTE HERE:  Should I use g_pDPPeer1->dpnidSecondPlayer or g_pDPPeer2->dpnidLocalPlayer
/*
    if (FAILED(g_pDPPeer1->pDP->GetPeerAddress(g_pDPPeer1->dpnidSecondPlayer, &pPeerAddress, 0)))
		OutputDebugString("GetPeerAddress failure\n");
	else
		OutputDebugString("GetPeerAddress success\n");
*/

    if (FAILED(g_pDPPeer2->pDP->GetPeerAddress(g_pDPPeer2->dpnidSecondPlayer, &pPeerAddress, 0)))
		OutputDebugString("GetPeerAddress failure\n");
	else
		OutputDebugString("GetPeerAddress success\n");

    if (CloseDPlayPeer(g_pDPPeer1) == FALSE)
		OutputDebugString("CloseDPlayPeer failure\n");
	else
		OutputDebugString("CloseDPlayPeer success\n");

    if (CloseDPlayPeer(g_pDPPeer2) == FALSE)
		OutputDebugString("CloseDPlayPeer failure\n");
	else
		OutputDebugString("CloseDPlayPeer success\n");

    if (ReleaseDPlayPeer(g_pDPPeer1) == FALSE)
		OutputDebugString("ReleaseDPlayPeer failure\n");
	else
		OutputDebugString("ReleaseDPlayPeer success\n");

    if (ReleaseDPlayPeer(g_pDPPeer2) == FALSE)
		OutputDebugString("ReleaseDPlayPeer failure\n");
	else
		OutputDebugString("ReleaseDPlayPeer success\n");

    HRESULT hr = DPlayCleanup();

    if (FAILED(hr))
        __asm int 3;

    __asm int 3;
}

BOOL GlobalInit(BOOL fThreadEnabled)
{
    DWORD dwThreadID = 0;
    HANDLE hThread = NULL;

    if (XnetInitialize(NULL, TRUE) != NO_ERROR)
    {
        __asm int 3;
        return FALSE;
    }

    if (FAILED(DPlayInitialize(1024 * 200)))
    {
        __asm int 3;
        return FALSE;
    }

    if (fThreadEnabled)
        hThread = CreateThread( NULL, 0, WorkerThread, 0, 0, &dwThreadID );

    g_pDPPeer1 = new APP_DP_PEER;
    g_pDPPeer2 = new APP_DP_PEER;

    g_pDPPeer1->pDP = NULL;
    g_pDPPeer2->pDP = NULL;

    return TRUE;
}

BOOL InitDPlayPeer(LPAPP_DP_PEER pDirectPlay8Peer)
{
    HRESULT hr;

    pDirectPlay8Peer->dwPeerType = 0;
    pDirectPlay8Peer->dpnidLocalPlayer = -1;
    pDirectPlay8Peer->dpnidSecondPlayer = -1;
    pDirectPlay8Peer->lNumPlayers = 0;
    pDirectPlay8Peer->hEvent1 = NULL;
    pDirectPlay8Peer->hEvent2 = NULL;
    pDirectPlay8Peer->hEvent3 = NULL;
    pDirectPlay8Peer->hEvent4 = NULL;

    pDirectPlay8Peer->hEvent1 = CreateEvent(NULL, TRUE, FALSE, NULL);
    pDirectPlay8Peer->hEvent2 = CreateEvent(NULL, TRUE, FALSE, NULL);
    pDirectPlay8Peer->hEvent3 = CreateEvent(NULL, TRUE, FALSE, NULL);
    pDirectPlay8Peer->hEvent4 = CreateEvent(NULL, TRUE, FALSE, NULL);

    ResetEvent(pDirectPlay8Peer->hEvent1);
    ResetEvent(pDirectPlay8Peer->hEvent2);
    ResetEvent(pDirectPlay8Peer->hEvent3);
    ResetEvent(pDirectPlay8Peer->hEvent4);

    if (pDirectPlay8Peer->pDP == NULL)
    {
        hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) &(pDirectPlay8Peer->pDP), NULL);
        if( FAILED(hr) )
        {
            __asm int 3;
            return FALSE;
        }
    }

    hr = pDirectPlay8Peer->pDP->Initialize( (void*)pDirectPlay8Peer, DirectPlayMessageHandler, 0 );
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    return TRUE;
}

BOOL CloseDPlayPeer(LPAPP_DP_PEER pDirectPlay8Peer)
{
    HRESULT hr;

    hr = pDirectPlay8Peer->pDP->Close(0);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    CloseHandle(pDirectPlay8Peer->hEvent1);
    CloseHandle(pDirectPlay8Peer->hEvent2);
    CloseHandle(pDirectPlay8Peer->hEvent3);
    CloseHandle(pDirectPlay8Peer->hEvent4);

    return TRUE;
}


BOOL ReleaseDPlayPeer(LPAPP_DP_PEER pDirectPlay8Peer)
{
    LPDIRECTPLAY8PEER pTempPeer = NULL;
    HRESULT hr = S_OK;

    pTempPeer = pDirectPlay8Peer->pDP;
    pDirectPlay8Peer->pDP = NULL;

    SleepEx(10, FALSE);

    hr = pTempPeer->Release();
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    return TRUE;
}


BOOL HostGame(LPAPP_DP_PEER pDirectPlay8Peer)
{
    HRESULT hr;
    DPN_APPLICATION_DESC dnAppDesc;
    LPDIRECTPLAY8ADDRESS pDeviceAddress;

    pDirectPlay8Peer->dwPeerType = PEER_TYPE_HOST;

    // Create a device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pDeviceAddress, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    pDeviceAddress->BuildAddress(LOCALADDRESS, HOSTPORT);

    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = g_guidApp;
    dnAppDesc.pwszSessionName = L"MyGamexbox";
    dnAppDesc.dwMaxPlayers    = 5;
    dnAppDesc.dwFlags         = 0;

    hr = pDirectPlay8Peer->pDP->Host( &dnAppDesc, &pDeviceAddress, 1, NULL, NULL, NULL, 0 );
    if( FAILED( hr ) )
    {
        __asm int 3;
        return FALSE;
    }

    pDeviceAddress->Release();

    return TRUE;
}

BOOL JoinGame(LPAPP_DP_PEER pDirectPlay8Peer)
{
    HRESULT hr;
    DPN_APPLICATION_DESC dnAppDesc;
//    DPN_PLAYER_INFO dpPlayerInfo;
    DPNHANDLE hConnectAsyncOp;
    LPDIRECTPLAY8ADDRESS pDeviceAddress;
    LPDIRECTPLAY8ADDRESS pHostAddress;

    pDirectPlay8Peer->dwPeerType = PEER_TYPE_JOIN;

    // Create a device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pDeviceAddress, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    // Create a host address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pHostAddress, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    pHostAddress->BuildAddress(LOCALADDRESS, HOSTPORT);

    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = g_guidApp;

/*
    ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = L"MarkXbox";

    hr = pDirectPlay8Peer->pDP->SetPeerInfo( &dpPlayerInfo, NULL, &hConnectAsyncOp, 0 );
    if( FAILED( hr ) )
    {
        __asm int 3;
        return FALSE;
    }
*/

    hr = pDirectPlay8Peer->pDP->Connect( &dnAppDesc, pHostAddress, pDeviceAddress, NULL, NULL, NULL, 0, NULL, NULL, &hConnectAsyncOp, 0 );
    if( hr != E_PENDING && FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    pHostAddress->Release();
    pDeviceAddress->Release();

    return TRUE;
}

BOOL SendMessage(LPAPP_DP_PEER pDirectPlay8Peer)
{
    GAMEMSG_GENERIC msgWave;
    DPN_BUFFER_DESC bufferDesc;
    DPNHANDLE hAsync;

    msgWave.dwType = GAME_MSGID_WAVE;
    bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
    bufferDesc.pBufferData  = (BYTE*) &msgWave;

    pDirectPlay8Peer->pDP->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1, 0, NULL, &hAsync, DPNSEND_NOLOOPBACK );

    return TRUE;
}

DWORD WINAPI WorkerThread( void *pParam )
{
    while (1)
    {
        if (g_fThreadRun)
        {
            g_pDPPeer1->pDP->DoWork(0);
            g_pDPPeer2->pDP->DoWork(0);
            SleepEx(10, FALSE);
        }
    }

    return 0;
}


VOID WorkForAwhile( HANDLE hEvent, DWORD dwIterations )
{

	if( WaitForSingleObjectEx( hEvent, 0, TRUE ) == WAIT_OBJECT_0 )
		return;

	if (hEvent != NULL)
	{
		while (1)
		{
			
			if (g_pDPPeer1->pDP != NULL)
			{
				g_pDPPeer1->pDP->DoWork(0);

				switch ( WaitForSingleObjectEx( hEvent, 0, TRUE ) )
				{
				case WAIT_OBJECT_0:
					{
						goto Exit;
						break;
					}
					
				case WAIT_TIMEOUT:
					{
						break;
					}
				}
			}
			
			if (g_pDPPeer2->pDP != NULL)
			{
				g_pDPPeer2->pDP->DoWork(0);

				switch ( WaitForSingleObjectEx( hEvent, 0, TRUE ) )
				{
				case WAIT_OBJECT_0:
					{
						goto Exit;
						break;
					}
					
				case WAIT_TIMEOUT:
					{
						break;
					}
				}
			}
		}
	}

	if (dwIterations == 0)
	{
        HRESULT hr = S_OK;

		while (hr == S_OK)
        {
            if (g_pDPPeer1->pDP != NULL)
                hr = g_pDPPeer1->pDP->DoWork(0);

            if (g_pDPPeer2->pDP != NULL)
                 if (g_pDPPeer2->pDP->DoWork(0) == S_OK)
                     hr = S_OK;
        }
		goto Exit;
	}

	
	for (DWORD i=0; i<dwIterations; i+=1)
	{
        if (g_pDPPeer1->pDP != NULL)
    		g_pDPPeer1->pDP->DoWork(0);

        if (g_pDPPeer2->pDP != NULL)
	    	g_pDPPeer2->pDP->DoWork(0);
	}

Exit:

    return;
}

HRESULT DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer )
{
    LPAPP_DP_PEER pDirectPlay8Peer = (LPAPP_DP_PEER) pvUserContext;
    HRESULT hr = S_OK;

	OutputDebugString("DirectPlayMessageHandler\n");

    switch( dwMessageId )
    {
        case DPN_MSGID_CREATE_PLAYER:
        {
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            if( pDirectPlay8Peer->lNumPlayers == 0)
            {
                pDirectPlay8Peer->dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;
                SetEvent(pDirectPlay8Peer->hEvent1);
            }
            else
            {
                pDirectPlay8Peer->dpnidSecondPlayer = pCreatePlayerMsg->dpnidPlayer;
                SetEvent(pDirectPlay8Peer->hEvent3);
            }

            pDirectPlay8Peer->lNumPlayers += 1;

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;

            pDirectPlay8Peer->lNumPlayers -= 1;

            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            PDPNMSG_RECEIVE pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;

            break;
        }

        case DPN_MSGID_INDICATE_CONNECT:
        {
            SetEvent(pDirectPlay8Peer->hEvent2);

            break;
        }

        case DPN_MSGID_CONNECT_COMPLETE:
        {
            PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE)pMsgBuffer;

            hr = pConnectCompleteMsg->hResultCode;

            SetEvent(pDirectPlay8Peer->hEvent2);

            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

            break;
        }

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\footprint\dpmemtest\dpmemtest.cpp ===
//-----------------------------------------------------------------------------
// File: dpmemtest.cpp
//
// Desc: Basic executable to measure dynamic DirectPlay memory usage
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define INITGUID
#include <xtl.h>
#include <dplay8.h>
#include <dpaddr.h>
#include <stdio.h>
#include <xbdm.h>

#define USE_PERF_COUNTERS

// {ECD3B292-B7B6-447f-AA2A-D2F6ABF34CB1}
DEFINE_GUID(GUID_BASEAPP,
0xecd3b292, 0xb7b6, 0x447f, 0xaa, 0x2a, 0xd2, 0xf6, 0xab, 0xf3, 0x4c, 0xb1);

// Define only one of the following
#define CALL_PEER_FUNCTIONS
//#define CALL_CLIENT_FUNCTIONS
//#define CALL_SERVER_FUNCTIONS
//#define CALL_ADDRESS_FUNCTIONS

typedef enum _MEMORY_STAT_TYPE
{
	MIN_STAT_TYPE = 0,
	FREE_PAGES = 0,
	CACHE_PAGES,
	VIRT_PAGES,
	POOL_PAGES,
	STACK_PAGES,
	IMAGE_PAGES,
	MAX_STAT_TYPE
} MEMORY_STAT_TYPE;

HANDLE g_MemStatHandles[MAX_STAT_TYPE];
LPCSTR g_MemStatStrings[] =
{
	"Free Pages",
	"Cache Pages",
	"Virtual Pages",
	"Pool Pages",
	"Stack Pages",
	"Image Pages"
};



//==================================================================================
// TRACE
//----------------------------------------------------------------------------------
//
// Description: Logs a string with variable parameters to the debugger
//
// Arguments:
//	LPCSTR		szFormat		Formatting string for debugger output
//
// Returns: nothing
//==================================================================================
void WINAPI TRACE(LPCSTR szFormat, ...) {
	CHAR szBuffer[1024] = "";
	va_list pArgs; 
	va_start(pArgs, szFormat);
	
	vsprintf(szBuffer, szFormat, pArgs);
	
	va_end(pArgs);
	OutputDebugString(szBuffer);
}

//==================================================================================
// InitMemStatHandles
//----------------------------------------------------------------------------------
//
// Description: Looks up all the memory stat handles that we need for perf counter APIs
//
// Arguments: none
//
// Returns: nothing
//==================================================================================
void InitMemStatHandles()
{
	for(INT i = MIN_STAT_TYPE;i < MAX_STAT_TYPE;++i)
	{
		g_MemStatHandles[i] = NULL;
		DmOpenPerformanceCounter(g_MemStatStrings[i], &(g_MemStatHandles[i]));
	}
}

//==================================================================================
// CloseMemStatHandles
//----------------------------------------------------------------------------------
//
// Description: Closes all the memory stat handles that we needed for perf counter APIs
//
// Arguments: none
//
// Returns: nothing
//==================================================================================
void CloseMemStatHandles()
{
	for(INT i = MIN_STAT_TYPE;i < MAX_STAT_TYPE;++i)
	{
		DmClosePerformanceCounter(g_MemStatHandles[i]);
		g_MemStatHandles[i] = NULL;
	}
}

//==================================================================================
// LogMemoryStatus
//----------------------------------------------------------------------------------
//
// Description: Logs the current memory status to the debugger
//
// Arguments: none
//
// Returns: nothing
//==================================================================================
void LogMemoryStatus()
{
#ifdef USE_PERF_COUNTERS
	DM_COUNTDATA		CountData;
	HANDLE				hCounter = NULL;

	TRACE("Memory status:\n");
	for(INT i = MIN_STAT_TYPE;i < MAX_STAT_TYPE;++i)
	{
		DmQueryPerformanceCounter(g_MemStatHandles[i], DMCOUNT_VALUE | DMCOUNT_AVERAGE, &CountData);

		TRACE("    %s: %u\n", g_MemStatStrings[i], CountData.CountValue.QuadPart);

		hCounter = NULL;
	}
#elif
	MEMORYSTATUS MemoryStatus;

	memset(&MemoryStatus, 0, sizeof(MEMORYSTATUS));
	MemoryStatus.dwLength = sizeof(MEMORYSTATUS);

	GlobalMemoryStatus (&MemoryStatus);

	TRACE("Memory status:\n");
	TRACE("    Available physical: %u\n", MemoryStatus.dwAvailPhys);

#endif
}

//==================================================================================
// DirectPlayMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT DirectPlayMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;

	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
		case DPN_MSGID_CREATE_PLAYER:
		case DPN_MSGID_DESTROY_PLAYER:
		case DPN_MSGID_INDICATE_CONNECT:
			break;
		default:
			break;
	}

	return (hr);
}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: everyone knows what main does...
//-----------------------------------------------------------------------------
void __cdecl main()
{
	DPN_APPLICATION_DESC	dpnAppDesc;
	PDIRECTPLAY8ADDRESS		pDeviceAddress = NULL, pHostAddress = NULL;
	DPN_BUFFER_DESC			dpnBufferDesc;
	DPNHANDLE				dpnHandle = NULL;
	WCHAR					szHostname[] = L"xboxnetsync1";
	BYTE					DataBuffer[100];
	HRESULT					hr = DPN_OK;
	INT						n = 0;

	InitMemStatHandles();

	memset(DataBuffer, 0, 100);
	memset(&dpnBufferDesc, 0, sizeof(DPN_BUFFER_DESC));
	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));

	TRACE("\nTest started...\n");
	LogMemoryStatus();

	XnetInitialize(NULL, TRUE);

	TRACE("\nXnet initialized...\n");
	LogMemoryStatus();

	hr = DPlayInitialize(1024 * 200);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nDPlay initialized...\n");
	LogMemoryStatus();

	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (VOID **) &pDeviceAddress, NULL);
	if(hr != DPN_OK)
		goto Exit;

	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (VOID **) &pHostAddress, NULL);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nDevice and host addresses created...\n");
	LogMemoryStatus();

#ifdef CALL_PEER_FUNCTIONS
	IDirectPlay8Peer *pPeer = NULL;

	hr = DirectPlay8Create(IID_IDirectPlay8Peer, (LPVOID *) &pPeer, NULL);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nPeer object created...\n");
	LogMemoryStatus();

	hr = pPeer->Initialize(NULL, DirectPlayMessageHandler, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nInitialized peer object...\n");
	LogMemoryStatus();

	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
	
	hr = pPeer->EnumHosts(&dpnAppDesc, NULL, pDeviceAddress, (PVOID) DataBuffer, 100, 0, 0, 0, NULL, &dpnHandle, 0);
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
		goto Exit;

	TRACE("\nStarted host enumeration...\n");
	LogMemoryStatus();

	while((hr = pPeer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after enumeration...\n");
	LogMemoryStatus();

	hr = pPeer->CancelAsyncOperation(NULL, DPNCANCEL_ENUM);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCalled CancelAsyncOperation on enumeration...\n");
	LogMemoryStatus();

	while((hr = pPeer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after canceling enumeration...\n");
	LogMemoryStatus();

	hr = pPeer->Close(0);
	if(hr != DPN_OK)
		goto Exit;
	
	TRACE("\nClosed peer object...\n");
	LogMemoryStatus();

	hr = pPeer->Initialize(NULL, DirectPlayMessageHandler, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nInitialized peer object...\n");
	LogMemoryStatus();

	hr = pHostAddress->BuildAddress(szHostname, 2302);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCalled BuildAddress...\n");
	LogMemoryStatus();

	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
	dpnAppDesc.guidApplication = GUID_BASEAPP;

	hr = pPeer->Connect(&dpnAppDesc, pHostAddress, pDeviceAddress, NULL, NULL, (PVOID) DataBuffer, 100, NULL, NULL, &dpnHandle, 0);
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
		goto Exit;

	TRACE("\nStarted connection...\n");
	LogMemoryStatus();

	while((hr = pPeer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after connection...\n");
	LogMemoryStatus();

	hr = pHostAddress->Clear();
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCleared host address...\n");
	LogMemoryStatus();

	hr = pPeer->CancelAsyncOperation(NULL, DPNCANCEL_CONNECT);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCalled CancelAsyncOperation on connection...\n");
	LogMemoryStatus();

	while((hr = pPeer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after canceling connection...\n");
	LogMemoryStatus();

	hr = pPeer->Close(0);
	if(hr != DPN_OK)
		goto Exit;
	
	TRACE("\nClosed peer object...\n");
	LogMemoryStatus();

	hr = pPeer->Initialize(NULL, DirectPlayMessageHandler, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nInitialized peer object...\n");
	LogMemoryStatus();

	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
	dpnAppDesc.guidApplication = GUID_BASEAPP;

	hr = pPeer->Host(&dpnAppDesc, &pDeviceAddress, 1, NULL, NULL, NULL, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nStarted hosting...\n");
	LogMemoryStatus();

	while((hr = pPeer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after hosting...\n");
	LogMemoryStatus();

	memset(&dpnBufferDesc, 0, sizeof(DPN_BUFFER_DESC));
	dpnBufferDesc.dwBufferSize = 100;
	dpnBufferDesc.pBufferData = DataBuffer;

	hr = pPeer->SendTo(0, &dpnBufferDesc, 1, 0, NULL, &dpnHandle, 0);
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
		goto Exit;

	TRACE("\nStarted sending...\n");
	LogMemoryStatus();

	while((hr = pPeer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after sending...\n");
	LogMemoryStatus();

	hr = pPeer->Close(0);
	if(hr != DPN_OK)
		goto Exit;
	
	TRACE("\nClosed peer object...\n");
	LogMemoryStatus();
#endif

#ifdef CALL_CLIENT_FUNCTIONS
	IDirectPlay8Client *pClient = NULL;

	hr = DirectPlay8Create(IID_IDirectPlay8Client, (LPVOID *) &pClient, NULL);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nClient object created...\n");
	LogMemoryStatus();

	hr = pClient->Initialize(NULL, DirectPlayMessageHandler, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nInitialized client object...\n");
	LogMemoryStatus();

	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
	
	hr = pClient->EnumHosts(&dpnAppDesc, NULL, pDeviceAddress, (PVOID) DataBuffer, 100, 0, 0, 0, NULL, &dpnHandle, 0);
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
		goto Exit;

	TRACE("\nStarted host enumeration...\n");
	LogMemoryStatus();

	while((hr = pClient->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after enumeration...\n");
	LogMemoryStatus();

	hr = pClient->CancelAsyncOperation(NULL, DPNCANCEL_ENUM);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCalled CancelAsyncOperation on enumeration...\n");
	LogMemoryStatus();

	while((hr = pClient->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after canceling enumeration...\n");
	LogMemoryStatus();

	hr = pClient->Close(0);
	if(hr != DPN_OK)
		goto Exit;
	
	TRACE("\nClosed client object...\n");
	LogMemoryStatus();

	hr = pClient->Initialize(NULL, DirectPlayMessageHandler, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nInitialized client object...\n");
	LogMemoryStatus();

	hr = pHostAddress->BuildAddress(szHostname, 2302);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCalled BuildAddress...\n");
	LogMemoryStatus();

	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
	dpnAppDesc.guidApplication = GUID_BASEAPP;

	hr = pClient->Connect(&dpnAppDesc, pHostAddress, pDeviceAddress, NULL, NULL, (PVOID) DataBuffer, 100, NULL, &dpnHandle, 0);
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
		goto Exit;

	TRACE("\nStarted connection...\n");
	LogMemoryStatus();

	while((hr = pClient->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after connection...\n");
	LogMemoryStatus();

	hr = pHostAddress->Clear();
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCleared host address...\n");
	LogMemoryStatus();

	hr = pClient->CancelAsyncOperation(NULL, DPNCANCEL_CONNECT);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nCalled CancelAsyncOperation on connection...\n");
	LogMemoryStatus();

	while((hr = pClient->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after canceling connection...\n");
	LogMemoryStatus();

	hr = pClient->Close(0);
	if(hr != DPN_OK)
		goto Exit;
	
	TRACE("\nClosed client object...\n");
	LogMemoryStatus();
#endif

#ifdef CALL_SERVER_FUNCTIONS
	IDirectPlay8Server *pServer = NULL;
	
	hr = DirectPlay8Create(IID_IDirectPlay8Server, (LPVOID *) &pServer, NULL);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nServer object created...\n");
	LogMemoryStatus();

	hr = pServer->Initialize(NULL, DirectPlayMessageHandler, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nInitialized server object...\n");
	LogMemoryStatus();

	memset(&dpnAppDesc, 0, sizeof(DPN_APPLICATION_DESC));
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
	dpnAppDesc.guidApplication = GUID_BASEAPP;
	dpnAppDesc.dwFlags = DPNSESSION_CLIENT_SERVER;

	hr = pServer->Host(&dpnAppDesc, &pDeviceAddress, 1, NULL, NULL, NULL, 0);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nStarted hosting...\n");
	LogMemoryStatus();

	while((hr = pServer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after hosting...\n");
	LogMemoryStatus();

	memset(&dpnBufferDesc, 0, sizeof(DPN_BUFFER_DESC));
	dpnBufferDesc.dwBufferSize = 100;
	dpnBufferDesc.pBufferData = DataBuffer;

	hr = pServer->SendTo(0, &dpnBufferDesc, 1, 0, NULL, &dpnHandle, 0);
	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
		goto Exit;

	TRACE("\nStarted sending...\n");
	LogMemoryStatus();

	while((hr = pServer->DoWork(0)) != S_FALSE)
	{
		if(hr !=  DPN_OK)
			goto Exit;
	}

	TRACE("\nCalled DoWork until S_FALSE after sending...\n");
	LogMemoryStatus();

	hr = pServer->Close(0);
	if(hr != DPN_OK)
		goto Exit;
	
	TRACE("\nClosed server object...\n");
	LogMemoryStatus();
#endif

#ifdef CALL_ADDRESS_FUNCTIONS
	IDirectPlay8Address *pAddress = NULL;

	hr = DirectPlay8AddressCreate(NULL, NULL, NULL);
	if(hr != DPN_OK)
		goto Exit;

	TRACE("\nAddress object created...\n");
	LogMemoryStatus();
#endif
	
	goto Exit;

Exit:

#ifdef CALL_PEER_FUNCTIONS
	pPeer->Release();

	TRACE("\nPeer object released...\n");
	LogMemoryStatus();

	pPeer = NULL;
#endif

#ifdef CALL_CLIENT_FUNCTIONS
	pClient->Release();

	TRACE("\nClient object released...\n");
	LogMemoryStatus();

	pClient = NULL;
#endif

#ifdef CALL_SERVER_FUNCTIONS
	pServer->Release();

	TRACE("\nServer object released...\n");
	LogMemoryStatus();

	pServer = NULL;
#endif

#ifdef CALL_ADDRESS_FUNCTIONS
	pAddress->Release();

	TRACE("\nAddress object released...\n");
	LogMemoryStatus();

	pAddress = NULL;
#endif

	pDeviceAddress->Release();
	pDeviceAddress = NULL;

	pHostAddress->Release();
	pHostAddress = NULL;

	TRACE("\nDevice and host address released...\n");
	LogMemoryStatus();

	DPlayCleanup();

	TRACE("\nDirectPlay cleaned up...\n");
	LogMemoryStatus();

	XnetCleanup();

	TRACE("\nXnet cleaned up...\n");
	LogMemoryStatus();

	CloseMemStatHandles();

	while(TRUE)
	{
		// Loop to infinity
	}
	
	__asm int 3;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\stress\dpstress\peerstress.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dpstress.h"

extern DWORD g_dwDPStressBytesAllocated;
static HRESULT g_hrLastError = DPN_OK;

using namespace DPlayStressNamespace;

namespace DPlayStressNamespace {

// Basic percentage distribution for when to perform a given action
#define SEND_PLAYER_PERCENTAGE 40
#define SEND_GROUP_PERCENTAGE 10
#define GROUP_PERCENTAGE 2
#define APPDESC_CHANGE_PERCENTAGE 0
//#define SEND_GROUP_PERCENTAGE 0
//#define GROUP_PERCENTAGE 0
//#define APPDESC_CHANGE_PERCENTAGE 0

// Basic percentage distribution for when to use certain send flags
#define GUARANTEED_PERCENTAGE 10
#define SEQUENTIAL_PERCENTAGE 30
#define NOLOOPBACK_PERCENTAGE 50

HRESULT PeerStressMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

void WINAPI TRACE(LPCTSTR szFormat, ...) {
	TCHAR szBuffer[1024] = TEXT("");
	va_list pArgs; 
	va_start(pArgs, szFormat);
	
	wvsprintf(szBuffer, szFormat, pArgs);
	
	va_end(pArgs);
	OutputDebugString(szBuffer);
}

//==================================================================================
// InitializePeerStressContext
//----------------------------------------------------------------------------------
//
// Description: Set up the member variables of a PEERSTRESSCONTEXT
//
// Arguments:
//	HANDLE				hLog					Handle to the logging subsystem
//	PEERSTRESSCONTEXT	*pPeerStressContext		Context to initialize
//
// Returns:
//	TRUE if the context was initialized successfully, FALSE otherwise
//==================================================================================
BOOL InitializePeerStressContext(HANDLE hLog, PEERSTRESSCONTEXT *pPeerStressContext, BOOL fIsHost)
{
	if(!pPeerStressContext)
		return FALSE;

	memset(pPeerStressContext, 0, sizeof(PEERSTRESSCONTEXT));

	pPeerStressContext->hLog = hLog;
	pPeerStressContext->fIsHost = fIsHost;
	pPeerStressContext->fVerbose = FALSE;
	strcpy(pPeerStressContext->szContextDescription, fIsHost ? "Host" : "Peer");
	SAFE_CREATEEVENT(pPeerStressContext->hConnectComplete, NULL, FALSE, FALSE, NULL);
	SAFE_CREATEEVENT(pPeerStressContext->hHostMigrated, NULL, FALSE, FALSE, NULL);
	SAFE_CREATEEVENT(pPeerStressContext->hSessionTerminated, NULL, FALSE, FALSE, NULL);
	SAFE_CREATEEVENT(pPeerStressContext->hCriticalError, NULL, FALSE, FALSE, NULL);
	InitializeCriticalSection(&(pPeerStressContext->Lock));

	return ((pPeerStressContext->hConnectComplete) &&
		(pPeerStressContext->hHostMigrated) &&
		(pPeerStressContext->hSessionTerminated));
}

//==================================================================================
// CleanupPeerStressContext
//----------------------------------------------------------------------------------
//
// Description: Clean up the member variables of a PEERSTRESSCONTEXT
//
// Arguments:
//	PEERSTRESSCONTEXT	*pPeerStressContext		Context to cleanup
//
// Returns:
//	TRUE if the test completed successfully (right now, only returns true)
//==================================================================================
void CleanupPeerStressContext(PEERSTRESSCONTEXT *pPeerStressContext)
{
	SAFE_CLOSEHANDLE(pPeerStressContext->hConnectComplete);
	SAFE_CLOSEHANDLE(pPeerStressContext->hHostMigrated);
	SAFE_CLOSEHANDLE(pPeerStressContext->hSessionTerminated);
	SAFE_CLOSEHANDLE(pPeerStressContext->hCriticalError);
	DeleteCriticalSection(&(pPeerStressContext->Lock));

	return;
}

//==================================================================================
// DisplayStressStatistics
//----------------------------------------------------------------------------------
//
// Description: Prints statistics from the current stress session
//
// Arguments:
//	HANDLE				hLog				Handle to the logging subsystem
//	PEERSTRESSCONTEXT	*pContext			Pointer to the peer stress context
//  DWORD				dwLastMinAvail		These 3 DWORD parameters are used to 
//	DWORD				dwLastMinAppAlloc	track memory usage
//	DWORD				dwMinAvail
//
// Returns:
//	nothing
//==================================================================================
void DisplayStressStatistics(HANDLE hLog, PEERSTRESSCONTEXT *pContext, DWORD dwLastMinAvail, DWORD dwLastMinAppAlloc, DWORD dwMinAvail)
{
	xLog(hLog, XLL_INFO, "DirectPlay Peer-to-Peer Stress Statistics");
	xLog(hLog, XLL_INFO, "   Bytes allocated by test: %u", g_dwDPStressBytesAllocated);
	xLog(hLog, XLL_INFO, "   Current local groups: %u", pContext->dwCurrentGroups);
	xLog(hLog, XLL_INFO, "   Current players: %u", pContext->dwPlayersConnected);
	xLog(hLog, XLL_INFO, "   Cumulative local groups: %u", pContext->dwGroupCreationCounter);
	xLog(hLog, XLL_INFO, "   App description changes: %u", pContext->dwAppDescChangeCounter);
	xLog(hLog, XLL_INFO, "   Group messages sent: %u", pContext->TotalGroupMessagesSent);
	xLog(hLog, XLL_INFO, "   Group bytes sent: %u", pContext->TotalGroupBytesSent);
	xLog(hLog, XLL_INFO, "   Individual messages sent: %u", pContext->TotalMessagesSent);
	xLog(hLog, XLL_INFO, "   Individual bytes sent: %u", pContext->TotalBytesSent);
	xLog(hLog, XLL_INFO, "   Players added to group 1: %u", pContext->dwPlayersAdded[0]);
	xLog(hLog, XLL_INFO, "   Players added to group 2: %u", pContext->dwPlayersAdded[1]);
	xLog(hLog, XLL_INFO, "   Players added to group 3: %u", pContext->dwPlayersAdded[2]);
	xLog(hLog, XLL_INFO, "   Min (avail %u + app alloc %u) mem: %u", dwLastMinAvail, dwLastMinAppAlloc, dwMinAvail);
}

//==================================================================================
// AddRandomPlayersToGroup
//----------------------------------------------------------------------------------
//
// Description: Enum the current players in the session, pick a random subset of them,
//				and add them to the group
//
// Arguments:
//	HANDLE				hLog		Handle to the logging subsytem
//	PDIRECTPLAY8PEER	pDP8Peer	DirectPlay 8 peer to have a new group created
//	DPNID				dpnidGroup	ID of the group to add players to
//
// Returns:
//	DWORD indicating the number of players added to the group
//==================================================================================
DWORD AddRandomPlayersToGroup(HANDLE hLog, PDIRECTPLAY8PEER pDP8Peer, DPNID dpnidGroup)
{
	DPNHANDLE	hAsyncOp = NULL;
	HRESULT		hr = DPN_OK;
	DPNID		*pPlayerList = NULL;
	DWORD		dwNumPlayers = 0, dwPlayersAdded = 0;

	// Query for the number of player and/or groups
	hr = pDP8Peer->EnumPlayersAndGroups(NULL, &dwNumPlayers, DPNENUM_PLAYERS);

	// If the operation succeeded, then DirectPlay is saying that there aren't any
	// players available on this object.
	if(hr == DPN_OK)
	{
		// This should never happen, since we should at least have the local player...
		xLog(hLog, XLL_WARN, "No players are available!");
		goto Exit;
	}
	else if (hr != DPNERR_BUFFERTOOSMALL)
	{
		xLog(hLog, XLL_WARN, "Couldn't enumerate any players: 0x%08x", hr);
		g_hrLastError = hr;
		goto Exit;
	}

AllocatePlayerArray:

	// Do the player array allocation here
	if(dwNumPlayers > 0)
	{
		pPlayerList = (DPNID *) MemAlloc(dwNumPlayers * sizeof(DPNID));
		if(!pPlayerList)
		{
			xLog(hLog, XLL_WARN, "Couldn't allocate player buffer!");
			goto Exit;
		}
	}
	// DirectPlay should always return at least return the one host player...
	else
	{
		xLog(hLog, XLL_WARN, "EnumPlayersAndGroups claimed buffer was too small, but returned 0 players/groups!");
		goto Exit;
	}

	// Try to retrieve the player and group information...
	// If it's changed since the last time we called, we may have to reallocate our buffer again
	hr = pDP8Peer->EnumPlayersAndGroups(pPlayerList, &dwNumPlayers, DPNENUM_PLAYERS);

	// It succeeded, so we have an array of player/group ID's
	if(hr == DPN_OK)
	{
		DWORD dwCurrentPlayer = 0;
		
		// We now have a list of players, so randomly add them to the group
		if(dwNumPlayers > 0)
		{
			for(dwCurrentPlayer = 0;dwCurrentPlayer < dwNumPlayers;++dwCurrentPlayer)
			{
				// 50-50 chance of adding the player to the group
				if(rand() % 2)
				{
					hr = pDP8Peer->AddPlayerToGroup(dpnidGroup, pPlayerList[dwCurrentPlayer], NULL, &hAsyncOp, 0);
					switch(hr)
					{
					case DPN_OK:
						xLog(hLog, XLL_WARN, "CreateGroup unexpectedly returned synchronously!");
					case DPNSUCCESS_PENDING:
						++dwPlayersAdded;
						break;
					case DPNERR_INVALIDPLAYER:
						// This is expected from time to time.  We tried to add a player to a group but that player
						// has since left the session
						break;
					default:
						xLog(hLog, XLL_WARN, "Couldn't add player 0x%08x to group 0x%08x! (error 0x%08x)",
							pPlayerList[dwCurrentPlayer], dpnidGroup, hr);
						g_hrLastError = hr;
						goto Exit;
					}
				}
			}

			// If no one wound up being added, scan through the list and at least add one user to the group
			// In the case where we are hosting and no one has connected, this will add the host player
			if(!dwPlayersAdded)
			{
				for(dwCurrentPlayer = 0;dwCurrentPlayer < dwNumPlayers;++dwCurrentPlayer)
				{
					hr = pDP8Peer->AddPlayerToGroup(dpnidGroup, pPlayerList[dwCurrentPlayer], NULL, &hAsyncOp, 0);
					switch(hr)
					{
					case DPN_OK:
						xLog(hLog, XLL_WARN, "CreateGroup unexpectedly returned synchronously!");
					case DPNSUCCESS_PENDING:
						++dwPlayersAdded;
						// This is a hack to get us to leave the loop since we only wanted to add one player
						dwCurrentPlayer = dwNumPlayers;
						break;
					case DPNERR_INVALIDPLAYER:
						// This is expected from time to time.  We tried to add a player to a group but that player
						// has since left the session
						break;
					default:
						xLog(hLog, XLL_WARN, "Couldn't add player 0x%08x to group 0x%08x! (error 0x%08x)",
							pPlayerList[dwCurrentPlayer], dpnidGroup, hr);
						g_hrLastError = hr;
						goto Exit;
					}
				}	
			}
		}
		// DirectPlay should at least return the one host player...
		else
		{
			xLog(hLog, XLL_WARN, "EnumPlayersAndGroups said there are no players in the session!");
			goto Exit;
		}

	}
	// If our buffer is too small, we'll have to try querying for the new required buffer size
	else if (hr == DPNERR_BUFFERTOOSMALL)
	{
		pPlayerList ? MemFree(pPlayerList) : 0;
		pPlayerList = NULL;
		goto AllocatePlayerArray;
	}
	else
	{
		xLog(hLog, XLL_WARN, "Couldn't enumerate any players: 0x%08x", hr);
		g_hrLastError = hr;
		goto Exit;
	}

Exit:
	pPlayerList ? MemFree(pPlayerList) : 0;

	return dwPlayersAdded;
}


//==================================================================================
// CreateGroupWithRandomInfo
//----------------------------------------------------------------------------------
//
// Description: Create a group and populate it with a name based on the local system name
//				and a random info buffer
//
// Arguments:
//	HANDLE				hLog		Handle to the logging subsytem
//	PDIRECTPLAY8PEER	pDP8Peer	DirectPlay 8 peer to have a new group created
//	PEERSTRESSCONTEXT	*pContext	Pointer to the context for this peer
//
// Returns:
//	TRUE if the group creation call was successfully made, FALSE otherwise
//==================================================================================
BOOL CreateGroupWithRandomInfo(HANDLE hLog, PDIRECTPLAY8PEER pDP8Peer, PEERSTRESSCONTEXT *pContext)
{
	DPN_GROUP_INFO	dpnGroupInfo;
	DPNHANDLE		hGroupOp = NULL;
	HRESULT			hr = DPN_OK;
	DWORD			dwBufferSize = 0;
	CHAR			szLocalMacAddress[20];
	WCHAR			szNameString[20];
	BOOL			fRet = TRUE;
	
	memset(&dpnGroupInfo, 0, sizeof(DPN_GROUP_INFO));
	dpnGroupInfo.dwSize = sizeof(DPN_GROUP_INFO);

	// Always provide both name information
	dpnGroupInfo.dwInfoFlags = DPNINFO_NAME;

	// Create auto-destruct groups half the time
	dpnGroupInfo.dwGroupFlags = (rand() % 2) ? DPNGROUP_AUTODESTRUCT : 0;

	// Use the mac address string to personalize group names made by this player
	if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
	{
		sprintf(szLocalMacAddress, "%s%u", UNKNOWN_HOST_STRING, (pContext->dwGroupCreationCounter) % 100);
	}
	else
	{
		sprintf(szLocalMacAddress + strlen(szLocalMacAddress), "%u", (pContext->dwGroupCreationCounter) % 100);
	}
	mbstowcs(szNameString, szLocalMacAddress, strlen(szLocalMacAddress) + 1);
	dpnGroupInfo.pwszName = szNameString;
	
	// Generate a random buffer of data to send
	if(!(dpnGroupInfo.dwDataSize = GenerateRandomDataBuffer((BYTE **) &(dpnGroupInfo.pvData), GROUP_DATA_MIN_SIZE, GROUP_DATA_MAX_SIZE)))
	{
		xLog(hLog, XLL_WARN, "Couldn't generate random buffer for send data");
		dpnGroupInfo.pvData = NULL;
	}
	else
	{
		// We successfully added data, so add that flag to the group structure.
		dpnGroupInfo.dwInfoFlags |= DPNINFO_DATA;
	}
	
	// Create the group, provide TRUE as the group context so that we know its one that we created
	hr = pDP8Peer->CreateGroup(&dpnGroupInfo, (LPVOID) TRUE, NULL, &hGroupOp, 0);
	if (hr == DPN_OK)
	{
		xLog(hLog, XLL_WARN, "CreateGroup unexpectedly returned synchronously!");
	}
	// Group creation failed or some reason
	else if (hr != DPNSUCCESS_PENDING)
	{
		xLog(hLog, XLL_WARN, "Couldn't create group! (error 0x%08x)", hr);
		g_hrLastError = hr;
		fRet = FALSE;
	}

	// Free the group data pointer
	dpnGroupInfo.pvData ? MemFree(dpnGroupInfo.pvData) : 0;
	dpnGroupInfo.pvData = NULL;

	return fRet;
}

//==================================================================================
// GetRandomTarget
//----------------------------------------------------------------------------------
//
// Description: Enumerate players and/or groups on a peer and pick one at random
//
// Arguments:
//	HANDLE				hLog		Handle to the logging subsytem
//	PDIRECTPLAY8PEER	pDP8Peer	DirectPlay 8 peer to have players/groups enumerated on
//	DPNID				*pTarget	Variable for passing back randomly selected player/group
//	DWORD				dwFlags		Contains DPNENUM_PLAYERS and/or DPNENUM_GROUPS to indicate
//									if players, groups or both should be randomly selected from
//
// Returns:
//	DPNENUM_PLAYERS or DPNENUM_GROUPS to indicate if player or group (respectively) is being
//	returned in pTarget
//==================================================================================
DWORD GetRandomTarget(HANDLE hLog, PDIRECTPLAY8PEER pDP8Peer, DPNID *pTarget, DWORD dwFlags)
{
	HRESULT	hr;
	DPNID	*pPlayerList = NULL;
	DWORD	dwNumPlayers = 0, dwTargetIndex = 0, dwTargetType = 0;


	if(!(dwFlags & DPNENUM_PLAYERS) && !(dwFlags & DPNENUM_GROUPS))
	{
		xLog(hLog, XLL_WARN, "No player/group flags specified!");
		goto Exit;
	}

	// Query for the number of player and/or groups
	hr = pDP8Peer->EnumPlayersAndGroups(NULL, &dwNumPlayers, dwFlags);

	// If the operation succeeded, then DirectPlay is saying that there aren't any
	// players and/or groups available on this object.  If we were querying for players,
	// then this must mean that we're disconnected.  If we were querying for just groups,
	// this only means that no groups have been created yet.
	if(hr == DPN_OK)
	{
		if(dwFlags & DPNENUM_PLAYERS)
		{
			xLog(hLog, XLL_WARN, "No players are available!");
			goto Exit;
		}
		else if(dwFlags & DPNENUM_GROUPS)
		{
			// This case is possible if we don't have any active local groups at the momemt
//			xLog(hLog, XLL_INFO, "No groups are available.");
			goto Exit;
		}
	}
	else if (hr != DPNERR_BUFFERTOOSMALL)
	{
		xLog(hLog, XLL_WARN, "Couldn't enumerate any players: 0x%08x", hr);
		g_hrLastError = hr;
		goto Exit;
	}

AllocatePlayerArray:

	// Do the player array allocation here
	if(dwNumPlayers > 0)
	{
		pPlayerList = (DPNID *) MemAlloc(dwNumPlayers * sizeof(DPNID));
		if(!pPlayerList)
		{
			xLog(hLog, XLL_WARN, "Couldn't allocate player buffer!");
			goto Exit;
		}
	}
	// Something weird happened if DirectPlay said we needed a larger buffer but there aren't any player/groups
	else
	{
		xLog(hLog, XLL_WARN, "EnumPlayersAndGroups claimed buffer was too small, but returned 0 players/groups!");
		goto Exit;
	}

	// Try to retrieve the player and group information...
	// If it's changed since the last time we called, we may have to reallocate our buffer again
	hr = pDP8Peer->EnumPlayersAndGroups(pPlayerList, &dwNumPlayers, dwFlags);

	// It succeeded, so we have an array of player/group ID's
	if(hr == DPN_OK)
	{
		DWORD dwInfoSize = 0;

		// Pick a random index in the array and set that as the target
		dwTargetIndex = (rand() % dwNumPlayers);
		*pTarget = pPlayerList[dwTargetIndex];

		// Determine if it is a player or a group

		// If we were querying for both players and groups, then we'll have to call
		// GetPeerInfo and GetGroupInfo to determine if it's a player or a group
		if((dwFlags & DPNENUM_PLAYERS) && (dwFlags & DPNENUM_GROUPS))
		{
			dwInfoSize = 0;
			hr = pDP8Peer->GetPeerInfo(*pTarget, NULL, &dwInfoSize, 0);

			// This is either a group or a disconnected player
			if(hr == DPNERR_INVALIDPLAYER)
			{
				dwInfoSize = 0;
				hr = pDP8Peer->GetGroupInfo(*pTarget, NULL, &dwInfoSize, 0);

				// Must be a disconnected player since GetPeerInfo and GetGroupInfo failed
				if(hr == DPNERR_INVALIDGROUP)
				{
					xLog(hLog, XLL_INFO, "Randomly selected target (0x%08x) no longer exists!", *pTarget);
					*pTarget = 0;
					goto Exit;
				}
				// Must be a group since it didn't return INVALIDGROUP
				else if(hr == DPNERR_BUFFERTOOSMALL)
				{
					dwTargetType = DPNENUM_PLAYERS;
				}
				// Something weird failed in the call, return failure
				else
				{
					xLog(hLog, XLL_WARN, "Couldn't verify type of selected target: 0x%08x", hr);
					g_hrLastError = hr;
					*pTarget = 0;
					goto Exit;
				}

				dwTargetType = DPNENUM_GROUPS;
			}
			// Must be a player since it didn't return INVALIDPLAYER
			else if(hr == DPNERR_BUFFERTOOSMALL)
			{
				dwTargetType = DPNENUM_PLAYERS;
			}
			// Something weird failed in the call, return failure
			else
			{
				xLog(hLog, XLL_WARN, "Couldn't verify type of selected target: 0x%08x", hr);
				g_hrLastError = hr;
				*pTarget = 0;
				goto Exit;
			}
		}
		// otherwise, the flag that was set will tell us
		else if (dwFlags & DPNENUM_PLAYERS)
		{
				dwTargetType = DPNENUM_PLAYERS;
		}
		else
		{
				dwTargetType = DPNENUM_GROUPS;
		}

	}
	// If our buffer is too small, we'll have to try querying for the new required buffer size
	else if (hr == DPNERR_BUFFERTOOSMALL)
	{
		pPlayerList ? MemFree(pPlayerList) : 0;
		pPlayerList = NULL;
		goto AllocatePlayerArray;
	}
	else
	{
		xLog(hLog, XLL_WARN, "Couldn't enumerate any players: 0x%08x", hr);
		g_hrLastError = hr;
		goto Exit;
	}

Exit:

	pPlayerList ? MemFree(pPlayerList) : 0;

	return dwTargetType;
}

//==================================================================================
// GenerateRandomSendFlags
//----------------------------------------------------------------------------------
//
// Description: Helper function that randomly generates send flags
//
// Arguments:
//	BOOL			fGroupSend		Boolean that indicates if this send is to a group
//
// Returns:
//	DWORD containing the flags for this send
//==================================================================================
DWORD GenerateRandomSendFlags(BOOL fGroupSend)
{
	DWORD dwSendFlags = 0;

/*
	// Randomly determine send priority...
	switch(rand() % 3)
	{
	case 0:
		dwSendFlags |= DPNSEND_PRIORITY_HIGH;
		break;
	case 1:
		dwSendFlags |= DPNSEND_PRIORITY_LOW;
		break;
	default:
		break;
	}
	
	// Randomly determine guaranteed/non-guaranteed...
	if((rand() % 100) < GUARANTEED_PERCENTAGE)
	{
		dwSendFlags |= DPNSEND_GUARANTEED;
	}
	
	// Randomly determine sequential/non-sequential...
	if((rand() % 100) >= SEQUENTIAL_PERCENTAGE)
	{
		dwSendFlags |= DPNSEND_NONSEQUENTIAL;
	}
	
	// If this is a group send, consider using the no loopback flag
	if(fGroupSend)
	{
		if((rand() % 100) < NOLOOPBACK_PERCENTAGE)
		{
			dwSendFlags |= DPNSEND_NONSEQUENTIAL;
		}
	}
*/
	return dwSendFlags;
}

//==================================================================================
// PerformRandomDirectPlayWork
//----------------------------------------------------------------------------------
//
// Description: Enumerate players and/or groups on a peer and pick one at random
//
// Arguments:
//	HANDLE				hLog		Handle to the logging subsytem
//	PDIRECTPLAY8PEER	pDP8Peer	DirectPlay 8 peer to have players/groups enumerated on
//	PPEERSTRESSCONTEXT	pContext	Pointer to the context associated with the pDP8Peer object
//
// Returns:
//	DPNENUM_PLAYERS or DPNENUM_GROUPS to indicate if player or group (respectively) is being
//	returned in pTarget
//==================================================================================
BOOL PerformRandomDirectPlayWork(HANDLE hLog, PDIRECTPLAY8PEER pDP8Peer, PEERSTRESSCONTEXT *pContext)
{
	DPN_BUFFER_DESC		dpnbd;
	DPNHANDLE			AsyncHandle;
	HRESULT				hr;
	DWORD				dwRandomAction = 0, dwTargetType = 0, dwBytesInQueue = 0, dwBufferSize = 0, n = 0;
	DPNID				dpnidTarget;
	BOOL				fSuccess = TRUE;
	BYTE				*pBuffer = NULL;

	dwRandomAction = (rand() % 100);

	// This case handles when the random action is a single player send
	if(dwRandomAction < SEND_PLAYER_PERCENTAGE)
	{
		// Get a random player to send to
		dwTargetType = GetRandomTarget(hLog, pDP8Peer, &dpnidTarget, DPNENUM_PLAYERS);
		if(!(dwTargetType & DPNENUM_PLAYERS))
		{
			fSuccess = FALSE;
			goto Exit;
		}

		// If the selected target isn't the local player, then check the send queue to insure
		// that this target isn't getting clogged with data
		if(pContext->LocalPlayerID != dpnidTarget)
		{
			// Check their send queue info to see if we'll be choking the connection by sending to them
			hr = pDP8Peer->GetSendQueueInfo(dpnidTarget, NULL, &dwBytesInQueue,0);
			if(hr != DPN_OK)
			{
				xLog(hLog, XLL_INFO, "Lost connection with targeted player: 0x%08x (error 0x%08x)", dpnidTarget, hr);
				g_hrLastError = hr;
				fSuccess = FALSE;
				goto Exit;
			}
			
			// If the send queue has gotten too large, skip this send
			if(dwBytesInQueue > MAX_PENDING_SEND_BYTES)
			{
//				xLog(hLog, XLL_INFO, "Targetted player's send queue is too large: 0x%08x", dpnidTarget);
				fSuccess = FALSE;
				goto Exit;
			}
		}

		// Generate a random buffer of data to send
		if(!(dwBufferSize = GenerateRandomDataBuffer(&pBuffer, SEND_DATA_MIN_SIZE, SEND_DATA_MAX_SIZE)))
		{
			xLog(hLog, XLL_WARN, "Couldn't generate random buffer for send data");
			fSuccess = FALSE;
			goto Exit;
		}

		// Package up the buffer
		dpnbd.dwBufferSize = dwBufferSize;
		dpnbd.pBufferData = pBuffer;

		// BUGBUG - what about various message flags?
		// As a last attempt to prevent our send queues from getting unreasonably large...
		// the send will timeout after 100 ms.  So at most, 50 sends can be pending at at time
		// since the main loop will spend at least 2ms per loop processing DoWork calls
		// This may change if the test starts calling the PerformRandomDirectPlayWork multiple times per loop
		hr = pDP8Peer->SendTo(dpnidTarget, &dpnbd, 1, 100, NULL, &AsyncHandle, GenerateRandomSendFlags(FALSE));
		if (hr == DPN_OK)
		{
			xLog(hLog, XLL_WARN, "SendTo unexpectedly returned synchronously!");
		}
		else if (hr != DPNSUCCESS_PENDING)
		{
			xLog(hLog, XLL_WARN, "Lost connection while sending to player: 0x%08x (error 0x%08x)", dpnidTarget, hr);
			g_hrLastError = hr;
			fSuccess = FALSE;
			goto Exit;
		}

		++(pContext->TotalMessagesSent);
		(pContext->TotalBytesSent) += dwBufferSize;
	}
	// This case handles when the random action is a group send
	else if((dwRandomAction -= SEND_PLAYER_PERCENTAGE) < SEND_GROUP_PERCENTAGE)
	{
		// Get a random group to send to
		dwTargetType = GetRandomTarget(hLog, pDP8Peer, &dpnidTarget, DPNENUM_GROUPS);

		// Possible that we don't have any active groups right now
		if(!(dwTargetType & DPNENUM_GROUPS))
		{
			fSuccess = FALSE;
			goto Exit;
		}

		// Generate a random buffer of data to send
		if(!(dwBufferSize = GenerateRandomDataBuffer(&pBuffer, SEND_DATA_MIN_SIZE, SEND_DATA_MAX_SIZE)))
		{
			xLog(hLog, XLL_WARN, "Couldn't generate random buffer for send data");
			fSuccess = FALSE;
			goto Exit;
		}

		// Package up the buffer
		dpnbd.dwBufferSize = dwBufferSize;
		dpnbd.pBufferData = pBuffer;

		// BUGBUG - what about various message flags?
		// As a last attempt to prevent our send queues from getting unreasonably large...
		// the send will timeout after 100 ms.  So at most, 50 sends can be pending at at time
		// since the main loop will spend at least 2ms per loop processing DoWork calls
		// This may change if the test starts calling the PerformRandomDirectPlayWork multiple times per loop
		hr = pDP8Peer->SendTo(dpnidTarget, &dpnbd, 1, 100, NULL, &AsyncHandle, GenerateRandomSendFlags(TRUE));
		if (hr == DPN_OK)
		{
			xLog(hLog, XLL_WARN, "SendTo unexpectedly returned synchronously!");
		}
		else if (hr != DPNSUCCESS_PENDING)
		{
			xLog(hLog, XLL_WARN, "Lost connection while sending to group: 0x%08x (error 0x%08x)", dpnidTarget, hr);
			g_hrLastError = hr;
			fSuccess = FALSE;
			goto Exit;
		}

		++(pContext->TotalGroupMessagesSent);
		(pContext->TotalGroupBytesSent) += dwBufferSize;
	}
	// This case handles when the random action is a group create/delete
	else if((dwRandomAction -= SEND_GROUP_PERCENTAGE) < GROUP_PERCENTAGE)
	{
		DPNHANDLE	hGroupOp;
		BOOL		fCreateGroup = TRUE;

		switch(pContext->dwCurrentGroups)
		{
		case 0:				// There are no groups, create one...
			fCreateGroup = TRUE;
			break;
		case MAX_GROUPS:	// Maximum groups have been created, delete one...
			fCreateGroup = FALSE;
			break;
		default:			// Somewhere in between no groups and max groups, randomly decide what to do...
			fCreateGroup = (BOOL) (rand() % 2);
			break;
		}

		// If we haven't already created a group... then create one...
		if(fCreateGroup)
		{
			if(!CreateGroupWithRandomInfo(hLog, pDP8Peer, pContext))
			{
				fSuccess = FALSE;
				goto Exit;
			}

			++(pContext->dwCurrentGroups);
			++(pContext->dwGroupCreationCounter);
		}
		// If we already created a group... then destroy it...
		else
		{
			DPNID dpnidGroupToDelete = 0;

			for(n = 0;n < MAX_GROUPS;++n)
			{
				if(dpnidGroupToDelete = pContext->LocalGroupIDs[n])
					break;
			}

			if(!dpnidGroupToDelete)
			{
//				xLog(hLog, XLL_WARN, "Tried to delete local group, but its creation hasn't been indicated yet!");
				fSuccess = FALSE;
				goto Exit;
			}
			
			hr = pDP8Peer->DestroyGroup(dpnidGroupToDelete, NULL, &hGroupOp, 0);
			if (hr == DPN_OK)
			{
				xLog(hLog, XLL_WARN, "DestroyGroup unexpectedly returned synchronously!");
			}
			else if (hr != DPNSUCCESS_PENDING)
			{
				xLog(hLog, XLL_WARN, "Couldn't destroy group: 0x%08x (error 0x%08x)", dpnidGroupToDelete, hr);
				fSuccess = FALSE;
				g_hrLastError = hr;
				goto Exit;
			}

			--(pContext->dwCurrentGroups);
			pContext->LocalGroupIDs[n] = 0;
			pContext->dwPlayersAdded[n] = 0;
		}
	}
	else if((dwRandomAction -= GROUP_PERCENTAGE) < APPDESC_CHANGE_PERCENTAGE)
	{
		if(pContext->fIsHost)
		{
			DPN_APPLICATION_DESC	dpnad;
			CHAR					szLocalMacAddress[20];
			WCHAR					szNameString[20];
			
			ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
			dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
			dpnad.dwFlags = DPNSESSION_MIGRATE_HOST;
			dpnad.guidApplication = GUID_PEER_STRESS;
			
			// Use the mac address string to personalize the application name
			if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
			{
				sprintf(szLocalMacAddress, "%s%u", UNKNOWN_HOST_STRING, (pContext->dwAppDescChangeCounter) % 100);
			}
			else
			{
				sprintf(szLocalMacAddress + strlen(szLocalMacAddress), "%u", (pContext->dwAppDescChangeCounter) % 100);
			}
			mbstowcs(szNameString, szLocalMacAddress, strlen(szLocalMacAddress) + 1);
			dpnad.pwszSessionName = szNameString;
			
			// Allocate a random buffer for application data
			if(!(dpnad.dwApplicationReservedDataSize =
				GenerateRandomDataBuffer((BYTE **) &(dpnad.pvApplicationReservedData), APP_DESC_MIN_SIZE, APP_DESC_MAX_SIZE)))
			{
				xLog(hLog, XLL_WARN, "Couldn't generate random buffer for application data");
				fSuccess = FALSE;
				goto Exit;
			}
			
			hr = pDP8Peer->SetApplicationDesc(&dpnad, 0);
			if (hr != DPN_OK)
			{
				xLog(hLog, XLL_WARN, "Couldn't set application description: (error 0x%08x)", hr);
				dpnad.pvApplicationReservedData ? MemFree(dpnad.pvApplicationReservedData) : 0;
				dpnad.pvApplicationReservedData = NULL;
				fSuccess = FALSE;
				goto Exit;
			}
			
			dpnad.pvApplicationReservedData ? MemFree(dpnad.pvApplicationReservedData) : 0;
			dpnad.pvApplicationReservedData = NULL;
		}
	}
//	else if((dwRandomAction -= SEND_PERCENTAGE) < SOMEOTHER_PERCENTAGE)
//	{
//		// BUGBUG - Implement other cases
//	}

	// 
	// Everything beyond this point will be executed regardless of what random action was chosen.
	// In some cases, this processing is used to complete an earlier action, such as adding players
	// to a group that has now been asynchronously created

	// If local groups have been created, see if any need players added to them...
	if(pContext->dwCurrentGroups)
	{
		// Scan the local group list
		for(n = 0;n < MAX_GROUPS;++n)
		{
			// If a particular group has been created, but doesn't have any players yet,
			// go ahead and add them.
			if(pContext->LocalGroupIDs[n] && !(pContext->dwPlayersAdded[n]))
				pContext->dwPlayersAdded[n] = AddRandomPlayersToGroup(hLog, pDP8Peer, pContext->LocalGroupIDs[n]);
		}
	}

Exit:

	pBuffer ? MemFree(pBuffer) : 0;
	pBuffer = NULL;

	return fSuccess;
}

//==================================================================================
// PeerStress
//----------------------------------------------------------------------------------
//
// Description: Host or connect to a DPlay session and start stress
//
// Arguments:
//	HANDLE		hLog			Handle to the logging subsystem
//	HANDLE		hNetsync		Handle to the Netsync subsystem
//	DP_HOSTINFO	*pMsg			Received Netsync message containing DPlay session info
//	IN_ADDR		*pLocalAddr		pLocalAddr
//	BOOL		fStartedAsHost	Boolean indicating if this machine is being started as the host
//
// Returns:
//	TRUE if the test completed successfully (right now, only returns true)
//==================================================================================
BOOL PeerStress(HANDLE hLog, HANDLE hNetsync, DP_HOSTINFO *pMsg, IN_ADDR *pLocalAddr, BOOL fStartedAsHost)
{
	DPN_APPLICATION_DESC	dpnad;
	PDIRECTPLAY8ADDRESS		pDP8DeviceAddress = NULL, pDP8HostAddress = NULL;
	PEERSTRESSCONTEXT		PeerStressContext;
	PDIRECTPLAY8PEER		pDP8Peer = NULL;
	PPLAYERCONTEXT			pLocalPlayerContext = NULL;
	SOCKADDR_IN				HostSockAddr, EnumedSockAddr;
	DPNHANDLE				AsyncHandle;
	HRESULT					hr;
	HANDLE					hEnumEvent = NULL;
	DWORD					dwPort = 0, dwBufferSize = 0, dwLastKATime = 0;
	DWORD					dwLastMemTime = 0, dwLoopStartTime = 0, dwTimeElapsed = 0;
	BYTE					*pBuffer = NULL;

	MEMORYSTATUS			MemoryStatus;
	DWORD					dwMinAvail = 0, dwLastMinAppAlloc = 0, dwLastMinAvail = 0;

	BOOL					fDPlayInitialized = FALSE, fPeerInitialized = FALSE;

	memset(&MemoryStatus, 0, sizeof(MEMORYSTATUS));
	MemoryStatus.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus (&MemoryStatus);

	xLog(hLog, XLL_INFO, "Memory status at start", MemoryStatus.dwAvailPhys);
	xLog(hLog, XLL_INFO, "   Available:          %u", MemoryStatus.dwAvailPhys);
	xLog(hLog, XLL_INFO, "   Allocated by App:   %u", g_dwDPStressBytesAllocated);
	xLog(hLog, XLL_INFO, "   Sum:                %u",
		dwMinAvail = MemoryStatus.dwAvailPhys + g_dwDPStressBytesAllocated);

	hr = DPlayInitialize(1024 * 400);
	if(hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "Couldn't init DPlay: 0x%08x", hr);
		goto Exit;
	}

	fDPlayInitialized = TRUE;
//	xLog(g_hLog, XLL_INFO, "DirectPlay layer initialized");

	// First, create a peer object... no voice
	hr = DirectPlay8Create(IID_IDirectPlay8Peer, (LPVOID *) &pDP8Peer, NULL);
	if(hr != DPN_OK)
	{
		xLog(hLog, XLL_WARN, "Couldn't create peer object: 0x%08x", hr);
		goto Exit;
	}

	// Initialize all the member variables of the peer context
	if(!InitializePeerStressContext(hLog, &PeerStressContext, fStartedAsHost))
	{
		xLog(hLog, XLL_WARN, "Couldn't create peer object: 0x%08x", hr);
		goto Exit;
	}

	// Next, initialize the peer object
	hr = pDP8Peer->Initialize(&PeerStressContext, PeerStressMessageHandler, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_WARN, "Initializing peer object failed: 0x%08x", hr);
		goto Exit;
	}

	fPeerInitialized = TRUE;

	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);
	if(hr != DPN_OK)
	{
		xLog(hLog, XLL_WARN, "Couldn't create device address object: 0x%08x", hr);
		goto Exit;
	}
	
	// Set the service provider of this address
	hr = pDP8DeviceAddress->SetSP(&CLSID_DP8SP_TCPIP);
	if(hr != DPN_OK)
	{
		xLog(hLog, XLL_WARN, "Couldn't set the local device address SP to TCP/IP: 0x%08x", hr);
		goto Exit;
	}
	
	// If we are the host, go ahead and start hosting...
	if(fStartedAsHost)
	{
		xLog(hLog, XLL_INFO, "Initializing local DirectPlay peer object as host...");

		//----------------------------------------
		// HOST STARTS HOSTING
		//----------------------------------------

		// For now, we're hardcoding the hosting port to DPSTRESS_PORT...
		// It will turn up on the DPlay protocol parser that way
		dwPort = DPSTRESS_PORT;
		hr = pDP8DeviceAddress->AddComponent(DPNA_KEY_PORT, &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't add a specific port to the host object: 0x%08x", hr);
			goto Exit;
		}

		// Set up the application description for this session
		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_MIGRATE_HOST;
		dpnad.guidApplication = GUID_PEER_STRESS;

		// Allocate a local player context.  Callback will deallocate on destroy player message
		pLocalPlayerContext = NULL;
		pLocalPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
		memset(pLocalPlayerContext, 0, sizeof(PLAYERCONTEXT));

		if(!pLocalPlayerContext)
		{
			xLog(hLog, XLL_WARN, "Couldn't allocate local player context");
			goto Exit;
		}

		// Host the session
		hr = pDP8Peer->Host(&dpnad, &pDP8DeviceAddress, 1, NULL, NULL, pLocalPlayerContext, 0);
		if (hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't host session: 0x%08x", hr);
			goto Exit;
		}
	}
	// Otherwise, we need to connect to the host...
	else
	{
		xLog(hLog, XLL_INFO, "Initializing local DirectPlay peer object as non-host...");

		//----------------------------------------
		// NON-HOST ENUMERATION CASES
		//----------------------------------------

		// Set up the application description for this session
		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.guidApplication = GUID_PEER_STRESS;

		SAFE_CREATEEVENT(hEnumEvent, NULL, FALSE, FALSE, NULL);

		// For now, we're hardcoding the hosting port to DPSTRESS_PORT...
		// It will turn up on the DPlay protocol parser that way
		HostSockAddr.sin_family = AF_INET;
		HostSockAddr.sin_port = htons(DPSTRESS_PORT);
		HostSockAddr.sin_addr.S_un.S_addr = pMsg->dwHostAddr;

		
		hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &(PeerStressContext.pExpectedHostAddress), NULL);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't create device address object: 0x%08x", hr);
			goto Exit;
		}

		
		hr = PeerStressContext.pExpectedHostAddress->BuildFromSockAddr((SOCKADDR *) &HostSockAddr);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't build an address from a SOCKADDR: %0x%08x", hr);
			goto Exit;
		}

		//----------------------------------------
		// 1) NO HOST ADDRESS PROVIDED
		//----------------------------------------

		// Allocate a buffer of random enum data
		if(!(dwBufferSize = GenerateRandomDataBuffer(&pBuffer, ENUM_DATA_MIN_SIZE, ENUM_DATA_MAX_SIZE)))
		{
			xLog(hLog, XLL_WARN, "Couldn't generate random buffer for enumeration request data");
			goto Exit;
		}

		ResetEvent(hEnumEvent);
		xLog(hLog, XLL_INFO, "Enumerating host without a host address");

		// Start the enumeration
		hr = pDP8Peer->EnumHosts(&dpnad, NULL, pDP8DeviceAddress, pBuffer, dwBufferSize,
			0, 0, 0, hEnumEvent, &AsyncHandle, 0);
		if (hr != (HRESULT) DPNSUCCESS_PENDING)
		{
			xLog(hLog, XLL_WARN, "Couldn't enumerate hosts: 0x%08x", hr);
			goto Exit;
		}

		// Waiting for enumeration to complete
		if(!PollPeerUntilEventSignalled(hLog, pDP8Peer, MAX_ENUM_TIME, hEnumEvent, NULL))
			xLog(hLog, XLL_WARN, "Enumeration without address couldn't find host");

		// Cancel to enum to make sure that it's complete before starting the next enum
		hr = pDP8Peer->CancelAsyncOperation(0, DPNCANCEL_ENUM);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't cancel asynchronous enumeration!", hr);
			goto Exit;
		}

		MemFree(pBuffer);
		pBuffer = NULL;
		dwBufferSize = 0;

		//----------------------------------------
		// 2) HOST PORT, BUT NO HOST IP PROVIDED
		//----------------------------------------

		// Allocate a buffer of random enum data
		if(!(dwBufferSize = GenerateRandomDataBuffer(&pBuffer, ENUM_DATA_MIN_SIZE, ENUM_DATA_MAX_SIZE)))
		{
			xLog(hLog, XLL_WARN, "Couldn't generate random buffer for enumeration request data");
			goto Exit;
		}

		// Create host address
		hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8HostAddress, NULL);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't create host address object: %0x%08x", hr);
			goto Exit;
		}
		
		// Set the service provider of this address
		hr = pDP8HostAddress->SetSP(&CLSID_DP8SP_TCPIP);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't set the remote host address SP to TCP/IP: %0x%08x", hr);
			goto Exit;
		}

		// For now, we're hardcoding the hosting port to DPSTRESS_PORT...
		// It will turn up on the DPlay protocol parser that way
		dwPort = DPSTRESS_PORT;
		hr = pDP8HostAddress->AddComponent(DPNA_KEY_PORT, &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't add a specific port to the host object: %0x%08x", hr);
			goto Exit;
		}

		ResetEvent(hEnumEvent);
		xLog(hLog, XLL_INFO, "Enumerating host with port, but no IP address");

		hr = pDP8Peer->EnumHosts(&dpnad, pDP8HostAddress, pDP8DeviceAddress, pBuffer, dwBufferSize,
			0, 0, 0, hEnumEvent, &AsyncHandle, 0);
		if (hr != (HRESULT) DPNSUCCESS_PENDING)
		{
			xLog(hLog, XLL_WARN, "Couldn't enumerate hosts: 0x%08x", hr);
			goto Exit;
		}

		// Waiting for enumeration to complete
		if(!PollPeerUntilEventSignalled(hLog, pDP8Peer, MAX_ENUM_TIME, hEnumEvent, NULL))
			xLog(hLog, XLL_WARN, "Enumeration with port, but no IP address couldn't find host");

		// Cancel to enum to make sure that it's complete before starting the next enum
		hr = pDP8Peer->CancelAsyncOperation(0, DPNCANCEL_ENUM);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't cancel asynchronous enumeration!", hr);
			goto Exit;
		}

		MemFree(pBuffer);
		pBuffer = NULL;
		dwBufferSize = 0;

		//----------------------------------------
		// 3) HOST PORT AND HOST IP PROVIDED
		//----------------------------------------

		// Allocate a buffer of random enum data
		if(!(dwBufferSize = GenerateRandomDataBuffer(&pBuffer, ENUM_DATA_MIN_SIZE, ENUM_DATA_MAX_SIZE)))
		{
			xLog(hLog, XLL_WARN, "Couldn't generate random buffer for enumeration request data");
			goto Exit;
		}

		pDP8HostAddress->Clear();

		hr = pDP8HostAddress->BuildFromSockAddr( (SOCKADDR *) &HostSockAddr);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't build an address from a SOCKADDR: %0x%08x", hr);
			goto Exit;
		}

		ResetEvent(hEnumEvent);
		xLog(hLog, XLL_INFO, "Enumerating host with both port and IP address");

		hr = pDP8Peer->EnumHosts(&dpnad, pDP8HostAddress, pDP8DeviceAddress, pBuffer, dwBufferSize,
			0, 0, 0, hEnumEvent, &AsyncHandle, 0);
		if (hr != (HRESULT) DPNSUCCESS_PENDING)
		{
			xLog(hLog, XLL_WARN, "Couldn't enumerate hosts: 0x%08x", hr);
			goto Exit;
		}

		// Waiting for enumeration to complete
		if(!PollPeerUntilEventSignalled(hLog, pDP8Peer, MAX_ENUM_TIME, hEnumEvent, NULL))
		{
			xLog(hLog, XLL_WARN, "Enumeration with both port and IP address couldn't find host!");
			goto Exit;
		}

		// Cancel to enum to make sure that it's complete before starting the next enum
		hr = pDP8Peer->CancelAsyncOperation(0, DPNCANCEL_ENUM);
		if(hr != DPN_OK)
		{
			xLog(hLog, XLL_WARN, "Couldn't cancel asynchronous enumeration!", hr);
			goto Exit;
		}

		MemFree(pBuffer);
		pBuffer = NULL;
		dwBufferSize = 0;

		//----------------------------------------
		// NON-HOST STARTS CONNECTING
		//----------------------------------------
		
		xLog(hLog, XLL_INFO, "Connecting local peer to remote host...");

		// Allocate a player context for the local player
		pLocalPlayerContext = NULL;
		pLocalPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
		memset(pLocalPlayerContext, 0, sizeof(PLAYERCONTEXT));

		if(!pLocalPlayerContext)
		{
			xLog(hLog, XLL_WARN, "Couldn't allocate local player context");
			goto Exit;
		}

		// Allocate a buffer of random connect data
		if(!(dwBufferSize = GenerateRandomDataBuffer(&pBuffer, CONN_DATA_MIN_SIZE, CONN_DATA_MAX_SIZE)))
		{
			xLog(hLog, XLL_WARN, "Couldn't generate random buffer for enumeration request data");
			goto Exit;
		}

		hr = pDP8Peer->Connect(&dpnad, pDP8HostAddress, pDP8DeviceAddress, NULL, NULL, pBuffer, dwBufferSize,
			pLocalPlayerContext, NULL, &AsyncHandle, 0);

		if (hr != (HRESULT) DPNSUCCESS_PENDING)
		{
			xLog(hLog, XLL_WARN, "Couldn't connect to host: 0x%08x", hr);
			goto Exit;
		}

		// Waiting for enumeration to complete
		if(!PollPeerUntilEventSignalled(hLog, pDP8Peer, MAX_CONN_TIME, PeerStressContext.hConnectComplete, NULL))
		{
			xLog(hLog, XLL_WARN, "Connection didn't succeed within %u seconds", MAX_CONN_TIME / 1000);
			goto Exit;
		}
	}

	xLog(hLog, XLL_INFO, "Starting random work loop...");

	dwLastMemTime = GetTickCount();

	// Start the main test loop
	while(WAIT_TIMEOUT == WaitForSingleObject(PeerStressContext.hSessionTerminated, 0))
	{
		dwLoopStartTime = GetTickCount();

		g_hrLastError = DPN_OK;

		PerformRandomDirectPlayWork(hLog, pDP8Peer, &PeerStressContext);

		if(g_hrLastError != DPN_OK)
		{
			DWORD dwWaitResult;
			dwWaitResult = WaitForSingleObject(PeerStressContext.hSessionTerminated, 0);
			switch(dwWaitResult)
			{
			case WAIT_TIMEOUT:
				TRACE(TEXT("Got unexpected DirectPlay error (0x%08x) and session hasn't terminated.\n"), g_hrLastError);
				break;
			case WAIT_OBJECT_0:
				TRACE(TEXT("Got unexpected DirectPlay error (0x%08x) but session has already terminated.\n"), g_hrLastError);
				break;
			default:
				TRACE(TEXT("Got unexpected DirectPlay error (0x%08x) and wait on session termination failed.\n"), g_hrLastError);
				break;
			}

			DisplayStressStatistics(hLog, &PeerStressContext, dwLastMinAvail, dwLastMinAppAlloc, dwMinAvail);

			goto Exit;
		}


		DoWorkForFixedInterval<IDirectPlay8Peer>(pDP8Peer, 2);
		
		if(IsNetsyncSessionOver(hNetsync))
		{
			// Netsync signalled that it couldn't maintain the session any longer.  Probably because
			// multiple machines think they are host after a connection was lost.
			// Exit and resync with Netsync
			xLog(hLog, XLL_WARN, "Netsync signalled that the session is over");
			goto Exit;
		}

		if(PeerStressContext.fIsHost)
		{	
			// Check to see if the host has migrated to this machine
			// A newly migrated machine won't have set fStartedAsHost to TRUE yet
			if(!fStartedAsHost)
			{
				// If it has, send an update to the Netsync server and
				// act as though we were started as the host, so we won't
				// continue to send Netsync updates
				
				if(SendNetsyncHostUpdate(hNetsync, pLocalAddr) == WAIT_FAILED)
				{
					// We have to exit in this case, otherwise, Netsync will be sending new peers to the old host
					xLog(hLog, XLL_WARN, "Couldn't update Netsync server with migrated host information");
					goto Exit;
				}
				
				fStartedAsHost = TRUE;

				dwLastKATime = GetTickCount();
			}

			// If this isn't a newly migrated host, see if we need to send a keepalive
			else
			{
				// Calculate the amount of time that has elapsed since the last keepalive
				if(dwLoopStartTime < dwLastKATime)
					dwTimeElapsed = ((DWORD) 0xffffffff) - dwLastKATime + dwLoopStartTime;
				else
					dwTimeElapsed = dwLoopStartTime - dwLastKATime;

				// If the time has come, send a keepalive
				if(dwTimeElapsed > HOST_KEEPALIVE_INTERVAL)
				{
					if(SendNetsyncHostKeepalive(hNetsync) == WAIT_FAILED)
					{
						// We have to exit in this case, otherwise, the Netsync server will remove us anyway
						xLog(hLog, XLL_WARN, "Couldn't send keepalive to Netsync server");
						goto Exit;
					}

					dwLastKATime = GetTickCount();
				}
			}
		}

		memset(&MemoryStatus, 0, sizeof(MEMORYSTATUS));
		MemoryStatus.dwLength = sizeof(MEMORYSTATUS);
		GlobalMemoryStatus (&MemoryStatus);

		// We add back the memory allocated by the app so that DirectPlay isn't penalized for it
		// But if the adjusted amount of available memory is below the previous minimum, record it
		if((MemoryStatus.dwAvailPhys + g_dwDPStressBytesAllocated) < dwMinAvail)
		{
			dwMinAvail = MemoryStatus.dwAvailPhys + g_dwDPStressBytesAllocated;
			dwLastMinAppAlloc = g_dwDPStressBytesAllocated;
			dwLastMinAvail = MemoryStatus.dwAvailPhys;
		}

		// Calculate the amount of time that has elapsed since the last keepalive
		if(dwLoopStartTime < dwLastMemTime)
			dwTimeElapsed = ((DWORD) 0xffffffff) - dwLastMemTime + dwLoopStartTime;
		else
			dwTimeElapsed = dwLoopStartTime - dwLastMemTime;

		if(dwTimeElapsed > 1800000)
		{
			DisplayStressStatistics(hLog, &PeerStressContext, dwLastMinAvail, dwLastMinAppAlloc, dwMinAvail);
			dwLastMemTime = GetTickCount();
		}

		if(g_hrLastError != DPN_OK)
		{

			xLog(hLog, XLL_WARN, "Error 0x%08x was returned from a DirectPlay call, exiting test...", g_hrLastError);
			goto Exit;
		}
	}
	
Exit:
	PeerStressContext.pExpectedHostAddress ? PeerStressContext.pExpectedHostAddress->Release() : 0;
	PeerStressContext.pExpectedHostAddress = NULL;

	pBuffer ? MemFree(pBuffer) : 0;
	pBuffer = NULL;
	SAFE_CLOSEHANDLE(hEnumEvent);

	if(fPeerInitialized && pDP8Peer)
	{
		hr = pDP8Peer->Close(0);
		if(hr != DPN_OK)
			xLog(hLog, XLL_FAIL, "Couldn't close DPlay peer: 0x%08x", hr);
		else
			xLog(hLog, XLL_INFO, "DirectPlay peer closed");
	}

	pDP8Peer ? pDP8Peer->Release() : 0;
	pDP8Peer = NULL;

	pDP8DeviceAddress ? pDP8DeviceAddress->Release() : 0;
	pDP8DeviceAddress = NULL;

	pDP8HostAddress ? pDP8HostAddress->Release() : 0;
	pDP8HostAddress = NULL;

	if(fDPlayInitialized)
	{
		hr = DPlayCleanup();
		if(hr != DPN_OK)
			xLog(hLog, XLL_FAIL, "Couldn't cleanup DPlay: 0x%08x", hr);
		else
			xLog(hLog, XLL_INFO, "DirectPlay layer cleaned-up");
	}

	CleanupPeerStressContext(&PeerStressContext);

	xLog(hLog, XLL_INFO, "Exiting test...");

	Sleep(30000);

	return TRUE;
}


#undef DEBUG_SECTION
#define DEBUG_SECTION	"PeerStressMessageHandler()"
//==================================================================================
// PeerStressMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerStressMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT				hr = DPN_OK;
	PEERSTRESSCONTEXT	*pContext = (PEERSTRESSCONTEXT *) pvContext;
	PPLAYERCONTEXT		pPlayerContext = NULL;
	BOOL				fLocalPlayer = TRUE;
	DWORD				dwStartTime = 0, dwEndTime = 0, n = 0;
	
	dwStartTime = GetTickCount();
	
	switch (dwMsgType)
	{
	case DPN_MSGID_CREATE_PLAYER:
		{
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;
			
			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_CREATE_PLAYER");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pCreatePlayerMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidPlayer = %u/0x%08x", pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pCreatePlayerMsg->pvPlayerContext);
			}
			
			// If this is a local player, then take the buffer that we allocated when we hosted
			// or connected
			if(pCreatePlayerMsg->pvPlayerContext)
			{
				fLocalPlayer = TRUE;
				
				pContext->LocalPlayerID = pCreatePlayerMsg->dpnidPlayer;
				pPlayerContext = ((PPLAYERCONTEXT) pCreatePlayerMsg->pvPlayerContext);
			}
			// Otherwise this is a remote player.  Create a new buffer.
			else
			{
				fLocalPlayer = FALSE;
				
				pPlayerContext = (PPLAYERCONTEXT) MemAlloc(sizeof(PLAYERCONTEXT));
				if(!pPlayerContext)
				{
					xLog(pContext->hLog, XLL_WARN, "Not enough memory to allocate player context!  Signal main app!");
					
					SetEvent(pContext->hCriticalError);
					hr = E_FAIL;
					break;
				}
				
				pCreatePlayerMsg->pvPlayerContext = pPlayerContext;
			}
			
			// Initialize the player information
			pPlayerContext->PlayerID = pCreatePlayerMsg->dpnidPlayer;
			pPlayerContext->TotalBytesReceived = 0;
			pPlayerContext->TotalMessagesReceived = 0;
			
			// Add info on this player to our global player list
			EnterCriticalSection(&(pContext->Lock));
			
			pPlayerContext->pPrev = NULL;
			if(pContext->pPlayerList)
				pContext->pPlayerList->pPrev = pPlayerContext->pNext;
			pPlayerContext->pNext = pContext->pPlayerList;
			pContext->pPlayerList = pPlayerContext;
			
			++pContext->dwPlayersConnected;
			
			LeaveCriticalSection(&(pContext->Lock));
		}
		
		break;
		
	case DPN_MSGID_DESTROY_PLAYER:
		{
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;
			
			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			if(pContext->fVerbose)
			{
				CHAR					szReason[64] = "";
				
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_DESTROY_PLAYER");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pDestroyPlayerMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidPlayer = %u/0x%08x", pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pDestroyPlayerMsg->pvPlayerContext);
				
				switch(pDestroyPlayerMsg->dwReason)
				{
				case DPNDESTROYPLAYERREASON_NORMAL:
					strcpy(szReason, "NORMAL");
					break;
				case DPNDESTROYPLAYERREASON_CONNECTIONLOST:
					strcpy(szReason, "CONNECTIONLOST");
					break;
				case DPNDESTROYPLAYERREASON_SESSIONTERMINATED:
					strcpy(szReason, "SESSIONTERMINATED");
					break;
				case DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER:
					strcpy(szReason, "HOSTDESTROYEDPLAYER");
					break;
				default:
					xLog(pContext->hLog, XLL_WARN, "Unknown player destroy reason!");
					break;
				}
				
				xLog(pContext->hLog, XLL_INFO, "     dwReason = %s", szReason);
			}
			
			pPlayerContext = (PPLAYERCONTEXT) pDestroyPlayerMsg->pvPlayerContext;
			
			if(!pPlayerContext)
			{
				xLog(pContext->hLog, XLL_WARN, "No player context received!  Signal main app!");
				
				SetEvent(pContext->hCriticalError);
				hr = E_FAIL;
				break;
			}
			
			// Remove this player from our global player list
			EnterCriticalSection(&(pContext->Lock));
			
			if(pPlayerContext->pNext)
				pPlayerContext->pNext->pPrev = pPlayerContext->pPrev;
			if(pPlayerContext->pPrev)
				pPlayerContext->pPrev->pNext = pPlayerContext->pNext;
			else
				pContext->pPlayerList = pPlayerContext->pNext;
			
			--pContext->dwPlayersConnected;
			
			LeaveCriticalSection(&(pContext->Lock));
			
			// Release the player context
			MemFree(pPlayerContext);
		}
		break;
		
	case DPN_MSGID_CREATE_GROUP:
		{
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;
			
			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_CREATE_GROUP");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pCreateGroupMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidGroup = %u/0x%08x", pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
				xLog(pContext->hLog, XLL_INFO, "     dpnidOwner = %u/0x%08x", pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pCreateGroupMsg->pvGroupContext);
			}

			// This group was created locally...
			if(pCreateGroupMsg->pvGroupContext)
			{
				// Find an empty slot in the local group list
				for(n = 0;n < MAX_GROUPS;++n)
				{
					// Store the new group ID in the first empty slot
					if(!pContext->LocalGroupIDs[n])
					{
						pContext->LocalGroupIDs[n] = pCreateGroupMsg->dpnidGroup;
						break;
					}
				}

				// This should never happen...
				// The main loop will only call CreateGroup if we have less than the max number of groups
				if(n == MAX_GROUPS)
					xLog(pContext->hLog, XLL_WARN, "Got a local group creation, but there are no slots left!");
			}
		}
		break;
		
	case DPN_MSGID_DESTROY_GROUP:
		{
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;
			
			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;
			
			if(pContext->fVerbose)
			{
				CHAR					szReason[64] = "";
				
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_DESTROY_GROUP");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pDestroyGroupMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidGroup = %u/0x%08x", pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
				xLog(pContext->hLog, XLL_INFO, "     pvGroupContext = 0x%08x", pDestroyGroupMsg->pvGroupContext);
				
				switch(pDestroyGroupMsg->dwReason)
				{
				case DPNDESTROYGROUPREASON_SESSIONTERMINATED:
					strcpy(szReason, "SESSIONTERMINATED");
					break;
				default:
					xLog(pContext->hLog, XLL_WARN, "Unknown group destroy reason!");
					break;
				}
				
				xLog(pContext->hLog, XLL_INFO, "     dwReason = %s", szReason);
			}
		}
		break;
		
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
		{
			PDPNMSG_ADD_PLAYER_TO_GROUP	pAddPlayerMsg;
			
			pAddPlayerMsg = (PDPNMSG_ADD_PLAYER_TO_GROUP) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_ADD_PLAYER_TO_GROUP");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pAddPlayerMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidGroup = %u/0x%08x", pAddPlayerMsg->dpnidGroup, pAddPlayerMsg->dpnidGroup);
				xLog(pContext->hLog, XLL_INFO, "     pvGroupContext = 0x%08x", pAddPlayerMsg->pvGroupContext);
				xLog(pContext->hLog, XLL_INFO, "     dpnidPlayer = %u/0x%08x", pAddPlayerMsg->dpnidPlayer, pAddPlayerMsg->dpnidPlayer);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pAddPlayerMsg->pvPlayerContext);
			}
		}
		break;
		
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			PDPNMSG_REMOVE_PLAYER_FROM_GROUP	pRemovePlayerMsg;
			
			pRemovePlayerMsg = (PDPNMSG_REMOVE_PLAYER_FROM_GROUP) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_REMOVE_PLAYER_FROM_GROUP");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pRemovePlayerMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidGroup = %u/0x%08x", pRemovePlayerMsg->dpnidGroup, pRemovePlayerMsg->dpnidGroup);
				xLog(pContext->hLog, XLL_INFO, "     pvGroupContext = 0x%08x", pRemovePlayerMsg->pvGroupContext);
				xLog(pContext->hLog, XLL_INFO, "     dpnidPlayer = %u/0x%08x", pRemovePlayerMsg->dpnidPlayer, pRemovePlayerMsg->dpnidPlayer);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pRemovePlayerMsg->pvPlayerContext);
			}
		}
		break;
		
	case DPN_MSGID_INDICATE_CONNECT:
		{
			PDPNMSG_INDICATE_CONNECT pIndicateConnectMsg;
			
			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;
			
			if(pContext->fVerbose)
			{
				LPSTR szAddress = NULL;
				
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_INDICATE_CONNECT");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pIndicateConnectMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     pvUserConnectData = 0x%08x", pIndicateConnectMsg->pvUserConnectData);
				xLog(pContext->hLog, XLL_INFO, "     dwUserConnectDataSize = %u", pIndicateConnectMsg->dwUserConnectDataSize);
				xLog(pContext->hLog, XLL_INFO, "     pvReplyData = 0x%08x", pIndicateConnectMsg->pvReplyData);
				xLog(pContext->hLog, XLL_INFO, "     dwReplyDataSize = %u", pIndicateConnectMsg->dwReplyDataSize);
				xLog(pContext->hLog, XLL_INFO, "     pvReplyContext = 0x%08x", pIndicateConnectMsg->pvReplyContext);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pIndicateConnectMsg->pvPlayerContext);
				
				// Parse the player address
				szAddress = NULL;
				szAddress = GetAddressString(pIndicateConnectMsg->pAddressPlayer);
				xLog(pContext->hLog, XLL_INFO, "     pAddressPlayer = %s",
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
				
				// Parse the device address
				szAddress = NULL;
				szAddress = GetAddressString(pIndicateConnectMsg->pAddressDevice);
				xLog(pContext->hLog, XLL_INFO, "     pAddressDevice = %s",
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
			}
			
			if(!pContext->fIsHost)
			{
				xLog(pContext->hLog, XLL_WARN, "INDICATED_CONNECT shouldn't be called on non-host!");
			}
			
			// Parse any connect data if present
			if(pIndicateConnectMsg->pvUserConnectData)
			{
				if(!VerifyDataBuffer(pIndicateConnectMsg->pvUserConnectData, pIndicateConnectMsg->dwUserConnectDataSize))
				{
					xLog(pContext->hLog, XLL_WARN, "Received invalid connect data! (%u bytes)",
						pIndicateConnectMsg->dwUserConnectDataSize);
				}
				else
				{
					// Generate a connect reply buffer
					if(!(pIndicateConnectMsg->dwReplyDataSize = 
						GenerateRandomDataBuffer((BYTE **) &(pIndicateConnectMsg->pvReplyData), CONNREPLY_DATA_MIN_SIZE, CONNREPLY_DATA_MAX_SIZE)))
					{
						xLog(pContext->hLog, XLL_WARN, "Couldn't generate random buffer for connect reply data");
						pIndicateConnectMsg->pvReplyData = NULL;
					}
				}
			}
			
			// Signal the main thread that a connection was indicated
			SetEvent(pContext->hConnectComplete);
		}
		break;
		
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			PDPNMSG_INDICATED_CONNECT_ABORTED pIndicateConnectAbortedMsg;
			
			pIndicateConnectAbortedMsg = (PDPNMSG_INDICATED_CONNECT_ABORTED) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_INDICATED_CONNECT_ABORTED");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pIndicateConnectAbortedMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pIndicateConnectAbortedMsg->pvPlayerContext);
			}
		}
		break;
		
		
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
			
			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_CONNECT_COMPLETE");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pConnectCompleteMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     hAsyncOp = 0x%08x", pConnectCompleteMsg->hAsyncOp);
				// BUGBUG - compare this with what was passed in to connect
				xLog(pContext->hLog, XLL_INFO, "     pvUserContext = 0x%08x", pConnectCompleteMsg->pvUserContext);
				xLog(pContext->hLog, XLL_INFO, "     hResultCode = 0x%08x", pConnectCompleteMsg->hResultCode);
				xLog(pContext->hLog, XLL_INFO, "     pvApplicationReplyData = 0x%08x", pConnectCompleteMsg->pvApplicationReplyData);
				xLog(pContext->hLog, XLL_INFO, "     dwApplicationReplyDataSize = %u", pConnectCompleteMsg->dwApplicationReplyDataSize);
			}
			
			if(pContext->fIsHost)
			{
				xLog(pContext->hLog, XLL_WARN, "CONNECT_COMPLETE shouldn't be called on host!");
			}
			
			// Parse any reply data if present
			if(pConnectCompleteMsg->dwApplicationReplyDataSize)
			{
				if(!VerifyDataBuffer(pConnectCompleteMsg->pvApplicationReplyData, pConnectCompleteMsg->dwApplicationReplyDataSize))
				{
					xLog(pContext->hLog, XLL_WARN, "Received invalid connect reply data! (%u bytes)",
						pConnectCompleteMsg->dwApplicationReplyDataSize);
				}
			}
			
			// Signal the main thread that connection completed
			SetEvent(pContext->hConnectComplete);
		}
		break;
		
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			PDPNMSG_ENUM_HOSTS_QUERY pEnumQueryMsg;
			
			pEnumQueryMsg = (PDPNMSG_ENUM_HOSTS_QUERY) pvMsg;
			
			if(pContext->fVerbose)
			{
				LPSTR szAddress = NULL;
				
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_ENUM_HOSTS_QUERY");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pEnumQueryMsg->dwSize);
				
				// Parse the player address
				szAddress = NULL;
				szAddress = GetAddressString(pEnumQueryMsg->pAddressSender);
				xLog(pContext->hLog, XLL_INFO, "     pAddressSender = %s",
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
				
				// Parse the device address
				szAddress = NULL;
				szAddress = GetAddressString(pEnumQueryMsg->pAddressDevice);
				xLog(pContext->hLog, XLL_INFO, "     pAddressDevice = %s",
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
				
				xLog(pContext->hLog, XLL_INFO, "     pvReceivedData = 0x%08x", pEnumQueryMsg->pvReceivedData);
				xLog(pContext->hLog, XLL_INFO, "     dwReceivedDataSize = %u", pEnumQueryMsg->dwReceivedDataSize);
				xLog(pContext->hLog, XLL_INFO, "     dwMaxResponseDataSize = %u", pEnumQueryMsg->dwMaxResponseDataSize);
				xLog(pContext->hLog, XLL_INFO, "     pvResponseData = 0x%08x", pEnumQueryMsg->pvResponseData);
				xLog(pContext->hLog, XLL_INFO, "     dwResponseDataSize = %u", pEnumQueryMsg->dwResponseDataSize);
				xLog(pContext->hLog, XLL_INFO, "     pvResponseContext = 0x%08x", pEnumQueryMsg->pvResponseContext);
				
			}
			else
			{
				LPSTR szAddress = NULL;
				
				// Parse the player address
				szAddress = NULL;
				szAddress = GetAddressString(pEnumQueryMsg->pAddressSender);
				xLog(pContext->hLog, XLL_INFO, "Received enumeration query from %s", 
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
			}
			
			if(!pContext->fIsHost)
			{
				xLog(pContext->hLog, XLL_WARN, "ENUM_HOSTS_QUERY shouldn't be called on non-host!");
			}
			
			// Parse any request data if present
			if(pEnumQueryMsg->pvReceivedData)
			{
				if(!VerifyDataBuffer(pEnumQueryMsg->pvReceivedData, pEnumQueryMsg->dwReceivedDataSize))
				{
					xLog(pContext->hLog, XLL_WARN, "Received invalid enum query data! (%u bytes)",
						pEnumQueryMsg->dwReceivedDataSize);
				}
				else
				{
					// Generate a connect reply buffer
					if(!(pEnumQueryMsg->dwResponseDataSize = 
						GenerateRandomDataBuffer((BYTE **) &(pEnumQueryMsg->pvResponseData), ENUMREPLY_DATA_MIN_SIZE, pEnumQueryMsg->dwMaxResponseDataSize)))
					{
						xLog(pContext->hLog, XLL_WARN, "Couldn't generate random buffer for enum reply data");
						pEnumQueryMsg->pvReceivedData = NULL;
					}
				}
			}
		}
		break;
		
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			PDPNMSG_ENUM_HOSTS_RESPONSE pEnumResponseMsg;
			
			pEnumResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE) pvMsg;
			
			if(pContext->fVerbose)
			{
				LPSTR szAddress = NULL;
				
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_ENUM_HOSTS_RESPONSE");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pEnumResponseMsg->dwSize);
				
				// Parse the player address
				szAddress = NULL;
				szAddress = GetAddressString(pEnumResponseMsg->pAddressSender);
				xLog(pContext->hLog, XLL_INFO, "     pAddressSender = %s",
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
				
				// Parse the device address
				szAddress = NULL;
				szAddress = GetAddressString(pEnumResponseMsg->pAddressDevice);
				xLog(pContext->hLog, XLL_INFO, "     pAddressDevice = %s",
					szAddress ? szAddress : "unknown" );
				szAddress ? MemFree(szAddress) : 0;
				
				xLog(pContext->hLog, XLL_INFO, "     pApplicationDescription = 0x%08x", pEnumResponseMsg->pApplicationDescription);
				xLog(pContext->hLog, XLL_INFO, "     pvResponseData = 0x%08x", pEnumResponseMsg->pvResponseData);
				xLog(pContext->hLog, XLL_INFO, "     dwResponseDataSize = %u", pEnumResponseMsg->dwResponseDataSize);
				xLog(pContext->hLog, XLL_INFO, "     pvUserContext = 0x%08x", pEnumResponseMsg->pvUserContext);
				xLog(pContext->hLog, XLL_INFO, "     dwRoundTripLatencyMS = %u", pEnumResponseMsg->dwRoundTripLatencyMS);
			}
			else
			{
				LPSTR szAddress = NULL;
				
				// Parse the player address
				szAddress = NULL;
				szAddress = GetAddressString(pEnumResponseMsg->pAddressSender);
				xLog(pContext->hLog, XLL_INFO, "Received enumeration response from %s (%u ms latency)", 
					szAddress ? szAddress : "unknown", pEnumResponseMsg->dwRoundTripLatencyMS);
				szAddress ? MemFree(szAddress) : 0;
			}
			
			if(pContext->fIsHost)
			{
				xLog(pContext->hLog, XLL_WARN, "ENUM_HOSTS_RESPONSE shouldn't be called on host!");
			}
			
			// Parse any response data if present
			if(pEnumResponseMsg->pvResponseData)
			{
				if(!VerifyDataBuffer(pEnumResponseMsg->pvResponseData, pEnumResponseMsg->dwResponseDataSize))
				{
					xLog(pContext->hLog, XLL_WARN, "Received invalid enum response data! (%u bytes)",
						pEnumResponseMsg->dwResponseDataSize);
				}
			}

			if(pContext->pExpectedHostAddress)
			{
				if(pEnumResponseMsg->pAddressSender->IsEqual(pContext->pExpectedHostAddress) == DPNSUCCESS_EQUAL)
				{
					xLog(pContext->hLog, XLL_INFO, "Enum response is from expected host.");
					pEnumResponseMsg->pvUserContext ? SetEvent((HANDLE) pEnumResponseMsg->pvUserContext) : 0;
				}
				else
				{
					xLog(pContext->hLog, XLL_INFO, "Enum response is from unexpected host.");
				}
			}
			else
			{
				xLog(pContext->hLog, XLL_INFO, "ENUM_HOSTS_RESPONSE was called but no address has been set to compare it with!");
			}

		}
		break;
		
	case DPN_MSGID_RECEIVE:
		{
			PDPNMSG_RECEIVE pReceiveMsg;
			
			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_RECEIVE", 0);
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pReceiveMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidSender = %u/0x%08x", pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pReceiveMsg->pvPlayerContext);
				// BUGBUG - create a common message format that contains the sender information
				// so that we can verify that this data is accurate
				xLog(pContext->hLog, XLL_INFO, "     pReceiveData = 0x%08x", pReceiveMsg->pReceiveData);
				xLog(pContext->hLog, XLL_INFO, "     dwReceiveDataSize = %u", pReceiveMsg->dwReceiveDataSize);
				// BUGBUG - try holding onto this buffer and returning it on subsequent calls to receive
				// Use the buffer handle to return it later.  Maybe store the last buffer handle received
				// in the players context.
				xLog(pContext->hLog, XLL_INFO, "     hBufferHandle = 0x%08x", pReceiveMsg->hBufferHandle);
			}
			
			// Verify that the received buffer is valid
			if(pReceiveMsg->dwReceiveDataSize)
			{
				if(!VerifyDataBuffer(pReceiveMsg->pReceiveData, pReceiveMsg->dwReceiveDataSize))
				{
					xLog(pContext->hLog, XLL_WARN, "Received invalid player message! (%u bytes)",
						pReceiveMsg->dwReceiveDataSize);
				}
			}
			else
			{
				xLog(pContext->hLog, XLL_WARN, "Received message with 0 bytes!");
			}
			
			// Because messages from the same player are serialized, we know that DELETE_PLAYER can't come along
			// and remove this context before we access it... so there is no need to lock the critical section.
			
			if(!pReceiveMsg->pvPlayerContext)
			{
				xLog(pContext->hLog, XLL_WARN, "Received message from unknown player: 0x%08x", pReceiveMsg->dpnidSender);
			}
			else
			{
				// Update the player context entry to reflect the received message
				pPlayerContext = (PPLAYERCONTEXT) pReceiveMsg->pvPlayerContext;
				++(pPlayerContext->TotalMessagesReceived);
				(pPlayerContext->TotalBytesReceived) += pReceiveMsg->dwReceiveDataSize;
			}
		}
		break;
	case DPN_MSGID_SEND_COMPLETE:
		{
			PDPNMSG_SEND_COMPLETE pSendCompleteMsg;
			
			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_SEND_COMPLETE");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pSendCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of a send
				// that we have outstanding
				xLog(pContext->hLog, XLL_INFO, "     hAsyncOp = 0x%08x", pSendCompleteMsg->hAsyncOp);
				// BUGBUG - again check with the context and verify that this is the context that we
				// supplied with a call to send
				xLog(pContext->hLog, XLL_INFO, "     pvUserContext = 0x%08x", pSendCompleteMsg->pvUserContext);
				// BUGBUG - are there ways to get this value to be a failure?
				xLog(pContext->hLog, XLL_INFO, "     hResultCode = 0x%08x", pSendCompleteMsg->hResultCode);
				// BUGBUG - do lots of sends and see if this increases, what about guaranteed?
				xLog(pContext->hLog, XLL_INFO, "     dwSendTime = %u ms", pSendCompleteMsg->dwSendTime);
			}
		}
		break;
		
	case DPN_MSGID_APPLICATION_DESC:
		{
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_APPLICATION_DESC");
			}
			
			++pContext->dwAppDescChangeCounter;
		}
		break;
		
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
			
			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_ASYNC_OP_COMPLETE");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pAsyncOpCompleteMsg->dwSize);
				// BUGBUG - check with the context and verify that this is the handle of an operation
				// that we have outstanding
				xLog(pContext->hLog, XLL_INFO, "     hAsyncOp = %u", pAsyncOpCompleteMsg->hAsyncOp);
				// BUGBUG - are there ways to get this value to be a failure?
				xLog(pContext->hLog, XLL_INFO, "     hResultCode = 0x%08x", pAsyncOpCompleteMsg->hResultCode);
			}
		}
		break;
		
	case DPN_MSGID_PEER_INFO:
		{
			PDPNMSG_PEER_INFO pPeerInfoMsg;
			
			pPeerInfoMsg = (PDPNMSG_PEER_INFO) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_PEER_INFO");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pPeerInfoMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidPeer = %u/0x%08x", pPeerInfoMsg->dpnidPeer, pPeerInfoMsg->dpnidPeer);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pPeerInfoMsg->pvPlayerContext);
			}
			
			// Because messages from the same player are serialized, we know that DELETE_PLAYER can't come along
			// and remove this context before we access it... so there is no need to lock the critical section.
			
			if(!pPeerInfoMsg->pvPlayerContext)
			{
				xLog(pContext->hLog, XLL_WARN, "Received player info change from unknown player: 0x%08x", pPeerInfoMsg->dpnidPeer);
			}
			else
			{
				// Update the player context entry to reflect the received message
				pPlayerContext = (PPLAYERCONTEXT) pPeerInfoMsg->pvPlayerContext;
				++pPlayerContext->dwPlayerInfoChangeCounter;
			}
		}
		break;
		
	case DPN_MSGID_GROUP_INFO:
		{
			PDPNMSG_GROUP_INFO pGroupInfoMsg;
			
			pGroupInfoMsg = (PDPNMSG_GROUP_INFO) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_GROUP_INFO");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pGroupInfoMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidGroup = %u/0x%08x", pGroupInfoMsg->dpnidGroup, pGroupInfoMsg->dpnidGroup);
				// BUGBUG - verify that the player context matches the player context that was set when
				// this player connected
				xLog(pContext->hLog, XLL_INFO, "     pvGroupContext = 0x%08x", pGroupInfoMsg->pvGroupContext);
			}
		}
		break;
		
	case DPN_MSGID_TERMINATE_SESSION:
		{
			PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
			
			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;
		
			TRACE(TEXT("TERMINATE_SESSION message received!\n"));
			xLog(pContext->hLog, XLL_WARN, "TERMINATE_SESSION message received!");

			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_TERMINATE_SESSION");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pTerminateSessionMsg->dwSize);
				// BUGBUG - check the context and verify the difference between the host calling\
				// close and the host calling terminate session.
				xLog(pContext->hLog, XLL_INFO, "     hResultCode = 0x%08x", pTerminateSessionMsg->hResultCode);
				// BUGBUG - check with the context and verify whether or not data should have been provided
				xLog(pContext->hLog, XLL_INFO, "     pvTerminateData = 0x%08x", pTerminateSessionMsg->pvTerminateData);
				xLog(pContext->hLog, XLL_INFO, "     dwTerminateDataSize = %u", pTerminateSessionMsg->dwTerminateDataSize);
			}
			
			// Verify that the received buffer is valid
			if(pTerminateSessionMsg->dwTerminateDataSize)
			{
				if(!VerifyDataBuffer(pTerminateSessionMsg->pvTerminateData, pTerminateSessionMsg->dwTerminateDataSize))
				{
					xLog(pContext->hLog, XLL_WARN, "Received invalid terminate session data! (%u bytes)",
						pTerminateSessionMsg->dwTerminateDataSize);
				}
			}
			
			// Signal the main thread that the session terminated
			SetEvent(pContext->hSessionTerminated);
		}
		break;
		
	case DPN_MSGID_RETURN_BUFFER:
		{
			PDPNMSG_RETURN_BUFFER pReturnBufferMsg;
			
			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_RETURN_BUFFER");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pReturnBufferMsg->dwSize);
				// BUGBUG - in enum cases, this could be an error, otherwise, should be success
				xLog(pContext->hLog, XLL_INFO, "     hResultCode = 0x%08x", pReturnBufferMsg->hResultCode);
				xLog(pContext->hLog, XLL_INFO, "     pvBuffer = 0x%08x", pReturnBufferMsg->pvBuffer);
				// BUGBUG - this should probably only be set in concurrent enumeration cases
				xLog(pContext->hLog, XLL_INFO, "     pvUserContext = 0x%08x", pReturnBufferMsg->pvUserContext);
			}
			
			if(!pReturnBufferMsg->pvBuffer)
			{
				xLog(pContext->hLog, XLL_WARN, "Return buffer message with invalid buffer!  Signal main app!");
				
				SetEvent(pContext->hCriticalError);
				hr = E_FAIL;
				break;
			}
			
			MemFree(pReturnBufferMsg->pvBuffer);
		}
		break;
		
	case DPN_MSGID_HOST_MIGRATE:
		{
			PDPNMSG_HOST_MIGRATE pHostMigrateMsg;
			
			pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE) pvMsg;
			
			if(pContext->fVerbose)
			{
				xLog(pContext->hLog, XLL_INFO, "DPN_MSGID_HOST_MIGRATE");
				xLog(pContext->hLog, XLL_INFO, "     dwSize = %u", pHostMigrateMsg->dwSize);
				xLog(pContext->hLog, XLL_INFO, "     dpnidNewHost = %u", pHostMigrateMsg->dpnidNewHost);
				xLog(pContext->hLog, XLL_INFO, "     pvPlayerContext = 0x%08x", pHostMigrateMsg->pvPlayerContext);
			}
			
			if(pContext->fIsHost)
			{
				xLog(pContext->hLog, XLL_WARN, "Received host migration message on host!  Signal main app!");
				
				SetEvent(pContext->hCriticalError);
				hr = E_FAIL;
				break;
			}
			
			if(pHostMigrateMsg->dpnidNewHost == pContext->LocalPlayerID)
			{
				xLog(pContext->hLog, XLL_INFO, "Host has migrated to this machine!");
				pContext->fIsHost = TRUE;
			}
			
			SetEvent(pContext->hHostMigrated);
		}
		break;
		
	default:
		{
			xLog(pContext->hLog, XLL_INFO, "Got unexpected message type 0x%08x!  Signal main app!", dwMsgType);
			
			SetEvent(pContext->hCriticalError);
			hr = E_FAIL;
		}
			break;
	} // end switch (on message type)

	dwEndTime = GetTickCount();

	pContext->dwCallbackTime += (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

	return (hr);
} // PeerStressMessageHandler
#undef DEBUG_SECTION

} // namespace DPlayStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\stress\dpstress\stressutils.h ===
#ifndef __STRESSUTILS_H__
#define __STRESSUTILS_H__

namespace DPlayStressNamespace {

//==================================================================================
// Prototypes
//==================================================================================
BOOL   FindServerIP(HANDLE hLog, char *szServerName, IN_ADDR *pServerAddr);

// Random buffer allocate/verify functions for generating DPlay buffers
DWORD  GenerateRandomDataBuffer(BYTE **ppBuffer, DWORD dwMinSize, DWORD dwMaxSize);
BOOL   VerifyDataBuffer(LPVOID pBuffer, DWORD dwBufferSize);

// Generates a string representing an address
LPSTR GetAddressString(PDIRECTPLAY8ADDRESS pDP8Address);

// Work pump wrapper
BOOL PollPeerUntilEventSignalled(HANDLE hLog, PDIRECTPLAY8PEER pDP8Peer, DWORD dwMaxTime, HANDLE hEvent, LPDWORD pdwCallbackTime);

// Netsync communication functions
DWORD SendNetsyncHostKeepalive(HANDLE hNetsync);
DWORD SendNetsyncHostUpdate(HANDLE hNetsync, IN_ADDR *pLocalAddr);
BOOL IsNetsyncSessionOver(HANDLE hNetsync);
template< class T > void DoWorkForFixedInterval( T *pDPObject, DWORD dwInterval);


} // namespace DPlayStressNamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\stress\dpstress\dpstress.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "dpstress.h"

extern DWORD g_dwDPStressBytesAllocated = 0;

using namespace DPlayStressNamespace;

namespace DPlayStressNamespace {

//==================================================================================
// Globals
//==================================================================================

// Test specific globals
static CRITICAL_SECTION g_csSerializeAccess;
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
static HANDLE g_hHeap = NULL;

#undef DEBUG_SECTION
#define DEBUG_SECTION	"MemAlloc()"
//==================================================================================
// MemAlloc
//----------------------------------------------------------------------------------
//
// Description: Private heap allocation function
//
// Arguments:
//	DWORD		dwSize		Size of buffer to allocate from the private heap
//
// Returns: Valid pointer to newly allocated memory, NULL otherwise
//==================================================================================
LPVOID MemAlloc(DWORD dwSize)
{
	LPVOID pBuffer = NULL;
	DWORD dwAllocatedSize = 0;

	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return NULL;
	}

	pBuffer = HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize);

	// Determine the size that was allocated and increment the global tracking variable
	dwAllocatedSize = HeapSize(g_hHeap, 0, pBuffer);
	if(dwAllocatedSize == -1)
	{
//		DbgPrint("Couldn't get size of allocated buffer 0x%08x", pBuffer);
		return NULL;
	}

	g_dwDPStressBytesAllocated += dwAllocatedSize;

	return pBuffer;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"MemFree()"
//==================================================================================
// MemFree
//----------------------------------------------------------------------------------
//
// Description: Private heap deallocation function
//
// Arguments:
//	LPVOID		pBuffer		Pointer to buffer to be released
//
// Returns: TRUE if the buffer was deallocated, FALSE otherwise
//==================================================================================
BOOL MemFree(LPVOID pBuffer)
{
	DWORD dwAllocatedSize = 0;

	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return FALSE;
	}

	// Determine the size that was allocated and increment the global tracking variable
	dwAllocatedSize = HeapSize(g_hHeap, 0, pBuffer);
	if(dwAllocatedSize == -1)
	{
//		DbgPrint("Couldn't get size of buffer being freed 0x%08x", pBuffer);
		return FALSE;
	}

	g_dwDPStressBytesAllocated -= dwAllocatedSize;

	return HeapFree(g_hHeap, 0, pBuffer);
}

//==================================================================================
// DpPeerStressDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry for peer stress test
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI DpPeerStressDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XnetInitialize(NULL, TRUE);
		InitializeCriticalSection(&g_csSerializeAccess);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		XnetCleanup();
		DeleteCriticalSection(&g_csSerializeAccess);
		HeapDestroy(g_hHeap);
		break;
	default:
		break;
	}

    return TRUE;
}

//==================================================================================
// DpPeerStressStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point for peer to peer stress
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI DpPeerStressStartTest(IN HANDLE  hLog)
{
	SESSION_TYPE_CALLBACK CallbackSessionInfo;
	HRESULT hr = DPN_OK;
	IN_ADDR NetsyncServerAddr;
	WSADATA WSAData;
	INT nRet = 0;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Network(S)", "DirectPlay (S-n)");
	xSetFunctionName(g_hLog, "Stress");

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
		goto Exit;
	}

//	xLog(g_hLog, XLL_INFO, "Winsock layer initialized");

	// Prepare to find a server that can run the DP tests
	CallbackSessionInfo.byMinClientCount = 1;
	CallbackSessionInfo.byMaxClientCount = 8;
	CallbackSessionInfo.nMinPortCount = 2;
	CallbackSessionInfo.lpszDllName_W = DP_PEER_STRESS_DLL_W;
	CallbackSessionInfo.lpszMainFunction_A = DP_PEER_STRESS_MAIN_FUNCTION_A;
	CallbackSessionInfo.lpszStartFunction_A = DP_PEER_STRESS_START_FUNCTION_A;
	CallbackSessionInfo.lpszStopFunction_A = DP_PEER_STRESS_STOP_FUNCTION_A;

	BEGIN_STRESS_LOOP(hLog)
	{	
		// For each loop of the test, find out if this Xbox is on the Corpnet or Internet
		// and set the address of the netsync server for the rest of this iteration.
		// In this way, it would be possible to take an
		
		if(FindServerIP(hLog, CORPNET_NETSYNC_NAME, &NetsyncServerAddr))
		{
			xLog(g_hLog, XLL_INFO, "Found the Corpnet Netsync server at %s", inet_ntoa(NetsyncServerAddr));
		}
		else if(FindServerIP(hLog, INTERNET_NETSYNC_NAME, &NetsyncServerAddr))
		{
			xLog(g_hLog, XLL_INFO, "Found the Internet Netsync server at %s", inet_ntoa(NetsyncServerAddr));
		}
		else
		{
			xLog(g_hLog, XLL_WARN, "Both the Corpnet and Internet Netsync servers are unavailable at this time");
			WAIT10_AND_LOOP(hLog);
		}

//		xLog(g_hLog, XLL_INFO, "Querying Netsync for DirectPlay host information...");

		// Query the Netsync server for host information
		GET_HOSTINFO(hLog, NetsyncServerAddr, &CallbackSessionInfo);

//		xLog(g_hLog, XLL_INFO, "Determining local address information...");

		// Determine local address information
		GET_LOCALINFO(hLog);
		
//		xLog(g_hLog, XLL_INFO, "Calling DirectPlay peer stress function...");

		// Run the peer stress function
		RUN_PEERSTRESS(hLog);
	}
	END_STRESS_LOOP(hLog)

Exit:


	// Clean up winsock
	xLog(g_hLog, XLL_INFO, "Cleaning up Winsock layer");
	WSACleanup();

	g_hLog = INVALID_HANDLE_VALUE;

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);

}            

//==================================================================================
// DpPeerStressEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI DpPeerStressEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

//==================================================================================
// DpCSStressDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry for client/server stress test
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI DpCSStressDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XnetInitialize(NULL, TRUE);
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		XnetCleanup();
		DeleteCriticalSection(&g_csSerializeAccess);
		break;
	default:
		break;
	}

    return TRUE;
}

/*
//==================================================================================
// DpCSStressStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point for client/server stress
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI DpCSStressStartTest(IN HANDLE  hLog)
{
	SESSION_TYPE_CALLBACK CallbackSessionInfo;
	PDP_HOSTINFO pHostInfoMsg = NULL;
	HRESULT hr = DPN_OK;
	IN_ADDR NetsyncServerAddr, HostAddr, FromAddr, LocalAddr;
	WSADATA WSAData;
	HANDLE hEnumObject = NULL, hClientObject = NULL;
	DWORD dwHostInfoSize, dwReceiveStatus, dwAddressType;
	BOOL fDPlayInitialized = FALSE;
	WORD LowPort, HighPort;
	INT nRet = 0, i;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Network(S)", "DirectPlay (S-n)");
	xSetFunctionName(g_hLog, "Stress");

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Winsock layer initialized");

	hr = DPlayInitialize(1024 * 200);
	if(hr != DPN_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init DPlay: 0x%08x", hr);
		goto Exit;
	}

	fDPlayInitialized = TRUE;
	xLog(g_hLog, XLL_INFO, "DirectPlay layer initialized");

	// Determine our local IP address and how it was obtained
	dwAddressType = XnetGetIpAddress(&LocalAddr);

	xLog(g_hLog, XLL_INFO, "Network info:", inet_ntoa(LocalAddr));

	switch(dwAddressType & (XNET_ADDR_NONE | XNET_ADDR_DHCP | XNET_ADDR_AUTOIP | XNET_ADDR_STATIC | XNET_ADDR_LOOPBACK))
	{
	case XNET_ADDR_NONE:
		xLog(g_hLog, XLL_FAIL, "    No IP address available!");
		goto Exit;
	case XNET_ADDR_DHCP:
		xLog(g_hLog, XLL_INFO, "    Local IP (%s) was obtained via DHCP", inet_ntoa(LocalAddr));
		break;
	case XNET_ADDR_AUTOIP:
		xLog(g_hLog, XLL_INFO, "    Local IP (%s) was obtained via AutoIP", inet_ntoa(LocalAddr));
		break;
	case XNET_ADDR_STATIC:
		xLog(g_hLog, XLL_INFO, "    Local IP (%s) was statically assigned", inet_ntoa(LocalAddr));
		break;
	case XNET_ADDR_LOOPBACK:
		xLog(g_hLog, XLL_INFO, "    Local IP (%s) is a loopback address", inet_ntoa(LocalAddr));
		break;
	default:
		xLog(g_hLog, XLL_FAIL, "GetBestIpAddress returned an unknown value: 0x%08x", dwAddressType);
		goto Exit;
	}

	if(dwAddressType & XNET_HAS_GATEWAY)
		xLog(g_hLog, XLL_INFO, "    Gateway is available");
	else
		xLog(g_hLog, XLL_INFO, "    No gateway is avaiable");


	// Prepare to find a server that can run the DP tests
	CallbackSessionInfo.byMinClientCount = 2;
	CallbackSessionInfo.byMaxClientCount = 100;
	CallbackSessionInfo.nMinPortCount = 2;
	CallbackSessionInfo.lpszDllName_W = DP_PEER_STRESS_DLL_W;
	CallbackSessionInfo.lpszMainFunction_A = DP_PEER_STRESS_MAIN_FUNCTION_A;
	CallbackSessionInfo.lpszStartFunction_A = DP_PEER_STRESS_START_FUNCTION_A;
	CallbackSessionInfo.lpszStopFunction_A = DP_PEER_STRESS_STOP_FUNCTION_A;

	// BUGBUG - determine server address

	// Begin enumerating servers
	hEnumObject = NetsyncQueryServer(NetsyncServerAddr.S_un.S_addr, SESSION_CALLBACK, &CallbackSessionInfo);
	if(hEnumObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't find a server to run DPSTRESS test");
		goto Exit;
	}

	// Create a client to communicate with that server
	hClientObject = NetsyncCreateClient(hEnumObject, NetsyncServerAddr.S_un.S_addr, &LowPort, &HighPort);
	if(hClientObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't create Netsync client");
		goto Exit;
	}
	
	dwHostInfoSize = 0;
	pHostInfoMsg = NULL;

	// Wait for information on the other hosts in the session from the Netsync server
	dwReceiveStatus = NetsyncReceiveClientMessage(hClientObject, RECEIVE_TIMEOUT, &(FromAddr.S_un.S_addr), &dwHostInfoSize, (char **) &pHostInfoMsg);

	// If we didn't receive the host information from the server then report failure and end the test
	if((dwReceiveStatus != WAIT_OBJECT_0) || (pHostInfoMsg->dwMessageId != DPMSG_HOSTINFO))
	{
		xLog(g_hLog, XLL_FAIL, "Didn't receive host info from server");
		goto Exit;
	}

	// Set up the host machines address as an IN_ADDR for easy conversion to a string
	HostAddr.S_un.S_addr = pHostInfoMsg->dwHostAddr;

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run simple peer tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	if(!SyncWithOtherTesters(hLog, hClientObject, SIMPLE_HOST_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	(HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr) ? 
		DirectPlayExec_SimpleHost(hLog, pHostInfoMsg, LowPort) :
		DirectPlayExec_SimpleConnect(hLog, pHostInfoMsg, LowPort);

Exit:

	hClientObject ? NetsyncCloseClient(hClientObject) : 0;
	hEnumObject ? NetsyncCloseFindServer(hEnumObject) : 0;
	pHostInfoMsg ? NetsyncFreeMessage((char *) pHostInfoMsg) : 0;

	if(fDPlayInitialized)
	{
		hr = DPlayCleanup();
		if(hr != DPN_OK)
			xLog(g_hLog, XLL_FAIL, "Couldn't cleanup DPlay: 0x%08x", hr);
		else
			xLog(g_hLog, XLL_INFO, "DirectPlay layer cleaned-up");
	}


	// Clean up winsock
	xLog(g_hLog, XLL_INFO, "Cleaning up Winsock layer");
	WSACleanup();

	g_hLog = INVALID_HANDLE_VALUE;

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);

}            

//==================================================================================
// DpCSStressEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI DpCSStressEndTest()
{
	// We already cleaned up everything at the end of StartTest
}
*/

} // namespace DPlayStressNamespace


// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dppeerstress )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( dppeerstress )
    EXPORT_TABLE_ENTRY( "StartTest", DpPeerStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DpPeerStressEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", DpPeerStressDllMain )
END_EXPORT_TABLE( dppeerstress )

/*
// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dpcsstress )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( dpcsstress )
    EXPORT_TABLE_ENTRY( "StartTest", DpCSStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DpCSStressEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", DpCSStressDllMain )
END_EXPORT_TABLE( dpcsstress )
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\stress\dpstress\dpstress.h ===
#ifndef __DPSTRESS_H__
#define __DPSTRESS_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <stdio.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>

#include <dplay8.h>
#include <dpaddr.h>

#include "dpmsg.h"
#include "stressutils.h"

namespace DPlayStressNamespace {

//==================================================================================
// Stress function prototypes
//==================================================================================
BOOL PeerStress(HANDLE hLog, HANDLE hNetsync, DP_HOSTINFO *pMsg, IN_ADDR *pLocalAddr, BOOL fStartedAsHost);

// Private heap functions
LPVOID MemAlloc(DWORD dwSize);
BOOL   MemFree(LPVOID pBuffer);

//==================================================================================
// Defines
//==================================================================================
// BUGBUG - change to real names
#define CORPNET_NETSYNC_NAME "xboxnetsync1"
//#define CORPNET_NETSYNC_NAME "tristanj0"
#define INTERNET_NETSYNC_NAME "xonline.org"
#define DPSTRESS_PORT 2302

#define DP_PEER_STRESS_DLL_W L"dpserv.dll"
#define DP_PEER_STRESS_MAIN_FUNCTION_A "DpStressCallbackFunction"
#define DP_PEER_STRESS_START_FUNCTION_A "DpStressStartFunction"
#define DP_PEER_STRESS_STOP_FUNCTION_A "DpStressStopFunction"

#define UNKNOWN_HOST_STRING		"Unknown"

#define MAX_GROUPS					(3)

#define HOST_KEEPALIVE_INTERVAL		(5000)
#define MAX_PENDING_SEND_BYTES		(10 * 1024)
#define MAX_ENUM_TIME				(30000)
#define MAX_CONN_TIME				(60000)

#define SEND_DATA_MIN_SIZE			(8)
#define SEND_DATA_MAX_SIZE			(256)
#define ENUM_DATA_MIN_SIZE			(8)
#define ENUM_DATA_MAX_SIZE			(1000)
#define	ENUMREPLY_DATA_MIN_SIZE		(8)
#define CONN_DATA_MIN_SIZE			(8)
#define CONN_DATA_MAX_SIZE			(1000)
#define CONNREPLY_DATA_MIN_SIZE		(8)
#define CONNREPLY_DATA_MAX_SIZE		(1000)
#define GROUP_DATA_MIN_SIZE			(8)
#define GROUP_DATA_MAX_SIZE			(1000)
#define APP_DESC_MIN_SIZE			(8)
#define APP_DESC_MAX_SIZE			(10)

//==================================================================================
// Netsync Macros
//==================================================================================
// These macros are used in DirectPlay stress tests that use Netsync for determining
// server and host addresses...

// Cleans up all variables... deallocating buffers and closing handles...
// Used at the end of each loop and whenever the loop is being exited
#define CLEAN_NETSYNC_VARIABLES			(hClient && (hClient != INVALID_HANDLE_VALUE)) ? NetsyncCloseClient(hClient) : 0;\
										hClient = NULL;\
										(hEnum && (hEnum != INVALID_HANDLE_VALUE)) ? NetsyncCloseFindServer(hEnum) : 0;\
										hEnum = NULL;\
										pMsg ? NetsyncFreeMessage((char *) pMsg) : 0;\
										pMsg = NULL;\
										wLowPort = wHighPort = 0;\
										dwMsgSize = dwRecvStatus = dwAddrType = 0;\
										dwStartTime = dwEndTime = dwTotalTime = 0;

// The start of the loop code.  Allocates all necessary variables for Netsync communication
// and starts a while loop
#define BEGIN_STRESS_LOOP(log)			{\
											PDP_HOSTINFO pMsg = NULL;\
											IN_ADDR HostAddr, FromAddr, LocalAddr;\
											HANDLE hEnum = NULL, hClient = NULL;\
											DWORD dwMsgSize = 0, dwRecvStatus = 0, dwAddrType = 0;\
											DWORD dwStartTime = 0, dwEndTime = 0, dwTotalTime = 0;\
											WORD wLowPort = 0, wHighPort = 0;\
											/*xLog(log, XLL_INFO, "Starting stress loop...");*/\
											\
											while(TRUE)\
											{
						
// The end of the while loop code.  Cleans up all the variables and prints a message if the
// loop has been ended				
#define END_STRESS_LOOP(log)					CLEAN_NETSYNC_VARIABLES;\
											}\
											\
											xLog(log, XLL_INFO, "Leaving stress loop...");\
										}

// Cleans Netsync variables and restarts the loop.  Used when a problem has been encountered
// that will require the client to resync with the Netsync server
#define WAIT10_AND_LOOP(log)			/*xLog(log, XLL_WARN, "Wait 10 seconds and try again...");*/\
										CLEAN_NETSYNC_VARIABLES;\
										Sleep(10000);\
										continue

// Used to exit the loop.  Not currently used anywhere so that stress tests will contiue trying
// to connect to the Netsync server even if it is temporarily unavailable
#define EXIT_LOOP(log)					xLog(log, XLL_WARN, "An unrecoverable error occurred!");\
										CLEAN_NETSYNC_VARIABLES;\
										break

// Gets the local IP address and prins a message indicating what type it is
#define GET_LOCALINFO(log)				dwAddrType = XnetGetIpAddress(&LocalAddr);\
										switch(dwAddrType & (XNET_ADDR_DHCP | XNET_ADDR_AUTOIP | XNET_ADDR_STATIC))\
										{\
										case XNET_ADDR_DHCP:\
											/*xLog(g_hLog, XLL_INFO, "Local address %s was obtained via DHCP", inet_ntoa(LocalAddr));*/\
											break;\
										case XNET_ADDR_AUTOIP:\
											/*xLog(g_hLog, XLL_INFO, "Local address %s was obtained via AutoIP", inet_ntoa(LocalAddr));*/\
											break;\
										case XNET_ADDR_STATIC:\
											/*xLog(g_hLog, XLL_INFO, "Local address %s was statically assigned", inet_ntoa(LocalAddr));*/\
											break;\
										default:\
											xLog(g_hLog, XLL_WARN, "Couldn't get an acceptable IP address: 0x%08x", dwAddrType);\
											LocalAddr.S_un.S_addr = 0;\
											WAIT10_AND_LOOP(hLog);\
										}
// Communicates with Netsync server and retries a host info message indicating where the Netsync server
// thinks the current host for this session is
#define GET_HOSTINFO(log, naddr, pinfo)	hEnum = NetsyncQueryServer(naddr.S_un.S_addr, SESSION_CALLBACK, pinfo);\
										if(hEnum == INVALID_HANDLE_VALUE)\
										{\
											xLog(log, XLL_WARN, "Netsync server %s can't run this test now", inet_ntoa(naddr));\
											WAIT10_AND_LOOP(log);\
										}\
										\
										hClient = NetsyncCreateClient(hEnum, naddr.S_un.S_addr, &wLowPort, &wHighPort);\
										if(hClient == INVALID_HANDLE_VALUE)\
										{\
											xLog(log, XLL_WARN, "Couldn't start session on Netsync server %s", inet_ntoa(naddr));\
											WAIT10_AND_LOOP(log);\
										}\
										\
										NetsyncCloseFindServer(hEnum);\
										hEnum = NULL;\
										\
										dwStartTime = dwEndTime = dwTotalTime = dwMsgSize = 0;\
										pMsg = NULL;\
										\
										dwStartTime = GetTickCount();\
										\
										do\
										{\
											dwRecvStatus = NetsyncReceiveClientMessage(hClient, 30000 - dwTotalTime, (DWORD *) &FromAddr, &dwMsgSize, (char **) &pMsg);\
											if((dwRecvStatus == WAIT_OBJECT_0) && (pMsg->dwMessageId == DPMSG_HOSTINFO))\
												break;\
											\
											dwEndTime = GetTickCount();\
											dwTotalTime = (dwEndTime < dwStartTime) ? ((DWORD) 0xffffffff) - dwStartTime + dwEndTime : (dwEndTime - dwStartTime);\
											pMsg ? NetsyncFreeMessage((char *) pMsg) : 0;\
											pMsg = NULL;\
										} while(dwTotalTime < 30000);\
										\
										if((dwRecvStatus != WAIT_OBJECT_0) || (pMsg->dwMessageId != DPMSG_HOSTINFO))\
										{\
											xLog(log, XLL_WARN, "Netsync didn't reply with valid host info within 30 seconds, try again later...");\
											WAIT10_AND_LOOP(log);\
										}\
										\
										if(!pMsg->dwHostAddr)\
										{\
											xLog(log, XLL_WARN, "Netsync indicated this session's host is migrating, try again later...");\
											WAIT10_AND_LOOP(log);\
										}\
										\
										HostAddr.S_un.S_addr = pMsg->dwHostAddr;\
										xLog(log, XLL_INFO, "DirectPlay host address is %s", inet_ntoa(HostAddr))

// Examines address variables in the loop and determins if this client has been selected as the
// host for this session
#define IS_HOST()						(LocalAddr.S_un.S_addr && HostAddr.S_un.S_addr && (LocalAddr.S_un.S_addr == HostAddr.S_un.S_addr))

// Executes the peer stress test... passing in all necessary variables from Netsync
#define RUN_PEERSTRESS(log)				PeerStress(log, hClient, pMsg, &LocalAddr, IS_HOST())

//==================================================================================
// General Macros
//==================================================================================
// These macros are for general tasks such as determining handle validity and safely
// creating and closing various objects

#define IS_VALID_HANDLE(x)      		(x && (INVALID_HANDLE_VALUE != x))
#define SAFE_CLOSEHANDLE(h)				{\
											if (IS_VALID_HANDLE(h))\
											{\
												CloseHandle(h);\
												h = NULL;\
											}\
										}												
#define SAFE_CREATEEVENT(handle, lpEventAttributes, fManualReset, fInitialState, pszName)\
										{\
											if (handle != NULL)\
											{\
												xLog(hLog, XLL_WARN, "Handle %x is not NULL at line %i, DEBUGBREAK()-ing.", handle, __LINE__);\
												CloseHandle(handle);\
											}\
											handle = NULL;\
											handle = CreateEvent(lpEventAttributes, fManualReset, fInitialState, pszName);\
											if (handle == NULL)\
											{\
												DWORD dwError = GetLastError();\
												xLog(hLog, XLL_WARN, "Couldn't create event!: 0x%08x(%u)", dwError, dwError);\
											}\
										}

//==================================================================================
// Typedefs
//==================================================================================
// Player context that is allocated for all players in a session...
// allows callbacks to have instant access to information about the player
// that a given network event pertains to
typedef struct tagPLAYERCONTEXT
{
	DPNID					PlayerID;					// DirectPlay player ID this context refers to
	DWORD					TotalMessagesReceived;		// Counts total messages received from player
	DWORD					TotalBytesReceived;			// Counts total bytes received from player
	DWORD					dwPlayerInfoChangeCounter;	// Counts number of times player has changed info
	struct tagPLAYERCONTEXT	*pPrev;						// Pointer to the next player in the list
	struct tagPLAYERCONTEXT	*pNext;						// Pointer to the previous player in the list
} PLAYERCONTEXT, * PPLAYERCONTEXT;

// DirectPlay callback context for peer stress tests
typedef struct tagPEERSTRESSCONTEXT
{
	CHAR					szContextDescription[20];	// A short description of who this context belongs to
	PDIRECTPLAY8ADDRESS		pExpectedHostAddress;		// Expected host address from enumeration
	BOOL					fVerbose;					// Controls amount of logging from callback
	BOOL					fIsHost;					// Indicates if this context refers to the host
	DWORD					dwCurrentGroups;			// Tracks number of local groups created
	DPNID					LocalGroupIDs[MAX_GROUPS];	// Player IDs of the locally created groups
	DWORD					dwPlayersAdded[MAX_GROUPS];	// Number of players added to each group
	DWORD					dwGroupCreationCounter;		// Counts number of local groups that have been created
	CRITICAL_SECTION		Lock;						// Critical section for callback
	PPLAYERCONTEXT			pPlayerList;				// Maintains a list of known players
	HANDLE					hLog;						// Handle to logging subsystem
	DPNID					LocalPlayerID;				// Stores the id of the local player
	DWORD					dwCallbackTime;				// Tracks the number of milliseconds spent in the callback
	DWORD					dwPlayersConnected;			// Tracks the number of players currently connected
	DWORD					dwAppDescChangeCounter;		// Counts app desc changes
	HANDLE					hConnectComplete;			// Event for indicating incoming connections
	HANDLE					hSessionTerminated;			// Event for indicating session termination
	HANDLE					hHostMigrated;				// Event for indicating host migration
	HANDLE					hCriticalError;				// Event for indicating critical errors
	DWORD					TotalMessagesSent;			// Counts total message sent by this player
	DWORD					TotalBytesSent;				// Counts total bytes sent by this player
	DWORD					TotalGroupMessagesSent;		// Counts total message sent by this player
	DWORD					TotalGroupBytesSent;		// Counts total bytes sent by this player
} PEERSTRESSCONTEXT, * PPEERSTRESSCONTEXT;

// DirectPlay callback context for client stress tests
typedef struct tagCLIENTSTRESSCONTEXT
{
	CHAR					szContextDescription[20];	// A short description of who this context belongs to
	BOOL					fVerbose;					// Controls amount of logging from callback
	CRITICAL_SECTION		Lock;						// Critical section for callback
	HANDLE					hLog;						// Handle to logging subsystem
	DWORD					dwCallbackTime;				// Tracks the number of milliseconds spent in the callback
	HANDLE					hConnectComplete;			// Variable for handling incoming connections
	DWORD					dwServerInfoChangeCounter;	// Variable for handling host information changes
	DWORD					dwAppDescChangeCounter;		// Counts app desc changes
	HANDLE					hSessionTerminated;			// Variables for handling session termination
	HANDLE					hCriticalError;				// Event for indicating critical errors
} CLIENTSTRESSCONTEXT, * PCLIENTSTRESSCONTEXT;

// DirectPlay callback context for server stress tests
typedef struct tagSERVERSTRESSCONTEXT
{
	CHAR					szContextDescription[20];	// A short description of who this context belongs to
	BOOL					fVerbose;					// Controls amount of logging from callback
	CRITICAL_SECTION		Lock;						// Critical section for callback
	PPLAYERCONTEXT			pPlayerList;				// Maintains a list of known players
	HANDLE					hLog;						// Handle to logging subsystem
	DPNID					LocalPlayerID;				// Stores the id of the local player
	DWORD					dwCallbackTime;				// Tracks the number of milliseconds spent in the callback
	DWORD					dwPlayersConnected;			// Tracks the number of players currently connected
	DWORD					dwAppDescChangeCounter;		// Counts app desc changes
	HANDLE					hConnectComplete;			// Event for indicating incoming connections
	HANDLE					hSessionTerminated;			// Event for indicating session termination
	HANDLE					hCriticalError;				// Event for indicating critical errors
} SERVERSTRESSCONTEXT, * PSERVERSTRESSCONTEXT;

// Header applied to all data buffers that are sent between machines during
// DirectPlay tests
typedef struct tagDATAHEADER
{
	DWORD					dwDataLength;
	DWORD					dwChecksum;
} DATAHEADER, *PDATAHEADER;

//==================================================================================
// Globals
//==================================================================================
// {6C84E0F9-5CF8-43f2-A3C1-C69D8BCB2CB9}
DEFINE_GUID(GUID_PEER_STRESS, 
0x6c84e0f9, 0x5cf8, 0x43f2, 0xa3, 0xc1, 0xc6, 0x9d, 0x8b, 0xcb, 0x2c, 0xb9);

} // namespace DPlayStressNamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\modules\1sttest\1sttest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>


#include "debugprint.h"
#include "cppobjhelp.h"
#include "linklist.h"
#include "linkedstr.h"

#include "tncontrl.h"


//#include "..\main.h"
#include "t_main.h"

#include "1sttest.h"






//==================================================================================
// Prototypes
//==================================================================================
HRESULT FirstTestExec_Basic(PTNEXECCASEDATA pTNecd);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"FirstTestLoadTestTable()"
//==================================================================================
// FirstTestLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				1.1			First tests
//				1.1.1		Simple test A
//
// Arguments:
//	PTNTESTTABLEGROUP pTable	Group/table to fill with tests in this file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FirstTestLoadTestTable(PTNTESTTABLEGROUP pTable)
{
	PTNTESTTABLEGROUP	pSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 1.1		First tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTable, "1.1", "First tests", &pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 1.1.1	Simple test A
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "1.1.1";
	tnatd.pszName			= "Simple test A";
	tnatd.pszDescription	= "This is a template for a test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_TOPLEVELTEST;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= FirstTestExec_Basic;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);


	return (S_OK);
} // FirstTestLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"FirstTestExec_Basic()"
//==================================================================================
// FirstTestExec_Basic
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				1.1.1 - Simple test A
//
// Arguments:
//	PTNEXECCASEDATA lpTNecd	Pointer to structure with parameters for test case.
//
// Expected input data:
//	None.
//
// Output data:
//	None.
//
// Dynamic variables set:
//	None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT FirstTestExec_Basic(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult		sr;
	CTNTestResult		tr;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Function 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Call the first function you want to test
//		tr = FunctionToTest1();

		// For our example, we say if the call didn't return S_OK then the test is a
		// failure.  We will make note of the failure, and stop executing any more
		// of the test.  The END_TESTCASE macro will report this failure for us, we
		// just have to make sure we clean up after/outside of END_TESTCASE.
//		if (tr != S_OK)
//		{
//			DPL(0, "FunctionToTest1 didn't return S_OK!", 0);
//			THROW_TESTRESULT;
//		} // end if (we failed)

		tr = S_OK;

		// Otherwise, we can report that this function succeeded, but continue on.
		// Note that this is optional.  You may choose not to have any reporting
		// except the final exit sucess/failure report.

		sr = pTNecd->pExecutor->Report(tr, TRUE);
		if (sr != S_OK)
		{
			DPL(0, "Reporting FunctionToTest1 success failed!", 0);
			THROW_SYSTEMRESULT;
		} // end if (reporting failed)

		OutputDebugString(L"Function 1 complete!\r\n");


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Function 2");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


		// Call the second function you want to test
//		tr = FunctionToTest2(NULL);

		// For our example, we say that if the call didn't return the appropriate
		// error ERROR_INVALID_PARAMETER then the test is a failure.  We will stop
		// executing any more of the test and report this result.
//		if (tr != ERROR_INVALID_PARAMETER)
//		{
//			DPL(0, "FunctionToTest2 didn't return ERROR_INVALID_PARAMETER!", 0);
//			THROW_TESTRESULT;
//		} // end if (we failed)

		tr = S_OK;

		// Otherwise, we can report that this function succeeded, but continue on.
		// Note that this is optional.  You may choose not to have any reporting
		// except the final exit sucess/failure report.

		sr = pTNecd->pExecutor->Report(tr, TRUE);
		if (sr != S_OK)
		{
			DPL(0, "Reporting FunctionToTest2 results failed!", 0);
			THROW_SYSTEMRESULT;
		} // end if (reporting failed)

		OutputDebugString(L"Function 2 complete!\r\n");


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Function 3");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


		// Call the third function you want to test
//		tr = FunctionToTest3();

		// If the call didn't return S_OK then the test is a failure.  Since this is
		// the last test, we use this as our final result.
//		if (tr != S_OK)
//		{
//			DPL(0, "FunctionToTest3 didn't return S_OK!", 0);
//			THROW_TESTRESULT;
//		} // end if (we failed)

		tr = S_OK;

		// Otherwise, we can report that this function succeeded, but continue on.
		// Note that this is optional.  You may choose not to have any reporting
		// except the final exit sucess/failure report.

		sr = pTNecd->pExecutor->Report(tr, TRUE);
		if (sr != S_OK)
		{
			DPL(0, "Reporting FunctionToTest3 results failed!", 0);
			THROW_SYSTEMRESULT;
		} // end if (reporting failed)

		OutputDebugString(L"Function 3 complete!\r\n");

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cleanup");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Do cleanup.  We should check the error codes here, as opposed to below
		// where we don't want to mash a possibly already existing error.
		


		// Now report the fact the test case is done and successful.
		FINAL_SUCCESS;
	}
	END_TESTCASE


	// Do any cleanup that may be necessary.  Note that you should ignore error
	// codes or use a temp hresult and call the OVERWRITE_SR_IF_OK macro since you
	// may reach here with an error code already, and you don't want to stomp it.
	// Also do not use the THROW macros since we are outside the catch handler.

	return (sr);
} // FirstTestExec_Basic
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\stress\dpstress\stressutils.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dpstress.h"

using namespace DPlayStressNamespace;

namespace DPlayStressNamespace {

template void DoWorkForFixedInterval<IDirectPlay8Peer> (IDirectPlay8Peer *, DWORD);

#undef DEBUG_SECTION
#define DEBUG_SECTION	"IsNetsyncSessionOver()"
//==================================================================================
// IsNetsyncSessionOver
//----------------------------------------------------------------------------------
//
// Description: Reads messages from Netsync server and verifies that session is still valid
//
// Arguments:
//	HANDLE		hNetsync		Handle to the Netsync subsystem
//
// Returns: TRUE if Netsync said the session is no longer valid, FALSE otherwise
//==================================================================================
BOOL IsNetsyncSessionOver(HANDLE hNetsync)
{
	DP_GENERIC	*pMsg = NULL;
	DWORD		dwFromAddr = 0, dwMsgSize = 0, dwRecvStatus = 0, dwMessageType = 0;
	BOOL		fIsOver = FALSE;

	// Read all client messages until there aren't anymore or a STOPSESSION message is encountered
	while(TRUE)
	{
		pMsg ? NetsyncFreeMessage((char *) pMsg) : 0;
		pMsg = NULL;

		// Read a message from the queue
		dwRecvStatus = NetsyncReceiveMessage(hNetsync, 0, &dwMessageType, &dwFromAddr, &dwMsgSize, (char **) &pMsg);
		if(dwRecvStatus == WAIT_OBJECT_0)
		{
			// If the received message was invalid, keep reading messages
			if(dwMsgSize < sizeof(DP_GENERIC))
				continue;

			// If the recieved message wasn't a STOPSESSION message, ignore it
			if(pMsg->dwMessageId != NETSYNC_MSG_STOPSESSION)
				continue;

			// If this point is reached, then a STOPSESSION was received... exit
			fIsOver = TRUE;
			goto Exit;
		}

		// If there aren't any messages... exit
		else if(dwRecvStatus == WAIT_TIMEOUT)
		{
			fIsOver = FALSE;
			goto Exit;
		}
		
		// If we experienced a low level Netsync problem... exit
		else
		{
			fIsOver = TRUE;
			goto Exit;
		}
	}

Exit:

	pMsg ? NetsyncFreeMessage((char *) pMsg) : 0;
	pMsg = NULL;

	return fIsOver;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendNetsyncHostKeepalive()"
//==================================================================================
// SendNetsyncHostKeepalive
//----------------------------------------------------------------------------------
//
// Description: Sends message to Netsync server indicating that host is still alive
//
// Arguments:
//	HANDLE		hNetsync		Handle to the Netsync subsystem
//
// Returns:
//    If the function succeeds, the return value is WAIT_OBJECT_0.
//    If the function times out, the return value is WAIT_TIMEOUT.
//    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().
//==================================================================================
DWORD SendNetsyncHostKeepalive(HANDLE hNetsync)
{
	DP_HOSTKEEPALIVE	HostKeepAlive;
	DWORD				dwSendStatus = WAIT_FAILED;

	HostKeepAlive.dwMessageId = DPMSG_HOSTKEEPALIVE;

	dwSendStatus = NetsyncSendClientMessage(hNetsync, 0, sizeof(DP_HOSTKEEPALIVE), (char *) &HostKeepAlive);

	return dwSendStatus;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SendNetsyncHostUpdate()"
//==================================================================================
// SendNetsyncHostUpdate
//----------------------------------------------------------------------------------
//
// Description: Sends message to Netsync server indicating that host has migrated
//
// Arguments:
//	HANDLE		hNetsync		Handle to the Netsync subsystem
//	IN_ADDR		*pLocalAddr		Pointer to the address of the local machine
//
// Returns:
//    If the function succeeds, the return value is WAIT_OBJECT_0.
//    If the function times out, the return value is WAIT_TIMEOUT.
//    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().
//==================================================================================
DWORD SendNetsyncHostUpdate(HANDLE hNetsync, IN_ADDR *pLocalAddr)
{
	DP_NEWHOST	NewHostMessage;
	DWORD		dwSendStatus;

	NewHostMessage.dwMessageId = DPMSG_NEWHOST;
	NewHostMessage.dwHostAddr = pLocalAddr->S_un.S_addr;

	dwSendStatus = NetsyncSendClientMessage(hNetsync, 0, sizeof(DP_NEWHOST), (char *) &NewHostMessage);

	return dwSendStatus;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"FindServerIP()"
//==================================================================================
// FindServerIP
//----------------------------------------------------------------------------------
//
// Description: Resolve a given machine name to an IP address
//
// Arguments:
//	HANDLE		hLog			Handle to the logging subsystem
//	CHAR		*szServerName	Machine name to resolve
//	IN_ADDR		*pServerAddr	Pointer to an IP address that will hold the resolved address
//
// Returns:
//	TRUE if the machine name was successfully resolved, FALSE otherwise
//==================================================================================
BOOL FindServerIP(HANDLE hLog, CHAR *szServerName, IN_ADDR *pServerAddr)
{
	HOSTENT *pHost = NULL;
	DWORD dwNetError = 0;

	if(!szServerName || !pServerAddr)
	{
		xLog(hLog, XLL_WARN, "FindServerIP must be called with a valid server name and address pointer!");
		return FALSE;
	}

	pHost = gethostbyname(szServerName);
	if(!pHost)
	{
		dwNetError = WSAGetLastError();
		if(dwNetError == WSAHOST_NOT_FOUND)
			xLog(hLog, XLL_INFO, "Server %s wasn't found\n", szServerName);
		else
			xLog(hLog, XLL_WARN, "Network error %u occured while searching for %s\n", dwNetError, szServerName);

		return FALSE;
	}

	pServerAddr->S_un.S_addr = *((DWORD *)pHost->h_addr);

	return TRUE;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"GenerateRandomDataBuffer()"
//==================================================================================
// GenerateRandomDataBuffer
//----------------------------------------------------------------------------------
//
// Description: Generate a data buffer of a given size with a header and checksum
//
// Arguments:
//	LPVOID		*ppBuffer		Parameter for passing back a pointer to the created buffer
//	DWORD		dwMinSize		Minimum size for this buffer (must be >= sizeof(DATAHEADER))
//	DWORD		dwMaxSize		Maximum size for this buffer (must be >= dwMinSize)
//
// Returns:
//	Returns the number of bytes in the generated packet, 0 indicates failure
//==================================================================================
DWORD GenerateRandomDataBuffer(BYTE **ppBuffer, DWORD dwMinSize, DWORD dwMaxSize)
{
	DATAHEADER *pHeader = NULL;
	DWORD dwBufferSize = 0;
	BYTE *pCurrent = NULL;

	if(!ppBuffer || (dwMinSize > dwMaxSize) || (dwMinSize < sizeof(DATAHEADER)))
		return 0;

	dwBufferSize = (rand() % (dwMaxSize - dwMinSize + 1)) + dwMinSize;

	if(!(pCurrent = (BYTE *) MemAlloc(dwBufferSize)))
		return 0;

	// Pass back the buffer via the ppBuffer variable
	*ppBuffer =  pCurrent;

	pHeader = (DATAHEADER *) pCurrent;
	pHeader->dwDataLength = dwBufferSize;
	pHeader->dwChecksum = 0;

	for(DWORD dwCurrent = sizeof(DATAHEADER); dwCurrent < dwBufferSize; ++dwCurrent)
	{
		(pHeader->dwChecksum) += (pCurrent[dwCurrent] = (BYTE) (rand() & 0x000000ff));
	}

	return dwBufferSize;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"VerifyDataBuffer()"
//==================================================================================
// VerifyDataBuffer
//----------------------------------------------------------------------------------
//
// Description: Verify the validity of a data buffer
//
// Arguments:
//	LPVOID		pBuffer			Pointer to the buffer to verify
//	DWORD		dwBufferSize	Size of the buffer
//
// Returns:
//	TRUE if the packet passes its checksum, FALSE otherwise
//==================================================================================
BOOL VerifyDataBuffer(LPVOID pBuffer, DWORD dwBufferSize)
{
	DATAHEADER *pHeader = (DATAHEADER *) pBuffer;
	BYTE *pCurrent = (BYTE *) pBuffer;

	if(!pBuffer || (pHeader->dwDataLength != dwBufferSize) || (dwBufferSize < sizeof(DATAHEADER)))
		return FALSE;

	DWORD dwComputedChecksum = 0;

	for(DWORD dwCurrent = sizeof(DATAHEADER); dwCurrent < dwBufferSize; ++dwCurrent)
	{
		dwComputedChecksum += (pCurrent[dwCurrent]);
	}

	return (dwComputedChecksum == pHeader->dwChecksum);
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"GetAddressString()"
//==================================================================================
// GetAddressString
//----------------------------------------------------------------------------------
//
// Description: Retrieves a string representation of a DirectPlay 8 address
//
// Arguments:
//	DIRECTPLAY8ADDRESS		*pDP8Address		Pointer to the DirectPlay address
//
// Returns:
//	Pointer to a character string representing the DirectPlay 8 address, NULL on failure
//==================================================================================
LPSTR GetAddressString(PDIRECTPLAY8ADDRESS pDP8Address)
{
	HRESULT hr = NULL;
	DWORD dwAddressStringSize = 0;
	LPSTR szAddressString = NULL;
	BOOL fSuccess = TRUE;

	// Query for the address size
	hr = pDP8Address->GetURLA(NULL, &dwAddressStringSize);
	if(hr != DPNERR_BUFFERTOOSMALL)
	{
		fSuccess = FALSE;
		goto Exit;
	}
				
	// Allocate a buffer for it
	szAddressString = (CHAR *) MemAlloc(dwAddressStringSize);
	if(!szAddressString)
	{
		fSuccess = FALSE;
		goto Exit;
	}
				
	// Retrieve the URL
	hr = pDP8Address->GetURLA(szAddressString, &dwAddressStringSize);
	if(hr != DPN_OK)
	{
		fSuccess = FALSE;
		goto Exit;
	}

Exit:
	
	if(!fSuccess && szAddressString)
	{
		MemFree(szAddressString);
		szAddressString = NULL;
	}

	return szAddressString;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"DoWorkForFixedInterval()"
//==================================================================================
// DoWorkForFixedInterval
//----------------------------------------------------------------------------------
//
// Description: Calls the peer's DoWork function until the specified event is signalled
//
// Arguments:
//
//
// Returns: nothing
//==================================================================================
template< class T > void DoWorkForFixedInterval( T *pDPObject, DWORD dwInterval)
{
	DWORD dwDoWorkStartTime = GetTickCount(), dwCurrentTime = 0;
	DWORD dwElapsedTime = 0;

	while(dwElapsedTime <= dwInterval)
	{
		pDPObject->DoWork(0);

		dwCurrentTime = GetTickCount();
		if(dwCurrentTime >= dwDoWorkStartTime)
		{
			dwElapsedTime = dwCurrentTime - dwDoWorkStartTime;
		}
		else
		{
			dwElapsedTime = (DWORD) 0xFFFFFFFF - dwDoWorkStartTime + dwCurrentTime;
		}
	}
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"PollPeerUntilEventSignalled()"
//==================================================================================
// PollPeerUntilEventSignalled
//----------------------------------------------------------------------------------
//
// Description: Calls the peer's DoWork function until the specified event is signalled
//
// Arguments:
//	HANDLE				hLog			Handle to logging subsystem
//	PDIRECTPLAY8PEER	pDP8Peer		Pointer to the peer to call DoWork on
//	DWORD				dwMaxTime		Maximum time to wait before returning failure
//	HANDLE				hEvent			Handle to event that must be signalled to exit
//	LPDWORD				pdwCallbackTime	Number of milliseconds spent in our callback routine
//
//
// Returns: TRUE if the event signalled successfully
//			FALSE otherwise
//==================================================================================
BOOL PollPeerUntilEventSignalled(HANDLE hLog, PDIRECTPLAY8PEER pDP8Peer, DWORD dwMaxTime, HANDLE hEvent, LPDWORD pdwCallbackTime)
{
	HRESULT hr = S_OK;
	DWORD dwDoWorkCalls = 0, dwTotalTimeInDoWork = 0, dwStartDoWorkTime = 0, dwEndDoWorkTime = 0, dwWaitResult = 0;
	DWORD dwTotalTime, dwStartTime, dwEndTime;
	BOOL fRet = TRUE;

	if(pdwCallbackTime)
		*pdwCallbackTime = 0;

	dwStartTime = GetTickCount();
	dwTotalTime = 0;

	dwWaitResult = WaitForSingleObject(hEvent, 0);
	while((dwWaitResult == WAIT_TIMEOUT) && ((dwMaxTime == INFINITE) || (dwTotalTime <= dwMaxTime)))
	{
		dwStartDoWorkTime = GetTickCount();
		
		// Call the work pump function
		hr = pDP8Peer->DoWork(0);

// BUGBUG - later we will move to the global online state-machine model
//		hr = XONAsyncWorkPump(XON_ASYNCWORK_ALL);
		
		dwEndDoWorkTime = GetTickCount();
		
		// Update the total time we have spent in the DoWork function
		dwTotalTimeInDoWork += (dwEndDoWorkTime >= dwStartDoWorkTime) ? dwEndDoWorkTime - dwStartDoWorkTime : (0xFFFFFFFF - dwStartDoWorkTime) + dwEndDoWorkTime;
		
		if((hr != DPN_OK) && (hr != S_FALSE))
		{
			xLog(hLog, XLL_WARN, "Couldn't do DirectPlay work! (0x%08x)", hr);
			fRet = FALSE;
			goto Exit;
		}
		
		++dwDoWorkCalls;
		
		// Wait for the desired result
		dwWaitResult = WaitForSingleObject(hEvent, 0);

		// Calculate the total time we have been in this function
		if(dwMaxTime != INFINITE)
		{
			dwEndTime = GetTickCount();
			dwTotalTime = (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;
		}

	}
	
	// If the wait failed, then return an error
	if(dwWaitResult != WAIT_OBJECT_0)
	{
		// If we wound up waiting too long, then return an error
		if((dwMaxTime != INFINITE) && (dwTotalTime > dwMaxTime))
		{
			xLog(hLog, XLL_WARN, "Spent more than %u ms waiting for event", dwMaxTime);
			fRet = FALSE;
			goto Exit;
		}

		xLog(hLog, XLL_WARN, "Error while waiting for event to signal!");
		fRet = FALSE;
		goto Exit;
	}

	
	if(pdwCallbackTime)
		xLog(hLog, XLL_INFO, "Called work function %u times for %u ms (%u ms callback)", dwDoWorkCalls, dwTotalTimeInDoWork, *pdwCallbackTime);
//	else
//		xLog(hLog, XLL_INFO, "Called work function %u times for %u ms", dwDoWorkCalls, dwTotalTimeInDoWork);

Exit:

	return fRet;
}


} // namespace DPlayStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\modules\1sttest\1sttest.h ===
#ifndef __TEMPLATE_MINIMUMTESTS__
#define __TEMPLATE_MINIMUMTESTS__





//==================================================================================
// External Prototypes
//==================================================================================
HRESULT FirstTestLoadTestTable(PTNTESTTABLEGROUP pTable);






#endif //__TEMPLATE_MINIMUMTESTS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\checkver.c ===
#include <windows.h>
#include "checkver.h"

#define lmalloc(_usize)     LocalAlloc(LPTR, _usize)
#define lfree(_ptr)         LocalFree(_ptr)

#define VER_ERROR_MSG       "Your copy of %s is old.\r\n\r\nYour version:  %u.%u.%u.%u\r\nRequired version:  %u.%u.%u.%u"

#ifndef _XBOX // GetFileVersionInfo not supported
BOOL WINAPI GetLibraryVersion(LPCSTR lpszPath, LPCSTR lpszFile, LPDWORD lpdwVersionMS, LPDWORD lpdwVersionLS, BOOL *lpbDebug)
{
    char                    szFullPath[MAX_PATH + 1];
    LPVOID                  lpvVersionInfo;
    DWORD                   dwSize;
    DWORD                   dwReserved;
    VS_FIXEDFILEINFO *      lpFFI;
    UINT                    uSize;
    
    if(!lpszFile)
    {
        return FALSE;
    }
    
    if(lpszPath)
    {
        lstrcpy(szFullPath, lpszPath);
    }
    else
    {
        if(!GetSystemDirectory(szFullPath, sizeof(szFullPath)))
        {
            return FALSE;
        }
    }

    if(szFullPath[lstrlen(szFullPath) - 1] != '\\')
    {
        lstrcat(szFullPath, "\\");
    }

    lstrcat(szFullPath, lpszFile);

    if(!(dwSize = GetFileVersionInfoSize(szFullPath, &dwReserved)))
    {
        return FALSE;
    }

    if(!(lpvVersionInfo = lmalloc(dwSize)))
    {
        return FALSE;
    }

    if(!GetFileVersionInfo(szFullPath, 0, dwSize, lpvVersionInfo))
    {
        lfree(lpvVersionInfo);
        return FALSE;
    }

    if(!VerQueryValue(lpvVersionInfo, "\\", (LPVOID *)&lpFFI, &uSize))
    {
        lfree(lpvVersionInfo);
        return FALSE;
    }

	if (lpbDebug)
	{
		if (lpFFI->dwFileFlags & VS_FF_DEBUG)
			*lpbDebug	= TRUE;
		else
			*lpbDebug	= FALSE;
	}

    if(lpdwVersionMS)
    {
        *lpdwVersionMS = lpFFI->dwFileVersionMS;
    }

    if(lpdwVersionLS)
    {
        *lpdwVersionLS = lpFFI->dwFileVersionLS;
    }

    lfree(lpvVersionInfo);

    return TRUE;
}
#endif // ! XBOX

#ifndef _XBOX // GetFileVersionInfo not supported
BOOL WINAPI CheckLibraryVersion(HWND hWnd, LPCSTR lpszPath, LPCSTR lpszFile, DWORD dwMinVersionMS, DWORD dwMinVersionLS, BOOL fDialog)
{
    DWORD                   dwVersionMS, dwVersionLS;
    char                    szMessage[512];
    BOOL                    fOld = TRUE;

    if(!GetLibraryVersion(lpszPath, lpszFile, &dwVersionMS, &dwVersionLS, NULL))
    {
        return FALSE;
    }

    if(HIWORD(dwVersionMS) > HIWORD(dwMinVersionMS))
    {
        fOld = FALSE;
    }
    else
    {
        if(LOWORD(dwVersionMS) > LOWORD(dwMinVersionMS))
        {
            fOld = FALSE;
        }
        else
        {
            if(HIWORD(dwVersionLS) > HIWORD(dwMinVersionLS))
            {
                fOld = FALSE;
            }
            else
            {
                if(LOWORD(dwVersionLS) >= LOWORD(dwMinVersionLS))
                {
                    fOld = FALSE;
                }
            }
        }
    }
    
    if(fOld)
    {
        if(fDialog)
        {
            wsprintf(szMessage, VER_ERROR_MSG, lpszFile, HIWORD(dwVersionMS), LOWORD(dwVersionMS), HIWORD(dwVersionLS), LOWORD(dwVersionLS), HIWORD(dwMinVersionMS), LOWORD(dwMinVersionMS), HIWORD(dwMinVersionLS), LOWORD(dwMinVersionLS));

			MessageBeep(MB_ICONHAND);
            MessageBox(hWnd, szMessage, NULL, MB_OK | MB_ICONHAND | MB_TASKMODAL);
        }

        return FALSE;
    }

    return TRUE;
}
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\checkver.h ===
#ifndef _INC_CHECKVER
#define _INC_CHECKVER

#include <windows.h>

/* 
   File versions are made up of a most-significant and least-significant
   version.  Both versions are divided into major and minor versions.  The
   versions dealt with in this library can be thought of as follows:

   HIWORD(dwVerMS).LOWORD(dwVerMS).HIWORD(dwVerLS).LOWORD(dwVerLS)

   where the standard major and minor versions are stored in dwVerMS and the
   build number is stored in the LOWORD of dwVerLS.  To check for a version
   of at least 1.2.3.4, call CheckLibraryVersion() like this:

   CheckLibraryVersion(hWnd, NULL, "foo.dll", MAKELONG(2, 1), MAKELONG(4, 3), TRUE)
*/



//BEGIN vanceo
//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined
//END vanceo


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// ---------------------------------------------------------------------------
// CheckLibraryVersion
// ---------------------------------------------------------------------------
// Description:         Checks a given dll or exe version against a minimum.
// Arguments:
//  HWND [in]           Parent window handle.
//  LPCSTR [in]         Library path or NULL for the system directory.
//  LPCSTR [in]         Library file name.
//  DWORD [in]          Minimum most-significant version number.
//  DWORD [in]          Minimum least-significant version number.
//  BOOL [in]           TRUE to display an error dialog if the version does
//                      not meet the minimums.
// Returns:
//  BOOL                TRUE if the library meets the minimum version.
#ifndef _XBOX // GetFileVersionInfo not supported
	DLLEXPORT extern BOOL WINAPI CheckLibraryVersion(HWND, LPCSTR, LPCSTR, DWORD, DWORD, BOOL);
#endif // ! XBOX

// ---------------------------------------------------------------------------
// GetLibraryVersion
// ---------------------------------------------------------------------------
// Description:         Retreives the file version for a given dll or exe.
// Arguments:
//  LPCSTR [in]         Library path or NULL for the system directory.
//  LPCSTR [in]         Library file name.
//  LPDWORD [out]       Filled with the most-significant version number.
//  LPDWORD [out]       Filled with the least-significant version number.
//  BOOL [out]			TRUE if these are debug bits, FALSE otherwise.
// Returns:
//  BOOL                TRUE if all goes well.
#ifndef _XBOX // GetFileVersionInfo not supported
DLLEXPORT extern BOOL WINAPI GetLibraryVersion(LPCSTR, LPCSTR, LPDWORD, LPDWORD, LPBOOL);
#endif // ! XBOX




#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _INC_CHECKVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\cmdline.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <windowsx.h>
#include <direct.h>
#ifndef CMDLINE_WINDOWS_ONLY
#include <stdio.h>
#endif // ! CMDLINE_WINDOWS_ONLY

#ifndef CMDLINE_CONSOLE_ONLY
#include <stdlib.h>	// NT BUILD needs this for _pgmptr
#endif // ! CMDLINE_CONSOLE_ONLY

#include "resource.h"

#include "main.h"
#include "cppobjhelp.h"
#include "linklist.h"
#include "linkedstr.h"
#include "fileutils.h"
#include "strutils.h"
#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#endif // NO_TNCOMMON_DEBUG_SPEW
#ifdef _XBOX
#include "debugprint.h"
#endif

#include "cmdline.h"




//==================================================================================
// Defines
//==================================================================================
#define WRAP_DESCRIPTION_CHARACTERS		75




//==================================================================================
// Structures
//==================================================================================
typedef struct tagCMDLINEREADFILECONTEXT
{
	BOOL					fInCommandLineSection; // are we currently in the command line section?
	PSPECIFIEDPARAMSLIST	pItemList; // pointer to list to add items to
} CMDLINEREADFILECONTEXT, * PCMDLINEREADFILECONTEXT;




//==================================================================================
// Prototypes
//==================================================================================
HRESULT CmdlineReadFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
						BOOL* pfStopReading);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::CCommandLine()"
//==================================================================================
// CCommandLine constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CCommandLine object.
//
// Arguments: None.
//
// Returns: None (the object).
//==================================================================================
CCommandLine::CCommandLine(void)
{
	this->m_pszPathToApp = NULL;
	this->m_pszOriginalCommandLine = NULL;
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	this->m_fConsole = FALSE;
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
	this->m_dwFlags = 0;

	this->m_fHTML = FALSE;
	this->m_fHelp = FALSE;
	this->m_fDebug = FALSE;
	this->m_pszIniFile = NULL;

	this->m_papHelpItems = NULL;
	this->m_dwNumHelpItems = 0;
	this->m_dwHelpStartItem = 0;
	this->m_lMaxHelpLineWidth = 0;
	this->m_lMaxHelpHeight = 0;
	this->m_lLargestLeftHelpTextWidth = 0;
	this->m_lLargestRightHelpTextWidth = 0;
	this->m_lLargestHelpLineHeight = 0;

#ifndef CMDLINE_CONSOLE_ONLY
	this->m_pszTempParamNameBuffer = NULL;
#endif // not CMDLINE_CONSOLE_ONLY
} // CCommandLine::CCommandLine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::~CCommandLine()"
//==================================================================================
// CCommandLine destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CCommandLine object.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CCommandLine::~CCommandLine(void)
{
	if (this->m_pszOriginalCommandLine != NULL)
	{
		LocalFree(this->m_pszOriginalCommandLine);
		this->m_pszOriginalCommandLine = NULL;
	} // end if (allocated command line)

	if (this->m_pszPathToApp != NULL)
	{
		LocalFree(this->m_pszPathToApp);
		this->m_pszPathToApp = NULL;
	} // end if (we allocated a path to the app)

	if (this->m_papHelpItems != NULL)
	{
		LocalFree(this->m_papHelpItems);
		this->m_papHelpItems = NULL;
	} // end if (we allocated a help item array)

#ifndef CMDLINE_CONSOLE_ONLY
	if (this->m_pszTempParamNameBuffer != NULL)
	{
		LocalFree(this->m_pszTempParamNameBuffer);
		this->m_pszTempParamNameBuffer = NULL;
	} // end if (we allocated a param name buffer)
#endif // not CMDLINE_CONSOLE_ONLY
} // CCommandLine::~CCommandLine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::Initialize()"
//==================================================================================
// CCommandLine::Initialize
//----------------------------------------------------------------------------------
//
// Description: Initializes the CCommandLine object with the specified flags, and
//				prepares to parse the command line searching for the given items.
//
// Arguments:
//	DWORD dwFlags						The flags for the behavior you want.
//	PCMDLINEHANDLEDITEM aHandledItems	Pointer to array of handled items that you
//										expect to parse.
//	DWORD dwNumHandledItems				Number of items in the preceding array.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::Initialize(DWORD dwFlags, PCMDLINEHANDLEDITEM aHandledItems,
								DWORD dwNumHandledItems)
{
	HRESULT				hr;
	CMDLINEHANDLEDITEM	stditem;
	DWORD				dwTemp;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG

	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(1, "Called with (%x, %x, %u)", 3, dwFlags, lpaHandledItems, dwNumHandledItems);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

	// Set the flags
	this->m_dwFlags = dwFlags;


	// Add built-in "ini" switch with parameter if it's allowed.

	if (! (this->m_dwFlags & CMDLINE_FLAG_DONTHANDLEINIFILES))
	{
		ZeroMemory(&stditem, sizeof (CMDLINEHANDLEDITEM));
		stditem.dwType = CMDLINE_PARAMTYPE_STRING;
		stditem.pszName = "ini";
		stditem.pszDescription = "Reads command line items from the specified file.";
		//stditem.dwOptions = 0;
		stditem.ppvValuePtr = (PVOID*) (&(this->m_pszIniFile));
		//stditem.lpvAdditionalData = NULL;
		//stditem.dwAdditionalDataSize = 0;

		hr = this->AddItemInternal(&stditem, &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding built-in item \"ini\"!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (adding the item failed)
	} // end if (ini files are allowed)


	// Add built-in "?" and "help" switches if they're allowed

	if (! (this->m_dwFlags & CMDLINE_FLAG_DONTHANDLEHELPSWITCHES))
	{
		ZeroMemory(&stditem, sizeof (CMDLINEHANDLEDITEM));
		stditem.dwType = CMDLINE_PARAMTYPE_BOOL;
		stditem.pszName = "?";
		stditem.pszDescription = "Displays help.";
		//stditem.dwOptions = 0;
		stditem.ppvValuePtr = (PVOID*) (&(this->m_fHelp));
		//stditem.lpvAdditionalData = NULL;
		//stditem.dwAdditionalDataSize = 0;

		hr = this->AddItemInternal(&stditem, &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding built-in item \"?\"!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (adding the item failed)


		// Add built-in "help" switch

		stditem.pszName = "help";

		hr = this->AddItemInternal(&stditem, &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding built-in item \"help\"!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (adding the item failed)
	} // end if (help switches are allowed)



	// Add built-in "debug" switch if it's allowed

	if (! (this->m_dwFlags & CMDLINE_FLAG_DONTHANDLEDEBUGSWITCH))
	{
		stditem.pszName = "debug";
		stditem.pszDescription = "Turns on debug mode.";
		stditem.ppvValuePtr = (PVOID*) (&(this->m_fDebug));

		hr = this->AddItemInternal(&stditem, &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding built-in item \"debug\"!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (adding the item failed)
	} // end if (debug switch is allowed)



	// Add built-in "html" switch if it's allowed

	if (! (this->m_dwFlags & CMDLINE_FLAG_DONTHANDLEHTMLSWITCH))
	{
		stditem.pszName = "html";
		stditem.pszDescription = "Turns on html mode.";
		stditem.ppvValuePtr = (PVOID*) (&(this->m_fHTML));

		hr = this->AddItemInternal(&stditem, &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding built-in item \"html\"!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (adding the item failed)
	} // end if (HTML switch is allowed)



	for(dwTemp = 0; dwTemp < dwNumHandledItems; dwTemp++)
	{
		hr = this->AddItemInternal(&(aHandledItems[dwTemp]), &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding item %u!", 1, dwTemp);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (adding the item failed)
	} // end for (each handled command line item)

	return (CMDLINE_OK);
} // CCommandLine::Initialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef CMDLINE_CONSOLE_ONLY

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::Parse(windows)"
//==================================================================================
// CCommandLine::Parse overloaded
// Windows version.
//----------------------------------------------------------------------------------
//
// Description: Parses the command line arguments passed in.
//				This is the Windows version, so call this with the parameters
//				passed into your application's WinMain() function.
//
// Arguments:
//	LPCSTR lpcszString	The command line string.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::Parse(LPCSTR lpcszString)
{
	HRESULT		hr;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we've got a bad object)
#endif // DEBUG

	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(1, "Called with (%s)", 1, lpcszString);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

	// Grab the path to the app

	if (this->m_pszPathToApp != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "WARNING: Overwriting previous path to app (was %s)!",
			1, this->m_pszPathToApp);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		LocalFree(this->m_pszPathToApp);
		this->m_pszPathToApp = NULL;
	} // end if (we already allocated a name)

	//BUGBUG _pgmptr may not contain the correct info.
	this->m_pszPathToApp = (char*) LocalAlloc(LPTR, (strlen(_pgmptr) + 1));
	if (this->m_pszPathToApp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	strcpy(this->m_pszPathToApp, _pgmptr);



	// Copy the original command line

	if (this->m_pszOriginalCommandLine != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "WARNING: Overwriting original command line (was %s)!?",
			1, this->m_pszOriginalCommandLine);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		LocalFree(this->m_pszOriginalCommandLine);
		this->m_pszOriginalCommandLine = NULL;
	} // end if (we already allocated a name)

	this->m_pszOriginalCommandLine = (char*) LocalAlloc(LPTR, strlen(lpcszString) + 1);
	if (this->m_pszOriginalCommandLine == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	strcpy(this->m_pszOriginalCommandLine, lpcszString);


	// Take out any extra spaces
	StringPopLeadingChars(this->m_pszOriginalCommandLine, " ", TRUE);
	StringPopTrailingChars(this->m_pszOriginalCommandLine, " ", TRUE);


	// If there aren't any items, and the user wants to fail in that case, then
	// do it.
	if ((strcmp(this->m_pszOriginalCommandLine, "") == 0) &&
		(this->m_dwFlags & CMDLINE_FLAG_FAILIFNOPARAMS))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "No command line parameters passed, but user required them!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = CMDLINEERR_NOPARAMSPASSED;
		goto ERROR_EXIT;
	} // end if (no command line items and should fail)


	// Actually parse it

	hr = this->ParseInternal(this->m_pszOriginalCommandLine, &(this->m_handleditems),
							&(this->m_specifieditems));
	if (hr != S_OK)
		goto ERROR_EXIT;

	return (S_OK);


ERROR_EXIT:

	if (this->m_pszOriginalCommandLine != NULL)
	{
		LocalFree(this->m_pszOriginalCommandLine);
		this->m_pszOriginalCommandLine = NULL;
	} // end if (allocated command line)

	if (this->m_pszPathToApp != NULL)
	{
		LocalFree(this->m_pszPathToApp);
		this->m_pszPathToApp = NULL;
	} // end if (allocated command line)

	return (hr);
} // CCommandLine::Parse(windows)
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! CMDLINE_CONSOLE_ONLY



#ifndef CMDLINE_WINDOWS_ONLY

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::Parse(console)"
//==================================================================================
// CCommandLine::Parse overloaded
// Console version.
//----------------------------------------------------------------------------------
//
// Description: Parses the command line arguments passed in.
//				This is the console version, so call this with the parameters
//				passed into your application's main() function.
//
// Arguments:
//	int iNumArgs		The number of arguments in the string array.
//	char* aszArgsArray	The array of command line arguments.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::Parse(int iNumArgs, char* aszArgsArray[])
{
	HRESULT		hr;
	int			i;
	DWORD		dwLength = 0;
	
	
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we've got a bad object)
#endif // DEBUG

	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "Called with (%i,  %x)", 2, iNumArgs, aszArgsArray);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	// Make note of the fact we're in a console app
	this->m_fConsole = TRUE;
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)


	// Grab the application path.

	if (this->m_pszPathToApp != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "WARNING: Overwriting previous path to app (was %s)!?",
			1, this->m_pszPathToApp);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		LocalFree(this->m_pszPathToApp);
		this->m_pszPathToApp = NULL;
	} // end if (we already allocated a name)

	this->m_pszPathToApp = (char*) LocalAlloc(LPTR, (strlen(aszArgsArray[0]) + 1));
	if (this->m_pszPathToApp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	strcpy(this->m_pszPathToApp, aszArgsArray[0]);


	// Now we want to flatten out the command line into all one string. Start at 1
	// because first parameter passed is the path of the app.
	for(i = 1; i < iNumArgs; i++)
	{
		dwLength += strlen(aszArgsArray[i]);

		// If this isn't the last item, add room for a space character
		if (i < iNumArgs)
			dwLength++;
	} // end for (loop through all the passed arguments)



	// If there aren't any items, and the user wants to fail in that case, then
	// do it.
	if ((dwLength == 0) && (this->m_dwFlags & CMDLINE_FLAG_FAILIFNOPARAMS))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "No command line parameters passed, but user required them!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = CMDLINEERR_NOPARAMSPASSED;
		goto ERROR_EXIT;
	} // end if (no command line items and should fail)


	if (this->m_pszOriginalCommandLine != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "WARNING: Overwriting original command line (was %s)!?",
			1, this->m_pszOriginalCommandLine);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		LocalFree(this->m_pszOriginalCommandLine);
		this->m_pszOriginalCommandLine = NULL;
	} // end if (we already allocated a name)

	this->m_pszOriginalCommandLine = (char*) LocalAlloc(LPTR, dwLength + 1); // + 1 for NULL termination
	if (this->m_pszOriginalCommandLine == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)


	// Loop through again and put in all the elements
	for(i = 1; i < iNumArgs; i++)
	{
		strcat(this->m_pszOriginalCommandLine, aszArgsArray[i]);

		// If this isn't the last item, add a space character
		if (i < iNumArgs)
			strcat(this->m_pszOriginalCommandLine, " ");
	} // end for (loop through all the passed arguments)


	// Actually parse it

	hr = this->ParseInternal(this->m_pszOriginalCommandLine, &(this->m_handleditems),
							&(this->m_specifieditems));
	if (hr != S_OK)
		goto ERROR_EXIT;

	return (S_OK);


ERROR_EXIT:

	if (this->m_pszOriginalCommandLine != NULL)
	{
		LocalFree(this->m_pszOriginalCommandLine);
		this->m_pszOriginalCommandLine = NULL;
	} // end if (allocated command line)

	if (this->m_pszPathToApp != NULL)
	{
		LocalFree(this->m_pszPathToApp);
		this->m_pszPathToApp = NULL;
	} // end if (allocated command line)

	return (hr);
} // CCommandLine::Parse(console)
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! CMDLINE_WINDOWS_ONLY




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::InHelpMode()"
//==================================================================================
// CCommandLine::InHelpMode
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if a help switch was specified (which can't happen if
//				the help switch is not allowed) or a required parameter wasn't
//				found and CMDLINE_FLAG_MISSINGPARAMMEANSHELP was specifed.
//
// Arguments: None.
//
// Returns: TRUE if help switch was specified or param was missing, FALSE otherwise.
//==================================================================================
BOOL CCommandLine::InHelpMode(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	return (this->m_fHelp);
} // CCommandLine::InHelpMode
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::InDebugMode()"
//==================================================================================
// CCommandLine::InDebugMode
//----------------------------------------------------------------------------------
//
// Description: Returns whether the debug switch was specified (this will always
//				return FALSE if the debug switch is not allowed).
//
// Arguments: None.
//
// Returns: TRUE if debug switch was allowed and specified, FALSE otherwise.
//==================================================================================
BOOL CCommandLine::InDebugMode(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	return (this->m_fDebug);
} // CCommandLine::InDebugMode
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::InHTMLMode()"
//==================================================================================
// CCommandLine::InHTMLMode
//----------------------------------------------------------------------------------
//
// Description: Returns whether the HTML switch was specified (this will always
//				return FALSE if the HTML switch is not allowed).
//
// Arguments: None.
//
// Returns: TRUE if HTML switch was allowed and specified, FALSE otherwise.
//==================================================================================
BOOL CCommandLine::InHTMLMode(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	return (this->m_fHTML);
} // CCommandLine::InHTMLMode
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::DisplayHelp()"
//==================================================================================
// CCommandLine::DisplayHelp
//----------------------------------------------------------------------------------
//
// Description: Displays a window with (or prints to the console if in a console
//				app) all the commmand line parameters along with their descriptions
//				given to Initialize.
//				IMPORTANT: Parse must have been called prior to this function!
//
// Arguments:
//	BOOL fAlphabetize	Whether to alphabetize the items when displaying them.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::DisplayHelp(BOOL fAlphabetize)
{
	HRESULT				hr = CMDLINE_OK;
	PHANDLEDPARAM		pParam = NULL;
	HWND				hHelpWnd = NULL;
#ifndef CMDLINE_CONSOLE_ONLY
	WNDCLASSEX			wcex;
	HDC					hdc = NULL;
	MSG					msg;
	SIZE				size;
	DWORD				dwLongestNameLength = 0;
	DWORD				dwNameLength;
	DWORD				dwTemp;
#endif // ! CMDLINE_CONSOLE_ONLY
	LONG				lLeftWidth;
	LONG				lRightWidth;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG

	//BUGBUG make sure we're not already in help mode

	// Allocate room for the maximum number of items
	this->m_papHelpItems = (PHANDLEDPARAM*) LocalAlloc(LPTR, (this->m_handleditems.Count() * sizeof (PHANDLEDPARAM)));
	if (this->m_papHelpItems == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	// This boolean is only set by calling the Console version of Parse.
	if (this->m_fConsole)
	{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_WINDOWS_ONLY
		this->m_lMaxHelpLineWidth = 77;

		printf("Command line parameters:\n");
#endif // ! CMDLINE_WINDOWS_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	} // end if (console app)
	else
	{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_CONSOLE_ONLY
		this->m_lMaxHelpLineWidth = 595;
		this->m_lMaxHelpHeight = 350;

		ZeroMemory(&wcex, sizeof (WNDCLASSEX));
		wcex.cbSize = sizeof (WNDCLASSEX);
		GetClassInfoEx(NULL, WC_DIALOG, &wcex);
		wcex.lpfnWndProc = (WNDPROC)HelpBoxWndProc;
#ifdef LOCAL_TNCOMMON
		wcex.hInstance = NULL;
#else
		wcex.hInstance = s_hInstance;
#endif // ! LOCAL_TNCOMMON
		wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
		wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
		wcex.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
		wcex.lpszMenuName = NULL;
		wcex.lpszClassName = WINDOWCLASS_CMDLINE_HELPBOX;
		wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

		if (! RegisterClassEx(&wcex))
		{
			hr = GetLastError();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't register window class!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't register class)

#ifdef LOCAL_TNCOMMON
		hHelpWnd = CreateDialog(NULL, MAKEINTRESOURCE(IDD_HELP), NULL,
								HelpBoxWndProc);
#else
		hHelpWnd = CreateDialog(s_hInstance, MAKEINTRESOURCE(IDD_HELP), NULL,
								HelpBoxWndProc);
#endif // ! LOCAL_TNCOMMON
		if (hHelpWnd == NULL)
		{
			hr = GetLastError();

			if (hr == S_OK)
				hr = E_FAIL;

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't create help dialog!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't create dialog)

		// Store the object pointer with the window
		SetWindowLongPtr(hHelpWnd, 0, (LONG_PTR) this);


		hdc = GetDC(hHelpWnd);
		if (hdc == NULL)
		{
			hr = GetLastError();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get window's device context!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't get device context)
#endif // ! CMDLINE_CONSOLE_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	} // end else (Windows app)
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)


	do
	{
		pParam = (PHANDLEDPARAM) this->m_handleditems.GetNextItem(pParam);
		if (pParam == NULL)
			break;


		// If it's a hidden option, don't display it
		if (pParam->m_dwOptions & CMDLINE_PARAMOPTION_HIDDEN)
			continue;

#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		if (this->m_fConsole)
		{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_WINDOWS_ONLY
			lLeftWidth = strlen(pParam->GetString());
			lRightWidth = 0;
			if (pParam->m_pszDescription != NULL)
			{
				lRightWidth = strlen(pParam->m_pszDescription);
			} // end if (there's a description)
#endif // ! CMDLINE_WINDOWS_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		} // end if (console app)
		else
		{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_CONSOLE_ONLY

			// Make sure the temporary buffer is big enough to hold this parameter
			// name plus at least three periods.
			dwNameLength = strlen(pParam->GetString());
			if (dwLongestNameLength < (dwNameLength + 4))
			{
				if (this->m_pszTempParamNameBuffer != NULL)
				{
					LocalFree(this->m_pszTempParamNameBuffer);
					this->m_pszTempParamNameBuffer = NULL;
				} // end if (already had buffer)

				dwLongestNameLength = dwNameLength + 4;

				this->m_pszTempParamNameBuffer = (char*) LocalAlloc(LPTR, dwLongestNameLength);
				if (this->m_pszTempParamNameBuffer == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
			} // end if (we allocated a param name buffer)


			// Copy the param name (without the NULL termination).
			memcpy(this->m_pszTempParamNameBuffer, pParam->GetString(), dwNameLength);

			// Make sure remaining buffer is filled with periods.
			for(dwTemp = dwNameLength; dwTemp < (dwLongestNameLength - 1); dwTemp++)
			{
				this->m_pszTempParamNameBuffer[dwTemp] = '.';
			} // end for (each remaining character)

			// Make sure buffer is NULL terminated.
			//this->m_pszTempParamNameBuffer[dwTemp] = '\0';


			// Prepare to calculate using a fixed font.
			SelectFont(hdc, GetStockObject(ANSI_FIXED_FONT));

			if (! GetTextExtentPoint32(hdc, this->m_pszTempParamNameBuffer, dwLongestNameLength, &size))
			{
				hr = GetLastError();
				if (hr == S_OK)
					hr = E_FAIL;
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't get text extents for \"%s\"!",
					1, this->m_pszTempParamNameBuffer);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

				goto DONE;
			} // end if (couldn't get text size)

			lLeftWidth = size.cx;

			if (size.cy > this->m_lLargestHelpLineHeight)
				this->m_lLargestHelpLineHeight = size.cy;

			lRightWidth = 0;
			if (pParam->m_pszDescription != NULL)
			{
				// Prepare to calculate using a more pleasing font.
				SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));

				if (! GetTextExtentPoint32(hdc, pParam->m_pszDescription, strlen(pParam->m_pszDescription), &size))
				{
					hr = GetLastError();
					if (hr == S_OK)
						hr = E_FAIL;
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Couldn't get text extents for \"%s\"!", 1, pParam->m_pszDescription);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW

					goto DONE;
				} // end if (couldn't get text size)

				lRightWidth = size.cx;

				if (size.cy > this->m_lLargestHelpLineHeight)
					this->m_lLargestHelpLineHeight = size.cy;
			} // end if (there's a description)
#endif // ! CMDLINE_CONSOLE_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		} // end else (not a console app)
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)

		if (lLeftWidth > this->m_lLargestLeftHelpTextWidth)
		{
			// Clip the description section line length if this puts us over
			// the limit
			this->m_lLargestLeftHelpTextWidth = lLeftWidth;
			if (lLeftWidth + this->m_lLargestRightHelpTextWidth > this->m_lMaxHelpLineWidth)
				this->m_lLargestRightHelpTextWidth = this->m_lMaxHelpLineWidth - lLeftWidth;
		} // end if (this is longer than the previous longest name)

		if (lRightWidth > this->m_lLargestRightHelpTextWidth)
		{
			// Wrap to the next line if greater than the max allowable
			if (lRightWidth + this->m_lLargestLeftHelpTextWidth > this->m_lMaxHelpLineWidth)
				this->m_lLargestRightHelpTextWidth = this->m_lMaxHelpLineWidth - this->m_lLargestLeftHelpTextWidth;
			else
				this->m_lLargestRightHelpTextWidth = lRightWidth;
		} // end if (this is longer than the previous longest description)

		if (! fAlphabetize)
			this->m_papHelpItems[this->m_dwNumHelpItems++] = pParam;
		else
		{
			DWORD	dwTemp;
			DWORD	dwTemp2;


			// Loop through all the params we've put in the array so far.  If we
			// should be higher alphabetically than an item, insert it there and
			// push all the remaining ones down.  Otherwise, we'll just put it
			// at the last entry.
			for(dwTemp = 0; dwTemp < this->m_dwNumHelpItems; dwTemp++)
			{
				if (strcmp(pParam->GetString(), this->m_papHelpItems[dwTemp]->GetString()) < 0)
				{
					// Bump all current items in the table down one
					for(dwTemp2 = this->m_dwNumHelpItems; dwTemp2 > dwTemp; dwTemp2--)
					{
						this->m_papHelpItems[dwTemp2] = this->m_papHelpItems[dwTemp2 - 1];
					} // end for (each item after this in the list)

					// We found our spot, so stop
					break;
				} // end if (we should place the new item before the current item)
			} // end for (each existing item)

			// Store this item in the current spot and increment the count
			this->m_papHelpItems[dwTemp] = pParam;
			this->m_dwNumHelpItems++;
		} // end else (we should alphabetize the items)
	} // end do (while not done with list of parameters)
	while (pParam != NULL);


	this->m_dwHelpStartItem = 0;


	// Display the first page of help items.  hHelpWnd is ignored if in
	// console mode (it's NULL then anyway).
	hr = this->DisplayHelpPageInternal(&(this->m_dwHelpStartItem), hHelpWnd);
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't display first help page!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (displaying first help page failed)


	// If we're displaying a Window, wait for it to be closed.
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	if (! this->m_fConsole)
	{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_CONSOLE_ONLY
		ShowWindow(hHelpWnd, SW_SHOW); // ignoring error

		while(GetMessage(&msg, NULL, 0, 0) > 0)
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		} // end while (there's a non-quit message)
#endif // ! CMDLINE_CONSOLE_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	} // end if (Windows app)
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)


DONE:

#ifndef CMDLINE_CONSOLE_ONLY
	if (hdc != NULL)
	{
		ReleaseDC(hHelpWnd, hdc); // ignore error;
		hdc = NULL;
	} // end if (got device context)

	if (this->m_pszTempParamNameBuffer != NULL)
	{
		LocalFree(this->m_pszTempParamNameBuffer);
		this->m_pszTempParamNameBuffer = NULL;
	} // end if (we allocated a param name buffer)
#endif // ! CMDLINE_CONSOLE_ONLY

	if (this->m_papHelpItems != NULL)
	{
		LocalFree(this->m_papHelpItems);
		this->m_papHelpItems = NULL;
	} // end if (allocated an arrary for param items)

	this->m_dwNumHelpItems = 0;

	return (hr);
} // CCommandLine::DisplayHelp
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
//#pragma TODO(tristanj, "No help displayed")
#endif // XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::CheckForItem()"
//==================================================================================
// CCommandLine::CheckForItem
//----------------------------------------------------------------------------------
//
// Description: Adds an item to parse on the command line.  This must be called
//				after Parse.
//
// Arguments:
//	PCMDLINEHANDLEDITEM pHandledItem	Pointer to items that you want to parse.
//	BOOL* pfWasSpecified				Optional pointer to boolean to set to TRUE
//										if it was actually found on the command
//										line, FALSE otherwise.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::CheckForItem(PCMDLINEHANDLEDITEM pHandledItem,
									BOOL* pfWasSpecified)
{
	HRESULT			hr;
	PHANDLEDPARAM	pParam;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we've got a bad object)
#endif // DEBUG

	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(1, "Called with (%x, %x)", 2, pHandledItem, pfWasSpecified);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

	hr = this->AddItemInternal(pHandledItem, &(this->m_handleditems));
	if (hr != CMDLINE_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Failed adding item!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (adding the item failed)


	// Get the last item
	pParam = (PHANDLEDPARAM) this->m_handleditems.GetPrevItem(NULL);
	if (pParam == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't get item just added!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		hr = E_FAIL;
		goto DONE;
	} // end if (adding the item failed)


	// Now try to read it from the remaining command line values
	hr = pParam->GetSelfAndValues(((this->m_dwFlags & CMDLINE_FLAG_CASESENSITIVE) ? TRUE : FALSE),
									&(this->m_specifieditems));
	if (hr != CMDLINE_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Failed getting parameter and value!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (failed getting param from command line)


	if (pfWasSpecified != NULL)
		(*pfWasSpecified) = pParam->m_fFound;

DONE:

	return (hr);
} // CCommandLine::CheckForItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::CheckForItems()"
//==================================================================================
// CCommandLine::CheckForItems
//----------------------------------------------------------------------------------
//
// Description: Adds items to parse on the command line.  This must be called after
//				Parse.
//
// Arguments:
//	PCMDLINEHANDLEDITEM aHandledItems	Array of items that you want to parse.
//	DWORD dwNumHandledItems				Number of items in previous array.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::CheckForItems(PCMDLINEHANDLEDITEM aHandledItems,
									DWORD dwNumHandledItems)
{
	HRESULT			hr;
	DWORD			dwTemp;
	PHANDLEDPARAM	pParam;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we've got a bad object)
#endif // DEBUG

	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(1, "Called with (%x, %u)", 2, aHandledItems, dwNumHandledItems);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

	for(dwTemp = 0; dwTemp < dwNumHandledItems; dwTemp++)
	{
		hr = this->AddItemInternal(&(aHandledItems[dwTemp]), &(this->m_handleditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed adding item!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (adding the item failed)


		// Get the last item
		pParam = (PHANDLEDPARAM) this->m_handleditems.GetPrevItem(NULL);
		if (pParam == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get item just added!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			hr = E_FAIL;
			goto DONE;
		} // end if (adding the item failed)


		// Now try to read it from the remaining command line values
		hr = pParam->GetSelfAndValues(((this->m_dwFlags & CMDLINE_FLAG_CASESENSITIVE) ? TRUE : FALSE),
										&(this->m_specifieditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed getting parameter and value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (failed getting param from command line)
	} // end for (each handled item)


DONE:

	return (hr);
} // CCommandLine::CheckForItems
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::GetPathToApp()"
//==================================================================================
// CCommandLine::GetPathToApp
//----------------------------------------------------------------------------------
//
// Description: Copies the path to this application into the string.  If the buffer
//				is NULL, the size required (including NULL termination) for the
//				string is placed in pdwBufferSize, and ERROR_BUFFER_TOO_SMALL is
//				returned.
//
// Arguments:
//	char* pszBuffer			String to store results in, or NULL to retrieve size.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::GetPathToApp(char* pszBuffer, DWORD* pdwBufferSize)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG


	if (pszBuffer == NULL)
	{
		(*pdwBufferSize) = strlen(this->m_pszPathToApp) + 1;
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (just retrieving size)
	
	strcpy(pszBuffer, this->m_pszPathToApp);

	return (CMDLINE_OK);
} // CCommandLine::GetPathToApp
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // not supported on Xbox
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::GetPathToAppDir()"
//==================================================================================
// CCommandLine::GetPathToAppDir
//----------------------------------------------------------------------------------
//
// Description: Copies the path to this application's directory into the string.  If
//				the buffer is NULL, the size required (including NULL termination)
//				for the string is placed in pdwBufferSize, and
//				ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	char* pszBuffer			String to store results in, or NULL to retrieve size.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::GetPathToAppDir(char* pszBuffer, DWORD* pdwBufferSize)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG


	// The size returned is actually too large (it's for the entire string, not just
	// the parent dir path).  Oh well.
	if (pszBuffer == NULL)
	{
		(*pdwBufferSize) = strlen(this->m_pszPathToApp) + 1;
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (just retrieving size)
	
	FileGetParentDirFromPath(this->m_pszPathToApp, pszBuffer);
	
	return (CMDLINE_OK);
} // CCommandLine::GetPathToAppDir
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // not supported on Xbox
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::GetNameOfApp()"
//==================================================================================
// CCommandLine::GetNameOfApp
//----------------------------------------------------------------------------------
//
// Description: Copies the name of this application into the string.  If the buffer
//				is NULL, the size required (including NULL termination) for the
//				string is placed in pdwBufferSize, and ERROR_BUFFER_TOO_SMALL is
//				returned.
//
// Arguments:
//	char* pszBuffer			String to store results in, or NULL to retrieve size.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::GetNameOfApp(char* pszBuffer, DWORD* pdwBufferSize)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG



	// The size returned is actually too large (it's for the entire string, not just
	// the app name).  Oh well.
	if (pszBuffer == NULL)
	{
		(*pdwBufferSize) = strlen(this->m_pszPathToApp) + 1;
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (just retrieving size)

	FileGetLastItemInPath(this->m_pszPathToApp, pszBuffer);

	return (CMDLINE_OK);
} // CCommandLine::GetNameOfApp
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::WasSpecified()"
//==================================================================================
// Overloaded CCommandLine::WasSpecified
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the item passed in was overridden with a value from
//				the command line, FALSE otherwise.  Note this must match a value
//				specified as a ppvValuePtr in the array passed to Initialize.
//
// Arguments:
//	PVOID* ppvItem		Pointer to item that was given to Initialize.
//
// Returns: TRUE if item was overridden, FALSE if still default.
//==================================================================================
BOOL CCommandLine::WasSpecified(PVOID* ppvItem)
{
	PHANDLEDPARAM	pParam = NULL;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	do
	{
		pParam = (PHANDLEDPARAM) this->m_handleditems.GetNextItem(pParam);
		if (pParam == NULL)
			break;

		if (pParam->m_ppvValuePtr == ppvItem)
			return (pParam->m_fFound);
	} // end do
	while (pParam != NULL);

	return (FALSE);
} // CCommandLine::WasSpecified()
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::GetSwitchValueString()"
//==================================================================================
// CCommandLine::GetSwitchValueString
//----------------------------------------------------------------------------------
//
// Description: Returns pointer to the string value of the switch with the given
//				name.  This will return NULL if an error occurred, or the default
//				value if it was not specified.  If you want to know whether this
//				item was specified or not, you will have to use NULL for the default
//				value, and check whether the return value is NULL.
//				If you did not pass an item with the same name into Initialize, then
//				it is added here and its value returned.  If it was not found on the
//				command line, NULL is returned.
//
// Arguments:
//	char* szName	Name of an item passed to Initialize, or new item to add.
//
// Returns: Pointer to string value of switch given, or NULL.
//==================================================================================
char* CCommandLine::GetSwitchValueString(char* szName)
{
	HRESULT				hr;
	PHANDLEDPARAM		pParam = NULL;
	BOOL				fMatch = FALSE;
	CMDLINEHANDLEDITEM	newitem;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	do
	{
		pParam = (PHANDLEDPARAM) this->m_handleditems.GetNextItem(pParam);
		if (pParam == NULL)
			break;

		// If this item isn't a string, skip it
		if (pParam->m_dwType != CMDLINE_PARAMTYPE_STRING)
			continue;

		if (this->m_dwFlags & CMDLINE_FLAG_CASESENSITIVE)
			fMatch = (strcmp(szName, pParam->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(szName, pParam->GetString());

		if (fMatch)
			return (((PHANDLEDPARAMSTRING) pParam)->m_pszValue);
	} // end do
	while (pParam != NULL);


	// We didn't find the item specified, so it appears it wasn't passed to
	// Initialize.  Let's build it and add it now.
	ZeroMemory(&newitem, sizeof (CMDLINEHANDLEDITEM));
	newitem.dwType = CMDLINE_PARAMTYPE_STRING;
	newitem.pszName = szName;
	//newitem.pszDescription = NULL;
	newitem.dwOptions = CMDLINE_PARAMOPTION_HIDDEN;
	//newitem.ppvValuePtr = NULL;
	//newitem.lpvAdditionalData = NULL;
	//newitem.dwAdditionalDataSize = 0;

	//BUGBUG do we want to add it to the main list or just some temp one?
	hr = this->AddItemInternal(&newitem, &(this->m_handleditems));
	if (hr != CMDLINE_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Failed adding built-in item \"ini\"!  %e", 1, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (NULL);
	} // end if (adding the item failed)

	// Get the last item
	pParam = (PHANDLEDPARAM) this->m_handleditems.GetPrevItem(NULL);
	if (pParam == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't get item just added!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (NULL);
	} // end if (adding the item failed)

	//BUGBUG check to make sure it's the right one


	// Now try to read it from the remaining command line values
	hr = pParam->GetSelfAndValues(((this->m_dwFlags & CMDLINE_FLAG_CASESENSITIVE) ? TRUE : FALSE),
									&(this->m_specifieditems));
	if (hr != CMDLINE_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Failed getting parameter and value!  %e", 1, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (NULL);
	} // end if (failed getting param from command line)

	// If getting the value found it, this will be the value, otherwise it will be
	// NULL.  That's what we want, so just return it now.
	return (((PHANDLEDPARAMSTRING) pParam)->m_pszValue);
} // CCommandLine::GetSwitchValueString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no INI files supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::WriteToINI()"
//==================================================================================
// CCommandLine::WriteToINI
//----------------------------------------------------------------------------------
//
// Description: Writes all parsable command line items with the actual values to the
//				specified .ini file.
//
// Arguments:
//	char* szFilepath	Path to .ini file to write command line to.
//	DWORD dwOptions		Options to use when writing file.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::WriteToINI(char* szFilepath, DWORD dwOptions)
{
	HRESULT			hr;
	HANDLE			hFile = INVALID_HANDLE_VALUE;
	int				i;
	//int				j;
	PHANDLEDPARAM	pParam = NULL;
	char*			pszTemp;
	char*			pcTemp;
	char*			pcTemp2;



	hr = FileCreateAndOpenFile(szFilepath,
							((dwOptions & CMDLINE_WRITEINIOPTION_FAILIFEXISTS) ? TRUE : FALSE),
							((dwOptions & CMDLINE_WRITEINIOPTION_APPEND) ? TRUE : FALSE),
							FALSE,
							&hFile);
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't create and open file \"%s\"!", 1, szFilepath);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (couldn't open file)

	FileWriteLine(hFile, "[CommandLine]");

	for(i = 0; i < this->m_handleditems.Count(); i++)
	{
		pParam = (PHANDLEDPARAM) this->m_handleditems.GetItem(i);
		if (pParam == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get command line item %i!", 1, i);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		if ((dwOptions & CMDLINE_WRITEINIOPTION_PRINTDESCRIPTIONS) &&
			(pParam->m_pszDescription != NULL))
		{
			/*
			FileWriteString(hFile, "//");
			// - 2 for "//"
			for(j = WRAP_DESCRIPTION_CHARACTERS - 2; j > 0; j--)
				FileWriteString(hFile, "-");
			FileWriteLine(hFile, "");
			*/


			pszTemp = pParam->m_pszDescription;

			do
			{
				// + 3 for "// "
				if (strlen(pszTemp) > (WRAP_DESCRIPTION_CHARACTERS + 3))
				{
					pcTemp = pszTemp + (WRAP_DESCRIPTION_CHARACTERS - 4);

					// Walk back until we find an appropriate place to word-wrap.
					while ((*pcTemp) != ' ')
					{
						pcTemp--;

						// If we're about to hit the beginning, we have to stop and
						// just break the line in the middle of the text.
						if (pcTemp == pszTemp + 1)
						{
							pcTemp = pszTemp + WRAP_DESCRIPTION_CHARACTERS - 4;
							break;
						} // end if (about to hit beginning)
					} // end while (haven't found space)

					// Skip all preceding spaces
					pcTemp2 = pcTemp;
					while (((*pcTemp2) == ' ') && (pcTemp2 > pszTemp))
						pcTemp2--;

					// Write this segment of the string, ignoring error.
					FileSprintfWriteLine(hFile, "// %z", 2, pszTemp,
										((pcTemp2 + 1) - pszTemp));

					// Skip all trailing spaces
					while (((*pcTemp) == ' ') && ((*pcTemp) != '\0'))
						pcTemp++;


					pszTemp += pcTemp - pszTemp;
				} // end if (longer than the line we want)
				else
				{
					// Ignore error
					FileSprintfWriteLine(hFile, "// %s", 1, pszTemp);

					pszTemp += strlen(pszTemp);
				} // end else (fits in one line)
			} // end do (while there's more string left)
			while (pszTemp[0] != '\0');


			/*
			FileWriteString(hFile, "//");
			// - 2 for "//"
			for(j = WRAP_DESCRIPTION_CHARACTERS - 2; j > 0; j--)
				FileWriteString(hFile, "-");
			FileWriteLine(hFile, "");
			*/
		} // end if (we can print description and there is one)


		// Ignore error
		pParam->PrintToFile(hFile,
							((dwOptions & CMDLINE_WRITEINIOPTION_PRINTDESCRIPTIONS) ? TRUE : FALSE));


		if ((dwOptions & CMDLINE_WRITEINIOPTION_PRINTDESCRIPTIONS))
		{
			// Space out the items, ignoring error
			FileWriteLine(hFile, "");
		} // end if (printing descriptions)
	} // end for (each item)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (file is still open)

	return (hr);
} // CCommandLine::WriteToINI
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::AddItemInternal()"
//==================================================================================
// CCommandLine::AddItemInternal
//----------------------------------------------------------------------------------
//
// Description: Adds the specified item to the list.
//
// Arguments:
//	PCMDLINEHANDLEDITEM pItem			Pointer to the item to add.
//	PHANDLEDPARAMSLIST pHandledItems	Pointer to list to add item to.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::AddItemInternal(PCMDLINEHANDLEDITEM pItem,
										PHANDLEDPARAMSLIST pHandledItems)
{
	HRESULT			hr = CMDLINE_OK;
	PHANDLEDPARAM	pParam = NULL;


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "Adding cmdline item \"%s\".", 1, lpItem->pszName);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

	pParam = (PHANDLEDPARAM) pHandledItems->GetStringObject(pItem->pszName, 0,
															((this->m_dwFlags & CMDLINE_FLAG_CASESENSITIVE) ? TRUE : FALSE));
	if (pParam != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Already specified an item with name \"%s\"!",
			1, pItem->pszName);
		#endif // NO_TNCOMMON_DEBUG_SPEW
		return (CMDLINEERR_DUPLICATEHANDLEDITEM);
	} // end if (user already specified that name)


	switch (pItem->dwType)
	{
		case CMDLINE_PARAMTYPE_BOOL:
			pParam = (PHANDLEDPARAM) new (CHandledParamBool)(pItem->pszName,
															pItem->pszDescription,
															pItem->dwOptions,
															pItem->ppvValuePtr);
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add boolean \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		case CMDLINE_PARAMTYPE_INT:
			pParam = (PHANDLEDPARAM) new (CHandledParamInt)(pItem->pszName,
															pItem->pszDescription,
															pItem->dwOptions,
															pItem->ppvValuePtr);
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add int \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		case CMDLINE_PARAMTYPE_DWORD:
			pParam = (PHANDLEDPARAM) new (CHandledParamDWord)(pItem->pszName,
															pItem->pszDescription,
															pItem->dwOptions,
															pItem->ppvValuePtr);
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add DWORD \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		case CMDLINE_PARAMTYPE_DWORD_HEX:
			pParam = (PHANDLEDPARAM) new (CHandledParamDWordHex)(pItem->pszName,
																pItem->pszDescription,
																pItem->dwOptions,
																pItem->ppvValuePtr);
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add DWORD_HEX \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		case CMDLINE_PARAMTYPE_STRING:
			pParam = (PHANDLEDPARAM) new (CHandledParamString)(pItem->pszName,
																pItem->pszDescription,
																pItem->dwOptions,
																pItem->ppvValuePtr);
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add string \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		case CMDLINE_PARAMTYPE_ID:
			if ((pItem->pvAdditionalData == NULL) ||
				(pItem->dwAdditionalDataSize < (sizeof (CMDLINEIDITEM))))
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "ID Item table is invalid!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW
				hr = CMDLINEERR_INVALIDINITDATA;
				break;
			} // end if (user didn't give a valid table)

			pParam = (PHANDLEDPARAM) new (CHandledParamID)(pItem->pszName,
															pItem->pszDescription,
															pItem->dwOptions,
															pItem->ppvValuePtr,
															(PCMDLINEIDITEM) (pItem->pvAdditionalData),
															(pItem->dwAdditionalDataSize / sizeof (CMDLINEIDITEM)));
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add ID \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		case CMDLINE_PARAMTYPE_MULTISTRING:
			pParam = (PHANDLEDPARAM) new (CHandledParamMultiString)(pItem->pszName,
																	pItem->pszDescription,
																	pItem->dwOptions,
																	pItem->ppvValuePtr);
			if (pParam == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			} // end if (couldn't allocate object)

			hr = pHandledItems->Add(pParam);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add multistring \"%s\" to list!",
					1, pItem->pszName);
				#endif // NO_TNCOMMON_DEBUG_SPEW

				delete (pParam);
				pParam = NULL;

				//break;
			} // end if (couldn't allocate object)
		  break;

		default:
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Unknown item type %u!", 1, pItem->dwType);
			#endif // NO_TNCOMMON_DEBUG_SPEW
			hr = CMDLINEERR_UNKNOWNITEMTYPE;
		  break;
	} // end switch (on item type)

	return (hr);
} // CCommandLine::AddItemInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::ParseInternal()"
//==================================================================================
// CCommandLine::ParseInternal
//----------------------------------------------------------------------------------
//
// Description: Parses the command line arguments passed in.
//
// Arguments:
//	char* szCommandLine						The command line string to parse.
//	PHANDLEDPARAMSLIST pHandledItems		Pointer to list containing handled
//											items.
//	PSPECIFIEDPARAMSLIST pSpecifiedItems	Pointer to list to hold remaining
//											specified items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::ParseInternal(char* szCommandLine,
									PHANDLEDPARAMSLIST pHandledItems,
									PSPECIFIEDPARAMSLIST pSpecifiedItems)
{
	HRESULT			hr;
	BOOL			fDone = FALSE;
	DWORD			dwIndex = 0;
	DWORD			dwItemStart = 0xFFFFFFFF;
	DWORD			dwQuoteStart = 0xFFFFFFFF;
	BOOL			fSwitch;
	PHANDLEDPARAM	pParam = NULL;


	// Split line into spaced components but spaces inside non-escaped quote
	// characters don't count.
	do
	{
		switch (szCommandLine[dwIndex])
		{
			case '\0':
				// End of the string.  If we're in an item, add it.
				if (dwItemStart != 0xFFFFFFFF)
				{
					// If the item starts with a switch character, it's a switch
					if (StringContainsChar(CMDLINE_SWITCH_TOKENS, szCommandLine[dwItemStart], TRUE, 0) >= 0)
						fSwitch = TRUE;
					else
						fSwitch = FALSE;

					// Skip past the switch char if it's there, and allow it to be
					// split.
					hr = pSpecifiedItems->AddItem(((fSwitch) ? szCommandLine + dwItemStart + 1 : szCommandLine + dwItemStart),
													fSwitch, TRUE, FALSE);
					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't add string!", 0);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						return (hr);
					} // end if (couldn't add string)

					dwItemStart = 0xFFFFFFFF;
				} // end if (in the middle of an item)

				fDone = TRUE;
			  break;

			case ' ':
				// Space.  If we're in a non-quoted item, add it.
				if ((dwItemStart != 0xFFFFFFFF) && (dwQuoteStart == 0xFFFFFFFF))
				{
					// If the item starts with a switch character, it's a switch
					if (StringContainsChar(CMDLINE_SWITCH_TOKENS, szCommandLine[dwItemStart], TRUE, 0) >= 0)
						fSwitch = TRUE;
					else
						fSwitch = FALSE;

					szCommandLine[dwIndex] = '\0'; // temporarily end the string here

					// Skip past the switch char if it's there, and allow it to be
					// split.
					hr = pSpecifiedItems->AddItem(((fSwitch) ? szCommandLine + dwItemStart + 1 : szCommandLine + dwItemStart),
													fSwitch, TRUE, FALSE);

					szCommandLine[dwIndex] = ' '; // go back to it being a space

					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't add string!", 0);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						return (hr);
					} // end if (couldn't add string)

					dwItemStart = 0xFFFFFFFF;
				} // end if (in the middle of an item)
			  break;

			case '\"':
				// Quote character.  Start or end the quotes, unless this quote
				// character is escaped.

				if ((dwIndex <= 0) || (szCommandLine[dwIndex - 1] != '\\'))
				{
					if (dwQuoteStart == 0xFFFFFFFF)
					{
						if (dwItemStart == 0xFFFFFFFF)
							dwItemStart = dwIndex;

						dwQuoteStart = dwIndex;
					} // end if (we're starting a quote)
					else
					{
						dwQuoteStart = 0xFFFFFFFF;
					} // end else (we're ending a quote)
				} // end if (non-escaped character)
			  break;

			default:
				// Any other characters.  Just treat it as an item start.
				if (dwItemStart == 0xFFFFFFFF)
					dwItemStart = dwIndex;
			  break;
		} // end switch (on the current character)

		dwIndex++;
	} // end do (while not at the end of the string)
	while (! fDone);


	// We now have a list of individual strings.  We want to parse them as
	// appropriate.

#ifndef _XBOX // no INI files just yet...
	// If the user specified INI files as allowable, check for that first.
	if (! (this->m_dwFlags & CMDLINE_FLAG_DONTHANDLEINIFILES))
	{
		// The first item should be "ini".  And if it was specified, we want to
		// read the file in now, so we only have to parse once.  Things still on
		// the command line override what was in the .ini file, since ini items are
		// added at the end of the list.

		pParam = (PHANDLEDPARAM) pHandledItems->GetNextItem(pParam);
		if ((pParam == NULL) || (strcmp(pParam->GetString(), "ini") != 0))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "First parameter wasn't \"%ini\"!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (ERROR_BAD_ENVIRONMENT);
		} // end if (first item wasn't ini)
		

		// "ini" is always case insensitive, hence FALSE
		hr = pParam->GetSelfAndValues(FALSE, &(this->m_specifieditems));
		if (hr != CMDLINE_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get \"%ini\" from command line!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			return (hr);
		} // end if (failed getting ini from command line)
		

		// If we found the ini file, we want to read it in right now before
		// continuing.
		if (pParam->m_fFound)
		{
			DWORD	dwSize;
			char*	pszSpecifiedPath;
			char*	pszRealPath;


			// Add a NULL string.  Since the GetSelfAndValues parsers may try to
			// grab "the next item", meaning it may find a switch with no value in
			// the same string so it has to retrieve the next string, tacking on all
			// the ini file items at the end may cause it to walk off the command
			// line and into the ini file entries, which is obviously not good.
			// Adding a NULL separator forces it to stop in case it was going to.
			hr = pSpecifiedItems->AddItem(NULL, FALSE, FALSE, FALSE);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add NULL string to list!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				return (hr);
			} // end if (failed getting ini from command line)


			pszSpecifiedPath = ((PHANDLEDPARAMSTRING) pParam)->m_pszValue;

			dwSize = strlen(pszSpecifiedPath) + 1; // + NULL termination

			// Check for surrounding quotes.
			if (StringStartsWith(pszSpecifiedPath, "\"", TRUE))
			{
				if ((! StringEndsWith(pszSpecifiedPath, "\"", TRUE)) ||
					(StringIsCharBackslashEscaped(pszSpecifiedPath, pszSpecifiedPath + strlen(pszSpecifiedPath))))
				{
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Ini path starts but doesn't end with a non-escaped quote character!", 0);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW
					return (E_FAIL);
				} // end if (string doesn't end with a quote)

				dwSize -= 2;
			} // end if (item is surrounded by quotes)

			pszRealPath = (char*) LocalAlloc(LPTR, dwSize);
			if (pszRealPath == NULL)
			{
				return (E_OUTOFMEMORY);
			} // end if (couldn't allocate memory)

			if (StringStartsWith(pszSpecifiedPath, "\"", TRUE))
			{
				CopyMemory(pszRealPath, pszSpecifiedPath + 1,
							strlen(pszSpecifiedPath) - 2);
			} // end if (item is surrounded by quotes)
			else
			{
				strcpy(pszRealPath, pszSpecifiedPath);
			} // end else (item is not surrounded by quotes)


			hr = this->ReadIniFileInternal(pszRealPath, pSpecifiedItems);
			if (hr != CMDLINE_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't read ini file \"%s\"!", 1, pszRealPath);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

				LocalFree(pszRealPath);
				pszRealPath = NULL;

				return (hr);
			} // end if (failed getting ini from command line)

			LocalFree(pszRealPath);
			pszRealPath = NULL;
		} // end if (we found ini on the command line)
	} // end if (ini files are allowable)
#endif // ! XBOX

	// Now loop through the rest of the handled items and find them in the command
	// line.
	do
	{
		pParam = (PHANDLEDPARAM) pHandledItems->GetNextItem(pParam);
		if (pParam == NULL)
			break;

		hr = pParam->GetSelfAndValues(((this->m_dwFlags & CMDLINE_FLAG_CASESENSITIVE) ? TRUE : FALSE),
										&(this->m_specifieditems));
		if (hr != CMDLINE_OK)
			return (hr);

		// If this item was supposed to be on the command line, but we didn't find
		// it, then return an error.
		if ((! pParam->m_fFound) &&
			(pParam->m_dwOptions & CMDLINE_PARAMOPTION_FAILIFNOTEXIST))
		{
			if (this->m_dwFlags & CMDLINE_FLAG_MISSINGPARAMMEANSHELP)
			{
				// Put us into help mode
				this->m_fHelp = TRUE;
			} // end if (should go into help mode)
			else
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't find required parameter \"%s\"!",
					1, pParam->GetString());
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

				return (CMDLINEERR_REQUIREDPARAMNOTPASSED);
			} // end else (should fail directly)
		} // end if (param had to be there but it wasn't)
	} // end do (while haven't looked at all the handled items)
	while (TRUE);

	return (CMDLINE_OK);
} // CCommandLine::ParseInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no INI files just yet...
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::ReadIniFileInternal()"
//==================================================================================
// CCommandLine::ReadIniFileInternal
//----------------------------------------------------------------------------------
//
// Description: Reads the INI file specified and loads all the items into the string
//				list passed in.  If the given item doesn't end in an extension, .ini
//				is assumed.
//
// Arguments:
//	char* szFilepath				The path to the INI file to read.
//	PSPECIFIEDPARAMSLIST pItemList	Pointer to the list to add the items to.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CCommandLine::ReadIniFileInternal(char* szFilepath,
										PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT					hr = CMDLINE_OK;
	char					szExtension[32];
	DWORD					dwTempSize;
	char*					pszTemp = NULL;
	CMDLINEREADFILECONTEXT	clrfc;


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(1, "Called with (%s, %x).", 2, szFilepath, lpItemList);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	// Build the file path.  It's just a straight copy of the one passed in unless
	// the path doesn't end in an extension, in which case ".ini" is tacked on.

	dwTempSize = strlen(szFilepath) + 1;
	if (dwTempSize <= 1)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Bad file path specified!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't open file)

	ZeroMemory(szExtension, 32);
	FileGetExtension(szFilepath, szExtension, FALSE);
	if (strcmp(szExtension, "") == 0)
		dwTempSize += 4;

	pszTemp = (char*) LocalAlloc(LPTR, dwTempSize);
	if (pszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszTemp, szFilepath);
	if (strcmp(szExtension, "") == 0)
		strcat(pszTemp, ".ini");

	ZeroMemory(&clrfc, sizeof (CMDLINEREADFILECONTEXT));
	//clrfc.fInCommandLineSection = FALSE;
	clrfc.pItemList = pItemList;

	hr = FileReadTextFile(pszTemp, FILERTFO_ALLOPTIONS, CmdlineReadFileCB, &clrfc);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't read text file \"%s\"!", 1, pszTemp);
		goto DONE;
	} // end if (couldn't read text file)


DONE:

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (we allocated the filepath)

	return (hr);
} // CCommandLine::ReadIniFileInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CCommandLine::DisplayHelpPageInternal()"
//==================================================================================
// CCommandLine::DisplayHelpPageInternal
//----------------------------------------------------------------------------------
//
// Description: Copies the path to this application into the string.
//
// Arguments:
//	DWORD* pdwStartItem		Pointer to first help item on this page, and place to
//							update start of next page if there are more pages to
//							display.
//	HWND hWnd				Window to use, if in Windows app.
//
// Returns: None.
//==================================================================================
HRESULT CCommandLine::DisplayHelpPageInternal(DWORD* pdwStartItem, HWND hWnd)
{
	HRESULT		hr = S_OK;
	DWORD		dwTemp;
#ifndef CMDLINE_CONSOLE_ONLY
	HDC			hdc = NULL;
	//HFONT		hFont = NULL;
	SIZE		size;
	LONG		lRightWidth;
	LONG		lCurrentHeight = 0;
	BOOL		fMorePages = FALSE;
	char*		pszRemainingLine = NULL;
	HWND		hSubWnd = NULL;
	char*		pcCurrent;
#endif // ! CMDLINE_CONSOLE_ONLY


	// If we're a windows app, get the device context
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	if (! this->m_fConsole)
	{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_CONSOLE_ONLY
		// Remove all the current text items, if any
		while (GetDlgItem(hWnd, IDS_ALL) != NULL)
			DestroyWindow(GetDlgItem(hWnd, IDS_ALL));


		hdc = GetDC(hWnd);
		if (hdc == NULL)
		{
			hr = GetLastError();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get window's device context!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't get device context)
#endif // ! CMDLINE_CONSOLE_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	} // end if (a Windows app)
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)

	for(dwTemp = (*pdwStartItem); dwTemp < this->m_dwNumHelpItems; dwTemp++)
	{
		if (this->m_papHelpItems[dwTemp] == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Help item %u is non-existent!", 1, dwTemp);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			hr = E_FAIL;
			goto DONE;
		} // end if (there isn't an item there)

#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		if (this->m_fConsole)
		{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_WINDOWS_ONLY
			printf(this->m_papHelpItems[dwTemp]->GetString());

			// Print the description if there is one
			if (this->m_papHelpItems[dwTemp]->m_pszDescription != NULL)
			{
				DWORD	dwSpaces;


				// Pad the left field with enough spaces
				dwSpaces = this->m_lLargestLeftHelpTextWidth - strlen(this->m_papHelpItems[dwTemp]->GetString()) + 1;
				while (dwSpaces > 0)
				{
					printf(" ");
					dwSpaces--;
				} // end while (need more spacing)

				printf(this->m_papHelpItems[dwTemp]->m_pszDescription);
			} // end if (there's a description)

			printf("\n");

			//BUGBUG pause if exceed a page height?

#endif // ! CMDLINE_WINDOWS_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		} // end if (console app)
		else
		{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_CONSOLE_ONLY
			// Find out where end of param name will be.
			pcCurrent = this->m_pszTempParamNameBuffer
						+ strlen(this->m_papHelpItems[dwTemp]->GetString());

			// Copy the param name (without the NULL termination).
			memcpy(this->m_pszTempParamNameBuffer,
					this->m_papHelpItems[dwTemp]->GetString(),
					((DWORD_PTR) pcCurrent - (DWORD_PTR) this->m_pszTempParamNameBuffer));

			// Make sure remaining buffer is filled with periods.
			while ((*pcCurrent) != '\0')
			{
				(*pcCurrent) = '.';
				pcCurrent++;
			} // end while (still more buffer)

			
			// Create the param name static text window
#ifdef LOCAL_TNCOMMON
			hSubWnd = CreateWindow("STATIC",
									this->m_pszTempParamNameBuffer,
									WS_CHILD | WS_VISIBLE | SS_SIMPLE,
									0,
									lCurrentHeight,
									this->m_lLargestLeftHelpTextWidth,
									this->m_lLargestHelpLineHeight,
									hWnd,
									(HMENU) IDS_ALL,
									NULL,
									0);
#else // ! LOCAL_TNCOMMON
			hSubWnd = CreateWindow("STATIC",
									this->m_pszTempParamNameBuffer,
									WS_CHILD | WS_VISIBLE | SS_SIMPLE,
									0,
									lCurrentHeight,
									this->m_lLargestLeftHelpTextWidth,
									this->m_lLargestHelpLineHeight,
									hWnd,
									(HMENU) IDS_ALL,
									s_hInstance,
									0);
#endif // ! LOCAL_TNCOMMON
			if (hSubWnd == NULL)
			{
				hr = GetLastError();

				if (hr == S_OK)
					hr = E_FAIL;

				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't create text \"%s\"!",
					1, this->m_pszTempParamNameBuffer);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't create window)

			// Change the font to a fixed font.
			SetWindowFont(hSubWnd, GetStockObject(ANSI_FIXED_FONT), TRUE);


			// Word wrap the description if there is one
			if ((this->m_papHelpItems[dwTemp]->m_pszDescription != NULL) &&
				(strlen(this->m_papHelpItems[dwTemp]->m_pszDescription) > 0))
			{
				char*	lpcCurrent;


				pszRemainingLine = (char*) LocalAlloc(LPTR, strlen(this->m_papHelpItems[dwTemp]->m_pszDescription) + 1);
				if (pszRemainingLine == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				strcpy(pszRemainingLine, this->m_papHelpItems[dwTemp]->m_pszDescription);

				lpcCurrent = pszRemainingLine;
				lRightWidth = 0;

				while ((*lpcCurrent) != '\0')
				{
					// Prepare to calculate using a more pleasing font.
					SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));

					if (! GetTextExtentPoint32(hdc, lpcCurrent, 1, &size))
					{
						hr = GetLastError();
						if (hr == S_OK)
							hr = E_FAIL;

						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't get text extents for '%c'!", 1, lpcCurrent);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW

						goto DONE;
					} // end if (couldn't get text size)

					lRightWidth += size.cx;

					// If we went over the limit for text width, find the
					// most recent word break and wrap there
					if (lRightWidth > this->m_lLargestRightHelpTextWidth)
					{
						while (((*lpcCurrent) != ' ') && (lpcCurrent > pszRemainingLine))
							lpcCurrent--;

						// If we didn't find a word break earlier in the
						// line, we're just going to have to clip it, and
						// start with the next word.
						if (lpcCurrent == pszRemainingLine)
						{
							while (((*lpcCurrent) != ' ') && ((*lpcCurrent) != '\0'))
								lpcCurrent++;

							// Stop if we hit the end of the string
							if ((*lpcCurrent) != '\0')
								break;
						} // end if (we didn't find a word break)

						// Display the line up to this break
						(*lpcCurrent) = '\0';

#ifdef LOCAL_TNCOMMON
						hSubWnd = CreateWindow("STATIC",
												pszRemainingLine,
												WS_CHILD | WS_VISIBLE | SS_SIMPLE,
												this->m_lLargestLeftHelpTextWidth + 5,
												lCurrentHeight,
												this->m_lLargestRightHelpTextWidth,
												this->m_lLargestHelpLineHeight,
												hWnd,
												(HMENU) IDS_ALL,
												NULL,
												0);
#else // ! LOCAL_TNCOMMON
						hSubWnd = CreateWindow("STATIC",
												pszRemainingLine,
												WS_CHILD | WS_VISIBLE | SS_SIMPLE,
												this->m_lLargestLeftHelpTextWidth + 5,
												lCurrentHeight,
												this->m_lLargestRightHelpTextWidth,
												this->m_lLargestHelpLineHeight,
												hWnd,
												(HMENU) IDS_ALL,
												s_hInstance,
												0);
#endif // ! LOCAL_TNCOMMON
						if (hSubWnd == NULL)
						{
							hr = GetLastError();

							if (hr == S_OK)
								hr = E_FAIL;

							#ifndef NO_TNCOMMON_DEBUG_SPEW
							DPL(0, "Couldn't create text \"%s\"!", 1, pszRemainingLine);
							#endif // ! NO_TNCOMMON_DEBUG_SPEW
							goto DONE;
						} // end if (couldn't create window)

						// Change the font to a more pleasing font.
						SetWindowFont(hSubWnd, GetStockObject(ANSI_VAR_FONT), TRUE);

						// Slide all the remaining text down to the beginning
						// of the string, and dump any extra spaces.
						memcpy(pszRemainingLine, lpcCurrent + 1, strlen(lpcCurrent + 1) + 1);
						StringPopLeadingChars(pszRemainingLine, " ", TRUE);

						lpcCurrent = pszRemainingLine;

						lCurrentHeight += this->m_lLargestHelpLineHeight;

						// Reset the line width counter
						lRightWidth = 0;
					} // end if (this puts us over the limit)
					else
					{
						// Move to next character
						lpcCurrent++;
					} // end else (we're still in the limit)
				} // end while (not at the end of the string)

				// If there's any string left, dump it.
				if (strlen(pszRemainingLine) > 0)
				{
#ifdef LOCAL_TNCOMMON
					hSubWnd = CreateWindow("STATIC",
											pszRemainingLine,
											WS_CHILD | WS_VISIBLE | SS_SIMPLE,
											this->m_lLargestLeftHelpTextWidth + 5,
											lCurrentHeight,
											this->m_lLargestRightHelpTextWidth,
											this->m_lLargestHelpLineHeight,
											hWnd,
											(HMENU) IDS_ALL,
											NULL,
											0);
#else // ! LOCAL_TNCOMMON
					hSubWnd = CreateWindow("STATIC",
											pszRemainingLine,
											WS_CHILD | WS_VISIBLE | SS_SIMPLE,
											this->m_lLargestLeftHelpTextWidth + 5,
											lCurrentHeight,
											this->m_lLargestRightHelpTextWidth,
											this->m_lLargestHelpLineHeight,
											hWnd,
											(HMENU) IDS_ALL,
											s_hInstance,
											0);
#endif // ! LOCAL_TNCOMMON
					if (hSubWnd == NULL)
					{
						hr = GetLastError();

						if (hr == S_OK)
							hr = E_FAIL;

						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't create text \"%s\"!", 1, pszRemainingLine);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't create window)

					// Change the font to a more pleasing font.
					SetWindowFont(hSubWnd, GetStockObject(ANSI_VAR_FONT), TRUE);
				} // end if (there's more to dump)
				else
				{
					// BUGBUG Subtract it?
					//lCurrentHeight -= this->m_lLargestHelpLineHeight + 7;
				} // end else (there's nothing to dump)

				LocalFree(pszRemainingLine);
				pszRemainingLine = NULL;
			} // end if (there's a description)

			// Include space for each item + a little buffer
			lCurrentHeight += this->m_lLargestHelpLineHeight + 7;

			// Note this only ends the page on an item, so if you have
			// a really long description the window could go beyond
			// this limit.
			if ((lCurrentHeight >= this->m_lMaxHelpHeight) &&
				(dwTemp < this->m_dwNumHelpItems - 1))
			{
				fMorePages = TRUE;
				(*pdwStartItem) = dwTemp + 1;
				break;
			} // end if (we're going past the height)
#endif // ! CMDLINE_CONSOLE_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		} // end else (in Windows mode)
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
	} // end for (each item)


	// If we're a Windows app, resize the window, show buttons, cleanup, etc.
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	if (! this->m_fConsole)
	{
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
#ifndef CMDLINE_CONSOLE_ONLY
		if (hdc != NULL)
		{
			ReleaseDC(hWnd, hdc); // ignore error;
			hdc = NULL;
		} // end if (got device context)

		// Space out the text from the button
		lCurrentHeight += 10;

		if (fMorePages)
		{
			// Center the OK button on the left
			if (! MoveWindow(GetDlgItem(hWnd, IDOK),
							(((this->m_lLargestLeftHelpTextWidth + this->m_lLargestRightHelpTextWidth + 20) / 2) - 110),
							lCurrentHeight,
							100,
							25,
							TRUE))
			{
				hr = GetLastError();
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't move OK button!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't move OK button)

			// Center the Next button on the right
			if (! MoveWindow(GetDlgItem(hWnd, IDB_NEXT),
							(((this->m_lLargestLeftHelpTextWidth + this->m_lLargestRightHelpTextWidth + 20) / 2) + 10),
							lCurrentHeight,
							100,
							25,
							TRUE))
			{
				hr = GetLastError();
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't move Next button!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't move Next button)

			// Show the Next button
			ShowWindow(GetDlgItem(hWnd, IDB_NEXT), SW_SHOW);

			// Hide the Back button
			ShowWindow(GetDlgItem(hWnd, IDB_BACKTOFIRST), SW_HIDE);
		} // end if (there are more pages)
		else if (this->m_dwHelpStartItem > 0)
		{
			// Center the OK button on the left
			if (! MoveWindow(GetDlgItem(hWnd, IDOK),
							(((this->m_lLargestLeftHelpTextWidth + this->m_lLargestRightHelpTextWidth + 20) / 2) - 110),
							lCurrentHeight,
							100,
							25,
							TRUE))
			{
				hr = GetLastError();
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't move OK button!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't move OK button)

			// Hide the Next button
			ShowWindow(GetDlgItem(hWnd, IDB_NEXT), SW_HIDE);

			// Center the Back button on the right
			if (! MoveWindow(GetDlgItem(hWnd, IDB_BACKTOFIRST),
							(((this->m_lLargestLeftHelpTextWidth + this->m_lLargestRightHelpTextWidth + 20) / 2) + 10),
							lCurrentHeight,
							100,
							25,
							TRUE))
			{
				hr = GetLastError();
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't move Back button!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't move Back button)

			// Show the Back button
			ShowWindow(GetDlgItem(hWnd, IDB_BACKTOFIRST), SW_SHOW);
		} // end else if (there is a first page)
		else
		{
			// Center the OK button
			if (! MoveWindow(GetDlgItem(hWnd, IDOK),
							(((this->m_lLargestLeftHelpTextWidth + this->m_lLargestRightHelpTextWidth + 20) / 2) - 50),
							lCurrentHeight,
							100,
							25,
							TRUE))
			{
				hr = GetLastError();
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't move OK button!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't move OK button)

			// Get rid of the Next and Back buttons
			DestroyWindow(GetDlgItem(hWnd, IDB_NEXT));
			DestroyWindow(GetDlgItem(hWnd, IDB_BACKTOFIRST));
		} // end else (there's only one page)

		// Button height + some extra (don't know why)
		lCurrentHeight += 25 + 30;


		// Resize the main window
		if (! MoveWindow(hWnd,
						0,
						0,
						(this->m_lLargestLeftHelpTextWidth + this->m_lLargestRightHelpTextWidth + 20),
						lCurrentHeight,
						TRUE))
		{
			hr = GetLastError();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't resize window!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't resize window)
#endif // ! CMDLINE_CONSOLE_ONLY
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
	} // end if (a Windows app)
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)


DONE:

#ifndef CMDLINE_CONSOLE_ONLY
	if (pszRemainingLine != NULL)
	{
		LocalFree(pszRemainingLine);
		pszRemainingLine = NULL;
	} // end if (allocated a remaining line string)

	if (hdc != NULL)
	{
		ReleaseDC(hWnd, hdc); // ignore error;
		hdc = NULL;
	} // end if (got device context)
#endif // ! CMDLINE_CONSOLE_ONLY

	return (hr);
} // CCommandLine::DisplayHelpPageInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParam::CHandledParam()"
//==================================================================================
// CHandledParam constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParam object.  Initializes the string and
//				options and value pointer to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwType			Type of this item (child class ID)
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParam::CHandledParam(char* szName, char* pszDescription, DWORD dwType,
							DWORD dwOptions, PVOID* ppvValuePtr):
	CLString(szName),
	m_pszDescription(NULL),
	m_dwType(dwType),
	m_dwOptions(dwOptions),
	m_fFound(FALSE),
	m_ppvValuePtr(ppvValuePtr)
{
	if (pszDescription != NULL)
	{
		this->m_pszDescription = (char*) LocalAlloc(LPTR, (strlen(pszDescription) + 1));
		if (this->m_pszDescription != NULL)
			strcpy(this->m_pszDescription, pszDescription);
	} // end if (there's a description)
} // CHandledParam::CHandledParam
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParam::~CHandledParam()"
//==================================================================================
// CHandledParam destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CHandledParam object and any resources it may have
//				allocated.
//
// Arguments: None.
//
// Returns: None
//==================================================================================
CHandledParam::~CHandledParam(void)
{
	if (this->m_pszDescription != NULL)
	{
		LocalFree(this->m_pszDescription);
		this->m_pszDescription = NULL;
	} // end if (we allocated a description)
} // CHandledParam::CHandledParam 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamBool::CHandledParamBool()"
//==================================================================================
// CHandledParamBool constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamBool object.  Initializes the name and
//				value to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParamBool::CHandledParamBool(char* szName, char* pszDescription,
									DWORD dwOptions, PVOID* ppvValuePtr):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_BOOL, dwOptions,
				ppvValuePtr),
	m_fValue(FALSE)
{
	if (ppvValuePtr != NULL)
	{
		//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		this->m_fValue = (DWORD_PTR) (*((UNALIGNED PVOID*) ppvValuePtr));
	} // end if (there's a value pointer)
} // CHandledParamBool::CHandledParamBool 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamBool::GetSelfAndValues()"
//==================================================================================
// CHandledParamBool::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive				Whether the searches should be case sensitive.
//	PSPECIFIEDPARAMSLIST pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamBool::GetSelfAndValues(BOOL fCaseSensitive,
											PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	PSPECIFIEDPARAM		pNextString = NULL;
	BOOL				fMatch;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;


		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());

		// If we didn't match the name, just move on
		if (! fMatch)
			continue;

		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);

		if ((pNextString == NULL) || (! pNextString->m_fSeparated))
		{
			// If the value wasn't specified, the new value is just opposite of
			// the current value.
			this->m_fValue = (! this->m_fValue);
		} // end if (value wasn't specified
		else
		{
			// If the next item was already used it can't be a value for us, and we
			// can't use this switch.
			if (pNextString->GetString() == NULL)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				continue;
			} // end if (the item was already used)

			// Set the value to the one specified.
			this->m_fValue = StringIsTrue(pNextString->GetString());
		} // end else (the value was specified)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
		{
			//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
			*((UNALIGNED DWORD_PTR*) this->m_ppvValuePtr) = this->m_fValue;
		} // end if (there's a value pointer)


		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Stop searching.
		break;
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamBool::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamBool::PrintToFile()"
//==================================================================================
// CHandledParamBool::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamBool::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr;


	hr = FileSprintfWriteLine(hFile, "%s%s=%B",
							3, ((this->m_fFound) ? "": "//"),
							this->GetString(),
							this->m_fValue);

	return (hr);
} // CHandledParamBool::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamInt::CHandledParamInt()"
//==================================================================================
// CHandledParamInt constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamInt object.  Initializes the name and value
//				to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParamInt::CHandledParamInt(char* szName, char* pszDescription,
									DWORD dwOptions, PVOID* ppvValuePtr):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_INT, dwOptions,
					ppvValuePtr),
	m_iValue(0)
{
	if (ppvValuePtr != NULL)
	{
		//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		this->m_iValue = (INT_PTR) (*((UNALIGNED PVOID*) ppvValuePtr));
	} // end if (there's a value pointer)
} // CHandledParamInt::CHandledParamInt
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamInt::GetSelfAndValues()"
//==================================================================================
// CHandledParamInt::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive			Whether the searches should be case sensitive.
//	PSPECIFIEDPARAM pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamInt::GetSelfAndValues(BOOL fCaseSensitive,
											PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	BOOL				fMatch;
	PSPECIFIEDPARAM		pNextString;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;


		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());


		// If we didn't match the name, just move on
		if (! fMatch)
			continue;


		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pNextString == NULL)
			break;


		// If the next item was already used it can't be a value for us, and we
		// can't use this switch.
		if (pNextString->GetString() == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			if (pNextString->m_fSeparated)
			{
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
			} // end if (was marked as separated)
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			continue;
		} // end if (the item was already used)


		// We want to handle values separated by only a space, but that can lead
		// to issues.  Alert the user, in case he's trying to figure out why his
		// app is crashing because of wacky input.
		if (! pNextString->m_fSeparated)
		{
			DPL(0, "NOTE: Using next item after \"%s\" that was separated by a space (\"%s\").",
				2, pString->GetString(), pNextString->GetString());
		} // end if (didn't separate)



		// Otherwise, assume it's a valid integer.
		this->m_iValue = StringToInt(pNextString->GetString());

		// Mark this value command line item as used.
		hr = pNextString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear value string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
			*((INT_PTR*) this->m_ppvValuePtr) = this->m_iValue;


		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Stop searching.
		break;
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamInt::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamInt::PrintToFile()"
//==================================================================================
// CHandledParamInt::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamInt::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr;


	hr = FileSprintfWriteLine(hFile, "%s%s=%i",
							3, ((this->m_fFound) ? "": "//"),
							this->GetString(),
							this->m_iValue);

	return (hr);
} // CHandledParamInt::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamDWord::CHandledParamDWord()"
//==================================================================================
// CHandledParamDWord constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamDWord object.  Initializes the name and
//				value to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParamDWord::CHandledParamDWord(char* szName, char* pszDescription,
										DWORD dwOptions, PVOID* ppvValuePtr):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_DWORD, dwOptions,
				ppvValuePtr),
	m_dwValue(0)
{
	if (ppvValuePtr != NULL)
	{
		//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		this->m_dwValue = (DWORD_PTR) (*((UNALIGNED PVOID*) ppvValuePtr));
	} // end if (there's a value pointer)
} // CHandledParamDWord::CHandledParamDWord
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamDWord::GetSelfAndValues()"
//==================================================================================
// CHandledParamDWord::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive				Whether the searches should be case sensitive.
//	PSPECIFIEDPARAMSLIST pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamDWord::GetSelfAndValues(BOOL fCaseSensitive,
											PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	BOOL				fMatch;
	PSPECIFIEDPARAM		pNextString;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;



		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());

		// If we didn't match the name, just move on
		if (! fMatch)
			continue;


		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pNextString == NULL)
			break;


		// If the next item was already used it can't be a value for us, and we
		// can't use this switch.
		if (pNextString->GetString() == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			if (pNextString->m_fSeparated)
			{
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
			} // end if (was marked as separated)
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			continue;
		} // end if (the item was already used)


		// We want to handle values separated by only a space, but that can lead
		// to issues.  Alert the user, in case he's trying to figure out why his
		// app is crashing because of wacky input.
		if (! pNextString->m_fSeparated)
		{
			DPL(0, "NOTE: Using next item after \"%s\" that was separated by a space (\"%s\").",
				2, pString->GetString(), pNextString->GetString());
		} // end if (didn't separate)


		// Otherwise, assume it's a valid DWORD.
		this->m_dwValue = StringToDWord(pNextString->GetString());

		// Mark this value command line item as used.
		hr = pNextString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear value string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
			*((DWORD_PTR*) this->m_ppvValuePtr) = this->m_dwValue;


		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Stop searching.
		break;
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamDWord::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamDWord::PrintToFile()"
//==================================================================================
// CHandledParamDWord::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamDWord::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr;


	hr = FileSprintfWriteLine(hFile, "%s%s=%u",
							3, ((this->m_fFound) ? "": "//"),
							this->GetString(),
							this->m_dwValue);

	return (hr);
} // CHandledParamDWord::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamDWordHex::CHandledParamDWordHex()"
//==================================================================================
// CHandledParamDWordHex constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamDWordHex object.  Initializes the name and
//				value to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParamDWordHex::CHandledParamDWordHex(char* szName, char* pszDescription,
										DWORD dwOptions, PVOID* ppvValuePtr):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_DWORD, dwOptions,
				ppvValuePtr),
	m_dwValue(0)
{
	if (ppvValuePtr != NULL)
	{
		//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		this->m_dwValue = (DWORD_PTR) (*((UNALIGNED PVOID*) ppvValuePtr));
	} // end if (there's a value pointer)
} // CHandledParamDWordHex::CHandledParamDWordHex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamDWordHex::GetSelfAndValues()"
//==================================================================================
// CHandledParamDWordHex::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive				Whether the searches should be case sensitive.
//	PSPECIFIEDPARAMSLIST pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamDWordHex::GetSelfAndValues(BOOL fCaseSensitive,
												PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	BOOL				fMatch;
	PSPECIFIEDPARAM		pNextString;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;



		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());

		// If we didn't match the name, just move on
		if (! fMatch)
			continue;


		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pNextString == NULL)
			break;


		// If the next item was already used it can't be a value for us, and we
		// can't use this switch.
		if (pNextString->GetString() == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			if (pNextString->m_fSeparated)
			{
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
			} // end if (was marked as separated)
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			continue;
		} // end if (the item was already used)


		// We want to handle values separated by only a space, but that can lead
		// to issues.  Alert the user, in case he's trying to figure out why his
		// app is crashing because of wacky input.
		if (! pNextString->m_fSeparated)
		{
			DPL(0, "NOTE: Using next item after \"%s\" that was separated by a space (\"%s\").",
				2, pString->GetString(), pNextString->GetString());
		} // end if (didn't separate)


		// Otherwise, assume it's a valid hex DWORD.
		this->m_dwValue = StringHexToDWord(pNextString->GetString());

		// Mark this value command line item as used.
		hr = pNextString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear value string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
			*((DWORD_PTR*) this->m_ppvValuePtr) = this->m_dwValue;


		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Stop searching.
		break;
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamDWordHex::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // No file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamDWordHex::PrintToFile()"
//==================================================================================
// CHandledParamDWordHex::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamDWordHex::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr;


	hr = FileSprintfWriteLine(hFile, "%s%s=%x",
							3, ((this->m_fFound) ? "": "//"),
							this->GetString(),
							this->m_dwValue);

	return (hr);
} // CHandledParamDWordHex::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamString::CHandledParamString()"
//==================================================================================
// CHandledParamString constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamString object.  Initializes the name and
//				value to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParamString::CHandledParamString(char* szName, char* pszDescription,
										DWORD dwOptions, PVOID* ppvValuePtr):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_STRING, dwOptions,
					ppvValuePtr),
	m_pszValue(NULL)
{
	//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	if ((ppvValuePtr != NULL) && ((*((UNALIGNED PVOID*) ppvValuePtr)) != NULL))
	{
		this->m_pszValue = (char*) LocalAlloc(LPTR, (strlen((char*) (*((UNALIGNED PVOID*) ppvValuePtr))) + 1));
		if (this->m_pszValue != NULL)
		{
			strcpy(this->m_pszValue, ((char*) (*((UNALIGNED PVOID*) ppvValuePtr))));
		} // end if (allocated memory)
	} // end if (there's a default value)
} // CHandledParamString::CHandledParamString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamString::~CHandledParamString()"
//==================================================================================
// CHandledParamString destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CHandledParamString object and any resources it may have
//				allocated.
//
// Arguments: None.
//
// Returns: None
//==================================================================================
CHandledParamString::~CHandledParamString(void)
{
	if (this->m_pszValue != NULL)
	{
		LocalFree(this->m_pszValue);
		this->m_pszValue = NULL;
	} // end if (we allocated a description)
} // CHandledParamString::CHandledParamString 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamString::GetSelfAndValues()"
//==================================================================================
// CHandledParamString::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive				Whether the searches should be case sensitive.
//	PSPECIFIEDPARAMSLIST pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamString::GetSelfAndValues(BOOL fCaseSensitive,
											PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	BOOL				fMatch;
	PSPECIFIEDPARAM		pNextString;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;


		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());


		// If we didn't match the name, just move on
		if (! fMatch)
			continue;


		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pNextString == NULL)
			break;


		// If the next item was already used it can't be a value for us, and we
		// can't use this switch.
		if (pNextString->GetString() == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			if (pNextString->m_fSeparated)
			{
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
			} // end if (was marked as separated)
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			continue;
		} // end if (the item was already used)


		// We want to handle values separated by only a space, but that can lead
		// to issues.  Alert the user, in case he's trying to figure out why his
		// app is crashing because of wacky input.
		if (! pNextString->m_fSeparated)
		{
			DPL(0, "NOTE: Using next item after \"%s\" that was separated by a space (\"%s\").",
				2, pString->GetString(), pNextString->GetString());
		} // end if (didn't separate)



		// If we previously had a value, get rid of it
		if (this->m_pszValue != NULL)
		{
			LocalFree(this->m_pszValue);
			this->m_pszValue = NULL;
		} // end if (we had a value previously)

		this->m_pszValue = (char*) LocalAlloc(LPTR, (strlen(pNextString->GetString()) + 1));
		if (this->m_pszValue == NULL)
			return (E_OUTOFMEMORY);

		strcpy(this->m_pszValue, pNextString->GetString());


		// Mark this value command line item as used.
		hr = pNextString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear value string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
			*((char**) this->m_ppvValuePtr) = this->m_pszValue;


		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Stop searching.
		break;
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamString::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamString::PrintToFile()"
//==================================================================================
// CHandledParamString::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamString::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr;


	if (this->m_pszValue)
	{
		hr = FileSprintfWriteLine(hFile, "%s%s=%s",
								3, ((this->m_fFound) ? "": "//"),
								this->GetString(),
								this->m_pszValue);
	} // end if (there's an item)
	else
	{
		hr = FileSprintfWriteLine(hFile, "%s%s=",
								2, ((this->m_fFound) ? "": "//"),
								this->GetString());
	} // end else (there isn't an item)


	return (hr);
} // CHandledParamString::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX


#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamID::CHandledParamID()"
//==================================================================================
// CHandledParamID constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamID object.  Initializes the name and value
//				to the ones passed in.
//
// Arguments:
//	char* szName					Name of this item.
//	char* pszDescription			Pointer to optional description of this item
//	DWORD dwOptions					Options for this item.
//	PVOID* ppvValuePtr				Pointer to default value and place to update
//									with value.
//	PCMDLINEIDITEM paLookupTable	Array of items to use when looking up a value.
//	DWORD dwNumTableEntries			Number of entries in the above array.
//
// Returns: None (the object).
//==================================================================================
CHandledParamID::CHandledParamID(char* szName, char* pszDescription, DWORD dwOptions,
								PVOID* ppvValuePtr, PCMDLINEIDITEM paLookupTable,
								DWORD dwNumTableEntries):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_ID, dwOptions,
					ppvValuePtr),
	m_paLookupTable(paLookupTable),
	m_dwNumTableEntries(dwNumTableEntries),
	m_dwValue(0)
{
	if (ppvValuePtr != NULL)
	{
		//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		this->m_dwValue = (DWORD_PTR) (*((UNALIGNED PVOID*) ppvValuePtr));
	} // end if (there's a value pointer)
} // CHandledParamID::CHandledParamID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamID::GetSelfAndValues()"
//==================================================================================
// CHandledParamID::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive				Whether the searches should be case sensitive.
//	PSPECIFIEDPARAMSLIST pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamID::GetSelfAndValues(BOOL fCaseSensitive,
										PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	BOOL				fMatch;
	DWORD				dwTemp;
	PSPECIFIEDPARAM		pNextString;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;


		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());

		// If we didn't match the name, just move on
		if (! fMatch)
			continue;


		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pNextString == NULL)
			break;


		// If the next item was already used it can't be a value for us, and we
		// can't use this switch.
		if (pNextString->GetString() == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			if (pNextString->m_fSeparated)
			{
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
			} // end if (was marked as separated)
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			continue;
		} // end if (the item was already used)


		// We want to handle values separated by only a space, but that can lead
		// to issues.  Alert the user, in case he's trying to figure out why his
		// app is crashing because of wacky input.
		if (! pNextString->m_fSeparated)
		{
			DPL(0, "NOTE: Using next item after \"%s\" that was separated by a space (\"%s\").",
				2, pString->GetString(), pNextString->GetString());
		} // end if (didn't separate)


		// If we don't find a match, we will return an error, unless the
		// user said we shouldn't, in which case it will just stay the
		// default value.
		fMatch = FALSE;
		for(dwTemp = 0; dwTemp < this->m_dwNumTableEntries; dwTemp++)
		{
			if (fCaseSensitive)
				fMatch = (strcmp(this->m_paLookupTable[dwTemp].pszName, pNextString->GetString()) == 0) ? TRUE : FALSE;
			else
				fMatch = StringCmpNoCase(this->m_paLookupTable[dwTemp].pszName, pNextString->GetString());

			if (fMatch)
			{
				this->m_dwValue = this->m_paLookupTable[dwTemp].dwValue;
				break;
			} // end if (this item matches)
		} // end for (each item in the ID table)

		if ((! fMatch) &&
			(! (this->m_dwOptions & CMDLINE_PARAMOPTION_DONTFAILIFUNKNOWNID)))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "\"%s\" is not a recognized value for the switch \"%s\"!",
				2, pNextString->GetString(), this->GetString());
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (CMDLINERR_INVALIDPARAMETERVALUE);
		} // end if (item wasn't valid and we can fail)


		// Mark this value command line item as used.
		hr = pNextString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear value string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
			*((DWORD_PTR*) this->m_ppvValuePtr) = this->m_dwValue;



		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Stop searching.
		break;
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamID::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamID::PrintToFile()"
//==================================================================================
// CHandledParamID::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamID::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr;
	char*		pszName = NULL;
	DWORD		dwTemp;


	// If we can print extended information, we'll print all the accepted values.
	if (fVerbose)
	{
		FileWriteLine(hFile, "// Accepted values:");
	} // end if (can print descriptions)


	// Look for the current value, and if printing more information, print each
	// value.
	for(dwTemp = 0; dwTemp < this->m_dwNumTableEntries; dwTemp++)
	{
		if ((pszName == NULL) &&
			(this->m_paLookupTable[dwTemp].dwValue == this->m_dwValue))
		{
			pszName = this->m_paLookupTable[dwTemp].pszName;

			// If not printing verbosely, stop.
			if (! fVerbose)
				break;
		} // end if (this item matches)

		if (fVerbose)
		{
			hr = FileSprintfWriteLine(hFile, "//     \"%s\" (%u)",
									2, this->m_paLookupTable[dwTemp].pszName,
									this->m_paLookupTable[dwTemp].dwValue);
		} // end if (can print descriptions)
	} // end for (each item in the ID table)


	/*
	FileWriteString(hFile, "//");
	// - 2 for "//" and -1 for the second character each iteration
	for(dwTemp = 0; dwTemp < WRAP_DESCRIPTION_CHARACTERS - 3; dwTemp += 2)
		FileWriteString(hFile, " -");
	FileWriteLine(hFile, "");
	*/


	// If we found a name for our value, print it.  Otherwise print the actual
	// value but commented out.
	if (pszName != NULL)
	{
		hr = FileSprintfWriteLine(hFile, "%s%s=%s",
								3, ((this->m_fFound) ? "": "//"),
								this->GetString(),
								pszName);
	} // end if (found a match)
	else
	{
		hr = FileSprintfWriteLine(hFile, "//%s=%u? %s",
									3, this->GetString(),
									this->m_dwValue,
									((this->m_fFound) ? "": "(was not specified)"));
	} // end else (didn't find a matching ID)

	return (hr);
} // CHandledParamID::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX


#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamMultiString::CHandledParamMultiString()"
//==================================================================================
// CHandledParamMultiString constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CHandledParamMultiString object.  Initializes the name
//				and value to the ones passed in.
//
// Arguments:
//	char* szName			Name of this item.
//	char* pszDescription	Pointer to optional description of this item
//	DWORD dwOptions			Options for this item.
//	PVOID* ppvValuePtr		Pointer to default value and place to update with value.
//
// Returns: None (the object).
//==================================================================================
CHandledParamMultiString::CHandledParamMultiString(char* szName, char* pszDescription,
													DWORD dwOptions,
													PVOID* ppvValuePtr):
	CHandledParam(szName, pszDescription, CMDLINE_PARAMTYPE_MULTISTRING, dwOptions,
					ppvValuePtr),
	m_pValues(NULL),
	m_fCreatedValuesList(FALSE)
{
	// If there was an existing item.
	//  6/29/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
	if ((ppvValuePtr != NULL) && ((*((UNALIGNED PVOID*) ppvValuePtr)) != NULL))
	{
		this->m_pValues = (PLSTRINGLIST) (*((UNALIGNED PVOID*) ppvValuePtr));
	} // end if (there's a default value)
	else
	{
		this->m_pValues = new (CLStringList);
		this->m_fCreatedValuesList = TRUE;
	} // end if (there's a default value)
} // CHandledParamMultiString::CHandledParamMultiString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamMultiString::~CHandledParamMultiString()"
//==================================================================================
// CHandledParamMultiString destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CHandledParamMultiString object and any resources it
//				may have allocated.
//
// Arguments: None.
//
// Returns: None
//==================================================================================
CHandledParamMultiString::~CHandledParamMultiString(void)
{
	if ((this->m_pValues != NULL) && (this->m_fCreatedValuesList))
	{
		delete (this->m_pValues);
		this->m_pValues = NULL;
	} // end if (we allocated a description)
} // CHandledParamMultiString::CHandledParamMultiString 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamMultiString::GetSelfAndValues()"
//==================================================================================
// CHandledParamMultiString::GetSelfAndValues
//----------------------------------------------------------------------------------
//
// Description: Searches the list of items for this object and pertinent values.  If
//				found, this object's values are updated and the items used are
//				pulled from the passed in list.
//				CMDLINE_OK is still returned even if this object wasn't found in
//				the list.
//
// Arguments:
//	BOOL fCaseSensitive				Whether the searches should be case sensitive.
//	PSPECIFIEDPARAMSLIST pItemList	List of remaining command line items.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamMultiString::GetSelfAndValues(BOOL fCaseSensitive,
													PSPECIFIEDPARAMSLIST pItemList)
{
	HRESULT				hr;
	PSPECIFIEDPARAM		pString = NULL;
	BOOL				fMatch;
	PSPECIFIEDPARAM		pNextString;


	do
	{
		pString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pString == NULL)
			break;


		// If this item was already used, skip it.
		if (pString->GetString() == NULL)
			continue;

		// If this item isn't a switch, skip it.
		if (! pString->m_fSwitch)
			continue;


		// Check to see if we've matched the name
		if (fCaseSensitive)
			fMatch = (strcmp(pString->GetString(), this->GetString()) == 0) ? TRUE : FALSE;
		else
			fMatch = StringCmpNoCase(pString->GetString(), this->GetString());


		// If we didn't match the name, just move on
		if (! fMatch)
			continue;


		pNextString = (PSPECIFIEDPARAM) pItemList->GetNextItem(pString);
		if (pNextString == NULL)
			break;


		// If the next item was already used it can't be a value for us, and we
		// can't use this switch.
		if (pNextString->GetString() == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			if (pNextString->m_fSeparated)
			{
				DPL(0, "WARNING: Next item (%x) already used but it's marked separated!?",
					1, pNextString);
			} // end if (was marked as separated)
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			continue;
		} // end if (the item was already used)


		// We want to handle values separated by only a space, but that can lead
		// to issues.  Alert the user, in case he's trying to figure out why his
		// app is crashing because of wacky input.
		if (! pNextString->m_fSeparated)
		{
			DPL(0, "NOTE: Using next item after \"%s\" that was separated by a space (\"%s\").",
				2, pString->GetString(), pNextString->GetString());
		} // end if (didn't separate)


		hr = this->m_pValues->AddString(pNextString->GetString());
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't add value string \"%s\"!", 1, pNextString->GetString());
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't add string)


		// Mark this value command line item as used.
		hr = pNextString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear value string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Mark this as found and update the user's value pointer
		this->m_fFound = TRUE;
		if (this->m_ppvValuePtr != NULL)
			*((PLSTRINGLIST*) this->m_ppvValuePtr) = this->m_pValues;


		// Mark the command line item as used.
		hr = pString->SetString(NULL);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't clear string value!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (hr);
		} // end if (couldn't set string)


		// Note that we continue searching...
	} // end do (while haven't looked at all the remaining command line items)
	while (TRUE);

	return (CMDLINE_OK);
} // CHandledParamMultiString::GetSelfAndValues
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no file printing
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CHandledParamMultiString::PrintToFile()"
//==================================================================================
// CHandledParamMultiString::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the textual representation of this item to the specified open
//				file.
//
// Arguments:
//	HANDLE hFile	Handle of open file to write to.
//	BOOL fVerbose	Whether more description can be printed, if necessary.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CHandledParamMultiString::PrintToFile(HANDLE hFile, BOOL fVerbose)
{
	HRESULT		hr = CMDLINE_OK;
	BOOL		fPrinted = FALSE;
	int			i;
	PLSTRING	pString = NULL;



	if (this->m_pValues != NULL)
	{
		for(i = 0; i < this->m_pValues->Count(); i++)
		{
			pString = (PLSTRING) this->m_pValues->GetItem(i);
			if (pString == NULL)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't get string value %i!", 1, i);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				hr = E_FAIL;
				break;
			} // end if (couldn't get item)

			hr = FileSprintfWriteLine(hFile, "%s%s=%s",
									3, ((this->m_fFound) ? "": "//"),
									this->GetString(),
									pString->GetString());
			fPrinted = TRUE;
		} // end for (each value)
	} // end if (there are values)

	if (! fPrinted)
	{
		hr = FileSprintfWriteLine(hFile, "//%s has no value%s",
								2, this->GetString(),
								((this->m_fFound) ? "s but was specified": "s"));
	} // end if (haven't printed anything yet)

	return (hr);
} // CHandledParamMultiString::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
#pragma TODO(tristanj, "Print error when unhandled command line parameter encountered?")
#endif // XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CSpecifiedParam::CSpecifiedParam()"
//==================================================================================
// CSpecifiedParam constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CSpecifiedParam object.  Initializes the string and
//				boolean to the ones passed in.
//
// Arguments:
//	char* szName		Name of this item.
//	BOOL fSwitch		Is this item a switch?
//	BOOL fSeparated		Was this item separated from its switch name?
//
// Returns: None (the object).
//==================================================================================
CSpecifiedParam::CSpecifiedParam(char* szName, BOOL fSwitch, BOOL fSeparated):
	CLString(szName),
	m_fSwitch(fSwitch),
	m_fSeparated(fSeparated)
{
} // CSpecifiedParam::CSpecifiedParam
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CSpecifiedParamsList::AddItem()"
//==================================================================================
// CSpecifiedParamsList::AddItem
//----------------------------------------------------------------------------------
//
// Description: Adds an item to the list.  If it's a switch that can be split, the
//				switch and value are added separately.
//
// Arguments:
//	char* szString		String to add.
//	BOOL fSwitch		Whether this item is a switch.
//	BOOL fTryToSplit	If it's a switch, whether this item may contain a value as
//						well.
//	BOOL fWasSplit		If we shouldn't try to split the item, whether this item was
//						split already.
//
// Returns: CMDLINE_OK if successful, error code otherwise.
//==================================================================================
HRESULT CSpecifiedParamsList::AddItem(char* szString, BOOL fSwitch, BOOL fTryToSplit,
									BOOL fWasSplit)
{
	HRESULT				hr;
	unsigned int		ui;
	int					iPos = -1;
	PSPECIFIEDPARAM		pNewItem = NULL;
	char*				pszTemp = NULL;


	if (fSwitch && fTryToSplit)
	{
		// Loop through all the value tokens looking for the first instance of one
		// in the string.
		for(ui = 0; ui < strlen(CMDLINE_VALUE_TOKENS); ui++)
		{
			iPos = StringContainsChar(szString, CMDLINE_VALUE_TOKENS[ui], TRUE, 0);
			if (iPos >= 0)
				break;
		} // end for (each cmdline value token)
	} // end if (we should try to split the item)


	if (iPos >= 0)
	{
		// Grab the first part of the string (the switch)
		pszTemp = (char*) LocalAlloc(LPTR, iPos + 1);
		if (pszTemp == NULL)
			return (E_OUTOFMEMORY);

		CopyMemory(pszTemp, szString, iPos);


		// Make a new item

		pNewItem = new (CSpecifiedParam)(pszTemp, TRUE, FALSE);

		LocalFree(pszTemp);
		pszTemp = NULL;

		if (pNewItem == NULL)
		{
			return (E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		
		// Add the item to the list

		hr = this->Add(pNewItem);
		if (hr != S_OK)
		{
			delete (pNewItem);
			pNewItem = NULL;
			return (hr);
		} // end if (couldn't add object)


		// Grab the second part of the string (the value)
		pszTemp = (char*) LocalAlloc(LPTR, strlen(szString) - iPos);
		if (pszTemp == NULL)
			return (E_OUTOFMEMORY);

		CopyMemory(pszTemp, szString + iPos + 1, strlen(szString) - iPos - 1);


		// Make another new item

		pNewItem = new (CSpecifiedParam)(pszTemp, FALSE, TRUE);

		LocalFree(pszTemp);
		pszTemp = NULL;

		if (pNewItem == NULL)
		{
			return (E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		
		// Add that item to the list

		hr = this->Add(pNewItem);
		if (hr != S_OK)
		{
			delete (pNewItem);
			pNewItem = NULL;
			//return (hr);
		} // end if (couldn't add object)
	} // end if (we should and can split the item)
	else
	{
		pNewItem = new (CSpecifiedParam)(szString, fSwitch, fWasSplit);
		if (pNewItem == NULL)
		{
			return (E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		hr = this->Add(pNewItem);
		if (hr != S_OK)
		{
			delete (pNewItem);
			pNewItem = NULL;
			//return (hr);
		} // end if (couldn't add object)
	} // end else (we shouldn't or couldn't split the item)

	return (hr);
} // CSpecifiedParamsList::AddItem 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CmdlineReadFileCB()"
//==================================================================================
// CmdlineReadFileCB
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	char* szLine			Line that was read.
//	PFILELINEINFO pInfo		Information on line that was read.
//	PVOID pvContext			Pointer to context.  Cast as a CMDLINEREADFILECONTEXT
//							pointer.
//	BOOL* pfStopReading		Pointer to boolean to set to TRUE to discontinue reading
//							from the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CmdlineReadFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
						BOOL* pfStopReading)
{
	HRESULT						hr = S_OK;
	PCMDLINEREADFILECONTEXT		pContext = (PCMDLINEREADFILECONTEXT) pvContext;
	char*						pszKey = NULL;
	char*						pszValue;


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "Reading line %u:\"%s\".", 2, lpInfo->dwLineNumber, szLine);
	#endif // NO_TNCOMMON_DEBUG_SPEW
	*/

	switch (pInfo->dwType)
	{
		case FILERTFT_SECTION:
			if (StringCmpNoCase(szLine, "CommandLine"))
			{
				pContext->fInCommandLineSection = TRUE;
			} // end if (command line section)
			else
			{
				//pContext->fInCommandLineSection = FALSE;

				// If we were in the command line section, stop parsing
				if (pContext->fInCommandLineSection)
					(*pfStopReading) = TRUE;
			} // end else (not in command line section)
		  break;

		default:
			// If we're not in the command line section, just skip it.
			if (! pContext->fInCommandLineSection)
				break;

			pszKey = (char*) LocalAlloc(LPTR, strlen(szLine) + 1);
			if (pszKey == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			StringGetKey(szLine, pszKey);

			// If we didn't find a key (no '=' character in the line), just add
			// the line directly and we're done.  Otherwise, add the key and
			// value separately.
			if (strcmp(pszKey, "") == 0)
			{
				hr = pContext->pItemList->AddItem(szLine, TRUE, FALSE, FALSE);
				if (hr != S_OK)
				{
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Couldn't add string \"%s\" to list!", 1, szLine);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW
					goto DONE;
				} // end if (couldn't allocate memory)
			} // end if (we didn't find a key)
			else
			{
				// Specifying an ini file to read inside an ini file being read
				// doesn't make a whole lotta sense, so we'll skip it.
				if (StringCmpNoCase(pszKey, "ini"))
				{
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(1, "Ignoring \"ini\" being specified inside an ini file, line %u:%s",
						2, pInfo->dwLineNumber, szLine);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW
				} // end if (ini key)
				else
				{
					hr = pContext->pItemList->AddItem(pszKey, TRUE, FALSE, FALSE);
					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't add key \"%s\" to list!", 1, pszKey);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't allocate memory)

					pszValue = StringGetKeyValue(szLine);
					hr = pContext->pItemList->AddItem(pszValue, FALSE, FALSE, TRUE);
					if (hr != NULL)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't add value \"%s\" to list!", 1, pszValue);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't allocate memory)
				} // end else (not ini key)
			} // end else (there's a key)
		  break;
	} // end switch (on line type)


DONE:

	if (pszKey != NULL)
	{
		LocalFree(pszKey);
		pszKey = NULL;
	} // end if (allocated a key)

	return (hr);
} // CmdlineReadFileCB 
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no window logging
#ifndef CMDLINE_CONSOLE_ONLY

#undef DEBUG_SECTION
#define DEBUG_SECTION	"HelpBoxWndProc()"
//==================================================================================
// HelpBoxWndProc
//----------------------------------------------------------------------------------
//
// Description: Message pump that handles the command line help window.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK HelpBoxWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HRESULT			hr;
	PCOMMANDLINE	pThisObj;


	switch (uMsg)
	{
		/*
		case WM_INITDIALOG:
		  break;
		*/

		case WM_CLOSE:
			PostQuitMessage(0);
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "User pressed 'OK'.", 0);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW

					PostMessage(hWnd, WM_CLOSE, 0, 0);
					return (0);
				  break;

				case IDB_NEXT:
					// Retrieve the CCommandLine object pointer
					//  6/29/2000(RichGr) - IA64: Change GetWindowLong() to GetWindowLongPtr() as we are retrieving a pointer.
					pThisObj = (PCOMMANDLINE) GetWindowLongPtr(hWnd, 0);

					// Display the next page of help items.
					hr = pThisObj->DisplayHelpPageInternal(&(pThisObj->m_dwHelpStartItem),
															hWnd);
					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't display first help page!", 0);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
					} // end if (displaying first help page failed)
				  break;

				case IDB_BACKTOFIRST:
					// Retrieve the CCommandLine object pointer
					pThisObj = (PCOMMANDLINE) GetWindowLongPtr(hWnd, 0);

					// Display the first page of help items.
					pThisObj->m_dwHelpStartItem = 0;
					hr = pThisObj->DisplayHelpPageInternal(&(pThisObj->m_dwHelpStartItem),
															hWnd);
					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't display first help page!", 0);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
					} // end if (displaying first help page failed)
				  break;
			} // end switch (on the button pressed/control changed)
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! CMDLINE_CONSOLE_ONLY
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\modules\1sttest\t_version.h ===
#ifndef __TEMPLATE_VERSION__
#define __TEMPLATE_VERSION__





//==================================================================================
// Versioning information
//==================================================================================

// Major module version.  Must match or control layer won't see sessions.
#define TNMOD_VERSION_MATCH_MAJOR		1

// Minor module version.  Must match or control layer won't see sessions.
#define TNMOD_VERSION_MATCH_MINOR		0

// Minor module version.  Doesn't matter.
#define TNMOD_VERSION_MINOR				0

// Particular module build.  Doesn't matter.
#define TNMOD_VERSION_BUILD				1

#define TNMOD_VERSION_STRING			"01.00.00.0001"


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#define TNMOD_SHORTNAMECAPS		"TEMPLATE"
#define TNMOD_SHORTNAMELWR		"template"

#define TNMOD_NAME				"Template Tests"

#define TNMOD_COMPANY			"Microsoft Corporation"

#define TNMOD_COPYRIGHT			"Copyright  1999"

#define TNMOD_DESCRIPTION		"This module contains Template TestNet tests."

#define TNMOD_AUTHORS			"BillG, NotMe"



#endif //__TEMPLATE_VERSION__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\cmdline.h ===
#ifndef __COMMAND_LINE__
#define __COMMAND_LINE__


#if ((defined (CMDLINE_CONSOLE_ONLY)) && (defined (CMDLINE_WINDOWS_ONLY)))
#error You cannot define both CMDLINE_CONSOLE_ONLY and CMDLINE_CONSOLE_ONLY
#endif // CMDLINE_CONSOLE_ONLY and CMDLINE_WINDOWS_ONLY




//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined



//==================================================================================
// Defines
//==================================================================================
#ifndef CMDLINE_SWITCH_TOKENS
// Switches begin with one of these characters
#define CMDLINE_SWITCH_TOKENS	"/+-"
#endif // ! CMDLINE_SWITCH_TOKENS

#ifndef CMDLINE_VALUE_TOKENS
// Switch names end and values begin with one of these characters
#define CMDLINE_VALUE_TOKENS	":="
#endif // ! CMDLINE_VALUE_TOKENS



//==================================================================================
// Errors
//==================================================================================
// No error
#define CMDLINE_OK							S_OK

// You specified a handled item more than once to Initialize.
#define CMDLINEERR_DUPLICATEHANDLEDITEM		ERROR_ALREADY_EXISTS

// You specified a handled item of an unknown type to Initialize.
#define CMDLINEERR_UNKNOWNITEMTYPE			ERROR_INVALID_DATA

// You specified that parameters must be passed to the app, but none were given.
#define CMDLINEERR_NOPARAMSPASSED			ERROR_BAD_LENGTH

// The command line did not contain a parameter that was marked as required.
#define CMDLINEERR_REQUIREDPARAMNOTPASSED	ERROR_NOT_FOUND

// You passed something goofy into the init routine.
#define CMDLINEERR_INVALIDINITDATA			ERROR_INVALID_PARAMETER

// The command line contained a parameter with a value that wasn't recognized or
// that isn't allowed.
#define CMDLINERR_INVALIDPARAMETERVALUE		ERROR_BAD_COMMAND




//==================================================================================
// Initialization flags
//==================================================================================
// Use this flag if you want the parser to match parameter names exactly.
#define CMDLINE_FLAG_CASESENSITIVE				0x01

// Use this so that Parse will fail with CMDLINEERR_NOPARAMSPASSED when no items are
// specified on the command line.
#define CMDLINE_FLAG_FAILIFNOPARAMS				0x02

// If a parameter that is required (see CMDLINE_PARAMOPTION_FAILIFNOTEXIST) does not
// exist, then the object is automatically placed in help mode (the caller can access
// this information via IsInHelpMode and can act however he sees fit, but usually he
// calls DisplayHelp).
#define CMDLINE_FLAG_MISSINGPARAMMEANSHELP		0x04

// If INI files are allowed, then if the user passes the switch "ini" followed by
// a valid file name on the command line, the file is read in and items under the
// "[CommandLine]" section in the file are parsed as if they were specified on the
// command line.  This flag prevents the ini switch from automatically being
// handled.
#define CMDLINE_FLAG_DONTHANDLEINIFILES			0x08

// Use this if you do not want the parser to automatically detect the help switch.
#define CMDLINE_FLAG_DONTHANDLEHELPSWITCHES		0x10

// Use this if you do not want the parser to automatically detect the debug switch.
#define CMDLINE_FLAG_DONTHANDLEDEBUGSWITCH		0x20

// Use this if you do not want the parser to automatically detect the HTML switch.
#define CMDLINE_FLAG_DONTHANDLEHTMLSWITCH		0x40


/*
// Use this so that if a non-switch is found while parsing the command line,
// CMDLINE will stop processing and return CMDLINERR_ILLEGAL_PARAMETER.
#define CMDLINE_NONSWITCHES_CAUSE_ERROR			?

// Use this if you want to simply ignore any non-switches.  Will cause
// CMDLINEERR_INVALID_INIT_FLAGS if specified with CMDLINE_NONSWITCHES_CAUSE_ERROR.
#define CMDLINE_IGNORE_NONSWITCHES				?
*/





//==================================================================================
// Structures
//==================================================================================
typedef struct tagCMDLINEHANDLEDITEM
{
	DWORD		dwType; // kind of item this is, see CMDLINE_PARAMTYPE_xxx
	char*		pszName; // pointer to string to look for in command line
	char*		pszDescription; // pointer to string to description of command
	DWORD		dwOptions; // additional options for this item, see CMDLINE_PARAMOPTION_xxx
	PVOID*		ppvValuePtr; // pointer to default value and place to update to value
	PVOID		pvAdditionalData; // pointer to additional data, if any, for param type
	DWORD		dwAdditionalDataSize; // size of above additional data
} CMDLINEHANDLEDITEM, * PCMDLINEHANDLEDITEM;

typedef struct tagCMDLINEIDITEM
{
	char*		pszName; // pointer to string that is a valid value
	DWORD		dwValue; // value to assign if the string is found
} CMDLINEIDITEM, * PCMDLINEIDITEM;






//==================================================================================
// Parameter types
//==================================================================================
// Note that the value and additional data pointers must remain valid throughout the
// life of the CCommandLine object using them.

// BOOL
// If the name exists on the command line, the value becomes the toggled default
// value, i.e. if you set the default value to TRUE, specifying it will set the
// value to FALSE.  If the name is followed by a string, then the value becomes the
// interpretation of that string.  "0"'s, "false" or "off" (case-insensitive) mean
// FALSE, anything else is interpreted as TRUE.
// This switch can NOT be separated from its value by a space.
//
// The default value is a cast as a BOOL.
#define CMDLINE_PARAMTYPE_BOOL			1
#define CLPT_BOOL						CMDLINE_PARAMTYPE_BOOL


// INT
// The string following the name is converted into an int, which becomes the value.
// This switch can be separated from its value by a space.
//
// The value pointer can point to an int.
// There is no additional data.
#define CMDLINE_PARAMTYPE_INT			2
#define CLPT_INT						CMDLINE_PARAMTYPE_INT


// DWORD
// The string following the name is converted into a DWORD, which becomes the value.
// This switch can be separated from its value by a space.
//
// The value pointer can point to a DWORD.
// There is no additional data.
#define CMDLINE_PARAMTYPE_DWORD			3
#define CLPT_DWORD						CMDLINE_PARAMTYPE_DWORD


// DWORD_HEX
// The string following the name is converted into a hexadecimal DWORD, which
// becomes the value.
// This switch can be separated from its value by a space.
//
// The value pointer can point to a DWORD.
// There is no additional data.
#define CMDLINE_PARAMTYPE_DWORD_HEX		4
#define CLPT_DWORD_HEX					CMDLINE_PARAMTYPE_DWORD_HEX


// STRING
// The string following the name becomes the value.  The default value passed in
// is duplicated, so it can safely be released after the Initialize call, if you
// want.
// This switch can be separated from its value by a space.
//
// The value pointer can point to a string (char*).
// There is no additional data.
#define CMDLINE_PARAMTYPE_STRING		5
#define CLPT_STRING						CMDLINE_PARAMTYPE_STRING


// ID
// The string following the name is checked against the table passed in the
// additional data parameters, and if found, the value becomes the associated
// DWORD.
// This switch can be separated from its value by a space.
//
// The value pointer can point to a DWORD.
// The additional data must point to an array of CMDLINEIDITEMs holding strings and
// their associated values.
#define CMDLINE_PARAMTYPE_ID			6
#define CLPT_ID							CMDLINE_PARAMTYPE_ID


// MULTISTRING
// Multiple instances of parameters with this name can be specified, and a list
// of their values is built up.  If the default value exists, that existing
// CStringList is used, otherwise a new one is created.  Note there is no reference
// counting on the list object, so you must delete the command line object before
// deleting the CStringList.
// This switch can be separated from its value by a space.
//
// The value pointer can point to an PLSTRINGLIST.
// There is no additional data.
#define CMDLINE_PARAMTYPE_MULTISTRING	7
#define CLPT_MULTISTRING				CMDLINE_PARAMTYPE_MULTISTRING




//==================================================================================
// Parameter options
//==================================================================================
// If this item was not found on the command line, then return
// CMDLINEERR_REQUIREDPARAMNOTPASSED or go into help mode, if
// CMDLINE_FLAG_MISSINGPARAMMEANSHELP was specified.
// All types can specify this.
#define CMDLINE_PARAMOPTION_FAILIFNOTEXIST			0x1

// Don't display this item when displaying help.
// All types can specify this
#define CMDLINE_PARAMOPTION_HIDDEN					0x2

// Normally passing unknown IDs (strings that aren't in the lookup table) will cause
// parsing to fail with CMDLINERR_INVALIDPARAMETERVALUE.  Specifying this flag will
// causing parsing to continue (the item will be marked as found, but the value will
// remain the default).
// Only PARAMTYPE_IDs can specify this, it is ignored otherwise.
#define CMDLINE_PARAMOPTION_DONTFAILIFUNKNOWNID		0x4






//==================================================================================
// Parameter types
//==================================================================================
// Should the function fail if the specified file already exists?
#define CMDLINE_WRITEINIOPTION_FAILIFEXISTS			0x1

// If this is specified and the file exists, the text is added to the end of the
// file.
#define CMDLINE_WRITEINIOPTION_APPEND				0x2

// If this is used, the description specified for each command line item is printed
// in comments immediately preceding the command line item.
#define CMDLINE_WRITEINIOPTION_PRINTDESCRIPTIONS	0x4





//==================================================================================
// Class typedefs
//==================================================================================
typedef class CHandledParam				CHandledParam,				* PHANDLEDPARAM;
typedef class CHandledParamBool			CHandledParamBool,			* PHANDLEDPARAMBOOL;
typedef class CHandledParamInt			CHandledParamInt,			* PHANDLEDPARAMINT;
typedef class CHandledParamDWord		CHandledParamDWord,			* PHANDLEDPARAMDWORD;
typedef class CHandledParamDWordHex		CHandledParamDWordHex,		* PHANDLEDPARAMDWORDHEX;
typedef class CHandledParamString		CHandledParamString,		* PHANDLEDPARAMSTRING;
typedef class CHandledParamID			CHandledParamID,			* PHANDLEDPARAMID;
typedef class CHandledParamMultiString	CHandledParamMultiString,	* PHANDLEDPARAMMULTISTRING;

typedef class CHandledParamsList		CHandledParamsList,			* PHANDLEDPARAMSLIST;


typedef class CSpecifiedParam			CSpecifiedParam,			* PSPECIFIEDPARAM;
typedef class CSpecifiedParamsList		CSpecifiedParamsList,		* PSPECIFIEDPARAMSLIST;


typedef class CCommandLine				CCommandLine,				* PCOMMANDLINE;





#ifndef CMDLINE_CONSOLE_ONLY
//==================================================================================
// Local prototypes
//==================================================================================
INT_PTR CALLBACK HelpBoxWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // ! CMDLINE_CONSOLE_ONLY




//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CHandledParam:public CLString
{
	public:
		char*				m_pszDescription; // optional description of this item
		DWORD				m_dwType; // type of this item (i.e. child class ID)
		DWORD				m_dwOptions; // options for item
		int					m_fFound; // whether the item was found on the command line, or not
		PVOID*				m_ppvValuePtr; // pointer to place to update value


		CHandledParam(char* szName, char* pszDescription, DWORD dwType,
					DWORD dwOptions, PVOID* ppvValuePtr);
		virtual ~CHandledParam(void);

		// Pure virtual functions.  The child classes had better implement these
		// because we sure don't.
		virtual HRESULT GetSelfAndValues(BOOL fCaseSensitive, PSPECIFIEDPARAMSLIST pItemList) = 0;
#ifndef _XBOX // no file printing
		virtual HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose) = 0;
#endif // ! XBOX
};


class DLLEXPORT CHandledParamBool:public CHandledParam
{
	public:
		DWORD_PTR			m_fValue; // value of this item


		CHandledParamBool(char* szName, char* pszDescription, DWORD dwOptions,
						PVOID* ppvValuePtr);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};


class DLLEXPORT CHandledParamInt:public CHandledParam
{
	public:
		INT_PTR				m_iValue; // value of this item


		CHandledParamInt(char* szName, char* pszDescription, DWORD dwOptions,
						PVOID* ppvValuePtr);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};


class DLLEXPORT CHandledParamDWord:public CHandledParam
{
	public:
		DWORD_PTR				m_dwValue; // value of this item


		CHandledParamDWord(char* szName, char* pszDescription, DWORD dwOptions,
							PVOID* ppvValuePtr);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};


class DLLEXPORT CHandledParamDWordHex:public CHandledParam
{
	public:
		DWORD_PTR				m_dwValue; // value of this item


		CHandledParamDWordHex(char* szName, char* pszDescription, DWORD dwOptions,
							PVOID* ppvValuePtr);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};


class DLLEXPORT CHandledParamString:public CHandledParam
{
	public:
		char*				m_pszValue; // value of this item


		CHandledParamString(char* szName, char* pszDescription, DWORD dwOptions,
							PVOID* ppvValuePtr);
		virtual ~CHandledParamString(void);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};


class DLLEXPORT CHandledParamID:public CHandledParam
{
	public:
		PCMDLINEIDITEM		m_paLookupTable; // table to look up string values in
		DWORD				m_dwNumTableEntries; // number of items in the above table
		DWORD_PTR			m_dwValue; // value of this item


		CHandledParamID(char* szName, char* pszDescription, DWORD dwOptions,
						PVOID* ppvValuePtr, PCMDLINEIDITEM paLookupTable,
						DWORD dwNumTableEntries);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};


class DLLEXPORT CHandledParamMultiString:public CHandledParam
{
	public:
		PLSTRINGLIST		m_pValues; // list of values for this item
		BOOL				m_fCreatedValuesList; // TRUE if we created the above list, FALSE if it was given to us


		CHandledParamMultiString(char* szName, char* pszDescription, DWORD dwOptions,
								PVOID* ppvValuePtr);
		virtual ~CHandledParamMultiString(void);

		// Virtual function implementation.
		HRESULT GetSelfAndValues(BOOL fCaseSensitive,
								PSPECIFIEDPARAMSLIST pItemList);
#ifndef _XBOX // no file printing
		HRESULT PrintToFile(HANDLE hFile, BOOL fVerbose);
#endif // ! XBOX
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class DLLEXPORT CHandledParamsList:public CLStringList
{
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class DLLEXPORT CSpecifiedParam:public CLString
{
	public:
		BOOL	m_fSwitch; // is this item a switch
		BOOL	m_fSeparated; // whether this item was split from from the previous item


		CSpecifiedParam(char* szName, BOOL fSwitch, BOOL fSeparated);
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class DLLEXPORT CSpecifiedParamsList:public CLStringList
{
	public:
		HRESULT AddItem(char* szString, BOOL fSwitch, BOOL fTryToSplit,
						BOOL fWasSplit);
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class DLLEXPORT CCommandLine
{
#ifndef CMDLINE_CONSOLE_ONLY
	// This is a friend so it can access the protected members
	friend INT_PTR CALLBACK HelpBoxWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif // ! CMDLINE_CONSOLE_ONLY


	private:
		char*					m_pszPathToApp; // path to the application that created this object
		char*					m_pszOriginalCommandLine; // original command line item passed
#if (! ((defined (CMDLINE_CONSOLE_ONLY)) || (defined (CMDLINE_WINDOWS_ONLY))))
		BOOL					m_fConsole; // was the console version of Parse called?
#endif // not (CMDLINE_CONSOLE_ONLY or CMDLINE_WINDOWS_ONLY)
		DWORD					m_dwFlags; // flags we were initialized with

		BOOL					m_fHTML; // was the HTML switch found?
		BOOL					m_fHelp; // was a help switch found or a required parameter missing?
		BOOL					m_fDebug; // was the debug switch found?
		char*					m_pszIniFile; // pointer to INI file specified, if any

		CHandledParamsList		m_handleditems; // list of items that can be handled
		CSpecifiedParamsList	m_specifieditems; // list of items that were specified
		PHANDLEDPARAM*			m_papHelpItems; // temporary array of help items to display
		DWORD					m_dwNumHelpItems; // how many items in the preceding array
		LONG					m_lMaxHelpLineWidth; // max number of units a line can hold
		LONG					m_lMaxHelpHeight; // max number of units a help page can hold
		LONG					m_lLargestLeftHelpTextWidth; // largest name width
		LONG					m_lLargestRightHelpTextWidth; // largest description width
		LONG					m_lLargestHelpLineHeight; // largest help line height
#ifndef CMDLINE_CONSOLE_ONLY
		char*					m_pszTempParamNameBuffer; // buffer to hold largest possible parameter name
#endif // not CMDLINE_CONSOLE_ONLY



		HRESULT AddItemInternal(PCMDLINEHANDLEDITEM pItem,
								PHANDLEDPARAMSLIST pHandledItems);

		HRESULT ParseInternal(char* szCommandLine,
								PHANDLEDPARAMSLIST pHandledItems,
								PSPECIFIEDPARAMSLIST pSpecifiedItems);

		HRESULT ReadIniFileInternal(char* szFilepath,
									PSPECIFIEDPARAMSLIST pItemList);



	protected:
		DWORD		m_dwHelpStartItem; // first item index for current page


		HRESULT DisplayHelpPageInternal(DWORD* pdwStartItem, HWND hWnd);

	
	public:
		DLLSAFE_NEWS_AND_DELETES;

		CCommandLine(void);
		virtual ~CCommandLine(void);


		HRESULT Initialize(DWORD dwFlags, PCMDLINEHANDLEDITEM aHandledItems,
							DWORD dwNumHandledItems);

		// Overloaded
#ifndef CMDLINE_CONSOLE_ONLY
		HRESULT Parse(LPCSTR lpcszString);
#endif // ! CMDLINE_CONSOLE_ONLY
#ifndef CMDLINE_WINDOWS_ONLY
		HRESULT Parse(int iNumArgs, char* aszArgsArray[]);
#endif // ! CMDLINE_CONSOLE_ONLY

		BOOL InHelpMode(void);
		BOOL InDebugMode(void);
		BOOL InHTMLMode(void);

		HRESULT DisplayHelp(BOOL fAlphabetize);

		HRESULT CheckForItem(PCMDLINEHANDLEDITEM pHandledItem, BOOL* pfWasSpecified);
		HRESULT CheckForItems(PCMDLINEHANDLEDITEM aHandledItems, DWORD dwNumHandledItems);

		HRESULT GetPathToApp(char* pszBuffer, DWORD* pdwBufferSize);
		HRESULT GetPathToAppDir(char* pszBuffer, DWORD* pdwBufferSize);
		HRESULT GetNameOfApp(char* pszBuffer, DWORD* pdwBufferSize);

		BOOL WasSpecified(PVOID* ppvItem);

		char* GetSwitchValueString(char* szName);

		HRESULT WriteToINI(char* szFilepath, DWORD dwOptions);
};





#endif //__COMMAND_LINE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\modules\1sttest\t_main.h ===
#ifndef __TEMPLATE_MAIN__
#define __TEMPLATE_MAIN__
//#pragma message("Defining __TEMPLATE_MAIN__")






//==================================================================================
// Common Defines
//==================================================================================
#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)


//#ifdef DPVTEST_EXPORTS

//#ifdef DLLEXPORT
//#undef DLLEXPORT
//#endif // ! DLLEXPORT
//#define DLLEXPORT __declspec(dllexport)

//#else // ! DPVTEST_EXPORTS

//#ifdef DLLEXPORT
//#undef DLLEXPORT
//#endif // ! DLLEXPORT
//#define DLLEXPORT __declspec(dllimport)

//#endif // ! DPVTEST_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// Defines
//==================================================================================
#undef DEBUG_MODULE
#define DEBUG_MODULE	"TEMPLATE"









#else //__TEMPLATE_MAIN__
//#pragma message("__TEMPLATE_MAIN__ already included!")
#endif //__TEMPLATE_MAIN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\modules\1sttest\t_main.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include <objbase.h>
#include <windows.h>
#include <initguid.h>

#include "..\..\tncommon\debugprint.h"
#include "..\..\tncommon\cppobjhelp.h"
#include "..\..\tncommon\linklist.h"
#include "..\..\tncommon\linkedstr.h"
#include "..\..\tncommon\cmdline.h"
#include "..\..\tncommon\excptns.h"

#include "..\..\tncontrl\tncontrl.h"

#include "..\..\tnshell\dll\tnshell.h"


#include "t_version.h"
#include "t_main.h"
#include "1sttest.h"




//==================================================================================
// Globals
//==================================================================================
BOOL		g_fMaster = FALSE;
DWORD		g_dwMode = 0;
char*		g_pszDirectory = NULL;






//==================================================================================
// Statics
//==================================================================================
static TNMODULEID	s_ModuleID =	{	TNMOD_SHORTNAMECAPS,		// short name, must match
										TNMOD_VERSION_MATCH_MAJOR,	// major version, must match
										TNMOD_VERSION_MATCH_MINOR,	// minor version, must match
										TNMOD_VERSION_MINOR,		// minor version, doesn't matter
										TNMOD_VERSION_BUILD			// build number, doesn't matter
									};

static HINSTANCE	s_hInstance = NULL;





//==================================================================================
// Prototypes
//==================================================================================
HRESULT TNM_LoadTestTable(PTNTESTTABLEGROUP pTable);

HRESULT TNM_InitModuleTesting(PTNMACHINEINFO pInfo);

HRESULT TNM_CleanupTesting(PTNMACHINEINFO pInfo);

HRESULT TNM_AddImportantBinaries(PTNTRACKEDBINARIES pBinList);

HRESULT TNM_GetModuleInfo(PTNSHELLINFO pTNsi, PTNMODULEINFO pTNmi);
HRESULT TNM_InitModule(PTNINITMODULEDATA pTNid);
HRESULT TNM_Release(void);



#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_GetModuleInfo()"
//==================================================================================
// TNM_GetModuleInfo
//----------------------------------------------------------------------------------
//
// Description: Mandatory entry point for module that the shell uses to retrieve
//				information on this DLL so the user can choose which to load.
//				This is called with NULL pointers to strings, which requires us to
//				fill in the size required for the strings so the shell can call us
//				again with appropriate buffers.  We return ERROR_BUFFER_TOO_SMALL
//				if that's the case.
//
// Arguments:
//	PTNSHELLINFO pTNsi		Pointer to structure describing shell that is calling
//							us.
//	pTNmi pTNmi		Pointer to structure to return info in.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNM_GetModuleInfo(PTNSHELLINFO pTNsi, PTNMODULEINFO pTNmi)
{
	HRESULT		hr = S_OK;


	// Don't bother printing warnings if the shell and control layers are different
	// versions from what we expected, because the shell may not end up loading us.
	// The information is only marginally useful to us in this call, and is here
	// in case in the future we need to alter how we respond to GetModuleInfo which
	// is not very likely.
	pTNmi->dwShellAPIVersion = CURRENT_TNSHELL_API_VERSION;
	pTNmi->dwControlAPIVersion = CURRENT_TNCONTROL_API_VERSION;


	// Copy the module ID

	memcpy(&(pTNmi->moduleid), &(s_ModuleID), sizeof (TNMODULEID));


	// Return the name string

	if ((pTNmi->pszName == NULL) ||
		(pTNmi->dwNameSize < (strlen(TNMOD_NAME) + 1)))
	{
		hr = ERROR_BUFFER_TOO_SMALL;
		pTNmi->dwNameSize = strlen(TNMOD_NAME) + 1;
	} // end if (the buffer to copy the name in isn't big enough)
	else
		strcpy(pTNmi->pszName, TNMOD_NAME);


	// Return the description string

	if ((pTNmi->pszDescription == NULL) ||
		(pTNmi->dwDescriptionSize < (strlen(TNMOD_DESCRIPTION) + 1)))
	{
		hr = ERROR_BUFFER_TOO_SMALL;
		pTNmi->dwDescriptionSize = strlen(TNMOD_DESCRIPTION) + 1;
	} // end if (the buffer to copy the name in isn't big enough)
	else
		strcpy(pTNmi->pszDescription, TNMOD_DESCRIPTION);


	// Return the authors string

	if ((pTNmi->pszAuthors == NULL) ||
		(pTNmi->dwAuthorsSize < (strlen(TNMOD_AUTHORS) + 1)))
	{
		hr = ERROR_BUFFER_TOO_SMALL;
		pTNmi->dwAuthorsSize = strlen(TNMOD_AUTHORS) + 1;
	} // end if (the buffer to copy the name in isn't big enough)
	else
		strcpy(pTNmi->pszAuthors, TNMOD_AUTHORS);


	return (hr);
} // TNM_GetModuleInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_InitModule()"
//==================================================================================
// TNM_InitModule
//----------------------------------------------------------------------------------
//
// Description: Mandatory entry point for module that allows it to initialize any
//				data it may need and to extract information from the command line.
//				The module's other functions, such as GetStartupData() are returned
//				in the TNMODFUNCS structure of the init data, and control layer
//				options required are returned in the given DWORD.
//
// Arguments:
//	PTNINITMODULEDATA pTNid		Pointer to data to use when initializing. Also has
//								items for module to fill out.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNM_InitModule(PTNINITMODULEDATA pTNid)
{
	HRESULT		hr;


	// Don't print warnings for older API versions, since we can assume we know
	// how to be backward compatible.

	if (pTNid->shellinfo.dwShellAPIVersion != CURRENT_TNSHELL_API_VERSION)
	{
		DPL(0, "WARNING: Shell using different API version (%i != %i), problems may exist.",
			2, pTNid->shellinfo.dwShellAPIVersion,  CURRENT_TNSHELL_API_VERSION);
	} // end if (we're working with a shell that's using a higher API version)
	if (pTNid->shellinfo.dwControlAPIVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "WARNING: Control layer using different API version (%i != %i), problems may exist.",
			2, pTNid->shellinfo.dwControlAPIVersion,  CURRENT_TNCONTROL_API_VERSION);
	} // end if (we're working with a control layer that's using a higher API version)

	// Handle the command line
	g_fMaster = pTNid->fMaster;
	g_dwMode = pTNid->dwMode;


	// Copy the directory we reside in
	g_pszDirectory = (char*) LocalAlloc(LPTR, (strlen(pTNid->pszModuleDirPath) + 1));
	if (g_pszDirectory == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	strcpy(g_pszDirectory, pTNid->pszModuleDirPath);



	// Fill in the functions we implement
	pTNid->TNModuleFuncs.pfnLoadTestTable = TNM_LoadTestTable;
	pTNid->TNModuleFuncs.pfnInitializeTesting = TNM_InitModuleTesting;
	pTNid->TNModuleFuncs.pfnCleanupTesting = TNM_CleanupTesting;
	pTNid->TNModuleFuncs.pfnAddImportantBinaries = TNM_AddImportantBinaries;
//	pTNid->TNModuleFuncs.pfnGetPokePages = TNM_GetPokePages;
	pTNid->TNModuleFuncs.pfnGetPokePages = NULL;

	// Return the control layer options we need.
	pTNid->dwControlLayerFlags = TNCLR_INITIALIZE_COM_FOR_TESTTHREAD; 

	return (S_OK);


ERROR_EXIT:

	// If we fail to initialize, Shutdown() won't be called, so we have to clean
	// up any partially allocated things here.

	if (g_pszDirectory != NULL)
	{
		LocalFree(g_pszDirectory);
		g_pszDirectory = NULL;
	} // end if (allocated a directory)

	return (hr);
} // TNM_InitModule
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_Release()"
//==================================================================================
// TNM_Release
//----------------------------------------------------------------------------------
//
// Description: Mandatory entry point for module that allows it to clean up any data
//				it used during its lifetime.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNM_Release(void)
{
	// If this function is being called, it means that Initialize completed
	// successfully.

	if (g_pszDirectory != NULL)
	{
		LocalFree(g_pszDirectory);
		g_pszDirectory = NULL;
	} // end if (we allocated a directory string)

	return (S_OK);
} // TNM_Release
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_LoadTestTable()"
//==================================================================================
// TNM_LoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Mandatory entry point for module that loads all the possible tests
//				into the table passed in.
//
// Arguments:
//	PTNTESTTABLEGROUP pTable	Table to fill with tests in this file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNM_LoadTestTable(PTNTESTTABLEGROUP pTable)
{
	HRESULT		hr;


	hr = FirstTestLoadTestTable(pTable);
	if (hr != S_OK)
	{
		DPL(0, "Loading First tests failed!", 0);
		return (hr);
	} // end if (loading tests failed)

	return (S_OK);
} // TNM_LoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_InitModuleTesting()"
//==================================================================================
// TNM_InitModuleTesting
//----------------------------------------------------------------------------------
//
// Description: Called before testing begins.  This allows us to allocate any
//				resources we need and prep for testing.
//
// Arguments:
//	PTNMACHINEINFO pInfo	Pointer to current info for this machine.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNM_InitModuleTesting(PTNMACHINEINFO pInfo)
{
	// Do any initialization here.

	return (S_OK);
} // TNM_InitModuleTesting
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_CleanupTesting()"
//==================================================================================
// TNM_CleanupTesting
//----------------------------------------------------------------------------------
//
// Description: Called after testing completes.  This allows us to free any
//				resources we allocated during testing.
//
// Arguments:
//	PTNMACHINEINFO pInfo	Pointer to current info for this machine.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNM_CleanupTesting(PTNMACHINEINFO pInfo)
{
	// Do any cleanup here.

	return (S_OK);
} // TNM_CleanupTesting
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNM_AddImportantBinaries()"
//==================================================================================
// TNM_AddImportantBinaries
//----------------------------------------------------------------------------------
//
// Description: Callback that allows the module to select the binaries that are
//				relevant/important or whose versions impact the testing that will be
//				done.
//
// Arguments:
//	PTNTRACKEDBINARIES pBinList		List to attach important binaries to.
//
// Returns: S_OK if successful, the error code otherwise.
//==================================================================================
HRESULT TNM_AddImportantBinaries(PTNTRACKEDBINARIES pBinList)
{
	HRESULT			hr;


	// Specify whatever binaries you think are important instead of these.  The
	// file information for these will show up in the UI and is also easily
	// available during the test.  You can key off of it for version specific tests,
	// for example.

	hr = pBinList->LocateAndAddBinary("kernel32.dll");
	if (hr != S_OK)
	{
		DPL(0, "Couldn't identify kernel32.dll binary!", 0);
		return (hr);
	} // end if (couldn't identify binary)

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	hr = pBinList->LocateAndAddBinary("user32.dll");
	if (hr != S_OK)
	{
		DPL(0, "Couldn't identify user32.dll binary!", 0);
		return (hr);
	} // end if (couldn't identify binary)

	return (S_OK);
} // TNM_AddImportantBinaries
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"DllMain()"
//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HINSTANCE hmod		Handle to this DLL module.
//	DWORD dwReason		Reason for calling this function.
//	LPVOID lpvReserved	Reserved.
//
// Returns: 0 if all goes well.
//==================================================================================
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			TNDebugInitialize();

//			DPL(0, "Attaching to process %x.", 1, GetCurrentProcessId());

			s_hInstance = hmod;
		  break;

		case DLL_PROCESS_DETACH:
//			DPL(0, "Detaching from process %x.", 1, GetCurrentProcessId());

			TNDebugCleanup();
		  break;
	} // end switch (on the reason we're being called here)

	return (TRUE);
} // DllMain
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\convhelp.h ===
#ifdef _XBOX
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//==================================================================================
// wsprintf
//==================================================================================
int wsprintf(LPSTR pszOutput, LPCSTR pszFormat, ...);
HANDLE FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\crc32.c ===
#include <windows.h>
#include "crc32.h"


// Checksum lookup table
const CHECKSUM g_crcTable[] = 
{
    0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL, 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L,
    0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L, 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L,
    0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL, 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L,
    0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL, 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L,
    0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L, 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL,
    0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L, 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L,
    0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L, 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL,
    0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L, 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL,

    0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL, 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L,
    0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L, 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L,
    0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL, 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L,
    0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL, 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L,
    0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L, 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL,
    0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L, 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L,
    0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L, 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL,
    0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L, 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL,

    0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL, 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L,
    0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L, 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L,
    0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL, 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L,
    0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL, 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L,
    0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L, 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL,
    0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L, 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L,
    0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L, 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL,
    0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L, 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL,

    0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL, 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L,
    0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L, 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L,
    0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL, 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L,
    0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL, 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L,
    0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L, 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL,
    0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L, 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L,
    0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L, 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL,
    0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L, 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL
};


// ---------------------------------------------------------------------------
// GetChecksum
// ---------------------------------------------------------------------------
// Description:             Returns a 32-bit checksum for some supplied data.
// Arguments:               
//  LPVOID [in]             Data buffer.
//  DWORD [in]              Size of above buffer.
// Returns:
//  CHECKSUM                32-bit CRC of above data.
CHECKSUM WINAPI GetChecksum(LPVOID lpvData, DWORD dwSize)
{
    LPBYTE                  lpbData = (LPBYTE)lpvData;
    CHECKSUM                crc = -1;
    
    if(dwSize > 0)
    {
        while(dwSize--)
            crc = g_crcTable[(BYTE)crc ^ *lpbData++] ^ ((crc >> 8) & 0x00FFFFFFL);
    }
       
    return -1 - crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\convhelp.cpp ===
#ifdef _XBOX
#include "convhelp.h"

//==================================================================================
// wsprintf
//==================================================================================
int wsprintf(char *pszOutput, char const *pszFormat, ...)
{
	int		nRet = 0;
	WCHAR	szWideOutput[1024], szWideFormat[1024];

	va_list pArgs;
	va_start(pArgs, pszFormat);

	if(strlen(pszFormat) > 1023)
		return -1;

	// Covert the original format string to wide...
	mbstowcs(szWideFormat, pszFormat, strlen(pszFormat));
	szWideFormat[strlen(pszFormat)] = 0;

	// Do the wide version of wsprintf
	if((nRet = swprintf(szWideOutput, szWideFormat, pArgs)) > 1023)
		return -1;

	va_end(pArgs);

	// Convert the created wide string to multi-byte...
	wcstombs(pszOutput, szWideOutput, wcslen(szWideOutput));
	pszOutput[wcslen(szWideOutput)] = 0;

	return nRet;
}

HANDLE FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData)
{
	WCHAR szWideFileName[MAX_PATH];

	mbstowcs(szWideFileName, lpFileName, strlen(lpFileName));
	szWideFileName[strlen(lpFileName)] = 0;

	return FindFirstFile(szWideFileName, lpFindFileData);
}

#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\cppobjhelp.h ===
#ifndef __CPP_OBJECT_HELP__
#define __CPP_OBJECT_HELP__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined




//==================================================================================
// DLL safe memory/object allocation routines and macros.
//==================================================================================
#ifdef DEBUG
#ifndef NO_CPPOBJHELP_LEAKCHECK
DLLEXPORT void InitCPPObjHelp(void);
DLLEXPORT void CheckForCPPObjLeaks(void);
DLLEXPORT void CleanupCPPObjHelp(void);
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // DEBUG

DLLEXPORT void* DLLSafeNew(unsigned int cb);
DLLEXPORT void DLLSafeDelete(void* p);

// You should use this macro in your own classes if they don't inherit from a class
// that already uses this (i.e. not derived from the classes in this header).
#define DLLSAFE_NEWS_AND_DELETES	inline void* operator new(size_t cb)\
									{\
										return (DLLSafeNew(cb));\
									};\
									inline void* operator new[](size_t cb)\
									{\
										return (DLLSafeNew(cb));\
									};\
									inline void operator delete(void* p)\
									{\
										DLLSafeDelete(p);\
									};\
									inline void operator delete[](void* p)\
									{\
										DLLSafeDelete(p);\
									}




#endif //__CPP_OBJECT_HELP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\cppobjhelp.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>


#include "main.h"
#include "cppobjhelp.h"
#ifdef DEBUG
#include "linklist.h"
#include "sprintf.h"
#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#endif // ! NO_TNCOMMON_DEBUG_SPEW
#ifndef NO_CPPOBJHELP_LEAKCHECK
#include "symbols.h"
#include "stack.h"
#include "strutils.h"
#include "linkedstr.h"
#include "fileutils.h"
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // DEBUG




#ifdef DEBUG
#ifndef NO_CPPOBJHELP_LEAKCHECK


//==================================================================================
// Defines
//==================================================================================
#define MEMORYTRACKING_ARRAYSIZEINCREMENT	50

#define MEMORYTRACKING_COOKIE				0x66666666
#define MEMORYTRACKING_FREEDCOOKIE			0x6A6A6A6A




//==================================================================================
// Structures
//==================================================================================
typedef struct tagMEMORYTRACKINGHEADER
{
	DWORD			dwCookie; // cookie to make sure the memory is good
	PVOID			pvCallersAddress; // address of the allocating function
	PVOID			pvCallersCaller; // address of allocating function's caller
	unsigned int	uiSize; // size of the memory
} MEMORYTRACKINGHEADER, * PMEMORYTRACKINGHEADER;




//==================================================================================
// Globals
//==================================================================================
DWORD					g_dwCPPObjInits = 0;
CRITICAL_SECTION		g_csMem;
DWORD					g_dwNumOutstandingObjects = 0;
DWORD					g_dwTotalOutstandingBytes = 0;
PMEMORYTRACKINGHEADER*	g_paAllocations = NULL;
DWORD					g_dwAllocationsCount = 0;





#undef DEBUG_SECTION
#define DEBUG_SECTION	"InitCPPObjHelp()"
//==================================================================================
// InitCPPObjHelp
//----------------------------------------------------------------------------------
//
// Description: Prepares this file for use.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void InitCPPObjHelp(void)
{
	g_dwCPPObjInits++;

	if (g_dwCPPObjInits == 1)
	{
		InitializeCriticalSection(&g_csMem);

		g_paAllocations = (PMEMORYTRACKINGHEADER*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															MEMORYTRACKING_ARRAYSIZEINCREMENT * sizeof (PMEMORYTRACKINGHEADER));
		if (g_paAllocations == NULL)
		{
			DeleteCriticalSection(&g_csMem);
			return;
		} // end if (couldn't allocate memory)

		g_dwAllocationsCount = MEMORYTRACKING_ARRAYSIZEINCREMENT;
	} // end if (first initialization)
} // InitCPPObjHelp
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CheckForCPPObjLeaks()"
//==================================================================================
// CheckForCPPObjLeaks
//----------------------------------------------------------------------------------
//
// Description: Prints out all currently outstanding objects.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CheckForCPPObjLeaks(void)
{
#ifndef _XBOX // no GetModuleFileName supported, so don't implement this now

	HRESULT		hr;
	DWORD		dwTemp;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	char		szTemp[1024];
	char		szCallersAddress[1024];
	char		szCallersCaller[1024];
	DWORD_PTR	dwOffset;

#ifndef NO_TNCOMMON_DEBUG_SPEW
	// Make sure we can debug print
	TNDebugInitialize();
#endif // ! NO_TNCOMMON_DEBUG_SPEW


	if (g_dwCPPObjInits == 0)
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "CPP object help not initialized!", 0);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (not initted)


	// Check for any items we've leaked
	if (g_dwNumOutstandingObjects > 0)
	{
		hr = FileCreateAndOpenFile("leaks.txt", FALSE, TRUE, FALSE, &hFile);
		if (hr != S_OK)
		{
#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't create and open \"leaks.txt\" file!  %e", 1, hr);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
		} // end if (couldn't open file)


		if (hFile != INVALID_HANDLE_VALUE)
		{
			FileWriteLine(hFile, "//==================================================================================");
			StringGetCurrentDateStr(szTemp);
			FileSprintfWriteLine(hFile, "// Leaks for process %x/%u at %s",
								3, GetCurrentProcessId(), GetCurrentProcessId(),
								szTemp);
			FileWriteLine(hFile, "//==================================================================================");

			FileSprintfWriteLine(hFile, "Leaked %u C++ object(s) for a total of %u bytes!",
								2, g_dwNumOutstandingObjects,
								(g_dwTotalOutstandingBytes - (g_dwNumOutstandingObjects * sizeof (MEMORYTRACKINGHEADER))));
			FileSprintfWriteLine(hFile, "(%u bytes including memory tracking headers)!",
								1, g_dwTotalOutstandingBytes);
		} // end if (have open file)

#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Leaked %u C++ object(s) for a total of %u bytes!",
			2, g_dwNumOutstandingObjects,
			(g_dwTotalOutstandingBytes - (g_dwNumOutstandingObjects * sizeof (MEMORYTRACKINGHEADER))));
		DPL(0, "(%u bytes including memory tracking headers)!",
			1, g_dwTotalOutstandingBytes);
#endif // ! NO_TNCOMMON_DEBUG_SPEW


		for(dwTemp = 0; dwTemp < g_dwAllocationsCount; dwTemp++)
		{
			if (g_paAllocations[dwTemp] != NULL)
			{
				// Unfortunately, in-app symbol resolution doesn't seem to work
				// when the process is shutting down (plus TNSymCleanup should
				// have already been called), so we can't use %Xs.  However, we
				// can just retrieve a module name and offset, so we'll do that.
				ZeroMemory(szCallersAddress, 1024);
				ZeroMemory(szCallersCaller, 1024);

				hr = TNSymGetModuleNameAndOffsetForPointer(g_paAllocations[dwTemp]->pvCallersAddress,
															szCallersAddress,
															1024,
															&dwOffset);
				if (hr != S_OK)
				{
#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Couldn't get module name and offset for caller's address %x!  %e",
						2, g_paAllocations[dwTemp]->pvCallersAddress,
						hr);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
				} // end if (couldn't resolve name)
				else
				{
					wsprintf(szTemp, " + 0x" SPRINTF_PTR " (0x" SPRINTF_PTR ")",
							dwOffset,
							g_paAllocations[dwTemp]->pvCallersAddress);
					strcat(szCallersAddress, szTemp);
				} // end else (could get name)


				hr = TNSymGetModuleNameAndOffsetForPointer(g_paAllocations[dwTemp]->pvCallersCaller,
															szCallersCaller,
															1024,
															&dwOffset);
				if (hr != S_OK)
				{
#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Couldn't get module name and offset for caller's caller %x!  %e",
						2, g_paAllocations[dwTemp]->pvCallersCaller,
						hr);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
				} // end if (couldn't resolve name)
				else
				{
					wsprintf(szTemp, " + 0x" SPRINTF_PTR " (0x" SPRINTF_PTR ")",
							dwOffset,
							g_paAllocations[dwTemp]->pvCallersCaller);
					strcat(szCallersCaller, szTemp);
				} // end else (could get name)


				if (hFile != INVALID_HANDLE_VALUE)
				{
					FileSprintfWriteLine(hFile,
										"Leaked C++ object at %x, %u bytes (+ %u byte header)!",
										3, ((LPBYTE) (g_paAllocations[dwTemp])) + sizeof (MEMORYTRACKINGHEADER),
										g_paAllocations[dwTemp]->uiSize,
										sizeof (MEMORYTRACKINGHEADER));

					FileSprintfWriteLine(hFile, "   Allocated by %s",
										1, szCallersAddress);
					FileSprintfWriteLine(hFile, "   Which was called by %s",
										1, szCallersCaller);
				} // end if (have open file)

#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Leaked C++ object at %x, %u bytes (+ %u byte header)!",
					3, ((LPBYTE) (g_paAllocations[dwTemp])) + sizeof (MEMORYTRACKINGHEADER),
					g_paAllocations[dwTemp]->uiSize,
					sizeof (MEMORYTRACKINGHEADER));

				DPL(0, "   Allocated by %s",
					1, szCallersAddress);
				DPL(0, "   Which was called by %s",
					1, szCallersCaller);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
			} // end if (still an allocation here)
		} // end for (each allocation slot)

		if (hFile != INVALID_HANDLE_VALUE)
		{
			// Add extra space in case the file is appended to.
			FileWriteLine(hFile, "");

			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
		} // end if (have open file)
	} // end if (anything left outstanding)


DONE:

#ifndef NO_TNCOMMON_DEBUG_SPEW
	TNDebugCleanup();
#endif // ! NO_TNCOMMON_DEBUG_SPEW
#else // ! XBOX
#pragma TODO(tristanj, "CheckForCPPObjLeaks isn't doing anything")
#endif // XBOX
} // CheckForCPPObjLeaks
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CleanupCPPObjHelp()"
//==================================================================================
// CleanupCPPObjHelp
//----------------------------------------------------------------------------------
//
// Description: Cleans up after this file.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CleanupCPPObjHelp(void)
{
	if (g_dwCPPObjInits == 1)
	{
		CheckForCPPObjLeaks();


		HeapFree(GetProcessHeap(), 0, g_paAllocations);
		g_paAllocations = NULL;

		g_dwAllocationsCount = 0;
		g_dwNumOutstandingObjects = 0;

		DeleteCriticalSection(&g_csMem);
	} // end if (last deinitialize)

	g_dwCPPObjInits--;
} // CleanupCPPObjHelp
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // DEBUG





#undef DEBUG_SECTION
#define DEBUG_SECTION	"DLLSafeNew()"
//==================================================================================
// DLLSafeNew
//----------------------------------------------------------------------------------
//
// Description: Allocates memory of the specified size from the process heap.
//
// Arguments:
//	unsigned int cb		Size of memory block to allocate.
//
// Returns: Pointer to the memory allocated, or NULL if an error occurred.
//==================================================================================
void* DLLSafeNew(unsigned int cb)
{
	DWORD					dwSize;
	void*					pvResult;
#ifdef DEBUG
#ifndef NO_CPPOBJHELP_LEAKCHECK
	PMEMORYTRACKINGHEADER	pHeader = NULL;


	if (g_dwCPPObjInits == 0)
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "CPP object help not initialized!", 0);
#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (not initialized)

	EnterCriticalSection(&g_csMem);
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // DEBUG


	dwSize = cb;
#ifdef DEBUG
#ifndef NO_CPPOBJHELP_LEAKCHECK
	dwSize += sizeof (MEMORYTRACKINGHEADER);
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // DEBUG

	pvResult = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

#ifdef DEBUG
	/*
#ifndef NO_CPPOBJHELP_LEAKCHECK
#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "%x (%x) = HeapAlloc(%x, HEAP_ZERO_MEMORY, %u (%u))",
		5, pvResult, (((LPBYTE) pvResult) + sizeof (MEMORYTRACKINGHEADER)),
		GetProcessHeap(), dwSize, cb);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
#endif // ! NO_CPPOBJHELP_LEAKCHECK
	*/

	if (pvResult == NULL)
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "HeapAlloc(%x, HEAP_ZERO_MEMORY, %u) failed!",
			2, GetProcessHeap(), dwSize);
#endif // ! NO_TNCOMMON_DEBUG_SPEW

#ifndef NO_CPPOBJHELP_LEAKCHECK
		LeaveCriticalSection(&g_csMem);
#endif // ! NO_CPPOBJHELP_LEAKCHECK

		return (NULL);
	} // end else (failed allocating memory)


#ifndef NO_CPPOBJHELP_LEAKCHECK
	pHeader = (PMEMORYTRACKINGHEADER) pvResult;
	pvResult = pHeader + 1;

	pHeader->dwCookie = MEMORYTRACKING_COOKIE;
	pHeader->uiSize = cb;
	TNStackGetCallersAddress(&(pHeader->pvCallersAddress),
							&(pHeader->pvCallersCaller));


	if (g_dwNumOutstandingObjects < g_dwAllocationsCount)
	{
		DWORD	dwTemp;


		// Look for the empty allocation slot
		for(dwTemp = 0; dwTemp < g_dwAllocationsCount; dwTemp++)
		{
			if (g_paAllocations[dwTemp] == NULL)
			{
				g_paAllocations[dwTemp] = pHeader;
				break;
			} // end if (found empty slot)
		} // end for (each slot)

#ifndef NO_TNCOMMON_DEBUG_SPEW
		if (dwTemp >= g_dwAllocationsCount)
		{
			DPL(0, "Didn't find empty slot in array!?", 0);
		} // end if (didn't find slot)
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (there's an empty slot somewhere)
	else
	{
		void*	pvTemp;


		pvTemp = HeapAlloc(GetProcessHeap(),
							HEAP_ZERO_MEMORY,
							((g_dwAllocationsCount + MEMORYTRACKING_ARRAYSIZEINCREMENT) * sizeof (PMEMORYTRACKINGHEADER)));
		if (g_paAllocations == NULL)
		{
			HeapFree(GetProcessHeap(), 0, pvResult);
			pvResult = NULL;

			LeaveCriticalSection(&g_csMem);
			return (NULL);
		} // end if (couldn't allocate memory)

		CopyMemory(pvTemp, g_paAllocations,
				(g_dwAllocationsCount * sizeof (PMEMORYTRACKINGHEADER)));

		HeapFree(GetProcessHeap(), 0, g_paAllocations);
		g_paAllocations = (PMEMORYTRACKINGHEADER*) pvTemp;
		pvTemp = NULL;

		g_dwAllocationsCount += MEMORYTRACKING_ARRAYSIZEINCREMENT;

		g_paAllocations[g_dwNumOutstandingObjects] = pHeader;
	} // end if (need more room in allocation array)

	g_dwNumOutstandingObjects++;
	g_dwTotalOutstandingBytes += dwSize;


	/*
#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "%u outstanding objects, %u bytes.",
		2, g_dwNumOutstandingObjects, g_dwTotalOutstandingBytes);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/


	LeaveCriticalSection(&g_csMem);
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // DEBUG

	return (pvResult);
} // DLLSafeNew
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"DLLSafeDelete()"
//==================================================================================
// DLLSafeDelete
//----------------------------------------------------------------------------------
//
// Description: Frees memory previously allocated from the process heap.
//
// Arguments:
//	void* p		Pointer to memory to free.
//
// Returns: None.
//==================================================================================
void DLLSafeDelete(void* p)
{
#ifdef DEBUG
#ifndef NO_CPPOBJHELP_LEAKCHECK
	PMEMORYTRACKINGHEADER	pHeader = NULL;
	DWORD					dwSize;
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#ifndef NO_TNCOMMON_DEBUG_SPEW
	HRESULT					hr;
#endif // ! NO_TNCOMMON_DEBUG_SPEW


#ifndef NO_CPPOBJHELP_LEAKCHECK
	if (g_dwCPPObjInits == 0)
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "CPP object help not initialized!", 0);
#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return;
	} // end if (not initialized)

	EnterCriticalSection(&g_csMem);


	pHeader = (PMEMORYTRACKINGHEADER) (((LPBYTE) p) - sizeof (MEMORYTRACKINGHEADER));

	if (pHeader->dwCookie != MEMORYTRACKING_COOKIE)
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Memory tracking cookie for %x (allocated for %x) is wrong (%x != %x)!",
			4, pHeader, p, pHeader->dwCookie, MEMORYTRACKING_COOKIE);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (not cookie)
	else
	{
		// We're about to free it, so update it.
		pHeader->dwCookie = MEMORYTRACKING_FREEDCOOKIE;
	} // end else (is cookie)

	dwSize = pHeader->uiSize + sizeof (MEMORYTRACKINGHEADER);

	/*
#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "HeapFree(%x, 0, %x)", 2, GetProcessHeap(), pHeader);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // ! DEBUG


#if ((defined (DEBUG)) && (! defined (NO_CPPOBJHELP_LEAKCHECK)))
	if (! HeapFree(GetProcessHeap(), 0, pHeader))
#else // ! DEBUG || NO_CPPOBJHELP_LEAKCHECK
	if (! HeapFree(GetProcessHeap(), 0, p))
#endif // ! DEBUG || NO_CPPOBJHELP_LEAKCHECK

#ifdef DEBUG
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		hr = GetLastError();

#ifdef NO_CPPOBJHELP_LEAKCHECK
		DPL(0, "Couldn't free item %x from process heap (%x)!  %e",
			3, p, GetProcessHeap(), hr);
#else // ! NO_CPPOBJHELP_LEAKCHECK
		DPL(0, "Couldn't free item %x (%x) from process heap (%x)!  %e",
			4, pHeader, p, GetProcessHeap(), hr);
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (couldn't free item)
#ifndef NO_CPPOBJHELP_LEAKCHECK
	else
	{
		DWORD	dwTemp;


		// Loop through all our allocations for this one, and mark it as gone.
		for(dwTemp = 0; dwTemp < g_dwAllocationsCount; dwTemp++)
		{
			if (g_paAllocations[dwTemp] == pHeader)
			{
				g_paAllocations[dwTemp] = NULL; // it's gone now
				pHeader = NULL; // remember that we found it
				break; // stop looping
			} // end if (found pointer)
		} // end for (each allocation)

#ifndef NO_TNCOMMON_DEBUG_SPEW
		if (pHeader != NULL)
		{
			DPL(1, "WARNING: Couldn't find %x (%x) in memory tracking array!",
				2, pHeader, p);
		} // end if (didn't find item in array)
#endif // ! NO_TNCOMMON_DEBUG_SPEW


		g_dwNumOutstandingObjects--;
		g_dwTotalOutstandingBytes -= dwSize;

		/*
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "%u remaining outstanding objects, %u bytes.",
			2, g_dwNumOutstandingObjects, g_dwTotalOutstandingBytes);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/
	} // end else (did free item)


	LeaveCriticalSection(&g_csMem);
#endif // ! NO_CPPOBJHELP_LEAKCHECK
#else // ! DEBUG
	{
	} // end if (couldn't free item)
#endif // ! DEBUG
} // DLLSafeDelete
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\crc32.h ===
#ifndef _INC_CRC32
#define _INC_CRC32

#include <windows.h>


//BEGIN vanceo
//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined
//END vanceo


typedef long            CHECKSUM, *LPCHECKSUM;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

DLLEXPORT CHECKSUM WINAPI GetChecksum(LPVOID, DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _INC_CRC32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\debugprint.h ===
#ifndef __DEBUGPRINT__
#define __DEBUGPRINT__




//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined



// Initialize these to empty strings
#ifndef DEBUG_MODULE
#define DEBUG_MODULE	""
#endif // not DEBUG_MODULE

#ifndef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // not DEBUG_SECTION




//==================================================================================
// Debugging help
//==================================================================================
// You can dump this string from a debugger to get some useful information and
// tips for debugging.
extern char		g_szDebugHelp[];

#ifdef DEBUG
// This points the dynamically allocated debug log help.
extern char*	g_pszDebugLogHelp;
#endif // DEBUG




//==================================================================================
// Useful macros based on some DNet code (which was taken from code by ToddLa)
//==================================================================================
//
// Macros that generate compile time messages.  Use these with #pragma:
//
//	#pragma TODO(vanceo, "Fix this later")
//	#pragma BUGBUG(vanceo, "Busted!")
//	#pragma WAITFORDEVFIX(vanceo, millen, 666, "DPLAY: Broken")
//	#pragma PRINTVALUE(DPERR_SOMETHING)
//
// To turn them off, define TODO_OFF, BUGBUG_OFF, WAITFORDEVFIX_OFF, PRINTVALUE_OFF
// in your project preprocessor defines.
//
//
// If we're building under VC, (you should define BUILDENV_VISUALC), these expand to
// look like:
//
//	D:\directory\file.cpp(101) : BUGBUG: vanceo: Busted!
//
// in your output window, and you should be able to double click on it to jump
// directly to that location (line 101 of D:\directory\file.cpp).
//
// If we're building under the NT build environment, these expand to look like:
//
//	BUGBUG: vanceo: D:\directory\file.cpp(101) : Busted!
//
// because (at least right now) the build process thinks that a failure occurred if
// a message beginning with a filename and line number is printed.  It used to work
// just fine, but who knows.
//

#ifdef BUILDENV_VISUALC
#define __TODO(user, msgstr, n)								message(__FILE__ "(" #n ") : TODO: " #user ": " msgstr)
#define __BUGBUG(user, msgstr, n)							message(__FILE__ "(" #n ") : BUGBUG: " #user ": " msgstr)
#define __WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)	message(__FILE__ "(" #n ") : WAITFORDEVFIX: " #user ": " #bugdb " bug #" #bugnum" : " titlestr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message(__FILE__ "(" #n ") : PRINTVALUE: " itemnamestr " = " itemvaluestr)
#else // ! BUILDENV_VISUALC
#define __TODO(user, msgstr, n)								message("TODO: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __BUGBUG(user, msgstr, n)							message("BUGBUG: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)	message("WAITFORDEVFIX: " #user ": " __FILE__ "(" #n ") : " #bugdb " bug #" #bugnum" : " titlestr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message("PRINTVALUE: " __FILE__ "(" #n ") : " itemnamestr " = " itemvaluestr)
#endif // ! BUILDENV_VISUALC


#define _TODO(user, msgstr, n)								__TODO(user, msgstr, n)
#define _BUGBUG(user, msgstr, n)							__BUGBUG(user, msgstr, n)
#define _WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)	__WAITFORDEVFIX(user, bugdb, bugnum, titlestr, n)
#define _PRINTVALUE(itemstr, item, n)						__PRINTVALUE(itemstr, #item, n)


#ifdef TODO_OFF
#define TODO(user, msgstr)
#else
#define TODO(user, msgstr)									_TODO(user, msgstr, __LINE__)
#endif

#ifdef BUGBUG_OFF
#define BUGBUG(user, msgstr)
#else
#define BUGBUG(user, msgstr)								_BUGBUG(user, msgstr, __LINE__)
#endif

#ifdef WAITFORDEVFIX_OFF
#define WAITFORDEVFIX(user, bugdb, bugnum, titlestr)
#else
#define WAITFORDEVFIX(user, bugdb, bugnum, titlestr)		_WAITFORDEVFIX(user, bugdb, bugnum, titlestr, __LINE__)
#endif

#ifdef PRINTVALUE_OFF
#define PRINTVALUE(item)
#else
#define PRINTVALUE(item)					_PRINTVALUE(#item, item, __LINE__)
#endif



// If debug is specified, these will be functions.  Otherwise, these will simply
// become no-ops.
#ifdef DEBUG


//==================================================================================
// External prototypes when DEBUG is specified
//==================================================================================
DLLEXPORT void TNDebugInitialize(void);

DLLEXPORT void TNDebugCleanup(void);


DLLEXPORT void TNDebugTakeLock(void);

DLLEXPORT void TNDebugDropLock(void);


DLLEXPORT void TNDebugSetDebuggerLogLevel(int iLevelMin, int iLevelMax);


DLLEXPORT void TNDebugStartFileLog(LPTSTR lptszFilepath, LPTSTR lptszHeaderString,
									BOOL fAppend, DWORD dwStartNewFileSize);

DLLEXPORT HRESULT TNDebugGetCurrentFileLogPath(LPTSTR lptszFilepath, DWORD* pdwFilepathSize);

DLLEXPORT void TNDebugEndFileLog(void);

DLLEXPORT void TNDebugSetFileLogLevel(int iLevelMin, int iLevelMax);


DLLEXPORT void TNDebugStartMemoryLog(DWORD dwNumEntries);

DLLEXPORT void TNDebugEndMemoryLog(void);

DLLEXPORT void TNDebugSetMemoryLogLevel(int iLevelMin, int iLevelMax);

DLLEXPORT void TNDebugDumpMemoryLogToFile(LPTSTR lptszFilepath, LPTSTR lptszHeaderString,
										BOOL fAppend);

DLLEXPORT void TNDebugDumpMemoryLogToString(char* szString, DWORD dwStringSize);

DLLEXPORT void TNDebugDisplayNewMemLogEntries(BOOL fToDebuggerIfOn, BOOL fToFileIfOn);


DLLEXPORT void TNDebugInitializeMemLogSharing(LPTSTR tszSharingKey);

DLLEXPORT void TNDebugCleanupMemLogSharing(void);


DLLEXPORT void TNDebugConnectDPlayLogging(void);

DLLEXPORT void TNDebugDisconnectDPlayLogging(void);

DLLEXPORT void TNDebugGrabNewDPlayEntries(void);



DLLEXPORT BOOL TNDebugGetThreadBlockNote(DWORD dwThreadID, LPTSTR lptszModule,
										 LPTSTR lptszSection, LPTSTR lptszFile,
										 int* lpiLineNum, LPTSTR lptszInfoString,
										 DWORD* lpdwNoteAge);



//==================================================================================
// Macros when DEBUG is specified
//==================================================================================
// This is the main macro to use
#define DPL				TNInternalDebugPrepLog(DEBUG_MODULE, DEBUG_SECTION), \
						TNInternalDebugPrintLine

#define DNB(string)		TNInternalDebugNoteBlock(DEBUG_MODULE, DEBUG_SECTION, __FILE__, __LINE__, string)


#ifdef DEBUGBREAK_INT3
  #ifdef _X86_
    #define DEBUGBREAK()	{_asm int 3}
  #else // _X86_
    #pragma message("You can't use int 3 debug breaks on non-x86 builds, defaulting to DebugBreak()!")
    #define DEBUGBREAK()	DebugBreak()
  #endif // _X86_
#else
  #ifdef DEBUGBREAK_OS
    #define DEBUGBREAK()	DebugBreak()
  #else
    #define DEBUGBREAK()	*((DWORD*) (0xDEADDEED)) = 0xBAADD00D
  #endif // DEBUGBREAK_INT3
#endif // DEBUGBREAK_INT3



//==================================================================================
// More prototypes when DEBUG is specified, use macro instead
//==================================================================================
DLLEXPORT void TNInternalDebugPrepLog(LPTSTR lptszModule, LPTSTR lptszSection);

DLLEXPORT void TNInternalDebugPrintLine(int iLevel, LPTSTR lptszFormatString,
										DWORD dwNumParms, ... );

DLLEXPORT void TNInternalDebugNoteBlock(LPTSTR lptszModule, LPTSTR lptszSection,
										LPTSTR lptszFile, int iLineNum,
										LPTSTR lptszInfoString);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
#else // ! DEBUG
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


//==================================================================================
// External prototypes when DEBUG is not specified
//==================================================================================
#define TNDebugInitialize()

#define TNDebugCleanup()


#define TNDebugTakeLock()

#define TNDebugDropLock()

#define TNDebugSetDebuggerLogLevel(iLevelMin, iLevelMax)


#define TNDebugStartFileLog(lptszFilepath, lptszHeaderString, fAppend, dwStartNewFileSize)

// Note that the single = sign is that way on purpose
#define TNDebugGetCurrentFileLogPath(lptszFilepath, pdwFilepathSize)	(((*pdwFilepathSize) = 0) ? ERROR_BAD_ENVIRONMENT : ERROR_BAD_ENVIRONMENT)

#define TNDebugEndFileLog()

#define TNDebugSetFileLogLevel(iLevelMin, iLevelMax)


#define TNDebugStartMemoryLog(dwNumEntries)

#define TNDebugEndMemoryLog()

#define TNDebugSetMemoryLogLevel(iLevelMin, iLevelMax)

#define TNDebugDumpMemoryLogToFile(lptszFilepath, lpszHeaderString, fAppend)

#define TNDebugDumpMemoryLogToString(szString, dwStringSize)

#define TNDebugDisplayNewMemLogEntries(fToDebuggerIfOn, fToFileIfOn)


#define TNDebugInitializeMemLogSharing(tszSharingKey)

#define TNDebugCleanupMemLogSharing()


#define TNDebugConnectDPlayLogging()

#define TNDebugDisconnectDPlayLogging()

#define TNDebugGrabNewDPlayEntries()



#define TNDebugGetThreadBlockNote(dwThreadID, lptszModule, lptszSection, lptszFile,\
								lpiLineNum, lptszInfoString, lpdwNoteAge)				(FALSE)



//==================================================================================
// Macros when DEBUG is not specified
//==================================================================================
#define DPL
	
#define DNB(string)

#define DEBUGBREAK()

#endif // ! DEBUG

#ifdef _XBOX
DLLEXPORT void WINAPI DebugPrint (char *format, ...);
#endif

#endif // __DEBUGPRINT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\debugprint.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <mmsystem.h>

#ifdef _XBOX
#include <stdio.h>
#include <stdlib.h>
#endif

#include "main.h"
#include "cppobjhelp.h"
#include "linklist.h"
#include "linkedstr.h"
#include "sprintf.h"
#include "strutils.h"
#include "fileutils.h"

#include "debugprint.h"


//==================================================================================
// Debugging help
//==================================================================================
#ifdef DEBUG
char	g_szDebugHelp[] =	"Debug help -"
							"  If the pointer at TNCOMMON!g_pszDebugLogHelp is NULL, the memory log is not enabled."
							"  Otherwise, dump the string it points to and follow the instructions to view the debug log.";
char*	g_pszDebugLogHelp = NULL;


#else // ! DEBUG
char	g_szDebugHelp[] =	"Not compiled with debugging support!";
#endif // ! DEBUG






// This file will not contain anything else if DEBUG is not defined
#ifdef DEBUG





//==================================================================================
// Defines
//==================================================================================
#define DEBUGPRINT_SHAREAPI_VERSION			3


#define MAX_MEMORYLOG_STRING_SIZE			512

#define DEBUGLOG_SHARED_MUTEX_PREFIX		"TNCommon Debug Log Shared Mutex"
#define DEBUGLOG_SHARED_MMFILE_PREFIX		"TNCommon Debug Log Shared MM File"

#define DEBUG_SHAREDLOGLOCATION_TNCOMMON	1
#define DEBUG_SHAREDLOGLOCATION_DPLAY		2






//==================================================================================
// Local structures
//==================================================================================
typedef struct tagTNMEMORYLOGENTRY
{
	DWORD	dwLocation; // who generated this entry (see above locations)
	int		iLevel; // spew level of the debug log entry
	DWORD	dwProcessID; // ID of process that submitted the entry
	DWORD	dwThreadID; // ID of thread that submitted the entry
	DWORD	tEntryTime; // time this entry was submitted
	char	szString[MAX_MEMORYLOG_STRING_SIZE]; // actual log entry
} TNMEMORYLOGENTRY, * PTNMEMORYLOGENTRY;

typedef struct tagTNTHREADINFOENTRY
{
	DWORD	dwThreadID; // ID of thread whose info is being maintained
	TCHAR	tszModule[256]; // module the thread was last known to be in
	TCHAR	tszSection[256]; // section the thread was last known to be in
	TCHAR	tszFile[256]; // file the thread was last known to be in
	int		iLineNum; // line number the thread was last known to be in
	TCHAR	tszInfoString[256]; // notes about the block of code the thread was last known to be in
	DWORD	tEntryTime; // time this entry was submitted
} TNTHREADINFOENTRY, * PTNTHREADINFOENTRY;



typedef struct tagDEBUGLOGMMFILEHEADER
{
	DWORD	dwVersion; // debugprint.cpp version that created this MM file
	DWORD	dwRefCount; // number of processes using this MM file
	DWORD	dwGlobalsOffset; // how far into the file the globals start
	DWORD	dwEntriesOffset; // how far into the file the entries start
} DEBUGLOGMMFILEHEADER, * PDEBUGLOGMMFILEHEADER;


typedef struct tagDEBUGLOGMEMORYGLOBALS
{
	DWORD	dwMaxMemoryLogEntries; // total number of entries in (i.e. size of) memory buffer
	int		iMemoryLogLevelMin; // minimum spew level to log to memory
	int		iMemoryLogLevelMax; // minimum spew level to log to memory
	DWORD	dwCurrentMemoryLogIndex; // current index into the memory array
	DWORD	dwEntrySize; // size of each entry; not used, for debugging purposes only
	DWORD	dwEntryNonStringSize; // size of each entry up to the string; not used, for debugging purposes only
	DWORD	dwCurrentEntryOffset; // offset of current entry; not used, for debugging purposes only
} DEBUGLOGMEMORYGLOBALS, * PDEBUGLOGMEMORYGLOBALS;



// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// From DPlay, with DPLAY prepended on items not starting with DPLAY or DP

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define DPLAYBASE_LOG_FILENAME  "DPLAYLOG-0"
#define DPLAYBASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(DPLAYSHARED_LOG_FILE)+((sizeof(DPLAYLOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _DPLAYSHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}DPLAYSHARED_LOG_FILE, *PDPLAYSHARED_LOG_FILE;

typedef struct _DPLAYLOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	//CHAR	str[0]; // commented out because it's not used directly and compiler barfs anyway
} DPLAYLOG_ENTRY, *PDPLAYLOG_ENTRY;

#endif // _DPLAY_SHARED_MEMLOG_
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -





//==================================================================================
// Instance-specific globals
//==================================================================================
DWORD				g_dwTNDebugRefcount = 0;
HANDLE				g_hLocalMutex = NULL;
TCHAR				g_tszModule[256];
TCHAR				g_tszSection[256];
TNTHREADINFOENTRY	g_aThreadInfos[128];
DWORD				g_dwNumThreadInfos = 0;

BOOL				g_fLogToDebugger = TRUE; // should we log to the debugger/terminal?
int					g_iDebuggerLogLevelMin = 0; // minimum spew level to log to the debugger/terminal
int					g_iDebuggerLogLevelMax = 0; // maximum spew level to log to the debugger/terminal

HANDLE				g_hFile = INVALID_HANDLE_VALUE; // handle to file to log to
TCHAR*				g_ptszCurrentFilepath = NULL; // name of current file path logging to
TCHAR*				g_ptszHeader = NULL; // header string for file
BOOL				g_fAppend = FALSE; // whether to append to files or not
DWORD				g_dwMaxFileSize = 0; // maximum size a file is allowed to grow to
int					g_iFileLogLevelMin = 0; // minimum spew level to log to the file
int					g_iFileLogLevelMax = 9; // maximum spew level to log to the file
DWORD				g_tTimeFileLastEntry = 0; // time the last entry was made

PTNMEMORYLOGENTRY	g_paLocalMemoryLog = NULL;

HANDLE				g_hSharedMutex = NULL;
HANDLE				g_hMemLogMMFile = NULL;
HANDLE				g_hMemLogView = NULL;
DWORD				g_dwLastMemLogIndex = 0;

HANDLE				g_hDPlayLogMutex = NULL;
HANDLE				g_hDPlayLogMMFile = NULL;
HANDLE				g_hDPlayLogView = NULL;
LPBYTE				g_lpDPlayLog = NULL;
DWORD				g_dwDPlayLastIndex = 0;


// These are the defaults to start up memory logging with.  This is used until
// TNDebugInitializeMemLogSharing (which is completely optional) is called.
DEBUGLOGMEMORYGLOBALS		g_defaultMemLogGlobals =
{
	0,															// dwMaxMemoryLogEntries
	0,															// iMemoryLogLevelMin
	9,															// iMemoryLogLevelMax
	0,															// dwCurrentMemoryLogIndex
	sizeof (TNMEMORYLOGENTRY),									// dwEntrySize
	(DWORD_PTR) (&(((PTNMEMORYLOGENTRY) (0x00000000))->szString)),	// dwEntryNonStringSize
	0															// dwCurrentEntryOffset
};

// These pointers may be local or shared, so don't try to free them, but they
// start off as local.
PDEBUGLOGMEMORYGLOBALS		g_pMemLogGlobals = &g_defaultMemLogGlobals;
PTNMEMORYLOGENTRY			g_paTNMemoryLog = g_paLocalMemoryLog;




//==================================================================================
// Local Prototypes
//==================================================================================
void BuildDebugLogHelpString(void);




//==================================================================================
// TNDebugInitialize
//----------------------------------------------------------------------------------
//
// Description: Initializes debug log functionality.  Must be called before any
//				other TNDebug functions are used.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugInitialize(void)
{
	DWORD	dwNewRefcount;


	//BUGBUG according to MSDN, this won't necessarily work on Win95, because "if
	//		 the result of the operation is greater than zero, the return value is
	//		 positive, but it is not necessarily equal to the result".
	dwNewRefcount = InterlockedIncrement((LPLONG) &g_dwTNDebugRefcount);

	// If this process has already initialized TNDebug at least once, we're done.
	if (dwNewRefcount > 1)
		return;

	// Otherwise, we're the first caller, set up the stuff we need.

	g_hLocalMutex = CreateMutex(NULL, TRUE, NULL);
	if (g_hLocalMutex == NULL)
	{
		OutputDebugString("Couldn't create/open debug log local mutex!\n");
		dwNewRefcount--; // should bring us back to 0
		//BUGBUG no way for caller to know this failed
		return;
	} // end if (couldn't create the mutex)


	//BUGBUG theoretically, a thread could enter this, increment to 1, get
	//		 preempted, while a separate thread sees that he doesn't need to init,
	//		 and tries to use the mutex before the first thread actually
	//		 finished creating it... 


	// Just ensure that it's initted, because we use it a lot.
	TNsprintfInitialize();

	ZeroMemory(g_tszModule, 256);
	ZeroMemory(g_tszSection, 256);
	ZeroMemory(g_aThreadInfos, 128 * sizeof (TNTHREADINFOENTRY));
	g_dwNumThreadInfos = 0;

	g_hMemLogMMFile = NULL;
	g_hMemLogView = NULL;

	// We took ownership of the mutex when we created it, so release it now
	ReleaseMutex(g_hLocalMutex);
} // TNDebugInitialize





//==================================================================================
// TNDebugCleanup
//----------------------------------------------------------------------------------
//
// Description: Cleans up debug log functionality.  Must be called for each call
//				to TNDebugInitialize.  Last caller in the process shuts down debug
//				log sharing, file, and memory logs if they were running.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugCleanup(void)
{
	// BUGBUG if someone calls Initialize while we're inside the final cleanup code,
	//		  they will get hosed.


	// We take the lock to make sure two people don't try (or nobody tries) to
	// do the final cleanup code.  Theoretically, we don't need to hold the lock for
	// the entire function, (since if we got that far, we'd be the only thread left
	// using it, but oh well)
	WaitForSingleObject(g_hLocalMutex, INFINITE); // ignore return value

	// If this process still has more users of TNDebug functions, we're done.
	if (g_dwTNDebugRefcount > 1)
	{
		g_dwTNDebugRefcount--;
		ReleaseMutex(g_hLocalMutex);
		return;
	} // end if (we're not the last one to use the function)


	// Otherwise, shut down the stuff that was in use.

	// If file logging was on, end it
	if (g_hFile != INVALID_HANDLE_VALUE)
		TNDebugEndFileLog();

	// If memory logging was on, end it
	if (g_paTNMemoryLog != NULL)
		TNDebugEndMemoryLog();

	// Balance our initialize call.
	TNsprintfCleanup();


	g_dwTNDebugRefcount--; // should be 0 after this
	if (g_dwTNDebugRefcount != 0)
	{
		OutputDebugString("Debug log refcount is screwed!\n");
		DEBUGBREAK();
	} // end if (refcount is screwed)

	ReleaseMutex(g_hLocalMutex);

	CloseHandle(g_hLocalMutex);
	g_hLocalMutex = NULL;
} // TNDebugCleanup






//==================================================================================
// TNDebugTakeLock
//----------------------------------------------------------------------------------
//
// Description: Prevents other threads (and processes, if sharing the memory debug
//				log) from printing anything to the debug log until TNDebugDropLock
//				is called by this thread.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugTakeLock(void)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Take both locks if we're sharing the log.
	if (g_hSharedMutex != NULL)
	{
		HANDLE	ahWaitObjects[3];


		//BUGBUG The mutexes could be closed between now and the WaitForMultipleObjects call.
		//		 Duplicate handles?
		ahWaitObjects[0] = g_hLocalMutex;
		ahWaitObjects[1] = g_hSharedMutex;
		ahWaitObjects[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this will cause it to rewalk the array

		WaitForMultipleObjects(2, ahWaitObjects, TRUE, INFINITE);
	} // end if (sharing the log)
	else
		WaitForSingleObject(g_hLocalMutex, INFINITE);
} // TNDebugTakeLock



//==================================================================================
// TNDebugDropLock
//----------------------------------------------------------------------------------
//
// Description: Releases other threads (and processes, if sharing the memory debug
//				log) to print to the debug log after a previous TNDebugTakeLock
//				call.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugDropLock(void)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Drop the sharing lock if it's there.
	if (g_hSharedMutex != NULL)
		ReleaseMutex(g_hSharedMutex);

	ReleaseMutex(g_hLocalMutex);
} // TNDebugDropLock




//==================================================================================
// TNDebugSetDebuggerLogLevel
//----------------------------------------------------------------------------------
//
// Description: Sets the minimum and maximum levels of spew that are output to the
//				debugger.
//
// Arguments:
//	int iLevelMin	Minimum spew level to print.
//	int iLevelMax	Maximum spew level to print.
//
// Returns: None.
//==================================================================================
void TNDebugSetDebuggerLogLevel(int iLevelMin, int iLevelMax)
{
	g_iDebuggerLogLevelMin = iLevelMin;
	g_iDebuggerLogLevelMax = iLevelMax;
} // TNDebugSetDebuggerLogLevel




#ifndef _XBOX // no file logging
//==================================================================================
// TNDebugStartFileLog
//----------------------------------------------------------------------------------
//
// Description: Starts logging to the file specified.  If specified the header is
//				written to the file.
//
// Arguments:
//	LPTSTR lptszFilepath		Path to file to log to.
//	LPTSTR lptszHeaderString	Pointer to optional header string to place above
//								file, or NULL for none.
//	BOOL fAppend				Whether to append to the file or overwrite if it
//								already exists.
//	DWORD dwStartNewFileSize	If the the file reaches this size (in bytes), then a
//								new file with a sequential number is started.  Note
//								that this is approximate, since a new file will only
//								be started after a line break.
//
// Returns: None.
//==================================================================================
void TNDebugStartFileLog(LPTSTR lptszFilepath, LPTSTR lptszHeaderString,
						BOOL fAppend, DWORD dwStartNewFileSize)
{
	HRESULT		hr;
	TCHAR		tszTemp[1024];
	DWORD		dwSize;
	int			iPos;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Take the local lock, ignoring return value
	WaitForSingleObject(g_hLocalMutex, INFINITE);


	if (g_hFile != INVALID_HANDLE_VALUE)
	{
		OutputDebugString("Previously logging debug strings to a file; closing that and opening new file.\n");
		TNDebugEndFileLog();
	} // end if (already started logging)



	// Ignore error, assume BUFFER_TOO_SMALL
	FileGetRealFilePath(lptszFilepath, FALSE, NULL, &dwSize);

	// If we could possibly split the log, make room for an order indicator.
	if (dwStartNewFileSize > 0)
		dwSize += 2 * sizeof (TCHAR); // + "_1"

	g_ptszCurrentFilepath = (TCHAR*) LocalAlloc(LPTR, dwSize);
	if (g_ptszCurrentFilepath == NULL)
	{
		ReleaseMutex(g_hLocalMutex);
		return;
	} // end if (couldn't allocate memory)

	hr = FileGetRealFilePath(lptszFilepath, FALSE, g_ptszCurrentFilepath, &dwSize);
	if (hr != S_OK)
	{
		wsprintf(tszTemp, "Couldn't get real file path of \"%s\"!  hr = 0x%08x\n",
				lptszFilepath, hr);
		OutputDebugString(tszTemp);
		LocalFree(g_ptszCurrentFilepath);
		g_ptszCurrentFilepath = NULL;
		ReleaseMutex(g_hLocalMutex);
		return;
	} // end if (couldn't get real file path)

	// If we could possibly split the log, tack on an order indicator.
	if (dwStartNewFileSize > 0)
	{
		// Move back to the end of the string
		iPos = strlen(g_ptszCurrentFilepath) - 1;

		// Loop backward until we find the start of the extension
		while (g_ptszCurrentFilepath[iPos] != '.')
		{
			iPos--;

			// If we hit the beginning of the file path or the file name, then
			// there is no extension.
			if ((iPos == 0) || (g_ptszCurrentFilepath[iPos] == '\\'))
				iPos = strlen(g_ptszCurrentFilepath);
		} // end while (haven't found extension)

		// Save the extension
		strcpy(tszTemp, g_ptszCurrentFilepath + iPos);

		// Set the string to end in "_1".
		g_ptszCurrentFilepath[iPos++] = '_';
		g_ptszCurrentFilepath[iPos++] = '1';
		g_ptszCurrentFilepath[iPos++] = '\0';

		// Restore the extension
		strcat(g_ptszCurrentFilepath, tszTemp);
	} // end if (we may split the file)



	if (lptszHeaderString != NULL)
	{
		g_ptszHeader = (TCHAR*) LocalAlloc(LPTR, (strlen(lptszHeaderString) + 1) * (sizeof (TCHAR)));
		if (g_ptszHeader == NULL)
		{
			LocalFree(g_ptszCurrentFilepath);
			g_ptszCurrentFilepath = NULL;
			ReleaseMutex(g_hLocalMutex);
			return;
		} // end if (couldn't allocate memory)
		strcpy(g_ptszHeader, lptszHeaderString);
	} // end if (there's a header string)


	g_dwMaxFileSize = dwStartNewFileSize;
	g_fAppend = fAppend;


	hr = FileCreateAndOpenFile(g_ptszCurrentFilepath, FALSE, g_fAppend, FALSE, &g_hFile);
	if (hr != S_OK)
	{
		wsprintf(tszTemp, "Couldn't create debug log file \"%s\"!  hr = 0x%08x\n",
				g_ptszCurrentFilepath, hr);
		OutputDebugString(tszTemp);
		LocalFree(g_ptszCurrentFilepath);
		g_ptszCurrentFilepath = NULL;
		ReleaseMutex(g_hLocalMutex);
		return;
	} // end if (couldn't create file)


	if (g_ptszHeader != NULL)
	{
		FileWriteLine(g_hFile, "//==================================================================================");
		FileSprintfWriteLine(g_hFile, "// %s", 1, g_ptszHeader);
		FileWriteLine(g_hFile, "//");

		FileWriteLine(g_hFile, "// Debug log file part 1");

		StringGetCurrentDateStr(tszTemp);
		StringPrepend(tszTemp, "// Begins ");
		FileWriteLine(g_hFile, tszTemp);

		FileSprintfWriteLine(g_hFile, "// Current process is %x, current thread is %x",
							2, GetCurrentProcessId(), GetCurrentThreadId());
		FileWriteLine(g_hFile, "//==================================================================================");
	} // end if (have header string to display)


#ifndef _XBOX // timeGetTime not supported
	g_tTimeFileLastEntry = timeGetTime();
#else // ! XBOX
	g_tTimeFileLastEntry = GetTickCount();
#endif // XBOX

	ReleaseMutex(g_hLocalMutex);
} // TNDebugStartFileLog
#endif // ! XBOX



//==================================================================================
// TNDebugGetCurrentFileLogPath
//----------------------------------------------------------------------------------
//
// Description: Retrieves the current path the debug log output is being written to,
//				or ERROR_NOT_READY if output is not currently going to a file.
//				If lptszFilepath is NULL, then the size of the buffer required
//				(including NULL termination) is stored in pdwFilepathSize and
//				ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	LPTSTR lptszFilepath	Buffer to store file path, or NULL to retrieve size
//							required.
//	DWORD* pdwFilepathSize	Pointer to size of previous buffer, or place to store
//							size required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNDebugGetCurrentFileLogPath(LPTSTR lptszFilepath, DWORD* pdwFilepathSize)
{
	HRESULT		hr;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return (ERROR_NOT_READY);
	} // end if (not initialized)


	// Take the local lock, ignoring return value
	WaitForSingleObject(g_hLocalMutex, INFINITE);

	if (g_hFile == INVALID_HANDLE_VALUE)
	{
		hr = ERROR_NOT_READY;
		goto DONE;
	} // end if (already started logging)

	if (lptszFilepath == NULL)
	{
		(*pdwFilepathSize) = strlen(g_ptszCurrentFilepath) + 1;
		hr = ERROR_BUFFER_TOO_SMALL;
	} // end if (retrieving size)
	else
	{
		strcpy(lptszFilepath, g_ptszCurrentFilepath);
		hr = S_OK;
	} // end else (getting actual path)


DONE:

	ReleaseMutex(g_hLocalMutex);

	return (hr);
} // TNDebugGetCurrentFileLogPath




//==================================================================================
// TNDebugEndFileLog
//----------------------------------------------------------------------------------
//
// Description: Stops logging to a file.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugEndFileLog(void)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Take the local lock, ignoring return value
	WaitForSingleObject(g_hLocalMutex, INFINITE);
	
	if (g_hFile != INVALID_HANDLE_VALUE)
	{
		if (! CloseHandle(g_hFile))
		{
			OutputDebugString("Couldn't close debug log file!");
		} // end if (couldn't close file)

		g_hFile = INVALID_HANDLE_VALUE;
	} // end if (already started logging)

	if (g_ptszCurrentFilepath != NULL)
	{
		LocalFree(g_ptszCurrentFilepath);
		g_ptszCurrentFilepath = NULL;
	} // end if (there's a filepath)

	if (g_ptszHeader != NULL)
	{
		LocalFree(g_ptszHeader);
		g_ptszHeader = NULL;
	} // end if (there's a filepath)

	g_dwMaxFileSize = 0;

	ReleaseMutex(g_hLocalMutex);
} // TNDebugEndFileLog




//==================================================================================
// TNDebugSetFileLogLevel
//----------------------------------------------------------------------------------
//
// Description: Sets the minimum and maximum levels of spew that are output to the
//				file.
//
// Arguments:
//	int iLevelMin	Minimum spew level to print.
//	int iLevelMax	Maximum spew level to print.
//
// Returns: None.
//==================================================================================
void TNDebugSetFileLogLevel(int iLevelMin, int iLevelMax)
{
	g_iFileLogLevelMin = iLevelMin;
	g_iFileLogLevelMax = iLevelMax;
} // TNDebugSetFileLogLevel





//==================================================================================
// TNDebugStartMemoryLog
//----------------------------------------------------------------------------------
//
// Description: Starts logging to the file specified.  If it already was logging,
//				the log is recreated from scratch.
//
// Arguments:
//	DWORD dwNumEntries		Number of entries to save.
//
// Returns: None.
//==================================================================================
void TNDebugStartMemoryLog(DWORD dwNumEntries)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)

	// Take the local lock, ignoring return value
	WaitForSingleObject(g_hLocalMutex, INFINITE);
	
	if (g_paLocalMemoryLog != NULL)
	{
		OutputDebugString("Previously logging debug strings to memory; freeing that and starting new memory log.\n");
		TNDebugEndMemoryLog();
	} // end if (already started logging)

	g_pMemLogGlobals->dwMaxMemoryLogEntries = dwNumEntries;
	g_pMemLogGlobals->dwCurrentMemoryLogIndex = 0;
	g_pMemLogGlobals->dwEntrySize = sizeof (TNMEMORYLOGENTRY);
	g_pMemLogGlobals->dwCurrentEntryOffset = 0;

	g_paLocalMemoryLog = (PTNMEMORYLOGENTRY) LocalAlloc(LPTR, dwNumEntries * sizeof (TNMEMORYLOGENTRY));
	g_paTNMemoryLog = g_paLocalMemoryLog;

	// If we can't allocate memory, we won't warn but we also won't do anything
	// further.
	if (g_paLocalMemoryLog != NULL)
	{
		BuildDebugLogHelpString();
	} // end if (allocated memory)


	ReleaseMutex(g_hLocalMutex);
} // TNDebugStartMemoryLog



//==================================================================================
// TNDebugEndMemoryLog
//----------------------------------------------------------------------------------
//
// Description: Stops logging to memory.  If the memory log is being shared, this
//				is terminated as well.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugEndMemoryLog(void)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// If we were connected to the DPlay log, disconnect.
	if (g_hMemLogView != NULL)
	{
		TNDebugDisconnectDPlayLogging();
	} // end if (sharing the DPlay log)


#ifndef _XBOX // no IPC supported, no need to share memory
	// If we were sharing the memory log, stop that.
	if (g_hMemLogView != NULL)
	{
		TNDebugCleanupMemLogSharing();
	} // end if (sharing the memory log)
#endif // ! XBOX

	// Take the local lock, ignoring return value
	WaitForSingleObject(g_hLocalMutex, INFINITE);


	if (g_paLocalMemoryLog != NULL)
	{
		LocalFree(g_paLocalMemoryLog);
		g_paLocalMemoryLog = NULL;
	} // end if (started logging)

	g_paTNMemoryLog = NULL;

	// Destroy the debug log help string, if we had it.
	if (g_pszDebugLogHelp != NULL)
	{
		LocalFree(g_pszDebugLogHelp);
		g_pszDebugLogHelp = NULL;
	} // end if (already have string)

	ReleaseMutex(g_hLocalMutex);
} // TNDebugEndMemoryLog



//==================================================================================
// TNDebugSetMemoryLogLevel
//----------------------------------------------------------------------------------
//
// Description: Sets the minimum and maximum levels of spew that are output to
//				memory.
//
// Arguments:
//	int iLevelMin	Minimum spew level to print.
//	int iLevelMax	Maximum spew level to print.
//
// Returns: None.
//==================================================================================
void TNDebugSetMemoryLogLevel(int iLevelMin, int iLevelMax)
{
	g_pMemLogGlobals->iMemoryLogLevelMin = iLevelMin;
	g_pMemLogGlobals->iMemoryLogLevelMax = iLevelMax;
} // TNDebugSetMemoryLogLevel





#ifndef _XBOX // no dumping files
//==================================================================================
// TNDebugDumpMemoryLogToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the current contents of the memory log (local or shared) to
//				the file specified.  If specified, the header is written to the
//				file.
//
// Arguments:
//	LPTSTR lptszFilepath		Path to dump current contents to.
//	LPTSTR lptszHeaderString	Pointer to optional header string to place above
//								file, or NULL for none.
//	BOOL fAppend				Whether to overwrite the file if it exists already.
//
// Returns: None.
//==================================================================================
void TNDebugDumpMemoryLogToFile(LPTSTR lptszFilepath, LPTSTR lptszHeaderString,
								BOOL fAppend)
{
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	DWORD		dwTemp;
	BOOL		fOneLine = FALSE;
	DWORD		tPreviousEntryTime = 0;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Take the locks
	TNDebugTakeLock();

	
	if (g_paTNMemoryLog == NULL)
	{
		OutputDebugString("Not currently logging debug strings to memory, ignoring call to DumpMemoryLogToFile.\n");
		goto DONE;
	} // end if (didn't start logging)


	hr = FileCreateAndOpenFile(lptszFilepath, FALSE, fAppend, FALSE, &hFile);
	if (hr != S_OK)
	{
		OutputDebugString("Failed creating/opening file to dump memory log!\n");
		goto DONE;
	} // end if (couldn't create file)


	if (lptszHeaderString != NULL)
	{
		FileWriteLine(hFile, "//==================================================================================");
		FileSprintfWriteLine(hFile, "// %s", 1, lptszHeaderString);
		FileSprintfWriteLine(hFile, "// Current process is %x, current thread is %x",
							2, GetCurrentProcessId(), GetCurrentThreadId());
		FileWriteLine(hFile, "//==================================================================================");
	} // end if (have header string to display)


	// Pull in any new entries from the DPlay log, if we're doing that.
	if (g_hDPlayLogView != NULL)
	{
		TNDebugGrabNewDPlayEntries();
	} // end if (sharing the DPlay log)
	

	dwTemp = g_pMemLogGlobals->dwCurrentMemoryLogIndex;

	do
	{
		if (strcmp(g_paTNMemoryLog[dwTemp].szString, "") != 0)
		{
			// Ignore errors.  Time printed as an integer to handle negative numbers.
			FileSprintfWriteString(hFile, "%u\t%x\t%x\t%u\t%i\t",
								5, dwTemp,
								g_paTNMemoryLog[dwTemp].dwProcessID,
								g_paTNMemoryLog[dwTemp].dwThreadID,
								g_paTNMemoryLog[dwTemp].tEntryTime,
								(g_paTNMemoryLog[dwTemp].tEntryTime - tPreviousEntryTime));

			tPreviousEntryTime = g_paTNMemoryLog[dwTemp].tEntryTime;

			if (g_paTNMemoryLog[dwTemp].dwLocation == DEBUG_SHAREDLOGLOCATION_DPLAY)
			{
				FileWriteString(hFile, "DP: ");
			} // end if (this log entry came from DPlay)

			FileWriteLine(hFile, g_paTNMemoryLog[dwTemp].szString);

			fOneLine = TRUE;
		} // end if (theres a valid string to dump)

		dwTemp++;

		if (dwTemp >= g_pMemLogGlobals->dwMaxMemoryLogEntries)
			dwTemp = 0;
	} // end do (while we haven't wrapped back to where we started)
	while (dwTemp != g_pMemLogGlobals->dwCurrentMemoryLogIndex);

	if (! fOneLine)
		FileWriteLine(hFile, "// No log entries.");


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (we had a file open)

	TNDebugDropLock();
} // TNDebugDumpMemoryLogToFile
#endif ! XBOX


//==================================================================================
// TNDebugDumpMemoryLogToString
//----------------------------------------------------------------------------------
//
// Description: Copies the current contents of the memory log (local or shared) to
//				the string passed in.  If the buffer is too small (dwStringSize is
//				reached), only the most recent entries that can completely fit in
//				the buffer are stored.
//				Entries are separated by newlines ('\n').
//
// Arguments:
//	char* szString			Pointer to buffer to place memory log into.
//	DWORD dwStringSize		How large the buffer is (including room for NULL
//							termination).
//
// Returns: None.
//==================================================================================
void TNDebugDumpMemoryLogToString(char* szString, DWORD dwStringSize)
{
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Here's a little macro for us
	#define CHKANDDUMPSTR(string, size)		if (size > dwStringSize)\
												break;\
											\
											pszCurrent -= size;\
											CopyMemory(pszCurrent, string, size);\
											dwStringSize -= size;
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	DWORD	dwTemp;
	TCHAR	tszNumber[32];
	char*	pszCurrent;
	char*	pszLastFullLine;
	DWORD	tPreviousEntryTime;



	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Take the locks
	TNDebugTakeLock();

	
	if (g_paTNMemoryLog == NULL)
	{
		OutputDebugString("Not currently logging debug strings to memory, ignoring call to DumpMemoryLogToString.\n");
		goto DONE;
	} // end if (didn't start logging)


	// Pull in any new entries from the DPlay log, if we're doing that
	if (g_hDPlayLogView != NULL)
	{
		TNDebugGrabNewDPlayEntries();
	} // end if (sharing the DPlay log)


	dwTemp = g_pMemLogGlobals->dwCurrentMemoryLogIndex - 1;

	// Start at the end of the buffer (with enough room for the NULL termination).
	dwStringSize--;
	pszCurrent = szString + dwStringSize;

	do
	{
		// Wherever we are right now, it must have fit into the buffer (or else we
		// wouldn't be here, duh).  So this is the last known valid spot to start
		// the string.
		pszLastFullLine = pszCurrent;


		// We dump everything backwards so when we hit our head on the buffer
		// limit, we can just slide the last complete line down to the start
		// of the string buffer.

		CHKANDDUMPSTR("\n", 1);

		CHKANDDUMPSTR(g_paTNMemoryLog[dwTemp].szString,
					strlen(g_paTNMemoryLog[dwTemp].szString));

		if (g_paTNMemoryLog[dwTemp].dwLocation == DEBUG_SHAREDLOGLOCATION_DPLAY)
		{
			CHKANDDUMPSTR("DP: ", 4);
		} // end if (this log entry came from DPlay)

		if (dwTemp > 0)
			tPreviousEntryTime = g_paTNMemoryLog[dwTemp - 1].tEntryTime;
		else
			tPreviousEntryTime = g_paTNMemoryLog[g_pMemLogGlobals->dwMaxMemoryLogEntries].tEntryTime;

		// Time printed as an integer to handle negative numbers.
		wsprintf(tszNumber, "%i\t", (g_paTNMemoryLog[dwTemp].tEntryTime - tPreviousEntryTime));
		CHKANDDUMPSTR(tszNumber, strlen(tszNumber));

		wsprintf(tszNumber, "%u\t", g_paTNMemoryLog[dwTemp].tEntryTime);
		CHKANDDUMPSTR(tszNumber, strlen(tszNumber));

		wsprintf(tszNumber, "0x%08x\t", g_paTNMemoryLog[dwTemp].dwThreadID);
		CHKANDDUMPSTR(tszNumber, strlen(tszNumber));

		wsprintf(tszNumber, "0x%08x\t", g_paTNMemoryLog[dwTemp].dwProcessID);
		CHKANDDUMPSTR(tszNumber, strlen(tszNumber));

		wsprintf(tszNumber, "%i\t", dwTemp);
		CHKANDDUMPSTR(tszNumber, strlen(tszNumber));

		if (dwTemp == 0)
			dwTemp = g_pMemLogGlobals->dwMaxMemoryLogEntries;
		else
			dwTemp--;

	} // end do (while we haven't wrapped back to where we started)
	while (dwTemp != (g_pMemLogGlobals->dwCurrentMemoryLogIndex - 1));

	// Shuffle everything down to the front of the string if it's not there already
	if (pszLastFullLine > szString)
		strcpy(szString, pszLastFullLine);


DONE:

	TNDebugDropLock();

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#undef CHKANDDUMPSTR
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
} // TNDebugDumpMemoryLogToString




//==================================================================================
// TNDebugDisplayNewMemLogEntries
//----------------------------------------------------------------------------------
//
// Description: Displays any items in the shared memory debug log that have been
//				entered since the last time this function was called (via another
//				process that's sharing the log, or DPlay connection, etc).  This
//				does not include any items that were printed to the memory log
//				locally.
//				The items are printed to the other debug log modes (if they are
//				running) according to the booleans passed in.
//
// Arguments:
//	BOOL fToDebuggerIfOn	The items will be printed to the debugger assuming the
//							level is correct and debugger logging is on.
//	BOOL fToFileIfOn		The items will be printed to the file assuming the
//							level is correct and file logging is on.
//
// Returns: None.
//==================================================================================
void TNDebugDisplayNewMemLogEntries(BOOL fToDebuggerIfOn, BOOL fToFileIfOn)
{
	DWORD	dwTemp;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)

	//BUGBUG these (and all other calls like them) should be inside the lock grab.
	if (g_paTNMemoryLog == NULL)
	{
		OutputDebugString("Memory debug log not initialized.\n");
		return;
	} // end if (mem log not initialized)


	// Grab our locks
	TNDebugTakeLock();


	//BUGBUG it's possible to wrap around to the exact same spot, and we'd miss
	//		 every single one of those entries
	if (g_dwLastMemLogIndex != g_pMemLogGlobals->dwCurrentMemoryLogIndex)
	{
		dwTemp = g_dwLastMemLogIndex;
		do
		{
			if (strcmp(g_paTNMemoryLog[dwTemp].szString, "") != 0)
			{
				// If debugger logging is on, and we should print to the debugger,
				// and the level is unknown or within the debugger logging
				// boundaries, print it.
				if ((g_fLogToDebugger) && (fToDebuggerIfOn) &&
					((g_paTNMemoryLog[dwTemp].iLevel == -1) ||
						((g_paTNMemoryLog[dwTemp].iLevel >= g_iDebuggerLogLevelMin) &&
						(g_paTNMemoryLog[dwTemp].iLevel <= g_iDebuggerLogLevelMax))))
				{
					// From experience it seems we may need to allow a little time
					// so that we don't flood the debugger.
					//Sleep(10);

					OutputDebugString("$$\t");

					if (g_paTNMemoryLog[dwTemp].dwLocation == DEBUG_SHAREDLOGLOCATION_DPLAY)
						OutputDebugString("DP: ");

					OutputDebugString(g_paTNMemoryLog[dwTemp].szString);
					OutputDebugString("\n");
				} // end if (should and can print to terminal)

				// If file logging is on, and we should print to the file, and the
				// level is unknown or within the file logging boundaries, print it.
				if ((g_hFile != INVALID_HANDLE_VALUE) && (fToFileIfOn) &&
					((g_paTNMemoryLog[dwTemp].iLevel == -1) ||
						((g_paTNMemoryLog[dwTemp].iLevel >= g_iFileLogLevelMin) &&
						(g_paTNMemoryLog[dwTemp].iLevel <= g_iFileLogLevelMax))))
				{
					// Ignore errors.  Time printed as an integer to handle negative numbers.
					FileSprintfWriteString(g_hFile, "%x\t%x\t%u\t%i\t",
										4, g_paTNMemoryLog[dwTemp].dwProcessID,
										g_paTNMemoryLog[dwTemp].dwThreadID,
										g_paTNMemoryLog[dwTemp].tEntryTime,
										(g_paTNMemoryLog[dwTemp].tEntryTime - g_tTimeFileLastEntry));

					g_tTimeFileLastEntry = g_paTNMemoryLog[dwTemp].tEntryTime;

					if (g_paTNMemoryLog[dwTemp].dwLocation == DEBUG_SHAREDLOGLOCATION_DPLAY)
					{
						FileWriteString(g_hFile, "DP: ");
					} // end if (this log entry came from DPlay)

					FileWriteLine(g_hFile, g_paTNMemoryLog[dwTemp].szString);
				} // end if (should and can print to file)
			} // end if (theres a valid string to dump)

			dwTemp++;

			if (dwTemp >= g_pMemLogGlobals->dwMaxMemoryLogEntries)
				dwTemp = 0;
		} // end do (while we haven't wrapped back to where we started)
		while (dwTemp != g_pMemLogGlobals->dwCurrentMemoryLogIndex);

		// Okay, we're up to date.
		g_dwLastMemLogIndex = g_pMemLogGlobals->dwCurrentMemoryLogIndex;
	} // end if (the DPlay log has been updated)
	/*
	else
	{
		OutputDebugString("\tNo updates to DPlay log.\n");
	} // end else (no updates to DPlay log)
	*/

	// Drop our locks
	TNDebugDropLock();
} // TNDebugDisplayNewMemLogEntries




#ifndef _XBOX // no IPC supported, no need to share memory
//==================================================================================
// TNDebugInitializeMemLogSharing
//----------------------------------------------------------------------------------
//
// Description: Sets up memory for inter-process sharing of the memory debug log.
//				TNDebugStartMemoryLog must have been called previously.
//				If a log with the same sharing key was already being shared by
//				another process, then it is used and whatever settings it has
//				override the current mem log settings.
//
// Arguments:
//	LPTSTR tszSharingKey	Key to use for sharing.
//
// Returns: None.
//==================================================================================
void TNDebugInitializeMemLogSharing(LPTSTR tszSharingKey)
{
	TCHAR					tszTemp[1024];
	PDEBUGLOGMMFILEHEADER	pHeader = NULL;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)

	if (g_paTNMemoryLog == NULL)
	{
		OutputDebugString("Memory debug log not initialized.\n");
		return;
	} // end if (not mem log initialized)

	if ((g_hMemLogMMFile != NULL) || (g_hMemLogView != NULL))
	{
		OutputDebugString("Debug sharing already initialized, restarting.\n");

		TNDebugCleanupMemLogSharing();
	} // end if (already initialized)

	if (tszSharingKey == NULL)
	{
		OutputDebugString("Can't pass in NULL string!\n");
		return;
	} // end if (not mem log initialized)


	// Build the shared mutex name
	wsprintf(tszTemp, "%s - %s", DEBUGLOG_SHARED_MUTEX_PREFIX, tszSharingKey);

	// Get the local lock, ignoring return value
	WaitForSingleObject(g_hLocalMutex, INFINITE);


	// Create the shared mutex, or open it if it already exists
	g_hSharedMutex = CreateMutex(NULL, FALSE, tszTemp);
	if (g_hSharedMutex == NULL)
	{
		ReleaseMutex(g_hLocalMutex);
		OutputDebugString("Couldn't create/open debug log shared mutex!\n");
		return;
	} // end if (couldn't create/open the mutex)
	

	// Build the shared memory mapping name
	wsprintf(tszTemp, "%s - %s", DEBUGLOG_SHARED_MMFILE_PREFIX, tszSharingKey);

	//BUGBUG load globals then resize mapping to hold all, or init if 0

	// Create the file mapping object, or open it if it already exists
	g_hMemLogMMFile = CreateFileMapping(INVALID_HANDLE_VALUE,
										NULL,
										PAGE_READWRITE,
										0,
										(sizeof (DEBUGLOGMMFILEHEADER) + sizeof (DEBUGLOGMEMORYGLOBALS) + (g_pMemLogGlobals->dwMaxMemoryLogEntries * sizeof (TNMEMORYLOGENTRY))),
										tszTemp);
	if (g_hMemLogMMFile == NULL)
	{
		CloseHandle(g_hSharedMutex);
		g_hSharedMutex = NULL;
		ReleaseMutex(g_hLocalMutex);
		OutputDebugString("Couldn't create debug log globals memory mapped file!\n");
		return;
	} // end if (couldn't create new file mapping)


	// Get the shared lock. We couldn't pass TRUE for CreateMutex to automatically
	// take the lock, since if the mutex already existed, it would be ignored, so
	// we have to do it explicitly here.
	WaitForSingleObject(g_hSharedMutex, INFINITE); // ignoring return value


	// Get a usable pointer to the shared memory
	g_hMemLogView = MapViewOfFile(g_hMemLogMMFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (g_hMemLogView == NULL)
	{
		OutputDebugString("Couldn't create view of file mapping!\n");
		goto ERROR_EXIT;
	} // end if (couldn't create view of file)


	pHeader = (PDEBUGLOGMMFILEHEADER) g_hMemLogView;

	// If we're the first users, initialize the shared memory to our current setup
	if (pHeader->dwVersion == 0)
	{
		pHeader->dwVersion = DEBUGPRINT_SHAREAPI_VERSION;
		pHeader->dwRefCount = 1; // us

		// Store the current memory log globals and offset
		pHeader->dwGlobalsOffset = sizeof (DEBUGLOGMMFILEHEADER);
		g_pMemLogGlobals = (PDEBUGLOGMEMORYGLOBALS) (((LPBYTE) pHeader) + pHeader->dwGlobalsOffset);
		CopyMemory(g_pMemLogGlobals, &g_defaultMemLogGlobals, sizeof (DEBUGLOGMEMORYGLOBALS));

		// Store the current memory log and offset
		pHeader->dwEntriesOffset = pHeader->dwGlobalsOffset + sizeof (DEBUGLOGMEMORYGLOBALS);
		g_paTNMemoryLog = (PTNMEMORYLOGENTRY) (((LPBYTE) pHeader) + pHeader->dwEntriesOffset);
		CopyMemory(g_paTNMemoryLog, g_paLocalMemoryLog,
					(g_pMemLogGlobals->dwMaxMemoryLogEntries * sizeof (TNMEMORYLOGENTRY)));
	} // end if (couldn't open file mapping)
	else
	{
		// Check to make sure we can use it
		if (pHeader->dwVersion != DEBUGPRINT_SHAREAPI_VERSION)
		{
			OutputDebugString("Can't use existing file mapping, incorrect version!\n");
			goto ERROR_EXIT;
		} // end if (can't use the file)


		// Increment the file's refcount
		pHeader->dwRefCount++;

		// Get pointers to the shared items
		g_pMemLogGlobals = (PDEBUGLOGMEMORYGLOBALS) (((LPBYTE) pHeader) + pHeader->dwGlobalsOffset);
		g_paTNMemoryLog = (PTNMEMORYLOGENTRY) (((LPBYTE) pHeader) + pHeader->dwEntriesOffset);

		g_dwLastMemLogIndex = g_pMemLogGlobals->dwCurrentMemoryLogIndex;
	} // end else (opened file mapping)


	// We won't need the local log anymore, so screw it.
	if (g_paLocalMemoryLog != NULL)
	{
		LocalFree(g_paLocalMemoryLog);
		g_paLocalMemoryLog = NULL;
	} // end if (local log exists)


	// We need to rebuild the help string.
	BuildDebugLogHelpString();



	// Drop the locks we had
	ReleaseMutex(g_hSharedMutex);
	ReleaseMutex(g_hLocalMutex);

	return;

ERROR_EXIT:

	if (g_hMemLogView != NULL)
	{
		UnmapViewOfFile(g_hMemLogView);
		g_hMemLogView = NULL;
	} // end if (globals view existed)

	if (g_hMemLogMMFile != NULL)
	{
		CloseHandle(g_hMemLogMMFile);
		g_hMemLogMMFile = NULL;
	} // end if (memory mapped file existed)

	if (g_hSharedMutex != NULL)
	{
		ReleaseMutex(g_hSharedMutex);
		CloseHandle(g_hSharedMutex);
		g_hSharedMutex = NULL;
	} // end if (shared mutex existed)

	ReleaseMutex(g_hLocalMutex);
} // TNDebugInitializeMemLogSharing
#endif // ! XBOX



#ifndef _XBOX // no IPC supported, no need to share memory
//==================================================================================
// TNDebugCleanupMemLogSharing
//----------------------------------------------------------------------------------
//
// Description: Releases any items that may have been allocated for sharing the
//				memory debug log.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugCleanupMemLogSharing(void)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	// Take the locks.
	TNDebugTakeLock();
	

	// Unmap the view if it existed
	if (g_hMemLogView != NULL)
	{
		PDEBUGLOGMMFILEHEADER	pHeader;


		// Update our local version to reflect what is currently in the shared log
		// before we fork/split.

		CopyMemory(&g_defaultMemLogGlobals, g_pMemLogGlobals, sizeof (DEBUGLOGMEMORYGLOBALS));
		g_pMemLogGlobals = &g_defaultMemLogGlobals;


		// If somehow we had a local log already, then we want to free the old one.
		if (g_paLocalMemoryLog != NULL)
		{
			OutputDebugString("WARNING: Freeing previous memory log!\n");
			LocalFree(g_paLocalMemoryLog);
			g_paLocalMemoryLog = NULL;
		} // end if (had memory log already)

		g_paLocalMemoryLog = (PTNMEMORYLOGENTRY) LocalAlloc(LPTR, (g_pMemLogGlobals->dwMaxMemoryLogEntries  * sizeof (TNMEMORYLOGENTRY)));
		if (g_paLocalMemoryLog == NULL)
		{
			TNDebugDropLock();
			return;
		} // end if (couldn't reallocate log)

		CopyMemory(g_paLocalMemoryLog, g_paTNMemoryLog,
					(g_pMemLogGlobals->dwMaxMemoryLogEntries * sizeof (TNMEMORYLOGENTRY)));
		g_paTNMemoryLog = g_paLocalMemoryLog;

		

		pHeader = (PDEBUGLOGMMFILEHEADER) g_hMemLogView;

		// Decrement the file's refcount, marking it for deletion if we're the
		// last users of it.
		pHeader->dwRefCount--;
		if (pHeader->dwRefCount == 0xFFFFFFFF)
		{
			OutputDebugString("WARNING: Shared log refcount is bogus!\n");
		} // end if (we're the last users)

		UnmapViewOfFile(g_hMemLogView);
		g_hMemLogView = NULL;
	} // end if (there was a view of the memory mapped file)

	// Close the memory mapped file
	if (g_hMemLogMMFile != NULL)
	{
		CloseHandle(g_hMemLogMMFile);
		g_hMemLogMMFile = NULL;
	} // end if (the memory mapped file exists)


	// We need to rebuild the help string.
	BuildDebugLogHelpString();


	// Close the shared mutex
	if (g_hSharedMutex != NULL)
	{
		ReleaseMutex(g_hSharedMutex);
		CloseHandle(g_hSharedMutex);
		g_hSharedMutex = NULL;
	} // end if (we took the shared lock)

	// Drop the remaining local lock
	ReleaseMutex(g_hLocalMutex);
} // TNDebugCleanupMemLogSharing
#endif // ! XBOX




#ifndef _XBOX // no IPC supported, so no need to share log
//==================================================================================
// TNDebugConnectDPlayLogging
//----------------------------------------------------------------------------------
//
// Description: Sets up resources used for sharing DPlay's debug log.
//				TNDebugStartMemoryLog must have been called previously.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugConnectDPlayLogging(void)
{
	PDPLAYSHARED_LOG_FILE	lpHeader = NULL;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)

	if (g_paTNMemoryLog == NULL)
	{
		OutputDebugString("Memory debug log not initialized.\n");
		return;
	} // end if (not mem log initialized)

	if ((g_hDPlayLogMMFile != NULL) || (g_hDPlayLogView != NULL))
	{
		OutputDebugString("DPlay log sharing already initialized, restarting.\n");

		TNDebugDisconnectDPlayLogging();
	} // end if (already initialized)

	TNDebugTakeLock();


	// Create the shared mutex.
	g_hDPlayLogMutex = CreateMutex(NULL, FALSE, DPLAYBASE_LOG_MUTEXNAME);
	if (g_hDPlayLogMutex == NULL)
	{
		OutputDebugString("Couldn't create DPlay log shared mutex!\n");
		goto ERROR_EXIT;
	} // end if (couldn't create the mutex)

	// Take the lock
	WaitForSingleObject(g_hDPlayLogMutex, INFINITE);


	g_hDPlayLogMMFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
										0, DPLOG_SIZE, DPLAYBASE_LOG_FILENAME);
	if (g_hDPlayLogMMFile == NULL)
	{
		OutputDebugString("Couldn't create DPlay log memory mapped file!\n");
		goto ERROR_EXIT;
	} // end if (couldn't create new file mapping)

	// Get a usable pointer to the shared memory
	g_hDPlayLogView = MapViewOfFile(g_hDPlayLogMMFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (g_hDPlayLogView == NULL)
	{
		OutputDebugString("Couldn't create view of file mapping!\n");
		goto ERROR_EXIT;
	} // end if (couldn't create view of file)


	// Initialize the shared memory to our current setup

	lpHeader = (PDPLAYSHARED_LOG_FILE) g_hDPlayLogView;

	g_lpDPlayLog = (((LPBYTE) lpHeader) + sizeof (DPLAYSHARED_LOG_FILE));

	g_dwDPlayLastIndex = lpHeader->iWrite;


	// Drop the locks we had
	ReleaseMutex(g_hDPlayLogMutex);

	TNDebugDropLock();

	return;

ERROR_EXIT:

	if (g_hDPlayLogView != NULL)
	{
		UnmapViewOfFile(g_hDPlayLogView);
		g_hDPlayLogView = NULL;
	} // end if (globals view existed)

	if (g_hDPlayLogMMFile != NULL)
	{
		CloseHandle(g_hDPlayLogMMFile);
		g_hDPlayLogMMFile = NULL;
	} // end if (memory mapped file existed)

	if (g_hDPlayLogMutex != NULL)
	{
		ReleaseMutex(g_hDPlayLogMutex);
		CloseHandle(g_hDPlayLogMutex);
		g_hDPlayLogMutex = NULL;
	} // end if (shared mutex existed)

	TNDebugDropLock();
} // TNDebugConnectDPlayLogging
#endif // ! XBOX



//==================================================================================
// TNDebugDisconnectDPlayLogging
//----------------------------------------------------------------------------------
//
// Description: Releases any items that may have been allocated for sharing the
//				DPlay debug log.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugDisconnectDPlayLogging(void)
{
	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	TNDebugTakeLock();

	if (g_hDPlayLogMutex == NULL)
	{
		ReleaseMutex(g_hLocalMutex);
		return;
	} // end if (don't have valid DPlay log mutex)

	// Get the DPlay log lock, ignoring return value
	WaitForSingleObject(g_hDPlayLogMutex, INFINITE);
	

	// Unmap the view if it existed
	if (g_hDPlayLogView != NULL)
	{
		UnmapViewOfFile(g_hDPlayLogView);
		g_hDPlayLogView = NULL;
	} // end if (there was a view of the memory mapped file)

	// Close the memory mapped file
	if (g_hDPlayLogMMFile != NULL)
	{
		CloseHandle(g_hDPlayLogMMFile);
		g_hDPlayLogMMFile = NULL;
	} // end if (the memory mapped file exists)


	// Close the shared DPlay mutex
	ReleaseMutex(g_hDPlayLogMutex);
	CloseHandle(g_hDPlayLogMutex);
	g_hDPlayLogMutex = NULL;

	TNDebugDropLock();
} // TNDebugDisconnectDPlayLogging




//==================================================================================
// TNDebugGrabNewDPlayEntries
//----------------------------------------------------------------------------------
//
// Description: Copies any items in DPlay debug log that have been entered since
//				the last time this function was called and places them in the
//				memory debug log.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNDebugGrabNewDPlayEntries(void)
{
	PDPLAYSHARED_LOG_FILE	lpHeader = NULL;
	PDPLAYLOG_ENTRY			lpEntry = NULL;
	DWORD					dwTemp;
	DWORD					dwSrcChar;
	DWORD					dwDestChar;
	char*					pszEntry;
	char					cTruncatedChar;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)

	//BUGBUG these (and all other calls like them) should be inside the lock grab.
	if (g_paTNMemoryLog == NULL)
	{
		OutputDebugString("Memory debug log not initialized.\n");
		return;
	} // end if (mem log not initialized)

	if (g_hDPlayLogView == NULL)
	{
		OutputDebugString("DPlay log not initialized.\n");
		return;
	} // end if (DPlay log not initialized)


	// Grab our locks
	TNDebugTakeLock();


	// Get the DPlay log lock, ignoring return value
	WaitForSingleObject(g_hDPlayLogMutex, INFINITE);


	lpHeader = (PDPLAYSHARED_LOG_FILE) g_hDPlayLogView;


	//BUGBUG it's possible to wrap around to the exact same spot, and we'd miss
	//		 every single one of those entries
	if (g_dwDPlayLastIndex != lpHeader->iWrite)
	{
		dwTemp = g_dwDPlayLastIndex;
		do
		{
			lpEntry = (PDPLAYLOG_ENTRY) (g_lpDPlayLog + (dwTemp * (sizeof (DPLAYLOG_ENTRY) + lpHeader->cbLine)));
			pszEntry = (char*) (lpEntry + 1);
			

			// Due to a bug in the DPlay logging, lines that exceed the length of
			// the buffer aren't terminated, which gives us garbage at the end
			// of the strings.  We're going to fix that up in here, as well as
			// put an ellipsis in our copy of the DPlay spew to indicate that it
			// got truncated.
			cTruncatedChar = '\0';

			// Check to see if we need to truncate the line.
			if (pszEntry[lpHeader->cbLine - 1] != '\0')
			{
				// Save the character at the end of the string and then terminate
				// it.
				cTruncatedChar = pszEntry[lpHeader->cbLine - 1];
				pszEntry[lpHeader->cbLine - 1] = '\0';

				// If our forced termination didn't actually affect the length of
				// the line, then don't bother saving the character we thought was
				// truncated.
				if (strlen(pszEntry) != (lpHeader->cbLine - 1))
					cTruncatedChar = '\0';
			} // end if (may need to truncate line)

			// Don't copy lines that are empty.
			if (pszEntry[0] != '\0')
			{
				g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].dwLocation = DEBUG_SHAREDLOGLOCATION_DPLAY;
				g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].iLevel = lpEntry->DebugLevel;
				g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].dwProcessID = 0xFFFFFFFF;
				g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].dwThreadID = lpEntry->hThread;
				g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].tEntryTime = lpEntry->tLogged;

				dwSrcChar = 0;
				dwDestChar = 0;
				do
				{
					// Skip newline characters.
					if (pszEntry[dwSrcChar] == '\r')
					{
						dwSrcChar++;
					} // end if (new line character)
					else
					{
						g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString[dwDestChar++] = pszEntry[dwSrcChar];
						dwSrcChar++;

						// If we've reached our buffer limit, stop.
						if (dwDestChar >= MAX_MEMORYLOG_STRING_SIZE)
							break;
					} // end else (not the new line character)
				} // end do (while not at end of mem log string)
				while (pszEntry[dwSrcChar] != '\0');

				// If we truncated the string, try to add it to our current string
				if ((cTruncatedChar != '\0') && (dwDestChar < MAX_MEMORYLOG_STRING_SIZE))
				{
					// Copy the truncated character.
					g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString[dwDestChar++] = cTruncatedChar;

					// If there's room, try to add an ellipsis to our string to help
					// the user notice that the line got truncated.
					if (dwDestChar < (MAX_MEMORYLOG_STRING_SIZE - 3))
					{
						g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString[dwDestChar++] = '.';
						g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString[dwDestChar++] = '.';
						g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString[dwDestChar++] = '.';
					} // end if (more room in string)
				} // end if (truncated string, but more room in our buffer)

				// Make sure the string is NULL terminated.
				g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString[dwDestChar] = '\0';


				g_pMemLogGlobals->dwCurrentEntryOffset += sizeof (TNMEMORYLOGENTRY);
				g_pMemLogGlobals->dwCurrentMemoryLogIndex++;
				if (g_pMemLogGlobals->dwCurrentMemoryLogIndex >= g_pMemLogGlobals->dwMaxMemoryLogEntries)
				{
					g_pMemLogGlobals->dwCurrentEntryOffset = 0;
					g_pMemLogGlobals->dwCurrentMemoryLogIndex = 0;
				} // end if (should wrap around)
			} // end if (there's a valid entry here)

			dwTemp++;

			if (dwTemp >= lpHeader->nEntries)
				dwTemp = 0;
		} // end do (while we haven't wrapped back to where we started)
		while (dwTemp != lpHeader->iWrite);

		// Okay, we're up to date.
		g_dwDPlayLastIndex = lpHeader->iWrite;
	} // end if (the DPlay log has been updated)

	// Drop the DPlay lock
	ReleaseMutex(g_hDPlayLogMutex);

	// Drop our locks
	TNDebugDropLock();
} // TNDebugGrabNewDPlayEntries




//==================================================================================
// TNDebugGetThreadBlockNote
//----------------------------------------------------------------------------------
//
// Description: Used to retrieve the last known block info for the given thread.
//				If the thread ID has some information, it is copied into the buffers
//				provided and TRUE is returned.  If not (or an error occcured),
//				FALSE is returned.
//
// Arguments:
//	DWORD dwThreadID		Thread ID to look up
//	LPTSTR lptszModule		String to store last known module for thread.
//	LPTSTR lptszString		String to store last known section for thread.
//	LPTSTR lptszFile		String to store last known file for thread.
//	int* lpiLineNum			Pointer to int to store last known line number for thread.
//	LPTSTR lptszInfoString	String to store last known extra info for thread.
//	DWORD* lpdwNoteAge		Place to store how long ago (in ms) this note was
//							entered.
//
// Returns: TRUE if thread's info was found and successfully copied, FALSE
//			otherwise.
//==================================================================================
BOOL TNDebugGetThreadBlockNote(DWORD dwThreadID, LPTSTR lptszModule,
								LPTSTR lptszSection, LPTSTR lptszFile,
								int* lpiLineNum, LPTSTR lptszInfoString,
								DWORD* lpdwNoteAge)
{
	DWORD	dwIndex;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return (FALSE);
	} // end if (not initialized)

	for(dwIndex = 0; dwIndex < g_dwNumThreadInfos; dwIndex++)
	{
		if (g_aThreadInfos[dwIndex].dwThreadID == dwThreadID)
		{
			lstrcpy(lptszModule, g_aThreadInfos[dwIndex].tszModule);
			lstrcpy(lptszSection, g_aThreadInfos[dwIndex].tszSection);
			lstrcpy(lptszFile, g_aThreadInfos[dwIndex].tszFile);
			(*lpiLineNum) = g_aThreadInfos[dwIndex].iLineNum;
			lstrcpy(lptszInfoString, g_aThreadInfos[dwIndex].tszInfoString);
#ifndef _XBOX // timeGetTime not supported
			(*lpdwNoteAge) = timeGetTime() - g_aThreadInfos[dwIndex].tEntryTime;
#else // ! XBOX
			(*lpdwNoteAge) = GetTickCount() - g_aThreadInfos[dwIndex].tEntryTime;
#endif // XBOX

			return (TRUE);
		} // end if (we found the thread)
	} // end for (each entry)

	// If we get here, we didn't find the thread.
	return (FALSE);
} // TNDebugGetThreadBlockNote




//==================================================================================
// TNInternalDebugPrepLog
//----------------------------------------------------------------------------------
//
// Description: Part of the DPL macro.  Prepares the log entry by setting the
//				module and section to the ones passed in.
//				NOTE: This enters the critical section, and it is up to the caller
//				to leave it.  Please use the macro instead of directly calling this
//				this function.
//
// Arguments:
//	LPTSTR lptszModule	Name of module.
//	LPTSTR lptszString	Name of section.
//
// Returns: None.
//==================================================================================
void TNInternalDebugPrepLog(LPTSTR lptszModule, LPTSTR lptszSection)
{
	if (g_dwTNDebugRefcount < 1)
	{
		//OutputDebugString("Debug log not initialized.\n");

		// Note we're going to copy the info anyway.
		lstrcpy(g_tszModule, lptszModule);
		lstrcpy(g_tszSection, lptszSection);

		return; // bail
	} // end if (not initialized)

	TNDebugTakeLock();


	// Siphon in the DPlay items, if we're doing that
	if (g_hDPlayLogView != NULL)
	{
		TNDebugGrabNewDPlayEntries();
	} // end if (sharing the DPlay log)

	// If memory logging is turned on, and some form of sharing is enabled, display
	// any new items.
	if ((g_paTNMemoryLog != NULL) &&
		((g_hMemLogView != NULL) || (g_hDPlayLogView != NULL)))
	{
		//BUGBUG make customizable
		TNDebugDisplayNewMemLogEntries(FALSE, TRUE);
		//TNDebugDisplayNewMemLogEntries(TRUE, TRUE);
	} // end if (some form of sharing is on)

	lstrcpy(g_tszModule, lptszModule);
	lstrcpy(g_tszSection, lptszSection);
} // TNInternalDebugPrepLog




//==================================================================================
// TNInternalDebugPrintLine
//----------------------------------------------------------------------------------
//
// Description: Part of the DPL macro.  Prints a string line to the debug terminal
//				log file, and/or memory at a specific logging level.
//
//				See the TNsprintf source for available tokens.				
//
//
//				For example:
//					#define DEBUG_MODULE	"SOMEAPP"
//					#define DEBUG_SECTION	"MyFunc()"
//					DebugPrintLine(2, "The %s is %i.", "result", 5);
//				Would print:
//					"SOMEAPP: MyFunc(): The result is 5.\n"
//
//				NOTE: This leaves the critical section, so the caller must have
//				previously entered it.  Please use the macro for this.
//
// Arguments:
//	int iLevel					Level at which to log the string.
//	LPTSTR lptszFormatString	String (with optional tokens) to print.
//	DWORD dwNumParms			Number of items in the following variable parameter
//								list.
//	...							Parameters to be inserted in the string.
//
// Returns: None.
//==================================================================================

// Internal version, see header actual macro to use
void TNInternalDebugPrintLine(int iLevel, LPTSTR lptszFormatString, DWORD dwNumParms,
							...)
{
#ifndef _XBOX // no TN printing supported
	TCHAR		tszCurrentModule[256];
	TCHAR		tszCurrentSection[256];
	BOOL		fDebuggerLog = FALSE;
	BOOL		fFileLog = FALSE;
	BOOL		fMemoryLog = FALSE;
	TCHAR*		ptszActualString = NULL;
	DWORD		dwActualStringSize = 0;
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		tCurrentTime;
	DWORD		dwTemp = 0;
	char*		pszOutput = NULL;


	// Save the location now, because it may get stomped by a subroutine.
	lstrcpy(tszCurrentModule, g_tszModule);
	lstrcpy(tszCurrentSection, g_tszSection);


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");

		// Note: continuing
	} // end if (not initialized)


	fDebuggerLog = ((g_fLogToDebugger) &&
					(iLevel >= g_iDebuggerLogLevelMin) &&
					(iLevel <= g_iDebuggerLogLevelMax)) ? TRUE : FALSE;

	fFileLog = ((g_hFile != INVALID_HANDLE_VALUE) &&
				(iLevel >= g_iFileLogLevelMin) &&
				(iLevel <= g_iFileLogLevelMax)) ? TRUE : FALSE;

	fMemoryLog = ((g_paTNMemoryLog != NULL) &&
				(iLevel >= g_pMemLogGlobals->iMemoryLogLevelMin) &&
				(iLevel <= g_pMemLogGlobals->iMemoryLogLevelMax)) ? TRUE : FALSE;

	// If none of the logs will print this, might as well skip the processing.
	if ((! (fDebuggerLog || fFileLog || fMemoryLog)) &&
		(g_dwTNDebugRefcount >= 1))
	{
		goto DONE;
	} // end if (no logs will print this item)

	if (dwNumParms > 0)
	{
		papvParms = (PVOID*) LocalAlloc(LPTR, dwNumParms * sizeof (PVOID));
		if (papvParms == NULL)
			goto DONE;

		va_start(currentparam, dwNumParms);

		while (dwTemp < dwNumParms)
		{
			papvParms[dwTemp] = va_arg(currentparam, PVOID);
			dwTemp++;
		} // end for (each parameter)

		va_end(currentparam);
	} // end if (there are parameters and/or module + section to print)


#ifndef _XBOX // no timeGetTime supported
	tCurrentTime = timeGetTime();
#else // ! XBOX
	tCurrentTime = GetTickCount();
#endif // XBOX

	// Actually parse the items into a string.
	TNsprintf_array(&pszOutput, lptszFormatString, dwNumParms, papvParms);

	// If we should print to the debugger and the level is appropriate (see above)
	// or we're not initialized and trying to be nice.
	if ((fDebuggerLog) || (g_dwTNDebugRefcount < 1))
	{
		dwActualStringSize = strlen(pszOutput) + 2; // + 2 = newline + NULL termination

		if (strcmp(tszCurrentModule, "") != 0)
			dwActualStringSize += strlen(tszCurrentModule) + 2; // + 2 = ": "
		if (strcmp(tszCurrentSection, "") != 0)
			dwActualStringSize += strlen(tszCurrentSection) + 2; // + 2 = ": "

		ptszActualString = (LPTSTR) LocalAlloc(LPTR, dwActualStringSize);
		if (ptszActualString == NULL)
			goto DONE;

		if (strcmp(tszCurrentModule, "") != 0)
		{
			strcat(ptszActualString, tszCurrentModule);
			strcat(ptszActualString, ": ");
		} // end if (there's a module to print)

		if (strcmp(tszCurrentSection, "") != 0)
		{
			strcat(ptszActualString, tszCurrentSection);
			strcat(ptszActualString, ": ");
		} // end if (there's a section to print)

		strcat(ptszActualString, pszOutput);
		strcat(ptszActualString, "\n");

		OutputDebugString(ptszActualString);

		LocalFree(ptszActualString);
		ptszActualString = NULL;
	} // end if (we should print to the debugger)


	// We're printing to the debugger just to be nice, but since we're not
	// initialized, there's no way we can do the advanced logging, so skip it.
	if (g_dwTNDebugRefcount < 1)
	{
		goto DONE;
	} // end if (not initialized)


	// If we should print to a file and the level is appropriate (see above)
	if (fFileLog)
	{
		TCHAR	tszProcessID[32];
		TCHAR	tszThreadID[32];
		TCHAR	tszTime[32];
		TCHAR	tszTimeSinceLast[32];


		dwActualStringSize = strlen(pszOutput) + 1; // + NULL termination

		wsprintf(tszProcessID, "0x%08x\t", GetCurrentProcessId());
		dwActualStringSize += strlen(tszProcessID);

		wsprintf(tszThreadID, "0x%08x\t", GetCurrentThreadId());
		dwActualStringSize += strlen(tszThreadID);

		wsprintf(tszTime, "%u\t", tCurrentTime);
		dwActualStringSize += strlen(tszTime);

		// Time printed as an integer to handle negative numbers.
		wsprintf(tszTimeSinceLast, "%i\t", tCurrentTime - g_tTimeFileLastEntry);
		dwActualStringSize += strlen(tszTimeSinceLast);

		// Update the last entry time
		g_tTimeFileLastEntry = tCurrentTime;


		if (strcmp(tszCurrentModule, "") != 0)
			dwActualStringSize += strlen(tszCurrentModule) + 2; // + 2 = ": "
		if (strcmp(tszCurrentSection, "") != 0)
			dwActualStringSize += strlen(tszCurrentSection) + 2; // + 2 = ": "

		ptszActualString = (LPTSTR) LocalAlloc(LPTR, dwActualStringSize);
		if (ptszActualString == NULL)
			goto DONE;

		strcat(ptszActualString, tszProcessID);
		strcat(ptszActualString, tszThreadID);
		strcat(ptszActualString, tszTime);
		strcat(ptszActualString, tszTimeSinceLast);

		if (strcmp(tszCurrentModule, "") != 0)
		{
			strcat(ptszActualString, tszCurrentModule);
			strcat(ptszActualString, ": ");
		} // end if (there's a module to print)

		if (strcmp(tszCurrentSection, "") != 0)
		{
			strcat(ptszActualString, tszCurrentSection);
			strcat(ptszActualString, ": ");
		} // end if (there's a section to print)

		strcat(ptszActualString, pszOutput);

		// Ignore error
		FileWriteLine(g_hFile, ptszActualString);

		LocalFree(ptszActualString);
		ptszActualString = NULL;


		// If we're capping file size, and that line put us over the limit, it's time
		// to start a new file.
		if ((g_dwMaxFileSize > 0) && (g_dwMaxFileSize <= GetFileSize(g_hFile, NULL)))
		{
			HRESULT		hr;
			TCHAR		tszTemp[1024];
			int			iPos;
			TCHAR*		ptszTemp;
			DWORD		dwLogNum;


			if (g_ptszCurrentFilepath == NULL)
			{
				// Uh oh, what can we do?
				goto DONE;
			} // end else (there's not filepath)

			FileGetExtension(g_ptszCurrentFilepath, tszTemp, TRUE);

			iPos = strlen(g_ptszCurrentFilepath) - strlen(tszTemp);
			g_ptszCurrentFilepath[iPos] = '\0'; // truncate the string

			iPos--; // move before the NULL terminator

			// Keep moving back until we find the underscore character.
			while (g_ptszCurrentFilepath[iPos] != '_')
			{
				iPos--;

				// If we hit the start of the name without encountering the
				// underscore character, something's messed up.
				if (iPos == 0)
					goto DONE;
			} // end while (haven't found non numeric character)

			iPos++; // move after underscore
			

			// Convert those last numbers into a DWORD and increment it.
			dwLogNum = StringToDWord(g_ptszCurrentFilepath + iPos);
			dwLogNum++;

			// + 1 for NULL termination
			ptszTemp = (TCHAR*) LocalAlloc(LPTR, (iPos + StringNumDWordDigits(dwLogNum) + strlen(tszTemp) + 1) * (sizeof (TCHAR)));
			if (ptszTemp == NULL)
				goto DONE;

			CopyMemory(ptszTemp, g_ptszCurrentFilepath, iPos * sizeof (TCHAR));
			wsprintf(ptszTemp + iPos, "%u", dwLogNum);
			strcat(ptszTemp, tszTemp);

			// Move the new filename into the global after freeing the old one.
			LocalFree(g_ptszCurrentFilepath);
			g_ptszCurrentFilepath = ptszTemp;
			ptszTemp = NULL;

			// Close the old file
			CloseHandle(g_hFile);
			g_hFile = INVALID_HANDLE_VALUE;


			// Open the new one
			hr = FileCreateAndOpenFile(g_ptszCurrentFilepath, FALSE, g_fAppend, FALSE, &g_hFile);
			if (hr != S_OK)
			{
				/*
				wsprintf(tszTemp, "Couldn't create debug log file \"%s\"!  hr = 0x%08x\n",
						g_ptszCurrentFilepath, hr);
				OutputDebugString(tszTemp);
				*/
				goto DONE;
			} // end if (couldn't create file)

			if (g_ptszHeader != NULL)
			{
				FileWriteLine(g_hFile, "//==================================================================================");
				FileSprintfWriteLine(g_hFile, "// %s", 1, g_ptszHeader);
				FileWriteLine(g_hFile, "//");

				FileSprintfWriteLine(g_hFile, "// Debug log file part %u", 1, dwLogNum);

				StringGetCurrentDateStr(tszTemp);
				StringPrepend(tszTemp, "// Begins ");
				FileWriteLine(g_hFile, tszTemp);

				FileWriteLine(g_hFile, "//==================================================================================");
			} // end if (have header string to display)
		} // end if (there's a max file size cap)
	} // end if (we should print to the debugger)

	// If we should print to memory and the level is appropriate (see above)
	if (fMemoryLog)
	{
		dwActualStringSize = strlen(pszOutput) + 1; // + 1 = NULL termination

		if (strcmp(tszCurrentModule, "") != 0)
			dwActualStringSize += strlen(tszCurrentModule) + 2; // + 2 = ": "
		if (strcmp(tszCurrentSection, "") != 0)
			dwActualStringSize += strlen(tszCurrentSection) + 2; // + 2 = ": "

		ptszActualString = (LPTSTR) LocalAlloc(LPTR, dwActualStringSize);
		if (ptszActualString == NULL)
			goto DONE;

		if (strcmp(tszCurrentModule, "") != 0)
		{
			strcat(ptszActualString, tszCurrentModule);
			strcat(ptszActualString, ": ");
		} // end if (there's a module to print)

		if (strcmp(tszCurrentSection, "") != 0)
		{
			strcat(ptszActualString, tszCurrentSection);
			strcat(ptszActualString, ": ");
		} // end if (there's a section to print)

		strcat(ptszActualString, pszOutput);

		g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].dwLocation = DEBUG_SHAREDLOGLOCATION_TNCOMMON;
		g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].iLevel = iLevel;
		g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].dwProcessID = GetCurrentProcessId();
		g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].dwThreadID = GetCurrentThreadId();
		g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].tEntryTime = tCurrentTime;


		if (strlen(ptszActualString) > MAX_MEMORYLOG_STRING_SIZE)
		{
			// Artificially terminate the string at the max length
			ptszActualString[MAX_MEMORYLOG_STRING_SIZE - 1] = 0;
		} // end if (we need to truncate the entry)

		strcpy(g_paTNMemoryLog[g_pMemLogGlobals->dwCurrentMemoryLogIndex].szString,
				ptszActualString);

		LocalFree(ptszActualString);
		ptszActualString = NULL;

		g_pMemLogGlobals->dwCurrentEntryOffset += sizeof (TNMEMORYLOGENTRY);
		g_pMemLogGlobals->dwCurrentMemoryLogIndex++;
		if (g_pMemLogGlobals->dwCurrentMemoryLogIndex >= g_pMemLogGlobals->dwMaxMemoryLogEntries)
		{
			g_pMemLogGlobals->dwCurrentEntryOffset = 0;
			g_pMemLogGlobals->dwCurrentMemoryLogIndex = 0;
		} // end if (should wrap around)

		g_dwLastMemLogIndex = g_pMemLogGlobals->dwCurrentMemoryLogIndex;
	} // end if (we should print to the debugger)


DONE:

	if (g_dwTNDebugRefcount >= 1)
	{
		TNDebugDropLock();
	} // end if (we we were initialized)

	TNsprintf_free(&pszOutput); // won't matter if it's NULL

	if (ptszActualString != NULL)
	{
		LocalFree(ptszActualString);
		ptszActualString = NULL;
	} // end if (allocated string)

	if (papvParms != NULL)
	{
		LocalFree(papvParms);
		papvParms = NULL;
	} // end if (allocated params array
#else // ! XBOX
#pragma TODO(tristanj, "Replace logging with Xbox log stuff")
#endif // XBOX
} // TNInternalDebugPrintLine



//==================================================================================
// TNInternalDebugNoteBlock
//----------------------------------------------------------------------------------
//
// Description: Called by the DNB macro.  Notes the 
//				Please use the macro instead of directly calling this
//				this function.
//
// Arguments:
//	LPTSTR lptszModule		Name of module.
//	LPTSTR lptszString		Name of section.
//	LPTSTR lptszFile		File containing caller.
//	int iLineNum			Line number of caller.
//	LPTSTR lptszInfoString	Extra info string describing the section.
//
// Returns: None.
//==================================================================================
void TNInternalDebugNoteBlock(LPTSTR lptszModule, LPTSTR lptszSection,
							LPTSTR lptszFile, int iLineNum, LPTSTR lptszInfoString)
{
	DWORD	dwCurrentThreadID;
	DWORD	dwIndex;


	if (g_dwTNDebugRefcount < 1)
	{
		OutputDebugString("Debug log not initialized.\n");
		return;
	} // end if (not initialized)


	dwCurrentThreadID = GetCurrentThreadId();

	for(dwIndex = 0; dwIndex < g_dwNumThreadInfos; dwIndex++)
	{
		if (g_aThreadInfos[dwIndex].dwThreadID == dwCurrentThreadID)
			break;
	} // end for (each entry)

	// If we didn't find an entry for this thread, make a new one if we can
	if (dwIndex >= g_dwNumThreadInfos)
	{
		if (g_dwNumThreadInfos >= 128)
		{
			OutputDebugString("Can't store any more thread info entries!\n");
			return;
		} // end if (we can't store any more thread info)

		dwIndex = g_dwNumThreadInfos;
		g_dwNumThreadInfos++;

		g_aThreadInfos[dwIndex].dwThreadID = dwCurrentThreadID;
	} // end if (we didn't find an existing entry)
	

	// Update the information regarding the thread.

	lstrcpy(g_aThreadInfos[dwIndex].tszModule, lptszModule);
	lstrcpy(g_aThreadInfos[dwIndex].tszSection, lptszSection);
	lstrcpy(g_aThreadInfos[dwIndex].tszFile, lptszFile);
	g_aThreadInfos[dwIndex].iLineNum = iLineNum;
	lstrcpy(g_aThreadInfos[dwIndex].tszInfoString, lptszInfoString);

#ifndef _XBOX // no timeGetTime supported
	g_aThreadInfos[dwIndex].tEntryTime = timeGetTime();
#else // ! XBOX
	g_aThreadInfos[dwIndex].tEntryTime = GetTickCount();
#endif // XBOX

} // TNInternalDebugNoteBlock





//==================================================================================
// BuildDebugLogHelpString
//----------------------------------------------------------------------------------
//
// Description: Builds the string that explains how to view the memory debug log
//				from inside a debugger.  The lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void BuildDebugLogHelpString(void)
{
	DWORD	dwSize;
	char	szMemLogStart[32];
	char	szMemLogEnd[32];
	char	szCurrentEntryOffset[32];
	char	szEntrySize[32];
	char	szEntryNonStringSize[32];


	// Free the previous help string if there was one.
	if (g_pszDebugLogHelp != NULL)
	{
		LocalFree(g_pszDebugLogHelp);
		g_pszDebugLogHelp = NULL;
	} // end if (already have string)


	// Bail if we don't have anything to work with.
	if ((g_paTNMemoryLog == NULL) || (g_pMemLogGlobals == NULL))
		return;


	wsprintf(szMemLogStart, "0x" SPRINTF_PTR, g_paTNMemoryLog);
	wsprintf(szMemLogEnd, "0x" SPRINTF_PTR,
			((LPBYTE) g_paTNMemoryLog) + (g_pMemLogGlobals->dwMaxMemoryLogEntries * g_pMemLogGlobals->dwEntrySize));
	wsprintf(szCurrentEntryOffset, "0x" SPRINTF_PTR,
			((LPBYTE) g_pMemLogGlobals) + (DWORD_PTR) (&(((PDEBUGLOGMEMORYGLOBALS) 0x00000000)->dwCurrentEntryOffset)));
	wsprintf(szEntrySize, "0x%08x", g_pMemLogGlobals->dwEntrySize);
	wsprintf(szEntryNonStringSize, "0x%08x", g_pMemLogGlobals->dwEntryNonStringSize);


	dwSize = strlen("DebugLogHelp -  To see the log, take the address ")
			+ strlen(szMemLogStart)
			+ strlen(" (value at g_paTNMemoryLog).  Dump the DWORD at ")
			+ strlen(szCurrentEntryOffset)
			+ strlen(" (g_pMemLogGlobals->dwCurrentEntryOffset) and add it to the address.  Finally, add ")
			+ strlen(szEntryNonStringSize)
			+ strlen(" (g_pMemLogGlobals->dwEntryNonStringSize).  Dumping the string at that address will print the oldest log entry.  Dump that address minus ")
			+ strlen(szEntrySize)
			+ strlen(" (g_pMemLogGlobals->dwEntrySize) will print the most recent log entry.  Continuing to go back ")
			+ strlen(szEntrySize)
			+ strlen("  bytes will give you older and older entries.  Remember that the log wraps around at the addresses ")
			+ strlen(szMemLogStart)
			+ strlen(" and ")
			+ strlen(szMemLogEnd)
			+ strlen(".")
			+ 1;

	g_pszDebugLogHelp = (char*) LocalAlloc(LPTR, dwSize);
	if (g_pszDebugLogHelp != NULL)
	{
		strcpy(g_pszDebugLogHelp, "DebugLogHelp -  To see the log, take the address ");
		strcat(g_pszDebugLogHelp, szMemLogStart);
		strcat(g_pszDebugLogHelp, " (value at g_paTNMemoryLog).  Dump the DWORD at ");
		strcat(g_pszDebugLogHelp, szCurrentEntryOffset);
		strcat(g_pszDebugLogHelp, " (g_pMemLogGlobals->dwCurrentEntryOffset) and add it to the address.  Finally, add ");
		strcat(g_pszDebugLogHelp, szEntryNonStringSize);
		strcat(g_pszDebugLogHelp, " (g_pMemLogGlobals->dwEntryNonStringSize).  Dumping the string at that address will print the oldest log entry.  Dump that address minus ");
		strcat(g_pszDebugLogHelp, szEntrySize);
		strcat(g_pszDebugLogHelp, " (g_pMemLogGlobals->dwEntrySize) will print the most recent log entry.  Continuing to go back ");
		strcat(g_pszDebugLogHelp, szEntrySize);
		strcat(g_pszDebugLogHelp, "  bytes will give you older and older entries.  Remember that the log wraps around at the addresses ");
		strcat(g_pszDebugLogHelp, szMemLogStart);
		strcat(g_pszDebugLogHelp, " and ");
		strcat(g_pszDebugLogHelp, szMemLogEnd);
		strcat(g_pszDebugLogHelp, ".");
	} // end if (allocated memory)
} // BuildDebugLogHelpString

#endif // DEBUG

#ifdef _XBOX
void WINAPI DebugPrint (char *format, ...)
{
    va_list params;
	char szTemp [2048];

    va_start (params, format);
    vsprintf (szTemp, format, params);
    OutputDebugStringA(szTemp);
    va_end (params);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\errors.h ===
#ifndef __ERRORS__
#define __ERRORS__





//==================================================================================
// Common Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined




//=========================================================================================
// Defines
//=========================================================================================
// Prefix the name of the error with the hexdecimal value.
#define ERRORSFLAG_PRINTHEXVALUE		0x01
// Prefix the name of the error with the decimal value.
#define ERRORSFLAG_PRINTDECIMALVALUE	0x02
// Print a description of the error, if any.
#define ERRORSFLAG_PRINTDESCRIPTION		0x04

#define ERRORSSHORTCUT_NOTSEARCHED		0xFFFFFFFF
#define ERRORSSHORTCUT_NOTFOUND			0xFFFFFFFE




//=========================================================================================
// Structures
//=========================================================================================
typedef struct tagTNERRORITEM
{
	HRESULT		hresult;
	char*		pszName;
	char*		pszDescription;
} TNERRORITEM, * PTNERRORITEM;




//=========================================================================================
// Prototypes
//=========================================================================================
DLLEXPORT HRESULT GetErrorDescription(LONG_PTR hresult, DWORD_PTR dwFlags, char* pszBuffer,
									DWORD* pdwBufferSize, DWORD* pdwShortcut);

DLLEXPORT void DoSprintfErrorBox(HWND hWndParent, LPTSTR lptszTitle, LPTSTR lptszFormatString,
								DWORD dwNumParms, ...);

DLLEXPORT void GetTNErrorTable(PTNERRORITEM* ppaTNErrorTable, DWORD* pdwNumEntries);





#endif //__ERRORS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\excptns.h ===
#ifndef __TNEXCEPTIONS__
#define __TNEXCEPTIONS__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined





//==================================================================================
// Class type definitions
//==================================================================================
typedef class CTNException		CTNException,		* PTNEXCEPTION;
typedef class CTNExceptionsList	CTNExceptionsList,	* PTNEXCEPTIONSLIST;





//==================================================================================
// Macros
//==================================================================================
#ifdef USE_TRY_CATCH


#define BEGIN_CONVERTEXCEPTIONS_BLOCK	DNB("Entering convertexceptions block.");\
										__try

#define END_CONVERTEXCEPTIONS_BLOCK		__except(TNExcptnConvertToClassFilter((PEXCEPTION_POINTERS) _exception_info(),\
																				&g_TNExceptions))\
										{\
											throw (&g_TNExceptions);\
										}\
										DNB("Leaving convertexceptions block.");


#else // ! USE_TRY_CATCH


#define BEGIN_CONVERTEXCEPTIONS_BLOCK	DNB("Entering block.");

#define END_CONVERTEXCEPTIONS_BLOCK		DNB("Leaving block.");


#endif // ! USE_TRY_CATCH




//==================================================================================
// External Prototypes
//==================================================================================
DLLEXPORT int TNExcptnConvertToClassFilter(PEXCEPTION_POINTERS pExceptionInfo,
											PTNEXCEPTIONSLIST pExceptionsList);




//==================================================================================
// Classes
//==================================================================================
class DLLEXPORT CTNException:public LLITEM
{
	public:
		CONTEXT		m_context;
		DWORD		m_dwExceptionCode;
		DWORD		m_dwExceptionFlags;
		PVOID		m_pvExceptionAddress;
		DWORD		m_dwNumberParameters;
		DWORD		m_adwExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];


		CTNException(LPCONTEXT lpContext,
					DWORD dwExceptionCode,
					DWORD dwExceptionFlags,
					PVOID pvExceptionAddress,
					DWORD dwNumberParameters,
					DWORD_PTR* padwExceptionInformation);

		//HRESULT GetDescription(void);
		HRESULT PrintSelf(void);
};

class DLLEXPORT CTNExceptionsList:public LLIST
{
};



//==================================================================================
// External globals
//==================================================================================
extern DLLEXPORT CTNExceptionsList	g_TNExceptions;






#endif // __TNEXCEPTIONS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\fileutils.h ===
#ifndef __TNCOMMON_FILEUTILS__
#define __TNCOMMON_FILEUTILS__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#define READTEXTFILE_BUFFER_SIZE_INCREMENT		50




//----------------------------------------------------------------------------------
// Read text file options
//----------------------------------------------------------------------------------
// Setting this causes empty lines not to be passed to the callback.
#define FILERTFO_SKIP_EMPTY_LINES					0x001

// Specify this option to identify of the section/subsection etc.  These are .ini
// style tokens.  A section is defined by "[sectionname]".  Sub-sections under that
// are "{subsectionname}".  A further level can be denoted by parentheses
// "(subsubsectionname)".  See the FILERTFT_xxx line types.
#define FILERTFO_PARSE_INI_STYLE_SECTIONS			0x002

// Use this to ignore beginning and ending white space on each line
#define FILERTFO_IGNORE_SURROUNDING_WHITESPACE		0x004

// Specify this option to ignore anything after double slashes ("//") and between
// "/*" "*/" tokens.  The latter can be spread across multiple lines.
#define FILERTFO_IGNORE_C_COMMENTS					0x008

// Specify this option to ignore anything after a semicolon (";")
#define FILERTFO_IGNORE_SEMICOLON_COMMENTS			0x010

// If this option is specified, environment variables found in the file are
// expanded to their value.  The parser looks for the string "%VARNAME%", and
// replaces that with the value assigned to VARNAME, if any.
#define FILERTFO_EXPAND_ENV_VARS					0x020

// If this option is specified, additional files can be included by using #include
// followed by the filename in quotes.  The given file is then read as if the text
// it contains were actually inside the including file.
#define FILERTFO_ALLOW_POUND_INCLUDES				0x040

// If this option is specified, environment variables can be declared using
// #define by the variable name.  An optional value can also be specified after
// the name.  This can be useful when combined with FILERTFO_EXPAND_ENV_VARS.
#define FILERTFO_ALLOW_POUND_DEFINES				0x080

// If this option is specified, then any line that ends with a backslash character
// is considered to be continued on the next line, and the carraige-return/newline
// sequence is ignored.
#define FILERTFO_ALLOW_ESCAPED_NEWLINES				0x100


#define FILERTFO_INIOPTIONS							(FILERTFO_SKIP_EMPTY_LINES |\
													FILERTFO_PARSE_INI_STYLE_SECTIONS |\
													FILERTFO_IGNORE_SURROUNDING_WHITESPACE)

#define FILERTFO_EXTENDEDINIOPTIONS					(FILERTFO_INIOPTIONS |\
													FILERTFO_IGNORE_C_COMMENTS |\
													FILERTFO_EXPAND_ENV_VARS |\
													FILERTFO_ALLOW_POUND_INCLUDES |\
													FILERTFO_ALLOW_POUND_DEFINES |\
													FILERTFO_ALLOW_ESCAPED_NEWLINES)

#define FILERTFO_ALLOPTIONS							(FILERTFO_EXTENDEDINIOPTIONS |\
													FILERTFO_IGNORE_SEMICOLON_COMMENTS)

//----------------------------------------------------------------------------------
// Read text file line types
//----------------------------------------------------------------------------------
// This line is just a regular line.  Will always be this if
// FILERTFO_PARSE_INI_STYLE_SECTIONS is not specifed.
#define FILERTFT_NORMAL			1

// This line is a section header.  FILERTFO_PARSE_INI_STYLE_SECTIONS must have been
// specified.  The "[]" characters are stripped.
#define FILERTFT_SECTION		2

// This line is a subsection header.  FILERTFO_PARSE_INI_STYLE_SECTIONS must have
// been specified.  The "{}" characters are stripped.
#define FILERTFT_SUBSECTION		3

// This line is a subsubsection header.  FILERTFO_PARSE_INI_STYLE_SECTIONS must have
// been specified.  The "()" characters are stripped.
#define FILERTFT_SUBSUBSECTION	4




//----------------------------------------------------------------------------------
// Copy tree options
//----------------------------------------------------------------------------------
// If a file already exists at the destination, then the function will fail.  Cannot
// be used with any of the other first three options.
#define FILECTO_FAIL_IF_EXISTS			0x01

// Normally files that already exist at the destination and have the same time, size,
// etc. are not copied.  This option overrides that.  Cannot be used with any of the
// other first three options.
#define FILECTO_FORCE_COPY_IF_SAME		0x02

// Erases all existing files in the directories at the destination where files will
// be copied prior to the actual copying.  Note that subdirectories are untouched;
// for that, use FileCleanDirectory.  Cannot be used with any of the other first
// three options.
#define FILECTO_EMPTY_COPIED_DIRS		0x04

// This specifies that even directories where no files are copied are created at the
// destination.  If FILECTO_EMPTY_COPIED_DIRS is specified, these empty directories
// are cleaned of existing files at the destination.
#define FILECTO_COPY_EMPTY_DIRS			0x08


#ifndef NO_FILEUTILS_COPYTREEPROGRESS
// This causes a window with the current file and a total progress bar to be
// displayed while copying.
#define FILECTO_DISPLAY_PROGRESS_BAR	0x10
#endif // ! NO_FILEUTILS_COPYTREEPROGRESS



//==================================================================================
// Structures
//==================================================================================
typedef struct tagFILELINEINFO
{
	// Type of current line, see FILERTFT_xxx above.
	DWORD	dwType;

	// How many lines into the file this one is (note this count includes all lines,
	// even blank ones that may have been skipped, and newline\carraige-returns that
	// were escaped).
	DWORD	dwLineNumber;

	// Current section for line, or NULL if none or not parsed.
	char*	pszCurrentSection;

	// Current subsection for line, or NULL if none or not parsed.
	char*	pszCurrentSubsection;

	// Current subsubsection for line, or NULL if none or not parsed.
	char*	pszCurrentSubsubsection;
} FILELINEINFO, * PFILELINEINFO;



//==================================================================================
// Callback function definitions
//==================================================================================
typedef HRESULT	(__stdcall *PFILEREADLINEPROC)	(char*, PFILELINEINFO, PVOID, BOOL*);





//==================================================================================
// Prototypes
//==================================================================================
DLLEXPORT HRESULT FileReadTextFile(char* szFilePath, DWORD dwOptions,
									PFILEREADLINEPROC pfnReadLine,
									PVOID pvContext);

DLLEXPORT void FileGetNameWithoutExtension(char* szPath, char* szResult, BOOL fIncludeDelimiter);

DLLEXPORT void FileGetExtension(char* szPath, char* szResult, BOOL fIncludeDelimiter);

DLLEXPORT void FileGetLastItemInPath(char* szPath, char* szResult);

DLLEXPORT void FileGetParentDirFromPath(char* szPath, char* szResult);

DLLEXPORT void FileGetDriveFromPath(char* szPath, char* szResult);

DLLEXPORT HRESULT FileCombinePaths(char* szBaseDir, char* szAdditivePath,
								char* pszNewPath, DWORD* pdwNewPathSize);

DLLEXPORT HRESULT FileGetAttributes(char* szItemPath, BOOL* pfIsDirectory,
									BOOL* pfIsReadOnly);
DLLEXPORT HRESULT FileSetAttributes(char* szItemPath, BOOL* pfReadOnly);

DLLEXPORT HRESULT FileGetRealFilePath(char* szItemPath, BOOL fFileAlreadyExists,
									char* pszResultPath, DWORD* pdwResultPathSize);

DLLEXPORT HRESULT FileEnsureDirectoryExists(char* szDirPath);

DLLEXPORT BOOL FileCompareFiles(char* szFirstPath, char* szSecondPath,
								BOOL fCheckCreationTime);


DLLEXPORT HRESULT FileCountFilesInDir(char* szDirPath, BOOL fCountSubdirectories,
									DWORD* lpdwCount);

DLLEXPORT HRESULT FileCopyTree(char* szSourceDirPath, char* szDestDirPath,
							   DWORD dwOptions, PLSTRINGLIST pSkipFiles);

DLLEXPORT HRESULT FileCleanDirectory(char* szDirPath, BOOL fDeleteDirectory,
									BOOL fApplyToSubDirs);


DLLEXPORT HRESULT FileCreateAndOpenFile(char* szFilepath, BOOL fFailIfExists,
										BOOL fAppend, BOOL fInheritableHandle,
										HANDLE* phFile);


DLLEXPORT HRESULT FileWriteString(HANDLE hFile, char* szString);

DLLEXPORT HRESULT FileSprintfWriteString(HANDLE hFile, char* szFormatString,
										DWORD dwNumParms, ...);

DLLEXPORT HRESULT FileWriteLine(HANDLE hFile, char* lpszString);

DLLEXPORT HRESULT FileSprintfWriteLine(HANDLE hFile, char* szFormatString,
										DWORD dwNumParms, ...);

DLLEXPORT HRESULT FileStartTrackingOutputFiles(void);

DLLEXPORT HRESULT FileGetOutputFilesArray(BOOL fIgnoreDuplicates, char** papszArray,
										DWORD* pdwMaxNumEntries);

DLLEXPORT HRESULT FileStopTrackingOutputFiles(void);





#endif // __TNCOMMON_FILEUTILS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\fileutils.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <direct.h>
#include <errno.h>
#ifndef _XBOX // no commctrl
#include <commctrl.h>
#endif // ! XBOX

#include <stdlib.h>	// NT BUILD needs this for _MAX_xxx and _splitpath



#include "main.h"
#include "resource.h"


#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#endif // ! NO_TNCOMMON_DEBUG_SPEW
#include "cppobjhelp.h"
#include "linklist.h"
#include "linkedstr.h"
#include "strutils.h"
#include "sprintf.h"

#include "fileutils.h"





//==================================================================================
// Structures
//==================================================================================
typedef struct tagCOPYTREEDATA
{
	BOOL			fSkip; // whether the entire directory should be skipped (only can happen when updating progress)
	DWORD			dwOptions; // options for copying the tree, see FILECTO_xxx
	PLSTRINGLIST	pSkipFiles; // optional list of filepaths (may use '*' wildcard character) to skip
	HANDLE			hProgressThreadStartedEvent; // handle to event for progress thread to set when ready
	HWND			hProgressWindow; // window to update with progress, if any
	DWORD			dwNumFilesHandled; // number of files that have been handled so far
	DWORD			dwTotalNumFiles; // total number of files in under topmost directory
} COPYTREEDATA, * PCOPYTREEDATA;




//==================================================================================
// Local Prototypes
//==================================================================================
HRESULT CopyTreeInternal(char* szSourceDirPath, char* szDestDirPath,
						PCOPYTREEDATA pCopyTreeData);

#ifndef NO_FILEUTILS_COPYTREEPROGRESS
INT_PTR CALLBACK CopyTreeProgressWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam,
											LPARAM lParam);

DWORD WINAPI CopyTreeProgressThreadProc(LPVOID lpvParameter);
#endif // ! NO_FILEUTILS_COPYTREEPROGRESS




//==================================================================================
// Globals
//==================================================================================
PLSTRINGLIST	g_pTrackedFiles = NULL;





#ifndef _XBOX // no file reading...
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileReadTextFile()"
//==================================================================================
// FileReadTextFile
//----------------------------------------------------------------------------------
//
// Description: Sets the file specified's attributes to the values passed in.  You
//				can pass NULL for any value you don't want to change.
//
// Arguments:
//	char* szFilePath				Path to file to read.
//	DWORD dwOptions					Options for reading the file (see FILERTFO_xxx).
//	PFILEREADLINEPROC pfnReadLine	Callback function to handle each line.
//	PVOID pvContext					Pointer to user context to specify to function.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileReadTextFile(char* szFilePath, DWORD dwOptions,
						PFILEREADLINEPROC pfnReadLine, PVOID pvContext)
{
	HRESULT			hr;
	HANDLE			hFile = INVALID_HANDLE_VALUE;
	BOOL			fEndOfFile = FALSE;
	DWORD			dwStringBufferSize = 0;
	char*			pszStringBuffer = NULL;
	DWORD			dwCurrentStringIndex;
	char			c = '\0';
	DWORD			dwBytesRead;
	BOOL			fInComment = FALSE;
	char*			pszTemp1 = NULL;
	char*			pszTemp2 = NULL;
	int				iPos;
	DWORD			dwRealLineNumber = 0;
	FILELINEINFO	fli;
	BOOL			fStopReading = FALSE;
#ifdef _XBOX
	WCHAR			szWideFilePath[256];
#endif


	ZeroMemory(&fli, sizeof (FILELINEINFO));


	if ((szFilePath == NULL) || (strcmp(szFilePath, "") == 0))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an invalid filepath!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed an invalid file)

	if (pfnReadLine == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an invalid callback function!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed an invalid callback)



	// Initialize the buffer
	dwStringBufferSize = READTEXTFILE_BUFFER_SIZE_INCREMENT;
	pszStringBuffer = (char*) LocalAlloc(LPTR, dwStringBufferSize);
	if (pszStringBuffer == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(1, "Opening file \"%s\".", 1, szFilePath);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/


	// Open the file
#ifndef _XBOX // Damn ANSI conversion
	hFile = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, 0, NULL);
#else // ! XBOX
	// Convert to wide
	mbstowcs(szWideFilePath, szFilePath, strlen(szFilePath));
	szWideFilePath[strlen(szFilePath)] = 0;

	// Call CreateFile with wide version
	hFile = CreateFile(szWideFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, 0, NULL);
#endif // XBOX

	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't open file \"%s\"!", 1, szFilePath);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't open file)


	// Loop until the end of the file
	do
	{
		// Start at beginning of buffer
		dwCurrentStringIndex = 0;

		dwRealLineNumber++;

		// This will not get updated for escaped lines until the next real newline.
		fli.dwLineNumber = dwRealLineNumber;

		// Loop until the end of the line or the end of the file
		do
		{
			// Increase the buffer size if we won't have enough room
			if (dwCurrentStringIndex >= dwStringBufferSize)
			{
				PVOID	pvTemp;


				pvTemp = LocalAlloc(LPTR, (dwStringBufferSize + READTEXTFILE_BUFFER_SIZE_INCREMENT));
				if (pvTemp == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvTemp, pszStringBuffer, dwStringBufferSize);
				dwStringBufferSize += READTEXTFILE_BUFFER_SIZE_INCREMENT;

				LocalFree(pszStringBuffer);
				pszStringBuffer = (char*) pvTemp;
				pvTemp = NULL;
			} // end if (we're not going to have enough room)

			if (! ReadFile(hFile, &c, 1, &dwBytesRead, NULL))
			{
				hr = GetLastError();
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Failed reading from file (line %u)!",
					1, dwRealLineNumber);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (failed reading from file)

			if (dwBytesRead == 0)
			{
				// End of file.  Terminate the string here and stop looping.
				fEndOfFile = TRUE;

				pszStringBuffer[dwCurrentStringIndex] = '\0';
				break;
			} // end if (didn't read anything)

			pszStringBuffer[dwCurrentStringIndex] = c;

			if ((c == '\n') && (dwCurrentStringIndex > 0) &&
				(pszStringBuffer[dwCurrentStringIndex - 1] == '\r'))
			{
				// We found a carraige-return\newline sequence.  If escaped
				// lines are allowed, make sure it's not one of those.

				if (dwOptions & FILERTFO_ALLOW_ESCAPED_NEWLINES)
				{
					if (StringIsCharBackslashEscaped(pszStringBuffer, pszStringBuffer + dwCurrentStringIndex - 1))
					{
						// Move the current index back to overwrite the escaped
						// characters.
						dwCurrentStringIndex -= 3;

						// We still want to increase our total line count (but
						// not our current line number).
						dwRealLineNumber++;
					} // end if (this carraige-return/newline is escaped)
					else
					{
						// Terminate the string at the start of the sequence and
						// stop looping.
						pszStringBuffer[dwCurrentStringIndex - 1] = '\0';
						break;
					} // end else (this carraige-return/newline is not escaped)
				} // end if (we should make sure the first character is not escaped)
				else
				{
					// Terminate the string at the start of the sequence and stop
					// looping.
					pszStringBuffer[dwCurrentStringIndex - 1] = '\0';
					break;
				} // end else (escaped newlines aren't allowed)
			} // end if (this isn't the first character)

			dwCurrentStringIndex++;
		} // end do (while not at end of line or end of file)
		while (TRUE);

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Line %u: \"%s\".", 2, fli.dwLineNumber, pszStringBuffer);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		// If we should ignore things in C style comments, do that.
		if (dwOptions & FILERTFO_IGNORE_C_COMMENTS)
		{
			if (fInComment)
			{
				iPos = StringContainsString(pszStringBuffer, "*/", TRUE, 0);
				if (iPos >= 0)
				{
					// Chop off any stuff before the comment ended
					if (! StringSplit(pszStringBuffer, iPos + 2, NULL, pszStringBuffer))
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "StringSplit() failed (line %u)!",
							1, dwRealLineNumber);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW

						hr = E_FAIL;
						goto DONE;
					} // end if (string split failed)

					fInComment = FALSE;
				} // end if (we found a multiline end comment token)
				else
				{
					// We started off with this line as a comment, and didn't
					// end the comment here, so this line should be ignored.
					continue;
				} // end else (we didn't find a multiline end comment token)
			} // end if (we're already in a comment from a previous line)

			do
			{
				iPos = 0;
				hr = StringGetBetween(pszStringBuffer, "/*", "*/", TRUE, FALSE,
										FALSE, TRUE, FALSE, &iPos,
										pszStringBuffer, NULL, &fInComment);
				if (hr != S_OK)
				{
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Removing multiple line/inline C comments failed (line %u)!",
						1, dwRealLineNumber);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW
					goto DONE;
				} // end if (removing stuff failed)
			} // end do
			while (iPos >= 0);

			iPos = 0;
			hr = StringGetBetween(pszStringBuffer, "//", NULL, TRUE, FALSE,
								FALSE, TRUE, FALSE, &iPos, pszStringBuffer,
								NULL, NULL);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Removing single line C comments failed (line %u)!",
					1, dwRealLineNumber);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (removing stuff failed)
		} // end if (C style comments are allowed)


		// If we should ignore things in semicolon comments, do that.
		if (dwOptions & FILERTFO_IGNORE_SEMICOLON_COMMENTS)
		{
			iPos = 0;
			hr = StringGetBetween(pszStringBuffer, ";", NULL, TRUE, FALSE,
								FALSE, TRUE, FALSE, &iPos, pszStringBuffer,
								NULL, NULL);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Removing semicolon comments failed (line %u)!",
					1, dwRealLineNumber);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (removing stuff failed)
		} // end if (C style comments are allowed)


		// Clear off surrounding whitespace, if allowed
		if (dwOptions & FILERTFO_IGNORE_SURROUNDING_WHITESPACE)
		{
			StringPopLeadingChars(pszStringBuffer, "\t ", TRUE); 
			StringPopTrailingChars(pszStringBuffer, "\t ", TRUE);
		} // end if (should ignore whitespace)

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Line %u: \"%s\".", 2, fli.dwLineNumber, pszStringBuffer);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		// If the user lets us expand environment variables, check for those.
		if (dwOptions & FILERTFO_EXPAND_ENV_VARS)
		{
			DWORD	dwTempSize;
			char	szBogus[1];


			// There's a bug in Windows 95 where if you pass NULL or a pointer to
			// invalid string buffer to this function it will fail, so we use a temp
			// thing to trick it into shutting up.
			dwTempSize = ExpandEnvironmentStrings(pszStringBuffer, szBogus, 0);

			if (dwTempSize == 0)
			{
				hr = GetLastError();

				if (hr == S_OK)
					hr = E_FAIL;

				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Expanding environment variables in \"%s\" failed (line %u)!",
					2, pszStringBuffer, dwRealLineNumber);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (expanding env vars failed)

			pszTemp1 = (char*) LocalAlloc(LPTR, dwTempSize);
			if (pszTemp1 == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (allocating memory failed)

			if (ExpandEnvironmentStrings(pszStringBuffer, pszTemp1, dwTempSize) == 0)
			{
				hr = GetLastError();

				if (hr == S_OK)
					hr = E_FAIL;

				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Expanding environment variables in \"%s\" failed (line %u)!",
					2, pszStringBuffer, dwRealLineNumber);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (expanding env vars failed)

			// Switch buffers if we don't have enough room, otherwise, copy
			// the new buffer back over the original one.
			if (dwTempSize >= dwStringBufferSize)
			{
				dwStringBufferSize = dwTempSize;
				LocalFree(pszStringBuffer);
				pszStringBuffer = pszTemp1;
				pszTemp1 = NULL;
			} // end if (we're not going to have enough room)
			else
			{
				strcpy(pszStringBuffer, pszTemp1);
				LocalFree(pszTemp1);
				pszTemp1 = NULL;
			} // end else (we have enough room)
		} // end if (we can expand environment variables)

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Line %u: \"%s\".", 2, fli.dwLineNumber, pszStringBuffer);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		// If it's an empty line (possibly after the above processing), skip it
		// if the caller doesn't want them.
		if ((strcmp(pszStringBuffer, "") == 0) &&
			(dwOptions & FILERTFO_SKIP_EMPTY_LINES))
		{
			continue;
		} // end if (empty line and should be skipped)


		fli.dwType = FILERTFT_NORMAL;

		if (dwOptions & FILERTFO_PARSE_INI_STYLE_SECTIONS)
		{
			if ((StringStartsWith(pszStringBuffer, "[", TRUE)) &&
				(StringEndsWith(pszStringBuffer, "]", TRUE)))
			{
				StringPopLeadingChars(pszStringBuffer, "[", TRUE);
				StringPopTrailingChars(pszStringBuffer, "]", TRUE);

				fli.dwType = FILERTFT_SECTION;


				// Forget the previous section, subsection, and subsubsection

				if (fli.pszCurrentSection != NULL)
				{
					LocalFree(fli.pszCurrentSection);
					fli.pszCurrentSection = NULL;
				} // end if (previously in section)

				if (fli.pszCurrentSubsection != NULL)
				{
					LocalFree(fli.pszCurrentSubsection);
					fli.pszCurrentSubsection = NULL;
				} // end if (previously in subsection)

				if (fli.pszCurrentSubsubsection != NULL)
				{
					LocalFree(fli.pszCurrentSubsubsection);
					fli.pszCurrentSubsubsection = NULL;
				} // end if (previously in subsubsection)


				// Save this new section

				fli.pszCurrentSection = (char*) LocalAlloc(LPTR, strlen(pszStringBuffer) + 1);
				if (fli.pszCurrentSection == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				strcpy(fli.pszCurrentSection, pszStringBuffer);
			} // end if (it's a section)
			else if ((StringStartsWith(pszStringBuffer, "{", TRUE)) &&
				(StringEndsWith(pszStringBuffer, "}", TRUE)))
			{
				StringPopLeadingChars(pszStringBuffer, "{", TRUE);
				StringPopTrailingChars(pszStringBuffer, "}", TRUE);

				fli.dwType = FILERTFT_SUBSECTION;


				// Forget the previous subsection, and subsubsection

				if (fli.pszCurrentSubsection != NULL)
				{
					LocalFree(fli.pszCurrentSubsection);
					fli.pszCurrentSubsection = NULL;
				} // end if (previously in subsection)

				if (fli.pszCurrentSubsubsection != NULL)
				{
					LocalFree(fli.pszCurrentSubsubsection);
					fli.pszCurrentSubsubsection = NULL;
				} // end if (previously in subsubsection)


				// Save this new subsection

				fli.pszCurrentSubsection = (char*) LocalAlloc(LPTR, strlen(pszStringBuffer) + 1);
				if (fli.pszCurrentSubsection == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				strcpy(fli.pszCurrentSubsection, pszStringBuffer);
			} // end else if (it's a subsection)
			else if ((StringStartsWith(pszStringBuffer, "(", TRUE)) &&
				(StringEndsWith(pszStringBuffer, ")", TRUE)))
			{
				StringPopLeadingChars(pszStringBuffer, "(", TRUE);
				StringPopTrailingChars(pszStringBuffer, ")", TRUE);

				fli.dwType = FILERTFT_SUBSUBSECTION;


				// Forget the previous subsubsection

				if (fli.pszCurrentSubsubsection != NULL)
				{
					LocalFree(fli.pszCurrentSubsubsection);
					fli.pszCurrentSubsubsection = NULL;
				} // end if (previously in subsubsection)


				// Save this new subsubsection

				fli.pszCurrentSubsubsection = (char*) LocalAlloc(LPTR, strlen(pszStringBuffer) + 1);
				if (fli.pszCurrentSubsubsection == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				strcpy(fli.pszCurrentSubsubsection, pszStringBuffer);
			} // end else if (it's a subsubsection)
		} // end if (section info should be parsed)

		if (StringStartsWith(pszStringBuffer, "#", TRUE))
		{
			DWORD	dwTempSize;
			DWORD	dwFields;


			dwTempSize = strlen(pszStringBuffer) + 1;
			pszTemp1 = (char*) LocalAlloc(LPTR, dwTempSize);
			if (pszTemp1 == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			// Separate items by white space
			dwFields = StringSplitIntoFields(pszStringBuffer, " \t", pszTemp1, &dwTempSize);
			if (dwFields > 1)
			{
				// Check for #includes, if allowed
				if ((dwOptions & FILERTFO_ALLOW_POUND_INCLUDES) &&
					(StringCmpNoCase(StringGetFieldPtr(pszTemp1, 0), "#include")))
				{
					char*		pszParentDir;
					char*		pszAbsoluteFile;
					DWORD		dwAbsoluteFileSize;
					int			iPos;


					pszTemp2 = (char*) LocalAlloc(LPTR, strlen(pszStringBuffer) + 1);
					if (pszTemp2 == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)

					iPos = 9; // start after #include
					hr = StringGetBetween(pszStringBuffer, "\"", "\"", TRUE, FALSE,
										FALSE, TRUE, TRUE, &iPos, NULL, pszTemp2,
										NULL);
					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't get string between quotes in %s (line %u)!",
							2, pszStringBuffer, dwRealLineNumber);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't get string in quotes)

					if (iPos < 0)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "WARNING: Didn't find file to include (no quotes) in \"%s\" (line %u)!  Ignoring.",
							2, pszStringBuffer, dwRealLineNumber);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
					} // end if (didn't find quotes)
					else
					{
						pszParentDir = (char*) LocalAlloc(LPTR, strlen(szFilePath) + 1);
						if (pszParentDir == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate memory)
						FileGetParentDirFromPath(szFilePath, pszParentDir);

						// If there isn't an explicit parent directory, use the current one
						if (strcmp(pszParentDir, "") == 0)
							strcpy(pszParentDir, ".");


						// Ignore error, assume BUFFER_TOO_SMALL
						FileCombinePaths(pszParentDir, pszTemp2, NULL,
										&dwAbsoluteFileSize);

						pszAbsoluteFile = (char*) LocalAlloc(LPTR, dwAbsoluteFileSize);
						if (pszAbsoluteFile == NULL)
						{
							LocalFree(pszParentDir);
							pszParentDir = NULL;
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate memory)


						hr = FileCombinePaths(pszParentDir, pszTemp2,
											pszAbsoluteFile, &dwAbsoluteFileSize);
						if (hr != S_OK)
						{
							#ifndef NO_TNCOMMON_DEBUG_SPEW
							DPL(0, "Couldn't combine \"%s\" and \"%s\" (line %u)!",
								3, pszParentDir, pszTemp2, dwRealLineNumber);
							#endif // ! NO_TNCOMMON_DEBUG_SPEW
							LocalFree(pszParentDir);
							pszParentDir = NULL;
							LocalFree(pszAbsoluteFile);
							pszAbsoluteFile = NULL;
							goto DONE;
						} // end if (couldn't get string in quotes)

						LocalFree(pszTemp2);
						pszTemp2 = NULL;

						LocalFree(pszParentDir);
						pszParentDir = NULL;


						// Recursively read in this new file we have.
						hr = FileReadTextFile(pszAbsoluteFile, dwOptions,
											pfnReadLine, pvContext);
						if (hr != S_OK)
						{
							#ifndef NO_TNCOMMON_DEBUG_SPEW
							DPL(0, "Couldn't read subfile \"%s\" (line %u)!",
								2, pszAbsoluteFile, dwRealLineNumber);
							#endif // ! NO_TNCOMMON_DEBUG_SPEW
							LocalFree(pszAbsoluteFile);
							pszAbsoluteFile = NULL;
							goto DONE;
						} // end if (couldn't get string in quotes)

						LocalFree(pszAbsoluteFile);
						pszAbsoluteFile = NULL;

						LocalFree(pszTemp1);
						pszTemp1 = NULL;

						// We don't want to hand the user this line
						continue;
					} // end else (found quotes)

					LocalFree(pszTemp2);
					pszTemp2 = NULL;
				} // end if (we found a #include)


				// Check for #defines, if allowed
				if ((dwOptions & FILERTFO_ALLOW_POUND_DEFINES) &&
					(StringCmpNoCase(StringGetFieldPtr(pszTemp1, 0), "#define")))
				{
					char*	pszName;
					int		iPos;
					

					pszName = StringGetFieldPtr(pszTemp1, 1);

					//pszTemp2 = NULL;
					if (dwFields >= 2)
					{
						// Find where the name starts in the string (skipping past
						// #define).
						iPos = StringContainsString(pszStringBuffer, pszName, TRUE, 8);
						if (iPos < 0)
						{
							#ifndef NO_TNCOMMON_DEBUG_SPEW
							DPL(0, "Couldn't find name string %s in \"%s\" (line %u)!",
								3, pszName, pszStringBuffer, dwRealLineNumber);
							#endif // ! NO_TNCOMMON_DEBUG_SPEW
							hr = E_FAIL;
							goto DONE;
						} // end if (couldn't find string)

						// Move past the name
						iPos += strlen(pszName);

						pszTemp2 = (char*) LocalAlloc(LPTR, strlen(pszStringBuffer + iPos) + 1);
						if (pszTemp2 == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate memory)

						strcpy(pszTemp2, (pszStringBuffer + iPos));

						// Get rid of the surrounding whitespace
						StringPopLeadingChars(pszTemp2, " \t", TRUE);
						StringPopTrailingChars(pszTemp2, " \t", TRUE);
					} // end if (there's a value)

#ifndef _XBOX // SetEnvironmentVariable not supported
					// Build an environment variable.  If the user didn't specify a
					// value, use an empty string
					if (! SetEnvironmentVariable(pszName, ((pszTemp2 == NULL) ? "" : pszTemp2)))
					{
						hr = GetLastError();
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't set environment variable \"%s\" to \"%s\" (line %u)!",
							3, pszName, pszTemp2, dwRealLineNumber);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't set an environment variable)
#else // ! XBOX
#pragma TODO(tristanj, "What effect does not setting the defined environment variable have?")
#endif // XBOX
					if (pszTemp2 != NULL)
					{
						LocalFree(pszTemp2);
						pszTemp2 = NULL;
					} // end if (allocated a value)

					LocalFree(pszTemp1);
					pszTemp1 = NULL;

					// We don't want to hand the user this line
					continue;
				} // end if (we found a #define)


				// Check for #pragma message()s
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				if ((StringCmpNoCase(StringGetFieldPtr(pszTemp1, 0), "#pragma")) &&
					(StringStartsWith(StringGetFieldPtr(pszTemp1, 1), "message", FALSE)) &&
					(StringEndsWith(pszStringBuffer, ")", TRUE)))
				{
					char	szLineNumber[64];


					pszTemp2 = (char*) LocalAlloc(LPTR, strlen(pszStringBuffer) + 1);
					if (pszTemp2 == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)

					iPos = 16; // start after #pragma message
					hr = StringGetBetween(pszStringBuffer, "\"", "\"", TRUE, FALSE,
										FALSE, TRUE, TRUE, &iPos, NULL, pszTemp2,
										NULL);
					if (hr != S_OK)
					{
						//#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't get string between quotes in %s (line %u)!",
							2, pszStringBuffer, dwRealLineNumber);
						//#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't get string in quotes)

					// Use the somewhat modified line number, not the real one.  It's
					// actually the top most line number for the current (possible)
					// multi-line.
					wsprintf(szLineNumber, "Line %u", fli.dwLineNumber);

					// We explicitly expand the macro so we can pass in the module and
					// section we want to see.
					TNInternalDebugPrepLog(szFilePath, szLineNumber);
					TNInternalDebugPrintLine(0, pszTemp2, 0);


					LocalFree(pszTemp2);
					pszTemp2 = NULL;

					LocalFree(pszTemp1);
					pszTemp1 = NULL;

					// We don't want to hand the user this line
					continue;
				} // end if (is a #pragma message)
				#endif // ! NO_TNCOMMON_DEBUG_SPEW


				LocalFree(pszTemp1);
				pszTemp1 = NULL;
			} // end if (it appears to be a valid pound directive)
		} // end if (it's starts with a pound char)


		// Call the user back with this line
		hr = pfnReadLine(pszStringBuffer, &fli, pvContext, &fStopReading);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "User's ReadLine callback failed (line %u)!",
				1, dwRealLineNumber);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (user's callback failed)

		if (fStopReading)
		{
			// Okay, do what the user wants.
			break;
		} // end if (the user wants to stop reading)

	} // end do (while not at the end of the file)
	while (! fEndOfFile);

	hr = S_OK;


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opend the file)

	if (pszStringBuffer != NULL)
	{
		LocalFree(pszStringBuffer);
		pszStringBuffer = NULL;
	} // end if (allocated a temp string)

	if (fli.pszCurrentSection != NULL)
	{
		LocalFree(fli.pszCurrentSection);
		fli.pszCurrentSection = NULL;
	} // end if (previously in section)

	if (fli.pszCurrentSubsection != NULL)
	{
		LocalFree(fli.pszCurrentSubsection);
		fli.pszCurrentSubsection = NULL;
	} // end if (previously in subsection)

	if (fli.pszCurrentSubsubsection != NULL)
	{
		LocalFree(fli.pszCurrentSubsubsection);
		fli.pszCurrentSubsubsection = NULL;
	} // end if (previously in subsubsection)

	if (pszTemp1 != NULL)
	{
		LocalFree(pszTemp1);
		pszTemp1 = NULL;
	} // end if (allocated a temp string)

	if (pszTemp2 != NULL)
	{
		LocalFree(pszTemp2);
		pszTemp2 = NULL;
	} // end if (allocated a temp string)

	return (hr);
} // FileReadTextFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // not supported on XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetNameWithoutExtension()"
//==================================================================================
// FileGetNameWithoutExtension
//----------------------------------------------------------------------------------
//
// Description: Get the root name of the file described (minus the ".xxx" extension)
//				and puts it in the result string.
//				If no extension existed, then no period is added (fIncludeDelimiter
//				is ignored).
//
// Arguments:
//	char* szPath			Path (absolute or relative) to file to get.
//	char* szResult			Buffer to store resulting root name in.
//	BOOL fIncludeDelimiter	Whether to include the extension delimiter character
//							(the period '.') in the result string or not.
//
// Returns: None.
//==================================================================================
void FileGetNameWithoutExtension(char* szPath, char* szResult, BOOL fIncludeDelimiter)
{
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	char szFname[_MAX_FNAME];
	char szExt[_MAX_EXT];


	_splitpath(szPath, szDrive, szDir, szFname, szExt);

	if ((fIncludeDelimiter) && (strlen(szExt) > 0))
		strcat(szFname, ".");

	strcpy(szResult, szFname);
} // FileGetNameWithoutExtension
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // not supported on XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetExtension()"
//==================================================================================
// FileGetExtension
//----------------------------------------------------------------------------------
//
// Description: Get the ".xxx" extension of the file described (without the period)
//				and puts it in the result string. 
//				If no extension existed, the resulting buffer will be empty.
//
// Arguments:
//	char* szPath			Path (absolute or relative) to item to get.
//	char* szResult			Buffer to store resulting extension in.
//	BOOL fIncludeDelimiter	Whether to include the extension delimiter character
//							(the period '.') in the result string or not.
//
// Returns: None.
//==================================================================================
void FileGetExtension(char* szPath, char* szResult, BOOL fIncludeDelimiter)
{
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	char szFname[_MAX_FNAME];
	char szExt[_MAX_EXT];


	_splitpath(szPath, szDrive, szDir, szFname, szExt);

	if (! fIncludeDelimiter)
		StringPopLeadingChars(szExt, ".", TRUE);

	strcpy(szResult, szExt);
} // FileGetExtension
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // not supported on Xbox
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetLastItemInPath()"
//==================================================================================
// FileGetLastItemInPath
//----------------------------------------------------------------------------------
//
// Description: Finds the last item (subdirectory or file) in a path and puts it in
//				the result string. 
//
// Arguments:
//	char* szPath	Path (absolute or relative) to item to get.
//	char* szResult	Place to store result
//
// Returns: None.
//==================================================================================
void FileGetLastItemInPath(char* szPath, char* szResult)
{
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	char szFname[_MAX_FNAME];
	char szExt[_MAX_EXT];


	_splitpath(szPath, szDrive, szDir, szFname, szExt);
	strcpy(szResult, szFname);
	strcat(szResult, szExt);
} // FileGetLastItemInPath
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetParentDirFromPath()"
//==================================================================================
// FileGetParentDirFromPath
//----------------------------------------------------------------------------------
//
// Description: Finds the last item (subdirectory or file)'s parent directory in a
//				path and puts the path to it in the result string. 
//
// Arguments:
//	char* szPath	Path (absolute or relative) to item to get.
//	char* szResult	Place to store result
//
// Returns: None.
//==================================================================================
void FileGetParentDirFromPath(char* szPath, char* szResult)
{
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	char szFname[_MAX_FNAME];
	char szExt[_MAX_EXT];


	_splitpath(szPath, szDrive, szDir, szFname, szExt);
	strcpy(szResult, szDrive);
	strcat(szResult, szDir);
} // FileGetParentDirFromPath
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetDriveFromPath()"
//==================================================================================
// FileGetDriveFromPath
//----------------------------------------------------------------------------------
//
// Description: Finds the the drive in a path and puts it in the result string. 
//
// Arguments:
//	char* szPath	Path to item.
//	char* szResult	Place to store result.
//
// Returns: None.
//==================================================================================
void FileGetDriveFromPath(char* szPath, char* szResult)
{
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	char szFname[_MAX_FNAME];
	char szExt[_MAX_EXT];


	_splitpath(szPath, szDrive, szDir, szFname, szExt);
	strcpy(szResult, szDrive);
} // FileGetDriveFromPath
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no file reading
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileCombinePaths()"
//==================================================================================
// FileCombinePaths
//----------------------------------------------------------------------------------
//
// Description: Returns a new absolute path given a base path and a relative path to
//				to add.
//				If pszNewPath is NULL, the DWORD pointed to by pdwNewPathSize is
//				filled with the size required, including NULL termination, and
//				ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	char* szBaseDir			Base directory (relative or absolute path) to start
//							with.
//	char* szAdditivePath	Relative path to combine with base path.
//	char* pszNewPath		Pointer to place to store result, or NULL to retrieve
//							size required.
//	DWORD* pdwNewPathSize	Pointer to size of buffer, or place to store size
//							required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileCombinePaths(char* szBaseDir, char* szAdditivePath, char* pszNewPath,
						DWORD* pdwNewPathSize)
{
	HRESULT		hr;
	char		szTemp[MAX_PATH];
	char*		pszOldCurrent = NULL;
	DWORD		dwOldCurrentSize;


	// Save the previous current directory.
	dwOldCurrentSize = GetCurrentDirectory(0, NULL);
	pszOldCurrent = (char*) LocalAlloc(LPTR, dwOldCurrentSize);
	if (pszOldCurrent == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	GetCurrentDirectory(dwOldCurrentSize, pszOldCurrent);


	// Temporarily move to the given base directory.
	if (! SetCurrentDirectory(szBaseDir))
	{
		hr = GetLastError();
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't temporarily set the current directory to \"%s\"!",
			1, szBaseDir);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (couldn't set current directory)


	// Convert the additive path to an absolute path based off of the given base.
	_fullpath(szTemp, szAdditivePath, MAX_PATH);


	// Revert to the old current directory.
	if (! SetCurrentDirectory(pszOldCurrent))
	{
		hr = GetLastError();
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't reset the current directory to the original (\"%s\")!",
			1, pszOldCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (couldn't set current directory)


	if (pszNewPath == NULL)
	{
		(*pdwNewPathSize) = strlen(szTemp) + 1;
		hr = ERROR_BUFFER_TOO_SMALL;
		goto DONE;
	} // end if (don't have a buffer)

	strcpy(pszNewPath, szTemp);

	hr = S_OK;


DONE:

	if (pszOldCurrent != NULL)
	{
		LocalFree(pszOldCurrent);
		pszOldCurrent = NULL;
	} // end if (allocated memory)

	return (hr);
} // FileCombinePaths
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // No GetFileAttributes
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetAttributes()"
//==================================================================================
// FileGetAttributes
//----------------------------------------------------------------------------------
//
// Description: Sets the booleans passed in to TRUE if they are true for the file
//				specified, FALSE if not.  You can pass NULL for any value you don't
//				want.
//
// Arguments:
//	char* szItemPath		Path to item to check.
//	BOOL* pfIsDirectory		Boolean to set to whether the item is a directory or not.
//	BOOL* pfIsReadOnly		Boolean to set to whether the item is read only or not.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileGetAttributes(char* szItemPath, BOOL* pfIsDirectory, BOOL* pfIsReadOnly)
{
	DWORD		dwAttributes;



	if (pfIsDirectory != NULL)
		(*pfIsDirectory) = FALSE;
	if (pfIsReadOnly != NULL)
		(*pfIsReadOnly) = FALSE;

	dwAttributes = GetFileAttributes(szItemPath);
	if (dwAttributes == 0xFFFFFFFF)
		return (GetLastError());


	if (pfIsDirectory != NULL)
		(*pfIsDirectory) = (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;

	if (pfIsReadOnly != NULL)
		(*pfIsReadOnly) = (dwAttributes & FILE_ATTRIBUTE_READONLY) ? TRUE : FALSE;

	return (S_OK);
} // FileGetAttributes
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // No GetFileAttributes
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileSetAttributes()"
//==================================================================================
// FileSetAttributes
//----------------------------------------------------------------------------------
//
// Description: Sets the file specified's attributes to the values passed in.  You
//				can pass NULL for any value you don't want to change.
//
// Arguments:
//	char* szItemPath		Path to item to check.
//	BOOL* pfReadOnly		Whether to set the item to be read only or not.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileSetAttributes(char* szItemPath, BOOL* pfReadOnly)
{
	DWORD		dwAttributes;



	dwAttributes = GetFileAttributes(szItemPath);
	if (dwAttributes == 0xFFFFFFFF)
		return (GetLastError());

	if (pfReadOnly != NULL)
	{

		 // If the flag exists, take it out.
		if (dwAttributes & FILE_ATTRIBUTE_READONLY)
			dwAttributes = dwAttributes & ~(FILE_ATTRIBUTE_READONLY);

		// If the flag is supposed to be there, put it back in.
		if ((*pfReadOnly))
			dwAttributes = dwAttributes | FILE_ATTRIBUTE_READONLY;
	} // end if (we're setting the read only flag)

	if (! SetFileAttributes(szItemPath, dwAttributes))
		return (GetLastError());

	return (S_OK);
} // FileSetAttributes
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no file stuff supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetRealFilePath()"
//==================================================================================
// FileGetRealFilePath
//----------------------------------------------------------------------------------
//
// Description: If fFileAlreadyExists is TRUE, returns the full path to the first
//				matching item the system would find based on its search rules:
//					The relative path given, if there are backslashes.  Otherwise,
//						1. The directory from which the application loaded.
//						2. The current directory.
//						3. The System directory(ies).
//						4. The Windows directory.
//						5. Directories in the PATH environment variable.
//				If no file exists at the location(s), ERROR_FILE_NOT_FOUND is
//				returned.
//				If fFileAlreadyExists is FALSE, the absolute path to the item is
//				returned, using the current directory as a base.
//				If pszResultPath is NULL, then pdwResultPath size is set to the
//				size required (including NULL termination), and
//				ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	char* szItemPath			Path to file or directory.
//	BOOL fFileAlreadyExists		If TRUE, the places listed above will be searched
//								for a file matching that description.  If FALSE, and
//								the item path isn't already an absolute path, the
//								current directory is used.
//	char* pszResultPath			Place to store resulting absolute path, or NULL to
//								retrieve size.
//	DWORD* pdwResultPathSize	Pointer to size of result buffer, or place to store
//								size required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileGetRealFilePath(char* szItemPath, BOOL fFileAlreadyExists,
							char* pszResultPath, DWORD* pdwResultPathSize)
{
	HRESULT				hr = S_OK;
	char				szTemp[MAX_PATH];
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		founddata;
	char*				pszTempDir = NULL;
	char*				pszPathVar = NULL;
	DWORD				dwSize;
	DWORD				dwNumPaths;
	DWORD				dwTemp;



	// If the path contains backslashes, get the absolute path to that relative one.
	if (StringContainsChar(szItemPath, '\\', 0, TRUE) >= 0)
	{
		_fullpath(szTemp, szItemPath, MAX_PATH);

		if (fFileAlreadyExists)
		{
			hFind = FindFirstFile(szTemp, &founddata);
			if (hFind != INVALID_HANDLE_VALUE)
			{
				// We found it, we're done.
				goto DONE;
			} // end if (couldn't find first file)

			hr = GetLastError();

			if (hr == S_OK)
				hr = E_FAIL;
		} // end if (file should already exist)

		// We can't do any other types of searching if it's not a plain item.
		goto DONE;
	} // end if (path contains backslashes)


	if (fFileAlreadyExists)
	{

#pragma TODO(vanceo, "Get path to current app")

	} // end if (file should already exist)



	// Get the current directory and try that.

	dwSize = GetCurrentDirectory(0, NULL);
	pszTempDir = (char*) LocalAlloc(LPTR, dwSize);
	if (pszTempDir == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	GetCurrentDirectory(dwSize, pszTempDir);

	strcpy(szTemp, pszTempDir);
	if (! StringEndsWith(pszTempDir, "\\", TRUE))
		strcat(szTemp, "\\");
	strcat(szTemp, szItemPath);

	LocalFree(pszTempDir);
	pszTempDir = NULL;


	// If we're not checking if the file already existed, then we're done (we built
	// the path based off the current directory).  Skip everything else.
	if (! fFileAlreadyExists)
		goto DONE;


	hFind = FindFirstFile(szTemp, &founddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		// We found it, we're done.
		goto DONE;
	} // end if (couldn't find first file)



	// Get the system directory and try that.

	dwSize = GetSystemDirectory(NULL, 0);
	pszTempDir = (char*) LocalAlloc(LPTR, dwSize);
	if (pszTempDir == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	GetSystemDirectoryA(pszTempDir, dwSize);

	strcpy(szTemp, pszTempDir);
	if (! StringEndsWith(pszTempDir, "\\", TRUE))
		strcat(szTemp, "\\");
	strcat(szTemp, szItemPath);

	LocalFree(pszTempDir);
	pszTempDir = NULL;

	hFind = FindFirstFile(szTemp, &founddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		// We found it, we're done.
		goto DONE;
	} // end if (couldn't find first file)



#pragma TODO(vanceo, "Check 16-bit system directory on NT")




	// Get the Windows directory and try that.

	dwSize = GetWindowsDirectory(NULL, 0);
	pszTempDir = (char*) LocalAlloc(LPTR, dwSize);
	if (pszTempDir == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	GetWindowsDirectoryA(pszTempDir, dwSize);

	strcpy(szTemp, pszTempDir);
	if (! StringEndsWith(pszTempDir, "\\", TRUE))
		strcat(szTemp, "\\");
	strcat(szTemp, szItemPath);

	LocalFree(pszTempDir);
	pszTempDir = NULL;

	hFind = FindFirstFile(szTemp, &founddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		// We found it, we're done.
		goto DONE;
	} // end if (couldn't find first file)



	// Get the PATH environment variable

	dwSize = GetEnvironmentVariable("PATH", NULL, 0);
	pszPathVar = (char*) LocalAlloc(LPTR, dwSize);
	if (pszPathVar == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	GetEnvironmentVariable("PATH", pszPathVar, dwSize);

	// It's okay to pass the string to split in as the output buffer because we don't
	// care if it gets destroyed.
	dwNumPaths = StringSplitIntoFields(pszPathVar, ";", pszPathVar, &dwSize);

	// Loop through all the paths in the environment variable
	for(dwTemp = 0; dwTemp < dwNumPaths; dwTemp++)
	{
		pszTempDir = StringGetFieldPtr(pszPathVar, dwTemp);

		strcpy(szTemp, pszTempDir);
		if (! StringEndsWith(pszTempDir, "\\", TRUE))
			strcat(szTemp, "\\");
		strcat(szTemp, szItemPath);

		pszTempDir = NULL;


		hFind = FindFirstFile(szTemp, &founddata);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			// We found it, we're done.
			goto DONE;
		} // end if (couldn't find first file)
	} // end for (each path)


	// If we got here, it means we didn't find it.
	hr = ERROR_FILE_NOT_FOUND;


DONE:

	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind); // ignore error
		hFind = INVALID_HANDLE_VALUE;
	} // end if (have find still open)

	if (pszPathVar != NULL)
	{
		LocalFree(pszPathVar);
		pszPathVar = NULL;
	} // end if (allocated string)

	if (pszTempDir != NULL)
	{
		LocalFree(pszTempDir);
		pszTempDir = NULL;
	} // end if (allocated string)

	if (hr == S_OK)
	{
		if (pszResultPath == NULL)
		{
			hr = ERROR_BUFFER_TOO_SMALL;
			(*pdwResultPathSize) = strlen(szTemp) + 1;
		} // end if (there's no buffer to copy to)
		else
		{
			strcpy(pszResultPath, szTemp);
		} // end else (there is a buffer to copy to)
	} // end if (we found the item)

	return (hr);
} // FileGetRealFilePath
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#ifndef _XBOX // not supported on Xbox
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileEnsureDirectoryExists()"
//==================================================================================
// FileEnsureDirectoryExists
//----------------------------------------------------------------------------------
//
// Description: Makes sure the specified directory and all parent directories
//				exist, creating them if necessary.
//
// Arguments:
//	char* szDirPath		Directory path to ensure.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileEnsureDirectoryExists(char* szDirPath)
{
	HRESULT		hr = S_OK;
	int			i;



	//BUGBUG what about paths enclosed in quotes?

	// If the path is a share, skip past the machine name and share directory.  If
	// it's local, skip past the drive.
	if (StringStartsWith(szDirPath, "\\\\", TRUE))
	{
		i = StringContainsChar(szDirPath, '\\',  TRUE, 2);
		if (i < 0)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't find share directory in \"%s\"!", 1, szDirPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			hr = ERROR_INVALID_PARAMETER;
			goto DONE;
		} // end if (there isn't a share directory)
	} // end if (the path is a share)
	else
	{
		i = 2; // start past the drive letter, and colon, and backslash
	} // end else (the path is not a share)


	// Keep looping through the path, making sure each directory exists.
	do
	{
		i = StringContainsChar(szDirPath, '\\', TRUE, i + 1);

		// If we found a directory delimiter, temporarily terminate the string at
		// that directory level
		if (i >= 0)
			szDirPath[i] = '\0';


		// Make sure the directory so far exists (if it already did, we're cool).
		if (_mkdir(szDirPath) == -1)
		{
			//hr = errno;
			hr = _doserrno;

			if (hr == ERROR_ALREADY_EXISTS)
				hr = S_OK;
		} // end if (failed creating directory)

		// Restore the path back to it's normal form.
		if (i >= 0)
			szDirPath[i] = '\\';

		// If it failed (but wasn't because it already exists), print out the
		// error and continue.
		// NOTE: This assumes the same error will happen again for subsequent
		// directories, so that the final directory attempted to be created will
		// also fail, and thus hr will not be S_OK when the function exits.
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(1, "NOTE: Failed creating directory \"%z\".  %e",
				3, szDirPath, i, hr);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
		} // end if (unknown failure)
	} // end do
	while (i > -1);


DONE:

	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "Failed ensuring directory \"%z\"!", 1, szDirPath);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW

	return (hr);
} // FileEnsureDirectoryExists
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#ifndef _XBOX // no file stuff
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileCompareFiles()"
//==================================================================================
// FileCompareFiles
//----------------------------------------------------------------------------------
//
// Description: Compares two files, and returns TRUE if they are the same file,
//				FALSE if not or an error occurred.  The files are compared by
//				dir/not dir attribute, modification date, file size, and optionally,
//				creation date.
//				NOTE: The filename is not checked.
//
// Arguments:
//	char* szFirstPath			Path to first item.
//	char* szSecondPath			Path to second item.
//	BOOL fCheckCreationTime		Whether file creation times must match or not.
//
// Returns: TRUE if they are the same file, FALSE otherwise.
//==================================================================================
BOOL FileCompareFiles(char* szFirstPath, char* szSecondPath, BOOL fCheckCreationTime)
{
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	HRESULT				hr;
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		firstdata;
	WIN32_FIND_DATA		seconddata;



	ZeroMemory(&firstdata, sizeof (WIN32_FIND_DATA));
	ZeroMemory(&seconddata, sizeof (WIN32_FIND_DATA));


	hFind = FindFirstFile(szFirstPath, &firstdata);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		hr = GetLastError();
		DPL(0, "Couldn't find first item (%s)!  %e", 2, szFirstPath, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/
		return (FALSE);
	} // end if (couldn't find first file)

	if (! FindClose(hFind))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		hr = GetLastError();
		DPL(0, "Couldn't close first find!  %e", 1, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (couldn't close find)
	//hFind = INVALID_HANDLE_VALUE;


	hFind = FindFirstFile(szSecondPath, &seconddata);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		hr = GetLastError();
		DPL(0, "Couldn't find second item (%s)!  %e", 2, szSecondPath, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/
		return (FALSE);
	} // end if (couldn't find first file)

	if (! FindClose(hFind))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		hr = GetLastError();
		DPL(0, "Couldn't close second find!  %e", 1, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (couldn't close find)
	hFind = INVALID_HANDLE_VALUE;



	if ((firstdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != (seconddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		return (FALSE);
	} // end if (directory attributes don't match)

	if (memcmp(&(firstdata.ftLastWriteTime), &(seconddata.ftLastWriteTime), sizeof (FILETIME)) != 0)
	{
		return (FALSE);
	} // end if (modification times don't match)

	if ((firstdata.nFileSizeHigh != seconddata.nFileSizeHigh) ||
		(firstdata.nFileSizeLow != seconddata.nFileSizeLow))
	{
		return (FALSE);
	} // end if (file sizes don't match)

	if (fCheckCreationTime)
	{
		if (memcmp(&(firstdata.ftCreationTime), &(seconddata.ftCreationTime), sizeof (FILETIME)) != 0)
		{
			return (FALSE);
		} // end if (creation times don't match)
	} // end if (file creation time is significant)

	return (TRUE);
} // FileCompareFiles
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no file stuff supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileCountFilesInDir()"
//==================================================================================
// FileCountFilesInDir
//----------------------------------------------------------------------------------
//
// Description: Counts the number of files in the given directory (and optionally,
//				its subdirectories).  Note that counting files in subdirectories
//				does not include the subdirectories themselves as part of that
//				number.
//				The value pointed to by lpdwCount must be initialized to zero.
//
// Arguments:
//	char* szDirPath				Path to directory containing files to count.
//	BOOL fCountSubdirectories	Whether to count files inside subdirectories as well.
//	DWORD* pdwCount			Place to store total.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileCountFilesInDir(char* szDirPath, BOOL fCountSubdirectories,
							DWORD* pdwCount)
{
	HRESULT				hr;
	HRESULT				temphr;
	DWORD				dwSize;
	char*				pszSearchPattern = NULL;
	DWORD				dwSubItemPathSize = 0;
	char*				pszSubItemPath = NULL;
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		finddata;


	if (szDirPath == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed invalid/NULL path!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed bad parameter)


	dwSize = strlen(szDirPath) + 4; // "*.*" + NULL termination

	// Make sure it ends in a backslash
	if (! StringEndsWith(szDirPath, "\\", TRUE))
		dwSize++;

	pszSearchPattern = (char*) LocalAlloc(LPTR, dwSize);
	if (pszSearchPattern == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszSearchPattern, szDirPath);

	if (! StringEndsWith(szDirPath, "\\", TRUE))
		strcat(pszSearchPattern, "\\");

	strcat(pszSearchPattern, "*.*");


	ZeroMemory(&finddata, sizeof (WIN32_FIND_DATA));

	hFind = FindFirstFile(pszSearchPattern, &finddata);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't find first item (%s)!", 1, pszSearchPattern);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't find first file)

	// This assumes the first item returned is the "." special directory
	while (FindNextFile(hFind, &finddata))
	{
		// Skip the ".." special directory, too.
		if (strcmp(finddata.cFileName, "..") == 0)
			continue;


		// Build the current source path

		// + room for possible extra backslash, and NULL termination.
		dwSize = strlen(szDirPath) + strlen(finddata.cFileName) + 2;

		// Make sure it ends in a backslash
		if (! StringEndsWith(szDirPath, "\\", TRUE))
			dwSize++;

		if (dwSize >= dwSubItemPathSize)
		{
			if (pszSubItemPath != NULL)
			{
				LocalFree(pszSubItemPath);
				pszSubItemPath = NULL;
			} // end if (had buffer before)

			pszSubItemPath = (char*) LocalAlloc(LPTR, dwSize);
			if (pszSubItemPath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
			dwSubItemPathSize = dwSize;
		} // end if (the buffer wasn't big enough before)

		strcpy(pszSubItemPath, szDirPath);

		if (! StringEndsWith(szDirPath, "\\", TRUE))
			strcat(pszSubItemPath, "\\");

		strcat(pszSubItemPath, finddata.cFileName);


		// Handle the item

		if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (fCountSubdirectories)
			{
				// Recursively call ourselves
				hr = FileCountFilesInDir(pszSubItemPath, fCountSubdirectories,
										pdwCount);
				if (hr != S_OK)
				{
					goto DONE;
				} // end if (a recursive call failed)
			} // end if (should apply to sub directories)
		} // end if (it's a directory)
		else
		{
			// Hey, here's a file, count it.
			(*pdwCount)++;
		} // end else (it's not a directory)
	} // end while (there are more items)

	// There was an error, so just make sure it's the right one.
	hr = GetLastError();

	if (hr == ERROR_NO_MORE_FILES)
		hr = S_OK;

	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Failed while searching for next item with \"%s\"!",
			1, pszSearchPattern);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end else (got unexpected error)


	if (! FindClose(hFind))
	{
		hr = GetLastError();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't close find!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't close find)
	hFind = INVALID_HANDLE_VALUE;


DONE:

	if (hFind != INVALID_HANDLE_VALUE)
	{
		if (! FindClose(hFind))
		{
			temphr = GetLastError();

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't close find!  %e", 1, temphr);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			if (hr == S_OK)
				hr = temphr;
		} // end if (couldn't close find)
		hFind = INVALID_HANDLE_VALUE;
	} // end if (there's an open find)

	if (pszSubItemPath != NULL)
	{
		LocalFree(pszSubItemPath);
		pszSubItemPath = NULL;
	} // end if (couldn't allocate memory)

	if (pszSearchPattern != NULL)
	{
		LocalFree(pszSearchPattern);
		pszSearchPattern = NULL;
	} // end if (couldn't allocate memory)

	return (hr);
} // FileCountFilesInDir
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileCopyTree()"
//==================================================================================
// FileCopyTree
//----------------------------------------------------------------------------------
//
// Description: Copies all files (including ones in subdirectories) from the source
//				path to the destination path.  The heirarchical structure is created
//				if it doesn't exist.
//
// Arguments:
//	char* szSourceDirPath		Path to root source directory.
//	char* szDestDirPath			Path to root destination directory.
//	DWORD dwOptions				Options for copying the tree, see FILECTO_xxx.
//	PLSTRINGLIST pSkipFiles		Optional list of filepaths (may use wildcard
//								charactesr) to skip, see linkedstr.cpp for more.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileCopyTree(char* szSourceDirPath, char* szDestDirPath, DWORD dwOptions,
					 PLSTRINGLIST pSkipFiles)
{
	HRESULT			hr;
	BOOL			fChoppedOffSourceBackslash = FALSE;
	BOOL			fChoppedOffDestBackslash = FALSE;
	COPYTREEDATA	ctd;
	HANDLE			hProgressThread = NULL;


	ZeroMemory(&ctd, sizeof (COPYTREEDATA));
	//ctd.fSkip = FALSE;
	ctd.dwOptions = dwOptions;
	ctd.pSkipFiles = pSkipFiles;
	//ctd.dwNumFilesHandled = 0;
	//ctd.dwTotalNumFiles = 0;
	//ctd.hProgressWindow = NULL;


	if ((szSourceDirPath == NULL) || (szDestDirPath == NULL))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed invalid/NULL parameters!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed bad parameters)


	// Make sure the caller didn't specify more than one of these, cause that's
	// bogus.
	if ((dwOptions & FILECTO_FAIL_IF_EXISTS) &&
		(dwOptions & FILECTO_FORCE_COPY_IF_SAME) &&
		(dwOptions & FILECTO_EMPTY_COPIED_DIRS))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Must specify only one of FILECTO_FAIL_IF_EXISTS, FILECTO_FORCE_COPY_IF_SAME and FILECTO_EMPTY_COPIED_DIRS!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed bad parameters)


#ifndef NO_FILEUTILS_COPYTREEPROGRESS
	if (dwOptions & FILECTO_DISPLAY_PROGRESS_BAR)
	{
		DWORD	dwThreadID;


		hr = FileCountFilesInDir(szSourceDirPath, TRUE, &(ctd.dwTotalNumFiles));
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Failed counting number of files in \"%s\"!",
				1, szSourceDirPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (failed to count files)

		ctd.hProgressThreadStartedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (ctd.hProgressThreadStartedEvent == NULL)
		{
			hr = GetLastError();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't create progress thread started event!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't create thread)

		hProgressThread = CreateThread(NULL, 0, CopyTreeProgressThreadProc, &ctd,
										0, &dwThreadID);
		if (hProgressThread == NULL)
		{
			hr = GetLastError();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't create CopyTreeProgress thread!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't create thread)

		hr = WaitForSingleObject(ctd.hProgressThreadStartedEvent, INFINITE);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Thread is ready
				hr = S_OK;
			  break;

			default:
				// Something wacky happened
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "WaitForSingleObject for progress thread to startup returned a wacky result!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			  break;
		} // end switch (on waiting for thread to start up)

		CloseHandle(ctd.hProgressThreadStartedEvent);
		ctd.hProgressThreadStartedEvent = NULL;
	} // end if (a progress bar should be displayed
#endif // ! NO_FILEUTILS_COPYTREEPROGRESS

	if (StringEndsWith(szSourceDirPath, "\\", TRUE))
	{
		szSourceDirPath[strlen(szSourceDirPath) - 1] = '\0';
		fChoppedOffSourceBackslash = TRUE;
	} // end if (source path ends in backslash)

	if (StringEndsWith(szDestDirPath, "\\", TRUE))
	{
		szDestDirPath[strlen(szDestDirPath) - 1] = '\0';
		fChoppedOffDestBackslash = TRUE;
	} // end if (dest path ends in backslash)


	hr = CopyTreeInternal(szSourceDirPath, szDestDirPath, &ctd);
	if (hr != S_OK)
	{
		DPL(0, "Failed copying tree \"%s\" to \"%s\"!",
			2, szSourceDirPath, szDestDirPath);
		goto DONE;
	} // end if (failed to copy tree)

	if (hProgressThread != NULL)
	{
		if (ctd.hProgressWindow != NULL)
		{
			// Tell the window to go bye-bye
			PostMessage(ctd.hProgressWindow, WM_CLOSE, 0, 0);
		} // end if (there's a progress window)

		// Wait for thread to die
		hr = WaitForSingleObject(hProgressThread, INFINITE);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Thread is gone, get exit code
				if (! GetExitCodeThread(hProgressThread, (LPDWORD) (&hr)))
				{
					hr = GetLastError();
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Couldn't get exit code for progress thread!", 0);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW
					goto DONE;
				} // end if (couldn't get thread exit code)
			  break;

			default:
				// Something wacky happened
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "WaitForSingleObject for progress thread to startup returned a wacky result!", 0);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			  break;
		} // end switch (on waiting for thread to start up)

		CloseHandle(hProgressThread);
		hProgressThread = NULL;
	} // end if (there's an event)


DONE:

	if (ctd.hProgressThreadStartedEvent != NULL)
	{
		CloseHandle(ctd.hProgressThreadStartedEvent);
		ctd.hProgressThreadStartedEvent = NULL;
	} // end if (there's an event)

	if (fChoppedOffSourceBackslash)
	{
		szSourceDirPath[strlen(szSourceDirPath)] = '\\';
		fChoppedOffSourceBackslash = FALSE;
	} // end if (couldn't allocate memory)

	if (fChoppedOffDestBackslash)
	{
		szDestDirPath[strlen(szDestDirPath)] = '\\';
		fChoppedOffDestBackslash = FALSE;
	} // end if (couldn't allocate memory)

	return (hr);
} // FileCopyTree
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no file copy stuff
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileCleanDirectory()"
//==================================================================================
// FileCleanDirectory
//----------------------------------------------------------------------------------
//
// Description: Removes all files from the given directory.  If fDeleteDirectory is
//				TRUE, the directory will be deleted after cleaning. If
//				fApplyToSubDirs is TRUE, all files from subdirectories are deleted
//				(and the subdirs are removed, if fDeleteDirectory is specified).
//				If fDeleteDirectory is TRUE, but fApplyToSubDirs is FALSE and there
//				are subdirectories, this call will fail when trying to remove the
//				directory.
//				If fDeleteDirectory is FALSE, then this call will fail if the
//				directory doesn't exist.
//
// Arguments:
//	char* szDirPath			Path to root source directory.
//	BOOL fDeleteDirectory	Path to root destination directory.
//	BOOL fApplyToSubDirs	Whether to do the same thing to any subdirectories.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileCleanDirectory(char* szDirPath, BOOL fDeleteDirectory, BOOL fApplyToSubDirs)
{
	HRESULT				hr;
	HRESULT				temphr;
	DWORD				dwSize;
	char*				pszSearchPattern = NULL;
	DWORD				dwSubItemPathSize = 0;
	char*				pszSubItemPath = NULL;
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		finddata;


	if (szDirPath == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed invalid/NULL path!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed bad parameter)


	dwSize = strlen(szDirPath) + 4; // "*.*" + NULL termination

	// Make sure it ends in a backslash
	if (! StringEndsWith(szDirPath, "\\", TRUE))
		dwSize++;

	pszSearchPattern = (char*) LocalAlloc(LPTR, dwSize);
	if (pszSearchPattern == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszSearchPattern, szDirPath);

	if (! StringEndsWith(szDirPath, "\\", TRUE))
		strcat(pszSearchPattern, "\\");

	strcat(pszSearchPattern, "*.*");


	ZeroMemory(&finddata, sizeof (WIN32_FIND_DATA));

	hFind = FindFirstFile(pszSearchPattern, &finddata);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();


		// If the directory doesn't exist but we would have deleted it anyway, then
		// that's okay.
		if ((hr == ERROR_PATH_NOT_FOUND) && (fDeleteDirectory))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(1, "\"%s\" doesn't exist, but we would have deleted it anyway.",
				1, szDirPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			hr = S_OK;
		} // end if (directory doesn't exist but we'd delete it)
		else
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't find first item (%s)!", 1, pszSearchPattern);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
		} // end else (other error)

		goto DONE;
	} // end if (couldn't find first file)

	// This assumes the first item returned is the "." special directory
	while (FindNextFile(hFind, &finddata))
	{
		// Skip the ".." special directory, too.
		if (strcmp(finddata.cFileName, "..") == 0)
			continue;


		// Build the current source path

		// + room for possible extra backslash, and NULL termination.
		dwSize = strlen(szDirPath) + strlen(finddata.cFileName) + 2;

		// Make sure it ends in a backslash
		if (! StringEndsWith(szDirPath, "\\", TRUE))
			dwSize++;

		if (dwSize >= dwSubItemPathSize)
		{
			if (pszSubItemPath != NULL)
			{
				LocalFree(pszSubItemPath);
				pszSubItemPath = NULL;
			} // end if (had buffer before)

			pszSubItemPath = (char*) LocalAlloc(LPTR, dwSize);
			if (pszSubItemPath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
			dwSubItemPathSize = dwSize;
		} // end if (the buffer wasn't big enough before)

		strcpy(pszSubItemPath, szDirPath);

		if (! StringEndsWith(szDirPath, "\\", TRUE))
			strcat(pszSubItemPath, "\\");

		strcat(pszSubItemPath, finddata.cFileName);


		// Handle the item

		if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (fApplyToSubDirs)
			{
				// Recursively call ourselves
				hr = FileCleanDirectory(pszSubItemPath, fDeleteDirectory,
										fApplyToSubDirs);
				if (hr != S_OK)
				{
					goto DONE;
				} // end if (a recursive call failed)
			} // end if (should apply to sub directories)
		} // end if (it's a directory)
		else
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(1, "Deleting file \"%s\".", 1, pszSubItemPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			if (! DeleteFile(pszSubItemPath))
			{
				hr = GetLastError();

				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't delete file \"%s\"!", 1, pszSubItemPath);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

				goto DONE;
			} // end if (couldn't delete file)
		} // end else (it's not a directory)
	} // end while (there are more items)

	// There was an error, so just make sure it's the right one.
	hr = GetLastError();

	if (hr == ERROR_NO_MORE_FILES)
		hr = S_OK;

	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Failed while searching for next item with \"%s\"!",
			1, pszSearchPattern);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end else (got unexpected error)


	if (! FindClose(hFind))
	{
		hr = GetLastError();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't close find!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't close find)
	hFind = INVALID_HANDLE_VALUE;

	// If we should delete the directory, too.
	if (fDeleteDirectory)
	{
		//if (! DeleteFile(szDirPath))
		if (_rmdir(szDirPath) == -1)
		{
			//hr = GetLastError();
			//hr = errno;
			hr = _doserrno;

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't delete directory \"%s\" (make sure it's not the current working directory)!",
				1, szDirPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			goto DONE;
		} // end if (couldn't delete file)
	} // end if (we should delete the directory)



DONE:

	if (hFind != INVALID_HANDLE_VALUE)
	{
		if (! FindClose(hFind))
		{
			temphr = GetLastError();

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't close find!  %e", 1, temphr);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			if (hr == S_OK)
				hr = temphr;
		} // end if (couldn't close find)
		hFind = INVALID_HANDLE_VALUE;
	} // end if (there's an open find)

	if (pszSubItemPath != NULL)
	{
		LocalFree(pszSubItemPath);
		pszSubItemPath = NULL;
	} // end if (couldn't allocate memory)

	if (pszSearchPattern != NULL)
	{
		LocalFree(pszSearchPattern);
		pszSearchPattern = NULL;
	} // end if (couldn't allocate memory)

	return (hr);
} // FileCleanDirectory
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // No creating files
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileCreateAndOpenFile()"
//==================================================================================
// FileCreateAndOpenFile
//----------------------------------------------------------------------------------
//
// Description: Creates a file (using the given options) at the path specified and
//				returns the handle to the file in the given pointer.
//				It is up to the caller to close the file when done by calling
//				CloseHandle on the value returned.
//				If file tracking is on, then this item is added to the list.
//
// Arguments:
//	char* szFilepath			Path of text file to create/open.
//	BOOL fFailIfExists			Whether to return an error if a file already exists
//								at that location.
//	BOOL fAppend				Whether to add to the file if one already exists at
//								that location.  Ignored if fFailIfExists is
//								specified.
//	BOOL fInheritableHandle		Whether the file handle can be inherited by child
//								processes or not.
//	HANDLE* phFile				Pointer to receive handle of file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileCreateAndOpenFile(char* szFilepath, BOOL fFailIfExists, BOOL fAppend,
							BOOL fInheritableHandle, HANDLE* phFile)
{
	HRESULT					hr;
	char*					pszRealFilepath = NULL;
	DWORD					dwSize = 0;
	DWORD					dwDisp;
	SECURITY_ATTRIBUTES		sa;


	if (phFile == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Must pass a valid pointer to store file handle!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (handle pointer is NULL)


	// Ignore error, assume BUFFER_TOO_SMALL.
	FileGetRealFilePath(szFilepath, FALSE, NULL, &dwSize);

	pszRealFilepath = (char*) LocalAlloc(LPTR, dwSize);
	if (pszRealFilepath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	hr = FileGetRealFilePath(szFilepath, FALSE, pszRealFilepath, &dwSize);
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't get real file path of \"%s\"!", 1, szFilepath);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (failed getting filepath)


	dwDisp = CREATE_ALWAYS;
	if (fFailIfExists)
		dwDisp = CREATE_NEW;
	else if (fAppend)
		dwDisp = OPEN_ALWAYS;



	ZeroMemory(&sa, sizeof (SECURITY_ATTRIBUTES));
	sa.nLength = sizeof (SECURITY_ATTRIBUTES);
	sa.bInheritHandle = fInheritableHandle;
	sa.lpSecurityDescriptor = NULL;


	(*phFile) = CreateFile(pszRealFilepath, GENERIC_WRITE, FILE_SHARE_READ, &sa,
							dwDisp, 0, NULL);
	if ((*phFile) == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't create file \"%s\"!", 1, pszRealFilepath);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't open file)

	// If we should append to the file, move to the end
	if (fAppend)
	{
		if (SetFilePointer((*phFile), 0, NULL, FILE_END) == 0xFFFFFFFF)
		{
			hr = GetLastError();

			if (hr == S_OK)
				hr = E_FAIL;

			CloseHandle((*phFile));
			(*phFile) = INVALID_HANDLE_VALUE;

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't set file pointer to end of file!", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			goto DONE;
		} // end if (couldn't set file pointer)
	} // end if (should append to the file)


	if (g_pTrackedFiles != NULL)
	{
		hr = g_pTrackedFiles->AddString(pszRealFilepath);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "WARNING: Couldn't add \"%s\" to tracked list!",
				1, pszRealFilepath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			goto DONE;
		} // end if (couldn't add string)
	} // end if (we're tracking files)


DONE:

	if (pszRealFilepath != NULL)
	{
		LocalFree(pszRealFilepath);
		pszRealFilepath = NULL;
	} // end if (allocated string)

	return (hr);
} // FileCreateAndOpenFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no file stuff
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileWriteString()"
//==================================================================================
// FileWriteString
//----------------------------------------------------------------------------------
//
// Description: Writes the string to the given (already opened) file.
//
// Arguments:
//	HANDLE hFile		File to write to.
//	char* szString		String to write.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileWriteString(HANDLE hFile, char* szString)
{
	HRESULT		hr = S_OK;
	DWORD		dwBytesWritten;
#ifndef NO_TNCOMMON_DEBUG_SPEW
	char		szTemp[256];
#endif // ! NO_TNCOMMON_DEBUG_SPEW


	// If the string is useless, we're done
	if ((szString == NULL) || (strlen(szString) < 1))
		return (S_OK);


	if (! WriteFile(hFile, szString, strlen(szString), &dwBytesWritten, NULL))
	{
		hr = GetLastError();

#ifndef NO_TNCOMMON_DEBUG_SPEW
		// Can't use DPL because it may be calling us.
		OutputDebugString("Couldn't write string \"");
		OutputDebugString(szString);
		wsprintf(szTemp, "\" to file 0x" SPRINTF_PTR ", hr = 0x%08x\n", hFile, hr);
		OutputDebugString(szTemp);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (couldn't write file)

	return (hr);
} // FileWriteString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no file stuff
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileSprintfWriteString()"
//==================================================================================
// FileSprintfWriteString
//----------------------------------------------------------------------------------
//
// Description: Writes the string to the given (already opened) file.  Any tokens in
//				the string are replaced as appropriate.  See sprintf for valid
//				tokens.
//
// Arguments:
//	HANDLE hFile			File to write to.
//	char* szFormatString	String with tokens to write.
//	DWORD dwNumParms		Number of items in the following variable parameter
//							list.
//	...						Variable parameter list with values to replace tokens
//							with.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileSprintfWriteString(HANDLE hFile, char* szFormatString, DWORD dwNumParms, ...)
{
	HRESULT		hr = S_OK;
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		dwTemp;
	char*		pszTemp = NULL;
	DWORD		dwBytesWritten;
#ifndef NO_TNCOMMON_DEBUG_SPEW
	char		szTemp[256];
#endif // ! NO_TNCOMMON_DEBUG_SPEW



	// If the string is useless, we're done
	if ((szFormatString == NULL) || (strlen(szFormatString) < 1))
		goto DONE;

	papvParms = (LPVOID*) LocalAlloc(LPTR, dwNumParms * sizeof (PVOID));
	if (papvParms == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Loop through the variable arguments and put them into an array for passing
	// to sprintf.
	va_start(currentparam, dwNumParms);
	for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
	{
		papvParms[dwTemp] = va_arg(currentparam, PVOID);
	} // end for (each variable parameter)
	va_end(currentparam);

	TNsprintf_array(&pszTemp, szFormatString, dwNumParms, papvParms);

	if (! WriteFile(hFile, pszTemp, strlen(pszTemp), &dwBytesWritten, NULL))
	{
		hr = GetLastError();

#ifndef NO_TNCOMMON_DEBUG_SPEW
		// Can't use DPL because it may be calling us.
		OutputDebugString("Couldn't sprintf write string \"");
		OutputDebugString(pszTemp);
		wsprintf(szTemp, "\" to file 0x" SPRINTF_PTR ", hr = 0x%08x\n", hFile, hr);
		OutputDebugString(szTemp);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (couldn't write file)


DONE:

	if (papvParms != NULL)
	{
		LocalFree(papvParms);
		papvParms = NULL;
	} // end if (allocated param list)

	if (pszTemp != NULL)
		TNsprintf_free(&pszTemp);

	return (hr);
} // FileSprintfWriteString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no file stuff
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileWriteLine()"
//==================================================================================
// FileWriteLine
//----------------------------------------------------------------------------------
//
// Description: Writes the string to the given (already opened) file, and places the
//				carriage-return/newline combination after it.  If the pointer is
//				NULL or the string is empty, just the carriage-return and newline
//				are printed.
//
// Arguments:
//	HANDLE hFile		File to write to.
//	char* pszString	Pointer to string to write.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileWriteLine(HANDLE hFile, char* pszString)
{
	HRESULT		hr = S_OK;
	char*		pszTemp = NULL;
	DWORD		dwTempSize = 3; // cr + newline + NULL termination
	DWORD		dwBytesWritten;
#ifndef NO_TNCOMMON_DEBUG_SPEW
	char		szTemp[256];
#endif // ! NO_TNCOMMON_DEBUG_SPEW


	// We allocate a temp string because we want the line to be printed atomically.

	if ((pszString != NULL) && (strlen(pszString) > 0))
		dwTempSize += strlen(pszString);


	pszTemp = (char*) LocalAlloc(LPTR, dwTempSize);
	if (pszTemp == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate memory)

	if (pszString != NULL)
		strcpy(pszTemp, pszString);

	strcat(pszTemp, "\r\n");

	if (! WriteFile(hFile, pszTemp, strlen(pszTemp), &dwBytesWritten, NULL))
	{
		hr = GetLastError();

#ifndef NO_TNCOMMON_DEBUG_SPEW
		// Can't use DPL because it may be calling us.
		OutputDebugString("Couldn't write line \"");
		OutputDebugString(pszTemp);
		wsprintf(szTemp, "\" to file 0x" SPRINTF_PTR ", hr = 0x%08x\n", hFile, hr);
		OutputDebugString(szTemp);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (couldn't write file)

	LocalFree(pszTemp);
	pszTemp = NULL;

	return (hr);
} // FileWriteLine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no file stuff
#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileSprintfWriteLine()"
//==================================================================================
// FileSprintfWriteLine
//----------------------------------------------------------------------------------
//
// Description: Writes the string to the given (already opened) file.  Any tokens in
//				the string are replaced as appropriate.  See sprintf for valid
//				tokens.
//
// Arguments:
//	HANDLE hFile			File to write to.
//	char* szFormatString	String with tokens to write.
//	DWORD dwNumParms		Number of items in the following variable parameter
//							list.
//	...						Variable parameter list with values to replace tokens
//							with.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileSprintfWriteLine(HANDLE hFile, char* szFormatString, DWORD dwNumParms, ...)
{
	HRESULT		hr = S_OK;
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		dwTemp;
	char*		pszOutput = NULL;
#ifndef NO_TNCOMMON_DEBUG_SPEW
	char		szTemp[256];
#endif // ! NO_TNCOMMON_DEBUG_SPEW


	if ((szFormatString == NULL) && (strlen(szFormatString) < 1))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Won't write NULL or empty string to file %x!", 1, hFile);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got handed NULL or empty string)

	papvParms = (PVOID*) LocalAlloc(LPTR, dwNumParms * sizeof (PVOID));
	if (papvParms == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Loop through the variable arguments and put them into an array for passing
	// to sprintf.
	va_start(currentparam, dwNumParms);
	for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
	{
		papvParms[dwTemp] = va_arg(currentparam, PVOID);
	} // end for (each variable parameter)
	va_end(currentparam);

	TNsprintf_array(&pszOutput, szFormatString, dwNumParms, papvParms);

	hr = FileWriteLine(hFile, pszOutput);
#ifndef NO_TNCOMMON_DEBUG_SPEW
	if (hr != S_OK)
	{
		// Can't use DPL because it may be calling us.
		OutputDebugString("Couldn't sprintf write line \"");
		OutputDebugString(pszOutput);
		wsprintf(szTemp, "\" to file 0x" SPRINTF_PTR ", hr = 0x%08x\n", hFile, hr);
		OutputDebugString(szTemp);
	} // end if (couldn't write line)
#endif // ! NO_TNCOMMON_DEBUG_SPEW


DONE:

	if (papvParms != NULL)
	{
		LocalFree(papvParms);
		papvParms = NULL;
	} // end if (allocated param list)

	TNsprintf_free(&pszOutput);

	return (hr);
} // FileSprintfWriteLine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileStartTrackingOutputFiles()"
//==================================================================================
// FileStartTrackingOutputFiles
//----------------------------------------------------------------------------------
//
// Description: Begins saving the paths for all files created using routines in this
//				file.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileStartTrackingOutputFiles(void)
{
	HRESULT		hr = S_OK;


	//BUGBUG not thread safe
	if (g_pTrackedFiles != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "WARNING: Already tracking output files.", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (we're already tracking)

	g_pTrackedFiles = new (CLStringList);


DONE:

	return (hr);
} // FileStartTrackingOutputFiles
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileGetOutputFilesArray()"
//==================================================================================
// FileGetOutputFilesArray
//----------------------------------------------------------------------------------
//
// Description: Stops saving the paths for all created files and frees the memory
//				allocated.  If lpapszArray is NULL, the number of entries required
//				to hold the array is placed in lpdwMaxNumEntries, and
//				ERROR_BUFFER_TOO_SMALL is returned.	
//
// Arguments:
//	BOOL fIgnoreDuplicates		Whether to not include duplicates (files whose paths
//								match exactly) only once in the list.
//	char** papszArray			Array to store list in, or NULL to retrieve num
//								entries required.
//	DWORD* pdwMaxNumEntries		Pointer to number of entries in preceding array, or
//								place to store num required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileGetOutputFilesArray(BOOL fIgnoreDuplicates, char** papszArray,
								DWORD* pdwMaxNumEntries)
{
	HRESULT		hr = S_OK;
	int			i;
	DWORD		dwNumEntries = 0;
	PLSTRING	pItem;
	LLIST		usedlist;


	if (g_pTrackedFiles == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Not currently tracking output files!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (not currently tracking files)


	g_pTrackedFiles->EnterCritSection();

	for(i = 0; i < g_pTrackedFiles->Count(); i++)
	{
		pItem = (PLSTRING) g_pTrackedFiles->GetItem(i);
		if (pItem == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't add alias to item %x to used list!", 1, pItem);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't add item to used list)


		// If we should ignore duplicates, make sure we haven't used this item already
		if (fIgnoreDuplicates)
		{
			// If we've already found this item, skip it
			if (usedlist.GetFirstIndex(pItem) >= 0)
				continue;

			// Add an alias to it to our used list.
			hr = usedlist.Add(pItem);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't add alias to item %x to used list!", 1, pItem);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

				goto DONE;
			} // end if (couldn't add item to used list)
		} // end if (we should ignore duplicates)

		if (papszArray != NULL)
			papszArray[dwNumEntries] = pItem->GetString();

		dwNumEntries++;
	} // end for (each entry)


DONE:

	g_pTrackedFiles->LeaveCritSection();

	if ((hr == S_OK) && (papszArray == NULL))
	{
		(*pdwMaxNumEntries) = dwNumEntries;
		hr = ERROR_BUFFER_TOO_SMALL;
	} // end if (just retrieving size)

	return (hr);
} // FileGetOutputFilesArray
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"FileStopTrackingOutputFiles()"
//==================================================================================
// FileStopTrackingOutputFiles
//----------------------------------------------------------------------------------
//
// Description: Stops saving the paths for all created files and frees the memory
//				allocated.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT FileStopTrackingOutputFiles(void)
{
	HRESULT			hr;
	PLSTRINGLIST	pList;


	pList = g_pTrackedFiles;
	g_pTrackedFiles = NULL;

	if (pList == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "WARNING: Not currently tracking output files.", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (S_OK);
	} // end if (not currently tracking files)

	hr = pList->RemoveAll();
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't remove all tracked files from the list!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (not currently tracking files)

	delete (pList);
	pList = NULL;

	return (hr);
} // FileStopTrackingOutputFiles
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CopyTreeInternal()"
//==================================================================================
// CopyTreeInternal
//----------------------------------------------------------------------------------
//
// Description: Internal function that copies all files (including ones in
//				subdirectories) from the source path to the destination path.  The
//				heirarchical structure is created if it doesn't exist.
//
// Arguments:
//	char* szSourceDirPath			Path to root source directory.  Must not end in
//									a backslash.
//	char* szDestDirPath				Path to root destination directory.  Must not
//									end in a backslash.
//	PCOPYTREEDATA pCopyTreeData		Pointer to additional parameter data to use
//									when copying.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CopyTreeInternal(char* szSourceDirPath, char* szDestDirPath,
						PCOPYTREEDATA pCopyTreeData)
{
	HRESULT				hr;
	HRESULT				temphr;
	DWORD				dwSize;
	char*				pszSearchPattern = NULL;
	DWORD				dwSubItemSourcePathSize = 0;
	char*				pszSubItemSourcePath = NULL;
	DWORD				dwSubItemDestPathSize = 0;
	char*				pszSubItemDestPath = NULL;
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		finddata;
	BOOL				fPreparedDirectory = FALSE;
	BOOL				fSkip;


	// 5 = "\*.*" + NULL termination
	pszSearchPattern = (char*) LocalAlloc(LPTR, strlen(szSourceDirPath) + 5);
	if (pszSearchPattern == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszSearchPattern, szSourceDirPath);
	strcat(pszSearchPattern, "\\*.*");


	ZeroMemory(&finddata, sizeof (WIN32_FIND_DATA));

	hFind = FindFirstFile(pszSearchPattern, &finddata);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't find first item (%s)!", 1, pszSearchPattern);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't find first file)


	// If we're not skipping this entire directory and we're supposed to copy
	// empty directories, we can just go ahead and make it now.
	if ((! pCopyTreeData->fSkip) &&
		(pCopyTreeData->dwOptions & FILECTO_COPY_EMPTY_DIRS))
	{
		hr = FileEnsureDirectoryExists(szDestDirPath);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't make sure \"%s\" exists!", 1, szDestDirPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			goto DONE;
		} // end if (couldn't make sure destination directory exists)

		fPreparedDirectory = TRUE;

		if (pCopyTreeData->dwOptions & FILECTO_EMPTY_COPIED_DIRS)
		{
			hr = FileCleanDirectory(szDestDirPath, FALSE, FALSE);
			if (hr != S_OK)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't empty \"%s\"!", 1, szDestDirPath);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW
				goto DONE;
			} // end if (couldn't clean the directory)
		} // end if (should empty directory)
	} // end if (should always copy the directory)

	// This assumes the first item returned is the "." special directory
	while (FindNextFile(hFind, &finddata))
	{
		// Skip the ".." special directory, too.
		if (strcmp(finddata.cFileName, "..") == 0)
			continue;


		// If we're not skipping everything in this directory, start by
		// assuming we won't skip this item either.
		fSkip = pCopyTreeData->fSkip;


		// Build the current source path

		// + backslash, NULL termination, and room for possible extra backslash.
		dwSize = strlen(szSourceDirPath) + strlen(finddata.cFileName) + 3;
		if (dwSize >= dwSubItemSourcePathSize)
		{
			if (pszSubItemSourcePath != NULL)
			{
				LocalFree(pszSubItemSourcePath);
				pszSubItemSourcePath = NULL;
			} // end if (had buffer before)

			pszSubItemSourcePath = (char*) LocalAlloc(LPTR, dwSize);
			if (pszSubItemSourcePath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
			dwSubItemSourcePathSize = dwSize;
		} // end if (the buffer wasn't big enough before)

		strcpy(pszSubItemSourcePath, szSourceDirPath);
		strcat(pszSubItemSourcePath, "\\");
		strcat(pszSubItemSourcePath, finddata.cFileName);


		// Mark this for skipping the file if it's in the list and we're
		// not already skipping.
		if ((! fSkip) && (pCopyTreeData->pSkipFiles != NULL))
		{
			// If it's a directory, we temporarily add a backslash (don't worry we
			// made room up above) for easier filtering.
			if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				strcat(pszSubItemSourcePath, "\\");


			fSkip = pCopyTreeData->pSkipFiles->ContainsMatchingWildcardForString(pszSubItemSourcePath,
																				FALSE);
			if (fSkip)
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(1, "\"%s\" matches a pattern, skipping.",
					1, pszSubItemSourcePath);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

#ifndef NO_FILEUTILS_COPYTREEPROGRESS
				// If we don't need to update the progress, we can just move on
				// right now.
				if (! (pCopyTreeData->dwOptions & FILECTO_DISPLAY_PROGRESS_BAR))
#endif // ! NO_FILEUTILS_COPYTREEPROGRESS
					continue;
			} // end if (matched item)

			// Remove that backslash if we had one
			if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				pszSubItemSourcePath[strlen(pszSubItemSourcePath) - 1] = '\0';
		} // end if (there's a list of files to skip)


		// Build the current destination path

		dwSize = strlen(szDestDirPath) + strlen(finddata.cFileName) + 2;
		if (dwSize >= dwSubItemDestPathSize)
		{
			if (pszSubItemDestPath != NULL)
			{
				LocalFree(pszSubItemDestPath);
				pszSubItemDestPath = NULL;
			} // end if (had buffer before)

			pszSubItemDestPath = (char*) LocalAlloc(LPTR, dwSize);
			if (pszSubItemDestPath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
			dwSubItemDestPathSize = dwSize;
		} // end if (the buffer wasn't big enough before)

		strcpy(pszSubItemDestPath, szDestDirPath);
		strcat(pszSubItemDestPath, "\\");
		strcat(pszSubItemDestPath, finddata.cFileName);


		// Handle the item

		if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			BOOL	fSkipDir;


			// Save the old skip boolean.
			fSkipDir = pCopyTreeData->fSkip;
			// Pass the new one into the function.
			pCopyTreeData->fSkip = fSkip;

			// Recursively call ourselves
			hr = CopyTreeInternal(pszSubItemSourcePath, pszSubItemDestPath,
								pCopyTreeData);
			if (hr != S_OK)
			{
				goto DONE;
			} // end if (a recursive call failed)

			pCopyTreeData->fSkip = fSkipDir;
		} // end if (it's a directory)
		else
		{
			// If we got here, but we're skipping, then we just need to update the
			// progress bar)
			if (fSkip)
			{
#ifdef DEBUG
#ifndef NO_FILEUTILS_COPYTREEPROGRESS
				if (! (pCopyTreeData->dwOptions & FILECTO_DISPLAY_PROGRESS_BAR))
				{
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(1, "How did we get to skip the item processing but we're not displaying progress (item = \"%s\")!?",
						1, pszSubItemSourcePath);
					#endif // NO_TNCOMMON_DEBUG_SPEW

					hr = ERROR_BAD_ENVIRONMENT;
					goto DONE;
				} // end if (not displaying progress)
#endif // ! NO_FILEUTILS_COPYTREEPROGRESS
#endif // DEBUG
				// Update the handled count.
				pCopyTreeData->dwNumFilesHandled++;

				// Update the UI.
				if (pCopyTreeData->hProgressWindow != NULL)
				{
					SetWindowText(GetDlgItem(pCopyTreeData->hProgressWindow, IDT_CURRENTSOURCE),
								pszSubItemSourcePath);

					// Since we're not copying it, make a note of that.
					SetWindowText(GetDlgItem(pCopyTreeData->hProgressWindow, IDT_CURRENTDEST),
								"(not copied)");

					SendMessage(GetDlgItem(pCopyTreeData->hProgressWindow, IDPB_PROGRESSBAR),
								PBM_SETPOS, pCopyTreeData->dwNumFilesHandled, 0);
				} // end if (there's a window)

				// Move on
				continue;
			} // end if (skipping file)

			// If the user doesn't want to re-copy files that are the same or clean
			// the directory prior to copying, check if the file already exists and
			// matches.  If so, then skip it.
			if ((! (pCopyTreeData->dwOptions & (FILECTO_FORCE_COPY_IF_SAME | FILECTO_EMPTY_COPIED_DIRS))) &&
				(FileCompareFiles(pszSubItemSourcePath, pszSubItemDestPath, FALSE)))
			{
				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(1, "\"%s\" is the same as \"%s\", skipping.",
					2, pszSubItemSourcePath, pszSubItemDestPath);
				#endif // NO_TNCOMMON_DEBUG_SPEW
				continue;
			} // end if (files are same and we don't copy those)


			// Since we're actually copying a file, make sure the destination
			// directory exists if we haven't already.
			if (! fPreparedDirectory)
			{
				hr = FileEnsureDirectoryExists(szDestDirPath);
				if (hr != S_OK)
				{
					#ifndef NO_TNCOMMON_DEBUG_SPEW
					DPL(0, "Couldn't make sure \"%s\" exists!", 1, szDestDirPath);
					#endif // ! NO_TNCOMMON_DEBUG_SPEW
					goto DONE;
				} // end if (couldn't make sure destination directory exists)

				fPreparedDirectory = TRUE;

				if (pCopyTreeData->dwOptions & FILECTO_EMPTY_COPIED_DIRS)
				{
					hr = FileCleanDirectory(szDestDirPath, FALSE, FALSE);
					if (hr != S_OK)
					{
						#ifndef NO_TNCOMMON_DEBUG_SPEW
						DPL(0, "Couldn't empty \"%s\"!", 1, szDestDirPath);
						#endif // ! NO_TNCOMMON_DEBUG_SPEW
						goto DONE;
					} // end if (couldn't clean the directory)
				} // end if (should empty directory)
			} // end if (haven't ensured directory yet)

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(1, "Copying file \"%s\" to \"%s\".",
				2, pszSubItemSourcePath, pszSubItemDestPath);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW


#ifndef NO_FILEUTILS_COPYTREEPROGRESS
			// Update the progress bar, if we're doing that
			if (pCopyTreeData->dwOptions & FILECTO_DISPLAY_PROGRESS_BAR)
			{
				// Update the handled count.
				pCopyTreeData->dwNumFilesHandled++;

				// Update the UI.
				if (pCopyTreeData->hProgressWindow != NULL)
				{
					SetWindowText(GetDlgItem(pCopyTreeData->hProgressWindow, IDT_CURRENTSOURCE),
								pszSubItemSourcePath);

					SetWindowText(GetDlgItem(pCopyTreeData->hProgressWindow, IDT_CURRENTDEST),
								pszSubItemDestPath);

					SendMessage(GetDlgItem(pCopyTreeData->hProgressWindow, IDPB_PROGRESSBAR),
								PBM_SETPOS, pCopyTreeData->dwNumFilesHandled, 0);

					InvalidateRect(pCopyTreeData->hProgressWindow, NULL, TRUE);
				} // end if (there's a window)
			} // end if (displaying progress)
#endif // ! NO_FILEUTILS_COPYTREEPROGRESS


			if (! CopyFile(pszSubItemSourcePath, pszSubItemDestPath, ((pCopyTreeData->dwOptions & FILECTO_FAIL_IF_EXISTS) ? TRUE : FALSE)))
			{
				hr = GetLastError();

				#ifndef NO_TNCOMMON_DEBUG_SPEW
				DPL(0, "Couldn't copy \"%s\" to \"%s\"!",
					2, pszSubItemSourcePath, pszSubItemDestPath);
				#endif // ! NO_TNCOMMON_DEBUG_SPEW

				goto DONE;
			} // end if (couldn't copy file)
		} // end else (it's not a directory)
	} // end while (there are more items)

	// There was an error, so just make sure it's the right one.
	hr = GetLastError();

	if (hr == ERROR_NO_MORE_FILES)
		hr = S_OK;
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	else
	{
		DPL(0, "Failed while searching for next item with \"%s\"!",
			1, pszSearchPattern);
	} // end else (got unexpected error)
	#endif // ! NO_TNCOMMON_DEBUG_SPEW


DONE:

	if (hFind != INVALID_HANDLE_VALUE)
	{
		if (! FindClose(hFind))
		{
			temphr = GetLastError();

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't close find!  %e", 1, temphr);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			if (hr == S_OK)
				hr = temphr;
		} // end if (couldn't close find)
		hFind = INVALID_HANDLE_VALUE;
	} // end if (there's an open find)

	if (pszSubItemDestPath != NULL)
	{
		LocalFree(pszSubItemDestPath);
		pszSubItemDestPath = NULL;
	} // end if (couldn't allocate memory)

	if (pszSubItemSourcePath != NULL)
	{
		LocalFree(pszSubItemSourcePath);
		pszSubItemSourcePath = NULL;
	} // end if (couldn't allocate memory)

	if (pszSearchPattern != NULL)
	{
		LocalFree(pszSearchPattern);
		pszSearchPattern = NULL;
	} // end if (couldn't allocate memory)

	return (hr);
} // CopyTreeInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef NO_FILEUTILS_COPYTREEPROGRESS


#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CopyTreeProgressWindowProc()"
//==================================================================================
// CopyTreeProgressWindowProc
//----------------------------------------------------------------------------------
//
// Description: Message pump that handles the CopyTree progress window.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK CopyTreeProgressWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam,
											LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_CLOSE:
			PostQuitMessage(0);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // CopyTreeProgressWindowProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CopyTreeProgressThreadProc()"
//==================================================================================
// CopyTreeProgressThreadProc
//----------------------------------------------------------------------------------
//
// Description: Thread that only exists to display the copy tree progress.
//
// Arguments:
//	LPVOID lpvParameter		Parameter.  Cast as pointer to a COPYTREEDATA structure.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
DWORD WINAPI CopyTreeProgressThreadProc(LPVOID lpvParameter)
{
	HRESULT			hr = S_OK;
	PCOPYTREEDATA	pCopyTreeData = (PCOPYTREEDATA) lpvParameter;
	WNDCLASSEX		wcex;
	MSG				msg;



	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(8, "Starting up  (%x)", 1, pCopyTreeData); 
	#endif // ! NO_TNCOMMON_DEBUG_SPEW


	ZeroMemory(&wcex, sizeof (WNDCLASSEX));
	wcex.cbSize = sizeof (WNDCLASSEX);
	GetClassInfoEx(NULL, WC_DIALOG, &wcex);
	wcex.lpfnWndProc = (WNDPROC)CopyTreeProgressWindowProc;
#ifdef LOCAL_TNCOMMON
	wcex.hInstance = NULL;
#else
	wcex.hInstance = s_hInstance;
#endif // ! LOCAL_TNCOMMON
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = WINDOWCLASS_FILE_COPYTREEPROGRESS;
	wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	if (! RegisterClassEx(&wcex))
	{
		hr = GetLastError();
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't register window class!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (couldn't register class)


	// Make sure they're loaded.
	InitCommonControls();


#ifdef LOCAL_TNCOMMON
	pCopyTreeData->hProgressWindow = CreateDialog(NULL,
													MAKEINTRESOURCE(IDD_PROGRESS),
													NULL,
													CopyTreeProgressWindowProc);
#else
	pCopyTreeData->hProgressWindow = CreateDialog(s_hInstance,
													MAKEINTRESOURCE(IDD_PROGRESS),
													NULL,
													CopyTreeProgressWindowProc);
#endif // ! LOCAL_TNCOMMON
	if (pCopyTreeData->hProgressWindow == NULL)
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't create progress bar dialog!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (couldn't create dialog)

	// Set the progress bar range.
	SendMessage(GetDlgItem(pCopyTreeData->hProgressWindow, IDPB_PROGRESSBAR),
				PBM_SETRANGE, 0, (MAKELPARAM(0, pCopyTreeData->dwTotalNumFiles)));

	ShowWindow(pCopyTreeData->hProgressWindow, SW_SHOW); // ignoring error


	// Okay, we're ready, signal our creator
	if (! SetEvent(pCopyTreeData->hProgressThreadStartedEvent))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't set thread ready event (%x)!",
			1, pCopyTreeData->hProgressThreadStartedEvent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		goto DONE;
	} // end if (couldn't set ready event)


	// Enter the window message loop.
	while(GetMessage(&msg, NULL, 0, 0) > 0)
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end while (there's a non-quit message)



DONE:

	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(8, "Exiting, %e", 1, hr); 
	#endif // ! NO_TNCOMMON_DEBUG_SPEW

	return (hr);
} // CopyTreeProgressThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX

#endif // ! NO_FILEUTILS_COPYTREEPROGRESS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\linkedstr.h ===
#ifndef __LINKED_STRINGS__
#define __LINKED_STRINGS__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined




//===========================================================================
// Class typedefs
//===========================================================================
typedef class CLString		CLString,		* PLSTRING;
typedef class CLStringList	CLStringList,	* PLSTRINGLIST;




//===========================================================================
// Classes
//===========================================================================
class DLLEXPORT CLString:public LLITEM
{
	private:
		char*	m_pszString; // the string


	public:
		// Overloaded
		CLString(void);
		CLString(char* pszString);

		virtual ~CLString(void);


		HRESULT SetString(char* pszString);
		char* GetString(void);
		HRESULT ConcatenateString(char* pszString);
		BOOL IsKey(char* szKeyName);
		BOOL IsValueTrue(void);
		char* GetKeyValue(void);
};



class DLLEXPORT CLStringList:public LLIST
{
	public:
		/*
		CLStringList(void);
		virtual ~CLStringList(void);
		*/
		
		HRESULT AddString(char* pszString);
		char* GetIndexedString(int iPos);
		int GetStringIndex(char* szString, int iStartPos, BOOL fMatchCase);
		PLSTRING GetStringObject(char* szString, int iStartPos, BOOL fMatchCase);
		char* GetValueOfKey(char* szKeyName);
		BOOL IsKeyTrue(char* szKeyName);
		BOOL ContainsMatchingWildcardForString(char* szString, BOOL fMatchCase);
};




#endif //__LINKED_STRINGS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\linkedstr.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>


#include "main.h"
#include "cppobjhelp.h"
#include "linklist.h"
#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#endif // ! NO_TNCOMMON_DEBUG_SPEW
#include "strutils.h"

#include "linkedstr.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::CLString(none)"
//==================================================================================
// CLString overloaded constructor
// No parameters version
//----------------------------------------------------------------------------------
//
// Description: Creates the CLString object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CLString::CLString(void)
{
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	this->m_pszString = NULL;
} // CLString::CLString(none)
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::CLString(string)"
//==================================================================================
// CLString overloaded constructor
// String version
//----------------------------------------------------------------------------------
//
// Description: Creates the CLString object.  Initializes the data structures, and
//				sets the string value to the one passed in.
//
// Arguments:
//	char* pszString	String to initialize value to.
//
// Returns: None (just the object).
//==================================================================================
CLString::CLString(char* pszString):
	m_pszString(NULL)
{
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "this = %x, param = %s", 2, this, pszString);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	if (pszString != NULL)
	{
		this->m_pszString = (char*) HeapAlloc(GetProcessHeap(),
											HEAP_ZERO_MEMORY,
											(strlen(pszString) + 1));
		if (this->m_pszString != NULL)
		{
			strcpy(this->m_pszString, pszString);
		} // end if (allocated memory)
	} // end if (there's a valid string to use)
} // CLString::CLString(string)
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::~CLString()"
//==================================================================================
// CLString destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CLString object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CLString::~CLString(void)
{
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	if (this->m_pszString != NULL)
	{
		HeapFree(GetProcessHeap(), 0, this->m_pszString);
		this->m_pszString = NULL;
	} // end if (we allocated a string)
} // CLString::~CLString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::SetString()"
//==================================================================================
// CLString::SetString
//----------------------------------------------------------------------------------
//
// Description: Sets this object's value to the passed in string, replacing any
//				existing value.
//
// Arguments:
//	char* pszString	Pointer to string to set, or NULL to clear.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CLString::SetString(char* pszString)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG


	// If there was a value before, dump it.
	if (this->m_pszString != NULL)
	{
		HeapFree(GetProcessHeap(), 0, this->m_pszString);
		this->m_pszString = NULL;
	} // end if (we allocated a string before)


	// If there's a new value, set it.
	if (pszString != NULL)
	{
		this->m_pszString = (char*) HeapAlloc(GetProcessHeap(),
											HEAP_ZERO_MEMORY,
											(strlen(pszString) + 1));
		if (this->m_pszString == NULL)
		{
			return (E_OUTOFMEMORY);
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszString, pszString);
	} // end if (there was an item to replace it)

	return (S_OK);
} // CLString::SetString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::GetString()"
//==================================================================================
// CLString::GetString
//----------------------------------------------------------------------------------
//
// Description: Returns pointer to this object's value.
//
// Arguments: None.
//
// Returns: Pointer to value if it has been set, NULL otherwise.
//==================================================================================
char* CLString::GetString(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)
#endif // DEBUG


	return (this->m_pszString);
} // CLString::GetString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::ConcatenateString()"
//==================================================================================
// CLString::ConcatenateString
//----------------------------------------------------------------------------------
//
// Description: Adds the string to the end of this item's existing value, if any.
//
// Arguments:
//	char* pszString	Pointer to string to set, or NULL to clear.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CLString::ConcatenateString(char* pszString)
{
	char*	pszOldString;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG


	// If there's a new value, set it.
	if (pszString != NULL)
	{
		// If there was a value before, we're going to concatenate.
		if (this->m_pszString != NULL)
		{
			pszOldString = this->m_pszString;

			this->m_pszString = (char*) HeapAlloc(GetProcessHeap(),
												HEAP_ZERO_MEMORY,
												(strlen(pszOldString) + strlen(pszString) + 1));
			if (this->m_pszString == NULL)
			{
				HeapFree(GetProcessHeap(), 0, pszOldString);
				pszOldString = NULL;
				return (E_OUTOFMEMORY);
			} // end if (couldn't allocate memory)

			strcpy(this->m_pszString, pszOldString);
			strcat(this->m_pszString, pszString);

			HeapFree(GetProcessHeap(), 0, pszOldString);
			pszOldString = NULL;
		} // end if (we allocated a string before)
		else
		{
			this->m_pszString = (char*) HeapAlloc(GetProcessHeap(),
												HEAP_ZERO_MEMORY,
												(strlen(pszString) + 1));
			if (this->m_pszString == NULL)
			{
				return (E_OUTOFMEMORY);
			} // end if (couldn't allocate memory)

			strcpy(this->m_pszString, pszString);
		} // end else (there wasn't a string before)
	} // end if (there was an item to replace it)

	return (S_OK);
} // CLString::ConcatenateString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::IsKey()"
//==================================================================================
// CLString::IsKey
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this string begins with the key name specified,
//				case insensitive and ignoring whitespace, FALSE otherwise.
//
// Arguments:
//	char* szKeyName		Key to check if we match.
//
// Returns: TRUE if we matched the key, FALSE otherwise.
//==================================================================================
BOOL CLString::IsKey(char* szKeyName)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	return (StringIsKey(this->m_pszString, szKeyName));
} // CLString::IsKey
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::IsValueTrue()"
//==================================================================================
// CLString::IsValueTrue
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this string's key value exists and is not all "0"'s,
//				"false" or "off", case-insensitive.  Otherwise this returns FALSE.
//
// Arguments: None.
//
// Returns: TRUE if we're anything but the textual representations of false.
//==================================================================================
BOOL CLString::IsValueTrue(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	return (StringIsValueTrue(this->m_pszString));
} // CLString::IsValueTrue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLString::GetKeyValue()"
//==================================================================================
// CLString::GetKeyValue
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to this string's key value if there is one, NULL
//				if not.
//
// Arguments: None.
//
// Returns: Pointer to key value, or NULL if none.
//==================================================================================
char* CLString::GetKeyValue(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG

	return (StringGetKeyValue(this->m_pszString));
} // CLString::GetKeyValue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::CLStringList()"
//==================================================================================
// CLStringList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CLStringList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CLStringList::CLStringList(void)
{
	/-
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	-/
} // CLStringList::CLStringList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::~CLStringList()"
//==================================================================================
// CLStringList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CLStringList object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CLStringList::~CLStringList(void)
{
	/-
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	-/
} // CLStringList::~CLStringList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::AddString()"
//==================================================================================
// CLStringList::AddString
//----------------------------------------------------------------------------------
//
// Description: Adds the passed in string to the end of the list.
//
// Arguments:
//	char* pszString	Pointer to string to add.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT CLStringList::AddString(char* pszString)
{
	HRESULT		hr;
	PLSTRING	pNewItem = NULL;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)
#endif // DEBUG


	//pNewItem = new (CLString)(pszString);
	pNewItem = new (CLString);
	if (pNewItem == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't create object)

	hr = pNewItem->SetString(pszString);
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't set new string's contents!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't add item to list)

	hr = this->Add(pNewItem);
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't add new string item to list!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't add item to list)

	pNewItem = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pNewItem != NULL)
	{
		delete (pNewItem);
		pNewItem = NULL;
	} // end if (have leftover object)

	return (hr);
} // CLStringList::AddString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::GetIndexedString()"
//==================================================================================
// CLStringList::GetIndexedString
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the string at the given index in the list, or
//				NULL if an error occurred.
//
// Arguments:
//	int iPos	Index of string to retrieve.
//
// Returns: Pointer to string at index, NULL if an error occurred.
//==================================================================================
char* CLStringList::GetIndexedString(int iPos)
{
	PLSTRING	pItem = NULL;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)
#endif // DEBUG


	pItem = (PLSTRING) this->GetItem(iPos);
	if (pItem == NULL)
		return (NULL);

	return (pItem->GetString());
} // CLStringList::GetIndexedString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::GetStringIndex()"
//==================================================================================
// CLStringList::GetStringIndex
//----------------------------------------------------------------------------------
//
// Description: Finds the first instance of the specified string and returns its
//				index in the list.  The search is started at the specified index
//				(which is zero-based, so pass 0 to start searching from the
//				beginning).
//				If the is key not found, then -1 is returned.
//
// Arguments:
//	char* szString		String to search for.
//	int iStartPos		Index to begin search from, usually 0 to start at beginning.
//	BOOL fMatchCase		Whether case has to match or not.
//
// Returns: Index of the string, or -1 if not found or error occurred.
//==================================================================================
int CLStringList::GetStringIndex(char* szString, int iStartPos, BOOL fMatchCase)
{
	PLSTRING	pItem = NULL;
	int			i;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (szString == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Passed in NULL string to search for!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got bad parameters)
#endif // DEBUG

	this->EnterCritSection();

#ifdef DEBUG
	if ((iStartPos < 0) || (iStartPos >= this->Count()))
	{
		this->LeaveCritSection();
		return (-1);
	} // end if (the starting position is out of range)
#endif // DEBUG

	for(i = iStartPos; i < this->Count(); i++)
	{
		pItem = (PLSTRING) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get string item %i!", 1, i);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (-1);
		} // end if (couldn't get an item)

		// If it's an empty string, skip it.
		if (pItem->GetString() == NULL)
			continue;

		if (fMatchCase)
		{
			if (strcmp(pItem->GetString(), szString) == 0)
			{
				this->LeaveCritSection();
				return (i);
			} // end if (found the right item)
		} // end if (case is important)
		else
		{
			if (StringCmpNoCase(pItem->GetString(), szString))
			{
				this->LeaveCritSection();
				return (i);
			} // end if (found the right item)
		} // end else (case doesn't matter)
	} // end for (each string in the list)
	this->LeaveCritSection();

	return (-1);
} // CLStringList::GetStringIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::GetStringObject()"
//==================================================================================
// CLStringList::GetStringObject
//----------------------------------------------------------------------------------
//
// Description: Finds the first instance of the specified string and returns a
//				pointer to the object.  The search is started at the specified index
//				(which is zero-based, so pass 0 to start searching from the
//				beginning).
//				If the is key not found, then NULL is returned.
//
// Arguments:
//	char* szString		String to search for.
//	int iStartPos		Index to begin search from, usually 0 to start at beginning.
//	BOOL fMatchCase		Whether case has to match or not.
//
// Returns: Pointer to the CLString object, or NULL if not found or error occurred.
//==================================================================================
PLSTRING CLStringList::GetStringObject(char* szString, int iStartPos, BOOL fMatchCase)
{
	PLSTRING	pItem = NULL;
	int			i;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)

	if (szString == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Passed in NULL string to search for!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got bad parameters)
#endif // DEBUG


	this->EnterCritSection();

#ifdef DEBUG
	if ((iStartPos < 0) || (iStartPos >= this->Count()))
	{
		this->LeaveCritSection();
		return (NULL);
	} // end if (the starting position is out of range)
#endif // DEBUG

	for(i = iStartPos; i < this->Count(); i++)
	{
		pItem = (PLSTRING) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get string item %i!", 1, i);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (NULL);
		} // end if (couldn't get an item)

		// If it's an empty string, skip it.
		if (pItem->GetString() == NULL)
			continue;

		if (fMatchCase)
		{
			if (strcmp(pItem->GetString(), szString) == 0)
			{
				this->LeaveCritSection();
				return (pItem);
			} // end if (found the right item)
		} // end if (case is important)
		else
		{
			if (StringCmpNoCase(pItem->GetString(), szString))
			{
				this->LeaveCritSection();
				return (pItem);
			} // end if (found the right item)
		} // end else (case doesn't matter)
	} // end for (each string in the list)
	this->LeaveCritSection();

	return (NULL);
} // CLStringList::GetStringObject
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::GetValueOfKey()"
//==================================================================================
// CLStringList::GetValueOfKey
//----------------------------------------------------------------------------------
//
// Description: Searches all of the strings in the list for the first instance of
//				the specified key (case insensitive) and returns a pointer to its
//				value if found.  If the is key not found, then NULL is returned.
//
// Arguments:
//	char* szKeyName			The name of the key to search for.
//
// Returns: Pointer to value of key, or NULL if not found.
//==================================================================================
char* CLStringList::GetValueOfKey(char* szKeyName)
{
	PLSTRING	pItem = NULL;
	int			i;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)
#endif // DEBUG


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PLSTRING) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get string item %i!", 1, i);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (NULL);
		} // end if (couldn't get an item)

		if (pItem->IsKey(szKeyName))
		{
			this->LeaveCritSection();
			return (pItem->GetKeyValue());
		} // end if (found the right item)
	} // end for (each string in the list)
	this->LeaveCritSection();

	return (NULL);
} // CLStringList::GetValueOfKey
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::IsKeyTrue()"
//==================================================================================
// CLStringList::IsKeyTrue
//----------------------------------------------------------------------------------
//
// Description: Searches all of the strings in the list for the first instance of
//				the specified key (case insensitive) and returns TRUE if its value
//				is not all "0"'s, is "false" or "off", case-insensitive.  If the
//				key was not found or its value was one of the above, FALSE is
//				returned.
//
// Arguments:
//	char* szKeyName		The name of the key to search check.
//
// Returns: TRUE if the string is anything but the textual representations of FALSE.
//==================================================================================
BOOL CLStringList::IsKeyTrue(char* szKeyName)
{
	PLSTRING	pItem = NULL;
	int			i;
	BOOL		fResult = FALSE;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PLSTRING) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get string item %i!", 1, i);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (FALSE);
		} // end if (couldn't get an item)

		if (pItem->IsKey(szKeyName))
		{
			this->LeaveCritSection();
			return (pItem->IsValueTrue());
		} // end if (found the item)
	} // end for (each string in the list)
	this->LeaveCritSection();

	return (FALSE);
} // CLStringList::IsKeyTrue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CLStringList::ContainsMatchingWildcardForString()"
//==================================================================================
// CLStringList::ContainsMatchingWildcardForString
//----------------------------------------------------------------------------------
//
// Description: Treats all of the strings in the list as pattern matches and checks
//				to see if the passed in string fits at least one of them.  Multiple
//				items in this list are treated as ORed, i.e. the first rule that
//				matches stops searching and causes TRUE to be returned.  For FALSE
//				to be returned, none of the strings can match.
//
// Arguments:
//	char* szString		Pointer to string to store resulting value in.
//	BOOL fMatchCase		Whether case is important or not.
//
// Returns: TRUE if the string matches an item in the list, FALSE otherwise.
//==================================================================================
BOOL CLStringList::ContainsMatchingWildcardForString(char* szString, BOOL fMatchCase)
{
	PLSTRING	pItem = NULL;
	int			i;
	BOOL		fResult = FALSE;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (FALSE);
	} // end if (we've got a bad object)
#endif // DEBUG


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PLSTRING) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();

			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't get string item %i!", 1, i);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			return (FALSE);
		} // end if (couldn't get an item)

		if (StringMatchesWithWildcard(pItem->GetString(), szString, fMatchCase))
		{
			this->LeaveCritSection();
			return (TRUE);
		} // end if (matched the item)
	} // end for (each string in the list)

	this->LeaveCritSection();

	return (FALSE);
} // CLStringList::ContainsMatchingWildcardForString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\excptns.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "main.h"
#include "debugprint.h"
#include "cppobjhelp.h"
#include "linklist.h"
#ifdef TNCOMMON_EXPORTS
#include "symbols.h"
#endif // TNCOMMON_EXPORTS
#include "excptns.h"





//==================================================================================
// Exported Globals
//==================================================================================
CTNExceptionsList		g_TNExceptions;






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNException::CTNException"
//==================================================================================
// CTNException constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the exception object with the specified properties.
//
// Arguments:
//	LPCONTEXT lpContext					?
//	DWORD dwExceptionCode				?
//	DWORD dwExceptionFlags				?
//	PVOID pvExceptionAddress			?
//	DWORD dwNumberParameters			?
//	DWORD* padwExceptionInformation		?
//
// Returns: None (just the object).
//==================================================================================
CTNException::CTNException(LPCONTEXT lpContext,
					DWORD dwExceptionCode,
					DWORD dwExceptionFlags,
					PVOID pvExceptionAddress,
					DWORD dwNumberParameters,
					DWORD_PTR* padwExceptionInformation) :
		m_dwExceptionCode(dwExceptionCode),
		m_dwExceptionFlags(dwExceptionFlags),
		m_pvExceptionAddress(pvExceptionAddress),
		m_dwNumberParameters(dwNumberParameters)
{
	CopyMemory(&(this->m_context), lpContext, sizeof (CONTEXT));

	ZeroMemory(this->m_adwExceptionInformation,
				(EXCEPTION_MAXIMUM_PARAMETERS * sizeof (DWORD)));
	CopyMemory(this->m_adwExceptionInformation,
				padwExceptionInformation,
				dwNumberParameters * sizeof (DWORD));
} // CTNException::CTNException
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNException::GetDescription"
//==================================================================================
// CTNException::GetDescription
//----------------------------------------------------------------------------------
//
// Description: Destroys the exception object.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNException::GetDescription(void)
{
	return (S_OK);
} // CTNException::GetDescription
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNException::PrintSelf"
//==================================================================================
// CTNException::PrintSelf
//----------------------------------------------------------------------------------
//
// Description: Prints this object's properties to the DPL macro at level 0.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNException::PrintSelf(void)
{
	DPL(0, "%X", 1, this->m_pvExceptionAddress);

	switch (this->m_dwExceptionCode)
	{
		case EXCEPTION_ACCESS_VIOLATION:
			DPL(0, "Thread attempted to %s the address %X!",
					2, ((this->m_adwExceptionInformation[0] == 0) ? "read from" : "write to"),
					this->m_adwExceptionInformation[1]);
		  break;

		default:
			DWORD	dwTemp;


			for(dwTemp = 0; dwTemp < this->m_dwNumberParameters; dwTemp++)
			{
				DPL(0, "adwExceptionInformation[%u] = %X",
						2, dwTemp, this->m_adwExceptionInformation[dwTemp]);
			} // end for (each parameter)
		  break;
	} // end switch (on exception code)

#ifdef _X86_
	DPL(0, "eip = %X", 1, this->m_context.Eip);
	DPL(0, "ebp = %X", 1, this->m_context.Ebp);
	DPL(0, "esp = %X", 1, this->m_context.Esp);
	DPL(0, "eax = %X", 1, this->m_context.Eax);
	DPL(0, "ebx = %X", 1, this->m_context.Ebx);
	DPL(0, "ecx = %X", 1, this->m_context.Ecx);
	DPL(0, "edx = %X", 1, this->m_context.Edx);
#endif // _X86_

	return (S_OK);
} // CTNException::PrintSelf
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNExcptnConvertToClassFilter()"
//==================================================================================
// TNExcptnConvertToClassFilter
//----------------------------------------------------------------------------------
//
// Description: Filter to convert exceptions into a CTNException object.
//
// Arguments:
//	PEXCEPTION_POINTERS pExceptionInfo	Pointer to exception record(s).
//	PTNEXCEPTIONSLIST pExceptionsList	Pointer to list to add records to.
//
// Returns: Always returns EXCEPTION_EXECUTE_HANDLER.
//==================================================================================
int TNExcptnConvertToClassFilter(PEXCEPTION_POINTERS pExceptionInfo,
								PTNEXCEPTIONSLIST pExceptionsList)
{
	HRESULT				hr;
	PEXCEPTION_RECORD	pExceptionRecord = pExceptionInfo->ExceptionRecord;
	PTNEXCEPTION		pException = NULL;


	while (pExceptionRecord != NULL)
	{
		pException = new (CTNException)(pExceptionInfo->ContextRecord,
										pExceptionRecord->ExceptionCode,
										pExceptionRecord->ExceptionFlags,
										pExceptionRecord->ExceptionAddress,
										pExceptionRecord->NumberParameters,
										pExceptionRecord->ExceptionInformation);

		// Add the new exception to the front of the list
		hr = pExceptionsList->AddAfter(pException, NULL);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add new exception to list!  %e", 1, hr);
			delete (pException);
			pException = NULL;
		} // end if (couldn't add item to list)

		pExceptionRecord = pExceptionRecord->ExceptionRecord;
	} // end while (there are more exceptions to add)

	return (EXCEPTION_EXECUTE_HANDLER);
} // TNConvertExceptionsFilter
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\errors.cpp ===
//=============================================================================
// Includes
//=============================================================================
#include <windows.h>
#include <winerror.h>
#ifdef _XBOX
#include "convhelp.h"
#endif

#ifndef NO_ERRORS_DPLAY
#include <dplay.h>
#endif // NO_ERRORS_DPLAY

#ifndef NO_ERRORS_DPLAY8
#include <dplay8.h>
#endif // NO_ERRORS_DPLAY8

#ifndef NO_ERRORS_DVOICE
#include <dvoice.h>
#endif // NO_ERRORS_DVOICE

#ifndef NO_ERRORS_DSOUND
#include <mmreg.h> // NT BUILD complains about WAVEFORMATEX without it
#include <dsound.h>
#endif // NO_ERRORS_DSOUND

#ifndef NO_ERRORS_DDRAW
#include <ddraw.h>
#endif // NO_ERRORS_DDRAW

#ifndef _XBOX
#ifndef NO_ERRORS_WINSOCK
#include <winsock.h>
#endif // NO_ERRORS_WINSOCK
#else // ! XBOX
#ifndef NO_ERRORS_WINSOCK
#include <winsockx.h>
#endif // NO_ERRORS_WINSOCK
#endif // XBOX

#include <raserror.h>
#ifndef _XBOX  // no TAPI
#include <tapi.h>
#endif

#ifndef NO_ERRORS_TNCONTRL
// We can't actually do this because there's some wacky #including with that.  We'll
// just copy the code we need.
//#include "..\tncontrl\tncontrl.h"

#define TNERR_CONNECTIONDROPPED		0x86661001
#define TNERR_LOSTTESTER			0x86661002

//#define TNSR_INSYNC					S_OK
#define TNSR_USERCANCEL				0x86661101
#define TNSR_LOSTTESTER				0x86661103

//#define TNWR_GOTEVENT				S_OK
#define TNWR_USERCANCEL				0x86661111
#define TNWR_TIMEOUT				0x86661112
#define TNWR_LOSTTESTER				0x86661113

//#define TNCWR_CONNECTED				S_OK
#define TNCWR_USERCANCEL			0x86661121
#define TNCWR_TIMEOUT				0x86661122
#define TNCWR_LOSTTESTER			0x86661123

#endif // NO_ERRORS_TNCONTRL

#include "main.h"
#include "errors.h"
#include "sprintf.h"
#ifdef _XBOX
#include "debugprint.h"
#endif // XBOX





//=========================================================================================
// Data
//=========================================================================================
TNERRORITEM g_TNErrorTable [] =
{
	// 0L
	// S_OK
	// DP_OK
	// DV_OK
	// DPN_OK
	// ERROR_SUCCESS
	NO_ERROR,						"S_OK, ERROR_SUCCESS, NO_ERROR", "The operation completed successfully.",
	// 1L
	// S_FALSE
	ERROR_INVALID_FUNCTION,			"S_FALSE, ERROR_INVALID_FUNCTION", "Generic failure.' or 'Incorrect function.",
	// 2L
	ERROR_FILE_NOT_FOUND,			"ERROR_FILE_NOT_FOUND", "The system cannot find the file specified.",
	// 3L
	ERROR_PATH_NOT_FOUND,			"ERROR_PATH_NOT_FOUND", "The system cannot find the path specified.",
	// 4L
	ERROR_TOO_MANY_OPEN_FILES,		"ERROR_TOO_MANY_OPEN_FILES", "The system cannot open the file.",
	// 5L
	ERROR_ACCESS_DENIED,			"ERROR_ACCESS_DENIED", "Access is denied.",
	// 6L
	ERROR_INVALID_HANDLE,			"ERROR_INVALID_HANDLE", "The handle is invalid.",
	// 7L
	ERROR_ARENA_TRASHED,			"ERROR_ARENA_TRASHED", "The storage control blocks were destroyed.",
	// 8L
	ERROR_NOT_ENOUGH_MEMORY,		"ERROR_NOT_ENOUGH_MEMORY", "Not enough storage is available to process this command.",
	// 9L
	ERROR_INVALID_BLOCK,			"ERROR_INVALID_BLOCK", "The storage control block address is invalid.",
	// 10L
	ERROR_BAD_ENVIRONMENT,			"ERROR_BAD_ENVIRONMENT", "The environment is incorrect.",
	// 11L
	ERROR_BAD_FORMAT,				"ERROR_BAD_FORMAT", "An attempt was made to load a program with an incorrect format.",
	// 12L
	ERROR_INVALID_ACCESS,			"ERROR_INVALID_ACCESS", "The access code is invalid.",
	// 13L
	ERROR_INVALID_DATA,				"ERROR_INVALID_DATA", "The data is invalid.",
	// 14L
	ERROR_OUTOFMEMORY,				"ERROR_OUTOFMEMORY", "Not enough storage is available to complete this operation.",
	// 15L
	ERROR_INVALID_DRIVE,			"ERROR_INVALID_DRIVE", "The system cannot find the drive specified.",
	// 16L
	ERROR_CURRENT_DIRECTORY,		"ERROR_CURRENT_DIRECTORY", "The directory cannot be removed.",
	// 17L
	ERROR_NOT_SAME_DEVICE,			"ERROR_NOT_SAME_DEVICE", "The system cannot move the file to a different disk drive.",
	// 18L
	ERROR_NO_MORE_FILES,			"ERROR_NO_MORE_FILES", "There are no more files.",
	// 19L
	ERROR_WRITE_PROTECT,			"ERROR_ACCESS_DENIED", "The media is write protected.",
	// 20L
	ERROR_BAD_UNIT,					"ERROR_BAD_UNIT", "The system cannot find the device specified.",
	// 21L
	ERROR_NOT_READY,				"ERROR_NOT_READY", "The device is not ready.",
	// 22L
	ERROR_BAD_COMMAND,				"ERROR_BAD_COMMAND", "The device does not recognize the command.",
	// 23L
	ERROR_CRC,						"ERROR_CRC", "Data error (cyclic redundancy check).",
	// 24L
	ERROR_BAD_LENGTH,				"ERROR_BAD_LENGTH", "The program issued a command but its length is incorrect.",
	// 25L
	ERROR_SEEK,						"ERROR_SEEK", "The drive cannot locate a specific area or track on the disk.",
	// 26L
	ERROR_NOT_DOS_DISK,				"ERROR_NOT_DOS_DISK", "The specified disk or diskette cannot be accessed.",
	// 27L
	ERROR_SECTOR_NOT_FOUND,			"ERROR_SECTOR_NOT_FOUND", "The drive cannot find the sector requested.",
	// 28L
	ERROR_OUT_OF_PAPER,				"ERROR_OUT_OF_PAPER", "The printer is out of paper.",
	// 29L
	ERROR_WRITE_FAULT,				"ERROR_WRITE_FAULT", "The system cannot write to the specified device.",
	// 30L
	ERROR_READ_FAULT,				"ERROR_READ_FAULT", "The system cannot read from the specified device.",
	// 31L
	ERROR_GEN_FAILURE,				"ERROR_GEN_FAILURE", "A device attached to the system is not functioning.",
	// 32L
	ERROR_SHARING_VIOLATION,		"ERROR_SHARING_VIOLATION", "The process cannot access the file because it is being used by another process.",
	// 33L
	ERROR_LOCK_VIOLATION,			"ERROR_LOCK_VIOLATION", "The process cannot access the file because another process has locked a portion of the file.",
	// 34L
	ERROR_WRONG_DISK,				"ERROR_WRONG_DISK", "The wrong diskette is in the drive.",
	// 36L
	ERROR_SHARING_BUFFER_EXCEEDED,	"ERROR_SHARING_BUFFER_EXCEEDED", "Too many files opened for sharing.",
	// 38L
	ERROR_HANDLE_EOF,				"ERROR_HANDLE_EOF", "Reached the end of the file.",
	// 39L
	ERROR_HANDLE_DISK_FULL,			"ERROR_HANDLE_DISK_FULL", "The disk is full.",
	// 50L
	ERROR_NOT_SUPPORTED,			"ERROR_NOT_SUPPORTED", "The network request is not supported.",
	// 51L
	ERROR_REM_NOT_LIST,				"ERROR_REM_NOT_LIST", "The remote computer is not available.",
	// 52L
	ERROR_DUP_NAME,					"ERROR_DUP_NAME", "A duplicate name exists on the network.",
	// 53L
	ERROR_BAD_NETPATH,				"ERROR_BAD_NETPATH", "The network path was not found.",
	// 54L
	ERROR_NETWORK_BUSY,				"ERROR_NETWORK_BUSY", "The network is busy.",
	// 55L
	ERROR_DEV_NOT_EXIST,			"ERROR_DEV_NOT_EXIST", "The specified network resource or device is no longer available.",
	// 56L
	ERROR_TOO_MANY_CMDS,			"ERROR_TOO_MANY_CMDS", "The network BIOS command limit has been reached.",
	// 57L
	ERROR_ADAP_HDW_ERR,				"ERROR_ADAP_HDW_ERR", "A network adapter hardware error occurred.",
	// 58L
	ERROR_BAD_NET_RESP,				"ERROR_BAD_NET_RESP", "The specified server cannot perform the requested operation.",
	// 59L
	ERROR_UNEXP_NET_ERR,			"ERROR_UNEXP_NET_ERR", "An unexpected network error occurred.",
	// 60L
	ERROR_BAD_REM_ADAP,				"ERROR_BAD_REM_ADAP", "The remote adapter is not compatible.",

	// 72L
	ERROR_REDIR_PAUSED,				"ERROR_REDIR_PAUSED", "The specified printer or disk device has been paused.",
	// 80L
	ERROR_FILE_EXISTS,				"ERROR_FILE_EXISTS", "The file exists.",
	// 82L
	ERROR_CANNOT_MAKE,				"ERROR_CANNOT_MAKE", "The directory or file cannot be created.",
	// 83L
	ERROR_FAIL_I24,					"ERROR_FAIL_I24", "Fail on INT 24.",
	// 84L
	ERROR_OUT_OF_STRUCTURES,		"ERROR_OUT_OF_STRUCTURES", "Storage to process this request is not available.",
	// 85L
	ERROR_ALREADY_ASSIGNED,			"ERROR_ALREADY_ASSIGNED", "The local device name is already in use.",
	// 86L
	ERROR_INVALID_PASSWORD,			"ERROR_INVALID_PASSWORD", "The specified network password is not correct.",
	// 87L
	ERROR_INVALID_PARAMETER,		"ERROR_INVALID_PARAMETER", "The parameter is incorrect.",
	// 88L
	ERROR_NET_WRITE_FAULT,			"ERROR_NET_WRITE_FAULT", "A write fault occurred on the network.",

	//110L
	ERROR_OPEN_FAILED,				"ERROR_OPEN_FAILED", "The system cannot open the device or file specified.",
	//111L
	ERROR_BUFFER_OVERFLOW,			"ERROR_BUFFER_OVERFLOW", "The file name is too long.",
	//112L
	ERROR_DISK_FULL,				"ERROR_DISK_FULL", "There is not enough space on the disk.",
	//113L
	ERROR_NO_MORE_SEARCH_HANDLES,	"ERROR_NO_MORE_SEARCH_HANDLES", "No more internal file identifiers available.",
	//114L
	ERROR_INVALID_TARGET_HANDLE,	"ERROR_INVALID_TARGET_HANDLE", "The target internal file identifier is incorrect.",
	// ... 115 & 116 not specified ...
	//117L
	ERROR_INVALID_CATEGORY,			"ERROR_INVALID_CATEGORY", "The IOCTL call made by the application program is not correct.",
	//118L
	ERROR_INVALID_VERIFY_SWITCH,	"ERROR_INVALID_VERIFY_SWITCH", "The verify-on-write switch parameter value is not correct.",
	//119L
	ERROR_BAD_DRIVER_LEVEL,			"ERROR_BAD_DRIVER_LEVEL", "The system does not support the command requested.",
	//120L
	ERROR_CALL_NOT_IMPLEMENTED,		"ERROR_CALL_NOT_IMPLEMENTED", "This function is not supported on this system.",
	//121L
	ERROR_SEM_TIMEOUT,				"ERROR_SEM_TIMEOUT", "The semaphore timeout period has expired.",
	//122L
	ERROR_INSUFFICIENT_BUFFER,		"ERROR_INSUFFICIENT_BUFFER", "The data area passed to a system call is too small.",
	//123L
	ERROR_INVALID_NAME,				"ERROR_INVALID_NAME", "The filename, directory name, or volume label syntax is incorrect.",
	//124L
	ERROR_INVALID_LEVEL,			"ERROR_INVALID_LEVEL", "The system call level is not correct.",
	//125L
	ERROR_NO_VOLUME_LABEL,			"ERROR_NO_VOLUME_LABEL", "The disk has no volume label.",
	//126L
	ERROR_MOD_NOT_FOUND,			"ERROR_MOD_NOT_FOUND", "The specified module could not be found.",
	//127L
	ERROR_PROC_NOT_FOUND,			"ERROR_PROC_NOT_FOUND", "The specified procedure could not be found.",
	//128L
	ERROR_WAIT_NO_CHILDREN,			"ERROR_WAIT_NO_CHILDREN", "There are no child processes to wait for.",
	//129L
	ERROR_CHILD_NOT_COMPLETE,		"ERROR_CHILD_NOT_COMPLETE", "The application cannot be run in Win32 mode.",
	//130L
	ERROR_DIRECT_ACCESS_HANDLE,		"ERROR_DIRECT_ACCESS_HANDLE", "Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.",
	//131L
	ERROR_NEGATIVE_SEEK,			"ERROR_NEGATIVE_SEEK", "An attempt was made to move the file pointer before the beginning of the file.",

	//156L
	ERROR_SIGNAL_REFUSED,			"ERROR_SIGNAL_REFUSED", "The recipient process has refused the signal.",
	//157L
	ERROR_DISCARDED,				"ERROR_DISCARDED", "The segment is already discarded and cannot be locked.",
	//158L
	ERROR_NOT_LOCKED,				"ERROR_NOT_LOCKED", "The segment is already unlocked.",
	//159L
	ERROR_BAD_THREADID_ADDR,		"ERROR_BAD_THREADID_ADDR", "The address for the thread ID is not correct.",
	//160L
	ERROR_BAD_ARGUMENTS,			"ERROR_BAD_ARGUMENTS", "The argument string passed to DosExecPgm is not correct.",
	//161L
	ERROR_BAD_PATHNAME,				"ERROR_BAD_PATHNAME", "The specified path is invalid.",
	//162L
	ERROR_SIGNAL_PENDING,			"ERROR_SIGNAL_PENDING", "A signal is already pending.",
	//164L
	ERROR_MAX_THRDS_REACHED,		"ERROR_MAX_THRDS_REACHED", "No more threads can be created in the system.",
	//167L
	ERROR_LOCK_FAILED,				"ERROR_LOCK_FAILED", "Unable to lock a region of a file.",
	//170L
	ERROR_BUSY,						"ERROR_BUSY", "The requested resource is in use.",
	//173L
	ERROR_CANCEL_VIOLATION,			"ERROR_CANCEL_VIOLATION", "A lock request was not outstanding for the supplied cancel region.",
	//174L
	ERROR_ATOMIC_LOCKS_NOT_SUPPORTED, "ERROR_ATOMIC_LOCKS_NOT_SUPPORTED", "The file system does not support atomic changes to the lock type.",
	//180L
	ERROR_INVALID_SEGMENT_NUMBER,	"ERROR_INVALID_SEGMENT_NUMBER", "The system detected a segment number that was not correct.",
	//182L
	ERROR_INVALID_ORDINAL,			"ERROR_INVALID_ORDINAL", "The operating system cannot run that number.",
	//183L
	ERROR_ALREADY_EXISTS,			"ERROR_ALREADY_EXISTS", "Cannot create a file when that file already exists.",

	//232L
	ERROR_NO_DATA,					"ERROR_NO_DATA", "The pipe is being closed.",
	//233L
	ERROR_PIPE_NOT_CONNECTED,		"ERROR_PIPE_NOT_CONNECTED", "No process is on the other end of the pipe.",
	//234L
	ERROR_MORE_DATA,				"ERROR_MORE_DATA", "More data is available.",
	//240L
	ERROR_VC_DISCONNECTED,			"ERROR_VC_DISCONNECTED", "The session was canceled.",
	//254L
	ERROR_EA_LIST_INCONSISTENT,		"ERROR_EA_LIST_INCONSISTENT", "The extended attributes are inconsistent.",
	//258L
	WAIT_TIMEOUT,					"WAIT_TIMEOUT", "The wait operation timed out.",
	//259L
	ERROR_NO_MORE_ITEMS,			"ERROR_NO_MORE_ITEMS", "No more data is available.",
	//266L
	ERROR_CANNOT_COPY,				"ERROR_CANNOT_COPY", "The copy functions cannot be used.",
	//267L
	ERROR_DIRECTORY,				"ERROR_DIRECTORY", "The directory name is invalid.",
	//275L
	ERROR_EAS_DIDNT_FIT,			"ERROR_EAS_DIDNT_FIT", "The extended attributes did not fit in the buffer.",
	//276L
	ERROR_EA_FILE_CORRUPT,			"ERROR_EA_FILE_CORRUPT", "The extended attribute file on the mounted file system is corrupt.",
	//277L
	ERROR_EA_TABLE_FULL,			"ERROR_EA_TABLE_FULL", "The extended attribute table file is full.",
	//278L
	ERROR_INVALID_EA_HANDLE,		"ERROR_INVALID_EA_HANDLE", "The specified extended attribute handle is invalid.",
	//282L
	ERROR_EAS_NOT_SUPPORTED,		"ERROR_EAS_NOT_SUPPORTED", "The mounted file system does not support extended attributes.",
	//288L
	ERROR_NOT_OWNER,				"ERROR_NOT_OWNER", "Attempt to release mutex not owned by caller.",
	//298L
	ERROR_TOO_MANY_POSTS,			"ERROR_TOO_MANY_POSTS", "Too many posts were made to a semaphore.",
	//299L
	ERROR_PARTIAL_COPY,				"ERROR_PARTIAL_COPY", "Only part of a ReadProcessMemory or WriteProcessMemory request was completed.",
	//300L
	ERROR_OPLOCK_NOT_GRANTED,		"ERROR_OPLOCK_NOT_GRANTED", "The oplock request is denied.",
	//301L
	ERROR_INVALID_OPLOCK_PROTOCOL,	"ERROR_INVALID_OPLOCK_PROTOCOL", "An invalid oplock acknowledgment was received by the system.",
	//317L
	ERROR_MR_MID_NOT_FOUND,			"ERROR_MR_MID_NOT_FOUND", "The system cannot find message text for the message number in the message file.",
	//487L
	ERROR_INVALID_ADDRESS,			"ERROR_INVALID_ADDRESS", "Attempt to access invalid address.",
	//534L
	ERROR_ARITHMETIC_OVERFLOW,		"ERROR_ARITHMETIC_OVERFLOW", "Arithmetic result exceeded 32 bits.",
	//535L
	ERROR_PIPE_CONNECTED,			"ERROR_PIPE_CONNECTED", "There is a process on other end of the pipe.",
	//536L
	ERROR_PIPE_LISTENING,			"ERROR_PIPE_LISTENING", "Waiting for a process to open the other end of the pipe.",

	// Begin RAS errors
	//600L
	PENDING,						"PENDING", "An operation is pending.",
	//601L
	ERROR_INVALID_PORT_HANDLE,		"ERROR_INVALID_PORT_HANDLE", "The port handle is invalid.",
	//602L
	ERROR_PORT_ALREADY_OPEN,		"ERROR_PORT_ALREADY_OPEN", "The port is already open.",
	//603L
	ERROR_BUFFER_TOO_SMALL,			"ERROR_BUFFER_TOO_SMALL", "Caller's buffer is too small.",
	//604L
	ERROR_WRONG_INFO_SPECIFIED,		"ERROR_WRONG_INFO_SPECIFIED", "Wrong information specified.",
	//605L
	ERROR_CANNOT_SET_PORT_INFO,		"ERROR_CANNOT_SET_PORT_INFO", "Cannot set port information.",
	//606L
	ERROR_PORT_NOT_CONNECTED,		"ERROR_PORT_NOT_CONNECTED", "The port is not connected.",
	//607L
	ERROR_EVENT_INVALID,			"ERROR_EVENT_INVALID", "The event is invalid.",
	//608L
	ERROR_DEVICE_DOES_NOT_EXIST,	"ERROR_DEVICE_DOES_NOT_EXIST", "The device does not exist.",
	//609L
	ERROR_DEVICETYPE_DOES_NOT_EXIST, "ERROR_DEVICETYPE_DOES_NOT_EXIST", "The device type does not exist.",
	//610L
	ERROR_BUFFER_INVALID,			"ERROR_BUFFER_INVALID", "The buffer is invalid.",
	//611L
	ERROR_ROUTE_NOT_AVAILABLE,		"ERROR_ROUTE_NOT_AVAILABLE", "The route is not available.",
	//612L
	ERROR_ROUTE_NOT_ALLOCATED,		"ERROR_ROUTE_NOT_ALLOCATED", "The route is not allocated.",
	//613L
	ERROR_INVALID_COMPRESSION_SPECIFIED, "ERROR_INVALID_COMPRESSION_SPECIFIED", "Invalid compression specified.",
	//614L
	ERROR_OUT_OF_BUFFERS,			"ERROR_OUT_OF_BUFFERS", "Out of buffers.",
	//615L
	ERROR_PORT_NOT_FOUND,			"ERROR_PORT_NOT_FOUND", "The port was not found.",

	//630L
	ERROR_HARDWARE_FAILURE,			"ERROR_HARDWARE_FAILURE", "The port was disconnected due to hardware failure.",
	//631L
	ERROR_USER_DISCONNECTION,		"ERROR_USER_DISCONNECTION", "The port was disconnected by the user.",
	//632L
	ERROR_INVALID_SIZE,				"ERROR_INVALID_SIZE", "The structure size is incorrect.",
	// End RAS errors


	//994L
	ERROR_EA_ACCESS_DENIED,			"ERROR_EA_ACCESS_DENIED", "Access to the extended attribute was denied.",
	//995L
	ERROR_OPERATION_ABORTED,		"ERROR_OPERATION_ABORTED", "The I/O operation has been aborted because of either a thread exit or an application request.",
	//996L
	ERROR_IO_INCOMPLETE,			"ERROR_IO_INCOMPLETE", "Overlapped I/O event is not in a signaled state.",
	//997L
	ERROR_IO_PENDING,				"ERROR_IO_PENDING", "Overlapped I/O operation is in progress.",
	//998L
	ERROR_NOACCESS,					"ERROR_NOACCESS", "Invalid access to memory location.",
	//999L
	ERROR_SWAPERROR,				"ERROR_SWAPERROR", "Error performing inpage operation.",
	//1001L
	ERROR_STACK_OVERFLOW,			"ERROR_STACK_OVERFLOW", "Recursion too deep; the stack overflowed.",
	//1002L
	ERROR_INVALID_MESSAGE,			"ERROR_INVALID_MESSAGE", "The window cannot act on the sent message.",
	//1003L
	ERROR_CAN_NOT_COMPLETE,			"ERROR_CAN_NOT_COMPLETE", "Cannot complete this function.",
	//1004L
	ERROR_INVALID_FLAGS,			"ERROR_INVALID_FLAGS", "Invalid flags.",
	//1005L
	ERROR_UNRECOGNIZED_VOLUME,		"ERROR_UNRECOGNIZED_VOLUME", "The volume does not contain a recognized file system.",
	//1006L
	ERROR_FILE_INVALID,				"ERROR_FILE_INVALID", "The volume for a file has been externally altered so that the opened file is no longer valid.",
	//1007L
	ERROR_FULLSCREEN_MODE,			"ERROR_FULLSCREEN_MODE", "The requested operation cannot be performed in full-screen mode.",
	//1008L
	ERROR_NO_TOKEN,					"ERROR_NO_TOKEN", "An attempt was made to reference a token that does not exist.",
	//1009L
	ERROR_BADDB,					"ERROR_BADDB", "The configuration registry database is corrupt.",
	//1010L
	ERROR_BADKEY,					"ERROR_BADKEY", "The configuration registry key is invalid.",
	//1011L
	ERROR_CANTOPEN,					"ERROR_CANTOPEN", "The configuration registry key could not be opened.",
	//1012L
	ERROR_CANTREAD,					"ERROR_CANTREAD", "The configuration registry key could not be read.",
	//1013L
	ERROR_CANTWRITE,				"ERROR_CANTWRITE", "The configuration registry key could not be written.",
	//1014L
	ERROR_REGISTRY_RECOVERED,		"ERROR_REGISTRY_RECOVERED", "One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.",

	//1109L
	ERROR_UNABLE_TO_UNLOAD_MEDIA,	"ERROR_UNABLE_TO_UNLOAD_MEDIA", "Unable to unload the media.",
	//1110L
	ERROR_MEDIA_CHANGED,			"ERROR_MEDIA_CHANGED", "The media in the drive may have changed.",
	//1111L
	ERROR_BUS_RESET,				"ERROR_BUS_RESET", "The I/O bus was reset.",
	//1112L
	ERROR_NO_MEDIA_IN_DRIVE,		"ERROR_NO_MEDIA_IN_DRIVE", "No media in drive.",
	//1113L
	ERROR_NO_UNICODE_TRANSLATION,	"ERROR_NO_UNICODE_TRANSLATION", "No mapping for the Unicode character exists in the target multi-byte code page.",
	//1114L
	ERROR_DLL_INIT_FAILED,			"ERROR_DLL_INIT_FAILED", "A dynamic link library (DLL) initialization routine failed.",
	//1115L
	ERROR_SHUTDOWN_IN_PROGRESS,		"ERROR_SHUTDOWN_IN_PROGRESS", "A system shutdown is in progress.",
	//1116L
	ERROR_NO_SHUTDOWN_IN_PROGRESS,	"ERROR_NO_SHUTDOWN_IN_PROGRESS", "Unable to abort the system shutdown because no shutdown was in progress.",
	//1117L
	ERROR_IO_DEVICE,				"ERROR_IO_DEVICE", "The request could not be performed because of an I/O device error.",
	//1118L
	ERROR_SERIAL_NO_DEVICE,			"ERROR_SERIAL_NO_DEVICE", "No serial device was successfully initialized. The serial driver will unload.",
	//1119L
	ERROR_IRQ_BUSY,					"ERROR_IRQ_BUSY", "Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.",
	//1120L
	ERROR_MORE_WRITES,				"ERROR_MORE_WRITES", "A serial I/O operation was completed by another write to the serial port (the IOCTL_SERIAL_XOFF_COUNTER reached zero).",

	//1156L
	ERROR_DDE_FAIL,					"ERROR_DDE_FAIL", "An error occurred in sending the command to the application.",
	//1157L
	ERROR_DLL_NOT_FOUND,			"ERROR_DLL_NOT_FOUND", "One of the library files needed to run this application cannot be found.",
	//1158L
	ERROR_NO_MORE_USER_HANDLES,		"ERROR_NO_MORE_USER_HANDLES", "The current process has used all of its system allowance of handles for Window Manager objects.",
	//1159L
	ERROR_MESSAGE_SYNC_ONLY,		"ERROR_MESSAGE_SYNC_ONLY", "The message can be used only with synchronous operations.",
	//1160L
	ERROR_SOURCE_ELEMENT_EMPTY,		"ERROR_SOURCE_ELEMENT_EMPTY", "The indicated source element has no media.",
	//1161L
	ERROR_DESTINATION_ELEMENT_FULL,	"ERROR_DESTINATION_ELEMENT_FULL", "The indicated destination element already contains media.",
	//1162L
	ERROR_ILLEGAL_ELEMENT_ADDRESS,	"ERROR_ILLEGAL_ELEMENT_ADDRESS", "The indicated element does not exist.",
	//1163L
	ERROR_MAGAZINE_NOT_PRESENT,		"ERROR_MAGAZINE_NOT_PRESENT", "The indicated element is part of a magazine that is not present.",
	//1164L
	ERROR_DEVICE_REINITIALIZATION_NEEDED, "ERROR_DEVICE_REINITIALIZATION_NEEDED", "The indicated device requires reinitialization due to hardware errors.",
	//1165L
	ERROR_DEVICE_REQUIRES_CLEANING,	"ERROR_DEVICE_REQUIRES_CLEANING", "The device has indicated that cleaning is required before further operations are attempted.",
	//1166L
	ERROR_DEVICE_DOOR_OPEN,			"ERROR_DEVICE_DOOR_OPEN", "The device has indicated that its door is open.",
	//1167L
	ERROR_DEVICE_NOT_CONNECTED,		"ERROR_DEVICE_NOT_CONNECTED", "The device is not connected.",
	//1168L
	ERROR_NOT_FOUND,				"ERROR_NOT_FOUND", "Element not found.",
	//1169L
	ERROR_NO_MATCH,					"ERROR_NO_MATCH", "There was no match for the specified key in the index.",
	//1170L
	ERROR_SET_NOT_FOUND,			"ERROR_SET_NOT_FOUND", "The property set specified does not exist on the object.",
	//1171L
	ERROR_POINT_NOT_FOUND,			"ERROR_POINT_NOT_FOUND", "The point passed to GetMouseMovePoints is not in the buffer.",

	//1400L
	ERROR_INVALID_WINDOW_HANDLE,	"ERROR_INVALID_WINDOW_HANDLE", "Invalid window handle.",
	//1401L
	ERROR_INVALID_MENU_HANDLE,		"ERROR_INVALID_MENU_HANDLE", "Invalid menu handle.",
	//1402L
	ERROR_INVALID_CURSOR_HANDLE,	"ERROR_INVALID_CURSOR_HANDLE", "Invalid cursor handle.",
	//1403L
	ERROR_INVALID_ACCEL_HANDLE,		"ERROR_INVALID_ACCEL_HANDLE", "Invalid accelerator table handle.",
	//1404L
	ERROR_INVALID_HOOK_HANDLE,		"ERROR_INVALID_HOOK_HANDLE", "Invalid hook handle.",
	//1405L
	ERROR_INVALID_DWP_HANDLE,		"ERROR_INVALID_DWP_HANDLE", "Invalid handle to a multiple-window position structure.",
	//1406L
	ERROR_TLW_WITH_WSCHILD,			"ERROR_TLW_WITH_WSCHILD", "Cannot create a top-level child window.",
	//1407L
	ERROR_CANNOT_FIND_WND_CLASS,	"ERROR_CANNOT_FIND_WND_CLASS", "Cannot find window class.",
	//1408L
	ERROR_WINDOW_OF_OTHER_THREAD,	"ERROR_WINDOW_OF_OTHER_THREAD", "Invalid window; it belongs to other thread.",

	//1417L
	ERROR_NO_WILDCARD_CHARACTERS,	"ERROR_NO_WILDCARD_CHARACTERS", "No wildcards were found.",
	//1418L
	ERROR_CLIPBOARD_NOT_OPEN,		"ERROR_CLIPBOARD_NOT_OPEN", "Thread does not have a clipboard open.",
	//1419L
	ERROR_HOTKEY_NOT_REGISTERED,	"ERROR_HOTKEY_NOT_REGISTERED", "Hot key is not registered.",
	//1420L
	ERROR_WINDOW_NOT_DIALOG,		"ERROR_WINDOW_NOT_DIALOG", "The window is not a valid dialog window.",
	//1421L
	ERROR_CONTROL_ID_NOT_FOUND,		"ERROR_CONTROL_ID_NOT_FOUND", "Control ID not found.",
	//1422L
	ERROR_INVALID_COMBOBOX_MESSAGE,	"ERROR_INVALID_COMBOBOX_MESSAGE", "Invalid message for a combo box because it does not have an edit control.",

	//1454L
	ERROR_PAGEFILE_QUOTA,			"ERROR_PAGEFILE_QUOTA", "Insufficient quota to complete the requested service.",
	//1455L
	ERROR_COMMITMENT_LIMIT,			"ERROR_COMMITMENT_LIMIT", "The paging file is too small for this operation to complete.",
	//1456L
	ERROR_MENU_ITEM_NOT_FOUND,		"ERROR_MENU_ITEM_NOT_FOUND", "A menu item was not found.",
	//1457L
	ERROR_INVALID_KEYBOARD_HANDLE,	"ERROR_INVALID_KEYBOARD_HANDLE", "Invalid keyboard layout handle.",
	//1458L
	ERROR_HOOK_TYPE_NOT_ALLOWED,	"ERROR_HOOK_TYPE_NOT_ALLOWED", "Hook type not allowed.",

	//1812L
	ERROR_RESOURCE_DATA_NOT_FOUND,	"ERROR_RESOURCE_DATA_NOT_FOUND", "The specified image file did not contain a resource section.",
	//1813L
	ERROR_RESOURCE_TYPE_NOT_FOUND,	"ERROR_RESOURCE_TYPE_NOT_FOUND", "The specified resource type cannot be found in the image file.",
	//1814L
	ERROR_RESOURCE_NAME_NOT_FOUND,	"ERROR_RESOURCE_NAME_NOT_FOUND", "The specified resource name cannot be found in the image file.",
	//1815L
	ERROR_RESOURCE_LANG_NOT_FOUND,	"ERROR_RESOURCE_LANG_NOT_FOUND", "The specified resource language ID cannot be found in the image file.",

	// Begin WMI errors
	//4200L
	ERROR_WMI_GUID_NOT_FOUND,		"ERROR_WMI_GUID_NOT_FOUND", "The GUID passed was not recognized as valid by a WMI data provider.",
	//4201L
	ERROR_WMI_INSTANCE_NOT_FOUND,	"ERROR_WMI_INSTANCE_NOT_FOUND", "The instance name passed was not recognized as valid by a WMI data provider.",
	//4202L
	ERROR_WMI_ITEMID_NOT_FOUND,		"ERROR_WMI_ITEMID_NOT_FOUND", "The data item ID passed was not recognized as valid by a WMI data provider.",
	//4203L
	ERROR_WMI_TRY_AGAIN,			"ERROR_WMI_TRY_AGAIN", "The WMI request could not be completed and should be retried.",
	//4204L
	ERROR_WMI_DP_NOT_FOUND,			"ERROR_WMI_DP_NOT_FOUND", "The WMI data provider could not be located.",
	//4205L
	ERROR_WMI_UNRESOLVED_INSTANCE_REF, "ERROR_WMI_UNRESOLVED_INSTANCE_REF", "The WMI data provider references an instance set that has not been registered.",

	// End WMI errors


#ifndef NO_ERRORS_WINSOCK
	// Begin WinSock errors
	//10004L
	WSAEINTR,						"WSAEINTR", "Interrupted function call.",
	//10009L
	WSAEBADF,						"WSAEBADF", "The file handle supplied is invalid.",
	//10013L
	WSAEACCES,						"WSAEACCES", "An attempt was made to access a socket in a way forbidden by its access permissions.",
	//10014L
	WSAEFAULT,						"WSAEFAULT", "The system detected an invalid pointer address in attempting to use a pointer argument in a call.",
	//10022L
	WSAEINVAL,						"WSAEINVAL", "An invalid argument was supplied.",
	//10024L
	WSAEMFILE,						"WSAEMFILE", "Too many open sockets.",

	//10035L
	WSAEWOULDBLOCK,					"WSAEWOULDBLOCK", "A non-blocking socket operation could not be completed immediately.",
	//10036L
	WSAEINPROGRESS,					"WSAEINPROGRESS", "A blocking operation is currently executing.",
	//10037L
	WSAEALREADY,					"WSAEALREADY", "An operation was attempted on a non-blocking socket that already had an operation in progress.",
	//10038L
	WSAENOTSOCK,					"WSAENOTSOCK", "Socket operation on a non-socket.",
	//10039L
	WSAEDESTADDRREQ,				"WSAEDESTADDRREQ", "A required address was omitted from an operation on a socket.",
	//10040L
	WSAEMSGSIZE,					"WSAEMSGSIZE", "Message too long.",
	//10041L
	WSAEPROTOTYPE,					"WSAEPROTOTYPE", "A protocol was specified in the socket function call that does not support the semantics of the socket type requested.",
	//10042L
	WSAENOPROTOOPT,					"WSAENOPROTOOPT", "An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.",
	//10043L
	WSAEPROTONOSUPPORT,				"WSAEPROTONOSUPPORT", "Invalid flags.",
	//10044L
	WSAESOCKTNOSUPPORT,				"WSAESOCKTNOSUPPORT", "The support for the specified socket type does not exist in this address family.",
	//10045L
	WSAEOPNOTSUPP,					"WSAEOPNOTSUPP", "Operation not supported.",
	//10046L
	WSAEPFNOSUPPORT,				"WSAEPFNOSUPPORT", "The protocol family has not been configured into the system or no implementation for it exists.",
	//10047L
	WSAEAFNOSUPPORT,				"WSAEAFNOSUPPORT", "Address family not supported by protocol family.",
	//10048L
	WSAEADDRINUSE,					"WSAEADDRINUSE", "Address already in use.",
	//10049L
	WSAEADDRNOTAVAIL,				"WSAEADDRNOTAVAIL", "Cannot assign requested address.",
	//10050L
	WSAENETDOWN,					"WSAENETDOWN", "Network is down.",
	//10051L
	WSAENETUNREACH,					"WSAENETUNREACH", "Network is unreachable.",
	//10052L
	WSAENETRESET,					"WSAENETRESET", "Network dropped connection on reset.",
	//10053L
	WSAECONNABORTED,				"WSAECONNABORTED", "Software caused connection abort.",
	//10054L
	WSAECONNRESET,					"WSAECONNRESET", "Connection reset by peer.",
	//10055L
	WSAENOBUFS,						"WSAENOBUFS", "No buffer space available.",
	//10056L
	WSAEISCONN,						"WSAEISCONN", "Socket is already connected.",
	//10057L
	WSAENOTCONN,					"WSAENOTCONN", "Socket is not connected.",
	//10058L
	WSAESHUTDOWN,					"WSAESHUTDOWN", "Cannot send after socket shutdown.",
	//10059L
	WSAETOOMANYREFS,				"WSAETOOMANYREFS", "Too many references to some kernel object.",
	//10060L
	WSAETIMEDOUT,					"WSAETIMEDOUT", "Connection timed out.",
	//10061L
	WSAECONNREFUSED,				"WSAECONNREFUSED", "Connection refused.",
	//10062L
	WSAELOOP,						"WSAELOOP", "Cannot translate name.",
	//10063L
	WSAENAMETOOLONG,				"WSAENAMETOOLONG", "Name component or name was too long.",
	//10064L
	WSAEHOSTDOWN,					"WSAEHOSTDOWN", "A socket operation failed because the destination host was down.",
	//10065L
	WSAEHOSTUNREACH,				"WSAEHOSTUNREACH", "A socket operation was attempted to an unreachable host.",
	//10066L
	WSAENOTEMPTY,					"WSAENOTEMPTY", "Cannot remove a directory that is not empty.",
	//10067L
	WSAEPROCLIM,					"WSAEPROCLIM", "A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.",
	//10068L
	WSAEUSERS,						"WSAEUSERS", "Ran out of quota.",
	//10069L
	WSAEDQUOT,						"WSAEDQUOT", "Ran out of disk quota.",
	//10070L
	WSAESTALE,						"WSAESTALE", "File handle reference is no longer available.",
	//10071L
	WSAEREMOTE,						"WSAEREMOTE", "Item is not available locally.",

	//10091L
	WSASYSNOTREADY,					"WSASYSNOTREADY", "WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.",
	//10092L
	WSAVERNOTSUPPORTED,				"WSAVERNOTSUPPORTED", "The Windows Sockets version requested is not supported.",
	//10093L
	WSANOTINITIALISED,				"WSANOTINITIALISED", "Either the application has not called WSAStartup, or WSAStartup failed.",

	//10101L
	WSAEDISCON,						"WSAEDISCON", NULL,

	//10112L
	WSAEREFUSED,					"WSAEREFUSED", "A database query failed because it was actively refused.",

	//11001L
	WSAHOST_NOT_FOUND,				"WSAHOST_NOT_FOUND", "No such host is known.",
	//11002L
	WSATRY_AGAIN,					"WSATRY_AGAIN", "This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.",
	//11003L
	WSANO_RECOVERY,					"WSANO_RECOVERY", "A non-recoverable error occurred during a database lookup.",
	//11004L
	WSANO_DATA,						"WSANO_DATA", "The requested name is valid and was found in the database, but it does not have the correct associated data being resolved for.",

	//11015L
	WSA_QOS_GENERIC_ERROR,			"WSA_QOS_GENERIC_ERROR", "General QOS error.",
	// End WinSock errors
#endif // ! NO_ERRORS_WINSOCK


#ifndef _XBOX // no TAPI supported
	// Begin TAPI errors
	//0x80000001L
	LINEERR_ALLOCATED,				"LINEERR_ALLOCATED", NULL,
	//0x80000002L
	LINEERR_BADDEVICEID,			"LINEERR_BADDEVICEID", NULL,
	//0x80000003L
	LINEERR_BEARERMODEUNAVAIL,		"LINEERR_BEARERMODEUNAVAIL", NULL,
	//0x80000005L
	LINEERR_CALLUNAVAIL,			"LINEERR_CALLUNAVAIL", NULL,
	//0x80000006L
	LINEERR_COMPLETIONOVERRUN,		"LINEERR_COMPLETIONOVERRUN", NULL,
	//0x80000007L
	LINEERR_CONFERENCEFULL,			"LINEERR_CONFERENCEFULL", NULL,
	//0x80000008L
	LINEERR_DIALBILLING,			"LINEERR_DIALBILLING", NULL,
	//0x80000009L
	LINEERR_DIALDIALTONE,			"LINEERR_DIALDIALTONE", NULL,
	//0x8000000BL
	LINEERR_DIALQUIET,				"LINEERR_DIALQUIET", NULL,
	//0x8000000CL
	LINEERR_INCOMPATIBLEAPIVERSION, "LINEERR_INCOMPATIBLEAPIVERSION", NULL,
	//0x8000000DL
	LINEERR_INCOMPATIBLEEXTVERSION, "LINEERR_INCOMPATIBLEEXTVERSION", NULL,
	//0x80000048L
	LINEERR_OPERATIONFAILED,		"LINEERR_OPERATIONFAILED", NULL,
	//0x80000049L
	LINEERR_OPERATIONUNAVAIL,		"LINEERR_OPERATIONUNAVAIL", NULL,
	// End TAPI errors
#endif // ! XBOX

	//0x8000000AL
	// LINEERR_DIALPROMPT
	// DPERR_PENDING
	// DVERR_PENDING
	// DPNERR_PENDING
	E_PENDING,						"E_PENDING, LINEERR_DIALPROMPT", "Not an error, this return indicates that an asynchronous command has reached the point where it is successfully queued.",

	//0x80010100L
	RPC_E_SYS_CALL_FAILED,			"RPC_E_SYS_CALL_FAILED", "System call failed.",
	//0x80010101L
	RPC_E_OUT_OF_RESOURCES,			"RPC_E_OUT_OF_RESOURCES", "Could not allocate some required resource (memory, events, ...).",
	//0x80010102L
	RPC_E_ATTEMPTED_MULTITHREAD,	"RPC_E_ATTEMPTED_MULTITHREAD", "Attempted to make calls on more than one thread in single threaded mode.",
	//0x80010103L
	RPC_E_NOT_REGISTERED,			"RPC_E_NOT_REGISTERED", "The requested interface is not registered on the server object.",
	//0x80010104L
	RPC_E_FAULT,					"RPC_E_FAULT", "RPC could not call the server or could not return the results of calling the server.",
	//0x80010105L
	RPC_E_SERVERFAULT,				"RPC_E_SERVERFAULT", "The server threw an exception.",
	//0x80010106L
	RPC_E_CHANGED_MODE,				"RPC_E_CHANGED_MODE", "Cannot change thread mode after it is set.",
	//0x80010107L
	RPC_E_INVALIDMETHOD,			"RPC_E_INVALIDMETHOD", "The method called does not exist on the server.",
	//0x80010108L
	RPC_E_DISCONNECTED,				"RPC_E_DISCONNECTED", "The object invoked has disconnected from its clients.",
	//0x80010109L
	RPC_E_RETRY,					"RPC_E_RETRY", "The object invoked chose not to process the call now.  Try again later.",
	//0x8001010AL
	RPC_E_SERVERCALL_RETRYLATER,	"RPC_E_SERVERCALL_RETRYLATER", "The message filter indicated that the application is busy.",
	//0x8001010BL
	RPC_E_SERVERCALL_REJECTED,		"RPC_E_SERVERCALL_REJECTED", "The message filter rejected the call.",
	//0x8001010CL
	RPC_E_INVALID_CALLDATA,			"RPC_E_INVALID_CALLDATA", "A call control interfaces was called with invalid data.",
	//0x8001010DL
	RPC_E_CANTCALLOUT_ININPUTSYNCCALL, "RPC_E_CANTCALLOUT_ININPUTSYNCCALL", "An outgoing call cannot be made since the application is dispatching an input-synchronous call.",


	//0x80004001L
	// DPERR_UNSUPPORTED,
	// DVERR_UNSUPPORTED,
	// DPNERR_UNSUPPORTED,
	E_NOTIMPL,						"E_NOTIMPL, DPERR_UNSUPPORTED", "The function or feature is not available in this implementation.",
	//0x80004002L
	// DPERR_NOINTERFACE,
	// DVERR_NOINTERFACE,
	// DPNERR_NOINTERFACE,
	E_NOINTERFACE,					"E_NOINTERFACE", "No such interface supported.",

	//0x80004003L
	// DVERR_INVALIDPOINTER
	E_POINTER,						"E_POINTER", "Invalid pointer.",

	//0x80004005L
	// DPERR_GENERIC
	// DPNERR_GENERIC
	E_FAIL,							"E_FAIL, DPERR_GENERIC", "An undefined error condition occurred.",


	//0x80040110L
	CLASS_E_NOAGGREGATION,			"CLASS_E_NOAGGREGATION", "Class does not support aggregation (or class object is remote).",
	//0x80040111L
	CLASS_E_CLASSNOTAVAILABLE,		"CLASS_E_CLASSNOTAVAILABLE", "ClassFactory cannot supply requested class.",
	//0x80040112L
	CLASS_E_NOTLICENSED,			"CLASS_E_NOTLICENSED", "Class is not licensed for use.",

	//0x80040154L
	REGDB_E_CLASSNOTREG,			"REGDB_E_CLASSNOTREG", "Class not registered.",
	//0x80040155L
	REGDB_E_IIDNOTREG,				"REGDB_E_IIDNOTREG", "Interface not registered.",

	//0x80070005L
	E_ACCESSDENIED,					"E_ACCESSDENIED", NULL,
	//0x80070006L
	E_HANDLE,						"E_HANDLE", "Invalid handle.",

	//0x8007000EL
	// DPERR_NOMEMORY
	// DPERR_OUTOFMEMORY
	// DVERR_OUTOFMEMORY
	// DPNERR_OUTOFMEMORY
	E_OUTOFMEMORY,					"E_OUTOFMEMORY", "There is insufficient memory to perform the requested operation.",

	//0x80070057L
	// E_INVALIDARG
	// DPERR_INVALIDPARAM
	// DPERR_INVALIDPARAMS
	// DVERR_INVALIDPARAM
	// DPNERR_INVALIDPARAM
	E_INVALIDARG,					"E_INVALIDARG", "One or more arguments is invalid.",

	//0x8007007EL
	// ERROR_MOD_NOT_FOUND
	(0x80070000 + ERROR_MOD_NOT_FOUND), "ERROR_MOD_NOT_FOUND", "The specified module could not be found.",

	//0x800703E6L
	0x800703E6,						"0x800703E6?", "Seen when CoCreating an object not \"ThreadingModel=Both\" after CoInitializeEx.",


#ifndef NO_ERRORS_SECURITY
	//0x80090001L
	NTE_BAD_UID,					"NTE_BAD_UID", "Bad UID.",
	//0x80090002L
	NTE_BAD_HASH,					"NTE_BAD_HASH", "Bad hash.",
	//0x80090003L
	NTE_BAD_KEY,					"NTE_BAD_KEY", "Bad key.",
	//0x80090004L
	NTE_BAD_LEN,					"NTE_BAD_LEN", "Bad length.",
	//0x80090005L
	NTE_BAD_DATA,					"NTE_BAD_DATA", "Bad data.",
	//0x80090006L
	NTE_BAD_SIGNATURE,				"NTE_BAD_SIGNATURE", "Invalid signature.",
	//0x80090007L
	NTE_BAD_VER,					"NTE_BAD_VER", "Bad version of provider.",
	//0x80090008L
	NTE_BAD_ALGID,					"NTE_BAD_ALGID", "Invalid algorithm specified.",
	//0x80090009L
	NTE_BAD_FLAGS,					"NTE_BAD_FLAGS", "Invalid flags specified.",
	//0x8009000AL
	NTE_BAD_TYPE,					"NTE_BAD_TYPE", "Invalid type specified.",
	//0x8009000BL
	NTE_BAD_KEY_STATE,				"NTE_BAD_KEY_STATE", "Key not valid for use in specified state.",
	//0x8009000CL
	NTE_BAD_HASH_STATE,				"NTE_BAD_HASH_STATE", "Hash not valid for use in specified state.",
	//0x8009000DL
	NTE_NO_KEY,						"NTE_NO_KEY", "Key does not exist.",
	//0x8009000EL
	NTE_NO_MEMORY,					"NTE_NO_MEMORY", "Insufficient memory available for the operation.",
	//0x8009000FL
	NTE_EXISTS,						"NTE_EXISTS", "Object already exists.",
	//0x80090010L
	NTE_PERM,						"NTE_PERM", "Access denied.",
	//0x80090011L
	NTE_NOT_FOUND,					"NTE_NOT_FOUND", "Object was not found.",
	//0x80090012L
	NTE_DOUBLE_ENCRYPT,				"NTE_DOUBLE_ENCRYPT", "Data already encrypted.",
	//0x80090013L
	NTE_BAD_PROVIDER,				"NTE_BAD_PROVIDER", "Invalid provider specified.",
	//0x80090014L
	NTE_BAD_PROV_TYPE,				"NTE_BAD_PROV_TYPE", "Invalid provider type specified.",
	//0x80090015L
	NTE_BAD_PUBLIC_KEY,				"NTE_BAD_PUBLIC_KEY", "Provider's public key is invalid.",
	//0x80090016L
	NTE_BAD_KEYSET,					"NTE_BAD_KEYSET", "Keyset does not exist.",
	//0x80090017L
	NTE_PROV_TYPE_NOT_DEF,			"NTE_PROV_TYPE_NOT_DEF", "Provider type not defined.",
	//0x80090018L
	NTE_PROV_TYPE_ENTRY_BAD,		"NTE_PROV_TYPE_ENTRY_BAD", "Provider type as registered is invalid.",

	//0x8009030CL
	SEC_E_LOGON_DENIED,				"SEC_E_LOGON_DENIED", "The logon attempt failed.",
	//0x8009030DL
	SEC_E_UNKNOWN_CREDENTIALS,		"SEC_E_UNKNOWN_CREDENTIALS", "The credentials supplied to the package were not recognized.",
	//0x8009030EL
	SEC_E_NO_CREDENTIALS,			"SEC_E_NO_CREDENTIALS", "No credentials are available in the security package.",
	//0x8009030FL
	SEC_E_MESSAGE_ALTERED,			"SEC_E_MESSAGE_ALTERED", "The message supplied for verification has been altered.",
	//0x80090310L
	SEC_E_OUT_OF_SEQUENCE,			"SEC_E_OUT_OF_SEQUENCE", "The message supplied for verification is out of sequence.",
	//0x80090311L
	SEC_E_NO_AUTHENTICATING_AUTHORITY, "SEC_E_NO_AUTHENTICATING_AUTHORITY", "No authority could be contacted for authentication.",
	//0x80090312L
	SEC_I_CONTINUE_NEEDED,			"SEC_I_CONTINUE_NEEDED", "The function completed successfully, but must be called again to complete the context.",
	//0x80090313L
	SEC_I_COMPLETE_NEEDED,			"SEC_I_COMPLETE_NEEDED", "The function completed successfully, but CompleteToken must be called.",
#endif // ! NO_ERRORS_SECURITY

	E_UNEXPECTED,					"E_UNEXPECTED", NULL,
	CO_E_NOTINITIALIZED,			"CO_E_NOTINITIALIZED", NULL,
	CLASS_E_NOAGGREGATION,			"CLASS_E_NOAGGREGATION", NULL,
	ERROR_NOT_LOCKED,				"ERROR_NOT_LOCKED", NULL,
	ERROR_DISK_FULL,				"ERROR_DISK_FULL", NULL,
	ERROR_ACCESS_DENIED,			"ERROR_ACCESS_DENIED", NULL,
	ERROR_FILE_EXISTS,				"ERROR_FILE_EXISTS", NULL,
	ERROR_INVALID_NAME,				"ERROR_INVALID_NAME", "The filename, directory name, or volume label syntax is incorrect.",
	ERROR_UNEXP_NET_ERR,			"ERROR_UNEXP_NET_ERR", "An unexpected network error occurred.",


#ifndef NO_ERRORS_DPLAY
	// Begin DPlay errors
	DPERR_ACCESSDENIED,				"DPERR_ACCESSDENIED", "The session is full, or an incorrect password was supplied.",
	DPERR_ACTIVEPLAYERS,			"DPERR_ACTIVEPLAYERS", "The requested operation cannot be performed because there are existing active players.",
	DPERR_ALREADYINITIALIZED,		"DPERR_ALREADYINITIALIZED", "This object is already initialized.",
	DPERR_APPNOTSTARTED,			"DPERR_APPNOTSTARTED", "The application has not been started yet.",
	DPERR_BUFFERTOOLARGE,			"DPERR_BUFFERTOOLARGE", "The data buffer is too large to store.",
	DPERR_BUFFERTOOSMALL,			"DPERR_BUFFERTOOSMALL", "The supplied buffer is not large enough to contain the requested data.",
	DPERR_BUSY,						"DPERR_BUSY", "A message cannot be sent because the transmission medium is busy.",
	DPERR_CANCELFAILED,				"DPERR_CANCELFAILED", "The message could not be canceled, possibly because it is a group message that has already been to sent to one or more members of the group.",
	DPERR_CANTADDPLAYER,			"DPERR_CANTADDPLAYER", "The player cannot be added to the session.",
	DPERR_CANTCREATEGROUP,			"DPERR_CANTCREATEGROUP", "A new group cannot be created.",
	DPERR_CANTCREATEPLAYER,			"DPERR_CANTCREATEPLAYER", "A new player cannot be created.",
	DPERR_CANTCREATEPROCESS,		"DPERR_CANTCREATEPROCESS", "Cannot start the application.",
	DPERR_CANTCREATESESSION,		"DPERR_CANTCREATESESSION", "A new session cannot be created.",
	DPERR_CANTLOADCAPI,				"DPERR_CANTLOADCAPI", "No credentials were supplied and the CryptoAPI package (CAPI) to use for cryptography services cannot be loaded.",
	DPERR_CANTLOADSECURITYPACKAGE,	"DPERR_CANTLOADSECURITYPACKAGE", "The software security package cannot be loaded.",
	DPERR_CANTLOADSSPI,				"DPERR_CANTLOADSSPI", "No credentials were supplied, and the Security Support Provider Interface (SSPI) that will prompt for credentials cannot be loaded.",
	DPERR_CAPSNOTAVAILABLEYET,		"DPERR_CAPSNOTAVAILABLEYET", "The capabilities of the DirectPlay object have not been determined yet. This error will occur if the DirectPlay object is implemented on a connectivity solution that requires polling to determine available bandwidth and latency.",
	DPERR_CONNECTING,				"DPERR_CONNECTING", "The method is in the process of connecting to the network. The application should keep using the method until it returns DP_OK, indicating successful completion, or until it returns a different error.",
	DPERR_CONNECTIONLOST,			"DPERR_CONNECTIONLOST", "The service provider connection was reset while data was being sent.",
	DPERR_ENCRYPTIONFAILED,			"DPERR_ENCRYPTIONFAILED", "The requested information could not be digitally encrypted. Encryption is used for message privacy. This error is only relevant in a secure session.",
	DPERR_EXCEPTION,				"DPERR_EXCEPTION", "An exception occurred when processing the request.",
	DPERR_INVALIDFLAGS,				"DPERR_INVALIDFLAGS", "The flags passed to this method are invalid.",
	DPERR_INVALIDGROUP,				"DPERR_INVALIDGROUP", "The group ID is not recognized as a valid group ID for this game session.",
	DPERR_INVALIDINTERFACE,			"DPERR_INVALIDINTERFACE", "The interface parameter is invalid.",
	DPERR_INVALIDOBJECT,			"DPERR_INVALIDOBJECT", "The DirectPlay object pointer is invalid.",
	DPERR_INVALIDPASSWORD,			"DPERR_INVALIDPASSWORD", "An invalid password was supplied when attempting to join a session that requires a password'",
	DPERR_INVALIDPLAYER,			"DPERR_INVALIDPLAYER", "The player ID is not recognized as a valid player ID for this game session.",
	DPERR_INVALIDPRIORITY,			"DPERR_INVALIDPRIORITY", "The specified priority is not within the range of allowed priorities, which is inclusively 0-65535.",
	DPERR_LOGONDENIED,				"DPERR_LOGONDENIED", "The session could not be opened because credentials are required, and either no credentials were supplied, or the credentials were invalid.",
	DPERR_NOCAPS,					"DPERR_NOCAPS", "The communication link that DirectPlay is attempting to use is not capable of this function.",
	DPERR_NOCONNECTION,				"DPERR_NOCONNECTION", "No communication link was established.",
	DPERR_NOMESSAGES,				"DPERR_NOMESSAGES", "There are no messages in the receive queue.",
	DPERR_NONAMESERVERFOUND,		"DPERR_NONAMESERVERFOUND", "No name server (host) could be found or created. A host must exist to create a player.",
	DPERR_NONEWPLAYERS,				"DPERR_NONEWPLAYERS", "The session is not accepting any new players.",
	DPERR_NOPLAYERS,				"DPERR_NOPLAYERS", "There are no active players in the session.",
	DPERR_NOSESSIONS,				"DPERR_NOSESSIONS", "There are no existing sessions for this game.",
	DPERR_NOTLOBBIED,				"DPERR_NOTLOBBIED", "Returned by the IDirectPlayLobby3::Connect method if the application was not started by using the IDirectPlayLobby3::RunApplication method, or if there is no DPLCONNECTION structure currently initialized for this DirectPlayLobby object.",
	DPERR_NOTLOGGEDIN,				"DPERR_NOTLOGGEDIN", "An action cannot be performed because a player or client application is not logged in. Returned by the Send method when the client application tries to send a secure message without being logged in.",
	DPERR_PLAYERLOST,				"DPERR_PLAYERLOST", "A player has lost the connection to the session.",
	DPERR_SENDTOOBIG,				"DPERR_SENDTOOBIG", "The message being sent by the IDirectPlay4::Send method is too large.",
	DPERR_SESSIONLOST,				"DPERR_SESSIONLOST", "The connection to the session has been lost.",
	DPERR_SIGNFAILED,				"DPERR_SIGNFAILED", "The requested information could not be digitally signed. Digital signatures are used to establish the authenticity of messages.",
	DPERR_TIMEOUT,					"DPERR_TIMEOUT", "The operation could not be completed in the specified time.",
	DPERR_UNAVAILABLE,				"DPERR_UNAVAILABLE", "The requested function is not available at this time.",
	DPERR_UNINITIALIZED,			"DPERR_UNINITIALIZED", "The requested object has not been initialized.",
	DPERR_UNKNOWNAPPLICATION,		"DPERR_UNKNOWNAPPLICATION", "An unknown application was specified.",
	DPERR_UNKNOWNMESSAGE,			"DPERR_UNKNOWNMESSAGE", "The message ID isn't valid. Returned from IDirectPlay4::CancelMessage if the ID of the message to be cancelled is invalid.",
	DPERR_USERCANCEL,				"DPERR_USERCANCEL", "The user canceled the connection process during a call to the Open method or the user clicked Cancel in one of the DirectPlay service provider dialog boxes during a call to EnumSessions.",

	// BUGBUG what is this error?
	DPERR_CANNOTCREATESERVER,		"DPERR_CANNOTCREATESERVER", NULL,
	// End DPlay errors
#endif // ! NO_ERRORS_DPLAY

#ifndef NO_ERRORS_DPLAY8
	// Begin DirectPlay8 errors

	//0x00158000 + 5L
	DPNSUCCESS_EQUAL,				"DPNSUCCESS_EQUAL", NULL,
	//0x00158000 + 10L
	DPNSUCCESS_NOTEQUAL,			"DPNSUCCESS_NOTEQUAL", NULL,

	//0x80158030
	DPNERR_ABORTED,					"DPNERR_ABORTED", NULL,
	//0x80158040
	DPNERR_ADDRESSING,				"DPNERR_ADDRESSING", NULL,
	//0x80158050
	DPNERR_ALREADYCLOSING,			"DPNERR_ALREADYCLOSING", NULL,
	//0x80158060
	DPNERR_ALREADYCONNECTED,		"DPNERR_ALREADYCONNECTED", NULL,
	//0x80158070
	DPNERR_ALREADYDISCONNECTING,	"DPNERR_ALREADYDISCONNECTING", NULL,
	//0x80158080
	DPNERR_ALREADYINITIALIZED,		"DPNERR_ALREADYINITIALIZED", NULL,
	//0x80158090
	DPNERR_BUFFERTOOSMALL,			"DPNERR_BUFFERTOOSMALL", NULL,
	//0x80158100
	DPNERR_CANNOTCANCEL,			"DPNERR_CANNOTCANCEL", NULL,
	//0x80158110
	DPNERR_CANTCREATEGROUP,			"DPNERR_CANTCREATEGROUP", NULL,
	//0x80158120
	DPNERR_CANTCREATEPLAYER,		"DPNERR_CANTCREATEPLAYER", NULL,
	//0x80158130
	DPNERR_CANTLAUNCHAPPLICATION,	"DPNERR_CANTLAUNCHAPPLICATION", NULL,
	//0x80158140
	DPNERR_CONNECTING,				"DPNERR_CONNECTING", NULL,
	//0x80158150
	DPNERR_CONNECTIONLOST,			"DPNERR_CONNECTIONLOST", NULL,
	//0x80158160
	DPNERR_CONVERSION,				"DPNERR_CONVERSION", NULL,
	//0x80158170
	DPNERR_DOESNOTEXIST,			"DPNERR_DOESNOTEXIST", NULL,
	//0x80158180
	DPNERR_DUPLICATECOMMAND,		"DPNERR_DUPLICATECOMMAND", NULL,
	//0x80158190
	DPNERR_ENDPOINTNOTRECEIVING,	"DPNERR_ENDPOINTNOTRECEIVING", NULL,
	//0x80158200
	DPNERR_EXCEPTION,				"DPNERR_EXCEPTION", NULL,
	//0x80158210
	DPNERR_GROUPNOTEMPTY,			"DPNERR_GROUPNOTEMPTY", NULL,
	//0x80158220
	DPNERR_HOSTREJECTEDCONNECTION,	"DPNERR_HOSTREJECTEDCONNECTION", NULL,
	//0x80158230
	DPNERR_INCOMPLETEADDRESS,		"DPNERR_INCOMPLETEADDRESS", NULL,
	//0x80158240
	DPNERR_INVALIDADDRESSFORMAT,	"DPNERR_INVALIDADDRESSFORMAT", NULL,
	//0x80158250
	DPNERR_INVALIDAPPLICATION,		"DPNERR_INVALIDAPPLICATION", NULL,
	//0x80158260
	DPNERR_INVALIDCOMMAND,			"DPNERR_INVALIDCOMMAND", NULL,
	//0x80158270
	DPNERR_INVALIDENDPOINT,			"DPNERR_INVALIDENDPOINT", NULL,
	//0x80158280
	DPNERR_INVALIDFLAGS,			"DPNERR_INVALIDFLAGS", NULL,
	//0x80158290
	DPNERR_INVALIDGROUP,			"DPNERR_INVALIDGROUP", NULL,
	//0x80158300
	DPNERR_INVALIDHANDLE,			"DPNERR_INVALIDHANDLE", NULL,
	//0x80158310
	DPNERR_INVALIDINSTANCE,			"DPNERR_INVALIDINSTANCE", NULL,
	//0x80158320
	DPNERR_INVALIDINTERFACE,		"DPNERR_INVALIDINTERFACE", NULL,
#ifndef _XBOX
	//0x80158330
	DPNERR_INVALIDLOCALADDRESS,		"DPNERR_INVALIDLOCALADDRESS", NULL,
#endif
	//0x80158340
	DPNERR_INVALIDOBJECT,			"DPNERR_INVALIDOBJECT", NULL,
	//0x80158350
	DPNERR_INVALIDPASSWORD,			"DPNERR_INVALIDPASSWORD", NULL,
	//0x80158360
	DPNERR_INVALIDPLAYER,			"DPNERR_INVALIDPLAYER", NULL,
	//0x80158370
	DPNERR_INVALIDPRIORITY,			"DPNERR_INVALIDPRIORITY", NULL,
#ifndef _XBOX
	//0x80158380
	DPNERR_INVALIDREMOTEADDRESS,	"DPNERR_INVALIDREMOTEADDRESS", NULL,
#endif
	//0x80158390
	DPNERR_INVALIDSTRING,			"DPNERR_INVALIDSTRING", NULL,
	//0x80158400
	DPNERR_INVALIDURL,				"DPNERR_INVALIDURL", NULL,
	//0x80158410
	DPNERR_INVALIDVERSION,			"DPNERR_INVALIDVERSION", NULL,
	//0x80158420
	DPNERR_NOCAPS,					"DPNERR_NOCAPS", NULL,
	//0x80158430
	DPNERR_NOCONNECTION,			"DPNERR_NOCONNECTION", NULL,
	//0x80158440
	DPNERR_NOHOSTPLAYER,			"DPNERR_NOHOSTPLAYER", NULL,
	//0x80158450
	DPNERR_NOMOREADDRESSCOMPONENTS,	"DPNERR_NOMOREADDRESSCOMPONENTS", NULL,
	//0x80158460
	DPNERR_NORESPONSE,				"DPNERR_NORESPONSE", NULL,
	//0x80158470
	DPNERR_NOTALLOWED,				"DPNERR_NOTALLOWED", NULL,
	//0x80158480
	DPNERR_NOTHOST,					"DPNERR_NOTHOST", NULL,
	//0x80158490
	DPNERR_NOTREADY,				"DPNERR_NOTREADY", NULL,
	//0x80158500
	DPNERR_PLAYERLOST,				"DPNERR_PLAYERLOST", NULL,
	//0x80158510
	DPNERR_SENDTOOLARGE,			"DPNERR_SENDTOOLARGE", NULL,
	//0x80158520
	DPNERR_SESSIONFULL,				"DPNERR_SESSIONFULL", NULL,
	//0x80158530
	DPNERR_TABLEFULL,				"DPNERR_TABLEFULL", NULL,
	//0x80158540
	DPNERR_TIMEDOUT,				"DPNERR_TIMEDOUT", NULL,
	//0x80158550
	DPNERR_UNINITIALIZED,			"DPNERR_UNINITIALIZED", NULL,
	//0x80158560
	DPNERR_USERCANCEL,				"DPNERR_USERCANCEL", NULL,
	// End DNet errors
#endif // NO_ERRORS_DPLAY8

#ifndef NO_ERRORS_DVOICE
	// Begin DPlayVoice errors
	//0x00150005
	DV_FULLDUPLEX,					"DV_FULLDUPLEX", "Your soundcard is capable of full duplex operation.",
	//0x0015000A
	DV_HALFDUPLEX,					"DV_HALFDUPLEX", "Your soundcard can only run in half duplex mode.",
	//0x0015000F
	DV_EXIT,						"DV_EXIT", NULL,
	//0x8015001E
	DVERR_BUFFERTOOSMALL,			"DVERR_BUFFERTOOSMALL", "The supplied buffer is not large enough to contain the requested data.",
	//0x8015005A
	DVERR_EXCEPTION,				"DVERR_EXCEPTION", "An exception occurred when processing the request.",
	//0x80150078
	DVERR_INVALIDFLAGS,				"DVERR_INVALIDFLAGS", "The flags passed to this method are invalid.",
	//0x80150082
	DVERR_INVALIDOBJECT,			"DVERR_INVALIDOBJECT", "The DirectPlayVoice pointer is invalid.",
	//0x80150087
	DVERR_INVALIDPLAYER,			"DVERR_INVALIDPLAYER", "The player ID is not recognized as a valid ID for this voice session.",
	//0x80150091
	DVERR_INVALIDGROUP,				"DVERR_INVALIDGROUP", "The group ID is not recognized as a valid group ID for the transport session.",
	//0x80150096
	DVERR_INVALIDHANDLE,			"DVERR_INVALIDHANDLE", "The specified handle is not valid.",
	//0x8015012C
	DVERR_SESSIONLOST,				"DVERR_SESSIONLOST", "The transport has lost the connection to the session.",
	//0x8015012E
	DVERR_NOVOICESESSION,			"DVERR_NOVOICESESSION", NULL,
	//0x80150168
	DVERR_CONNECTIONLOST,			"DVERR_CONNECTIONLOST", NULL,
	//0x80150169
	DVERR_NOTINITIALIZED,			"DVERR_NOTINITIALIZED", "Initialize() must be called before using this method.",
	//0x8015016A
	DVERR_CONNECTED,				"DVERR_CONNECTED", "The DirectPlayVoice object is connected.",
	//0x8015016B
	DVERR_NOTCONNECTED,				"DVERR_NOTCONNECTED", "The DirectPlayVoice object is not connected.",
	//0x8015016E
	DVERR_CONNECTABORTING,			"DVERR_CONNECTABORTING", "The connection is being disconnected.",
	//0x8015016F
	DVERR_NOTALLOWED,				"DVERR_NOTALLOWED", "The object does not have the permission to perform this operation.",
	//0x80150170
	DVERR_INVALIDTARGET,			"DVERR_INVALIDTARGET", "The specified target is not a valid player ID or group ID for this voice session.",
	//0x80150171
	DVERR_TRANSPORTNOTHOST,			"DVERR_TRANSPORTNOTHOST", "You're trying to host a voice session on a player which is not a host, but the transport is valid, initialized, connected and a local player is present.",
	//0x80150172
	DVERR_COMPRESSIONNOTSUPPORTED,	"DVERR_COMPRESSIONNOTSUPPORTED", "The specified compression type is not supported on the local machine.",
	//0x80150173
	DVERR_ALREADYPENDING,			"DVERR_ALREADYPENDING", "An ASYNC call of this type is already pending.",
	//0x80150174
	DVERR_SOUNDINITFAILURE,			"DVERR_SOUNDINITFAILURE", "A failure was encountered initializing your soundcard.",
	//0x80150175
	DVERR_TIMEOUT,					"DVERR_TIMEOUT", "The operation could not be performed in the specified time.",
	//0x80150176
	DVERR_CONNECTABORTED,			"DVERR_CONNECTABORTED", "The connection was aborted.",
	//0x80150177
	DVERR_NO3DSOUND,				"DVERR_NO3DSOUND", "The local machine does not support 3D sound.",
	//0x80150178
	DVERR_ALREADYBUFFERED,			"DVERR_ALREADYBUFFERED", "There is already a UserBuffer for the specified ID.",
	//0x80150179
	DVERR_NOTBUFFERED,				"DVERR_NOTBUFFERED", "There is no UserBuffer for the specified ID.",
	//0x8015017A
	DVERR_HOSTING,					"DVERR_HOSTING", "The object is the host of the session.",
	//0x8015017B
	DVERR_NOTHOSTING,				"DVERR_NOTHOSTING", "The object is not the host of the session.",
	//0x8015017C
	DVERR_INVALIDDEVICE,			"DVERR_INVALIDDEVICE", "The specified device is not valid.",
	//0x8015017D
	DVERR_RECORDSYSTEMERROR,		"DVERR_RECORDSYSTEMERROR", "An error in the recording system has occurred.",
	//0x8015017E
	DVERR_PLAYBACKSYSTEMERROR,		"DVERR_PLAYBACKSYSTEMERROR", "An error in the playback system has occurred.",
	//0x8015017F
	DVERR_SENDERROR,				"DVERR_SENDERROR", "An error occurred while sending data.",
	//0x80150180
	DVERR_USERCANCEL,				"DVERR_USERCANCEL", NULL,
	//0x80150183
	DVERR_RUNSETUP,					"DVERR_RUNSETUP", NULL,
	//0x80150184
	DVERR_INCOMPATIBLEVERSION,		"DVERR_INCOMPATIBLEVERSION", NULL,
	//0x80150185
	DVERR_PREVIOUSCRASH,			"DVERR_PREVIOUSCRASH", NULL,
	//0x80150187
	DVERR_INITIALIZED,				"DVERR_INITIALIZED", NULL,
	//0x80150188
	DVERR_NOTRANSPORT,				"DVERR_NOTRANSPORT", "Invalid pointer passed to Initialize, not a valid transport, doesn't support transport interface (bad dplay version).",
	//0x80150189
	DVERR_NOCALLBACK,				"DVERR_NOCALLBACK", NULL,
	//0x8015019A
	DVERR_TRANSPORTNOTINIT,			"DVERR_TRANSPORTNOTINIT", "Initialize() hasn't been called on your transport object (but it is a valid interface).",
	//0x8015019B
	DVERR_TRANSPORTNOSESSION,		"DVERR_TRANSPORTNOSESSION", "Transport object has been initialized but no session is running on it.",
	//0x8015019C
	DVERR_TRANSPORTNOPLAYER,		"DVERR_TRANSPORTNOPLAYER", "Transport object is initialized, connected / hosting a session, but no local player has been created.",
	//0x8015019D
	DVERR_USERBACK,					"DVERR_USERBACK", NULL,
	//0x8015019E
	DVERR_NORECVOLAVAILABLE,		"DVERR_NORECVOLAVAILABLE", NULL,
	//0x8015019F
	DVERR_INVALIDBUFFER,			"DVERR_INVALIDBUFFER", NULL,
	// End DPlayVoice errors
#endif // NO_ERRORS_DVOICE


#ifndef NO_ERRORS_DSOUND
	// Begin DSound errors
#ifndef _XBOX // DSERR_ALLOCATED not supported
	DSERR_ALLOCATED,				"DSERR_ALLOCATED", "The call failed because resources (such as a priority level) were already being used by another caller.",
#endif // ! XBOX
	DSERR_CONTROLUNAVAIL,			"DSERR_CONTROLUNAVAIL", "The control (vol, pan, etc.) requested by the caller is not available.",
	DSERR_INVALIDPARAM,				"DSERR_INVALIDPARAM", "An invalid parameter was passed to the returning function.",
	DSERR_INVALIDCALL,				"DSERR_INVALIDCALL", "This call is not valid for the current state of this object.",

	DSERR_NOAGGREGATION,			"DSERR_NOAGGREGATION", NULL,
	DSERR_NODRIVER,					"DSERR_NODRIVER", NULL,
	DSERR_OUTOFMEMORY,				"DSERR_OUTOFMEMORY", NULL,
#endif // NO_ERRORS_DSOUND
	// End DSound errors

#ifndef NO_ERRORS_DDRAW
	// Begin DDraw errors
	DDERR_ALREADYINITIALIZED,		"DDERR_ALREADYINITIALIZED", "This object is already initialized.",
	DDERR_CANNOTATTACHSURFACE,		"DDERR_CANNOTATTACHSURFACE", "This surface can not be attached to the requested surface.",
	DDERR_CANNOTDETACHSURFACE,		"DDERR_CANNOTDETACHSURFACE", "This surface can not be detached from the requested surface.",
	DDERR_CURRENTLYNOTAVAIL,		"DDERR_CURRENTLYNOTAVAIL", "Support is currently not available.",
	DDERR_EXCEPTION,				"DDERR_EXCEPTION", "An exception was encountered while performing the requested operation.",
	DDERR_HEIGHTALIGN,				"DDERR_HEIGHTALIGN", "Height of rectangle provided is not a multiple of reqd alignment.",
	DDERR_INCOMPATIBLEPRIMARY,		"DDERR_INCOMPATIBLEPRIMARY", "Unable to match primary surface creation request with existing primary surface.",
	DDERR_INVALIDCAPS,				"DDERR_INVALIDCAPS", "One or more of the caps bits passed to the callback are incorrect.",
	DDERR_INVALIDCLIPLIST,			"DDERR_INVALIDCLIPLIST", "DirectDraw does not support provided Cliplist.",
	DDERR_INVALIDMODE,				"DDERR_INVALIDMODE", "DirectDraw does not support the requested mode.",
	DDERR_INVALIDOBJECT,			"DDERR_INVALIDOBJECT", "DirectDraw received a pointer that was an invalid DIRECTDRAW object.",
	DDERR_INVALIDPIXELFORMAT,		"DDERR_INVALIDPIXELFORMAT", "One or more of the parameters passed to the callback function are incorrect.",
	DDERR_INVALIDRECT,				"DDERR_INVALIDRECT", "Rectangle provided was invalid.",
	DDERR_LOCKEDSURFACES,			"DDERR_LOCKEDSURFACES", "Operation could not be carried out because one or more surfaces are locked.",
	DDERR_NO3D,						"DDERR_NO3D", "There is no 3D present.",
	DDERR_NOALPHAHW,				"DDERR_NOALPHAHW", "Operation could not be carried out because there is no alpha accleration hardware present or available.",
	DDERR_NOSTEREOHARDWARE,			"DDERR_NOSTEREOHARDWARE", "Operation could not be carried out because there is no stereo hardware present or available.",
	DDERR_NOSURFACELEFT,			"DDERR_NOSURFACELEFT", "Operation could not be carried out because there is no hardware present which supports stereo surfaces.",
	DDERR_NOCLIPLIST,				"DDERR_NOCLIPLIST", "No clip list available.",
	DDERR_NOCOLORCONVHW,			"DDERR_NOCOLORCONVHW", "Operation could not be carried out because there is no color conversion hardware present or available.",
	DDERR_NOCOOPERATIVELEVELSET,	"DDERR_NOCOOPERATIVELEVELSET", "Create function called without DirectDraw object method SetCooperativeLevel being called.",
	DDERR_NOCOLORKEY,				"DDERR_NOCOLORKEY", "Surface doesn't currently have a color key.",
	DDERR_NOCOLORKEYHW,				"DDERR_NOCOLORKEYHW", "Operation could not be carried out because there is no hardware support of the dest color key.",
	DDERR_NODIRECTDRAWSUPPORT,		"DDERR_NODIRECTDRAWSUPPORT", "No DirectDraw support possible with current display driver.",
	DDERR_NOEXCLUSIVEMODE,			"DDERR_NOEXCLUSIVEMODE", "Operation requires the application to have exclusive mode but the application does not have exclusive mode.",
	DDERR_NOFLIPHW,					"DDERR_NOFLIPHW", "Flipping visible surfaces is not supported.",
	DDERR_NOGDI,					"DDERR_NOGDI", "There is no GDI present.",
	DDERR_NOMIRRORHW,				"DDERR_NOMIRRORHW", "Operation could not be carried out because there is no hardware present or available.",
	DDERR_NOTFOUND,					"DDERR_NOTFOUND", "Requested item was not found.",
	DDERR_NOOVERLAYHW,				"DDERR_NOOVERLAYHW", "Operation could not be carried out because there is no overlay hardware present or available.",
	DDERR_OVERLAPPINGRECTS,			"DDERR_OVERLAPPINGRECTS", "Operation could not be carried out because the source and destination rectangles are on the same surface and overlap each other.",
	DDERR_NORASTEROPHW,				"DDERR_NORASTEROPHW", "Operation could not be carried out because there is no appropriate raster op hardware present or available.",
	DDERR_NOROTATIONHW,				"DDERR_NOROTATIONHW", "Operation could not be carried out because there is no rotation hardware present or available.",
	DDERR_NOSTRETCHHW,				"DDERR_NOSTRETCHHW", "Operation could not be carried out because there is no hardware support for stretching.",
	DDERR_NOT4BITCOLOR,				"DDERR_NOT4BITCOLOR", "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.",
	DDERR_NOT4BITCOLORINDEX,		"DDERR_NOT4BITCOLORINDEX", "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.",
	DDERR_NOT8BITCOLOR,				"DDERR_NOT8BITCOLOR", "DirectDraw Surface is not in 8 bit color mode and the requested operation requires 8 bit color.",
	DDERR_NOTEXTUREHW,				"DDERR_NOTEXTUREHW", "Operation could not be carried out because there is no texture mapping hardware present or available.",
	DDERR_NOVSYNCHW,				"DDERR_NOVSYNCHW", "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.",
	DDERR_NOZBUFFERHW,				"DDERR_NOZBUFFERHW", "Operation could not be carried out because there is no hardware support for zbuffer blting.",
	DDERR_NOZOVERLAYHW,				"DDERR_NOZOVERLAYHW", "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.",
	DDERR_OUTOFCAPS,				"DDERR_OUTOFCAPS", "The hardware needed for the requested operation has already been allocated.",
	DDERR_OUTOFVIDEOMEMORY,			"DDERR_OUTOFVIDEOMEMORY", "DirectDraw does not have enough memory to perform the operation.",
	DDERR_OVERLAYCANTCLIP,			"DDERR_OVERLAYCANTCLIP", "Hardware does not support clipped overlays.",
	DDERR_OVERLAYCOLORKEYONLYONEACTIVE, "DDERR_OVERLAYCOLORKEYONLYONEACTIVE", "Can only have ony color key active at one time for overlays.",
	DDERR_PALETTEBUSY,				"DDERR_PALETTEBUSY", "Access to this palette is being refused because the palette is already locked by another thread.",
	DDERR_COLORKEYNOTSET,			"DDERR_COLORKEYNOTSET", "No src color key specified for this operation.",
	DDERR_SURFACEALREADYATTACHED,	"DDERR_SURFACEALREADYATTACHED", "This surface is already attached to the surface it is being attached to.",
	DDERR_SURFACEALREADYDEPENDENT,	"DDERR_SURFACEALREADYDEPENDENT", "This surface is already a dependency of the surface it is being made a dependency of.",
	DDERR_SURFACEBUSY,				"DDERR_SURFACEBUSY", "Access to this surface is being refused because the surface is already locked by another thread.",
	DDERR_CANTLOCKSURFACE,			"DDERR_CANTLOCKSURFACE", "Access to this surface is being refused because no driver exists which can supply a pointer to the surface.",
	DDERR_SURFACEISOBSCURED,		"DDERR_SURFACEISOBSCURED", "Access to Surface refused because Surface is obscured.",
	DDERR_SURFACELOST,				"DDERR_SURFACELOST", "Access to this surface is being refused because the surface is gone.",
	DDERR_SURFACENOTATTACHED,		"DDERR_SURFACENOTATTACHED", "The requested surface is not attached.",
	DDERR_TOOBIGHEIGHT,				"DDERR_TOOBIGHEIGHT", "Height requested by DirectDraw is too large.",
	DDERR_TOOBIGSIZE,				"DDERR_TOOBIGSIZE", "Size requested by DirectDraw is too large --  The individual height and width are OK.",
	DDERR_TOOBIGWIDTH,				"DDERR_TOOBIGWIDTH", "Width requested by DirectDraw is too large.",
	DDERR_UNSUPPORTEDFORMAT,		"DDERR_UNSUPPORTEDFORMAT", "Pixel format requested is unsupported by DirectDraw.",
	DDERR_UNSUPPORTEDMASK,			"DDERR_UNSUPPORTEDMASK", "Bitmask in the pixel format requested is unsupported by DirectDraw.",
	DDERR_INVALIDSTREAM,			"DDERR_INVALIDSTREAM", "The specified stream contains invalid data.",
	DDERR_VERTICALBLANKINPROGRESS,	"DDERR_VERTICALBLANKINPROGRESS", "Vertical blank is in progress.",
	DDERR_WASSTILLDRAWING,			"DDERR_WASSTILLDRAWING", "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.",
	DDERR_DDSCAPSCOMPLEXREQUIRED,	"DDERR_DDSCAPSCOMPLEXREQUIRED", "The specified surface type requires specification of the COMPLEX flag.",
	DDERR_XALIGN,					"DDERR_XALIGN", "Rectangle provided was not horizontally aligned on reqd. boundary.",
	DDERR_INVALIDDIRECTDRAWGUID,	"DDERR_INVALIDDIRECTDRAWGUID", "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.",
	DDERR_DIRECTDRAWALREADYCREATED,	"DDERR_DIRECTDRAWALREADYCREATED", "A DirectDraw object representing this driver has already been created for this process.",
	DDERR_NODIRECTDRAWHW,			"DDERR_NODIRECTDRAWHW", "A hardware only DirectDraw object creation was attempted but the driver did not support any hardware.",
	DDERR_PRIMARYSURFACEALREADYEXISTS, "DDERR_PRIMARYSURFACEALREADYEXISTS", "This process already has created a primary surface.",
	DDERR_NOEMULATION,				"DDERR_NOEMULATION", "Software emulation not available.",
	DDERR_REGIONTOOSMALL,			"DDERR_REGIONTOOSMALL", "Region passed to Clipper::GetClipList is too small.",
	DDERR_CLIPPERISUSINGHWND,		"DDERR_CLIPPERISUSINGHWND", "An attempt was made to set a clip list for a clipper objec that is already monitoring an hwnd.",
	DDERR_NOCLIPPERATTACHED,		"DDERR_NOCLIPPERATTACHED", "No clipper object attached to surface object.",
	DDERR_NOHWND,					"DDERR_NOHWND", "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.",
	DDERR_HWNDSUBCLASSED,			"DDERR_HWNDSUBCLASSED", "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.",
	DDERR_HWNDALREADYSET,			"DDERR_HWNDALREADYSET", "The CooperativeLevel HWND has already been set.  It can not be reset while the process has surfaces or palettes created.",
	DDERR_NOPALETTEATTACHED,		"DDERR_NOPALETTEATTACHED", "No palette object attached to this surface.",
	DDERR_NOPALETTEHW,				"DDERR_NOPALETTEHW", "No hardware support for 16 or 256 color palettes.",
	DDERR_BLTFASTCANTCLIP,			"DDERR_BLTFASTCANTCLIP", "If a clipper object is attached to the source surface passed into a BltFast call.",
	DDERR_NOBLTHW,					"DDERR_NOBLTHW", "No blter.",

	// More...

#endif // NO_ERRORS_DDRAW
	// End DDraw errors

#ifndef NO_ERRORS_TNCONTRL
	// Begin TNCONTRL errors
	//0x86661001
	TNERR_CONNECTIONDROPPED,		"TNERR_CONNECTIONDROPPED", "The machine you're trying to send to disconnected.",
	//0x86661002
	TNERR_LOSTTESTER,				"TNERR_LOSTTESTER", "A tester completed the test or crashed.",

	//0x86661101
	TNSR_USERCANCEL,				"TNSR_USERCANCEL", "User cancelled a sync operation.",
	//0x86661103
	TNSR_LOSTTESTER,				"TNSR_LOSTTESTER", "A tester was lost during the sync operation.",

	//0x86661111
	TNWR_USERCANCEL,				"TNWR_USERCANCEL", "User cancelled a WaitForEventOrCancel operation.",
	//0x86661112
	TNWR_TIMEOUT,					"TNWR_TIMEOUT", "A WaitForEventOrCancel operation timed out.",
	//0x86661113
	TNWR_LOSTTESTER,				"TNWR_LOSTTESTER", "A tester was lost during the WaitForEventOrCancel operation.",

	//0x86661121
	TNCWR_USERCANCEL,				"TNCWR_USERCANCEL", "User cancelled a WaitForLeechConnection operation.",
	//0x86661122
	TNCWR_TIMEOUT,					"TNCWR_TIMEOUT", "A WaitForLeechConnection operation timed out.",
	//0x86661123
	TNCWR_LOSTTESTER,				"TNCWR_LOSTTESTER", "A tester was lost during the WaitForLeechConnection operation.",
	// End TNCONTRL errors
#endif // NO_ERRORS_TNCONTRL


	// Begin exceptions
	EXCEPTION_ACCESS_VIOLATION,		"EXCEPTION_ACCESS_VIOLATION", NULL,
	EXCEPTION_DATATYPE_MISALIGNMENT, "EXCEPTION_DATATYPE_MISALIGNMENT", NULL,
	EXCEPTION_BREAKPOINT,			"EXCEPTION_BREAKPOINT", NULL,
	EXCEPTION_SINGLE_STEP,			"EXCEPTION_SINGLE_STEP", NULL,
	EXCEPTION_ARRAY_BOUNDS_EXCEEDED, "EXCEPTION_ARRAY_BOUNDS_EXCEEDED", NULL,
	EXCEPTION_FLT_DENORMAL_OPERAND,	"EXCEPTION_FLT_DENORMAL_OPERAND", NULL,
	EXCEPTION_FLT_DIVIDE_BY_ZERO,	"EXCEPTION_FLT_DIVIDE_BY_ZERO", NULL,
	EXCEPTION_FLT_INEXACT_RESULT,	"EXCEPTION_FLT_INEXACT_RESULT", NULL,
	EXCEPTION_FLT_INVALID_OPERATION, "EXCEPTION_FLT_INVALID_OPERATION", NULL,
	EXCEPTION_FLT_OVERFLOW,			"EXCEPTION_FLT_OVERFLOW", NULL,
	EXCEPTION_FLT_STACK_CHECK,		"EXCEPTION_FLT_STACK_CHECK", NULL,
	EXCEPTION_FLT_UNDERFLOW,		"EXCEPTION_FLT_UNDERFLOW", NULL,
	EXCEPTION_INT_DIVIDE_BY_ZERO,	"EXCEPTION_INT_DIVIDE_BY_ZERO", NULL,
	EXCEPTION_INT_OVERFLOW,			"EXCEPTION_INT_OVERFLOW", NULL,
	EXCEPTION_PRIV_INSTRUCTION,		"EXCEPTION_PRIV_INSTRUCTION", NULL,
	EXCEPTION_IN_PAGE_ERROR,		"EXCEPTION_IN_PAGE_ERROR", NULL,
	EXCEPTION_ILLEGAL_INSTRUCTION,	"EXCEPTION_ILLEGAL_INSTRUCTION", NULL,
	EXCEPTION_NONCONTINUABLE_EXCEPTION, "EXCEPTION_NONCONTINUABLE_EXCEPTION", NULL,
	EXCEPTION_STACK_OVERFLOW,		"EXCEPTION_STACK_OVERFLOW", NULL,
	EXCEPTION_INVALID_DISPOSITION,	"EXCEPTION_INVALID_DISPOSITION", NULL,
	EXCEPTION_GUARD_PAGE,			"EXCEPTION_GUARD_PAGE", NULL,
	EXCEPTION_INVALID_HANDLE,		"EXCEPTION_INVALID_HANDLE", NULL,
	// End exceptions

	WAIT_IO_COMPLETION,				"WAIT_IO_COMPLETION, STATUS_USER_APC", NULL,
	WAIT_ABANDONED_0,				"WAIT_ABANDONED_0", NULL,
	WAIT_FAILED,					"WAIT_FAILED", NULL
};





//==================================================================================
// GetErrorDescription
//----------------------------------------------------------------------------------
//
// Description: Stores a text representation of the error code into the given
//				buffer.  If the pointer to that is NULL, the size is stored in the
//				given DWORD pointer and ERROR_BUFFER_TOO_SMALL is returned.
//				If pdwShortcut is not NULL, the DWORD it points to should be set to
//				ERRORSSHORTCUT_NOTSEARCHED the first time it is called.  It will
//				then be updated so that further calls to this function can skip the
//				lookup step.
//
// Arguments:
//	HRESULT hresult			Result code to print.
//	DWORD_PTR dwFlags		How to print the item.
//	char* pszBuffer			Pointer to buffer, or NULL to retrieve size.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to store size
//							required.
//	DWORD* pdwShortcut		Pointer to known index of error code, if any.  
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT GetErrorDescription(LONG_PTR hresult, DWORD_PTR dwFlags, char* pszBuffer,
							DWORD* pdwBufferSize, DWORD* pdwShortcut)
{
	char		szNumber[32];
	BOOL		fFound = FALSE;
	DWORD		dwTemp;


	if (pszBuffer == NULL)
		(*pdwBufferSize) = 1; // NULL termination
	else
		strcpy(pszBuffer, ""); // start with an empty string

	if (dwFlags & ERRORSFLAG_PRINTHEXVALUE)
	{
		wsprintf(szNumber, "0x%08x, ", hresult);
		if (pszBuffer == NULL)
		{
			(*pdwBufferSize) += strlen(szNumber);
		} // end if (there's no buffer)
		else
		{
			strcat(pszBuffer, szNumber);
		} // end else (there is a buffer)
	} // end if (should print hex value)

	if (dwFlags & ERRORSFLAG_PRINTDECIMALVALUE)
	{
		wsprintf(szNumber, "%i, ", hresult);
		if (pszBuffer == NULL)
		{
			(*pdwBufferSize) += strlen(szNumber);
		} // end if (there's no buffer)
		else
		{
			strcat(pszBuffer, szNumber);
		} // end else (there is a buffer)
	} // end if (should print hex value)

	// If there's no shortcut pointer, or it's ERRORSSHORTCUT_NOTSEARCHED,
	// start searching.
	if ((pdwShortcut == NULL) || ((*pdwShortcut) == ERRORSSHORTCUT_NOTSEARCHED))
	{
		for(dwTemp = 0; dwTemp < (sizeof (g_TNErrorTable) / sizeof (TNERRORITEM)); dwTemp++)
		{
			if (g_TNErrorTable[dwTemp].hresult == hresult)
			{
				fFound = TRUE;

				// If the caller was nice enough to let us have a place to store
				// a shortcut, do so.
				if (pdwShortcut != NULL)
					(*pdwShortcut) = dwTemp;

				if (pszBuffer == NULL)
				{
					(*pdwBufferSize) += strlen(g_TNErrorTable[dwTemp].pszName);

					if ((dwFlags & ERRORSFLAG_PRINTDESCRIPTION) && 
						(g_TNErrorTable[dwTemp].pszDescription != NULL))
					{
						(*pdwBufferSize) += 2 + strlen(g_TNErrorTable[dwTemp].pszDescription) + 1;
					} // end if (should print and there is a description)
				} // end if (there's no buffer)
				else
				{
					strcat(pszBuffer, g_TNErrorTable[dwTemp].pszName);

					if ((dwFlags & ERRORSFLAG_PRINTDESCRIPTION) && 
						(g_TNErrorTable[dwTemp].pszDescription != NULL))
					{
						strcat(pszBuffer, " '");
						strcat(pszBuffer, g_TNErrorTable[dwTemp].pszDescription);
						strcat(pszBuffer, "'");
					} // end if (should print and there is a description)
				} // end else (there is a buffer)

				// Get out of the for loop
				break;
			} // end if (we found the entry)
		} // end for (each error entry)
	} // end if (no shortcut pointer or it's NOTSEARCHED)
	else if ((pdwShortcut != NULL) && ((*pdwShortcut) != ERRORSSHORTCUT_NOTFOUND))
	{
		fFound = TRUE;

		if (pszBuffer == NULL)
		{
			(*pdwBufferSize) += strlen(g_TNErrorTable[(*pdwShortcut)].pszName);

			if ((dwFlags & ERRORSFLAG_PRINTDESCRIPTION) && 
				(g_TNErrorTable[(*pdwShortcut)].pszDescription != NULL))
			{
				(*pdwBufferSize) += 2 + strlen(g_TNErrorTable[(*pdwShortcut)].pszDescription) + 1;
			} // end if (should print and there is a description)
		} // end if (there's no buffer)
		else
		{
			strcat(pszBuffer, g_TNErrorTable[(*pdwShortcut)].pszName);

			if ((dwFlags & ERRORSFLAG_PRINTDESCRIPTION) && 
				(g_TNErrorTable[(*pdwShortcut)].pszDescription != NULL))
			{
				strcat(pszBuffer, " '");
				strcat(pszBuffer, g_TNErrorTable[(*pdwShortcut)].pszDescription);
				strcat(pszBuffer, "'");
			} // end if (should print and there is a description)
		} // end else (there is a buffer)
	} // end else if (there was a shortcut pointer and it's not NOTFOUND)

	if (! fFound)
	{
		// If the caller was nice enough to let us have a place to store
		// a shortcut, do so.
		if (pdwShortcut != NULL)
			(*pdwShortcut) = ERRORSSHORTCUT_NOTFOUND; // special value

		/*
		// FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
		// 				NULL,
		// 				hresult,
		// 				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		// 				pszBuffer,
		//				0,
		//				NULL);
		
		// Process any inserts in lpMsgBuf ?
		*/

		if (pszBuffer == NULL)
		{
			(*pdwBufferSize) += 13;
		} // end if (there's no buffer)
		else
		{
			strcat(pszBuffer, "Unknown_Error");
		} // end else (there is a buffer)
	} // end if (we didn't find the error)

	if (pszBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // GetErrorDescription




#undef DEBUG_SECTION
#define DEBUG_SECTION	"DoSprintfErrorBox()"
//==================================================================================
// DoSprintfErrorBox
//----------------------------------------------------------------------------------
//
// Description: Displays an error message box with the given title and text.  The
//				standard sprintf tokens can be specified, see
//				sprintf.h for details.
//
// Arguments:
//	HWND hWndParent				Parent window, or NULL for none.
//	LPTSTR lptszTitle			Title for message box
//	LPTSTR lptszFormatString	String (with optional tokens) to print.
//	DWORD dwNumParms			How many parameters are in the following variable
//								parameter list.
//	...							Variable list of parameters to parse.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
void DoSprintfErrorBox(HWND hWndParent, LPTSTR lptszTitle, LPTSTR lptszFormatString,
					DWORD dwNumParms, ...)
{
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		dwTemp = 0;
	TCHAR*		lptszBuffer = NULL;


	if (dwNumParms > 0)
	{
		papvParms = (PVOID*) LocalAlloc(LPTR, (dwNumParms * sizeof (PVOID)));
		if (papvParms == NULL)
			return;

		va_start(currentparam, dwNumParms);

		for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
		{
			papvParms[dwTemp] = va_arg(currentparam, PVOID);
		} // end for (each parameter)

		va_end(currentparam);
	} // end if (there are parameters to check)


#ifndef _XBOX // no GDI supported
	TNsprintf_array(&lptszBuffer, lptszFormatString, dwNumParms, papvParms);

	MessageBox(hWndParent, lptszBuffer, lptszTitle, MB_OK | MB_ICONEXCLAMATION);

	TNsprintf_free(&lptszBuffer);
#else // ! XBOX
#pragma TODO(tristanj, "Need to come up with an alternative form for MessageBox's on Xbox")
#endif // XBOX


	//if (papvParms != NULL)
	{
		LocalFree(papvParms);
		papvParms = NULL;
	} // end if (allocated array)
} // DoSprintfErrorBox
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"GetTNErrorTable()"
//==================================================================================
// GetTNErrorTable
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the error table and its size.
//
// Arguments:
//	PTNERRORITEM* ppaTNErrorTable	Place to store error table pointer.
//	DWORD* pdwNumEntries			Place to store number of entries in error table.
//
// Returns: None.
//==================================================================================
void GetTNErrorTable(PTNERRORITEM* ppaTNErrorTable, DWORD* pdwNumEntries)
{
	(*ppaTNErrorTable) = g_TNErrorTable;
	(*pdwNumEntries) = sizeof (g_TNErrorTable) / sizeof (TNERRORITEM);
} // GetTNErrorTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tncommon.rc
//

#define WINDOWCLASS_CMDLINE_HELPBOX			"CommandLine Help Box WindowClass"
#define WINDOWCLASS_FILE_COPYTREEPROGRESS	"FileCopyTree Progress Window Class"



#define IDD_HELP			90
#define IDB_NEXT			91
#define IDB_BACKTOFIRST		92
#define IDS_ALL				93
#define IDD_PROGRESS		94
#define IDS_CURRENTSOURCE	95
#define IDT_CURRENTSOURCE	96
#define IDS_CURRENTDEST		97
#define IDT_CURRENTDEST		98
#define IDPB_PROGRESSBAR	99


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\linklist.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>


#include "main.h"
#include "cppobjhelp.h"
#include "linklist.h"
#ifdef DEBUG
#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#include "stack.h"
#endif // ! NO_TNCOMMON_DEBUG_SPEW
#endif // DEBUG





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLITEM::LLITEM()"
//==================================================================================
// LLITEM constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the LLITEM object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
LLITEM::LLITEM(void)
{
/*
#ifdef DEBUG
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	LPVOID	lpvCaller;
	LPVOID	lpvCallersCaller;


	TNStackGetCallersAddress(&lpvCaller, &lpvCallersCaller);

	DPL(9, "this = %x, caller = %X, caller's caller = %X",
		3, this, lpvCaller, lpvCallersCaller);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
#endif // DEBUG
*/

	// We start off with a refcount of 0, but technically it should be 1, because
	// somebody clearly has to be holding on to this new item, as in:
	//		pItem = new (LLITEM);
	// which means someone has a reference to it.  We'll assume that the owner will
	// increment the refcount if he plans to hold on to the object and not put it
	// on a list or anything (which increments the refcount automatically).

	this->m_dwRefCount = 0;
	this->m_pPrev = NULL;
	this->m_pNext = NULL;
	this->m_fAlias = FALSE;
#ifdef DEBUG
	this->m_fDeleted = FALSE;
#endif //DEBUG
} // LLITEM::LLITEM
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLITEM::~LLITEM()"
//==================================================================================
// LLITEM destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the LLITEM object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
LLITEM::~LLITEM(void)
{
#ifdef DEBUG
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	PVOID	pvCaller;
	PVOID	pvCallersCaller;


	TNStackGetCallersAddress(&pvCaller, &pvCallersCaller);

	DPL(9, "Deleting item %x%s  caller = %X, caller's caller = %X",
		4, this,
		(this->fAlias ? " (It's an alias)." : "."),
		pvCaller,
		pvCallersCaller);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	if (this->m_dwRefCount > 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Deleting object %x with m_dwRefCount of %u!", 2, this, this->m_dwRefCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (some list still refers to us)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Object %x already marked as deleted?!", 1, this);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (this item has been deleted before)

	this->m_fDeleted = TRUE;

	this->m_pPrev = NULL;
	this->m_pNext = NULL;
#endif //DEBUG
} // LLITEM::~LLITEM
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLALIAS::LLALIAS()"
//==================================================================================
// LLALIAS constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the LLALIAS object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
LLALIAS::LLALIAS(void)
{
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	this->m_fAlias = TRUE;

	this->m_pTarget = NULL;
} // LLALIAS::LLALIAS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLALIAS::~LLALIAS()"
//==================================================================================
// LLALIAS destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the LLALIAS object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
LLALIAS::~LLALIAS(void)
{
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "this = %x", 1, this);
	DPL(0, "Deleting alias: %x    target: %x", 2, this, this->m_pTarget);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/


	/*
#ifdef DEBUG
	if (this->m_pTarget == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Alias' target is NULL!  How did that happen?", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return;
	} // end if (our count appears to be screwed up)
#endif //DEBUG
	*/


	// We don't want to implement this I don't think.
	/*
	this->m_pTarget->m_dwRefCount--;
	if (this->m_pTarget->m_dwRefCount <= 0)
	{
		/-
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Killing aliases target.  %x", 1, this->m_pTarget);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		-/

		delete (this->m_pTarget);
	} // end if (this is the last item referring to the object)

	this->m_pTarget = NULL;
	*/
} // LLALIAS::~LLALIAS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::LLIST()"
//==================================================================================
// LLIST constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the LLIST object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
LLIST::LLIST(void)
{
	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	InitializeCriticalSection(&(this->m_cs));

	this->m_pFirst = NULL;
	this->m_pLast = NULL;
	this->m_iCount = 0;

#ifdef DEBUG
	this->m_fDeleted = FALSE;
#endif //DEBUG
} // LLIST::LLIST
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::~LLIST()"
//==================================================================================
// LLIST destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the LLIST object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
LLIST::~LLIST(void)
{
	HRESULT		hr;


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(9, "this = %x", 1, this);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/


#ifdef DEBUG
	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Object %x already marked as deleted?!", 1, this);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (this item has been deleted before)
#endif //DEBUG


	hr = this->RemoveAll();
	if (hr != S_OK)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Removing all items failed!  %e", 1, hr);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (removing all items failed)


#ifdef DEBUG
	this->m_fDeleted = TRUE;
#endif //DEBUG

	
	DeleteCriticalSection(&this->m_cs);
} // LLIST::~LLIST
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::EnterCritSection()"
//==================================================================================
// LLIST::EnterCritSection
//----------------------------------------------------------------------------------
//
// Description: Enters this object's critical section.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void LLIST::EnterCritSection(void)
{

#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return;
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return;
	} // end if (using deleted object)
#endif // DEBUG


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "Entering LLIST critical section (%x).", 1, &this->cs);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	EnterCriticalSection(&(this->m_cs));
} // LLIST::EnterCritSection
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::LeaveCritSection()"
//==================================================================================
// LLIST::LeaveCritSection
//----------------------------------------------------------------------------------
//
// Description: Leaves this object's critical section.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void LLIST::LeaveCritSection(void)
{

#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return;
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return;
	} // end if (using deleted object)
#endif // DEBUG


	/*
	#ifndef NO_TNCOMMON_DEBUG_SPEW
	DPL(0, "Leaving LLIST critical section (%x).", 1, &this->cs);
	#endif // ! NO_TNCOMMON_DEBUG_SPEW
	*/

	LeaveCriticalSection(&(this->m_cs));
} // LLIST::LeaveCritSection
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::Add()"
//==================================================================================
// LLIST::Add
//----------------------------------------------------------------------------------
//
// Description: Adds the passed item to the end of the list.  Cannot be NULL.
//
// Arguments:
//	PLLITEM pNewItem	Pointer to object to add.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::Add(PLLITEM pNewItem)
{
	HRESULT		hr = S_OK;
	PLLALIAS	pAlias = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG

	if (pNewItem == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed a NULL pointer!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed a NULL pointer)

#ifdef DEBUG
	if (pNewItem->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "About to add an item (%x) which has already been deleted!  DEBUGBREAK()-ing.",
			1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (we got passed a NULL pointer)

	if (pNewItem->m_fAlias)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an alias object!  How did that happen?", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed an alias)

	if (pNewItem->m_dwRefCount == 0xFFFFFFFF)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "pNewItem (%x) refcount is bad!", 1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	}
#endif //DEBUG

	pNewItem->m_dwRefCount++; // this list will refer to the object

	// If someone else already has a reference to the object, we're going to
	// make an alias to it.
	if (pNewItem->m_dwRefCount > 1)
	{
		pAlias = new (LLALIAS);
		if (pAlias == NULL)
			return (E_OUTOFMEMORY);

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Adding alias %x pointing to %x, refcount is %u.",
			3, pAlias, pNewItem, pNewItem->m_dwRefCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		pAlias->m_pTarget = pNewItem;
		pNewItem->m_dwRefCount++; // this alias now refers to the object
		pNewItem = pAlias;
	} // end if (this object has been referred to by other lists or aliases already)
#ifdef DEBUG
	else
	{
		if ((pNewItem->m_pPrev != NULL) || (pNewItem->m_pNext != NULL))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Item to add (%x) had no references but it had a prev (%x) or next (%x) pointer!?",
				3, pNewItem, pNewItem->m_pPrev, pNewItem->m_pNext);

			DEBUGBREAK();
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			this->LeaveCritSection();
			return (ERROR_BAD_ENVIRONMENT);
		} // end if (new item but has list pointers)

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Adding original item %x.", 1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/
	} // end else (this object is new)
#endif // DEBUG

	this->EnterCritSection();

	if (this->m_iCount > 0)
	{
#ifdef DEBUG
		if ((this->m_pFirst == NULL) || (this->m_pLast == NULL))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "List count (%i) is bad, first = %x, last = %x!  DEBUGBREAK()-ing.",
				3, this->m_iCount, this->m_pFirst, this->m_pLast);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		this->m_pLast->m_pNext = pNewItem;
		pNewItem->m_pPrev = this->m_pLast;
		pNewItem->m_pNext = NULL;
		this->m_pLast = pNewItem;

		this->m_iCount++;
	} // end if (our count says we've added items already)
	else
	{
#ifdef DEBUG
		if ((this->m_pFirst != NULL) || (this->m_pLast != NULL))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "List count of 0 is bad, first = %x, last = %x!  DEBUGBREAK()-ing.",
				2, this->m_pFirst, this->m_pLast);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		this->m_pFirst = pNewItem;
		this->m_pLast = pNewItem;

		this->m_iCount = 1;
	} // end if (our count says we don't have any items)


#ifdef DEBUG
DONE:
#endif //DEBUG

	this->LeaveCritSection();

	return (hr);
} // LLIST::Add
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::AddAfter()"
//==================================================================================
// LLIST::AddAfter
//----------------------------------------------------------------------------------
//
// Description: Adds the object passed in after the item pAfterItem.  If NULL is
//				passed in as the object to AddAfter, the item is placed at the
//				beginning of the list.
//
// Arguments:
//	PLLITEM pNewItem		Pointer to object to add.
//	PLLITEM pAfterItem		Pointer to object to add after, or NULL for beginning.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::AddAfter(PLLITEM pNewItem, PLLITEM pAfterItem)
{
	HRESULT		hr = S_OK;
	PLLALIAS	pAlias = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	if (pNewItem == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed a NULL object to add!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (got passed nothing)


#ifdef DEBUG
	if (pNewItem->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "About to add an item (%x) which has already been deleted!  DEBUGBREAK()-ing.",
			1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (we got passed a NULL pointer)

	if ((pAfterItem != NULL) && (pAfterItem->m_fDeleted))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "About to AddAfter an item (%x) which has already been deleted!  DEBUGBREAK()-ing.",
			1,  pAfterItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (we got passed a NULL pointer)

	if (pNewItem->m_fAlias)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an alias object to add (%x)!  How did that happen?",
			1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed an alias)

	if ((pAfterItem != NULL) && (pAfterItem->m_fAlias))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an alias object to add after (%x)!  How did that happen?",
			1, pAfterItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed an alias)

	if (pNewItem == pAfterItem)
	{
		this->LeaveCritSection();
		return (ERROR_INVALID_PARAMETER);
	} // end if (trying to add item after itself)
#endif // DEBUG


	this->EnterCritSection();

	if (this->m_iCount <= 0) // if there aren't any items
	{
		if (pAfterItem == NULL) // not adding after anything as expected
			hr = this->Add(pNewItem); // let the normal Add's logic handle it
		else // where is the caller getting the item to add after?
			hr = ERROR_INVALID_PARAMETER;

		this->LeaveCritSection();
		return (hr);
	}

	// If we're adding at the end, that's just like calling plain old Add().
	if (pAfterItem == this->m_pLast)
	{
		hr = this->Add(pNewItem); // it's just a normal Add
		this->LeaveCritSection();
		return (hr);
	} // end if (we're adding at the end)


#ifdef DEBUG
	if (pNewItem->m_dwRefCount == 0xFFFFFFFF)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "pNewItem (%x) refcount is bad!", 1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (bogus refcount)
#endif //DEBUG

	pNewItem->m_dwRefCount++; // this list will refer to the object

	if (pNewItem->m_dwRefCount > 1)
	{
		pAlias = new (LLALIAS);
		if (pAlias == NULL)
		{
			this->LeaveCritSection();
			return (E_OUTOFMEMORY);
		} // end if (out of memory)

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Adding alias %x pointing to %x, refcount is %u.",
			3, pAlias, pNewItem, pNewItem->m_dwRefCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		pAlias->m_pTarget = pNewItem;
		pNewItem->m_dwRefCount++; // this alias now refers to the object
		pNewItem = pAlias;
	} // end if (this object has been referred to by other lists or aliases already)
#ifdef DEBUG
	else
	{
		if ((pNewItem->m_pPrev != NULL) || (pNewItem->m_pNext != NULL))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Item to add (%x) had no references but it had a prev (%x) or next (%x) pointer!?",
				3, pNewItem, pNewItem->m_pPrev, pNewItem->m_pNext);

			DEBUGBREAK();
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			this->LeaveCritSection();
			return (ERROR_BAD_ENVIRONMENT);
		} // end if (new item but has list pointers)

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Adding original item %x.", 1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/
	} // end else (this object is new)
#endif // DEBUG


	// If we're not adding after something
	if (pAfterItem == NULL)
	{
#ifdef DEBUG
		if ((this->m_pFirst == NULL) || (this->m_pFirst->m_pPrev != NULL))
		{
			this->LeaveCritSection();
			return (ERROR_BAD_ENVIRONMENT);
		} // end if (something got screwed)
#endif //DEBUG

		pNewItem->m_pNext = this->m_pFirst;
		pNewItem->m_pPrev = NULL;

		this->m_pFirst->m_pPrev = pNewItem;
		this->m_pFirst = pNewItem;

		this->m_iCount++;

		this->LeaveCritSection();
		return (S_OK);
	} // end if (we're not adding after something)

#ifdef DEBUG
	if (pAfterItem->m_pNext == NULL)
	{
		this->LeaveCritSection();
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (something got screwed)
#endif //DEBUG

	pNewItem->m_pNext = pAfterItem->m_pNext;
	pNewItem->m_pPrev = pAfterItem;
	pAfterItem->m_pNext->m_pPrev = pNewItem;
	pAfterItem->m_pNext = pNewItem;
	this->m_iCount++;

	this->LeaveCritSection();
	return (S_OK);
} // LLIST::AddAfter
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::InsertBeforeIndex()"
//==================================================================================
// LLIST::InsertBeforeIndex
//----------------------------------------------------------------------------------
//
// Description: Adds the object passed in before the item at the given index.
//
// Arguments:
//	PLLITEM pNewItem	Pointer to object to add.
//	int iPos			Index to insert object before.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::InsertBeforeIndex(PLLITEM pNewItem, int iPos)
{
	HRESULT		hr;
	PLLALIAS	pAlias = NULL;
	PLLITEM		pBeforeItem = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	// If we're putting the first item into the list
	if ((iPos == 0) && (this->m_iCount == 0))
	{
		// Let Add do the work for us
		hr = this->Add(pNewItem);
		this->LeaveCritSection();
		return (hr);
	} // end if (we're adding the first item)

#ifdef DEBUG
	if ((iPos < 0) || (iPos >= this->m_iCount))
	{
		this->LeaveCritSection();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Index is out of range!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (index is out of range)


	if (pNewItem == NULL)
	{
		this->LeaveCritSection();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed a NULL object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (passed nothing)

	if (pNewItem->m_fAlias)
	{
		this->LeaveCritSection();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an alias object!  How did that happen?", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_INVALID_PARAMETER);
	} // end if (we got passed an alias)

	if (pNewItem->m_dwRefCount == 0xFFFFFFFF)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "pNewItem (%x) refcount is bad!", 1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (ERROR_BAD_ENVIRONMENT);
	}
#endif //DEBUG


	pNewItem->m_dwRefCount++; // this list will refer to the object

	if (pNewItem->m_dwRefCount > 1)
	{
		pAlias = new (LLALIAS);
		if (pAlias == NULL)
		{
			this->LeaveCritSection();
			return (E_OUTOFMEMORY);
		} // end if (out of memory)

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Adding alias: %x   pointing to: %x", 2, pAlias, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		pAlias->m_pTarget = pNewItem;
		pNewItem->m_dwRefCount++; // this alias now refers to the object
		pNewItem = pAlias;
	} // end if (this object has been referred to by other lists or aliases already)
	/*
	else
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Adding original item.  %x", 1, pNewItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end else (this object is new)
	*/


#ifdef DEBUG
	if (this->m_pFirst == NULL)
	{
		this->LeaveCritSection();
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (something got screwed)
#endif //DEBUG

	// Inserting at beginning of list
	if (iPos == 0)
	{
		pNewItem->m_pNext = this->m_pFirst;
		pNewItem->m_pPrev = NULL;
		this->m_pFirst->m_pPrev = pNewItem;
		this->m_pFirst = pNewItem;
		this->m_iCount++;

		this->LeaveCritSection();
		return (S_OK);
	} // end if (inserting at beginning)


	pBeforeItem = this->m_pFirst;
	while (iPos > 0)
	{
#ifdef DEBUG
		if (pBeforeItem->m_pNext == NULL)
		{
			this->LeaveCritSection();
			return (ERROR_BAD_ENVIRONMENT);
		} // end if (something got screwed)
#endif //DEBUG

		pBeforeItem = pBeforeItem->m_pNext;
		iPos--;
	} // end while (we haven't reached the index specified)

	pNewItem->m_pNext = pBeforeItem;
	pNewItem->m_pPrev = pBeforeItem->m_pPrev;
	pNewItem->m_pPrev->m_pNext = pNewItem;
	pBeforeItem->m_pPrev = pNewItem;
	this->m_iCount++;

	this->LeaveCritSection();

	return (S_OK);
} // LLIST::InsertBeforeIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::GetItem()"
//==================================================================================
// LLIST::GetItem
//----------------------------------------------------------------------------------
//
// Description: Returns the pointer to the item specified, NULL if there was a
//				problem.  The index is zero based.
//
// Arguments:
//	int iPos	Position to retrieve item from.
//
// Returns: Pointer to object at index, or NULL if there was a problem.
//==================================================================================
PLLITEM LLIST::GetItem(int iPos)
{
	PLLITEM		pCurrent = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if ((this->m_iCount <= 0) || (iPos < 0) || (iPos >= this->m_iCount))
	{
		this->LeaveCritSection();
		return (NULL);
	} // end if (no items or the number to get is out of range)


#ifdef DEBUG
	if (this->m_pFirst == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "List count of %i is bogus because first pointer is NULL!",
			1, this->m_iCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();

		this->LeaveCritSection();
		return (NULL);
	} // end if (didn't get valid object)
#endif // DEBUG


	pCurrent = this->m_pFirst;
	while (iPos > 0)
	{
#ifdef DEBUG
		if (pCurrent->m_pNext == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Object %x has no next pointer but there should be at least %i more items (%i total in list)!",
				3, pCurrent, iPos, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			this->LeaveCritSection();
			return (NULL);
		} // end if (our count got screwed)
#endif // DEBUG

		pCurrent = pCurrent->m_pNext;
		iPos--;
	} // end while (we've still got more to traverse)


	if (pCurrent->m_fAlias)
	{
#ifdef DEBUG
		if (pCurrent == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Alias points to null object!  How did that happen?  DEBUGBREAK()-ing.", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();
		} // end if (something got screwed)

		if (pCurrent->m_fDeleted)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Using alias (%x) which has already been deleted!  DEBUGBREAK()-ing.",
				1, pCurrent);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();
		} // end if (item is deleted)
#endif //DEBUG

		pCurrent = ((PLLALIAS) pCurrent)->m_pTarget;
	} // end if (it's an alias)


#ifdef DEBUG
	if (pCurrent->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "About to return item (%x) which has already been deleted!  DEBUGBREAK()-ing.",
			1, pCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (item is deleted)
#endif //DEBUG

	this->LeaveCritSection();

	return (pCurrent);
} // LLIST::GetItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::GetFirstIndex()"
//==================================================================================
// LLIST::GetFirstIndex
//----------------------------------------------------------------------------------
//
// Description: Returns the index of the first instance of item in the list, or -1
//				if the item was not in the list.
//
// Arguments:
//	PLLITEM pItem	Item to locate.
//
// Returns: The zero based index of the item in the list, or -1 if not found.
//==================================================================================
int LLIST::GetFirstIndex(PLLITEM pItem)
{
	PLLITEM		pCurrent = NULL;
	int			iPos = 0;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if (this->m_iCount <= 0)
	{
		this->LeaveCritSection();
		return (-1);
	} // end if (no items)

#ifdef DEBUG
	if (pItem->m_fAlias)
	{
		this->LeaveCritSection();

		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Got passed an alias!  How did that happen?", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (-1);
	} // end if (we were given an alias)
#endif //DEBUG


	pCurrent = this->m_pFirst;
	while (pCurrent != NULL)
	{
		if (pCurrent->m_fAlias)
		{
			if (((PLLALIAS) pCurrent)->m_pTarget == pItem)
				break;
		} // end if (we're looking at an alias)
		else
		{
			if (pCurrent == pItem)
				break;
		} // end if (we're not looking at an alias)

		pCurrent = pCurrent->m_pNext;
		iPos++;
	} // end while (we've still got more to traverse)

	this->LeaveCritSection();

	if (pCurrent == NULL)
	{
		return (-1);
	} // end if (we didn't find the object)

	return (iPos);
} // LLIST::GetFirstIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::GetNextItem()"
//==================================================================================
// LLIST::GetNextItem
//----------------------------------------------------------------------------------
//
// Description: Returns the next item in the list after the one specified.  If NULL
//				is passed, then the first item is returned.
//				NOTE: The list lock must be held across calls to this function!
//				NOTE: This list must be composed of entirely original items (no
//					  aliases).
//
// Arguments:
//	PLLITEM pPreviousItem	Item to start from, or NULL to start at beginning.
//
// Returns: The next item in the list, or NULL if none.
//==================================================================================
PLLITEM LLIST::GetNextItem(PLLITEM pPreviousItem)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (using deleted object)

	if ((pPreviousItem != NULL) && (pPreviousItem->m_fAlias))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Using LLIST::GetNextItem requires that this list not contain any aliases!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)
#endif // DEBUG


	if (pPreviousItem == NULL)
		return (this->m_pFirst);

	return (pPreviousItem->m_pNext);
} // LLIST::GetNextItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::GetPrevItem()"
//==================================================================================
// LLIST::GetPrevItem
//----------------------------------------------------------------------------------
//
// Description: Returns the item found in the list immediately preceding the one
//				specified.  If NULL is passed, then the last item is returned.
//				NOTE: The list lock must be held across calls to this function!
//				NOTE: This list must be composed of entirely original items (no
//					  aliases).
//
// Arguments:
//	PLLITEM pNextItem	Item to work back from, or NULL to start at end.
//
// Returns: The previous item in the list, or NULL if none.
//==================================================================================
PLLITEM LLIST::GetPrevItem(PLLITEM pNextItem)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)

	if ((pNextItem != NULL) && (pNextItem->m_fAlias))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Using LLIST::GetPrevItem requires that this list not contain any aliases!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)
#endif // DEBUG


	if (pNextItem == NULL)
		return (this->m_pLast);

	return (pNextItem->m_pPrev);
} // LLIST::GetPrevItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::RemoveFirstReference()"
//==================================================================================
// LLIST::RemoveFirstReference
//----------------------------------------------------------------------------------
//
// Description: Finds the first occurrence of the passed in object and pulls it
//				off the list (without freeing the memory for the object).  Note that
//				the object's refcount will decremented by function exit, and it is
//				up to the caller to delete it or increment the refcount as
//				necessary.
//
// Arguments:
//	PLLITEM pItem	Item to pull from list.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::RemoveFirstReference(PLLITEM pItem)
{
	HRESULT		hr = S_OK;
	PLLITEM		pCurrent = NULL;
	PLLALIAS	pCurrentAsAlias = NULL;
	PLLITEM		pPrev = NULL;
	PLLITEM		pNext = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if (this->m_iCount <= 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: No items in list (count = %i)!", 1, this->m_iCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (there aren't any items)


	pCurrent = this->m_pFirst;
	pCurrentAsAlias = (PLLALIAS) pCurrent;

	// Keep trying while it's either:
	// not an alias and it isn't the object, or
	// it is an alias, but it doesn't point to the object.
	while (! (((! pCurrent->m_fAlias) && (pCurrent == pItem)) ||
			((pCurrent->m_fAlias) && (pCurrentAsAlias->m_pTarget == pItem))) )
	{
		if (pCurrent->m_pNext == NULL)
			break; // get out of here, it's not in the list
		pCurrent = pCurrent->m_pNext;
		pCurrentAsAlias = (PLLALIAS) pCurrent;
	} // end while (we haven't found that item yet)

	// If we didn't successfully find it in the list
	if (! (((! pCurrent->m_fAlias) && (pCurrent == pItem)) ||
		((pCurrent->m_fAlias) && (pCurrentAsAlias->m_pTarget == pItem))) )
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Didn't find item %x in list!", 1, pItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't find it in the list)


#ifdef DEBUG
	if (pCurrent->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "About to remove reference to item (%x) which has already been deleted!  DEBUGBREAK()-ing.",
			1, pCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (the item has already been deleted)
#endif //DEBUG

	
	// If there was only one item in this list, reset the list and jump to
	// the object cleanup code.
	if (this->m_iCount == 1)
	{
		this->m_pFirst = NULL;
		this->m_pLast = NULL;
		this->m_iCount = 0;
		goto REMOVE_OBJECT;
	} // end if (there's only one item)

	pPrev = pCurrent->m_pPrev;
	pNext = pCurrent->m_pNext;

	if (pCurrent == this->m_pFirst)
	{
#ifdef DEBUG
		if (pNext == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "%x is first object, and there's %i items left in the list, but there's no next pointer!  DEBUGBREAK()-ing.",
				2, pCurrent, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		pNext->m_pPrev = NULL;
		this->m_pFirst = pNext;
	} // end if (we're removing references from the first item)
	else if (pCurrent == this->m_pLast)
	{
#ifdef DEBUG
		if (pPrev == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "%x is the last object, and there's %i items left in the list, but there's no previous pointer!  DEBUGBREAK()-ing",
				2, pCurrent, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		pPrev->m_pNext = NULL;
		this->m_pLast = pPrev;
	} // end else if (we're removing references from the last item)
	else
	{
#ifdef DEBUG
		if ((pPrev == NULL) || (pNext == NULL))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "%x is not the first or last object, and there's %i items left in the list, but either the previous pointer (%x) or next pointer (%x) is NULL!  DEBUGBREAK()-ing.",
				4, pCurrent, this->m_iCount, pPrev, pNext);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		pPrev->m_pNext = pNext;
		pNext->m_pPrev = pPrev;
	} // end else (we're deleting in the middle)
	
	this->m_iCount--; // we took it out of the chain, so decrement the counter


REMOVE_OBJECT:

	pCurrent->m_pPrev = NULL;
	pCurrent->m_pNext = NULL;

	if (pCurrent->m_fAlias)
	{
		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Deleting alias   %x", 1, pCurrentAsAlias);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/


		// Grab the target so we can work with it below.
		pCurrent = pCurrentAsAlias->m_pTarget;

		pCurrentAsAlias->m_pTarget->m_dwRefCount--; // alias is no longer pointing to it
		delete (pCurrentAsAlias); // remove this as an alias object
		pCurrentAsAlias = NULL;
	} // end if (it's an alias)


#ifdef DEBUG
	if (pCurrent->m_dwRefCount == 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Original object %x refcount is 0!?", 1, pCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (object refcount is bad)
#endif // DEBUG

	// We took it off the list, so decrement the reference count.  Note: we aren't
	// deleting it!
	pCurrent->m_dwRefCount--;

	if (pCurrent->m_dwRefCount == 0)
	{
		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Object %x not being deleted when refcount hit 0, possibly expected behavior.",
			1, pCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/
	} // end if (last reference to this object)
	/*
	else
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Object %x refcount is %u.",
			2, pCurrent, pCurrent->m_dwRefCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end else (not last reference)
	*/


DONE:

	this->LeaveCritSection();
	return (hr);
} // LLIST::RemoveFirstReference
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::Remove()"
//==================================================================================
// LLIST::Remove
//----------------------------------------------------------------------------------
//
// Description: Removes the item at the specified index.
//
// Arguments:
//	int iPos	Index of item to remove from list.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::Remove(int iPos)
{
	HRESULT		hr = S_OK;
	PLLITEM		pCurrent = NULL;
	PLLITEM		pPrev = NULL;
	PLLITEM		pNext = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if ((iPos < 0) || (this->m_iCount <= 0) || (iPos >= this->m_iCount))
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Object to remove (%i) is out of range (list count == %i)!",
			2, iPos, this->m_iCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (no items or the number to get is too high )


	pCurrent = this->m_pFirst;

	while (iPos > 0)
	{
#ifdef DEBUG
		if (pCurrent->m_pNext == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Object %x has no next pointer but there should be at least %i more items (%i total in list)!",
				3, pCurrent, iPos, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count got screwed)
#endif //DEBUG

		pCurrent = pCurrent->m_pNext;
		iPos--;
	} // end while (we've still got more to traverse)



#ifdef DEBUG
	if (pCurrent->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "About to remove item (%x) which has already been deleted!  DEBUGBREAK()-ing.",
			1, pCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (the item has already been deleted)
#endif //DEBUG


	// If there was only one item in this list, reset the list and continue on to
	// deleting the object. 
	if (this->m_iCount == 1)
	{
		this->m_pFirst = NULL;
		this->m_pLast = NULL;
		this->m_iCount = 0;
		goto DELETE_OBJECT;
	} // end if (there's only one item)


	pPrev = pCurrent->m_pPrev;
	pNext = pCurrent->m_pNext;

	if (pCurrent == this->m_pFirst)
	{
#ifdef DEBUG
		if (pNext == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "%x is first object, and there's %i items left in the list, but there's no next pointer!  DEBUGBREAK()-ing.",
				2, pCurrent, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		pNext->m_pPrev = NULL;
		this->m_pFirst = pNext;
	} // end if (we're removing the first item)
	else if (pCurrent == this->m_pLast)
	{
#ifdef DEBUG
		if (pPrev == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "%x is the last object, and there's %i items left in the list, but there's no previous pointer!  DEBUGBREAK()-ing.",
				2, pCurrent, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		pPrev->m_pNext = NULL;
		this->m_pLast = pPrev;
	} // end else if (we're removing the last item)
	else
	{
#ifdef DEBUG
		if ((pPrev == NULL) || (pNext == NULL))
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "%x is not the first or last object, and there's %i items left in the list, but either the previous pointer (%x) or next pointer (%x) is NULL!  DEBUGBREAK()-ing.",
				4, pCurrent, this->m_iCount, pPrev, pNext);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (our count appears to be screwed up)
#endif //DEBUG

		pPrev->m_pNext = pNext;
		pNext->m_pPrev = pPrev;
	} // end else (we're deleting in the middle)
	
	this->m_iCount--; // we took it out of the chain, so decrement the counter



DELETE_OBJECT:

	if (pCurrent->m_fAlias)
	{
		PLLALIAS	pCurrentAsAlias;


		pCurrentAsAlias = (PLLALIAS) pCurrent;

#ifdef DEBUG
		if (pCurrentAsAlias->m_pTarget == NULL)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Alias points to null object!  How did that happen?  DEBUGBREAK()-ing.", 0);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();

			hr = ERROR_BAD_ENVIRONMENT;
			goto DONE;
		} // end if (something got screwed)

		if (pCurrentAsAlias->m_pTarget->m_fDeleted)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "About to remove alias target (%x) which has already been deleted!  DEBUGBREAK()-ing.",
				1, pCurrentAsAlias->m_pTarget);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			DEBUGBREAK();
		} // end if (the item has already been deleted)
#endif //DEBUG

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Deleting alias   %x", 1, pCurrentAsAlias);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/


		// Grab the target so we can possibly delete it as well in a second
		pCurrent = pCurrentAsAlias->m_pTarget;

		pCurrentAsAlias->m_pTarget->m_dwRefCount--; // alias is no longer pointing to it
		delete (pCurrentAsAlias); // remove this as an alias object
		pCurrentAsAlias = NULL;
	} // end if (it's an alias)


#ifdef DEBUG
	if (pCurrent->m_dwRefCount == 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Original item's refcount is zero!  It should be at least one!  DEBUGBREAK()-ing.", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();

		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (item's refcount is 0)
#endif //DEBUG


	// We took it off the list, so decrement the reference count.
	pCurrent->m_dwRefCount--;
	if (pCurrent->m_dwRefCount == 0)
	{
		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Deleting original   %x", 1, pCurrent);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		delete (pCurrent); // remove this as a normal object
		pCurrent = NULL;
	} // end if (this is the last reference to this object)
	/*
	else
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Not deleting object %x, its refcount is %u.", 
			2, pCurrent, pCurrent->m_dwRefCount);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end else (not last reference)
	*/


DONE:

	this->LeaveCritSection();

	return (hr);
} // LLIST::Remove
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::RemoveAll()"
//==================================================================================
// LLIST::RemoveAll
//----------------------------------------------------------------------------------
//
// Description: Removes all items in the list.
//
// Arguments: None.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::RemoveAll(void)
{
	HRESULT		hr = S_OK;
	int			iNumItems = -1;
	int			i;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	iNumItems = this->m_iCount;

	for(i = 0; i < iNumItems; i++)
	{
		hr = this->Remove(0);
		if (hr != S_OK)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Couldn't remove first item (this->m_pFirst = %x, this->m_iCount = %i)",
				2, this->m_pFirst, this->m_iCount);
			#endif // ! NO_TNCOMMON_DEBUG_SPEW
			break;
		} // end if (couldn't remove the first item)

	} // end for (each item in the list)

	this->LeaveCritSection();

	return (hr);
} // LLIST::RemoveAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::PopFirstItem()"
//==================================================================================
// LLIST::PopFirstItem
//----------------------------------------------------------------------------------
//
// Description: Pops the first item from the list and returns it.  If there are no
//				items, NULL is returned.  The item refcount is not reduced, because
//				even though it was taken off the list, the caller now has a
//				reference to it.
//
// Arguments: None.
//
// Returns: First item from list, or NULL if none.
//==================================================================================
PLLITEM LLIST::PopFirstItem(void)
{
	PLLITEM		pItem = NULL;



#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (NULL);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if (this->m_pFirst == NULL)
		goto DONE;

	pItem = this->m_pFirst;
	this->m_pFirst = pItem->m_pNext;

	// Since it's not going to be in a list anymore, enforce the fact that it's
	// not part of a chain.
	pItem->m_pNext = NULL;
#ifdef DEBUG
	if (pItem->m_pPrev != NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Object %x is screwed up, it's previous pointer is %x (should be NULL)!",
			2, pItem, pItem->m_pPrev);

		DEBUGBREAK();
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
	} // end if (item previous pointer is not NULL)
#endif // DEBUG

	this->m_iCount--; // we took out an item

	// If there's another item after the one we're popping, remove the backward
	// link it had to the item we popped.
	if (this->m_pFirst != NULL)
	{
#ifdef DEBUG
		if (this->m_iCount == 0)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Count is screwed up (it's 0 but %x is a non-NULL pointer)!",
				1, this->m_pFirst);

			DEBUGBREAK();
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			goto DONE;
		} // end if (count is wrong)
#endif // DEBUG

		this->m_pFirst->m_pPrev = NULL;
	} // end if (there's another item)
	else
	{
#ifdef DEBUG
		if (this->m_iCount != 0)
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Count is screwed up (it's %i but the first item pointer is NULL)!",
				1, this->m_iCount);

			DEBUGBREAK();
			#endif // ! NO_TNCOMMON_DEBUG_SPEW

			goto DONE;
		} // end if (count is wrong)
#endif // DEBUG

		// Make sure the last pointer is empty, too.
		this->m_pLast = NULL;
	} // end else (there aren't any more items)


	// If it was an alias instead of a real item, we can throw away the
	// alias.
	if (pItem->m_fAlias)
	{
		PLLALIAS	pAlias = NULL;


		pAlias = (PLLALIAS) pItem;
		pItem = pAlias->m_pTarget;

		/*
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(9, "Deleting alias   %x", 1, pAlias);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW
		*/

		// Delete the alias, we don't need it.
		delete (pAlias);
		pAlias = NULL;

		pItem->m_dwRefCount--; // the alias is now gone.
	} // end if (the item is an alias)


#ifdef DEBUG
	if (pItem->m_dwRefCount == 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Original object %x refcount is 0!?", 1, pItem);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		DEBUGBREAK();
	} // end if (object refcount is bad)
#endif // DEBUG


DONE:

	this->LeaveCritSection();

	return (pItem);
} // LLIST::PopFirstItem
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::Count()"
//==================================================================================
// LLIST::Count
//----------------------------------------------------------------------------------
//
// Description: Returns the number of items in the list.
//
// Arguments: None.
//
// Returns: Number of items in the list.
//==================================================================================
int LLIST::Count(void)
{
#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (-1);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (-1);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();
	this->LeaveCritSection();
	return (this->m_iCount);
} // LLIST::Count
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::MoveAfter()"
//==================================================================================
// LLIST::MoveAfter
//----------------------------------------------------------------------------------
//
// Description: Moves the item at the first specified index to be placed after
//				the second index.  If the after index is greater than the number
//				items actually in the list, it is placed at the end.
//
// Arguments:
//	int iPos		Index of item to move.
//	int iAfterPos	Index of item to place after.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::MoveAfter(int iPos, int iAfterPos)
{
	HRESULT		hr = S_OK;
	PLLITEM		pCurrent = NULL;
	PLLITEM		pAfter = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if ((this->m_iCount <= 0) || (iPos >= this->m_iCount))
	{
		this->LeaveCritSection();
		return (ERROR_INVALID_PARAMETER);
	} // end if (no items or bad count)

	if (iAfterPos >= this->m_iCount)
		iAfterPos = this->m_iCount - 1;

	if (iPos == iAfterPos)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (we're moving it after itself)

	pCurrent = this->GetItem(iPos);
	pAfter = this->GetItem(iAfterPos);

	//BUGBUG this may not work if the item appears multiple times in the list
	hr = this->RemoveFirstReference(pCurrent);
	if (hr == S_OK)
		hr = this->AddAfter(pCurrent, pAfter);

	this->LeaveCritSection();
	return (hr);
} // LLIST::MoveAfter
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"LLIST::SwapPosition()"
//==================================================================================
// LLIST::SwapPosition
//----------------------------------------------------------------------------------
//
// Description: Switches the items given so that the first item is now where the
//				second used to be, and vice versa.
//
// Arguments:
//	int iPos1	Index of first item to swap.
//	int iPos2	Index of other item to swap.
//
// Returns: S_OK if succeeded, otherwise the failure code.
//==================================================================================
HRESULT LLIST::SwapPosition(int iPos1, int iPos2)
{
	HRESULT		hr = S_OK;
	PLLITEM		pItem1 = NULL;
	PLLITEM		pItem2 = NULL;
	PLLITEM		pItem1Prev = NULL;
	PLLITEM		pItem2Prev = NULL;


#ifdef DEBUG
	if (this == NULL)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using invalid object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we've got a bad object)

	if (this->m_fDeleted)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "ERROR: Using deleted object!", 0);
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		return (ERROR_BAD_ENVIRONMENT);
	} // end if (using deleted object)
#endif // DEBUG


	this->EnterCritSection();

	if ((this->m_iCount <= 0) || (iPos1 >= this->m_iCount) || (iPos2 >= this->m_iCount))
	{
		this->LeaveCritSection();
		return (ERROR_INVALID_PARAMETER);
	} //end if (no items or bad indices)

	if (iPos1 == iPos2)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (they're the same item)

	pItem1 = this->GetItem(iPos1);
	if (pItem1 == NULL)
	{
		this->LeaveCritSection();
		return (E_FAIL);
	} // end if (failed to get the item)
	pItem2 = this->GetItem(iPos2);
	if (pItem2 == NULL)
	{
		this->LeaveCritSection();
		return (E_FAIL);
	} // end if (failed to get the item)

	pItem1Prev = pItem1->m_pPrev;
	pItem2Prev = pItem2->m_pPrev;

	if (pItem2Prev == pItem1)
	{
		//BUGBUG this may not work if the item appears multiple times in the list
		hr = this->RemoveFirstReference(pItem1);

		if (hr == S_OK)
			hr = this->AddAfter(pItem1, pItem2);
		
		this->LeaveCritSection();
		return (hr);
	} // end if (item 2 immediately follows item 1)

	if (pItem1Prev == pItem2)
	{
		//BUGBUG this may not work if the item appears multiple times in the list
		hr = this->RemoveFirstReference(pItem2);

		if (hr == S_OK)
			hr = this->AddAfter(pItem2, pItem1);
		
		this->LeaveCritSection();
		return (hr);
	} // end if (item 1 immediately follows item 2)

	//BUGBUG this may not work if the item appears multiple times in the list
	hr = this->RemoveFirstReference(pItem1);
	if (hr == S_OK)
		hr = this->RemoveFirstReference(pItem2);

	if (hr == S_OK)
		hr = this->AddAfter(pItem1, pItem2Prev);
	if (hr == S_OK)
		hr = this->AddAfter(pItem2, pItem1Prev);

	this->LeaveCritSection();
	return (hr);
} // LLIST::SwapPosition
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\linklist.h ===
#ifndef __LINKED_LIST__
#define __LINKED_LIST__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined




//===========================================================================
// Class typedefs
//===========================================================================
typedef class LLITEM	LLITEM,		* PLLITEM;
typedef class LLALIAS	LLALIAS,	* PLLALIAS;
typedef class LLIST		LLIST,		* PLLIST;






//==================================================================================
// The data class.
// These are the actual data elements.  You'll want to derive this class and add
// your own data that each element stores.
//==================================================================================
class DLLEXPORT LLITEM
{
	public:
		DWORD		m_dwRefCount; // how many lists and aliases refer to this item
		PLLITEM		m_pPrev; // Previous item in linked list
		PLLITEM		m_pNext; // Next item in linked list
		BOOL		m_fAlias; // is this item an alias instead of the actual item
#ifdef DEBUG
		BOOL		m_fDeleted; // set to false in constructor, true in destructor
#endif //DEBUG


		DLLSAFE_NEWS_AND_DELETES;

		LLITEM(void);
		virtual ~LLITEM(void);
};





//==================================================================================
// Pointers to data elements.
// Used to add another reference to a single item in the same or a different list
// without having to make a duplicate object.
//==================================================================================
class DLLEXPORT LLALIAS:public LLITEM
{
	public:
		PLLITEM		m_pTarget; // Object this alias stands for.


		LLALIAS(void);
		virtual ~LLALIAS(void);
};






//==================================================================================
// The list class.
// This keeps track of the individual data elements.
//==================================================================================
class DLLEXPORT LLIST:public LLITEM
{
	private:
		PLLITEM				m_pFirst; // First item in linked list
		PLLITEM				m_pLast; // Last item in linked list
		int					m_iCount; // Number of items in list
		CRITICAL_SECTION	m_cs; // Lists's critical section


	public:
#ifdef DEBUG
		BOOL				m_fDeleted; // set to FALSE in constructor, TRUE in destructor
#endif //DEBUG


		DLLSAFE_NEWS_AND_DELETES;

		LLIST(void);
		virtual ~LLIST(void);
		

		virtual void EnterCritSection(void);
		virtual void LeaveCritSection(void);

		HRESULT Add(PLLITEM pNewItem);
		HRESULT AddAfter(PLLITEM pNewItem, PLLITEM pAfterItem);
		HRESULT InsertBeforeIndex(PLLITEM pNewItem, int iPos);

		PLLITEM GetItem(int iPos);
		int GetFirstIndex(PLLITEM pItem);
		PLLITEM GetNextItem(PLLITEM pPreviousItem);
		PLLITEM GetPrevItem(PLLITEM pNextItem);

		HRESULT RemoveFirstReference(PLLITEM pItem);
		HRESULT Remove(int iPos);
		HRESULT RemoveAll(void);

		PLLITEM PopFirstItem(void);

		int Count(void);

		HRESULT MoveAfter(int iPos, int iAfterPos);
		HRESULT SwapPosition(int iPos1, int iPos2);
};






#ifdef DEBUG
#ifdef TRACKPOINTERS

//==================================================================================
// External structure definitions
//==================================================================================
typedef struct tagPOINTERTRACKING
{
	PVOID*		aPointers;
	DWORD		dwCurrentNumItems;
	DWORD		dwMaxNumItems;
} POINTERTRACKING, * PPOINTERTRACKING;


//==================================================================================
// External debugging globals
//==================================================================================
extern POINTERTRACKING		g_LLItems;
extern POINTERTRACKING		g_LLists;

#endif // TRACKPOINTERS
#endif // DEBUG



#endif //__LINKED_LIST__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\main.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "main.h"
#include "sprintf.h"
#include "debugprint.h"
#ifdef DEBUG
#include "cppobjhelp.h"
#include "symbols.h"
#endif // DEBUG

#include "version.h"



//==================================================================================
// Debugging help
//==================================================================================
char	g_szTNCOMMONVersion[] = TNCOMMON_VERSION_STRING;	




//==================================================================================
// External Statics
//==================================================================================
HINSTANCE	s_hInstance = NULL;




extern DWORD	g_dwStringsSize;




#undef DEBUG_SECTION
#define DEBUG_SECTION	"DllMain()"
//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HINSTANCE hmod		Handle to this DLL module.
//	DWORD dwReason		Reason for calling this function.
//	LPVOID lpvReserved	Reserved.
//
// Returns: TRUE if all goes well.
//==================================================================================
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
#ifdef DEBUG
	HRESULT		hr;
#endif // DEBUG


	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
#ifdef DEBUG
			InitCPPObjHelp();
#endif // DEBUG

			TNsprintfInitialize();

#ifdef DEBUG
			TNDebugInitialize();

#ifndef _XBOX // no symbol initialization
			hr = TNSymInitialize();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't initialize symbol functions!  %e", 1, hr);
			} // end if (couldn't initialize symbols)
#endif // ! XBOX

			DPL(1, "v%02u.%02u.%02u.%04u: attaching to process %x, hinstance = %x.",
				6, TNCOMMON_VERSION_MAJOR, TNCOMMON_VERSION_MINOR1,
				TNCOMMON_VERSION_MINOR2, TNCOMMON_VERSION_BUILD,
				GetCurrentProcessId(), hmod);
#endif // DEBUG

			s_hInstance = hmod;
		  break;

		case DLL_PROCESS_DETACH:
#ifndef _XBOX // No current process stuff...
			DPL(1, "Detaching from process %x, hinstance = %x.",
				2, GetCurrentProcessId(), hmod);
#endif // ! XBOX

#ifdef DEBUG
			//CheckForCPPObjLeaks();


			hr = TNSymCleanup();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't cleanup symbol functions!  %e", 1, hr);
			} // end if (couldn't cleanup symbols)

			TNDebugCleanup();
#endif //DEBUG

			TNsprintfCleanup();

#ifdef DEBUG
			CleanupCPPObjHelp();
#endif // ! XBOX
		  break;
	} // end switch (on the reason we're being called here)

	return (TRUE);
} // DllMain
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\main.h ===
#ifndef __TNCOMMON_MAIN__
#define __TNCOMMON_MAIN__
//#pragma message("Defining __TNCOMMON_MAIN__")




//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#undef DEBUG_MODULE
#define DEBUG_MODULE	"TNCOMMON"




//==================================================================================
// Debugging help
//==================================================================================
// This is the version of the DLL
extern char		g_szTNCOMMONVersion[];





//==================================================================================
// External Statics
//==================================================================================
extern HINSTANCE		s_hInstance;







#else //__TNCOMMON_MAIN__
//#pragma message("__TNCOMMON_MAIN__ already included!")
#endif //__TNCOMMON_MAIN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\sprintf.h ===
#ifndef __NEW_SPRINTF__
#define __NEW_SPRINTF__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined




//==================================================================================
// Defines
//==================================================================================
#ifdef _WIN64
#define SPRINTF_PTR		"%p"
#else
#define SPRINTF_PTR		"%08x"
#endif





//==================================================================================
// Prototypes
//==================================================================================
DLLEXPORT void TNsprintfInitialize(void);

DLLEXPORT void TNsprintfCleanup(void);


DLLEXPORT void TNsprintf(char** ppszOutput, char* szFormatString,
						DWORD dwNumParms, ...);

DLLEXPORT void TNsprintf_array(char** ppszOutput, char* szFormatString,
								DWORD dwNumParms, PVOID* apvParms);

DLLEXPORT void TNsprintf_free(char** ppszBuffer);


/*
DLLEXPORT void TNsprintfW(WCHAR** ppwszOutput, WCHAR* wszFormatString,
						DWORD dwNumParms, ...);

DLLEXPORT void TNsprintfW_array(WCHAR** ppwszOutput, WCHAR* wszFormatString,
								DWORD dwNumParms, PVOID* apvParms);

DLLEXPORT void TNsprintfW_free(WCHAR** ppwszBuffer);
*/






#endif // __NEW_SPRINTF__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\sprintf.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include <windows.h>

#ifndef _XBOX
#ifndef NO_SPRINTF_WINSOCK
#include <winsock.h>
#endif // ! NO_SPRINTF_WINSOCK
#else // ! XBOX
#ifndef NO_SPRINTF_WINSOCK
#include <winsock.h>
#endif // ! NO_SPRINTF_WINSOCK
#endif // XBOX

#ifndef NO_SPRINTF_DPLAY
#include <dplobby.h>
#endif // ! NO_SPRINTF_DPLAY

#ifndef NO_SPRINTF_DPLAY8
#include <dplay8.h>
#include <dpaddr.h>
#include <dpsp8.h>
#endif // ! NO_SPRINTF_DPLAY8

#ifndef NO_SPRINTF_DSOUND
#include <mmreg.h> // NTBUILD requires this for some reason
#include <dsound.h>
#endif // ! NO_SPRINTF_DSOUND

#ifndef NO_SPRINTF_DVOICE
#include <dvoice.h>
#endif // ! NO_SPRINTF_DVOICE

#include <initguid.h>


#include "main.h"
#include "errors.h"
#include "strutils.h"
#if ((defined (TNCOMMON_EXPORTS)) || (defined (USE_SPRINTF_SYMBOLLOOKUP)))
#include "symbols.h"
#endif // TNCOMMON_EXPORTS or USE_SPRINTF_SYMBOLLOOKUP
#include "sprintf.h"


//==================================================================================
// Local defines
//==================================================================================
#define INITIAL_BUFFER_SIZE		256



//==================================================================================
// Local structures
//==================================================================================
typedef struct TNSPRINTFBUFFER * PTNSPRINTFBUFFER;

struct TNSPRINTFBUFFER
{
	PTNSPRINTFBUFFER	pNextBuffer; // pointer to next buffer object in pool or list
	char*				pszBuffer; // pointer to actual string buffer
	DWORD				dwBufferSize; // size of actual string buffer, in bytes
};



//==================================================================================
// Globals
//==================================================================================
DWORD				g_dwTNsprintfRefcount = 0;
CRITICAL_SECTION	g_csBuffersLock;
PTNSPRINTFBUFFER	g_pFirstTNsprintfBufferInPool = NULL;
PTNSPRINTFBUFFER	g_pFirstTNsprintfBufferInOutstandingList = NULL;





//==================================================================================
// TNsprintfInitialize
//----------------------------------------------------------------------------------
//
// Description: Initializes TNsprintf functionality.  Should be called before any
//				other TNsprintf functions are used.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNsprintfInitialize(void)
{
	DWORD				dwTemp;
	PTNSPRINTFBUFFER	pBuffer;


	//BUGBUG according to MSDN, this won't necessarily work on Win95, because "if
	//		 the result of the operation is greater than zero, the return value is
	//		 positive, but it is not necessarily equal to the result".
	dwTemp = InterlockedIncrement((LPLONG) &g_dwTNsprintfRefcount);

	// If this process has already initialized TNsprintf at least once, we're done.
	if (dwTemp > 1)
		return;

	// Otherwise, we're the first caller, set up the stuff we need.

	//BUGBUG It's possible for another thread to try to use these before this first
	//       thread has completely set them up.

	InitializeCriticalSection(&g_csBuffersLock);

	g_pFirstTNsprintfBufferInPool = (PTNSPRINTFBUFFER) LocalAlloc(LPTR, sizeof (TNSPRINTFBUFFER));
	if (g_pFirstTNsprintfBufferInPool == NULL)
		return;

	pBuffer = g_pFirstTNsprintfBufferInPool;
	pBuffer->dwBufferSize = INITIAL_BUFFER_SIZE;
	pBuffer->pszBuffer = (char*) LocalAlloc(LPTR, pBuffer->dwBufferSize);
	if (pBuffer->pszBuffer == NULL)
	{
		LocalFree(g_pFirstTNsprintfBufferInPool);
		g_pFirstTNsprintfBufferInPool = NULL;
		return;
	} // end if (couldn't allocate memory)

	// End up with a total of 5 buffers.
	for(dwTemp = 1; dwTemp < 5; dwTemp++)
	{
		pBuffer->pNextBuffer = (PTNSPRINTFBUFFER) LocalAlloc(LPTR, sizeof (TNSPRINTFBUFFER));
		if (pBuffer->pNextBuffer == NULL)
			return;

		pBuffer = pBuffer->pNextBuffer;

		pBuffer->dwBufferSize = INITIAL_BUFFER_SIZE;
		pBuffer->pszBuffer = (char*) LocalAlloc(LPTR, pBuffer->dwBufferSize);
		if (pBuffer->pszBuffer == NULL)
			return;
	} // end for (each buffer)
} // TNsprintfInitialize





//==================================================================================
// TNsprintfCleanup
//----------------------------------------------------------------------------------
//
// Description: Cleans up TNsprintf functionality.  Must be called for each call
//				to TNsprintfInitialize.  Last caller in the process shuts down all
//				items allocated.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void TNsprintfCleanup(void)
{
	PTNSPRINTFBUFFER	pBuffer;
	PTNSPRINTFBUFFER	pNextBuffer;


	// BUGBUG if someone calls Initialize while we're inside the final cleanup code,
	//		  they will get hosed.


	// If this process still has more users of TNDebug functions, we're done.
	if (g_dwTNsprintfRefcount > 1)
	{
		g_dwTNsprintfRefcount--;
		return;
	} // end if (we're not the last one to use the function)


	// Otherwise, shut down the stuff that was in use.

	pNextBuffer = g_pFirstTNsprintfBufferInPool;
	g_pFirstTNsprintfBufferInPool = NULL;

	while (pNextBuffer != NULL)
	{
		pBuffer = pNextBuffer;
		pNextBuffer = pNextBuffer->pNextBuffer;

		if (pBuffer->pszBuffer != NULL)
			LocalFree(pBuffer->pszBuffer);

		LocalFree(pBuffer);
	} // end while (buffers to free)

#ifdef DEBUG
	if (g_pFirstTNsprintfBufferInOutstandingList != NULL)
	{
#ifdef _X86_
		OutputDebugString("There are still TNsprintf buffers outstanding!  int 3-ing.\n");
		{_asm int 3};
#else // _X86_
		OutputDebugString("There are still TNsprintf buffers outstanding!  DebugBreak()-ing.\n");
		DebugBreak();
#endif // _X86_
	} // end if (buffers not returned)
#endif // DEBUG

	DeleteCriticalSection(&g_csBuffersLock);

	g_dwTNsprintfRefcount--; // should be 0 after this
#ifdef DEBUG
	if (g_dwTNsprintfRefcount != 0)
	{
#ifdef _X86_
		OutputDebugString("TNsprintf refcount is screwed!  int 3-ing.\n");
		{_asm int 3};
#else // _X86_
		OutputDebugString("TNsprintf refcount is screwed!  DebugBreak()-ing.\n");
		DebugBreak();
#endif // _X86_
	} // end if (refcount is screwed)
#endif // DEBUG
} // TNsprintfCleanup






#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNsprintf()"
//==================================================================================
// TNsprintf
//----------------------------------------------------------------------------------
//
// Description: Builds a string from a required format string and additional
//				optional parameters.
//				NOTE: memory is allocated here, so the caller must call
//				TNsprintf_free when done using string.
//
//				The available special tokens are:
//					"%b" - bool, "false" is printed if the parameter is 0, otherwise
//							"true" is printed.
//					"%B" - BOOL, "FALSE" is printed if the parameter is 0, otherwise
//							"TRUE" is printed.
//					"%c" - ANSI character.
//					"%C" - Unicode character.
//					"%d" - signed decimal integer.  Same as %i.  [-][0][width] are
//							options which can be between the % and the d, where "-"
//							specifies right justified padding, 0 means use zero
//							padding instead of spaces, and width indicates the
//							minimum number of characters to display (i.e. padding,
//							but not the number to truncate to if longer).
//					"%e" - error name string.  Param is HRESULT.
//					"%E" - error name and description string.  Param is HRESULT.
//					"%f" - double precision floating point value.  Param is a
//							pointer to a double.
//					"%F" - floating point value.  Param is a pointer to a float.
//					"%g" - GUID. Param is a pointer to a GUID.
//					"%G" - GUID + attempts to resolve string name for GUID.  Param
//							is a pointer to a GUID.
//					"%i" - signed decimal integer.  Same as %d.  [-][0][width] are
//							options which can be between the % and the i, where "-"
//							specifies right justified padding, 0 means use zero
//							padding instead of spaces, and width indicates the
//							minimum number of characters to display (i.e. padding,
//							but not the number to truncate to if longer).
//					"%o" - socket address, param is pointer to SOCKADDR_IN.
//					"%s" - ANSI string.
//					"%S" - Unicode string.
//					"%t" - flag table. First parameter is the DWORD_PTR containing
//							flags to convert, second parameter is a pointer to the
//							TNFLAGTABLEITEM array for conversion, and third
//							parameter is number of items in the TNFLAGTABLEITEM
//							array.
//					"%u" - Unsigned decimal integer.  [-][0][width] are options
//							which can be between the % and the u, where "-"
//							specifies right justified padding, 0 means use zero
//							padding instead of spaces, and width indicates the
//							minimum number of characters to display (i.e. padding,
//							but not the number to truncate to if longer).
//					"%v" - binary data, printed in byte chunks, hex.  First
//							parameter is pointer to data, second is size of data.
//					"%x" - hexadecimal DWORD with 0x prefix.
//					"%X" - hexadecimal DWORD + attempts to look up a symbol
//							associated with the param.
//					"%z" - sized ANSI string.  First parameter is pointer to string
//							start, second is number of characters to print.
//
//
// Arguments:
//	char** ppszOutput		Pointer to pointer that will be set to point at the new
//							string.
//	char* szFormatString	String (with optional tokens) to print.
//	DWORD dwNumParms		How many parameters are in the following variable
//							parameter list.
//	...						Variable list of parameters to parse.
//
// Returns: None.
//==================================================================================
void TNsprintf(char** ppszOutput, char* szFormatString, DWORD dwNumParms, ...)
{
#ifndef _XBOX // need to overwrite this with xLogging
	PVOID*		papvParms = NULL;
	va_list		currentparam;
	DWORD		dwTemp = 0;


	if (dwNumParms > 0)
	{
		papvParms = (PVOID*) LocalAlloc(LPTR, (dwNumParms * sizeof (PVOID)));
		if (papvParms == NULL)
			return;

		va_start(currentparam, dwNumParms);

		for(dwTemp = 0; dwTemp < dwNumParms; dwTemp++)
		{
			papvParms[dwTemp] = va_arg(currentparam, PVOID);
		} // end for (each parameter)

		va_end(currentparam);
	} // end if (there are parameters to check)


	// Call the array version of this function.
	TNsprintf_array(ppszOutput, szFormatString, dwNumParms, papvParms);


	LocalFree(papvParms);
	papvParms = NULL;
#else // ! XBOX
//#pragma TODO(tristanj, "Need to map TNsprintf to an xLog based function")
#endif // XBOX

} // TNsprintf
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




// Save the current warning settings
#pragma warning(push)

// Turn off:
// warning C4800: 'void *' : forcing value to bool 'true' or 'false' (performance warning)
// see case 'b' below.
#pragma warning(disable : 4800)




#ifndef _XBOX // no logging
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNsprintf_array()"
//==================================================================================
// TNsprintf_array
//----------------------------------------------------------------------------------
//
// Description: Builds a string from a required format string and additional
//				optional parameters in the form of a variable sized array.
//				NOTE: memory is allocated here, so the caller must call
//				TNsprintf_free when done using string.
//
//				The available special tokens are:
//					"%b" - bool, "false" is printed if the parameter is 0, otherwise
//							"true" is printed.
//					"%B" - BOOL, "FALSE" is printed if the parameter is 0, otherwise
//							"TRUE" is printed.
//					"%c" - ANSI character.
//					"%C" - Unicode character.
//					"%d" - signed decimal integer.  Same as %i.  [-][0][width] are
//							options which can be between the % and the d, where "-"
//							specifies right justified padding, 0 means use zero
//							padding instead of spaces, and width indicates the
//							minimum number of characters to display (i.e. padding,
//							but not the number to truncate to if longer).
//					"%e" - error name string.  Param is HRESULT.
//					"%E" - error name and description string.  Param is HRESULT.
//					"%f" - double precision floating point value.  Param is a
//							pointer to a double.
//					"%F" - floating point value.  Param is a pointer to a float.
//					"%g" - GUID. Param is a pointer to a GUID.
//					"%G" - GUID + attempts to resolve string name for GUID.  Param
//							is a pointer to a GUID.
//					"%i" - signed decimal integer.  Same as %d.  [-][0][width] are
//							options which can be between the % and the i, where "-"
//							specifies right justified padding, 0 means use zero
//							padding instead of spaces, and width indicates the
//							minimum number of characters to display (i.e. padding,
//							but not the number to truncate to if longer).
//					"%o" - socket address, param is pointer to SOCKADDR_IN.
//					"%s" - ANSI string.
//					"%S" - Unicode string.
//					"%t" - flag table. First parameter is the DWORD_PTR containing
//							flags to convert, second parameter is a pointer to the
//							TNFLAGTABLEITEM array for conversion, and third
//							parameter is number of items in the TNFLAGTABLEITEM
//							array.
//					"%u" - Unsigned decimal integer.  [-][0][width] are options
//							which can be between the % and the u, where "-"
//							specifies right justified padding, 0 means use zero
//							padding instead of spaces, and width indicates the
//							minimum number of characters to display (i.e. padding,
//							but not the number to truncate to if longer).
//					"%v" - binary data, printed in byte chunks, hex.  First
//							parameter is pointer to data, second is size of data.
//					"%x" - hexadecimal DWORD with 0x prefix.
//					"%X" - hexadecimal DWORD + attempts to look up a symbol
//							associated with the param.
//					"%z" - sized ANSI string.  First parameter is pointer to string
//							start, second is number of characters to print.
//
//
// Arguments:
//	char** ppszOutput		Pointer to pointer that will be set to point at the new
//							string.
//	char* szFormatString	String (with optional tokens) to print.
//	DWORD dwNumParms		How many parameters are in the following array.
//	PVOID* apvParms			Array of parameter items to parse.
//
// Returns: None.
//==================================================================================
void TNsprintf_array(char** ppszOutput, char* szFormatString,
					DWORD dwNumParms, PVOID* apvParms)
{
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//BUGBUG DWORD to int conversion sometimes
	//This essentially performs a realloc.
	#define ENSUREBUFFERLENGTH(buffer, chars)	{\
													if ((int) (chars) >= buffer->dwBufferSize)\
													{\
														buffer->dwBufferSize += chars + INITIAL_BUFFER_SIZE;\
														pvTemp = LocalAlloc(LPTR, (buffer->dwBufferSize * sizeof (char)));\
														if (pvTemp == NULL)\
														{\
															goto DONE;\
														}\
														strcpy((char*) pvTemp, buffer->pszBuffer);\
														LocalFree(buffer->pszBuffer);\
														buffer->pszBuffer = (char*) pvTemp;\
														pvTemp = NULL;\
													}\
												}
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	DWORD_PTR			dwParm = 0;
	int					i;
	PTNSPRINTFBUFFER	pBuffer = NULL;
	PTNSPRINTFBUFFER	pTempBuffer = NULL;
	DWORD				dwCurrentTempIndex = 0;
	DWORD				dwUsedOutputLength = 0;
	BOOL				fInToken = FALSE;
	BOOL				fNumbersNotAllowed = FALSE;
	BOOL				fDashesNotAllowed = FALSE;
	BOOL				fPeriodsNotAllowed = FALSE;
	PVOID				pvTemp = NULL;
	DWORD				dwSize;
	DWORD_PTR			dwFlags;
	char				szNumber[32];
	GUID*				pGuid;
	char*				pszString;


	// Get 2 buffers, one to pass back to user and the other to use temporarily.
	// First try to get each from the pool.  If those are all taken, allocate a new
	// one.
	EnterCriticalSection(&g_csBuffersLock);
	for(i = 2; i > 0; i--)
	{
		pBuffer = g_pFirstTNsprintfBufferInPool;
		if (pBuffer == NULL)
		{
			pBuffer = (PTNSPRINTFBUFFER) LocalAlloc(LPTR, sizeof (TNSPRINTFBUFFER));
			if (pBuffer == NULL)
			{
				LeaveCriticalSection(&g_csBuffersLock);
				goto DONE;
			} // end if (out of memory)

			pBuffer->dwBufferSize = INITIAL_BUFFER_SIZE;
			pBuffer->pszBuffer = (char*) LocalAlloc(LPTR, pBuffer->dwBufferSize);
			if (pBuffer->pszBuffer == NULL)
			{
				LeaveCriticalSection(&g_csBuffersLock);
				goto DONE;
			} // end if (out of memory)
		} // end if (no buffers in pool)
		else
		{
			// We took the item out of the pool.
			g_pFirstTNsprintfBufferInPool = g_pFirstTNsprintfBufferInPool->pNextBuffer;

			// Not in any lists right now.
			pBuffer->pNextBuffer = NULL;
		} // end else (buffers left in pool)

		// First time through the loop was for the temp buffer.
		if (i == 2)
			pTempBuffer = pBuffer;
	} // end for (returned buffer and temp buffer)
	LeaveCriticalSection(&g_csBuffersLock);


#ifdef DEBUG
	// I'm not sure how this could happen, but it seems to be, so try to catch it
	// early.
	if (pTempBuffer == pBuffer)
	{
#ifdef _X86_
		OutputDebugString("\nTemp buffer and final buffer are the same!  int 3-ing.\n");
		{_asm int 3};
#else // _X86_
		OutputDebugString("\nTemp buffer and final buffer are the same!  DebugBreak()-ing.\n");
		DebugBreak();
#endif // _X86_
	} // end if (got same buffer)
#endif // DEBUG


	// i should be 0 here
	while (szFormatString[i] != 0)
	{
		// Make sure the temp buffer can hold more characters.
		ENSUREBUFFERLENGTH(pTempBuffer, dwCurrentTempIndex);

		// Default to just copying the character over.
		pTempBuffer->pszBuffer[dwCurrentTempIndex] = szFormatString[i];
		pTempBuffer->pszBuffer[dwCurrentTempIndex + 1] = 0; // NULL terminate it

		if (fInToken)
		{
			switch (szFormatString[i])
			{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					// If we already moved past an acceptable place for numbers,
					// abort this token.
					if (fNumbersNotAllowed)
					{
						// Abort this token string, and dump what we have
						fInToken = FALSE;
					} // end if (not the first character)

					// Movin' on up
					dwCurrentTempIndex++;

					// Dashes are not allowed after numbers.
					fDashesNotAllowed = TRUE;
				  break;

				case '-':
					// If we already moved past an acceptable place for a dash,
					// abort this token.
					if (fDashesNotAllowed)
					{
						// Abort this token string, and dump what we have
						fInToken = FALSE;
					} // end if (not the first character)

					// Movin' on up
					dwCurrentTempIndex++;
				  break;

				case '.':
					// If we already moved past an acceptable place for a period,
					// abort this token.
					if (fPeriodsNotAllowed)
					{
						// Abort this token string, and dump what we have
						fInToken = FALSE;
					} // end if (not the first character)

					// Movin' on up
					dwCurrentTempIndex++;

					// Dashes are not allowed after periods.
					fDashesNotAllowed = TRUE;
				  break;

				case 'b':
					bool	bData;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%b") == 0)
					{
						// This will generate a compiler warning on all platforms,
						// but it is disabled above.
						bData = (bool) apvParms[dwParm++];


						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough for larger of
						// ("true" | "false").
						//ENSUREBUFFERLENGTH(pTempBuffer, 5);

						if (bData)
							strcpy(pTempBuffer->pszBuffer, "true");
						else
							strcpy(pTempBuffer->pszBuffer, "false");
					} // end if (valid token)
				  break;
				  
				case 'B':
					BOOL	fData;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%B") == 0)
					{
// Unfortunately can't use the pragmas, because debugprint.h isn't (and can't be)
// included.
						fData = (BOOL)(DWORD_PTR) apvParms[dwParm++];


						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough for larger of
						// ("TRUE" | "FALSE").
						//ENSUREBUFFERLENGTH(pTempBuffer, 5);

						if (fData)
							strcpy(pTempBuffer->pszBuffer, "TRUE");
						else
							strcpy(pTempBuffer->pszBuffer, "FALSE");
					} // end if (valid token)
				  break;
				  
				case 'c':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%c") == 0)
					{
						// Make sure the buffer is large enough.
						ENSUREBUFFERLENGTH(pTempBuffer, 1);

						wsprintfA(pTempBuffer->pszBuffer, "%c", (char) apvParms[dwParm++]);
					} // end if (valid token)
				  break;
				  
				case 'C':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%C") == 0)
					{
						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough.
						//ENSUREBUFFERLENGTH(pTempBuffer, 1);

						wsprintfA(pTempBuffer->pszBuffer, "%C", (WCHAR) apvParms[dwParm++]);
					} // end if (valid token)
				  break;
				  
				case 'd':
				case 'i':
				case 'u':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;

					// %d and %i are ints, %u is a DWORD, but they all get passed
					// straight to wsprintfA the same way (formatting info and all).
					wsprintfA(szNumber, pTempBuffer->pszBuffer, apvParms[dwParm++]);

					// Commented out because we know it will be large enough....
					//
					// Make sure the buffer is large enough.
					//ENSUREBUFFERLENGTH(pTempBuffer, strlen(szNumber));

					strcpy(pTempBuffer->pszBuffer, szNumber);
				  break;
				  
				case 'e':
				case 'E':
					LONG_PTR	hrValue;
					DWORD		dwShortcut;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;

// Unfortunately can't use the pragmas, because debugprint.h isn't (and can't be)
// included.
//#pragma TODO(BrettHu,"Can you use a LONG_PTR in plcase of an HRESULT? Is this good coding practice for IA 64 ?")
					hrValue = (LONG_PTR) apvParms[dwParm++];

					dwFlags = ERRORSFLAG_PRINTHEXVALUE | ERRORSFLAG_PRINTDECIMALVALUE;

					// Uppercase E means they want the description, too.
					if (strcmp(pTempBuffer->pszBuffer, "%E") == 0)
						dwFlags |= ERRORSFLAG_PRINTDESCRIPTION;

					// We want to optimize, so initialize the shortcut.
					dwShortcut = ERRORSSHORTCUT_NOTSEARCHED;


					// Ignore error, assume BUFFER_TOO_SMALL
					GetErrorDescription(hrValue, dwFlags, NULL, &dwSize, &dwShortcut);

					// Make sure the buffer is large enough.
					ENSUREBUFFERLENGTH(pTempBuffer, dwSize);

					// Ignore error
					GetErrorDescription(hrValue, dwFlags, pTempBuffer->pszBuffer,
										&dwSize, &dwShortcut);
				  break;

				case 'f':
				case 'F':
					int		iSrcChar;
					int		iDestChar;
					int		iDec;
					int		iSign;


					fInToken = FALSE;

					if (szFormatString[i] == 'F')
					{
						pszString = _fcvt(*((float*) (apvParms[dwParm++])),
											10, &iDec, &iSign);

						if (pszString[0] == '\0')
						{
							// Commented out because we know it will be big enough.
							//ENSUREBUFFERLENGTH(pTempBuffer, strlen("__unprintable_float__") + 1);

							strcpy(pTempBuffer->pszBuffer, "__unprintable_float__");
							break; // bail out of the case statement
						} // end if (not a valid string)
					} // end if (float type proper)
					else
					{
						pszString = _ecvt(*((double*) (apvParms[dwParm++])),
											10, &iDec, &iSign);

						if (pszString[0] == '\0')
						{
							// Commented out because we know it will be big enough.
							//ENSUREBUFFERLENGTH(pTempBuffer, strlen("__unprintable_double__") + 1);

							strcpy(pTempBuffer->pszBuffer, "__unprintable_double__");
							break; // bail out of the case statement
						} // end if (not a valid string)
					} // end else (double type)


					// If the decimal point is to the right of the start of the string,
					// then we only need room for the decimal point.
					// Otherwise, we need to include room for leading zeros.
					// The 3 comes from: 1 for possible '-', 1 for decimal point, 1
					// for NULL termination
					if (iDec < 1)
						iSrcChar = (-1 * iDec) + 4; // + 1 for extra leading zero
					else
						iSrcChar = 3;

					ENSUREBUFFERLENGTH(pTempBuffer, strlen(pszString) + iSrcChar);

					iSrcChar = 0;
					iDestChar = 0;

					// If it's negative, add the minus sign
					if (iSign)
					{
						pTempBuffer->pszBuffer[iDestChar++] = '-'; // add minus sign
					} // end if (it's negative)
					
					// If -1 < number < 1, then put leading 0s.
					if (iDec < 1)
					{
						// Insert extra leading zero.
						pTempBuffer->pszBuffer[iDestChar++] = '0';
						// Insert decimal place
						pTempBuffer->pszBuffer[iDestChar++] = '.';

						// For even smaller numbers, add more zeroes.
						while (iDec < 0)
						{
							// Add another leading 0.
							pTempBuffer->pszBuffer[iDestChar++] = '0';
							iDec++;
						} // end while (need more leading zeros)

						// We've already placed the decimal point, so make sure
						// we don't do it again.
						iDec = -1;
					} // end if (less than |1|)

					do
					{
						// Insert the decimal point if it's located here.
						if (iDec == iSrcChar)
						{
							pTempBuffer->pszBuffer[iDestChar++] = '.';
						} // end if (should insert decimal point)


						// Copy the character over
						pTempBuffer->pszBuffer[iDestChar] = pszString[iSrcChar];

						if (pszString[iSrcChar] == '\0')
							break;

						iSrcChar++;
						iDestChar++;
					} // end do (while haven't hit end of string)
					while (TRUE);

					// Go back until the first non trailing zero.
					do
					{
						iDestChar--;
					} // end while (not at non-zero character)
					while (pTempBuffer->pszBuffer[iDestChar] == '0');

					// If the decimal point was at the end, that looks dumb, so
					// leave one trailing zero.
					if (pTempBuffer->pszBuffer[iDestChar] == '.')
						iDestChar++;

					// Make sure the string is terminated at the end here
					pTempBuffer->pszBuffer[iDestChar + 1] = '\0';
				  break;
				  
				case 'g':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%g") == 0)
					{
						pGuid = (GUID*) apvParms[dwParm++];

						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough.  This is the size of
						// the longest possible GUID string.
						//ENSUREBUFFERLENGTH(pTempBuffer, 38);

						if (pGuid == NULL)
						{
							strcpy(pTempBuffer->pszBuffer, "{NULL GUID pointer}");
							break; // get out of the case statement
						} // end if (NULL pointer)

						wsprintfA(pTempBuffer->pszBuffer, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
								pGuid->Data1, pGuid->Data2, pGuid->Data3,
								pGuid->Data4[0], pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3],
								pGuid->Data4[4], pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7]);
					} // end if (valid token)
				  break;
				  
				case 'G':
					BOOL		fFound;
					DWORD		dwType;
#ifndef NO_SPRINTF_REGISTRY
					HKEY		hKey;
					char		szTemp2[1024];
#endif // ! NO_SPRINTF_REGISTRY 


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%G") == 0)
					{
						pGuid = (GUID*) apvParms[dwParm++];

						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough.  This is the size of
						// the longest possible GUID string.  We'll probably do more
						// size checking in a second.
						//ENSUREBUFFERLENGTH(pTempBuffer, 38);

						if (pGuid == NULL)
						{
							strcpy(pTempBuffer->pszBuffer, "{NULL GUID pointer}");
							break; // get out of the case statement
						} // end if (NULL pointer)

						fFound = FALSE;
						dwType = 0;

						wsprintfA(pTempBuffer->pszBuffer, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
								pGuid->Data1, pGuid->Data2, pGuid->Data3,
								pGuid->Data4[0], pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3],
								pGuid->Data4[4], pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7]);

#ifndef NO_SPRINTF_REGISTRY
						strcpy(szTemp2, "CLSID\\");
						strcat(szTemp2, pTempBuffer->pszBuffer);

						// Look for a COM Class ID that matches this and pull out its
						// name, if possible.

						if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp2, 0, KEY_QUERY_VALUE, &hKey) == S_OK)
						{
							dwSize = 1024; // string buffer size
							if ((RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE) szTemp2, &dwSize) == S_OK) &&
								(dwType == REG_SZ))
							{
								strcat(szTemp2, " - ");

								// Make sure the buffer is large enough.
								ENSUREBUFFERLENGTH(pTempBuffer, 38 + strlen(szTemp2));

								StringPrepend(pTempBuffer->pszBuffer, szTemp2);
								fFound = TRUE;
							} // end if (there's a default string value for the key)

							RegCloseKey(hKey); // ignore error
						} // end if (we could open the specified key)

						if (fFound)
							break; // stop further processing


						// We didn't find a COM class that matched it, so look through
						// the DPlay SP GUIDs we know about.

						strcpy(szTemp2, "SOFTWARE\\Microsoft\\DirectPlay\\Service Providers");

						if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp2, 0, KEY_ENUMERATE_SUB_KEYS, &hKey) == S_OK)
						{
							DWORD	dwKeyIndex;
							char	szName[1024];
							DWORD	dwNameLength;
							HKEY	hSubKey;


							dwKeyIndex = 0; // start at beginning
							while (TRUE)
							{
								dwNameLength = 1024 - 1; // size of buffer - zero terminator
								if (RegEnumKeyEx(hKey, dwKeyIndex, szName, &dwNameLength, 0, NULL, NULL, NULL) != S_OK)
									break; // get out of the loop, assume it's a non-fatal error

								dwKeyIndex++; // move on to next key

								strcpy(szTemp2, "SOFTWARE\\Microsoft\\DirectPlay\\Service Providers\\");
								strcat(szTemp2, szName);

								if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp2, 0, KEY_QUERY_VALUE, &hSubKey) == S_OK)
								{
									dwSize = 1024; // string buffer size
									if ((RegQueryValueEx(hSubKey, "Guid", 0, &dwType, (LPBYTE) szTemp2, &dwSize) == S_OK) &&
										(dwType == REG_SZ))
									{
										// Make it lower case since the letters output
										// by the binary to string conversion for the
										// GUID above uses lower case letters.
										if (strcmp(_strlwr(szTemp2), pTempBuffer->pszBuffer) == 0)
										{
											strcat(szName, " - ");

											// Make sure the buffer is large enough.
											ENSUREBUFFERLENGTH(pTempBuffer, 38 + strlen(szName));

											StringPrepend(pTempBuffer->pszBuffer, szName);
											fFound = TRUE;
										} // end if (the GUIDs match)
									} // end if (there's a valid GUID string value for the sub key)

									RegCloseKey(hSubKey); // ignore error
								} // end if (we could open the sub key)
							} // end while (no error and there are more sub keys)

							RegCloseKey(hKey); // ignore error
						} // end if (we could open the specified key)
#endif // ! NO_SPRINTF_REGISTRY

						if (fFound)
							break; // stop further processing


						// We didn't find a DPlay SP that matched it, so check for any
						// other type of GUIDs we know about.  We don't bother checking
						// to make sure the temp buffer is big enough because we know
						// it will be.

#ifndef NO_SPRINTF_DPLAY
						if (IsEqualGUID((*pGuid), DPAID_ComPort))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_ComPort - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_INet))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_INet - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_INetW))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_INetW - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_INetPort))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_INetPort - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_LobbyProvider))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_LobbyProvider - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_Modem))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_Modem - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_ModemW))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_ModemW - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_Phone))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_Phone - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_PhoneW))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_PhoneW - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_ServiceProvider))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_ServiceProvider - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPAID_TotalSize))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPAID_TotalSize - ");
							break;
						} // end if (we know about this GUID)
#endif // ! NO_SPRINTF_DPLAY

#ifndef NO_SPRINTF_DPLAY8
						if (IsEqualGUID((*pGuid), IID_IDP8ServiceProvider))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDP8ServiceProvider - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8Client))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8Client - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8Server))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8Server - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8Peer))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8Peer - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8Address))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8Address - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8AddressInternal))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8AddressInternal - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8AddressIP))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8AddressIP - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8AddressIPX))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8AddressIPX - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8AddressModem))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8AddressModem - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlay8AddressSerial))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlay8AddressSerial - ");
							break;
						} // end if (we know about this GUID)
#endif // ! NO_SPRINTF_DPLAY8

#ifndef NO_SPRINTF_DVOICE

				//TODO: IIDs for different versions

						if (IsEqualGUID((*pGuid), IID_IDirectPlayVoiceClient))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlayVoiceClient - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlayVoiceServer))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlayVoiceServer - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlayVoiceTest))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlayVoiceTest - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_TRUESPEECH))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_TRUESPEECH - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_GSM))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_GSM - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_NONE))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_NONE - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_ADPCM))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_ADPCM - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_SC03))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_SC03 - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_SC06))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_SC06 - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), DPVCTGUID_VR12))
						{
							StringPrepend(pTempBuffer->pszBuffer, "DPVCTGUID_VR12 - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlayVoiceNotify))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlayVoiceNotify - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectPlayVoiceTransport))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectPlayVoiceTransport - ");
							break;
						} // end if (we know about this GUID)
#endif // ! NO_SPRINTF_DVOICE

#ifndef NO_SPRINTF_DSOUND
						if (IsEqualGUID((*pGuid), IID_IDirectSound))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSound - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectSoundBuffer))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSoundBuffer - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectSound3DListener))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSound3DListener - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectSound3DBuffer))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSound3DBuffer - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectSoundCapture))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSoundCapture - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectSoundCaptureBuffer))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSoundCaptureBuffer - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IDirectSoundNotify))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IDirectSoundNotify - ");
							break;
						} // end if (we know about this GUID)

						if (IsEqualGUID((*pGuid), IID_IKsPropertySet))
						{
							StringPrepend(pTempBuffer->pszBuffer, "IID_IKsPropertySet - ");
							break;
						} // end if (we know about this GUID)
#endif // ! NO_SPRINTF_DSOUND


						// Nobody knows about this GUID, so copy in a default string.

						StringPrepend(pTempBuffer->pszBuffer, "Unknown GUID - ");
					} // end if (valid token)
				  break;
				  				  
#ifndef NO_SPRINTF_WINSOCK
				case 'o':
					SOCKADDR_IN*	pSockAddrIn;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%o") == 0)
					{
						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough for
						// "255.255.255.255:65535"
						//ENSUREBUFFERLENGTH(pTempBuffer, 21);

						pSockAddrIn = (SOCKADDR_IN*) (apvParms[dwParm++]);
						wsprintfA(pTempBuffer->pszBuffer, "%s:%i", inet_ntoa(pSockAddrIn->sin_addr),
								ntohs(pSockAddrIn->sin_port));
					} // end if (valid token)
				  break;
#endif // NO_SPRINTF_WINSOCK

				case 's':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%s") == 0)
					{
						pszString = (char*) (apvParms[dwParm++]);

						if (pszString == NULL)
						{
							// Commented out because we know it will be large enough....
							//
							// Make sure the buffer is large enough for
							// "_NULL-string_"
							//ENSUREBUFFERLENGTH(pTempBuffer, 13);
							strcpy(pTempBuffer->pszBuffer, "_NULL-string_");
						} // end if (it's a NULL string)
						else
						{
							// Make sure it's a valid string.
							try
							{
								// Make sure the buffer is large enough.
								ENSUREBUFFERLENGTH(pTempBuffer, strlen(pszString));
								strcpy(pTempBuffer->pszBuffer, pszString);
							} // end try
							catch (...)
							{
								wsprintfA(szNumber, "0x" SPRINTF_PTR, pszString);

								// Commented out because we know it will be large enough....
								//
								// Make sure the buffer is large enough.
								//ENSUREBUFFERLENGTH(pTempBuffer, strlen(szNumber) + strlen("_invalid-string-_"));

								strcpy(pTempBuffer->pszBuffer, "_invalid-string-");
								strcat(pTempBuffer->pszBuffer, szNumber);
								strcat(pTempBuffer->pszBuffer, "_");
							} // end catch (all)
						} // end else (a valid string pointer)
					} // end if (valid token)
				  break;

				case 'S':
					WCHAR*	pwszString;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%S") == 0)
					{
						pwszString = (WCHAR*) (apvParms[dwParm++]);

						if (pwszString == NULL)
						{
							// Commented out because we know it will be large enough....
							//
							// Make sure the buffer is large enough for
							// "_NULL-string_"
							//ENSUREBUFFERLENGTH(pTempBuffer, 13);
							strcpy(pTempBuffer->pszBuffer, "_NULL-string_");
						} // end if (it's a NULL string)
						else
						{
							// Make sure it's a valid string.
							try
							{
								// Size is in bytes...
								dwSize = WideCharToMultiByte(CP_ACP, 0, pwszString, -1,
															NULL, 0, NULL, NULL);
								if (dwSize != 0)
								{
									// Make sure the buffer is large enough.
									ENSUREBUFFERLENGTH(pTempBuffer, dwSize);

									// Ignoring error
									WideCharToMultiByte(CP_ACP, 0, pwszString, -1,
														pTempBuffer->pszBuffer,
														(pTempBuffer->dwBufferSize * sizeof (char)),
														NULL, NULL);
								} // end if (there's a valid size)
							} // end try
							catch (...)
							{
								wsprintfA(szNumber, "0x" SPRINTF_PTR, pwszString);

								// Commented out because we know it will be large enough....
								//
								// Make sure the buffer is large enough.
								//ENSUREBUFFERLENGTH(pTempBuffer, strlen(szNumber) + strlen("_invalid-string-_"));

								strcpy(pTempBuffer->pszBuffer, "_invalid-string-");
								strcat(pTempBuffer->pszBuffer, szNumber);
								strcat(pTempBuffer->pszBuffer, "_");
							} // end catch (all)
						} // end else (a valid string pointer)
					} // end if (valid token)
				  break;

				case 't':
					DWORD_PTR			dwFlags;
					PTNFLAGTABLEITEM	paFlagTable;
					DWORD_PTR			dwNumFlagsInTable;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%t") == 0)
					{
						dwFlags = (DWORD_PTR) apvParms[dwParm++];

						if (dwParm < dwNumParms)
						{
							paFlagTable = (PTNFLAGTABLEITEM) apvParms[dwParm++];

							if (dwParm < dwNumParms)
							{
								dwNumFlagsInTable = (DWORD_PTR) apvParms[dwParm++];

								// Ignore error, assumer BUFFER_TOO_SMALL.
								StringAddFlags(dwFlags, paFlagTable, dwNumFlagsInTable,
												NULL, &dwSize);

								// Make sure the buffer is large enough to hold the
								// expand flags string
								ENSUREBUFFERLENGTH(pTempBuffer, dwSize);

								// Make sure the string is empty.
								pTempBuffer->pszBuffer[0] = '\0';

								// Ignore error
								StringAddFlags(dwFlags, paFlagTable, dwNumFlagsInTable,
												pTempBuffer->pszBuffer, &dwSize);
							} // end if (there's at least one more parameter in the array)
						} // end if (there's at least one more parameter in the array)
					} // end if (valid token)
				  break;

				case 'v':
					PVOID	pvData;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%v") == 0)
					{
						pvData = apvParms[dwParm++];

						if (dwParm < dwNumParms)
						{
							dwSize = (DWORD)(DWORD_PTR) apvParms[dwParm++];

							// Make sure the buffer is large enough.  Each byte
							// expands to 3 characters except the last one.
							ENSUREBUFFERLENGTH(pTempBuffer, (dwSize * 3) - 1);

							StringBufferToHexStr(pvData, dwSize, pTempBuffer->pszBuffer);
						} // end if (there's at least one more parameter in the array)
					} // end if (valid token)
				  break;
				  
				case 'x':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%x") == 0)
					{
						// Commented out because we know it will be large enough....
						//
						// Make sure the buffer is large enough for "0xFFFFFFFF".
						//ENSUREBUFFERLENGTH(pTempBuffer, 10);

						wsprintfA(pTempBuffer->pszBuffer, "0x" SPRINTF_PTR, apvParms[dwParm++]);
					} // end if (valid token)
				  break;

#ifndef _XBOX // not supporting symbol lookup
#if ((defined (TNCOMMON_EXPORTS)) || (defined (USE_SPRINTF_SYMBOLLOOKUP)))
				case 'X':
					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%X") == 0)
					{
// Unfortunately can't use the pragmas, because debugprint.h isn't (and can't be)
// included.
//#pragma BUGBUG(vanceo, "Be able to resize to use a large enough buffer")

						// Ignore error
						TNSymResolve(apvParms[dwParm++], pTempBuffer->pszBuffer, 
									(pTempBuffer->dwBufferSize * sizeof (char)));
					} // end if (valid token)
				  break;
#endif // TNCOMMON_EXPORTS or USE_SPRINTF_SYMBOLLOOKUP
#else // ! XBOX
//#pragma BUGBUG(tristanj, "May need to come up with an alternative for symbol lookup")
#endif // XBOX

				case 'z':
					char*	pszData;


					// If we didn't get a garbage token, convert it.  Otherwise
					// we'll abort the token string and dump what we have.
					fInToken = FALSE;
					if (strcmp(pTempBuffer->pszBuffer, "%z") == 0)
					{
						pszData = (char*) apvParms[dwParm++];

						if (dwParm < dwNumParms)
						{
							dwSize = (DWORD)(DWORD_PTR) apvParms[dwParm++];

							// Make sure the buffer is large enough for "0xFFFFFFFF".
							ENSUREBUFFERLENGTH(pTempBuffer, dwSize);

							CopyMemory(pTempBuffer->pszBuffer, pszData, (dwSize * sizeof (char)));
							pTempBuffer->pszBuffer[dwSize] = 0; // NULL terminate the string
						} // end if (there's at least one more parameter in the array)
					} // end if (valid token)
				  break;

				default:
					// Unrecognized token string, abort this token string, and
					// dump what we have.
					fInToken = FALSE;
				  break;
			} // end switch (on the current token character)
		} // end if (in a token)
		else
		{
			if (szFormatString[i] == '%')
			{
// Unfortunately can't use the pragmas, because debugprint.h isn't (and can't be)
// included.
//#pragma BUGBUG(vanceo, "What about possible tokens which don't require parms?")

				// Only parse special tokens if there are more parameters in the array
				if (dwParm < dwNumParms)
				{
					fInToken = TRUE;
					fNumbersNotAllowed = FALSE;
					fDashesNotAllowed = FALSE;
					fPeriodsNotAllowed = FALSE;
					dwCurrentTempIndex++;
				} // end if (there are still parms left in the string)
			} // end if (we're now in a token)
		} // end else (not in a token)

		i++; // move to next character

		// If we're not currently in a token or we've hit the end of the string,
		// dump what we have
		if ((! fInToken) || (szFormatString[i] == 0))
		{
			dwCurrentTempIndex = 0; // go back to the beginning
				  

			// If the buffer we're returning can't hold this latest string, increase
			// it so it does room.
			ENSUREBUFFERLENGTH(pBuffer, (dwUsedOutputLength + strlen(pTempBuffer->pszBuffer)));

			// Tack the current bit onto the end.
			strcpy((pBuffer->pszBuffer + dwUsedOutputLength), pTempBuffer->pszBuffer);
			dwUsedOutputLength += strlen(pTempBuffer->pszBuffer);
		} // end if (we're not in a token)
	} // end while (we're not at the end of the string)


DONE:

	if (pvTemp != NULL)
	{
		LocalFree(pvTemp);
		pvTemp = NULL;
	} // end if (still have memory)

	// If have temp buffer, return it to the pool.
	if (pTempBuffer != NULL)
	{
		EnterCriticalSection(&g_csBuffersLock);
		pTempBuffer->pNextBuffer = g_pFirstTNsprintfBufferInPool;
		g_pFirstTNsprintfBufferInPool = pTempBuffer;
		LeaveCriticalSection(&g_csBuffersLock);
	} // end if (have item )

	// If have buffer for user, put it on the outstanding list and return it to the
	// user.
	if (pBuffer != NULL)
	{
		EnterCriticalSection(&g_csBuffersLock);
		pBuffer->pNextBuffer = g_pFirstTNsprintfBufferInOutstandingList;
		g_pFirstTNsprintfBufferInOutstandingList = pBuffer;
		LeaveCriticalSection(&g_csBuffersLock);

		(*ppszOutput) = pBuffer->pszBuffer;
	} // end if (have item )

	return;

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#undef ENSURETEMPBUFFERLENGTH
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
} // TNsprintf_array
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


// Restore the previous warning settings
#pragma warning( pop ) 







#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNsprintf_free()"
//==================================================================================
// TNsprintf_free
//----------------------------------------------------------------------------------
//
// Description: Releases the memory allocated by a call to TNsprintf.
//
//
// Arguments:
//	char** ppszBuffer	Pointer to pointer retrieved by previous call to TNsprintf.
//
// Returns: None.
//==================================================================================
void TNsprintf_free(char** ppszBuffer)
{
	PTNSPRINTFBUFFER	pLastBuffer = NULL;
	PTNSPRINTFBUFFER	pBuffer;
	char				szNumber[32];


	if ((*ppszBuffer) == NULL)
		return;


	EnterCriticalSection(&g_csBuffersLock);

	pBuffer = g_pFirstTNsprintfBufferInOutstandingList;
	while (pBuffer != NULL)
	{
		// Is this the buffer corresponding to the string we gave them?
		if (pBuffer->pszBuffer == (*ppszBuffer))
		{
			// Yes, so pull it out of the list...
			if (pLastBuffer != NULL)
				pLastBuffer->pNextBuffer = pBuffer->pNextBuffer;
			else
				g_pFirstTNsprintfBufferInOutstandingList = pBuffer->pNextBuffer;

			// ...and place it back in the pool.
			pBuffer->pNextBuffer = g_pFirstTNsprintfBufferInPool;
			g_pFirstTNsprintfBufferInPool = pBuffer;

			LeaveCriticalSection(&g_csBuffersLock);

			return;
		} // end if (found buffer)

		pLastBuffer = pBuffer;
		pBuffer = pBuffer->pNextBuffer;
	} // end while (haven't hit end of list)

	LeaveCriticalSection(&g_csBuffersLock);


	// If we got here, we didn't find the corresponding buffer in our outstanding
	// list.

#ifdef DEBUG
	wsprintf(szNumber, "0x" SPRINTF_PTR, (*ppszBuffer));
	OutputDebugString("Didn't find TNsprintf buffer ");
	OutputDebugString(szNumber);
	OutputDebugString(" (\"");
	OutputDebugString((*ppszBuffer));

#ifdef _X86_
	OutputDebugString("\") in outstanding buffers list!  int 3-ing.\n");
	{_asm int 3};
#else // _X86_
	OutputDebugString("\") in outstanding buffers list!  DebugBreak()-ing.\n");
	DebugBreak();
#endif // _X86_

#endif // DEBUG
} // TNsprintf_free
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\sources.inc ===
!IF 0

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tncommon

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Tristan Jackson (tristanj)

!ENDIF

TARGETTYPE=DYNLINK
TARGETPATH=$(BASEDIR)\private\test\directx\dplay\testnet\bins

DLLENTRY=_DllMainCRTStartup

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DTNCOMMON_EXPORTS -DXBOX -DNO_ERRORS_DVOICE -DNO_SPRINTF_DPLAY8 -DNO_SPRINTF_DVOICE -DNO_SPRINTF_REGISTRY -DNO_CPPOBJHELP_LEAKCHECK -DNO_TNCOMMON_DEBUG_SPEW -DNO_ERRORS_DPLAY -DNO_ERRORS_DPLAY8


INCLUDES= \
        $(INCLUDES); \
        $(BASEDIR)\private\test\directx\dplay\testnet\tncontrl; \
        $(BASEDIR)\private\test\directx\dplay\testnet\tncommon; \
        $(BASEDIR)\private\windows\directx\dplay\inc; \
        $(BASEDIR)\private\test\inc; \

SOURCES=\
        ..\tncommon.rc    \
        ..\excptns.cpp    \
        ..\linkedstr.cpp  \
        ..\linklist.cpp   \
        ..\main.cpp       \
        ..\strutils.cpp   \
        ..\text.cpp       \
        ..\verutils.cpp   \
        ..\errors.cpp     \
        ..\cmdline.cpp    \
        ..\cppobjhelp.cpp \
        ..\stack.cpp      \
        ..\sprintf.cpp    \
        ..\symbols.cpp    \
        ..\debugprint.cpp \
        ..\fileutils.cpp  \
        ..\convhelp.cpp   \
        ..\crc32.c        \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\symbols.h ===
#ifndef __TNSYMBOLS__
#define __TNSYMBOLS__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// You tried to use a TNSym function before successfully calling TNSymInitialize
#define TNSYMERR_UNINITIALIZED		0x88770140 // DPERR_UNINITIALIZED










//==================================================================================
// External Prototypes
//==================================================================================
DLLEXPORT HRESULT TNSymInitialize(void);

DLLEXPORT HRESULT TNSymCleanup(void);

DLLEXPORT HRESULT TNSymSetOptions(BOOL fResolveUndecorated);

DLLEXPORT HRESULT TNSymResolve(PVOID pvPointer, char* szString, DWORD dwStringSize);

DLLEXPORT HRESULT TNSymLoadSymbolsForModules(char* szModulesList);

DLLEXPORT HRESULT TNSymGetModuleNameAndOffsetForPointer(PVOID pvPointer,
														char* pszName,
														DWORD dwNameSize,
														PDWORD_PTR pdwOffset);

DLLEXPORT BOOL TNSymGetDisableSymResolutionSetting(void);

DLLEXPORT void TNSymSetDisableSymResolutionSetting(BOOL fDisable);






#endif // __TNSYMBOLS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\text.h ===
#ifndef _XBOX // no window logging supported
//--------------------------------------------------------------------------;
//
//  File: Text.h
//
//  Copyright (c) 1994 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//
//
//  History:
//      08/28/94    Fwong       Created.
//      10/20/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

//BEGIN vanceo
//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined
//END vanceo


//==========================================================================;
//
//                             Messages...
//
//==========================================================================;

#define TM_DELETETEXT       WM_USER + 1
#define TM_SETSIZELIMIT     WM_USER + 2
#define TM_GETSIZELIMIT     WM_USER + 3
#define TM_SEARCH           WM_USER + 4
#define TM_SETNUMCOLORS     WM_USER + 5
#define TM_GETNUMCOLORS     WM_USER + 6
#define TM_SETCOLOR         WM_USER + 7
#define TM_GETCOLOR         WM_USER + 8


//==========================================================================;
//
//                               Flags...
//
//==========================================================================;

#define SETSIZEFLAG_TRUNCATE    0x0001
#define SEARCHFLAG_MATCHCASE    0x0001
#define TEXTCOLOR_DEFAULT       0x00

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define Text_Copy(hWnd)             SendMessage(hWnd,WM_COPY,0,0L)
#define Text_Delete(hWnd)           SendMessage(hWnd,TM_DELETETEXT,0,0L)
#define Text_GetBufferLimit(hWnd)   SendMessage(hWnd,TM_GETSIZELIMIT,0,0L)

#define Text_SetBufferLimit(hWnd,cbSize,uFlags)  \
            SendMessage(hWnd,TM_SETSIZELIMIT,(WPARAM)(uFlags),(LPARAM)(cbSize))

#define Text_SearchString(hWnd,pszString,uFlags)  \
            (BOOL)(SendMessage(hWnd,TM_SEARCH,(WPARAM)(uFlags), \
            (LPARAM)(LPSTR)(pszString)))

#define Text_SetNumColors(hWnd,uCount)  \
            (BOOL)(SendMessage(hWnd,TM_SETNUMCOLORS,(WPARAM)(uCount),0L))

#define Text_GetNumColors(hWnd)     SendMessage(hWnd,TM_GETNUMCOLORS,0,0L)

#define Text_SetColor(hWnd,id,cr)  \
            SendMessage(hWnd,TM_SETCOLOR,(WPARAM)id,(LPARAM)cr)

#define Text_GetColor(hWnd,id)  \
            (COLORREF)(SendMessage(hWnd,TM_GETCOLOR,(WPARAM)id,0L))

#define TextOutputString(a,b)       TextOutputStringColor(a,0,b)

//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

DLLEXPORT BOOL TextInit
(
    HINSTANCE   hInstance
);

DLLEXPORT void TextEnd
(
    HINSTANCE   hInstance
);

DLLEXPORT HWND TextCreateWindow
(
    DWORD       dwStyle,
    int         x,
    int         y,
    int         nWidth,
    int         nHeight,
    HWND        hWndParent,
    HMENU       hMenu,
    HINSTANCE   hInstance
);

DLLEXPORT void TextOutputStringColor
(
    HWND    hWnd,
    UINT    uColor,
    LPSTR   pText
);

DLLEXPORT int _cdecl TextPrintf
(
    HWND    hWnd,
    LPSTR   pszFormat,
    ...
);

DLLEXPORT int _cdecl TextPrintfColor
(
    HWND    hWnd,
    UINT    uColor,
    LPSTR   pszFormat,
    ...
);

DLLEXPORT LRESULT TextFocusProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
);
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\stack.h ===
#ifndef __TNSTACK__
#define __TNSTACK__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined







//==================================================================================
// External Structures
//==================================================================================
typedef struct tagTNGETSTACKDATA
{
	DWORD	dwSize; // size of this structure, must be filled in prior to calling the function

	BOOL	fCallStack; // whether to display the call stack (using "StackWalk()") 
	PVOID	pvIgnoreCallsAboveFunction; // pointer to function that represents the top most valid function to list

	DWORD	dwRawStackDepth; // how many entries to display off the raw stack, or 0 for none
} TNGETSTACKDATA, * PTNGETSTACKDATA;




//==================================================================================
// Typedef for macro
//==================================================================================
typedef void (__stdcall * RTLGETCALLERSADDRESSPROC)		(PVOID*, PVOID*);




//==================================================================================
// External Prototypes
//==================================================================================
DLLEXPORT HRESULT TNStackGetStackForCurrentThread(PTNGETSTACKDATA pGetStackData);

DLLEXPORT RTLGETCALLERSADDRESSPROC TNStackGetRGCAProc(void); // see symbols.h for definition





//==================================================================================
// External Macro
//==================================================================================
#define TNStackGetCallersAddress(ppvCallersAddress, ppvCallersCaller)\
											{\
												RTLGETCALLERSADDRESSPROC	pfnRtlGetCallersAddress;\
												\
												pfnRtlGetCallersAddress = TNStackGetRGCAProc();\
												pfnRtlGetCallersAddress(ppvCallersAddress, ppvCallersCaller);\
											}




#endif // __TNSTACK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\text.cpp ===
#ifndef _XBOX // no window logging supported
//--------------------------------------------------------------------------;
//
//  File: Text.c
//
//  Copyright (c) 1994 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      TextInit()
//      TextEnd()
//      TextCreateWindow()
//      lstrLineLen()
//      GetTextLines()
//      NewBuffer()
//      TextOutputStringColor()
//      TextPrintf()
//      TextPrintfColor()
//      PropagateDraw()
//      DeleteText()
//      GetTextSizeLimit()
//      SetTextSizeLimit()
//      GotoTextLine()
//      SetNumColors()
//      GetNumColors()
//      SetColor()
//      GetColor()
//      TextSearch()
//      TextCopy()
//      DrawVScroll()
//      TextUp()
//      TextDown()
//      TextCreate()
//      TextPaint()
//      TextSetFont()
//      TextGetFont()
//      TextClose()
//      TextVScroll()
//      TextHScroll()
//      TextSize()
//      TextSetRedraw()
//      TextColorChange()
//      TextLButtonDown()
//      TextLButtonUp()
//      TextMouseMove()
//      TextKey()
//      TextFocusProc()
//      TextWndProc()
//
//  History:
//      05/27/94    Fwong       Created for Wave Watcher project.
//      10/23/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <windowsx.h>
#include "text.h"
//vanceo
//#include "debug.h"


//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define TEXT_BUFFER_SIZE     4096
#define VSCROLL_RANGE        1000

#define TM_PROPAGATE         WM_USER

#define TEXTFLAG_END         0x00000001
#define TEXTFLAG_REDRAW      0x00000002
#define TEXTFLAG_SELECT      0x00000004
#define TEXTFLAG_CLICK       0x00000008
#define TEXTFLAG_SCROLLUP    0x00000010
#define TEXTFLAG_SCROLLDOWN  0x00000020
#define TEXTFLAG_SCROLLLEFT  0x00000040
#define TEXTFLAG_SCROLLRIGHT 0x00000080
#define TEXTFLAG_SCROLL      0x00000100

#define TEXTFLAG_DIRMASK     0x000000f0

#define TEXTKEY_SHIFT        0x00000001
#define TEXTKEY_CONTROL      0x00000002

//==========================================================================;
//
//                         Portability Stuff...
//
//==========================================================================;

#define EXPORT


//==========================================================================;
//
//                               Types...
//
//==========================================================================;

#ifndef LPUINT
typedef UINT FAR*           LPUINT;
#endif

typedef BYTE                INDEX;
typedef INDEX FAR*          LPINDEX;
#define MAX_COLORS          256

//==========================================================================;
//
//                            Structures...
//
//==========================================================================;

typedef struct textbuffer_tag
{
    UINT                        uLines;
    UINT                        uOffset;
    struct textbuffer_tag FAR   *pPrev;
    struct textbuffer_tag FAR   *pNext;
    LPSTR                       pText;
} TEXTBUFFER;
typedef TEXTBUFFER       *PTEXTBUFFER;
typedef TEXTBUFFER NEAR *NPTEXTBUFFER;
typedef TEXTBUFFER FAR  *LPTEXTBUFFER;

typedef struct location_tag
{
    DWORD   dwRow;
    UINT    uCol;
} LOCATION;
typedef LOCATION       *PLOCATION;
typedef LOCATION NEAR *NPLOCATION;
typedef LOCATION FAR  *LPLOCATION;

typedef struct textwindowinfo_tag
{
    DWORD           dwLines;
    DWORD           dwCurLine;
    DWORD           dwScroll;
    LPTEXTBUFFER    ptbFirst;
    LPTEXTBUFFER    ptbLast;
    DWORD           fdwFlags;
    LOCATION        locStart;
    LOCATION        locEnd;
    UINT            uBuffers;
    UINT            uCurCol;
    UINT            uMaxBuffers;
    UINT            uTextHeight;
    UINT            uTextWidth;
    HFONT           hFont;
    UINT            uNumColors;
    COLORREF        crHiLiteBackGnd;
    COLORREF        crHiLiteText;
    COLORREF        crBackGnd;
    COLORREF        crText[1];
} TEXTWINDOWINFO, *PTEXTWINDOWINFO;

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define CLEAR_FLAG(dw,flag) (dw &= (~(flag)))
#define SET_FLAG(dw,flag)   (dw |= (flag))

//==========================================================================;
//
//                              Globals...
//
//==========================================================================;

char    szTextClassName[] = "TextWindowClass";

//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

LRESULT CALLBACK EXPORT TextWndProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
);

//==========================================================================;
//
//                             Functions...
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  BOOL TextInit
//
//  Description:
//      Initializes Text window class.
//
//  Arguments:
//      HINSTANCE hinst: Handle to instance of application.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      07/02/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

BOOL TextInit
(
    HINSTANCE   hInstance
)
{
    WNDCLASS    wc;

    //
    //  Registering window class.
    //

    wc.style          = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = sizeof(PTEXTWINDOWINFO);
    wc.hInstance      = hInstance;
    wc.lpfnWndProc    = TextWndProc;
    wc.hIcon          = NULL;
    wc.hCursor        = LoadCursor(NULL,IDC_IBEAM);
    wc.hbrBackground  = NULL;
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = szTextClassName;
    
    if(!RegisterClass(&wc))
    {
        return FALSE;
    }

    return TRUE;
} // TextInit()


//--------------------------------------------------------------------------;
//
//  void TextEnd
//
//  Description:
//      Undoes things done by InitText.
//
//  Arguments:
//      HINSTANCE hinst: Handle to instance of application.
//
//  Return (void):
//
//  History:
//      07/02/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

void TextEnd
(
    HINSTANCE   hInstance
)
{
    UnregisterClass(szTextClassName,hInstance);
} // TextEnd()


//--------------------------------------------------------------------------;
//
//  HWND TextCreateWindow
//
//  Description:
//      Creates a Text Window
//
//  Arguments:
//      DWORD dwStyle: Window Style.
//
//      int x: X position of window.
//
//      int y: Y position of window.
//
//      int nWidth: Width of window.
//
//      int nHeight: Height of window.
//
//      HWND hWndParent: Handle to parent window.
//
//      HMENU hMenu: Handle to Menu.
//
//      HINSTANCE hInstance: Handle to instance.
//
//  Return (HWND):
//      Handle to window if successful, NULL otherwise.
//
//  History:
//      07/10/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

HWND TextCreateWindow
(
    DWORD       dwStyle,
    int         x,
    int         y,
    int         nWidth,
    int         nHeight,
    HWND        hWndParent,
    HMENU       hMenu,
    HINSTANCE   hInstance
)
{
    HWND                hWnd;
    HDC                 hDC;
    HFONT               hFont;
    TEXTMETRIC          tm;
    PTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;

    //  Allocating memory for TEXTWINDOWINFO
    ptwi = (PTEXTWINDOWINFO)LocalAlloc(LPTR, sizeof(TEXTWINDOWINFO) + sizeof(COLORREF));

    ptwi->dwLines         = 0;
    ptwi->dwCurLine       = 0L;
    ptwi->dwScroll        = 0L;
    ptwi->uCurCol         = 0;
    ptwi->fdwFlags        = TEXTFLAG_END;
    ptwi->uBuffers        = 1;
    ptwi->uMaxBuffers     = (UINT)(-1);
    ptwi->uNumColors      = 1;
    ptwi->hFont           = GetStockFont(ANSI_FIXED_FONT);
    ptwi->crHiLiteBackGnd = GetSysColor(COLOR_HIGHLIGHT);
    ptwi->crHiLiteText    = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ptwi->crBackGnd       = GetSysColor(COLOR_WINDOW);
    ptwi->crText[0]       = GetSysColor(COLOR_WINDOWTEXT);

    ptwi->locStart.dwRow  = 0L;
    ptwi->locStart.uCol   = 0;
    ptwi->locEnd.dwRow    = 0L;
    ptwi->locEnd.uCol     = 0;

    //  Allocating memory for TEXTBUFFER
    ptb = (LPTEXTBUFFER)LocalAlloc(LPTR, sizeof(TEXTBUFFER));
    if(NULL == ptb)
    {
        LocalFree(ptwi);
        return NULL;
    }

    ptwi->ptbFirst = ptb;
    ptwi->ptbLast  = ptb;

    ptb->uLines  = 0;
    ptb->uOffset = 0;
    ptb->pPrev   = ptb;
    ptb->pNext   = ptb;

    //  Allocating memory for text
    ptb->pText = (LPSTR)LocalAlloc(LPTR, TEXT_BUFFER_SIZE);
    if(NULL == ptb->pText)
    {
        LocalFree(ptb);
        LocalFree(ptwi);
        return NULL;
    }

    //
    //  Creating window...
    //
    //  Note: Pointer to TEXTWINDOWINFO structure is passed and later
    //        stored in the "extra" bytes for the window in WM_CREATE
    //        processing.

    hWnd = 
        CreateWindow
        (
            szTextClassName,
            "",
            dwStyle,
            x,
            y,
            nWidth,
            nHeight,
            hWndParent,
            hMenu,
            hInstance,
            ptwi
        );

    //
    //  Disabling scroll bars...
    //

    SetScrollRange(hWnd,SB_VERT,0,0,TRUE);
    SetScrollRange(hWnd,SB_HORZ,0,0,TRUE);

    hDC   = GetDC(hWnd);
    hFont = SelectFont(hDC,ptwi->hFont);

    GetTextMetrics(hDC,&tm);
    ptwi->uTextHeight = tm.tmHeight + tm.tmExternalLeading;
    ptwi->uTextWidth  = tm.tmAveCharWidth;

    SelectFont(hDC,hFont);
    ReleaseDC(hWnd,hDC);

    return hWnd;
} // TextCreateWindow()


//--------------------------------------------------------------------------;
//
//  int lstrLineLen
//
//  Description:
//      Gets the length of a zero, '\r' or '\n' terminated string.
//
//  Arguments:
//      LPSTR pszStr: Pointer to character string.
//
//  Return (int):
//      Size (in characters) of string.
//
//  History:
//      10/17/94    Fwong       Support function.
//
//--------------------------------------------------------------------------;

int lstrLineLen
(
    LPSTR   pszStr
)
{
    int     i;
    char    c;

    for(i=0;;i++,pszStr++)
    {
        c = *pszStr;

        if(('\n' == c) || ('\r' == c) || (0 == c))
        {
            return i;
        }
    }
} // lstrLineLen()


//--------------------------------------------------------------------------;
//
//  UINT GetTextLines
//
//  Description:
//      Gets the number of lines displayable in current window.
//
//  Arguments:
//      HWND hWnd:  Window Handle.
//
//  Return (UINT):
//      Number of lines that current window can hold.
//
//  History:
//      10/17/94    Fwong       Support function.
//
//--------------------------------------------------------------------------;

UINT GetTextLines
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;
    RECT                r;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    GetClientRect(hWnd,&r);

    return (UINT)(r.bottom / ptwi->uTextHeight);
} // GetTextLines()


//--------------------------------------------------------------------------;
//
//  LPTEXTBUFFER NewBuffer
//
//  Description:
//      Allocates or recycles buffer for output.
//
//  Arguments:
//      PTEXTWINDOWINFO ptwi: Pointer to TEXTWINDOWINFO.
//
//  Return (LPTEXTBUFFER):
//      Pointer to "new" TEXTBUFFER.
//
//  History:
//      07/02/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

LPTEXTBUFFER NewBuffer
(
    HWND    hWnd
)
{
    LPTEXTBUFFER        ptb;
    PTEXTWINDOWINFO    ptwi;


    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    //
    //  Have we reached our maximum number of buffers?
    //

    if(ptwi->uBuffers < ptwi->uMaxBuffers)
    {
        //  Allocating memory for new buffer...
        ptb = (LPTEXTBUFFER)LocalAlloc(LPTR, sizeof(TEXTWINDOWINFO));
        if(NULL != ptb)
        {
            //  Memory allocation successful; let's initialize.
            ptb->uLines   = 0;
            ptb->uOffset  = 0;
            ptb->pPrev    = ptwi->ptbLast;
            ptb->pNext    = ptwi->ptbFirst;

            //
            //  Allocating memory for text.
            //

            ptb->pText = (LPSTR)LocalAlloc(LPTR, TEXT_BUFFER_SIZE);
            if(NULL != ptb->pText)
            {
                //  Memory allocation successful; let's finish up and return
                ptwi->ptbLast->pNext  = ptb;
                ptwi->ptbFirst->pPrev = ptb;
                ptwi->ptbLast         = ptb;
                ptwi->uBuffers++;

                return ptb;
            }
            else
            {
                //  Second allocation unsuccessful; clean up first buffer
                //  recycle first buffer.
                LocalFree(ptb);
            }
        }
    }

    //
    //  Okay... we're recycling buffers...
    //  Note: This is _assuming_ we have more than one buffer.
    //

    ptb = ptwi->ptbFirst;

    ptwi->ptbFirst = ptwi->ptbFirst->pNext;
    ptwi->ptbLast  = ptwi->ptbLast->pNext;

    ptwi->dwLines -= (ptb->uLines);

    if(!(ptwi->fdwFlags & TEXTFLAG_END))
    {
        if(ptwi->dwCurLine < ptb->uLines)
        {
            ptwi->dwCurLine  = 0;
        }
        else
        {
            ptwi->dwCurLine -= ptb->uLines;
        }
    }

    if(ptwi->fdwFlags & TEXTFLAG_SELECT)
    {
        if(ptwi->locEnd.dwRow < ptb->uLines)
        {
            ptwi->locEnd.dwRow = 0;
            ptwi->locEnd.uCol  = 0;
        }
        else
        {
            ptwi->locEnd.dwRow -= ptb->uLines;
        }

        if(ptwi->locStart.dwRow < ptb->uLines)
        {
            ptwi->locStart.dwRow = 0;
            ptwi->locStart.uCol  = 0;
        }
        else
        {
            ptwi->locStart.dwRow -= ptb->uLines;
        }
    }

    ptb->uLines   = 0;
    ptb->uOffset  = 0;

    return ptb;
} // NewBuffer()


//--------------------------------------------------------------------------;
//
//  void TextOutputStringColor
//
//  Description:
//      Outputs raw string into Text Window.
//
//  Arguments:
//      HWND hWnd: Handle to Text Window.
//
//      UINT uColor: Color index into palette.
//
//      LPSTR pszText: String to output.
//
//  Return (void):
//
//  History:
//      10/17/94    Fwong       "Exported" function.
//      10/23/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

void TextOutputStringColor
(
    HWND    hWnd,
    UINT    uColor,
    LPSTR   pszText
)
{
    int                 i;
    PTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    UINT                uLines;
    RECT                r;



    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

	//BEGIN vanceo
	if (ptwi == NULL)
	{
		//DPL(0, "Couldn't get data pointer from window handle %x!", 1, hWnd);
		OutputDebugString("TNCOMMON: TextOutputStringColor(): Couldn't get data pointer from window handle!\n");
		return;
	} // end if (couldn't get data)
	//END vanceo


    ptb = ptwi->ptbLast;

    for(;;)
    {
        i = lstrLineLen(pszText);

        if(TEXT_BUFFER_SIZE < (ptb->uOffset + i + 1 + sizeof(INDEX)))
        {
            ptb = NewBuffer(hWnd);
        }

        ptwi->dwLines++;
        ptb->uLines++;
        ptwi->dwScroll++;

        //
        //  Adding color support.
        //

        *(LPINDEX)(&ptb->pText[ptb->uOffset]) = (INDEX)uColor;

        //
        //  Offsetting pointer by color index; accounting for '\0' on size.
        //

        lstrcpyn((LPSTR)(&(ptb->pText[ptb->uOffset + sizeof(INDEX)])),
                 pszText,
                 i + 1);

        ptb->uOffset += (i + 1 + sizeof(INDEX));
        pszText += (i);

        if(0 == *pszText)
        {
            break;
        }

        if('\r' == *pszText)
        {
            pszText++;
        }

        if('\n' == *pszText)
        {
            pszText++;
        }
    }

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        if(ptwi->fdwFlags & TEXTFLAG_REDRAW)
        {
            GetClientRect(hWnd,&r);

            uLines = (UINT)ptwi->dwScroll;
            ptwi->dwScroll = 0L;

            if(ptwi->dwLines <= (r.bottom / ptwi->uTextHeight))
            {
                r.top    = (int)((ptwi->dwLines - (DWORD)uLines) *
                        ptwi->uTextHeight);

                r.bottom = r.top + uLines * ptwi->uTextHeight;

                InvalidateRect(hWnd,&r,FALSE);
            }
            else
            {
                uLines  *= ptwi->uTextHeight;

                r.bottom = r.bottom - r.bottom % ptwi->uTextHeight;
                r.top    = uLines;

                ScrollWindow(hWnd,0,(-1)*uLines,&r,NULL);
            }

            UpdateWindow(hWnd);
        }
        else
        {
            if(!(ptwi->fdwFlags & TEXTFLAG_SCROLL))
            {
                SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLL);
                PostMessage(hWnd,TM_PROPAGATE,0,0L);
            }
        }
    }
} // TextOutputStringColor()


//--------------------------------------------------------------------------;
//
//  int TextPrintf
//
//  Description:
//      Equivalent to printf, but goes to window.  Note there is a 250
//          character limit.  Bump up if needed.
//
//  Arguments:
//      HWND hWnd: Handle to Text window.
//
//      LPSTR pszFormat: Pointer to format string.
//
//  Return (int):
//      Number of characters outputted.
//
//  History:
//      10/25/94    Fwong       Printf-like output function.
//
//--------------------------------------------------------------------------;

int _cdecl TextPrintf
(
    HWND    hWnd,
    LPSTR   pszFormat,
    ...
)
{
    char    szOutput[250];
    va_list va;
    int     cch;

    va_start(va,pszFormat);
    cch = wvsprintf(szOutput,pszFormat,va);
    va_end(va);

    TextOutputStringColor(hWnd,TEXTCOLOR_DEFAULT,szOutput);

    return cch;
} // TextPrintf()


//--------------------------------------------------------------------------;
//
//  int TextPrintfColor
//
//  Description:
//      Equivalent to printf, but goes to window.  Note there is a 250
//          character limit.  Bump up if needed.
//
//  Arguments:
//      HWND hWnd: Handle to Text window.
//
//      UINT uColor: Index to color palette.
//
//      LPSTR pszFormat: Pointer to format string.
//
//  Return (int):
//      Number of characters outputted.
//
//  History:
//      10/20/95    Fwong       Printf-like output function.
//
//--------------------------------------------------------------------------;

int _cdecl TextPrintfColor
(
    HWND    hWnd,
    UINT    uColor,
    LPSTR   pszFormat,
    ...
)
{
    char    szOutput[250];
    va_list va;
    int     cch;

    va_start(va,pszFormat);
    cch = wvsprintf(szOutput,pszFormat,va);
    va_end(va);

    TextOutputStringColor(hWnd,uColor,szOutput);

    return cch;
} // TextPrintf()


//--------------------------------------------------------------------------;
//
//  void PropagateDraw
//
//  Description:
//      Internal message to do defered scrolling.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/95    Fwong       Retroactive commenting.
//
//--------------------------------------------------------------------------;

void PropagateDraw
(
    HWND    hWnd
)
{
    RECT                r;
    UINT                uLines;
    PTEXTWINDOWINFO    ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    GetClientRect(hWnd,&r);

    uLines = r.bottom / ptwi->uTextHeight;

    if(ptwi->dwScroll > (DWORD)uLines)
    {
        InvalidateRect(hWnd,NULL,FALSE);
        UpdateWindow(hWnd);
    }

    uLines = (UINT)ptwi->dwScroll;
    ptwi->dwScroll = 0L;

    if(ptwi->dwLines <= (r.bottom / ptwi->uTextHeight))
    {
        r.top    = (int)((ptwi->dwLines - (DWORD)uLines) * ptwi->uTextHeight);
        r.bottom = r.top + uLines * ptwi->uTextHeight;

        InvalidateRect(hWnd,&r,FALSE);
    }
    else
    {
        uLines  *= ptwi->uTextHeight;

        r.bottom = r.bottom - r.bottom % ptwi->uTextHeight;
        r.top    = uLines;

        ScrollWindow(hWnd,0,(-1)*uLines,&r,NULL);
    }

    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLL);
    UpdateWindow(hWnd);
} // PropagateDraw()


//--------------------------------------------------------------------------;
//
//  void DeleteText
//
//  Description:
//      Clears window of text.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Adding functionality to clear the screen.
//
//--------------------------------------------------------------------------;

void DeleteText
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO ptwi;
    LPTEXTBUFFER    ptb;
    LPTEXTBUFFER    ptb2;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    if(ptwi->ptbLast != ptwi->ptbFirst)
    {
        ptwi->ptbLast->pNext = NULL;

        //  Free memory for all but first TEXTBUFFER...
        ptb = ptwi->ptbFirst->pNext;
        while(ptb)
        {
            ptb2 = ptb->pNext;
            LocalFree(ptb->pText);
            LocalFree(ptb);

            ptb = ptb2;
        }
    }

    ptwi->dwLines   = 0;
    ptwi->dwCurLine = 0L;
    ptwi->uBuffers  = 1;
    ptwi->ptbLast   = ptwi->ptbFirst;

    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);

    ptb          = ptwi->ptbFirst;
    ptb->uLines  = 0;
    ptb->uOffset = 0;
    ptb->pPrev   = ptb;
    ptb->pNext   = ptb;

    InvalidateRect(hWnd,NULL,TRUE);
} // DeleteText()


//--------------------------------------------------------------------------;
//
//  DWORD GetTextSizeLimit
//
//  Description:
//      Gets the current size limit (in bytes) for text window before
//          starting to recycle buffers.
//
//  Arguments:
//      HWND hWnd:  Handle to window.
//
//  Return (DWORD):
//      Size (in bytes) of buffer size limit.
//
//  History:
//      11/28/94    Fwong       Adding query flexibility.
//
//--------------------------------------------------------------------------;

DWORD GetTextSizeLimit
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    return (TEXT_BUFFER_SIZE * ptwi->uMaxBuffers);
} // GetTextSizeLimit()


//--------------------------------------------------------------------------;
//
//  DWORD SetTextSizeLimit
//
//  Description:
//      Sets the size limit (in bytes) for text before starting to
//          recycle buffers.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      DWORD cbSize: Size (in bytes) of desired memory.
//
//      UINT uFlags: Flags for function (if you want to truncate).
//
//  Return (DWORD):
//      Actual maximum size (may be little more than requested).
//
//  History:
//      10/25/94    Fwong       Adding flexibility.
//
//--------------------------------------------------------------------------;

DWORD SetTextSizeLimit
(
    HWND    hWnd,
    DWORD   cbSize,
    UINT    uFlags
)
{
    PTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    UINT                u;

    if(0 == cbSize)
    {
        cbSize++;
    }

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    u = (UINT)(cbSize / TEXT_BUFFER_SIZE + ((cbSize % TEXT_BUFFER_SIZE)?1:0));

    ptwi->uMaxBuffers = u;

    if(u < ptwi->uBuffers)
    {
        if(uFlags & SETSIZEFLAG_TRUNCATE)
        {
            u   = ptwi->uBuffers - ptwi->uMaxBuffers;
            ptb = ptwi->ptbFirst;

            for(;u;u--)
            {
                ptwi->ptbFirst = ptwi->ptbFirst->pNext;
            }

            ptwi->ptbLast->pNext  = ptwi->ptbFirst;
            ptwi->ptbFirst->pPrev = ptwi->ptbLast;

            u = ptwi->uBuffers - ptwi->uMaxBuffers;

            for(;u;u--)
            {
                ptwi->dwLines -= ptb->uLines;

                if(!(ptwi->fdwFlags & TEXTFLAG_END))
                {
                    if(ptwi->dwCurLine < ptb->uLines)
                    {
                        ptwi->dwCurLine  = 0;
                    }
                    else
                    {
                        ptwi->dwCurLine -= ptb->uLines;
                    }
                }

                //  Freeing memory for actual text.
                LocalFree(ptb->pText);

                //  Freeing memory for this (TEXTBUFFER) structure...
                LocalFree(ptb);
                ptb  = ptb->pNext;
            }
        }
        else
        {
            //  Not truncating buffer to so setting max to current number...
            ptwi->uMaxBuffers = ptwi->uBuffers;
        }
    }

    return (TEXT_BUFFER_SIZE * (ptwi->uMaxBuffers));
} // SetTextSizeLimit()


//--------------------------------------------------------------------------;
//
//  LPTEXTBUFFER GotoTextLine
//
//  Description:
//      Goes to specific text line.
//
//  Arguments:
//      PTEXTWINDOWINFO ptwi: Pointer to TEXTWINDOWINFO structure.
//
//      LPUINT puOffset: Offset into TEXTBUFFER (returned).
//
//      DWORD dwLine: Destination line.
//
//  Return (LPTEXTBUFFER):
//      Pointer to text buffer containing line.
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

LPTEXTBUFFER GotoTextLine
(
    PTEXTWINDOWINFO    ptwi,
    LPUINT              puOffset,
    DWORD               dwLine
)
{
    LPTEXTBUFFER    ptb;
    UINT            uOffset;

    //
    //  Walking list of TextBuffers.
    //

    for(ptb = ptwi->ptbFirst;
        (dwLine && (dwLine >= ptb->uLines));
        ptb = ptb->pNext)
    {
        dwLine -= ptb->uLines;
    }

    //
    //  Getting to particular line...
    //

    for(uOffset = 0;dwLine;dwLine--,uOffset++)
    {                            
        uOffset += (lstrlen(&(ptb->pText[uOffset + sizeof(INDEX)]))
                   + sizeof(INDEX));
    }

    *puOffset = uOffset;

    return ptb;
} // GotoTextLine()


//--------------------------------------------------------------------------;
//
//  DWORD SetNumColors
//
//  Description:
//      Sets the number of colors available on the Text palette.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uNumColors: Number of colors.
//
//  Return (DWORD):
//      Previous number of colors.
//
//  History:
//      10/20/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

DWORD SetNumColors
(
    HWND    hWnd,
    UINT    uNumColors
)
{
    PTEXTWINDOWINFO    ptwi;
    PTEXTWINDOWINFO    ptwiNew;
    UINT                uSize;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    uNumColors = (0 == uNumColors)?1:uNumColors;
    uNumColors = (MAX_COLORS < uNumColors)?MAX_COLORS:uNumColors;

    if(uNumColors == ptwi->uNumColors)
    {
        return uNumColors;
    }

    uSize = sizeof(TEXTWINDOWINFO) + uNumColors * sizeof(COLORREF);

    ptwiNew = (PTEXTWINDOWINFO)LocalAlloc(LPTR, uSize);

    if(NULL == ptwiNew)
    {
        return ptwi->uNumColors;    
    }

    for(uSize = uNumColors; uSize; uSize--)
    {
        ptwiNew->crText[uSize - 1] = ptwi->crText[0];
    }

    uSize = sizeof(TEXTWINDOWINFO) + sizeof(COLORREF) * (min(uNumColors,ptwi->uNumColors));

    CopyMemory(ptwiNew, ptwi, uSize);

    ptwiNew->uNumColors = uNumColors;

    SetWindowLongPtr(hWnd, 0, (LONG_PTR) ptwiNew);

    uNumColors = ptwi->uNumColors;

    LocalFree(ptwi);

    return uNumColors;
} // SetNumColors()


//--------------------------------------------------------------------------;
//
//  DWORD GetNumColors
//
//  Description:
//      Returns the number of colors in the given text palette.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (DWORD):
//      Number of available colors.
//
//  History:
//      10/20/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

DWORD GetNumColors
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    return (ptwi->uNumColors);
} // GetNumColors()


//--------------------------------------------------------------------------;
//
//  COLORREF SetColor
//
//  Description:
//      Sets the text's color given the index.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uIndex: Index of color.
//
//      COLORREF cr: New color.
//
//  Return (COLORREF):
//      Previous color.
//
//  History:
//      10/20/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

COLORREF SetColor
(
    HWND        hWnd,
    UINT        uIndex,
    COLORREF    cr
)
{
    PTEXTWINDOWINFO    ptwi;
    COLORREF            crOld;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    if(uIndex >= ptwi->uNumColors)
    {
        return cr;
    }

    crOld = ptwi->crText[uIndex];

    ptwi->crText[uIndex] = cr;

    InvalidateRect(hWnd,NULL,FALSE);

    if(ptwi->fdwFlags & TEXTFLAG_REDRAW)
    {
        UpdateWindow(hWnd);
    }

    return crOld;
} // SetColor()


//--------------------------------------------------------------------------;
//
//  COLORREF GetColor
//
//  Description:
//      Gets the color from the text palette given the index.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uIndex: Index of color.
//
//  Return (COLORREF):
//      Color in question.
//
//  History:
//      10/20/95    Fwong       Adding color support.
//
//--------------------------------------------------------------------------;

COLORREF GetColor
(
    HWND    hWnd,
    UINT    uIndex
)
{
    PTEXTWINDOWINFO    ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(uIndex >= ptwi->uNumColors)
    {
        return ptwi->crText[0];
    }

    return ptwi->crText[uIndex];
} // GetColor()


//--------------------------------------------------------------------------;
//
//  BOOL TextSearch
//
//  Description:
//      Searches for given text in buffer starting from either:
//          Top of current text OR immediately following current
//          hilight (if text is selected).
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      LPSTR pszSearch: String to search for.
//
//      UINT uFlags: Flags for searching (case sensitivity).
//
//  Return (BOOL):
//      TRUE if found, FALSE otherwise.
//
//  History:
//      11/22/94    Fwong       Additional functionality to text class.
//
//--------------------------------------------------------------------------;

BOOL TextSearch
(
    HWND    hWnd,
    LPSTR   pszSearch,
    UINT    uFlags
)
{
    PTEXTWINDOWINFO    ptwi;
    DWORD               dwLine,dwOldLine;
    UINT                uOffset,len;
    UINT                u,i,j,k,uMargin;
    LPTEXTBUFFER        ptb;
    LPSTR               pText;
    char                achTable[256];

    ptwi  = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    len   = lstrlen(pszSearch);

    //
    //  SPECIAL CASE!!
    //  Note:  The ONLY time when you would have a new buffer and have it be
    //         empty is when it is the first buffer.  Trust me on this one or
    //         you could decypher the code.  So I'll special case this one.
    //
    
    if((ptwi->ptbFirst == ptwi->ptbLast) && (0 == ptwi->ptbFirst->uOffset))
    {
        return (FALSE);
    }

    if(TEXTFLAG_SELECT & ptwi->fdwFlags)
    {
        //
        //  Text is selected.  Start search immediately after start of
        //  selection.
        //

        dwLine = min((ptwi->locStart.dwRow),(ptwi->locEnd.dwRow));
        
        if(ptwi->locStart.dwRow == ptwi->locEnd.dwRow)
        {
            u = min((ptwi->locStart.uCol),(ptwi->locEnd.uCol));
        }
        else
        {
            if(ptwi->locStart.dwRow < ptwi->locEnd.dwRow)
            {
                u = ptwi->locStart.uCol;
            }
            else
            {
                u = ptwi->locEnd.uCol;
            }
        }

        u++;

        //
        //  Just in case you have multiple finds on one line...
        //

        dwOldLine = dwLine;
        uMargin   = u;

        ptb      = GotoTextLine(ptwi,&uOffset,dwLine);

        pText    = &(ptb->pText[uOffset + sizeof(INDEX)]);
        i        = lstrlen(pText);
        u        = min(u,i);
        pText   += u;
        uOffset += u;
    }
    else
    {
        //
        //  No text is selected.  Start search from top of window.
        //

        ptb    = GotoTextLine(ptwi,&uOffset,ptwi->dwCurLine);
        pText  = &(ptb->pText[uOffset + sizeof(INDEX)]);

        dwLine = ptwi->dwCurLine;
    }

    //
    //  Note: The following "for" and "if" are _VERY_ ANSI depedented!!
    //

    for(u = 256;u;u--)
    {
        achTable[u - 1] = (BYTE)(u - 1);
    }

    if(!(SEARCHFLAG_MATCHCASE & uFlags))
    {
        for(u = 26; u; u--)
        {
            achTable['A' + u - 1] = 'a' + u - 1;
        }
    }

    for(;;dwLine++)
    {
        u = lstrlen(pText);

        if(u >= len)
        {
            i = u - len;

            for(j = 0;j <= i;j++)
            {
                for(k = len; k; k--)
                {
                    if(achTable[pszSearch[k-1]] != achTable[pText[k+j-1]])
                    {
                        break;
                    }
                }

                if(0 == k)
                {
                    //
                    //  FOUND!!  WAY COOL!!
                    //

                    ptwi->locStart.dwRow = dwLine;
                    ptwi->locStart.uCol  = j;

                    ptwi->locEnd.dwRow   = dwLine;
                    ptwi->locEnd.uCol    = j+len;

                    if ((TEXTFLAG_SELECT & ptwi->fdwFlags) &&
                        (dwLine == dwOldLine))
                    {
                        ptwi->locStart.uCol += uMargin;
                        ptwi->locEnd.uCol   += uMargin;
                    }

                    u = GetTextLines(hWnd);

                    if(dwLine >= (ptwi->dwCurLine + u))
                    {
                        //
                        //  We fell outside of the window; update viewport.
                        //

                        ptwi->dwCurLine = dwLine;

                        if(ptwi->dwLines <= (dwLine + u))
                        {
                            SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
                        }
                    }

                    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
                    InvalidateRect(hWnd,NULL,TRUE);

                    return TRUE;
                }
            }
        }

        //
        //  Adding color support.
        //

        uOffset += (u + 1 + sizeof(INDEX));

        if(uOffset == ptb->uOffset)
        {
            ptb        = ptb->pNext;
            pText      = ptb->pText + sizeof(INDEX);
            uOffset    = 0;

            if(ptb == ptwi->ptbFirst)
            {
                //
                //  Hmm... we're wrapping around?!
                //

                return FALSE;
            }
        }
        else
        {
            //
            //  Adding color support.
            //

            pText = &(pText[u + 1 + sizeof(INDEX)]);
        }
    }
} // TextSearch()


//--------------------------------------------------------------------------;
//
//  void TextCopy
//
//  Description:
//      Copies "high-lighted" text to clipboard.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Adding copy to clipboard functionality.
//
//--------------------------------------------------------------------------;

void TextCopy
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    DWORD               dw,cbBuffer;
    LPSTR               pText;
    LPSTR               pDest;
    UINT                u,uAdd;
    UINT                uOffset;
    LOCATION            loc1,loc2;

    ptwi  = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    if((ptwi->locStart.dwRow == ptwi->locEnd.dwRow) &&
        (ptwi->locStart.uCol == ptwi->locEnd.uCol))
    {
        return;
    }

    if(!(ptwi->fdwFlags & TEXTFLAG_SELECT))
    {
        return;
    }

    //
    //  Sorting locations...
    //

    loc1.dwRow = min(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);
    loc2.dwRow = max(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);

    if(loc1.dwRow == loc2.dwRow)
    {
        loc1.uCol = min(ptwi->locStart.uCol,ptwi->locEnd.uCol);
        loc2.uCol = max(ptwi->locStart.uCol,ptwi->locEnd.uCol);
    }
    else
    {
        if(loc1.dwRow == ptwi->locStart.dwRow)
        {
            loc1.uCol = ptwi->locStart.uCol;
            loc2.uCol = ptwi->locEnd.uCol;
        }
        else
        {
            loc2.uCol = ptwi->locStart.uCol;
            loc1.uCol = ptwi->locEnd.uCol;
        }
    }
    
    ptb = GotoTextLine(ptwi,&uOffset,loc1.dwRow);

    //
    //  Adding color support...
    //

    cbBuffer = 0;
    pText    = &(ptb->pText[uOffset + sizeof(INDEX)]);

    for(dw = loc1.dwRow;dw <= loc2.dwRow;dw++)
    {
        u = lstrlen(pText);

        uAdd = (dw == loc2.dwRow)?(min(loc2.uCol,u)):u;
        uAdd = (dw == loc1.dwRow)?(uAdd - min(uAdd,loc1.uCol)):uAdd;

        cbBuffer += uAdd;
        uOffset  += (u + 1 + sizeof(INDEX));

        if(uOffset == ptb->uOffset)
        {
            ptb        = ptb->pNext;
            pText      = ptb->pText + sizeof(INDEX);
            uOffset    = 0;

            if(ptb == ptwi->ptbFirst)
            {
                //
                //  Hmm... we're wrapping around?!
                //

                break;
            }
        }
        else
        {
            //
            //  Adding color support.
            //

            pText = &(pText[u + 1 + sizeof(INDEX)]);
        }
    }

    cbBuffer += (2*(dw - loc1.dwRow) + 1);
    dw        = loc1.dwRow;

    pDest = (LPSTR)LocalAlloc(LPTR, cbBuffer);

    if(NULL == pDest)
        return;

    ptb = GotoTextLine(ptwi,&uOffset,loc1.dwRow);
 
    //
    //  Adding color support.
    //

    pText = &(ptb->pText[uOffset + sizeof(INDEX)]);

    for(dw = loc1.dwRow;dw <= loc2.dwRow;dw++)
    {
        u = lstrlen(pText);

        uAdd = (dw == loc1.dwRow)?(min(u,loc1.uCol)):0;

        if(dw == loc2.dwRow)
        {
            lstrcpyn(pDest,&(pText[uAdd]),min(u,loc2.uCol) - uAdd + 1);
        }
        else
        {
            lstrcpy(pDest,&(pText[uAdd]));
            pDest    += lstrlen(pDest);
            pDest[0]  = '\r';
            pDest[1]  = '\n';
            pDest    += 2;
        }

        uOffset += (u + 1 + sizeof(INDEX));

        if(uOffset == ptb->uOffset)
        {
            ptb        = ptb->pNext;
            pText      = ptb->pText + sizeof(INDEX);
            uOffset    = 0;

            if(ptb == ptwi->ptbFirst)
            {
                //
                //  Hmm... we're wrapping around?!
                //

                break;
            }
        }
        else
        {
            pText = &(pText[u + 1 + sizeof(INDEX)]);
        }
    }

    OpenClipboard(hWnd);
    EmptyClipboard();
    
    SetClipboardData(CF_TEXT,pDest);
    CloseClipboard();

} // TextCopy()


//--------------------------------------------------------------------------;
//
//  void DrawVScroll
//
//  Description:
//      Draws the vertical scroll bar.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

void DrawVScroll
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;
    DWORD               dw;

    ptwi  = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        SetScrollPos(hWnd,SB_VERT,VSCROLL_RANGE,TRUE);
    }
    else
    {
        dw = ptwi->dwLines - GetTextLines(hWnd);
        dw = ((ptwi->dwCurLine)*VSCROLL_RANGE)/(dw) + 1;

        SetScrollPos(hWnd,SB_VERT,(int)dw,TRUE);
    }

} // DrawVScroll()


//--------------------------------------------------------------------------;
//
//  void TextUp
//
//  Description:
//      "Scrolls" text up by dwDelta amount.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      DWORD dwDelta: Number of lines to scroll up.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

void TextUp
(
    HWND    hWnd,
    DWORD   dwDelta
)
{
    PTEXTWINDOWINFO    ptwi;
    int                 i,j;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(0 == ptwi->dwCurLine)
    {
        //
        //  We're already on first line.
        //

        return;
    }

    GetScrollRange(hWnd,SB_VERT,&i,&j);

    if(0 == j)
    {
        //
        //  Scrollbar not enabled.  Nothing to scroll.
        //

        return;
    }

    i = GetTextLines(hWnd);

    if(dwDelta > ptwi->dwCurLine)
    {
        //
        //  Scrolling up more than number of lines?
        //

        ptwi->dwCurLine = 0;
    }
    else
    {
        ptwi->dwCurLine -= dwDelta;
    }
    
    InvalidateRect(hWnd,NULL,TRUE);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
} // TextUp()


//--------------------------------------------------------------------------;
//
//  void TextDown
//
//  Description:
//      "Scrolls" text down by dwDelta amount.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      DWORD dwDelta: Number of lines to scroll down.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

void TextDown
(
    HWND    hWnd,
    DWORD   dwDelta
)
{
    PTEXTWINDOWINFO    ptwi;
    int                 i,j;
    DWORD               dwEnd;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        //
        //  We're already on last line.
        //

        return;
    }

    GetScrollRange(hWnd,SB_VERT,&i,&j);

    if(0 == j)
    {
        //
        //  Scrollbar not enabled.  Nothing to scroll.
        //

        return;
    }

    i     = GetTextLines(hWnd);
    dwEnd = ptwi->dwLines - i;
    
    ptwi->dwCurLine += dwDelta;

    if(ptwi->dwCurLine >= dwEnd)
    {
        ptwi->dwCurLine = dwEnd;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
    }

    InvalidateRect(hWnd,NULL,TRUE);
} // TextDown()


//--------------------------------------------------------------------------;
//
//  BOOL TextCreate
//
//  Description:
//      Handles WM_CREATE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      LPCREATESTRUCT pCreateStruct: Pointer to CREATESTRUCT.
//
//  Return (BOOL):
//      (-1) if failure, 0 if successful.
//
//  History:
//      10/23/95    Fwong       Tweaking create stuff.
//
//--------------------------------------------------------------------------;

BOOL TextCreate
(
    HWND            hWnd,
    LPCREATESTRUCT  pCreateStruct
)
{
    //
    //  Note: The pointer to TEXTWINDOWINFO is the lpCreateParams from
    //        TextCreateWindow.
    //

    SetWindowLongPtr(hWnd,0,(LONG_PTR)(pCreateStruct->lpCreateParams));

    return (-1);
}


//--------------------------------------------------------------------------;
//
//  void TextPaint
//
//  Description:
//      Handles WM_PAINT messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextPaint
(
    HWND    hWnd
)
{
    HDC                 hDC;
    PAINTSTRUCT         ps;
    PTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    COLORREF            crText,crBackGnd;
    COLORREF            crTextCurr;
    HPEN                hPen;
    HBRUSH              hBrush;
    RECT                r,r2;
    LOCATION            loc1,loc2;
    UINT                nLines;
    UINT                uOffset;
    UINT                nPos;
    UINT                u,i;
    UINT                nLen,nStart;
    LPSTR               pText;
    HFONT               hFont;
    DWORD               dw;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    hDC    = BeginPaint(hWnd,&ps);
    hFont  = SelectFont(hDC,ptwi->hFont);

    nLines = GetTextLines(hWnd);
    nLines = (UINT)min((DWORD)nLines,(ptwi->dwLines));

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        ptwi->dwCurLine = ptwi->dwLines - nLines;
    }

    if(nLines != ptwi->dwLines)
    {
        SetScrollRange(hWnd,SB_VERT,1,VSCROLL_RANGE,FALSE);
        DrawVScroll(hWnd);
    }
    else
    {
        SetScrollRange(hWnd,SB_VERT,0,0,TRUE);
    }

    //
    //  Sorting locations...
    //

    if(ptwi->fdwFlags & TEXTFLAG_SELECT)
    {
        loc1.dwRow = min(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);
        loc2.dwRow = max(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);

        if(loc1.dwRow == loc2.dwRow)
        {
            loc1.uCol = min(ptwi->locStart.uCol,ptwi->locEnd.uCol);
            loc2.uCol = max(ptwi->locStart.uCol,ptwi->locEnd.uCol);
        }
        else
        {
            if(loc1.dwRow == ptwi->locStart.dwRow)
            {
                loc1.uCol = ptwi->locStart.uCol;
                loc2.uCol = ptwi->locEnd.uCol;
            }
            else
            {
                loc2.uCol = ptwi->locStart.uCol;
                loc1.uCol = ptwi->locEnd.uCol;
            }
        }
    }
    else
    {
        //
        //  This way nothing will be selected.  Will do more elegant fix
        //  later.
        //

        loc1.dwRow = (DWORD)(-1);
        loc1.dwRow = (DWORD)(-1);
        loc2.uCol  = (UINT)(-1);
        loc2.uCol  = (UINT)(-1);
    }

    //
    //  Horizontal Scroll Bar?!
    //

    GetWindowRect(hWnd,&r);

    u = (r.bottom - r.top - GetSystemMetrics(SM_CYHSCROLL)) / ptwi->uTextHeight;

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        dw = (UINT)min((DWORD)u,(ptwi->dwLines));
        dw = ptwi->dwLines - dw;
    }
    else
    {
        dw = ptwi->dwCurLine;
    }

    //
    //  Finding maximum line length in lines to be displayed.
    //

    ptb   = GotoTextLine(ptwi,&uOffset,dw);
    pText = &(ptb->pText[uOffset + sizeof(INDEX)]);

    u = min(u,(int)nLines);

    for(dw = u,u = 0;dw;dw--)
    {
        i = lstrlen(pText);
        u = max(i,u);

        uOffset += (i + 1 + sizeof(INDEX));

        if(uOffset == ptb->uOffset)
        {
            ptb     = ptb->pNext;
            pText   = ptb->pText + sizeof(INDEX);
            uOffset = 0;
        }
        else
        {
            pText = &(pText[i + 1 + sizeof(INDEX)]);
        }
    }

    GetClientRect(hWnd,&r);

    nPos = r.right / ptwi->uTextWidth;

    if(u > (int)nPos)
    {
        u -= (int)nPos;

        SetScrollRange(hWnd,SB_HORZ,0,u,FALSE);
        SetScrollPos(hWnd,SB_HORZ,ptwi->uCurCol,TRUE);
    }
    else
    {
        ptwi->uCurCol = 0;
        SetScrollRange(hWnd,SB_HORZ,0,0,TRUE);
    }

    ptb   = GotoTextLine(ptwi,&uOffset,ptwi->dwCurLine);
    pText = &(ptb->pText[uOffset + sizeof(INDEX)]);

    crText    = GetTextColor(hDC);
    crBackGnd = SetBkColor(hDC,ptwi->crBackGnd);

    GetClientRect(hWnd,&r);
    dw = ptwi->dwCurLine;

    //
    //  Offsetting locations by current horizontal position.
    //

    loc1.uCol = (ptwi->uCurCol > loc1.uCol)?0:(loc1.uCol - ptwi->uCurCol);
    loc2.uCol = (ptwi->uCurCol > loc2.uCol)?0:(loc2.uCol - ptwi->uCurCol);

    for(nPos = 0;nLines;nLines--,nPos += ptwi->uTextHeight,dw++)
    {
        crTextCurr = ptwi->crText[*(LPINDEX)(&pText[0 - sizeof(INDEX)])];

        i = lstrlen(pText);

        u = min(ptwi->uCurCol,((UINT)i));
        pText = &(pText[u]);
        i -= u;

        r.top    = nPos;
        r.bottom = nPos + ptwi->uTextHeight;

        if((dw < loc1.dwRow) || (dw > loc2.dwRow))
        {
            SetTextColor(hDC,crTextCurr);
            ExtTextOut(hDC,0,nPos,ETO_OPAQUE,&r,pText,i,NULL);
        }
        else
        {
            nLen = min(((UINT)i),loc2.uCol);
            nLen = (dw == loc2.dwRow)?nLen:i;

            nStart = min(((UINT)i),loc1.uCol);
            nStart = (dw == loc1.dwRow)?nStart:0;

            r2.top    = nPos;
            r2.bottom = r.bottom;
            r2.left   = nStart * ptwi->uTextWidth;
            r2.right  = nLen * ptwi->uTextWidth;

            SetTextColor(hDC,ptwi->crHiLiteText);
            SetBkColor(hDC,ptwi->crHiLiteBackGnd);

            ExtTextOut(hDC,r2.left,nPos,ETO_OPAQUE,&r2,&(pText[nStart]),nLen-nStart,NULL);

            SetTextColor(hDC,crTextCurr);
            SetBkColor(hDC,ptwi->crBackGnd);

            r2.right = r2.left;
            r2.left  = 0;

            if(0 != r2.right)
            {
                ExtTextOut(hDC,0,nPos,ETO_OPAQUE,&r2,pText,nStart,NULL);
            }

            r2.right = r.right;
            r2.left  = nLen * ptwi->uTextWidth;

            ExtTextOut(hDC,r2.left,nPos,ETO_OPAQUE,&r2,&(pText[nLen]),i-nLen,NULL);
        }

//        uOffset += (i + 1 + sizeof(INDEX));
        uOffset += (i + u + 1 + sizeof(INDEX));

        if(uOffset == ptb->uOffset)
        {
            ptb     = ptb->pNext;
            pText   = ptb->pText + sizeof(INDEX);
            uOffset = 0;
        }
        else
        {
            pText = &(pText[i + 1 + sizeof(INDEX)]);
        }
    }

    hBrush = CreateSolidBrush(ptwi->crBackGnd);
    hPen   = (HPEN)GetStockObject(NULL_PEN);

    //
    //  Drawing remainder of window (rectange)...
    //

    if(NULL == hBrush)
    {
        hBrush = (HBRUSH)GetStockObject(NULL_BRUSH);
    }

    hBrush = (HBRUSH)SelectObject(hDC,hBrush);
    hPen   = (HPEN)SelectObject(hDC,hPen);
    GetClientRect(hWnd,&r);
    Rectangle(hDC,0,nPos,r.right+1,r.bottom+1);
    hPen   = (HPEN)SelectObject(hDC,hPen);
    hBrush = (HBRUSH)SelectObject(hDC,hBrush);
    DeleteObject(hBrush);

    SetBkColor(hDC,crBackGnd);
    SetTextColor(hDC,crText);

    SelectFont(hDC,hFont);

    EndPaint(hWnd,&ps);

    //
    //  Are we scrolling?
    //

    if(TEXTFLAG_SCROLLUP & ptwi->fdwFlags)
    {
        if(0 != ptwi->dwCurLine)
        {
            TextUp(hWnd,1);
            ptwi->locEnd.dwRow = ptwi->dwCurLine;
        }
    }

    if(TEXTFLAG_SCROLLDOWN & ptwi->fdwFlags)
    {
        if(!(ptwi->fdwFlags & TEXTFLAG_END))
        {
            TextDown(hWnd,1);
            ptwi->locEnd.dwRow++;
        }
    }

    if(TEXTFLAG_SCROLLLEFT & ptwi->fdwFlags)
    {
        if(0 != ptwi->uCurCol)
        {
            ptwi->uCurCol--;
            ptwi->locEnd.uCol--;
            InvalidateRect(hWnd,NULL,TRUE);
        }
    }

    if(TEXTFLAG_SCROLLRIGHT & ptwi->fdwFlags)
    {
        int i1, i2;
        GetScrollRange(hWnd,SB_HORZ,&i1,&i2);
        u = (UINT)i2;
        if(u > ptwi->uCurCol)
        {
            ptwi->uCurCol++;
            ptwi->locEnd.uCol++;
            InvalidateRect(hWnd,NULL,TRUE);
        }
    }

} // TextPaint()


//--------------------------------------------------------------------------;
//
//  void TextSetFont
//
//  Description:
//      Sets the font in window.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      HFONT hFont: Handle to font.
//
//      BOOL fRedraw: TRUE if window is to be redrawn.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Adding flexibility.
//
//--------------------------------------------------------------------------;

void TextSetFont
(
    HWND    hWnd,
    HFONT   hFont,
    BOOL    fRedraw
)
{
    PTEXTWINDOWINFO    ptwi;
    TEXTMETRIC          tm;
    HDC                 hDC;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(NULL == hFont)
    {
        hFont = GetStockFont(ANSI_FIXED_FONT);
    }

    ptwi->hFont = hFont;

    hDC   = GetDC(hWnd);
    hFont = SelectFont(hDC,hFont);

    GetTextMetrics(hDC,&tm);
    ptwi->uTextHeight = tm.tmHeight + tm.tmExternalLeading;
    ptwi->uTextWidth  = tm.tmAveCharWidth;

    SelectFont(hDC,hFont);
    ReleaseDC(hWnd,hDC);

    if(fRedraw)
    {
        InvalidateRect(hWnd,NULL,TRUE);
    }
} // TextSetFont()


//--------------------------------------------------------------------------;
//
//  HFONT TextGetFont
//
//  Description:
//      Gets the current HFONT used for window.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (HFONT):
//      Handle to font.
//
//  History:
//      10/25/94    Fwong       Adding flexibility.
//
//--------------------------------------------------------------------------;

HFONT TextGetFont
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    return (ptwi->hFont);
} // TextGetFont()


//--------------------------------------------------------------------------;
//
//  void TextClose
//
//  Description:
//      Handles WM_CLOSE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextClose
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    ptwi->ptbLast->pNext = NULL;
    while(ptwi->ptbFirst)
    {
        ptb = ptwi->ptbFirst;
        ptwi->ptbFirst = ptwi->ptbFirst->pNext;

        // Free memory
        LocalFree(ptb->pText);
        LocalFree(ptb);
    }

    //  Freeing memory for this (TEXTWINDOWINFO) structure...
    LocalFree(ptwi);
} // TextClose()


//--------------------------------------------------------------------------;
//
//  void TextVScroll
//
//  Description:
//      Handles WM_VSCROLL messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      HWND hWndVScroll: Handle to Scroll bar.
//
//      UINT uScrollCode: Scroll code.
//
//      int nPos: Scroll Position.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextVScroll
(
    HWND    hWnd,
    HWND    hWndVScroll,
    UINT    uScrollCode,
    int     nPos
)
{
    PTEXTWINDOWINFO ptwi;
    int             nLines;
    int             i;
    DWORD           dwEnd;
    DWORD           dwDelta;

    //
    //  Is the scroll bar enabled?
    //

    GetScrollRange(hWnd,SB_VERT,&i,&nLines);

    if(0 == nLines)
    {
        //  No?  We're getting this message?
        return;
    }

    ptwi    = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    nLines  = GetTextLines(hWnd);
    dwDelta = nLines;

    switch(uScrollCode)
    {
        case SB_LINEUP:
            //  Note: Purposely falling through.
            dwDelta = 1;
            TextUp(hWnd,dwDelta);

        case SB_PAGEUP:
            dwDelta = 10;
            TextUp(hWnd,dwDelta);
            break;

        case SB_LINEDOWN:
            //  Note: Purposely falling through.
            dwDelta = 1;
            TextDown(hWnd,dwDelta);
            break;

        case SB_PAGEDOWN:
            dwDelta = 10;
            TextDown(hWnd,dwDelta);
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            dwEnd = ptwi->dwLines - nLines;

            ptwi->dwCurLine = (dwEnd * nPos)/VSCROLL_RANGE;
            
            CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_END);

            if(ptwi->dwCurLine >= dwEnd)
            {
                ptwi->dwCurLine = dwEnd;
                SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
            }

            if(1 == nPos)
            {
                ptwi->dwCurLine = 0;
            }

            InvalidateRect(hWnd,NULL,TRUE);

            break;
    }

    DrawVScroll(hWnd);
} // TextVScroll()


//--------------------------------------------------------------------------;
//
//  void TextHScroll
//
//  Description:
//      Handle WM_HSCROLL messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      HWND hWndVScroll: Handle to Scroll bar.
//
//      UINT uScrollCode: Scroll code.
//
//      int nPos: Scroll Position.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextHScroll
(
    HWND    hWnd,
    HWND    hWndHScroll,
    UINT    uScrollCode,
    int     nPos
)
{
    PTEXTWINDOWINFO    ptwi;
    UINT                u,uDelta;
    RECT                r;
    int                 i, iDelta;

    //
    //  Is the scroll bar enabled?
    //

    GetScrollRange(hWnd,SB_HORZ,&iDelta,&i);
    uDelta = (UINT)iDelta;
    u = (UINT)i;

    if(0 == u)
    {
        //
        //  No?  We're getting this message?
        //

        return;
    }

    ptwi    = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    GetClientRect(hWnd,&r);

    uDelta = r.right / ptwi->uTextWidth;

    switch(uScrollCode)
    {
        case SB_LINELEFT:
            //
            //  Note: Purposely falling through.
            //

            uDelta = 1;

        case SB_PAGELEFT:
            if(ptwi->uCurCol > uDelta)
            {
                ptwi->uCurCol -= uDelta;
            }
            else
            {
                ptwi->uCurCol = 0;
            }

            break;

        case SB_LINERIGHT:
            //
            //  Note: Purposely falling through.
            //

            uDelta = 1;

        case SB_PAGERIGHT:
            ptwi->uCurCol += uDelta;

            if(ptwi->uCurCol > u)
            {
                ptwi->uCurCol = u;
            }

            break;

        case SB_THUMBPOSITION:
            ptwi->uCurCol = nPos;
    }

    InvalidateRect(hWnd,NULL,TRUE);
    SetScrollPos(hWnd,SB_HORZ,ptwi->uCurCol,TRUE);
} // TextHScroll()


//--------------------------------------------------------------------------;
//
//  void TextSize
//
//  Description:
//      Handles WM_SIZE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uSizeType: How we're being sized.
//
//      int nWidth: New Width.
//
//      int nHeight: New Height.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//      10/23/95    Fwong       Deleted silly parameter validation.
//
//--------------------------------------------------------------------------;

void TextSize
(
    HWND    hWnd,
    UINT    uSizeType,
    int     nWidth,
    int     nHeight
)
{
    PTEXTWINDOWINFO    ptwi;
    UINT                uLines;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        //
        //  We don't recalculate the current line.  It will be done
        //  on the WM_PAINT message.
        //

        return;
    }

    uLines = (nHeight / ptwi->uTextHeight);
    
    if(ptwi->dwCurLine + uLines >= ptwi->dwLines)
    {
        //
        //  If end of buffer is displayable, then mark text as "end".
        //

        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
    }

} // TextSize()


//--------------------------------------------------------------------------;
//
//  void TextSetRedraw
//
//  Description:
//      Handles WM_SETREDRAW messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      BOOL fRedraw: TRUE if redraw should be enabled.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextSetRedraw
(
    HWND    hWnd,
    BOOL    fRedraw
)
{
    PTEXTWINDOWINFO    ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);

    if(fRedraw)
    {
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_REDRAW);
    }
    else
    {
        CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_REDRAW);
    }
} // TextSetRedraw()


//--------------------------------------------------------------------------;
//
//  void TextColorChange
//
//  Description:
//      Handles WM_SYSCOLORCHANGE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextColorChange
(
    HWND    hWnd
)
{
    PTEXTWINDOWINFO ptwi;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    ptwi->crHiLiteBackGnd = GetSysColor(COLOR_HIGHLIGHT);
    ptwi->crHiLiteText    = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ptwi->crBackGnd       = GetSysColor(COLOR_WINDOW);
    ptwi->crText[0]       = GetSysColor(COLOR_WINDOWTEXT);

    InvalidateRect(hWnd,NULL,TRUE);
} // TextColorChange()


//--------------------------------------------------------------------------;
//
//  void TextLButtonDown
//
//  Description:
//      Handles WM_LBUTTONDOWN messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      BOOL fDoubleClick: TRUE if double-clicked.
//
//      int x: x Position.
//
//      int y: y Position.
//
//      UINT keyFlags: Key flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextLButtonDown
(
    HWND    hWnd,
    BOOL    fDoubleClick,
    int     x,
    int     y,
    UINT    keyFlags
)
{
    PTEXTWINDOWINFO    ptwi;
    DWORD               dw;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    x  = (x < 0)?0:x;

    x = x / ptwi->uTextWidth;
    y = y / ptwi->uTextHeight;

    //
    //  Setting up this window to capture mouse messages.
    //

    SetCapture(hWnd);

    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_CLICK);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);

    //
    //  Storing location.
    //

    if(ptwi->dwLines == 0)
    {
        ptwi->locStart.dwRow = 0;
        ptwi->locStart.uCol  = 0;
    }
    else
    {
        dw = y + ptwi->dwCurLine;

        if(dw > ptwi->dwLines)
        {
            ptwi->locStart.dwRow = ptwi->dwLines - 1;
            ptwi->locStart.uCol  = (UINT)(-1);
        }
        else
        {
            ptwi->locStart.dwRow = dw;
            ptwi->locStart.uCol  = x + ptwi->uCurCol;
        }
    }
} // TextLButtonDown()


//--------------------------------------------------------------------------;
//
//  void TextLButtonUp
//
//  Description:
//      Handles WM_LBUTTONUP messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      int x: x Position.
//
//      int y: y Position.
//
//      UINT keyFlags: Key flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextLButtonUp
(
    HWND    hWnd,
    int     x,
    int     y,
    UINT    keyFlags
)
{
    PTEXTWINDOWINFO    ptwi;
    DWORD               dw;
    RECT                r;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    if(!(ptwi->fdwFlags & TEXTFLAG_CLICK))
    {
        return;
    }

    GetWindowRect(hWnd,&r);
    r.right  = r.right - r.left;
    r.bottom = r.bottom - r.top;

    x = (x < 0)?0:x;
    x = (x > r.right )?r.right :x;

    y = (y < 0)?0:y;
    y = (y > r.bottom)?r.bottom:y;

    x = x / ptwi->uTextWidth;
    y = y / ptwi->uTextHeight;

    dw = y + ptwi->dwCurLine;

    //
    //  Releasing this window from capturing mouse messages.
    //

    ReleaseCapture();

    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_CLICK);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLUP);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLDOWN);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLLEFT);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLRIGHT);

    //
    //  Storing location.
    //

    if(ptwi->dwLines == 0)
    {
        ptwi->locEnd.dwRow = 0;
        ptwi->locEnd.uCol  = 0;
    }
    else
    {
        if(dw > ptwi->dwLines)
        {
            ptwi->locEnd.dwRow = ptwi->dwLines - 1;
            ptwi->locEnd.uCol  = (UINT)(-1);
        }
        else
        {
            ptwi->locEnd.dwRow = dw;
            ptwi->locEnd.uCol  = x + ptwi->uCurCol;
        }
    }

    if ((ptwi->locEnd.dwRow == ptwi->locStart.dwRow) &&
        (ptwi->locEnd.uCol  == ptwi->locStart.uCol))
    {
        CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }
    else
    {
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }

    InvalidateRect(hWnd,NULL,TRUE);
} // TextLButtonUp()


//--------------------------------------------------------------------------;
//
//  void TextMouseMove
//
//  Description:
//      Handles WM_MOUSEMOVE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      int x: x Position.
//
//      int y: y Position.
//
//      UINT keyFlags: Key flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextMouseMove
(
    HWND    hWnd,
    int     x,
    int     y,
    UINT    keyFlags
)
{
    PTEXTWINDOWINFO    ptwi;
    DWORD               dw;
    RECT                r;

    ptwi = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    
    if(!(ptwi->fdwFlags & TEXTFLAG_CLICK))
    {
        return;
    }

    GetWindowRect(hWnd,&r);
    r.right  = r.right - r.left;
    r.bottom = r.bottom - r.top;

    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_DIRMASK);

    if(x < 0)
    {
        x = 0;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLLEFT);
    }

    if(x > r.right)
    {
        x = r.right;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLRIGHT);
    }

    if(y < 0)
    {
        y = 0;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLUP);
    }

    if(y > r.bottom)
    {
        y = r.bottom;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLDOWN);
    }

    x = x / ptwi->uTextWidth;
    y = y / ptwi->uTextHeight;

    dw = y + ptwi->dwCurLine;

    //
    //  Storing location.
    //

    if(ptwi->dwLines == 0)
    {
        ptwi->locEnd.dwRow = 0;
        ptwi->locEnd.uCol  = 0;
    }
    else
    {
        if(dw > ptwi->dwLines)
        {
            ptwi->locEnd.dwRow = ptwi->dwLines - 1;
            ptwi->locEnd.uCol  = (UINT)(-1);
        }
        else
        {
            ptwi->locEnd.dwRow = dw;
            ptwi->locEnd.uCol  = x + ptwi->uCurCol;
        }
    }

    if ((ptwi->locEnd.dwRow == ptwi->locStart.dwRow) &&
        (ptwi->locEnd.uCol  == ptwi->locStart.uCol))
    {
        CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }
    else
    {
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }

    InvalidateRect(hWnd,NULL,TRUE);
} // TextMouseMove()


//--------------------------------------------------------------------------;
//
//  void TextKey
//
//  Description:
//      Handles both WM_KEYDOWN and WM_KEYUP messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT vk: Virtual Key.
//
//      BOOL fDown: TRUE if key is down.
//
//      int cRepeat: Number of repetitions.
//
//      UINT flags: Flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextKey
(
    HWND    hWnd,
    UINT    vk,
    BOOL    fDown,
    int     cRepeat,
    UINT    flags
)
{
    PTEXTWINDOWINFO    ptwi;
    DWORD               dwDelta;
    DWORD               dwMask;
	//vanceo - unused so commented out
    //UINT                u1;
	UINT				u2;

    ptwi    = (PTEXTWINDOWINFO)GetWindowLongPtr(hWnd,0);
    dwDelta = GetTextLines(hWnd);

    dwMask  = ((DWORD)(-1) - 1);

    switch(vk)
    {
        case VK_UP:
            TextUp(hWnd,1);
            break;

        case VK_PRIOR:
            if(dwMask & GetKeyState(VK_CONTROL))
            {
                if(0 != ptwi->dwCurLine)
                {
                    ptwi->dwCurLine = 0L;
                    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
                    InvalidateRect(hWnd,NULL,TRUE);
                }
            }
            else
            {
                TextUp(hWnd,dwDelta);
            }
            break;

        case VK_DOWN:
            TextDown(hWnd,1);
            break;

        case VK_NEXT:
            if(dwMask & GetKeyState(VK_CONTROL))
            {
                if(!(ptwi->fdwFlags & TEXTFLAG_END))
                {
                    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
                    InvalidateRect(hWnd,NULL,TRUE);
                }
            }
            else
            {
                TextDown(hWnd,dwDelta);
            }
            break;

        case VK_HOME:
            ptwi->uCurCol = 0;
            InvalidateRect(hWnd,NULL,TRUE);
            break;

        case VK_LEFT:
            if(ptwi->uCurCol != 0)
            {
                ptwi->uCurCol--;
                InvalidateRect(hWnd,NULL,TRUE);
            }
            break;

        case VK_END:
        {
            int i1, i2;
            GetScrollRange(hWnd,SB_HORZ,&i1,&i2);
            ptwi->uCurCol = (UINT)i2;
            InvalidateRect(hWnd,NULL,TRUE);
            break;
        }

        case VK_RIGHT:
        {
            int i1, i2;
            GetScrollRange(hWnd,SB_HORZ,&i1,&i2);
            u2 = (UINT)i2;
            if(ptwi->uCurCol < u2)
            {
                ptwi->uCurCol++;
                InvalidateRect(hWnd,NULL,TRUE);
            }
            break;
        }

        case VK_INSERT:
            if(dwMask & GetKeyState(VK_CONTROL))
            {
                TextCopy(hWnd);
            }
            break;

        default:
            break;
    }
} // TextKey()


//--------------------------------------------------------------------------;
//
//  LRESULT TextFocusProc
//
//  Description:
//      This is similar to a DefMDIChildProc (but for Text windows).
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uMessage: Message.
//
//      WPARAM wParam: Message dependent.
//
//      LPARAM lParam: Message dependent.
//
//  Return (LRESULT):
//      Message dependent.
//
//  History:
//      10/25/94    Fwong       Adding "focus" functionality.
//
//--------------------------------------------------------------------------;

LRESULT TextFocusProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lr;

    switch(uMessage)
    {
        case WM_SYSCOLORCHANGE:
            lr = HANDLE_WM_SYSCOLORCHANGE(hWnd,wParam,lParam,TextColorChange);
            return lr;

        case WM_KEYDOWN:
            lr = HANDLE_WM_KEYDOWN(hWnd,wParam,lParam,TextKey);
            return lr;
    }
    // should never get here, returning something to keep the compiler happy
    return (LRESULT)-1;
} // TextFocusProc()   


//--------------------------------------------------------------------------;
//
//  LRESULT TextWndProc
//
//  Description:
//      Main WNDPROC for text window class.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uMessage: Message.
//
//      WPARAM wParam: Message depedent.
//
//      LPARAM lParam: Message depedent.
//
//  Return (LRESULT):
//      Message depedent.
//
//  History:
//      10/25/94    Fwong       Main WndProc.  Cheers!!
//
//--------------------------------------------------------------------------;

LRESULT CALLBACK EXPORT TextWndProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lr;

    switch(uMessage)
    {
        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CREATE:
            lr = HANDLE_WM_CREATE(hWnd,wParam,lParam,TextCreate);
            return lr;

        case WM_PAINT:
            lr = HANDLE_WM_PAINT(hWnd,wParam,lParam,TextPaint);
            return lr;

        case WM_CLOSE:
            lr = HANDLE_WM_CLOSE(hWnd,wParam,lParam,TextClose);
            return lr;

        case WM_VSCROLL:
            lr = HANDLE_WM_VSCROLL(hWnd,wParam,lParam,TextVScroll);
            return lr;

        case WM_HSCROLL:
            lr = HANDLE_WM_HSCROLL(hWnd,wParam,lParam,TextHScroll);
            return lr;

        case WM_SIZE:
            lr = HANDLE_WM_SIZE(hWnd,wParam,lParam,TextSize);
            return lr;

        case WM_LBUTTONDOWN:
            lr = HANDLE_WM_LBUTTONDOWN(hWnd,wParam,lParam,TextLButtonDown);
            return lr;

        case WM_LBUTTONUP:
            lr = HANDLE_WM_LBUTTONUP(hWnd,wParam,lParam,TextLButtonUp);
            return lr;

        case WM_MOUSEMOVE:
            lr = HANDLE_WM_MOUSEMOVE(hWnd,wParam,lParam,TextMouseMove);
            return lr;

        case WM_SETREDRAW:
            lr = HANDLE_WM_SETREDRAW(hWnd,wParam,lParam,TextSetRedraw);
            return lr;

        case WM_COPY:
            lr = HANDLE_WM_COPY(hWnd,wParam,lParam,TextCopy);
            return lr;

        case WM_SETFONT:
            lr = HANDLE_WM_SETFONT(hWnd,wParam,lParam,TextSetFont);
            return lr;

        case WM_GETFONT:
            lr = HANDLE_WM_GETFONT(hWnd,wParam,lParam,TextGetFont);
            return lr;

        //
        //  Special Messages defined for _this_ window class.
        //

        case TM_PROPAGATE:
            PropagateDraw(hWnd);
            return 0L;

        case TM_DELETETEXT:
            DeleteText(hWnd);
            return 0L;

        case TM_GETSIZELIMIT:
            return (LRESULT)((DWORD)GetTextSizeLimit(hWnd));

        case TM_SETSIZELIMIT:
            return (LRESULT)((DWORD)SetTextSizeLimit(
                hWnd,
                (DWORD)lParam,
                (UINT)wParam));

        case TM_SEARCH:
            return (LRESULT)((BOOL)TextSearch(
                hWnd,
                (LPSTR)lParam,
                (UINT)wParam));

        case TM_SETNUMCOLORS:
            return (LRESULT)((DWORD)SetNumColors(hWnd,(UINT)wParam));

        case TM_GETNUMCOLORS:
            return (LRESULT)((DWORD)GetNumColors(hWnd));

        case TM_SETCOLOR:
            return (LRESULT)((COLORREF)SetColor(
                hWnd,
                (UINT)wParam,
                (COLORREF)lParam));

        case TM_GETCOLOR:
            return (LRESULT)((COLORREF)GetColor(hWnd,(UINT)wParam));

        default:
            break;
    }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
} // TextWndProc()
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\strutils.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <time.h>
#include <windows.h>

#include <stdlib.h>	// NT BUILD needs this for div_t
#ifdef _XBOX
#include "convhelp.h"
#endif

#include "main.h"
#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#endif // ! NO_TNCOMMON_DEBUG_SPEW

#include "strutils.h"






//==================================================================================
// URL encoding hash table.
//==================================================================================

#define URLHASH_SAFE	0x00 // character is safe in the normal sequence
#define URLHASH_ESCAPE	0x01 // character is valid in an escape sequence
#define URLHASH_UNSAFE	0x80 // character is unsafe all places


// This was taken from DNet which in turn was from some IE source code.
//
// s_SafetyHash - the list of characters above 0x20 and below 0x7f that are
// classified as safe, escape, or unsafe. Safe characters do not need to be
// escaped.  Escape characters are the only ones allowed in an escape sequence.
// Unsafe characters must be escaped to be used.

static BYTE		s_SafetyHash[] =
{
	// UNSAFE: 0x00..0x20

	URLHASH_SAFE,					// 0x21 (!)
	URLHASH_UNSAFE,					// 0x22 (")
	URLHASH_SAFE,					// 0x23 (#)
	URLHASH_SAFE,					// 0x24 ($)
	URLHASH_UNSAFE,					// 0x25 (%)
	URLHASH_SAFE,					// 0x26 (&)
	URLHASH_SAFE,					// 0x27 (')
	URLHASH_SAFE,					// 0x28 (()
	URLHASH_SAFE,					// 0x29 ())
	URLHASH_SAFE,					// 0x2A (*)
	URLHASH_SAFE,					// 0x2B (+)
	URLHASH_SAFE,					// 0x2C (,)
	URLHASH_SAFE,					// 0x2D (-)
	URLHASH_SAFE,					// 0x2E (.)
	URLHASH_SAFE,					// 0x2F (/)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x30 (0)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x31 (1)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x32 (2)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x33 (3)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x34 (4)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x35 (5)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x36 (6)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x37 (7)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x38 (8)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x39 (9)
	URLHASH_SAFE,					// 0x3A (:)
	URLHASH_SAFE,					// 0x3B (;)
	URLHASH_UNSAFE,					// 0x3C (<)
	URLHASH_SAFE,					// 0x3D (=)
	URLHASH_UNSAFE,					// 0x3E (>)
	URLHASH_UNSAFE,					// 0x3F (?)
	URLHASH_SAFE,					// 0x40 (@)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x41 (A)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x42 (B)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x43 (C)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x44 (D)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x45 (E)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x46 (F)
	URLHASH_SAFE,					// 0x47 (G)
	URLHASH_SAFE,					// 0x48 (H)
	URLHASH_SAFE,					// 0x49 (I)
	URLHASH_SAFE,					// 0x4A (J)
	URLHASH_SAFE,					// 0x4B (K)
	URLHASH_SAFE,					// 0x4C (L)
	URLHASH_SAFE,					// 0x4D (M)
	URLHASH_SAFE,					// 0x4E (N)
	URLHASH_SAFE,					// 0x4F (O)
	URLHASH_SAFE,					// 0x50 (P)
	URLHASH_SAFE,					// 0x51 (Q)
	URLHASH_SAFE,					// 0x42 (R)
	URLHASH_SAFE,					// 0x43 (S)
	URLHASH_SAFE,					// 0x44 (T)
	URLHASH_SAFE,					// 0x45 (U)
	URLHASH_SAFE,					// 0x46 (V)
	URLHASH_SAFE,					// 0x47 (W)
	URLHASH_SAFE,					// 0x48 (X)
	URLHASH_SAFE,					// 0x49 (Y)
	URLHASH_SAFE,					// 0x5A (Z)
	URLHASH_UNSAFE,					// 0x5B ([)
	URLHASH_UNSAFE,					// 0x5C (\)
	URLHASH_UNSAFE,					// 0x5D (])
	URLHASH_UNSAFE,					// 0x5E (^)
	URLHASH_SAFE,					// 0x5F (_)
	URLHASH_UNSAFE,					// 0x60 (`)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x61 (a)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x62 (b)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x63 (c)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x64 (d)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x65 (e)
	URLHASH_SAFE | URLHASH_ESCAPE,	// 0x66 (f)
	URLHASH_SAFE,					// 0x67 (g)
	URLHASH_SAFE,					// 0x68 (h)
	URLHASH_SAFE,					// 0x69 (i)
	URLHASH_SAFE,					// 0x6A (j)
	URLHASH_SAFE,					// 0x6B (k)
	URLHASH_SAFE,					// 0x6C (l)
	URLHASH_SAFE,					// 0x6D (m)
	URLHASH_SAFE,					// 0x6E (n)
	URLHASH_SAFE,					// 0x6F (o)
	URLHASH_SAFE,					// 0x70 (p)
	URLHASH_SAFE,					// 0x71 (q)
	URLHASH_SAFE,					// 0x72 (r)
	URLHASH_SAFE,					// 0x73 (s)
	URLHASH_SAFE,					// 0x74 (t)
	URLHASH_SAFE,					// 0x75 (u)
	URLHASH_SAFE,					// 0x76 (v)
	URLHASH_SAFE,					// 0x77 (w)
	URLHASH_SAFE,					// 0x78 (x)
	URLHASH_SAFE,					// 0x79 (y)
	URLHASH_SAFE,					// 0x7A (z)
	URLHASH_UNSAFE,					// 0x7B ({)
	URLHASH_UNSAFE,					// 0x7C (|)
	URLHASH_UNSAFE,					// 0x7D (})
	URLHASH_UNSAFE					// 0x7E (~)

	// UNSAFE: 0x7F..0xFF
};








#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringStartsWith()"
//==================================================================================
// StringStartsWith
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the first string equals or begins with the second
//				string, FALSE otherwise.
//
// Arguments:
//	char* szString		String to check.
//	char* szPrefix		Prefix to check for.
//	BOOL fMatchCase		Whether case is important or not.
//
// Returns: TRUE if the string starts with the prefix, FALSE otherwise.
//==================================================================================
BOOL StringStartsWith(char* szString, char* szPrefix, BOOL fMatchCase)
{
	BOOL	fResult = FALSE;
	DWORD	dwPartialStringLen = 0;
	char*	pszFullStringStart = NULL;
	char*	pszPartialString = NULL;
	

	dwPartialStringLen = strlen(szPrefix);

	// If the string we're testing is shorter than the prefix, it can't
	// possibly begin with the substring.
	if (strlen(szString) < dwPartialStringLen)
		goto DONE;
	
	pszFullStringStart = (char*) LocalAlloc(LPTR, (dwPartialStringLen + 1));
	if (pszFullStringStart == NULL) // out of memory
		goto DONE;

	CopyMemory(pszFullStringStart, szString, dwPartialStringLen);
	
	// Terminate the temp string copy
	pszFullStringStart[dwPartialStringLen] = '\0';

	if (fMatchCase)
	{
		fResult = (strcmp(pszFullStringStart, szPrefix) == 0) ? TRUE : FALSE;
	} // end if (case is important)
	else
	{
		pszPartialString = (char*) LocalAlloc(LPTR, (dwPartialStringLen + 1));
		if (pszPartialString == NULL) // out of memory
			goto DONE;

		CopyMemory(pszPartialString, szPrefix, dwPartialStringLen + 1);

		_strlwr(pszFullStringStart);
		_strlwr(pszPartialString);

		fResult = (strcmp(pszFullStringStart, pszPartialString) == 0);
	} // end else (case is not important)
	

DONE:

	if (pszFullStringStart != NULL)
	{
		LocalFree(pszFullStringStart);
		pszFullStringStart = NULL;
	} // end if (allocated memory)

	if (pszPartialString != NULL)
	{
		LocalFree(pszPartialString);
		pszPartialString = NULL;
	} // end if (allocated memory)

	return (fResult);
} // StringStartsWith
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringEndsWith()"
//==================================================================================
// StringEndsWith
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the first string equals or ends with the second
//				string, FALSE otherwise.
//
// Arguments:
//	char* szString		String to check.
//	char* szSuffix		Suffix to check for.
//	BOOL fMatchCase		Whether case is important or not.
//
// Returns: TRUE if the string ends with the suffix, FALSE otherwise.
//==================================================================================
BOOL StringEndsWith(char* szString, char* szSuffix, BOOL fMatchCase)
{
	BOOL	fResult = FALSE;
	DWORD	dwPartialStringLen = 0;
	char*	pszFullStringEnd = NULL;
	char*	pszPartialString = NULL;
	
	
	dwPartialStringLen = strlen(szSuffix);

	// If the string we're testing is shorter than the suffix, it can't
	// possibly end with the substring.
	if (strlen(szString) < dwPartialStringLen)
		goto DONE;
	

	if (fMatchCase)
	{
		pszFullStringEnd = (szString + strlen(szString) - dwPartialStringLen);
		fResult = (strcmp(pszFullStringEnd, szSuffix) == 0);
		pszFullStringEnd = NULL; // don't try to free this memory, it was just a temp pointer
	} // end if (case is important)
	else
	{
		pszFullStringEnd = (char*) LocalAlloc(LPTR, (dwPartialStringLen + 1));
		if (pszFullStringEnd == NULL) // out of memory
			goto DONE;

		CopyMemory(pszFullStringEnd, (szString + strlen(szString) - dwPartialStringLen),
				dwPartialStringLen + 1);

		pszPartialString = (char*) LocalAlloc(LPTR, (dwPartialStringLen + 1));
		if (pszPartialString == NULL) // out of memory
			goto DONE;

		CopyMemory(pszPartialString, szSuffix, dwPartialStringLen + 1);

		_strlwr(pszFullStringEnd);
		_strlwr(pszPartialString);

		fResult = (strcmp(pszFullStringEnd, pszPartialString) == 0) ? TRUE : FALSE;
	} // end else (case is not important)
	

DONE:

	if (pszFullStringEnd != NULL)
	{
		LocalFree(pszFullStringEnd);
		pszFullStringEnd = NULL;
	} // end if (allocated memory)

	if (pszPartialString != NULL)
	{
		LocalFree(pszPartialString);
		pszPartialString = NULL;
	} // end if (allocated memory)

	return (fResult);
} // StringEndsWith
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringContainsChar()"
//==================================================================================
// StringContainsChar
//----------------------------------------------------------------------------------
//
// Description: Returns -1 if the passed string doesn't contain the char, otherwise
//				it returns the zero based position the first instance of the char
//				was found.  This checking starts at the value passed for iPos, so
//				pass zero if you want it to start at the beginning of the string. 
//
// Arguments:
//	char* szString		String to search.
//	char cCharToFind	Character to search for.
//	BOOL fMatchCase		Whether the character's case is important or not.
//	int iPos			Offset in string to begin looking
//
// Returns: The index of the char, or -1 if not found.
//==================================================================================
int StringContainsChar(char* szString, char cCharToFind, BOOL fMatchCase, int iPos)
{
	if (szString == NULL)
		return (-1);

	// (int) is to get rid of compiler warning
	if (iPos >= (int) strlen(szString))
		return (-1);

	if (iPos < 0)
		iPos = 0;

	if (cCharToFind == '\0')
		return (-1);

	if (fMatchCase)
	{
		while((szString[iPos] != '\0') && (szString[iPos] != cCharToFind))
			iPos++;
	} // end if (we have to match the case)
	else
	{
		char*	pszLowerString;
		char	szTemp[2];


		pszLowerString = (char*) LocalAlloc(LPTR, strlen(szString) + 1);
		if (pszLowerString == NULL)
			return (-1);

		strcpy(pszLowerString, szString);
		_strlwr(pszLowerString);


		szTemp[0] = cCharToFind;
		szTemp[1] = '\0';
		_strlwr(szTemp);

		while((pszLowerString[iPos] != '\0') &&
				(pszLowerString[iPos] != szTemp[0]))
		{
			iPos++;
		} // end while (not at end of string and not case-insensitive character)

		LocalFree(pszLowerString);
		pszLowerString = NULL;
	} // end else (we don't have to match the case)

	if (szString[iPos] == '\0')	// if we didn't find it
		return (-1);	// failure
	
	return (iPos);
} // StringContainsChar
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCountNumChars()"
//==================================================================================
// StringCountNumChars
//----------------------------------------------------------------------------------
//
// Description: Returns the number of times the string contains the passed in
//				character, or 0 if none. 
//
// Arguments:
//	char* szString		String to search.
//	char cCharToFind	Character to search for.
//	BOOL fMatchCase		Whether the character's case is important or not.
//
// Returns: The index of the char, or -1 if not found.
//==================================================================================
int StringCountNumChars(char* szString, char cCharToFind, BOOL fMatchCase)
{
	int				iCount = 0;
	unsigned int	ui;


	if (szString == NULL)
		return (-1);

	if (fMatchCase)
	{
		for(ui = 0; ui < strlen(szString); ui++)
		{
			if (szString[ui] == cCharToFind)
				iCount++;
		} // end for (each character in the string)
	} // end if (we have to match the case)
	else
	{
		char*	pszLowerString;
		char	szTemp[2];


		pszLowerString = (char*) LocalAlloc(LPTR, strlen(szString) + 1);
		if (pszLowerString == NULL)
			return (-1);

		strcpy(pszLowerString, szString);
		_strlwr(pszLowerString);


		szTemp[0] = cCharToFind;
		szTemp[1] = '\0';
		_strlwr(szTemp);


		for(ui = 0; ui < strlen(szString); ui++)
		{
			if (pszLowerString[ui] == szTemp[0])
				iCount++;
		} // end for (each character in the string)
	} // end else (we don't have to match the case)
	
	return (iCount);
} // StringCountNumChars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringContainsOneOfChars()"
//==================================================================================
// StringContainsOneOfChars
//----------------------------------------------------------------------------------
//
// Description: Returns -1 if the passed string doesn't contain any of the
//				characters in the szCharsToFind string, otherwise it returns the
//				zero based position of the first char found.  This checking starts
//				at the value passed for iPos, so pass zero if you want it to start
//				at the beginning of the string. 
//
// Arguments:
//	char* szString			String to search.
//	char* szCharsToFind		Characters to search for.
//	BOOL fMatchCase			Whether the characters' cases are important or not.
//	int iPos				Offset in string to begin looking
//
// Returns: The index of the char, or -1 if not found.
//==================================================================================
int StringContainsOneOfChars(char* szString, char* szCharsToFind, BOOL fMatchCase,
							int iPos)
{
	int		iFindCharPos;


	if (szString == NULL)
		return (-1);

	// (int) is to get rid of compiler warning
	if (iPos >= (int) strlen(szString))
		return (-1);

	if (iPos < 0)
		iPos = 0;

	if ((szCharsToFind == NULL) || (szCharsToFind[0] == '\0'))
		return (-1);

	if (fMatchCase)
	{
		while (szString[iPos] != '\0')
		{
			iFindCharPos = 0;

			while (szCharsToFind[iFindCharPos] != '\0')
			{
				if (szString[iPos] != szCharsToFind[iFindCharPos])
					return (iPos);

				iFindCharPos++;
			} // end while (still more chars to search for)
			iPos++;
		} // end while (not at the end of the string)
	} // end if (we have to match the case)
	else
	{
		char*	pszLowerString;
		char*	pszLowerCharsToFind;


		pszLowerString = (char*) LocalAlloc(LPTR, strlen(szString) + 1);
		if (pszLowerString == NULL)
			return (-1);

		strcpy(pszLowerString, szString);
		_strlwr(pszLowerString);


		pszLowerCharsToFind = (char*) LocalAlloc(LPTR, strlen(szCharsToFind) + 1);
		if (pszLowerCharsToFind == NULL)
		{
			LocalFree(pszLowerString);
			pszLowerString = NULL;
			return (-1);
		} // end if (couldn't allocate memory)

		strcpy(pszLowerCharsToFind, szCharsToFind);
		_strlwr(pszLowerCharsToFind);


		while (pszLowerString[iPos] != '\0')
		{
			iFindCharPos = 0;

			while (pszLowerCharsToFind[iFindCharPos] != '\0')
			{
				if (pszLowerString[iPos] != pszLowerCharsToFind[iFindCharPos])
				{
					LocalFree(pszLowerString);
					pszLowerString = NULL;
					LocalFree(pszLowerCharsToFind);
					pszLowerCharsToFind = NULL;
					return (iPos);
				} // end if (couldn't allocate memory)

				iFindCharPos++;
			} // end while (still more chars to search for)
			iPos++;
		} // end while (not at the end of the string)

		LocalFree(pszLowerString);
		pszLowerString = NULL;
		LocalFree(pszLowerCharsToFind);
		pszLowerCharsToFind = NULL;
	} // end else (we don't have to match the case)


	// If we got here, we failed.

	return (-1);
} // StringContainsOneOfChars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringContainsNonChar()"
//==================================================================================
// StringContainsNonChar
//----------------------------------------------------------------------------------
//
// Description: Returns -1 if the passed string contains only characters in the
//				szCharsToFind string, otherwise it returns the zero based position
//				of the first char found that is not.  This checking starts at the
//				value passed for iPos, so pass zero if you want it to start at the
//				beginning of the string. 
//
// Arguments:
//	char* szString			String to search.
//	char* szCharsAllowed	Characters that are accepted.
//	BOOL fMatchCase			Whether the characters' cases are important or not.
//	int iPos				Offset in string to begin looking
//
// Returns: The index of the char, or -1 if not found.
//==================================================================================
int StringContainsNonChar(char* szString, char* szCharsAllowed, BOOL fMatchCase,
						int iPos)
{
	int		iAllowedCharPos;


	if (szString == NULL)
		return (-1);

	// (int) is to get rid of compiler warning
	if (iPos >= (int) strlen(szString))
		return (-1);

	if (iPos < 0)
		iPos = 0;

	if ((szCharsAllowed == NULL) || (szCharsAllowed[0] == '\0'))
		return (-1);

	if (fMatchCase)
	{
		while (szString[iPos] != '\0')
		{
			iAllowedCharPos = 0;

			while (szCharsAllowed[iAllowedCharPos] != '\0')
			{
				if (szString[iPos] == szCharsAllowed[iAllowedCharPos])
					break;

				iAllowedCharPos++;
			} // end while (still more chars to search for)

			if (szCharsAllowed[iAllowedCharPos] == '\0')
				return (iPos);

			iPos++;
		} // end while (not at the end of the string)
	} // end if (we have to match the case)
	else
	{
		char*	pszLowerString;
		char*	pszLowerAllowedChars;


		pszLowerString = (char*) LocalAlloc(LPTR, strlen(szString) + 1);
		if (pszLowerString == NULL)
			return (-1);

		strcpy(pszLowerString, szString);
		_strlwr(pszLowerString);


		pszLowerAllowedChars = (char*) LocalAlloc(LPTR, strlen(szCharsAllowed) + 1);
		if (pszLowerAllowedChars == NULL)
		{
			LocalFree(pszLowerString);
			pszLowerString = NULL;
			return (-1);
		} // end if (couldn't allocate memory)

		strcpy(pszLowerAllowedChars, szCharsAllowed);
		_strlwr(pszLowerAllowedChars);


		while (pszLowerString[iPos] != '\0')
		{
			iAllowedCharPos = 0;

			while (pszLowerAllowedChars[iAllowedCharPos] != '\0')
			{
				if (pszLowerString[iPos] == pszLowerAllowedChars[iAllowedCharPos])
					break;

				iAllowedCharPos++;
			} // end while (still more chars to search for)

			if (szCharsAllowed[iAllowedCharPos] == '\0')
			{
				LocalFree(pszLowerString);
				pszLowerString = NULL;
				LocalFree(pszLowerAllowedChars);
				pszLowerAllowedChars = NULL;
				return (iPos);
			} // end if (got to end of allowed characters string)

			iPos++;
		} // end while (not at the end of the string)

		LocalFree(pszLowerString);
		pszLowerString = NULL;
		LocalFree(pszLowerAllowedChars);
		pszLowerAllowedChars = NULL;
	} // end else (we don't have to match the case)


	// If we got here, we didn't find any non-allowed characters.

	return (-1);
} // StringContainsNonChar
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCmpNoCase()"
//==================================================================================
// StringCmpNoCase
//----------------------------------------------------------------------------------
//
// Description: Performs similar to strcmp, except the case does not need to match.
//
// Arguments:
//	char* szString1		First string to use.
//	char* szString2		Second string to use.
//
// Returns: Returns TRUE if they match (case insensitive), FALSE otherwise.
//==================================================================================
BOOL StringCmpNoCase(char* szString1, char* szString2)
{
	BOOL	fResult = FALSE;
	DWORD	dwString1Len;
	DWORD	dwString2Len;
	char*	pszTemp1 = NULL;
	char*	pszTemp2 = NULL;


	dwString1Len = strlen(szString1);
	dwString2Len = strlen(szString2);

	// The sizes are wrong, then we don't even need to bother checking more
	if (dwString1Len != dwString2Len)
		goto DONE;

	pszTemp1 = (char*) LocalAlloc(LPTR, (strlen(szString1) + 1));
	if (pszTemp1 == NULL)
	{
		goto DONE;
	} // end if (couldn't allocate memory)

	CopyMemory(pszTemp1, szString1, dwString1Len);
	_strlwr(pszTemp1);


	pszTemp2 = (char*) LocalAlloc(LPTR, (strlen(szString2) + 1));
	if (pszTemp2 == NULL)
	{
		goto DONE;
	} // end if (couldn't allocate memory)
	CopyMemory(pszTemp2, szString2, dwString2Len);
	_strlwr(pszTemp2);


	// Compare lower case strings
	fResult = (strcmp(pszTemp1, pszTemp2) == 0) ? TRUE : FALSE;


DONE:

	if (pszTemp1 != NULL)
	{
		LocalFree(pszTemp1);
		pszTemp1 = NULL;
	} // end if (allocated first temp item)

	if (pszTemp2 != NULL)
	{
		LocalFree(pszTemp2);
		pszTemp2 = NULL;
	} // end if (allocated second temp item)

	return (fResult);
} // StringCmpNoCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringMatchesWithWildcard()"
//==================================================================================
// StringMatchesWithWildcard
//----------------------------------------------------------------------------------
//
// Description: Compares a string to one with wildcard characters (optionally case
//				sensitive), and returns TRUE if they match.
//				Wildcard characters are:
//					'*' - Any number of characters or none matches.
//					'?' - A single character matches.
//					'~' - Only allowed as first character of string.  Inverts any
//							results, so that if the string matches the rest of the
//							wildcard string, FALSE is returned, and if it does not
//							match, TRUE is returned.
//
// Arguments:
//	char* szWildcardString		String possibly containing wildcard characters.
//	char* szCompareString		Plain string to compare.
//	BOOL fMatchCase				Whether case is important or not.
//
// Returns: Returns TRUE if they match, FALSE otherwise.
//==================================================================================
BOOL StringMatchesWithWildcard(char* szWildcardString, char* szCompareString,
								BOOL fMatchCase)
{
	char*	pszTempCompare = NULL;
	char*	pszTempWildcard = NULL;
	BOOL	fResult = FALSE;
	BOOL	fInvert = FALSE;
	int		iStarPos = 0;
	int		iCurrentComparePos = 0;
	int		iNextStar;
	int		iQuestionPos;


	//DPL(8, "\"%s\" \"%s\"", 2, szWildcardString, szCompareString);



	if (szWildcardString[0] == '~')
	{
		fInvert = TRUE;
		// It's okay to bump this up, since we're working with a local copy of the
		// pointer.
		szWildcardString++;
	} // end if (should invert match)


	// We need a temporary buffer for comparisons, since our algorithm for ?
	// matching is destructive.
	pszTempCompare = (char*) LocalAlloc(LPTR, strlen(szCompareString) + 1);
	if (pszTempCompare == NULL)
	{
		fInvert = FALSE; // this ensures we return FALSE
		goto DONE;
	} // end if (couldn't allocate memory)


	// We'll never need anything bigger than the wildcard string, so just allocate
	// a buffer big enough for that.
	pszTempWildcard = (char*) LocalAlloc(LPTR, strlen(szWildcardString) + 1);
	if (pszTempWildcard == NULL)
	{
		fInvert = FALSE; // this ensures we return FALSE
		goto DONE;
	} // end if (couldn't allocate memory)


	/// Loop until we completely match or fail to match at some point.
	do
	{
		iNextStar = StringContainsChar(szWildcardString, '*', TRUE, iStarPos);

		if (iNextStar < 0)
		{
			if (strlen(szCompareString) >= strlen(szWildcardString + iStarPos))
			{
				strcpy(pszTempWildcard, szWildcardString + iStarPos);
				strcpy(pszTempCompare, szCompareString + strlen(szCompareString) - strlen(pszTempWildcard));

				// Loop through the section of the string to compare and convert all
				// characters in the temporary comparison buffer where there was a
				// question mark in the wildcard string into question marks too.  This
				// will cause the string comparison routine to match.
				iQuestionPos = 0;
				do
				{
					iQuestionPos = StringContainsChar(pszTempWildcard, '?', TRUE, iQuestionPos);

					// No more question marks?  Okay, we're done.
					if (iQuestionPos < 0)
						break;

					// This is destructive, but that's what we have the temp buffer
					// for.
					pszTempCompare[iQuestionPos] = '?';

					iQuestionPos++; // move past this question mark
				} // end do (while there are question marks)
				while (TRUE);


				// If the string doesn't end with this part, it's a failure.
				if (fMatchCase)
				{
					fResult = (strcmp(pszTempCompare, pszTempWildcard) == 0) ? TRUE : FALSE;
				} // end if (should match case)
				else
				{
					fResult = StringCmpNoCase(pszTempCompare, pszTempWildcard);
				} // end else (don't match case)
			} // end if (string is long enough)

			break;
		} // end if (didn't find another star)

		if (szWildcardString[iNextStar + 1] == '*')
		{
			#ifndef NO_TNCOMMON_DEBUG_SPEW
			DPL(0, "Two *'s in a row is illegal (\"%s\"), failing!",
				1, szWildcardString);
			#endif // NO_TNCOMMON_DEBUG_SPEW

			fInvert = FALSE; // this ensures we return FALSE

			break;
		} // end if (user had to stars in a row)

		// Check if the first character is a star.
		if (iNextStar == 0)
		{
			// Special case: having only one star, and it being at the beginning
			if (StringContainsChar(szWildcardString, '*', TRUE, 1) < 0)
			{
				// The string is just "*", so match everything
				if (szWildcardString[1] == '\0')
				{
					fResult = TRUE;
					break;
				} // end if (star is entire string)

				strcpy(pszTempWildcard, szWildcardString + 1);
				strcpy(pszTempCompare, szCompareString + strlen(szCompareString) - strlen(pszTempWildcard));

				// Loop through the section of the string to compare and convert all
				// characters in the temporary comparison buffer where there was a
				// question mark in the wildcard string into question marks too.  This
				// will cause the string comparison routine to match.
				iQuestionPos = 0;
				do
				{
					iQuestionPos = StringContainsChar(pszTempWildcard, '?', TRUE, iQuestionPos);

					// No more question marks?  Okay, we're done.
					if (iQuestionPos < 0)
						break;

					// This is destructive, but that's what we have the temp buffer
					// for.
					pszTempCompare[iQuestionPos] = '?';

					iQuestionPos++; // move past this question mark
				} // end do (while there are question marks)
				while (TRUE);


				// If the string doesn't end with this part, it's a failure.
				if (fMatchCase)
				{
					fResult = (strcmp(pszTempCompare, pszTempWildcard) == 0) ? TRUE : FALSE;
				} // end if (should match case)
				else
				{
					fResult = StringCmpNoCase(pszTempCompare, pszTempWildcard);
				} // end else (don't match case)

				break;
			} // end if (no more stars)

			// Otherwise, just move on

		} // end if (started in star, and this is it)
		else
		{
			// If the compare string isn't even long enough to start with this
			// segment, it can't match.  The (int) is just to avoid the naive
			// compiler warning.
			if ((int) strlen(szCompareString) < iNextStar - iStarPos)
			{
				break;
			} // end if (there's not enough room)

			CopyMemory(pszTempWildcard, szWildcardString + iStarPos,
						iNextStar - iStarPos);
			pszTempWildcard[iNextStar - iStarPos] = '\0'; // make sure the string ends


			// Handle not starting with a star.
			if (iStarPos == 0)
			{
				CopyMemory(pszTempCompare, szCompareString,
							iNextStar - iStarPos);
				pszTempCompare[iNextStar - iStarPos] = '\0'; // make sure the string ends


				// Loop through the section of the string to compare and convert
				// all characters in the temporary comparison buffer where there
				// was a question mark in the wildcard string into question marks
				// too.  This will cause the string comparison routine to match.

				iQuestionPos = 0;
				do
				{
					iQuestionPos = StringContainsChar(pszTempWildcard, '?', TRUE, iQuestionPos);

					// No more question marks?  Okay, we're done.
					if (iQuestionPos < 0)
						break;

					// This is destructive, but that's what we have the temp buffer
					// for.
					pszTempCompare[iQuestionPos] = '?';

					iQuestionPos++; // skip to the next character
				} // end do (while there are question marks)
				while (TRUE);

				// If these first segments don't match, the whole thing doesn't.
				if (fMatchCase)
				{
					if (strcmp(pszTempCompare, pszTempWildcard) != 0)
						break;
				} // end if (should match case)
				else
				{
					if (! StringCmpNoCase(pszTempCompare, pszTempWildcard))
						break;
				} // end else (don't match case)
			} // end if (this is the first star)
			else
			{
				//BUGBUG This probably could still be improved.  I haven't thought
				//		 it through, but I have this nagging feeling like the
				//		 logic here could be tricked.
				BOOL	fMatch;
				int		iStringLen;
				int		iSubStringLen;
				int		i;
				int		iDiffOffset;
				char*	pcCurrentString;
				char*	pcCurrentSubstring;
				

				strcpy(pszTempCompare, szCompareString + iCurrentComparePos);

				iStringLen = strlen(pszTempCompare);
				iSubStringLen = strlen(pszTempWildcard);


				if (! fMatchCase)
				{
					_strlwr(pszTempCompare);
					_strlwr(pszTempWildcard);
				} // end else (case isn't important)

				// Initialize the offset pointers.
				pcCurrentString = pszTempCompare;
				pcCurrentSubstring = pszTempWildcard;



				i = 0;
				fMatch = FALSE;
				// Try starting at every character in the string up to the length of
				// the string minus the length of the substring.  We can stop at
				// that point because if we haven't gotten into the matching
				// characters (inner) while loop, we'll never be able to succeed;
				// we'll hit the end of the main string before hitting the end of
				// the sub string.
				while (i <= iStringLen - iSubStringLen)
				{
					// Reset our current offset so if we travel anywhere in the
					// inner while loop, we can go back that many characters if it
					// ends up failing to match.
					iDiffOffset = 0;

					// Question marks in the substring (wildcard) count as a
					// matched character...
					while (((*pcCurrentString) == (*pcCurrentSubstring)) ||
							((*pcCurrentSubstring) == '?'))
					{
						pcCurrentString++;
						pcCurrentSubstring++;
						iDiffOffset++;

						// If that put us at the end of the substring, we're done.
						if ((*pcCurrentSubstring) == '\0')
						{
							// Move the compare spot after this found substring
							iCurrentComparePos += i + strlen(pszTempWildcard);
							fMatch = TRUE;
							break;
						} // end if (they match completely)
					} // end while (the current characters still match)

					if (fMatch)
						break;

					// If we got here, we didn't match the rest of the string, so reset it
					pcCurrentString -= iDiffOffset;
					pcCurrentSubstring -= iDiffOffset; // should put us back to 0 offset

					i++;
					pcCurrentString++; // move to next character to start
				} // end while (we aren't at the end of the usable string)

				// If we didn't find a match, we're done.
				if (! fMatch)
					break;
			} // end else (this is not the first star)

			// If there's nothing after this star, then we match.
			if (szWildcardString[iNextStar + 1] == '\0')
			{
				fResult = TRUE;
				break;
			} // end if (no more string left)
		} // end else (not looking at starting star)

		iStarPos = iNextStar + 1;
	} // end do (while haven't finished match or failed at some point)
	while (TRUE);


DONE:

	if (pszTempWildcard != NULL)
	{
		LocalFree(pszTempWildcard);
		pszTempWildcard = NULL;
	} // end if (allocated buffer)

	if (pszTempCompare != NULL)
	{
		LocalFree(pszTempCompare);
		pszTempCompare = NULL;
	} // end if (allocated buffer)


	// If we have to invert the result, do it,
	if (fInvert)
		fResult = (fResult) ? FALSE : TRUE;

	return (fResult);
} // StringMatchesWithWildcard
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringContainsString()"
//==================================================================================
// StringContainsString
//----------------------------------------------------------------------------------
//
// Description: Returns the index of the place where szSubstring begins (starting
//				the search at index iPos) inside szString, -1 otherwise. 
//
// Arguments:
//	char* szString		The string to search.
//	char* szSubstring	Character sequence to look for.
//	BOOL fMatchCase		Whether case is important or not.
//	int iPos			Location to start looking (0 for beginning).
//
// Returns: The starting location of the string or -1 if not found.
//==================================================================================
int StringContainsString(char* szString, char* szSubstring, BOOL fMatchCase, int iPos)
{
	int		iResult = -1;
	int		iStringLen;
	int		iSubStringLen;
	char*	pszLowerString = NULL;
	char*	pszLowerSubstring = NULL;
	int		i;
	int		iDiffOffset;
	char*	pcCurrentString;
	char*	pcCurrentSubstring;
	
	
	iStringLen = strlen(szString);
	iSubStringLen = strlen(szSubstring);

	// If the remainder of string we're testing is shorter than the substring, it
	// can't possibly contain the substring.
	if ((iStringLen - iPos) < iSubStringLen)
		goto DONE;
	

	// None of this empty substring stuff.
	if (iSubStringLen < 1)
		goto DONE;


	if (fMatchCase)
	{
		// Initialize the offset pointers.
		pcCurrentString = szString + iPos;
		pcCurrentSubstring = szSubstring;
	} // end if (case is important)
	else
	{
		// Copy the lower case main string
		pszLowerString = (char*) LocalAlloc(LPTR, (iStringLen - iPos + 1));
		if (pszLowerString == NULL)
			goto DONE;

		CopyMemory(pszLowerString, szString + iPos, iStringLen - iPos + 1);

		_strlwr(pszLowerString);


		// Copy the lower case sub string
		pszLowerSubstring = (char*) LocalAlloc(LPTR, (iSubStringLen + 1));
		if (pszLowerSubstring == NULL)
			goto DONE;

		CopyMemory(pszLowerSubstring, szSubstring, iSubStringLen + 1);

		_strlwr(pszLowerSubstring);


		// Initialize the offset pointers.
		pcCurrentString = pszLowerString;
		pcCurrentSubstring = pszLowerSubstring;
	} // end else (case isn't important)



	i = 0;
	// Try starting at every character in the string up to the length of the string
	// minus the length of the substring.  We can stop at that point because if we
	// haven't gotten into the matching characters (inner) while loop, we'll never
	// be able to succeed; we'll hit the end of the main string before hitting the
	// end of the sub string.
	while (i <= iStringLen - iPos - iSubStringLen)
	{
		// Reset our current offset so if we travel anywhere in the inner while
		// loop, we can go back that many characters if it ends up failing to match.
		iDiffOffset = 0;

		while ((*pcCurrentString) == (*pcCurrentSubstring))
		{
			pcCurrentString++;
			pcCurrentSubstring++;
			iDiffOffset++;

			// If that put us at the end of the substring, we're done.
			if ((*pcCurrentSubstring) == '\0')
			{
				iResult = i + iPos;
				goto DONE;
			} // end if (they match completely)
		} // end while (the current characters still match)

		// If we got here, we didn't match the rest of the string, so reset it
		pcCurrentString -= iDiffOffset;
		pcCurrentSubstring -= iDiffOffset; // should put us back to 0 offset

		i++;
		pcCurrentString++; // move to next character to start
	} // end while (we aren't at the end of the usable string)

DONE:

	if (pszLowerString != NULL)
	{
		LocalFree(pszLowerString);
		pszLowerString = NULL;
	} // end if (there's a lower case string)

	if (pszLowerSubstring != NULL)
	{
		LocalFree(pszLowerSubstring);
		pszLowerSubstring = NULL;
	} // end if (there's a lower case substring)
	
	return (iResult);
} // StringContainsString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringIsTrue()"
//==================================================================================
// StringIsTrue
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the string is not all "0"'s, "false" or "off",
//				case-insensitive.  Otherwise this returns FALSE.
//
// Arguments:
//	char* szString	String to check.
//
// Returns: TRUE if the string is anything but the textual representations of FALSE.
//==================================================================================
BOOL StringIsTrue(char* szString)
{
	BOOL	fResult = FALSE;
	char*	pszTemp = NULL;
	char*	pcCurrent = NULL;



	pszTemp = (char*) LocalAlloc(LPTR, (strlen(szString) + 1));
	if (pszTemp == NULL)
		goto DONE;

	strcpy(pszTemp, szString);

	// Make the string lower case
	_strlwr(pszTemp);

	if (strcmp(pszTemp, "false") == 0)
		goto DONE;

	if (strcmp(pszTemp, "off") == 0)
		goto DONE;

	// Search it to see if it's all zeros
	pcCurrent = pszTemp;
	while ((*pcCurrent) == '0')
	{
		pcCurrent++;

		// If moving put us at the end of the string, it contains all zeros,
		// so we return false
		if ((*pcCurrent) == '\0')
			goto DONE;
	} // end while (the current character is a zero)


	// If we got here, we didn't contain any of the textual representations of
	// FALSE, and there were no errors.  So let's go.
	fResult = TRUE;


DONE:

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated string)

	return (fResult);
} // StringIsTrue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetKey()"
//==================================================================================
// StringGetKey
//----------------------------------------------------------------------------------
//
// Description: Copies the key into the passed in result string, or sets it to the
//				empty string ("") if could not get the key.
//
// Arguments:
//	char* szString		String to retrieve key from.
//	char* szResult		String to place key name into.
//
// Returns: None.
//==================================================================================
void StringGetKey(char* szString, char* szResult)
{
	int		iEqualLoc = -1;
	char*	pszKeyStart = NULL;


	strcpy(szResult, "");

	pszKeyStart = szString;

	// Loop past any white space until we hit something.  If we hit the end of the
	// string, then bail.
	while ((pszKeyStart[0] == ' ') ||
			(pszKeyStart[0] == '\t'))
	{
		if (pszKeyStart[0] == '\0')
			return;

		pszKeyStart++;
	} // end while (there's white space)

	iEqualLoc = StringContainsChar(pszKeyStart, '=', FALSE, 0);

	if (iEqualLoc < 1)
		return;

	CopyMemory(szResult, pszKeyStart, iEqualLoc);
	szResult[iEqualLoc] = '\0'; // terminate the string there
	
	// Clean up any trailing whitespace
	StringPopTrailingChars(szResult, " \t", false);

	return;
} // StringGetKey
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetKeyValue()"
//==================================================================================
// StringGetKeyValue
//----------------------------------------------------------------------------------
//
// Description: Returns the a pointer to the first non-whitespace character after
//				the first equal sign in the string.  If no equal sign was found or
//				there are no non-whitespace characters after it, then NULL is
//				returned.
//				Note that the pointer returned refers to the string passed in, so
//				freeing the source string also invalidates the key value offset
//				pointer returned.
//
// Arguments:
//	char* szString		String to retrieve key value from.
//
// Returns: Pointer to the value of key in the string, NULL if none.
//==================================================================================
char* StringGetKeyValue(char* szString)
{
	int		iEqualLoc = -1;
	char*	pszValue = NULL;


	iEqualLoc = StringContainsChar(szString, '=', false, 0);

	if (iEqualLoc < 0)
		return (NULL);

	// Okay, we have a starting point (move past the equal sign character).
	pszValue = szString + iEqualLoc + 1;
	
	// Loop past any white space until we hit something.  If we hit the end of the
	// string, then bail.
	while ((pszValue[0] == ' ') ||
			(pszValue[0] == '\t'))
	{
		if (pszValue[0] == '\0')
			return (NULL);

		pszValue++;
	} // end while (there's white space)

	return (pszValue);
} // StringGetKeyValue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringIsKey()"
//==================================================================================
// StringIsKey
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the given string begins with the key name specified,
//				case insensitive and ignoring whitespace, FALSE otherwise.
//
// Arguments:
//	char* szString		String to check.
//	char* szKeyName		Key to check if we match.
//
// Returns: TRUE if we matched the key, FALSE otherwise.
//==================================================================================
BOOL StringIsKey(char* szString, char* szKeyName)
{
	BOOL	fResult = FALSE;
	char*	pszTemp = NULL;
	char*	pszMyKeyName = NULL;
	char*	pszMyValue = NULL;



	// Make the passed in key name case insensitive
	pszTemp = (char*) LocalAlloc(LPTR, (strlen(szKeyName) + 1));
	if (pszTemp == NULL)
		goto DONE;
	strcpy(pszTemp, szKeyName);
	_strlwr(pszTemp);

	// Remove any leading white space
	StringPopLeadingChars(pszTemp, " \t", FALSE);


	// Make our entire string case insensitive
	pszMyValue = (char*) LocalAlloc(LPTR, (strlen(szString) + 1));
	if (pszMyValue == NULL)
		goto DONE;
	strcpy(pszMyValue, szString);
	_strlwr(pszMyValue);

	// Remove any leading white space
	StringPopLeadingChars(pszMyValue, " \t", FALSE);

	pszMyKeyName = (char*) LocalAlloc(LPTR, (strlen(pszMyValue) + 1));
	if (pszMyKeyName == NULL)
		goto DONE;
	ZeroMemory(pszMyKeyName, strlen(pszMyValue) + 1);
	
	StringGetKey(pszMyValue, pszMyKeyName);

	// Now try to compare key names
	if (strcmp(pszMyKeyName, pszTemp) == 0)
		fResult = TRUE;



DONE:

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated a temp string)

	if (pszMyKeyName != NULL)
	{
		LocalFree(pszMyKeyName);
		pszMyKeyName = NULL;
	} // end if (allocated a name string)

	if (pszMyValue != NULL)
	{
		LocalFree(pszMyValue);
		pszMyValue = NULL;
	} // end if (allocated a value string)

	return (fResult);
} // StringIsKey
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringIsValueTrue()"
//==================================================================================
// StringIsValueTrue
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the string's key value exists and is not all "0"'s,
//				"false" or "off", case-insensitive.  Otherwise this returns ;.
//
// Arguments:
//	char* szString	String with value to check.
//
// Returns: TRUE if the string value is anything but the textual representations of
//			false.
//==================================================================================
BOOL StringIsValueTrue(char* szString)
{
	return (StringIsTrue(StringGetKeyValue(szString)));
} // StringIsValueTrue
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringIsCharBackslashEscaped()"
//==================================================================================
// StringIsCharBackslashEscaped
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the character pointed to is preceded by a backslash
//				(or an odd multiple of backslashes), indicating it is escaped.
//
// Arguments:
//	char* szString	String with character to check.
//	char* pcChar	Pointer to character within string to check.
//
// Returns: TRUE if the character is escaped, FALSE otherwise.
//==================================================================================
BOOL StringIsCharBackslashEscaped(char* szString, char* pcChar)
{
	char*	pcCurrent = pcChar - 1;


	if ((szString == NULL) || (pcChar == NULL))
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Either the string or character pointer is NULL!", 0);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (FALSE);
	} // end if (got bad pointers)

	// Keep going back until we hit the start of the string or a non-backslash
	// character.
	while ((pcCurrent >= szString) && ((*pcCurrent) == '\\'))
	{
		pcCurrent--;
	} // end while (we haven't hit the start of the string)

	// If there's an odd number of backslashes, it means the character is escaped,
	// but we were 1 off already, we compare with 0 instead of 1.
	if (((pcChar - pcCurrent) % 2) == 0)
		return (TRUE);
	
	return (FALSE);
} // StringIsCharBackslashEscaped
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringPopLeadingChars()"
//==================================================================================
// StringPopLeadingChars
//----------------------------------------------------------------------------------
//
// Description: Takes the string passed to it and removes all the chars in the
//				szPopChars string (if any) from the front of the string.  Returns
//				the number of chars popped. 
//
// Arguments:
//	char* szString		String to modify.
//	char* szPopChars	Characters at beginning of string to remove.
//	BOOL fMatchCase		Whether the case of the characters is important or not.
//
// Returns: Number of characters removed.
//==================================================================================
int StringPopLeadingChars(char* szString, char* szPopChars, BOOL fMatchCase)
{
	char*	pszString;
	int		iNumPopped = 0;


	pszString = szString;
	while (StringContainsChar(szPopChars, szString[iNumPopped], fMatchCase, 0) != -1)
	{
		pszString += sizeof (char);
		iNumPopped++;
	} // end while (there are still chars to pop)
	if (iNumPopped == 0)	// if we did nothing
		return (0);			// get out of here now
	
	strcpy(szString, pszString);

	return (iNumPopped);
} // StringPopLeadingChars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringPopTrailingChars()"
//==================================================================================
// StringPopTrailingChars
//----------------------------------------------------------------------------------
//
// Description: Takes the string passed to it and removes all the chars in the
//				szPopChars string (if any) from the end of the string.  Returns
//				the number of chars popped. 
//
// Arguments:
//	char* szString		String to modify.
//	char* szPopChars	Characters at end of string to remove.
//	BOOL fMatchCase		Whether the case of the characters is important or not.
//
// Returns: Number of characters removed.
//==================================================================================
int StringPopTrailingChars(char* szString, char* szPopChars, BOOL fMatchCase)
{
	int		i;
	int		iLen;


	iLen = strlen(szString) - 1;

	// If it's an empty string, we're done.
	if (iLen < 0)
		return (0);

	i = iLen;
	while (StringContainsChar(szPopChars, szString[i], fMatchCase, 0) != -1)
	{
		i--;
	} // end while (there are still chars to pop)

	szString[i + 1] = '\0'; // terminate the string here

	return (iLen - i);
} // StringPopTrailingChars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringPrepend()"
//==================================================================================
// StringPrepend
//----------------------------------------------------------------------------------
//
// Description: Inserts the second parameter at the front of the first parameter. 
//
// Arguments:
//	char* szString		String to start with.
//	char* szPrefix		String to place in front.
//
// Returns: None.
//==================================================================================
void StringPrepend(char* szString, char* szPrefix)
{
	// This method seems more optimal, but some compilers don't generate the code
	// for this correctly.
	/*
	// Move everything in the current string down (working backwards to avoid
	// overwriting).  +1 is to include NULL termination
	CopyMemory(szString + strlen(szPrefix), szString, (strlen(szString) + 1));
	*/


	char*	pcSource = szString + strlen(szString);
	char*	pcDest = szString + strlen(szString) + strlen(szPrefix);


	// Work backwards to avoid overwriting.
	do
	{
		(*pcDest) = (*pcSource);
		pcDest--;
		pcSource--;
	} // end do (while still more string left)
	while (pcSource >= szString);

	
	// Add in prefix
	CopyMemory(szString, szPrefix, strlen(szPrefix));
} // StringPrepend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringSplit()"
//==================================================================================
// StringSplit
//----------------------------------------------------------------------------------
//
// Description: Splits the past string into two strings, with the first string
//				getting the first iSplitPoint characters, and the second string
//				getting the remainder.  If the split point is out of bounds, this
//				returns FALSE.
//				If szFirst is NULL, that portion of the string is not copied
//				(obviously).  szLast cannot be NULL.
//				The last string can safely be the same as the source string.  Thus
//				the call StringSplit(szStringA, 5, szStringB, szStringA) essentially
//				pops off the first 5 characters of szStringA and saves them in
//				szStringB. 
//
// Arguments:
//	char* szString				String to split
//	unsigned int uiSplitPoint	Position in string to split at (zero based)
//	char* szFirst				String to store characters before split point.
//	char* szLast				String to store characters after split point.
//
// Returns: TRUE if successful, FALSE otherwise.
//==================================================================================
BOOL StringSplit(char* szString, unsigned int uiSplitPoint, char* szFirst,
				char* szLast)
{
	// Don't want to initialize these strings because they could be the same
	// as the source string.
	//strcpy(szFirst, "");
	//strcpy(szLast, "");

	if (uiSplitPoint > strlen(szString)) // invalid point
		return (FALSE); // get out of here

	if (szLast == NULL)
		return (FALSE); // get out of here

	if (szFirst != NULL)
	{
		CopyMemory(szFirst, szString, uiSplitPoint * sizeof (char));
		szFirst[uiSplitPoint] = '\0'; // null terminate.
	} // end if (the caller cares about the first part of the string)

	//if (fIncludeSplitChar)
		strcpy(szLast, szString + (sizeof (char) * uiSplitPoint));
	//else
	//	strcpy(szLast, szString + (sizeof (char) * (uiSplitPoint + 1)));

	return (TRUE);
} // StringSplit
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringSplitIntoFixedFields()"
//==================================================================================
// StringSplitIntoFixedFields
//----------------------------------------------------------------------------------
//
// Description: Splits the passed in string into fields separated by one or more of
//				any of the characters in szSplitChars.  The caller must allocate
//				the results string array (i.e. char  resultArray[5][256]) and
//				pass in the dimensions of this array in the last two parameters,
//				(i.e. 5, 256).  Note that this function may not actually find
//				iMaxResults fields, but if there are at least that many, then
//				elements 0 through (iMaxResults - 2) are the first
//				(iMaxResults - 1) fields found, and the last element contains the
//				rest of the string with leading and trailing split chars removed,
//				but truncated to fit in the array if necessary. 
//
// Arguments:
//	char* szString					The string to split.
//	char* szSplitChars				String containing all the characters that
//									delimit fields.
//	char* resultArray				An array of strings to store results in.
//	unsigned int uiMaxResults		How many strings the result array can hold.
//	unsigned int uiStringLength		How long the strings in the result array are.
//
// Returns: The number of fields the string was split into, 0 if no non-split
//			characters were found.
//==================================================================================
unsigned int StringSplitIntoFixedFields(char* szString, char* szSplitChars,
										char* resultArray, unsigned int uiMaxResults,
										unsigned int uiStringLength)
{
	char*			pszCurrent = szString;
	char*			pszFieldStart = szString;
	char*			pszDest = NULL;
	unsigned int	uiFieldSize = 0;
	unsigned int	uiNumFields = 0;
	BOOL			fInField = FALSE;


	while (uiNumFields < uiMaxResults)
	{
		// If we're now on a delimiter or we've reached the maximum field size, or
		// we've hit the end of the string.
		if ((StringContainsChar(szSplitChars, (*pszCurrent), FALSE, 0) != -1) ||
			(uiFieldSize >= uiStringLength - 1) ||
			((*pszCurrent) == '\0'))
		{
			if (fInField)
			{
				pszDest = resultArray + ((uiNumFields - 1) * uiStringLength);
				CopyMemory(pszDest, pszFieldStart, uiFieldSize * sizeof (char));

				// Now make sure the string is terminated
				pszDest[uiFieldSize] = '\0';

				fInField = FALSE;
				uiFieldSize = 0;
			} // end if (we were in a field)
		} // end if (this is a field delimiter)
		else
		{
			if (! fInField)
			{
				fInField = TRUE;
				uiNumFields++;
				uiFieldSize = 1;
				pszFieldStart = pszCurrent;
			} // end if (we weren't in a field)
			else
				uiFieldSize++;
		} // end else (this is part of a field)

		// If we're at the end of the string, we're done.
		if ((*pszCurrent) == '\0')
			break;

		pszCurrent++;
	} // end while (there's room for more fields)

	// If we stopped looping because we ran out of room for fields
	if (uiNumFields == uiMaxResults)
	{
		pszDest = resultArray + ((uiNumFields - 1) * uiStringLength);
		if (strlen(pszFieldStart) < uiStringLength)
			uiFieldSize = strlen(pszFieldStart);
		else
			uiFieldSize = uiStringLength - 1;

		CopyMemory(pszDest, pszFieldStart, (uiFieldSize * sizeof (char)));

		// Now make sure the string is terminated
		pszDest[uiFieldSize] = '\0';
	} // end if (ran out of room)

	return (uiNumFields);
} // StringSplitIntoFixedFields
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringSplitIntoFields()"
//==================================================================================
// StringSplitIntoFields
//----------------------------------------------------------------------------------
//
// Description: Splits the passed in string into fields separated by one or more of
//				any of the characters in szSplitChars.  The result buffer is filled
//				with the each of the fields' strings (including NULL termination)
//				concatenated.
//				If pszResultBuffer is NULL, then the size required is placed in
//				pdwResultBufferSize.  Note that the buffer size required will never
//				be larger than the original string.
//				Also note that the size is in number-of-characters, including NULL
//				terminators.
//
// Arguments:
//	char* szString					The string to split.
//	char* szSplitChars				String containing all the characters that
//									delimit fields.
//	char* pszResultBuffer			Pointer to buffer that holds concatentated
//									fields, or NULL to retrieve size.
//	DWORD* pdwResultBufferSize		Pointer to size of preceding buffer, or place to
//									store size required.  If this is NULL, it is
//									assumed the buffer exists and is the right size.
//
// Returns: The number of fields found, zero if an error occurred.
//==================================================================================
DWORD StringSplitIntoFields(char* szString, char* szSplitChars,
							char* pszResultBuffer, DWORD* pdwResultBufferSize)
{
	char*	pcCurrent = szString;
	char*	pcDest = pszResultBuffer;
	BOOL	fInField = FALSE;
	DWORD	dwNumFields = 0;
	DWORD	dwSizeRequired = 0;


	if ((pszResultBuffer == NULL) && (pdwResultBufferSize))
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Both parameters are NULL!", 0);
#endif // ! NO_TNCOMMON_DEBUG_SPEW
		return (0);
	} // end if (both parameters are NULL)

	while ((*pcCurrent) != '\0')
	{
		if (StringContainsChar(szSplitChars, (*pcCurrent), FALSE, 0) == -1)
		{
			// If we weren't in a field, we are now.
			if (! fInField)
			{
				dwNumFields++;
				fInField = TRUE;
			} // end if (we weren't in a field before)

			// Copy the character or at least include it in our size requirement.
			if (pszResultBuffer != NULL)
			{
				(*pcDest) = (*pcCurrent);
				pcDest++; // move the destination character pointer
			} // end if (there's a buffer to copy to)
			else
				dwSizeRequired++;
		} // end if (it's not a split char)
		else
		{
			// If we were in a field, we need to end it.
			if (fInField)
			{
				if (pszResultBuffer != NULL)
				{
					(*pcDest) = '\0';
					pcDest++; // move the destination character pointer
				} // end if (there's a buffer to copy to)
				else
					dwSizeRequired++;

				fInField = FALSE;
			} // end else (we were in a field)
		} // end else (it's a split char)

		pcCurrent++; // move the current character pointer
	} // end while (we're not at the end of the string)

	if (pszResultBuffer != NULL)
	{
		if (fInField)
			(*pcDest) = '\0'; // make sure the last string is terminated here
	} // end if (there's a buffer to copy to)
	else
	{
		if (fInField)
			dwSizeRequired++; // include final string's termination

		if (pdwResultBufferSize != NULL)
			(*pdwResultBufferSize) = dwSizeRequired;
	} // end else (the caller just wants the size)

	return (dwNumFields);
} // StringSplitIntoFields
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetFieldPtr()"
//==================================================================================
// StringGetFieldPtr
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the field at the given zero-based index in a
//				concatenated field buffer (like that generated from
//				StringSplitIntoFields).
//				It is up to the caller to make sure we are not walking off the end
//				of the buffer.
//
// Arguments:
//	char* szFieldsBuffer	A buffer previously generated by StringSplitIntoFields.
//	DWORD dwFieldNum		The number of fields in the previous buffer.
//
// Returns: The number of fields found.
//==================================================================================
char* StringGetFieldPtr(char* szFieldsBuffer, DWORD dwFieldNum)
{
	char*	pszCurrent = szFieldsBuffer;
	DWORD	dwCurrentNum = 0;


	while (dwCurrentNum < dwFieldNum)
	{
		pszCurrent += strlen(pszCurrent) + 1; // move past the current field
		dwCurrentNum++;
	} // end while (we haven't reached the field yet)

	return (pszCurrent);
} // StringGetFieldPtr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetBetween()"
//==================================================================================
// StringGetBetween
//----------------------------------------------------------------------------------
//
// Description: This retrieves all characters between the first occurrences of
//				szStartToken and pszEndToken.
//
//				If pszEndToken is NULL, then no ending token is searched for.
//
//				The search is started at the index pointed to by piPos.  Upon
//				completion of this function, that value will be set to -1 if the
//				start token was not found, or else the location at which the first
//				character was removed.
//
//				If pszOutside is not NULL, the remaining string after the
//				characters between the tokens are removed is copied there.  If
//				pszInside is not NULL, then the characters between the tokens are
//				copied to that string.  One or the other of these can safely be the
//				source string.
//
//				If pbUnfinished is not NULL, the boolean it points to will be set
//				to TRUE if the string ended before the end token was found.  Note
//				that this will always be TRUE if pszEndToken is NULL.
//
// Arguments:
//	char* szSource					Place to store the characters removed.
//	char* szStartToken				String that designates the start of characters
//									to be removed.
//	char* pszEndToken				String that designates the end of characters to
//									be removed (optional).
//	BOOL fMatchCase					Whether the cases of the tokens are important
//									when searching for them.
//	BOOL fKeepTokensInOutside		Whether to include the tokens in the remaining
//									outside string or not.
//	BOOL fKeepTokensInInside		Whether to include the tokens in the inside
//									string or not.
//	BOOL fCheckForNonEscapedStart	Should be TRUE if the first character in the
//									start token doesn't count as a match if it is
//									preceded by a backslash character ('\').
//	BOOL fCheckForNonEscapedEnd		Should be TRUE if the first character in the
//									end token doesn't count as a match if it is
//									preceded by a backslash character ('\').
//	int* piPos						Pointer to position to start looking and return
//									starting index of result in.
//	char* pszOutside				Optional place to store the remaining string
//									after the characters between the tokens have
//									been removed.
//	char* pszInside					Optional place to store the characters in
//									between the tokens.
//	BOOL* pfUnfinished				Optional pointer to boolean that will be set to
//									TRUE if the string ended before the end token
//									was found.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT StringGetBetween(char* szSource, char* szStartToken, char* pszEndToken,
						BOOL fMatchCase, BOOL fKeepTokensInOutside,
						BOOL fKeepTokensInInside, BOOL fCheckForNonEscapedStart,
						BOOL fCheckForNonEscapedEnd, int* piPos, char* pszOutside,
						char* pszInside, BOOL* pfUnfinished)
{
	HRESULT		hr = S_OK;
	BOOL		fSearchAgain = FALSE;
	int			iEndLoc = -1;
	char*		pszTempOutside = NULL;
	char*		pszTempInside = NULL;


	do
	{
		(*piPos) = StringContainsString(szSource, szStartToken, fMatchCase, (*piPos));
		if ((*piPos) < 0) // if we didn't find the start token
		{
			goto DONE;
		} // end if (didn't find start token)

		if (fCheckForNonEscapedStart)
		{
			if (StringIsCharBackslashEscaped(szSource, szSource + (*piPos)))
			{
				fSearchAgain = TRUE;
				(*piPos) += 1; // move on to the next character after this false match
			} // end if (we need to search again)
			else
				fSearchAgain = FALSE;
		} // end if (we should make sure the first character is not escaped)
	} // end do (while we should search again for the character)
	while (fSearchAgain);


	// If we should search for an end token, do it
	if (pszEndToken != NULL)
	{
		// Start looking after the start token
		iEndLoc = (*piPos) + strlen(szStartToken);

		do
		{
			iEndLoc = StringContainsString(szSource, pszEndToken, fMatchCase,
											iEndLoc);
			// If we hit the end of the string, stop checking
			if (iEndLoc < 0)
				break;

			if (fCheckForNonEscapedEnd)
			{
				if (StringIsCharBackslashEscaped(szSource, szSource + iEndLoc))
				{
					fSearchAgain = TRUE;
					iEndLoc += 1; // move on to the next character after this false match
				} // end if (we need to search again)
				else
					fSearchAgain = FALSE;
			} // end if (we should make sure the first character is not escaped)
		} // end do (while we should search again for the character)
		while (fSearchAgain);
	} // end if (we should search for an end token)


	// If we hit the end of the string before finding the end token, mark it as
	// an unfinished item.
	if ((iEndLoc < 0) && (pfUnfinished != NULL))
		(*pfUnfinished) = TRUE;


	if (pszOutside != NULL)
	{
		pszTempOutside = (char*) LocalAlloc(LPTR, ((strlen(szSource) + 1) * sizeof (char))); // include NULL character
		if (pszTempOutside == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		if (fKeepTokensInOutside)
			CopyMemory(pszTempOutside, szSource, ((*piPos) + strlen(szStartToken)) * sizeof (char));
		else
			CopyMemory(pszTempOutside, szSource, (*piPos) * sizeof (char));

		if (iEndLoc >= 0)
		{
			if (fKeepTokensInOutside)
				strcat(pszTempOutside, szSource + iEndLoc);
			else
				strcat(pszTempOutside, szSource + iEndLoc + strlen(pszEndToken));
		} // end if (we found the end token)
	} // end if (we should do a destination string)

	if (pszInside != NULL)
	{
		pszTempInside = (char*) LocalAlloc(LPTR, ((strlen(szSource) + 1) * sizeof (char))); // include NULL character
		if (pszTempInside == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		if (iEndLoc >= 0)
		{
			if (fKeepTokensInInside)
				CopyMemory(pszTempInside, szSource + (*piPos),
						(iEndLoc - (*piPos) + strlen(pszEndToken)) * sizeof (char));
			else
				CopyMemory(pszTempInside, szSource + (*piPos) + strlen(szStartToken),
						(iEndLoc - (*piPos) - 1) * sizeof (char));
		} // end if (we found the end token)
		else
		{
			if (fKeepTokensInInside)
				strcpy(pszTempInside, szSource + (*piPos));
			else
				strcpy(pszTempInside, szSource + (*piPos) + strlen(szStartToken));
		} // end else (we didn't find the end token)
	} // end if (we should do a removed string)


DONE:

	if (pszTempOutside != NULL)
	{
		strcpy(pszOutside, pszTempOutside);
		LocalFree(pszTempOutside);
		pszTempOutside = NULL;
	} // end if (we did a destination string)

	if (pszTempInside != NULL)
	{
		strcpy(pszInside, pszTempInside);
		LocalFree(pszTempInside);
		pszTempInside = NULL;
	} // end if (we did a remove string)

	return (hr);
} // StringGetBetween
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringReplaceAll()"
//==================================================================================
// StringReplaceAll
//----------------------------------------------------------------------------------
//
// Description: Replaces all occurrences of the search string with the replace
//				string, starting at the location given by iPos. 
//
// Arguments:
//	char* szString				The string to search & replace in.
//	char* szSearchString		Character sequence that should be replaced if found.
//	char* szReplaceString		Character sequence to replace found items with.
//	BOOL fMatchCase				Whether case is important when searching.
//	int iPos					Location to start looking.
//	unsigned int uiStringSize	Size of szString's buffer, including zero
//								terminator.
//
// Returns: The number of occurrences found and replaced.
//==================================================================================
int StringReplaceAll(char* szString, char* szSearchString, char* szReplaceString,
					 BOOL fMatchCase, int iPos, unsigned int uiStringSize)
{
	int		iNum = 0;
	int		iLoc = 0;
	char*	szFirst;
	char*	szLast;


	szFirst = (char*) LocalAlloc(LPTR, (sizeof (char) * uiStringSize));
	if (szFirst == NULL)
		goto DONE;

	szLast = (char*) LocalAlloc(LPTR, (sizeof (char) * uiStringSize));
	if (szLast == NULL)
		goto DONE;

	// While there's another occurence of the search string and we have
	// enough room in the string to replace it.
	while (((iLoc = StringContainsString(szString, szSearchString, fMatchCase, iPos)) >= 0) &&
		(strlen(szString) - strlen(szSearchString) + strlen(szReplaceString) < uiStringSize))
	{
		ZeroMemory(szFirst, sizeof (char) * uiStringSize);
		CopyMemory(szFirst, szString, sizeof (char) * iLoc);

		ZeroMemory(szLast, sizeof (char) * uiStringSize);
		CopyMemory(szLast, szString + sizeof (char) * (iLoc + strlen(szSearchString)),
				sizeof (char) * (strlen(szString) - strlen(szSearchString) - iLoc));

		strcpy(szString, szFirst);
		strcat(szString, szReplaceString);
		strcat(szString, szLast);

		iNum++;

		iPos = iLoc + strlen(szReplaceString);
	} // end while (there are still instances of the search string)

DONE:

	if (szFirst != NULL)
		LocalFree(szFirst);
	szFirst = NULL;

	if (szLast != NULL)
		LocalFree(szLast);
	szLast = NULL;

	return (iNum);
} // StringReplaceAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringToInt()"
//==================================================================================
// StringToInt
//----------------------------------------------------------------------------------
//
// Description: Takes the passed string which holds an integer in base ten and
//				converts it into an integer.  It ignores any non-English number
//				characters.
//
// Arguments:
//	char* szString		Textual representation of value.
//
// Returns: The value of the string converted into an integer.
//==================================================================================
int StringToInt(char* szString)
{
	int		iValue;
	DWORD	dwTemp;
	BOOL	fNegative = FALSE;


	iValue = 0;
	for(dwTemp = 0; dwTemp < strlen(szString); dwTemp++)
	{
		// If the first character is a - sign, note that.
		if ((dwTemp == 0) && (szString[dwTemp] == '-'))
			fNegative = TRUE;

		iValue = iValue * 10; // shift the decimal place
		switch (szString[dwTemp])
		{
			case '0':
			  break; // don't add anything

			case '1':
				iValue += 1;
			  break;

			case '2':
				iValue += 2;
			  break;

			case '3':
				iValue += 3;
			  break;

			case '4':
				iValue += 4;
			  break;

			case '5':
				iValue += 5;
			  break;

			case '6':
				iValue += 6;
			  break;

			case '7':
				iValue += 7;
			  break;

			case '8':
				iValue += 8;
			  break;

			case '9':
				iValue += 9;
			  break;

			default:
				iValue = iValue / 10; // shift the decimal place back
			  break; // we got a wacky character
		} // end switch (on the letter)
	} // end for (loop through each letter in the string)

	if (fNegative)
		return (-1 * iValue);

	return (iValue);
} // StringToInt
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringNumDWordDigits()"
//==================================================================================
// StringNumDWordDigits
//----------------------------------------------------------------------------------
//
// Description: Returns the number of decimal digits a given DWORD has.
//
// Arguments:
//	DWORD dwValue	DWORD to count digits.
//
// Returns: The number of decimal digits the DWORD has.
//==================================================================================
DWORD StringNumDWordDigits(DWORD dwValue)
{
	DWORD	dwDigits = 1;

	
	while (dwValue >= 10)
	{
		dwValue = dwValue / 10;
		dwDigits++;
	} // end while (there's still a tens place)
	
	return (dwDigits);
} // StringNumDWordDigits
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringToDWord()"
//==================================================================================
// StringToDWord
//----------------------------------------------------------------------------------
//
// Description: Takes the passed string which holds a positive integer in base ten
//				and converts it into a DWORD.  It ignores any non-English number
//				characters.
//
// Arguments:
//	char* szString		Textual representation of value.
//
// Returns: The value of the string converted into a DWORD.
//==================================================================================
DWORD StringToDWord(char* szString)
{
	DWORD	dwValue;
	DWORD	dwTemp;


	dwValue = 0;
	for(dwTemp = 0; dwTemp < strlen(szString); dwTemp++)
	{
		dwValue = dwValue * 10; // shift the decimal place
		switch (szString[dwTemp])
		{
			case '0':
			  break; // don't add anything
			case '1':
				dwValue += 1;
			  break;
			case '2':
				dwValue += 2;
			  break;
			case '3':
				dwValue += 3;
			  break;
			case '4':
				dwValue += 4;
			  break;
			case '5':
				dwValue += 5;
			  break;
			case '6':
				dwValue += 6;
			  break;
			case '7':
				dwValue += 7;
			  break;
			case '8':
				dwValue += 8;
			  break;
			case '9':
				dwValue += 9;
			  break;
			default:
				dwValue = dwValue / 10; // shift the decimal place back
			  break; // we got a wacky character
		} // end switch (on the letter)
	} // end for (loop through each letter in the string)

	return (dwValue);
} // StringToDWord
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringHexToDWord()"
//==================================================================================
// StringHexToDWord
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in string representation of a hexadecimal DWORD
//				to the actual DWORD value.  It ignores any non-English number
//				characters.
//
// Arguments:
//	char* szString		Textual representation of value.
//
// Returns: The value of the string converted into a DWORD.
//==================================================================================
DWORD StringHexToDWord(char* szString)
{
	DWORD	dwValue = 0;
	DWORD	dwTemp;


	// If the string starts with that "0x" prefix, we should move past that.
	if (StringStartsWith(szString, "0x", false))
		szString += 2;


	if ((strlen(szString) < 1) || (strlen(szString) > 8))
		return (0);


	dwValue = 0;
	for(dwTemp = 0; dwTemp < strlen(szString); dwTemp++)
	{
		dwValue *= 16; // shift the hexadecimal place
		switch (szString[dwTemp])
		{
			case '0':
			  break; // don't add anything
			case '1':
				dwValue += 1;
			  break;
			case '2':
				dwValue += 2;
			  break;
			case '3':
				dwValue += 3;
			  break;
			case '4':
				dwValue += 4;
			  break;
			case '5':
				dwValue += 5;
			  break;
			case '6':
				dwValue += 6;
			  break;
			case '7':
				dwValue += 7;
			  break;
			case '8':
				dwValue += 8;
			  break;
			case '9':
				dwValue += 9;
			  break;
			case 'a':
			case 'A':
				dwValue += 10;
			  break;
			case 'b':
			case 'B':
				dwValue += 11;
			  break;
			case 'c':
			case 'C':
				dwValue += 12;
			  break;
			case 'd':
			case 'D':
				dwValue += 13;
			  break;
			case 'e':
			case 'E':
				dwValue += 14;
			  break;
			case 'f':
			case 'F':
				dwValue += 15;
			  break;
			default:
				dwValue = dwValue / 16; // shift the hexadecimal place back
			  break; // we got a wacky character
		} // end switch (on the letter)
	} // end for (loop through each letter in the string)

	return (dwValue);
} // StringHexToDWord
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringToGuid()"
//==================================================================================
// StringToGuid
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in string representation of a GUID to the actual
//				GUID. 
//
// Arguments:
//	char* szString			Textual representation of guid.
//	LPGUID pguidResult		Pointer to guid to store result in.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT StringToGuid(char* szString, LPGUID pguidResult)
{
	int		iOldPos = 0;
	int		iNewPos = 0;
	char	szSegment[9];
	DWORD	dwValue = 0;
	int		i;



	// Skip the beginning
	while ((szString[iOldPos] == ' ') ||
			(szString[iOldPos] == '\t') ||
			(szString[iOldPos] == '{'))
	{
		iOldPos++;
	} // end while (it starts with an ignore character)


	// Data1 = 1 DWORD

	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	// Make sure we've got 8 valid characters of data (assume high order zeroes if
	// it's fewer than 8 characters).
	if ((iNewPos < 0) || (iNewPos > (iOldPos + 9)))
		return (ERROR_INVALID_PARAMETER);


	ZeroMemory(szSegment, 9);
	CopyMemory(szSegment, szString + iOldPos, (iNewPos - iOldPos));

	pguidResult->Data1 = StringHexToDWord(szSegment);

	iOldPos = iNewPos + 1;



	// Data2 = 1 WORD

	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	// 4 characters.
	if ((iNewPos < 0) || (iNewPos > (iOldPos + 5)))
		return (ERROR_INVALID_PARAMETER);


	ZeroMemory(szSegment, 9);
	CopyMemory(szSegment, szString + iOldPos, (iNewPos - iOldPos));

	pguidResult->Data2 = (WORD) StringHexToDWord(szSegment);

	iOldPos = iNewPos + 1;



	// Data3 = 1 WORD

	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	// 4 characters.
	if ((iNewPos < 0) || (iNewPos > (iOldPos + 5)))
		return (ERROR_INVALID_PARAMETER);


	ZeroMemory(szSegment, 9);
	CopyMemory(szSegment, szString + iOldPos, (iNewPos - iOldPos));

	pguidResult->Data3 = (WORD) StringHexToDWord(szSegment);


	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	iOldPos = strlen(szString); // temp variable

	// Make sure there are enough single bytes at the end here
	if (iNewPos + 16 > iOldPos)
		return (ERROR_INVALID_PARAMETER);


	// Move past dash
	iNewPos++;

	// Data4 = 8 single bytes

	for(i = 0; i < 8; i++)
	{
		if (i == 2)
		{
			if (szString[iNewPos] != '-')
				return (ERROR_INVALID_PARAMETER);

			// If it is the dash, then we want to skip it
			iNewPos++;
		} // end if (we should be at a dash)

		ZeroMemory(szSegment, 9);
		CopyMemory(szSegment, szString + iNewPos, 2);

		pguidResult->Data4[i] = (BYTE) StringHexToDWord(szSegment);

		iNewPos += 2;
	} // end for (each of the 8 individual bytes)


	return (S_OK);
} // StringToGuid
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringDWordToIPAddress()"
//==================================================================================
// StringDWordToIPAddress
//----------------------------------------------------------------------------------
//
// Description: Converts a DWORD IP address into its textual representation.
//
// Arguments:
//	DWORD dwValue		DWORD containing IP address.
//	char* szResult		Buffer to store result.
//
// Returns: ?
//==================================================================================
void StringDWordToIPAddress(DWORD dwValue, char* szResult)
{
	BYTE	segment;
	int		i;
	int		offset = 0;

	strcpy(szResult, "");

	for (i = 0; i < 4; i++)
	{
		segment = (BYTE) (dwValue % 256);
		dwValue = (dwValue - segment) / 256;
		offset += wsprintf(szResult + offset, "%i.", segment); 
	} // end for (each segment)

	szResult[offset - 1] = '\0'; // get rid of last period and end the string.
} // StringDWordToIPAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringNumIntDigits()"
//==================================================================================
// StringNumIntDigits
//----------------------------------------------------------------------------------
//
// Description: Returns the number of decimal digits a given integer has.
//
// Arguments:
//	int iValue		int for which to count digits.
//
// Returns: The number of decimal digits the int has.
//==================================================================================
DWORD StringNumIntDigits(int iValue)
{
	DWORD	dwDigits = 1;


	if (iValue < 0)
		iValue = iValue * -1; // make sure it's a positive number
	
	while (iValue >= 10)
	{
		iValue = iValue / 10;
		dwDigits++;
	} // end while (there's still a tens place)
	
	return (dwDigits);
} // StringNumIntDigits
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringIntToZeroPaddedStr()"
//==================================================================================
// StringIntToZeroPaddedStr
//----------------------------------------------------------------------------------
//
// Description: Takes a number and pads the front with zeros if it is fewer than the
//				number of digits passed and returns the result in the passed string. 
//
// Arguments:
//	int iNum			Number to pad, if necessary.
//	int iDigits			Minimum number of digits needed.
//	char* szString		Buffer in which to store results.
//
// Returns: None.
//==================================================================================
void StringIntToZeroPaddedStr(int iNum, int iDigits, char* szString)
{
	char*	szTemp = NULL;
	int		i;
	strcpy(szString, "");

	szTemp = (char*) LocalAlloc(LPTR, ((iDigits + 1 + 1) * sizeof (char))); // + 1 for possible negative
	if (szTemp == NULL) // out of memory
		return;

	if (iNum < 0)
	{
		strcpy(szString, "-");
		iNum = iNum * -1;
		iDigits--; // negative sign takes away a digit
	} // end if (the number is negative)

	wsprintf(szTemp, "%i", iNum);

	for (i = strlen(szTemp); i < iDigits; i++)
		strcat(szString, "0");
	strcat(szString, szTemp);

	LocalFree(szTemp);
	szTemp = NULL;
} // StringIntToZeroPaddedStr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringIntToChar()"
//==================================================================================
// StringIntToChar
//----------------------------------------------------------------------------------
//
// Description: Takes the integer number passed in (between 0 and 15) and returns
//				the ASCII character corresponding to the hexidecimal value.  If the
//				value is not between 0 and 15, an 'X' character is returned. 
//
// Arguments:
//	int iNum	Integer to convert.
//
// Returns: Character representing value.
//==================================================================================
char StringIntToChar(int iNum)
{
	switch (iNum)
	{
		case 0:
			return('0');
		  break;
		case 1:
			return('1');
		  break;
		case 2:
			return('2');
		  break;
		case 3:
			return('3');
		  break;
		case 4:
			return('4');
		  break;
		case 5:
			return('5');
		  break;
		case 6:
			return('6');
		  break;
		case 7:
			return('7');
		  break;
		case 8:
			return('8');
		  break;
		case 9:
			return('9');
		  break;
		case 10:
			return('A');
		  break;
		case 11:
			return('B');
		  break;
		case 12:
			return('C');
		  break;
		case 13:
			return('D');
		  break;
		case 14:
			return('E');
		  break;
		case 15:
			return('F');
		  break;
		default:
			return('X');
		  break;
	} // end switch
} // StringIntToChar
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringBufferToHexStr()"
//==================================================================================
// StringBufferToHexStr
//----------------------------------------------------------------------------------
//
// Description: Converts a block of memory into a string representation of the bytes
//				of data, in hex.
//
// Arguments:
//	PVOID pvBuffer		Pointer to buffer to use.
//	DWORD dwBufferSize	Size of buffer.
//	char* szResult		Pointer to string large enough to hold result (3 characters
//						per byte of data).
//
// Returns: None.
//==================================================================================
void StringBufferToHexStr(PVOID pvBuffer, DWORD dwBufferSize, char* szResult)
{
	BYTE*	pbCurrent = (BYTE*) pvBuffer;
	int		x;
	int		y;
	DWORD	dwStringPos = 0;


	while (dwBufferSize > 0)
	{
		x = (*pbCurrent);
		y = x % 16;
		x = (x - y) / 16;
		szResult[dwStringPos++] = StringIntToChar(x);
		szResult[dwStringPos++] = StringIntToChar(y);
		szResult[dwStringPos++] = ' ';

		pbCurrent++;
		dwBufferSize--;
	} // end for (each byte in the passed in buffer)

	if (dwStringPos <= 0) // if we didn't do anything
		dwStringPos = 1; // have the termination be at the start

	szResult[dwStringPos - 1] = '\0'; // terminate the string on the last space
} // StringBufferToHexStr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringEnclosePathSpacesInQuotes()"
//==================================================================================
// StringEnclosePathSpacesInQuotes
//----------------------------------------------------------------------------------
//
// Description: Copies the path string into the result string buffer, enclosing any
//				path items containing spaces in quotes.  If NULL is passed for a
//				result buffer, then the DWORD pointed to by the size argument will
//				be filled with the size of the buffer required, including NULL
//				termination, and ERROR_BUFFER_TOO_SMALL will be returned.
//
// Arguments:
//	char* szPath				String containing environment variables to expand.
//	char* pszResultBuffer		Pointer to buffer to place results in, or NULL to
//								retrieve size required.
//	DWORD* pdwResultBufferSize	Pointer to size of destination buffer, or place to
//								store size required, including NULL terminator.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT StringEnclosePathSpacesInQuotes(char* szPath, char* pszResultBuffer,
										DWORD* pdwResultBufferSize)
{
	(*pdwResultBufferSize) = strlen(szPath) + 1;


	if (StringContainsChar(szPath, ' ', FALSE, 0) >= 0)
		(*pdwResultBufferSize) += 2;


	if (pszResultBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);


	if (StringContainsChar(szPath, ' ', FALSE, 0) < 0)
	{
		strcpy(pszResultBuffer, szPath);
		return (S_OK);
	} // end if (there's no spaces in the path)


	strcpy(pszResultBuffer, "\"");
	strcat(pszResultBuffer, szPath);
	strcat(pszResultBuffer, "\"");

	return (S_OK);
} // StringEnclosePathSpacesInQuotes
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringURLEncode()"
//==================================================================================
// StringURLEncode
//----------------------------------------------------------------------------------
//
// Description: Takes the passed string and escapes the illegal characters via the
//				standard URL %xx format.
//				Pass in NULL for the destination buffer to have the size required
//				(including NULL termination) placed in the DWORD at
//				pdwEncodedStringSize), and have ERROR_BUFFER_TOO_SMALL returned.
//
// Arguments:
//	char* szString					String to convert.
//	char* pszEncodedString			Pointer to buffer to store results, or NULL to
//									retrieve size.
//	DWORD* pdwEncodedStringSize		Place to store buffer size (including NULL
//									terminator) required.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT StringURLEncode(char* szString, char* pszEncodedString,
						DWORD* pdwEncodedStringSize)
{
	BYTE*	pbCurrentSrc = (BYTE*) szString;
	BYTE*	pbCurrentDest = (BYTE*) pszEncodedString;
	DWORD	dwSizeRequired = 0;


	do
	{
		// All characters require at least one space in the encoded string.  We
		// may add more later.
		dwSizeRequired++;

		// If it's the NULL terminator, end the encoded string and we're done.
		if ((*pbCurrentSrc) == 0)
		{
			if (pbCurrentDest == NULL)
			{
				(*pdwEncodedStringSize) = dwSizeRequired;
				return (ERROR_BUFFER_TOO_SMALL);
			} // end if (no destination string)

			// Otherwise, there's a buffer to write to, so do it.
			(*pbCurrentDest) = 0;

			// Get out of the while loop.
			break;
		} // end if (NULL terminator)
		else if (((*pbCurrentSrc) < 0x21) ||
				((*pbCurrentSrc) > 0x7E) ||
				((s_SafetyHash[(*pbCurrentSrc) - 0x21]) & URLHASH_UNSAFE))
		{
			// It's an unsafe character, and must be converted.  That means
			// we need two extra bytes (for a total of 3, string is "%nn")
			dwSizeRequired += 2;
			
			if (pbCurrentDest != NULL)
			{
				// We're going to use (*pbCurrentDest) as a temporary
				// variable to hold the remainder (second letter in byte).
				(*pbCurrentDest) = (*pbCurrentSrc) % 16;

				*(pbCurrentDest + 2) = StringIntToChar(*pbCurrentDest);
				*(pbCurrentDest + 1) = StringIntToChar(((*pbCurrentSrc) - (*pbCurrentDest)) / 16);

				// Overwrite that temp spot with the actual character we want.
				(*pbCurrentDest) = '%'; // escape character;

				// Move 3 characters down.
				pbCurrentDest += 3;
			} // end if (there's a destination string)
		} // end else if (less than 0x21 or greater than 0x7E or unsafe)
		else
		{
			// It's a safe character, so just copy if over if there's a
			// buffer.
			if (pbCurrentDest != NULL)
			{
				(*pbCurrentDest) = (*pbCurrentSrc);
				pbCurrentDest++;
			} // end if (there's a destination string)
		} // end else (it's a safe character)

		pbCurrentSrc++;
	} // end do (while not at end of string)
	while (TRUE);


	return (S_OK);
} // StringURLEncode
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetCurrentDateStr()"
//==================================================================================
// StringGetCurrentDateStr
//----------------------------------------------------------------------------------
//
// Description: Gets the current time and date, formats it and puts it in the passed
//				string. 
//
// Arguments:
//	char* szString		Buffer to store result.
//
// Returns: None.
//==================================================================================
void StringGetCurrentDateStr(char* szString)
{
	time_t		tTime;
	struct tm*	ptmLocalTime;


	time(&tTime);
	ptmLocalTime = localtime(&tTime);
	strftime(szString, 128, "%I:%M:%S%p %A, %B %d, %Y", ptmLocalTime);
} // StringGetCurrentDateStr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetCurrentDateStrShort()"
//==================================================================================
// StringGetCurrentDateStrShort
//----------------------------------------------------------------------------------
//
// Description: Gets the current time and date, formats it and puts it in the passed
//				string. 
//
// Arguments:
//	char* szString		Buffer to store result.
//
// Returns: None.
//==================================================================================
void StringGetCurrentDateStrShort(char* szString)
{
	time_t		tTime;
	struct tm*	ptmLocalTime;


	time(&tTime);
	ptmLocalTime = localtime(&tTime);
	strftime(szString, 128, "%I:%M:%S%p %a. %b. %d, %Y", ptmLocalTime);
} // StringGetCurrentDateStrShort
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetCurrentTimeStr()"
//==================================================================================
// StringGetCurrentTimeStr
//----------------------------------------------------------------------------------
//
// Description: Gets the current time, formats it and puts it in the passed string. 
//
// Arguments:
//	char* szString		Buffer to store result.
//
// Returns: None.
//==================================================================================
void StringGetCurrentTimeStr(char* szString)
{
	time_t		tTime;
	struct tm*	ptmLocalTime;


	time(&tTime);
	ptmLocalTime = localtime(&tTime);
	strftime(szString, 128, "%I:%M:%S%p", ptmLocalTime);
} // StringGetCurrentTimeStr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetStrFromFiletime()"
//==================================================================================
// StringGetStrFromFiletime
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in file time into a string.  If the abbreviated
//				version is requested, day and month names are shortened.
//
// Arguments:
//	FILETIME* pFiletime		File time to convert.
//	BOOL fAbbreviated		Should the string be more compact?
//	char* szString			The string to store the results in.
//
// Returns: None
//==================================================================================
void StringGetStrFromFiletime(FILETIME* pFiletime, BOOL fAbbreviated,
								char* szString)
{
	BOOL			fZero = TRUE;
	LPBYTE			pCurrent = (LPBYTE) pFiletime;
	FILETIME		ftLocal;
	SYSTEMTIME		systime;
	char			szTemp[1024];

	if (pFiletime == NULL)
		return;

	while (pCurrent < (LPBYTE) (pFiletime + 1))
	{
		if ((*pCurrent) != 0)
		{
			fZero = FALSE;
			break;
		} // end if (non-zero byte)

		pCurrent++;
	} // end while (haven't hit end of buffer)

	if (fZero)
	{
		strcpy(szString, "unknown");
		return;
	} // end if (no time)


	// Convert the file time from UTC (Coordinated Universal Time) to local time
	ZeroMemory(&ftLocal, sizeof (FILETIME));
	if (! FileTimeToLocalFileTime(pFiletime, &ftLocal))
		return;

	// Convert the local time into an easily parsable format.
	if (! FileTimeToSystemTime(&ftLocal, &systime))
		return;


	wsprintf(szString, "%i:%02i:%02i",
			((systime.wHour > 12) ? (systime.wHour - 12) : ((systime.wHour == 0) ? 12 : systime.wHour)),
			systime.wMinute,
			systime.wSecond);

	if (! fAbbreviated)
	{
		// Tack on an extra space
		strcat(szString, " ");
	} // end if (not abbreviated)

	if (systime.wHour > 12)
	{
		strcat(szString, "PM ");
	} // end if (PM)
	else
	{
		strcat(szString, "AM ");
	} // end else (AM)

	if (! fAbbreviated)
	{
		// Tack on an extra space
		strcat(szString, " ");
	} // end if (not abbreviated)

	switch (systime.wDayOfWeek)
	{
		case 0:
			if (fAbbreviated)
				strcat(szString, "Sun. ");
			else
				strcat(szString, "Sunday, ");
		  break;

		case 1:
			if (fAbbreviated)
				strcat(szString, "Mon. ");
			else
				strcat(szString, "Monday, ");
		  break;

		case 2:
			if (fAbbreviated)
				strcat(szString, "Tue. ");
			else
				strcat(szString, "Tuesday, ");
		  break;

		case 3:
			if (fAbbreviated)
				strcat(szString, "Wed. ");
			else
				strcat(szString, "Wednesday, ");
		  break;

		case 4:
			if (fAbbreviated)
				strcat(szString, "Thu. ");
			else
				strcat(szString, "Thursday, ");
		  break;

		case 5:
			if (fAbbreviated)
				strcat(szString, "Fri. ");
			else
				strcat(szString, "Friday, ");
		  break;

		case 6:
			if (fAbbreviated)
				strcat(szString, "Sat. ");
			else
				strcat(szString, "Saturday, ");
		  break;
	} // end switch (on day of week)

	switch (systime.wMonth)
	{
		case 1:
			if (fAbbreviated)
				strcat(szString, "Jan. ");
			else
				strcat(szString, "January ");
		  break;

		case 2:
			if (fAbbreviated)
				strcat(szString, "Feb. ");
			else
				strcat(szString, "February ");
		  break;

		case 3:
			if (fAbbreviated)
				strcat(szString, "Mar. ");
			else
				strcat(szString, "March ");
		  break;

		case 4:
			if (fAbbreviated)
				strcat(szString, "Apr. ");
			else
				strcat(szString, "April ");
		  break;

		case 5:
			strcat(szString, "May ");
		  break;

		case 6:
			if (fAbbreviated)
				strcat(szString, "Jun. ");
			else
				strcat(szString, "June ");
		  break;

		case 7:
			if (fAbbreviated)
				strcat(szString, "Jul. ");
			else
				strcat(szString, "July ");
		  break;

		case 8:
			if (fAbbreviated)
				strcat(szString, "Aug. ");
			else
				strcat(szString, "August ");
		  break;

		case 9:
			if (fAbbreviated)
				strcat(szString, "Sep. ");
			else
				strcat(szString, "September ");
		  break;

		case 10:
			if (fAbbreviated)
				strcat(szString, "Oct. ");
			else
				strcat(szString, "October ");
		  break;

		case 11:
			if (fAbbreviated)
				strcat(szString, "Nov. ");
			else
				strcat(szString, "November ");
		  break;

		case 12:
			if (fAbbreviated)
				strcat(szString, "Dec. ");
			else
				strcat(szString, "December ");
		  break;
	} // end switch (on month)

	wsprintf(szTemp, "%i, %i", systime.wDay, systime.wYear);

	strcat(szString, szTemp);
} // StringGetStrFromFiletime
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCpyAToU()"
//==================================================================================
// StringCpyAToU
//----------------------------------------------------------------------------------
//
// Description: Performs like strcpy, except the destination string is a Unicode
//				string.  Just like strcpy, the destination buffer is assumed to be
//				large enough to hold it.
//
// Arguments:
//	WCHAR* wszUnicodeString		Unicode destination string to write to.
//	char* szANSIString			ANSI source string to copy from.
//
// Returns: Pointer to the Unicode string passed in.
//==================================================================================
WCHAR* StringCpyAToU(WCHAR* wszUnicodeString, char* szANSIString)
{
	int		i;


	i = MultiByteToWideChar(CP_ACP, 0, szANSIString, -1, wszUnicodeString,
							(strlen(szANSIString) + 1));

	if (i == 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't convert string to Unicode!  %e", 1, GetLastError());
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		ZeroMemory(wszUnicodeString, (strlen(szANSIString) + 1) * sizeof (WCHAR));
	} // end if (the function failed)
	
	return (wszUnicodeString);
} // StringCpyAToU
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCpyUToA()"
//==================================================================================
// StringCpyUToA
//----------------------------------------------------------------------------------
//
// Description: Performs like strcpy, except the source string is a Unicode
//				string.  Just like strcpy, the destination buffer is assumed to be
//				large enough to hold it.
//
// Arguments:
//	char* szANSIString			ANSI source string to write to.
//	WCHAR* wszUnicodeString		Unicode destination string to copy from.
//
// Returns: Pointer to the Unicode string passed in.
//==================================================================================
char* StringCpyUToA(char* szANSIString, WCHAR* wszUnicodeString)
{
	int		i;


	i = WideCharToMultiByte(CP_ACP, 0, wszUnicodeString, -1, szANSIString,
							(wcslen(wszUnicodeString) + 1), NULL, NULL);
	if (i == 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't convert string to ANSI!  %e", 1, GetLastError());
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		ZeroMemory(szANSIString, (wcslen(wszUnicodeString) + 1));
	} // end if (the function failed)
	
	return (szANSIString);
} // StringCpyUToA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCatAToU()"
//==================================================================================
// StringCatAToU
//----------------------------------------------------------------------------------
//
// Description: Performs like strcat, except the destination string is a Unicode
//				string.  Just like strcat, the destination buffer is assumed to be
//				large enough to hold the concatenated string.
//
// Arguments:
//	WCHAR* wszUnicodeString		Unicode destination string to write to.
//	char* szANSIString			ANSI source string to copy from.
//
// Returns: Pointer to the Unicode string passed in.
//==================================================================================
WCHAR* StringCatAToU(WCHAR* wszUnicodeString, char* szANSIString)
{
	int		i;


	i = MultiByteToWideChar(CP_ACP, 0, szANSIString, -1,
							wszUnicodeString + lstrlenW(wszUnicodeString),
							(strlen(szANSIString) + 1));

	if (i == 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't convert string to Unicode!  %e", 1, GetLastError());
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		ZeroMemory(wszUnicodeString + lstrlenW(wszUnicodeString),
					(strlen(szANSIString) + 1) * sizeof (WCHAR));
	} // end if (the function failed)
	
	return (wszUnicodeString);
} // StringCatAToU
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCmpAToU()"
//==================================================================================
// StringCmpAToU
//----------------------------------------------------------------------------------
//
// Description: Performs similar to strcmp, except the first string is Unicode, and
//				it returns TRUE if they match (case insensitive, if specified),
//				FALSE otherwise.
//
// Arguments:
//	WCHAR* wszUnicodeString		Unicode string to compare.
//	char* szANSIString			ANSI string to compare.
//	BOOL fMatchCase				Whether case matters or not.
//
// Returns: Returns TRUE if they match, FALSE otherwise.
//==================================================================================
BOOL StringCmpAToU(WCHAR* wszUnicodeString, char* szANSIString, BOOL fMatchCase)
{
	BOOL	fResult = FALSE;
	int		i;
	WCHAR*	pwszANSIAsUnicode = NULL;
	WCHAR*	pwszUnicodeLwr = NULL;
	WCHAR*	pwcCurrent1 = NULL;
	WCHAR*	pwcCurrent2 = NULL;



	i = MultiByteToWideChar(CP_ACP, 0, szANSIString, -1, NULL, 0);
	if (i <= 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't get size of ANSI string in Unicode!  %e", 1, GetLastError());
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (couldn't convert string)


	pwszANSIAsUnicode = (WCHAR*) LocalAlloc(LPTR, (i * sizeof (WCHAR)));
	if (pwszANSIAsUnicode == NULL)
	{
		goto DONE;
	} // end if (couldn't allocate memory)
	ZeroMemory(pwszANSIAsUnicode, i * sizeof (WCHAR));

	i = MultiByteToWideChar(CP_ACP, 0, szANSIString, -1, pwszANSIAsUnicode, i);
	if (i <= 0)
	{
		#ifndef NO_TNCOMMON_DEBUG_SPEW
		DPL(0, "Couldn't convert string to Unicode!  %e", 1, GetLastError());
		#endif // ! NO_TNCOMMON_DEBUG_SPEW

		goto DONE;
	} // end if (the function failed)


	// Make strings lower case for case-insensitive matching, if requested
	if (! fMatchCase)
	{
		_wcslwr(pwszANSIAsUnicode);

		pwszUnicodeLwr = (WCHAR*) LocalAlloc(LPTR, ((wcslen(wszUnicodeString) + 1) * sizeof (WCHAR)));
		if (pwszUnicodeLwr == NULL)
		{
			goto DONE;
		} // end if (couldn't allocate memory)
		wcscpy(pwszUnicodeLwr, wszUnicodeString);
		_wcslwr(pwszUnicodeLwr);
	} // end if (case insensitive)

	// Compare the strings
	fResult = ((wcscmp((fMatchCase ? wszUnicodeString : pwszUnicodeLwr),
				pwszANSIAsUnicode)) == 0) ? TRUE : FALSE;


DONE:

	if (pwszANSIAsUnicode != NULL)
	{
		LocalFree(pwszANSIAsUnicode);
		pwszANSIAsUnicode = NULL;
	} // end if (allocated string)

	if (pwszUnicodeLwr != NULL)
	{
		LocalFree(pwszUnicodeLwr);
		pwszUnicodeLwr = NULL;
	} // end if (allocated string)

	return (fResult);
} // StringCmpAToU
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringGetFlags()"
//==================================================================================
// StringGetFlags
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in textual representation of flags to their
//				actual values.  The flags must be separated by the pipe ('|') and/or
//				space (' ') characters.
//
// Arguments:
//	char* szString					The string to parse.
//	PTNFLAGTABLEITEM paFlagTable	Pointer to table to use for flag lookup.
//	DWORD_PTR dwNumFlagsInTable		Number of elements in the table being used.
//	BOOL fCaseSensitive				Whether case matters when matching flag names or
//									not.
//
// Returns: The valid session flags found.
//==================================================================================
DWORD_PTR StringGetFlags(char* szString, PTNFLAGTABLEITEM paFlagTable,
						DWORD_PTR dwNumFlagsInTable, BOOL fCaseSensitive)
{
	DWORD_PTR	dwResultFlags = 0;
	char*		pszFields = NULL;
	DWORD_PTR	dwSize = 0;
	DWORD_PTR	dwNumFields = 0;
	DWORD_PTR	dwTemp;
	DWORD_PTR	dwTemp2;
	char*		pszCurrentField = NULL;


	dwSize = strlen(szString) + 1;
	pszFields = (char*) LocalAlloc(LPTR, dwSize);
	if (pszFields == NULL)
		return (0);

	dwNumFields = StringSplitIntoFields(szString, " |", pszFields, &dwSize);
	for(dwTemp = 0; dwTemp < dwNumFields; dwTemp++)
	{
		pszCurrentField = StringGetFieldPtr(pszFields, dwTemp);

		for(dwTemp2 = 0; dwTemp2 < dwNumFlagsInTable; dwTemp2++)
		{
			if (fCaseSensitive)
			{
				if (strcmp(pszCurrentField, paFlagTable[dwTemp2].szString) == 0)
					dwResultFlags |= paFlagTable[dwTemp2].dwFlag;
			} // end if (case sensitive)
			else
			{
				if (StringCmpNoCase(pszCurrentField, paFlagTable[dwTemp2].szString))
					dwResultFlags |= paFlagTable[dwTemp2].dwFlag;
			} // end else (not case sensitive)
		} // end for (each known flag)
	} // end for (each field)

	LocalFree(pszFields);
	pszFields = NULL;

	return (dwResultFlags);
} // StringGetFlags
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringAddFlags()"
//==================================================================================
// StringAddFlags
//----------------------------------------------------------------------------------
//
// Description: Converts the flags contained in the passed in DWORD into their
//				textual representation separated by pipe ('|') characters and
//				concatenates them onto the end of the string passed in.
//				If the passed in string pointer is NULL, the DWORD passed in is set
//				to the size required by the string (including NULL terminator), and
//				ERROR_BUFFER_TOO_SMALL is returned.
//				If no valid flags were found, the string size required will be 0.
//				Note: space for 3 extra characters is required during the function's
//				execution, but this is included in the string size returned.
//
// Arguments:
//	DWORD_PTR dwFlags				Flags to convert.
//	PTNFLAGTABLEITEM paFlagTable	Pointer to table to use for flag lookup.
//	DWORD_PTR dwNumFlagsInTable		Number of elements in the table being used.
//	char* pszString					Pointer to string to which text will be added.
//	DWORD_PTR* pdwStringSize		Pointer to size of string buffer, or place to
//									store size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT StringAddFlags(DWORD_PTR dwFlags, PTNFLAGTABLEITEM paFlagTable,
						DWORD_PTR dwNumFlagsInTable, char* pszString,
						DWORD_PTR* pdwStringSize)
{
	DWORD_PTR	dwTemp;


	if (pszString == NULL)
		(*pdwStringSize) = 0;


	if (dwFlags != 0)
	{
		for(dwTemp = 0; dwTemp < dwNumFlagsInTable; dwTemp++)
		{
			if (dwFlags & (paFlagTable[dwTemp].dwFlag))
			{
				if (pszString == NULL)
					(*pdwStringSize) += strlen(paFlagTable[dwTemp].szString) + 3;
				else
				{
					strcat(pszString, paFlagTable[dwTemp].szString);
					strcat(pszString, " | ");
				} // end else (there's a buffer to copy to)

				dwFlags -= paFlagTable[dwTemp].dwFlag;

				if (dwFlags == 0)
					break;
			} // end if (we found a match)
		} // end for (each known flag)
	} // end if (there are any flags)

	// If there was no buffer to copy to, return the size required and BUFFER_TOO_SMALL
	if (pszString == NULL)
	{
		// If there are any items to display, also include room for a NULL terminator
		if ((*pdwStringSize) != 0)
			(*pdwStringSize)++;
		
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (there was no buffer)

	// If we actually added some flags, the string will end with " | ", which looks
	// dumb, so lets chop that off.
	if (strcmp(pszString, "") != 0)
	{
		pszString[strlen(pszString) - 3] = '\0'; // chop off the last 3 characters
	} // end if (we actually copied flags)
	
	return (S_OK);
} // StringAddFlags
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\stack.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <imagehlp.h>

#include "main.h"
#include "debugprint.h"
#include "cppobjhelp.h"
#include "linklist.h"
#include "strutils.h"
#include "symbols.h"
#include "stack.h"






//==================================================================================
// Structures
//==================================================================================
typedef struct tagGETSTACKTHREADCONTEXT
{
	HANDLE				hThreadToUse; // handle to thread to get the stack from
	PTNGETSTACKDATA		pData; // pointer to the parameters/options the caller specified
} GETSTACKTHREADCONTEXT, * PGETSTACKTHREADCONTEXT;

//BUGBUG let user get this (or some variant)?
typedef struct tagTNCALLSTACKENTRY
{
	PVOID	pvReturnAddress; // pointer to calling function
	PVOID	pvFunctionAddress; // pointer to called function
	PVOID	pvParam1; // first parameter to function (if applicable)
	PVOID	pvParam2; // second parameter to function (if applicable)
	PVOID	pvParam3; // third parameter to function (if applicable)
	PVOID	pvParam4; // fourth parameter to function (if applicable)
} TNCALLSTACKENTRY, * PTNCALLSTACKENTRY;





//==================================================================================
// Function prototypes so the below globals will work
//==================================================================================
typedef BOOL (__stdcall * STACKWALKPROC)				(DWORD, HANDLE, HANDLE,
														LPSTACKFRAME, LPVOID,
														PREAD_PROCESS_MEMORY_ROUTINE,
														PFUNCTION_TABLE_ACCESS_ROUTINE,
														PGET_MODULE_BASE_ROUTINE,
														PTRANSLATE_ADDRESS_ROUTINE);

typedef LPVOID (__stdcall * SYMFUNCTIONTABLEACCESSPROC)	(HANDLE, DWORD_PTR);

typedef DWORD_PTR (__stdcall * SYMGETMODULEBASEPROC)	(HANDLE, DWORD_PTR);





//==================================================================================
// "Secret" External Globals from symbols.cpp
//
// These are defined here so that we can access the IMAGEHLP.DLL and NTDLL.DLL
// functionality without having to load and initialize it here as well, etc.  Plus
// we can hook into the symbol stuff better (why would you even bother trying to
// dump the stack without symbols anyway?).
// Note that this means TNSymInitialize must be called in order for these functions
// to work.
//==================================================================================
extern DWORD						g_dwTNSymInits;
extern BOOL							g_fTNSymSomeFuncsUnavailable;
extern HANDLE						g_hTNSymProcess;
extern STACKWALKPROC				g_pfnStackWalk;
extern SYMFUNCTIONTABLEACCESSPROC	g_pfnSymFunctionTableAccess;
extern SYMGETMODULEBASEPROC			g_pfnSymGetModuleBase;
extern RTLGETCALLERSADDRESSPROC		g_pfnRtlGetCallersAddress;



//==================================================================================
// Local Prototypes
//==================================================================================
HRESULT PrintCallStack(LPCONTEXT lpThreadContext, HANDLE hThread,
					PVOID pvIgnoreCallsAboveFunction);

#ifdef _X86_
HRESULT PrintRawIntelStack(LPCONTEXT lpThreadContext, DWORD dwNumEntries);
#endif // _X86_

void Win9xFakeRtlGetCallersAddress(PVOID* ppvCallersAddress,
									PVOID* ppvCallersCaller);

DWORD WINAPI GetStackThreadProc(LPVOID lpvParameter);







#ifndef _XBOX // We don't support GetModuleFileName and this function ultimately depends on it
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNStackGetStackForCurrentThread()"
//==================================================================================
// TNStackGetStackForCurrentThread
//----------------------------------------------------------------------------------
//
// Description: Retrieves the stack for the current thread.
//
// Arguments:
//	PTNGETSTACKDATA pGetStackData		Pointer to parameter block for options on
//										how to get the stack.  See its definition.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNStackGetStackForCurrentThread(PTNGETSTACKDATA pGetStackData)
{
	HRESULT					hr;
	GETSTACKTHREADCONTEXT	gstc;
	HANDLE					hGetStackThread = NULL;
	DWORD					dwThreadID;


	ZeroMemory(&gstc, sizeof (GETSTACKTHREADCONTEXT));

	DPL(9, "==> (%X)", 1, pGetStackData);

	if (g_dwTNSymInits == 0) 
	{
		DPL(0, "TNSymInitialize was not successfully called!", 0);
		hr = TNSYMERR_UNINITIALIZED;
		goto DONE;
	} // end if (sym not initialized)

	if (pGetStackData->dwSize != sizeof (TNGETSTACKDATA))
	{
		DPL(0, "GetStackData passed in is not correct size (%i != %i)!",
			2, pGetStackData->dwSize, sizeof (TNGETSTACKDATA));
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (parameter block is wacky)
	

	// We need to convert the pseudo handle that GetCurrentThread() returns
	// into a real handle, because if we try to use the pseudo handle in
	// the GetStack thread, the OS will actually resolve it to be that
	// thread instead of this one.
	if (! DuplicateHandle(g_hTNSymProcess, GetCurrentThread(),
						g_hTNSymProcess, &gstc.hThreadToUse,
						0, FALSE, DUPLICATE_SAME_ACCESS))
	{
		hr = GetLastError();
		DPL(0, "Duplicating the current thread handle failed!", 0);
		goto DONE;
	} // end if (duplicating handle failed)

	gstc.pData = pGetStackData;


	hGetStackThread = CreateThread(NULL, 0, GetStackThreadProc, &gstc, 0, &dwThreadID);
	if (hGetStackThread == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create GetStack thread!", 0);
		goto DONE;
	} // end if (couldn't create thread)


	// Wait for the thread to complete
	hr = WaitForSingleObject(hGetStackThread, INFINITE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			// Thread is done as expected
			if (! GetExitCodeThread(hGetStackThread, (LPDWORD) (&hr)))
			{
				hr = GetLastError();
				DPL(0, "Couldn't get thread's exit code!", 0);
				goto DONE;
			} // end if (couldn't get thread's exit code)
		  break;

		/*
		case WAIT_TIMEOUT:
			// Thread is taking a really long time to die or something
			// is hosed...
		  break;
		*/

		default:
			// Some other wierd return
			DPL(0, "WaitForSingleObject returned unexpected value!", 0);
			goto DONE;
		  break;
	} // end switch (on wait result)


DONE:

	if (hGetStackThread != NULL)
	{
		CloseHandle(hGetStackThread);
		hGetStackThread = NULL;
	} // end if (have handle)

	if (gstc.hThreadToUse != NULL)
	{
		CloseHandle(gstc.hThreadToUse);
		gstc.hThreadToUse = NULL;
	} // end if (have handle)


	DPL(9, "<== %e", 1, hr);

	return (hr);
} // TNStackGetStackForCurrentThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNStackGetRGCAProc()"
//==================================================================================
// TNStackGetRGCAProc
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: Pointer to procedure to use.
//==================================================================================
RTLGETCALLERSADDRESSPROC TNStackGetRGCAProc(void)
{
	if (g_pfnRtlGetCallersAddress != NULL)
		return (g_pfnRtlGetCallersAddress);

	return (Win9xFakeRtlGetCallersAddress);
} // TNStackGetRGCAProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // We don't support GetModuleFileName and this function ultimately depends on it
#undef DEBUG_SECTION
#define DEBUG_SECTION	"PrintCallStack()"
//==================================================================================
// PrintCallStack
//----------------------------------------------------------------------------------
//
// Description: Walks the call stack and prints out all functions found.  If the
//				IgnoreCalls pointer is not NULL and a call to the function specified
//				by that address is found on the stack, it and all calls above it in
//				the stack are not printed.
//
// Arguments:
//	LPCONTEXT lpThreadContext			Pointer to the context of a suspended thread
//										whose call stack you wish to dump.
//	HANDLE hThread						Handle to the suspended thread.
//	PVOID pvIgnoreCallsAboveFunction	Address user wants to ignore on callstack if
//										not NULL.  Also all calls above this on the
//										stack are ignored as well.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT PrintCallStack(LPCONTEXT lpThreadContext, HANDLE hThread,
					PVOID pvIgnoreCallsAboveFunction)
{
	HRESULT				hr;
	STACKFRAME			stackframe;
	CONTEXT				tc;
	DWORD				dwTemp = 0;
	TNCALLSTACKENTRY	callstack[32];
	DWORD				dwNumItems = 0;
	DWORD				dwSkipFunctionEntry = 0xFFFFFFFF;
	char				szSymbol[256];


	ZeroMemory(&stackframe, sizeof (STACKFRAME));
	ZeroMemory(&tc, sizeof (CONTEXT));
	ZeroMemory(&callstack, sizeof (TNCALLSTACKENTRY));

#ifdef _X86_
	// Initialize the STACKFRAME structure for the first call.  This is only
	// necessary for Intel CPUs, and isn't mentioned in the documentation.
	stackframe.AddrPC.Offset = lpThreadContext->Eip;
	stackframe.AddrPC.Mode = AddrModeFlat;
	stackframe.AddrStack.Offset = lpThreadContext->Esp;
	stackframe.AddrStack.Mode = AddrModeFlat;
	stackframe.AddrFrame.Offset = lpThreadContext->Ebp;
	stackframe.AddrFrame.Mode = AddrModeFlat;
#endif // _X86_


	do
	{
		if (!g_pfnStackWalk(IMAGE_FILE_MACHINE_I386,
							g_hTNSymProcess,
							hThread,
							&stackframe,
							&tc,
							NULL,
							g_pfnSymFunctionTableAccess,
							g_pfnSymGetModuleBase,
							NULL))
		{
			hr = GetLastError();
			if ((hr == ERROR_MOD_NOT_FOUND) ||
				(hr == ERROR_INVALID_ADDRESS) ||
				(hr == ERROR_PARTIAL_COPY))
			{
				/*
				DPL(0, "Stopped walking stack because of expected error (%x).  Non-fatal.",
					1, hr);
				*/
				hr = S_OK;
				break;
			} // end if (expected error)

			DPL(0, "StackWalk returned an unexpected failure!", 0);
			goto DONE;
		} // end if (stack walk failed)


		if (stackframe.AddrFrame.Offset == 0)
		{
			DPL(0, "Stack frame is goofy!", 0);
			hr = E_FAIL;
			goto DONE;
		} // end if (stack frame is goofy)

		dwNumItems++;

		// If the user wants to ignore items, we haven't found the appropriate
		// function yet, and this is the function, mark it for skipping.
		if ((pvIgnoreCallsAboveFunction != NULL) &&
			(dwSkipFunctionEntry == 0xFFFFFFFF) &&
			(((LPVOID) (stackframe.AddrPC.Offset)) == pvIgnoreCallsAboveFunction))
		{
			/*
			DPL(9, "Found function to skip (%X) at stack level %u.",
				2, lpvIgnoreCallsAboveFunction, dwTemp);
			*/
			dwSkipFunctionEntry = dwTemp;
		} // end if (we found the skip function)

		callstack[dwTemp].pvReturnAddress = (LPVOID) (stackframe.AddrReturn.Offset);
		callstack[dwTemp].pvFunctionAddress = (LPVOID) (stackframe.AddrPC.Offset);
		callstack[dwTemp].pvParam1 = (LPVOID) stackframe.Params[0];
		callstack[dwTemp].pvParam2 = (LPVOID) stackframe.Params[1];
		callstack[dwTemp].pvParam3 = (LPVOID) stackframe.Params[2];
		callstack[dwTemp].pvParam4 = (LPVOID) stackframe.Params[3];

		dwTemp++;
		if (dwTemp > 32)
		{
			DPL(0, "32 stack items limit reached.", 0);
			break;
		} // end if (hit item limit)
	} // end do (while not done)
	while (true);

	// We're going to print out what we found.  Spit out the header
	DPL(9, "----- Dumping call stack -----", 0);
	DPL(9, "ReturnAddr\t   Module!SymbolName + offset   \t    Params", 0);
	DPL(9, "----------\t--------------------------------\t---------------------", 0);

	// If we didn't find (or didn't look for) a function to ignore, then start
	// printing at item zero (the first one)..  Otherwise, start at the function's
	// depth. 
	if (dwSkipFunctionEntry == 0xFFFFFFFF)
	{
		if (pvIgnoreCallsAboveFunction != NULL)
		{
			DPL(9, "WARNING: Didn't find function expected to skip on call stack. %X",
				1, pvIgnoreCallsAboveFunction);
		} // end if (were expecting to find function)

		dwSkipFunctionEntry = 0;
	} // end if (didn't find skip function)
	else
	{
		/*
		DPL(9, "... (%u functions)", 1, dwSkipFunctionEntry - 1);
		*/
	} // end else (found skip function))

	for(dwTemp = dwSkipFunctionEntry; dwTemp < dwNumItems; dwTemp++)
	{
		hr = TNSymResolve(callstack[dwTemp].pvFunctionAddress, szSymbol, 256);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't resolve symbol for %x!", 1, callstack[dwTemp].pvFunctionAddress);
			goto DONE;
		} // end if (couldn't resolve symbol)

		DPL(9, "%x\t%s\t(%x, %x, %x, %x)",
			6, callstack[dwTemp].pvReturnAddress, szSymbol,
			callstack[dwTemp].pvParam1, callstack[dwTemp].pvParam2,
			callstack[dwTemp].pvParam3, callstack[dwTemp].pvParam4);
	} // end for (each item to print)

	DPL(9, "----- End call stack dump -----", 0);


DONE:

	return (hr);
} // PrintCallStack
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX

#ifndef _XBOX // We don't support GetModuleFileName and this function ultimately depends on it
#ifdef _X86_

#undef DEBUG_SECTION
#define DEBUG_SECTION	"PrintRawIntelStack()"
//==================================================================================
// PrintRawIntelStack
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	LPCONTEXT lpThreadContext	Pointer to the context of a suspended thread whose
//								raw stack you wish to dump.
//	DWORD dwNumEntries			Number of DWORDs from the stack that should be
//								dumped.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT PrintRawIntelStack(LPCONTEXT lpThreadContext, DWORD dwNumEntries)
{
	HRESULT		hr;
	DWORD*		pdwPointer;
	DWORD		dwTemp = 0;
	char		szSymbol[1024];



	DPL(9, "----- Dumping stack -----", 0);

	pdwPointer = (DWORD*) (lpThreadContext->Esp);
	do
	{
		if (IsBadReadPtr(pdwPointer, sizeof (DWORD)))
		{
			Sleep(25);
			DPL(0, "Memory not valid at %x, breaking.", 1, pdwPointer);
			break;
		} // end if (the memory is not valid)

		hr = TNSymResolve((LPVOID) (*pdwPointer), szSymbol, 1024);
		if (hr != S_OK)
		{
			Sleep(25);
			DPL(0, "Couldn't resolve symbol for %x!", 1, (*pdwPointer));
			goto DONE;
		} // end if (couldn't resolve symbol)

		DPL(9, "%x:\t%s", 2, pdwPointer, szSymbol);

		pdwPointer++;

		dwTemp++;
		if (dwTemp > dwNumEntries)
		{
			Sleep(25);
			DPL(9, "%i dump limit.", 1, dwNumEntries);
			break;
		} // end if (we've reached the limit)
	} // end do (while not done)
	while (true);

	Sleep(25);
	DPL(9, "----- End stack dump -----", 0);


DONE:

	return (hr);
} // PrintRawIntelStack
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#endif // _X86_
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"Win9xFakeRtlGetCallersAddress()"
//==================================================================================
// Win9xFakeRtlGetCallersAddress
//----------------------------------------------------------------------------------
//
// Description: Dummy function that doesn't actually retrieve return addresses.
//
// Arguments:
//	PVOID* ppvCallersAddress	Place to store caller's return address.
//	PVOID* ppvCallersCaller		Place to store caller's caller's return address.
//
// Returns: None.
//==================================================================================
void Win9xFakeRtlGetCallersAddress(PVOID* ppvCallersAddress,
									PVOID* ppvCallersCaller)
{
	(*ppvCallersAddress) = NULL;
	(*ppvCallersCaller) = NULL;
} // Win9xFakeRtlGetCallersAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // this function doesn't seem to be used, and we don't support GetModuleFileName
#undef DEBUG_SECTION
#define DEBUG_SECTION	"GetStackThreadProc()"
//==================================================================================
// GetStackThreadProc
//----------------------------------------------------------------------------------
//
// Description: Short lived thread that suspends the specified thread, dumps its
//				stack, and the starts it again.
//
// Arguments:
//	LPVOID lpvParameter		Parameter.  Cast as pointer to a GETSTACKTHREADCONTEXT
//							structure.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
DWORD WINAPI GetStackThreadProc(LPVOID lpvParameter)
{
	HRESULT						hr = S_OK;
	PGETSTACKTHREADCONTEXT		pContext = (PGETSTACKTHREADCONTEXT) lpvParameter;
	BOOL						fThreadSuspended = FALSE;
	CONTEXT						tc;


	if ((pContext == NULL) || (pContext->pData == NULL))
	{
		DPL(0, "Somehow we got started without a context or options!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (context or options don't exist)

	SuspendThread(pContext->hThreadToUse);

	fThreadSuspended = TRUE;

	ZeroMemory(&tc, sizeof (CONTEXT));
	tc.ContextFlags = CONTEXT_CONTROL;
	if (! GetThreadContext(pContext->hThreadToUse, &tc))
	{
		hr = GetLastError();
		DPL(0, "GetThreadContext failed!", 0);
		goto DONE;
	} // end if (get thread context failed)

	// If the caller wants the callstack printed, and symbol functions
	// are available, do it.
	if ((pContext->pData->fCallStack) && (! g_fTNSymSomeFuncsUnavailable))
	{
		hr = PrintCallStack(&tc, pContext->hThreadToUse,
							pContext->pData->pvIgnoreCallsAboveFunction);
		if (hr != S_OK)
		{
			DPL(0, "Printing call stack failed!  %e", 1, hr);
			goto DONE;
		} // end if (printing stack failed)
	} // end if (we should print the call stack)

	if (pContext->pData->dwRawStackDepth > 0)
	{
#ifdef _X86_
		hr = PrintRawIntelStack(&tc, pContext->pData->dwRawStackDepth);
		if (hr != S_OK)
		{
			DPL(0, "Printing raw Intel stack failed!  %e", 1, hr);
			goto DONE;
		} // end if (printing stack failed)
#else
		DPL(0, "Can't print raw stack for non-Intel machines at this time!  Ignoring.", 0);
#endif // ! _X86_
	} // end if (we should print the raw stack depth)


DONE:

	if (fThreadSuspended)
	{
		ResumeThread(pContext->hThreadToUse);
		fThreadSuspended = FALSE;
	} // end if (suspended thread)

	return (hr);
} // GetStackThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\symbols.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <imagehlp.h>

#include <stdlib.h>	// NT BUILD needs this for _pgmptr


#include "main.h"
#include "debugprint.h"
#include "cppobjhelp.h"
#include "linklist.h"
#include "linkedstr.h"
#include "fileutils.h"
#include "strutils.h"
#include "sprintf.h"
#include "symbols.h"






//==================================================================================
// Defines
//==================================================================================
#ifndef REGKEY_TESTNET
#define REGKEY_TESTNET						"SOFTWARE\\Microsoft\\DirectPlay\\TestNet"
#endif // REGKEY_TESTNET

#define REGVALUE_DISABLESYMBOLRESOLUTION	"DisableSymbolResolution"







//==================================================================================
// Typedefs for IMAGEHLP.DLL functions so that we can use them with GetProcAddress
//==================================================================================
typedef BOOL (__stdcall * SYMINITIALIZEPROC)			(HANDLE, LPSTR, BOOL);

//typedef DWORD (__stdcall * SYMGETOPTIONSPROC)			(void);

typedef DWORD (__stdcall * SYMSETOPTIONSPROC)			(DWORD);

typedef BOOL (__stdcall * SYMLOADMODULEPROC)			(HANDLE, HANDLE, LPSTR,
														LPSTR, DWORD_PTR, DWORD);

typedef BOOL (__stdcall * SYMCLEANUPPROC)				(HANDLE);

#ifdef _WIN64
typedef BOOL (__stdcall * SYMGETSYMFROMADDR64PROC)		(HANDLE, DWORD_PTR, PDWORD_PTR,
														PIMAGEHLP_SYMBOL64);
#else // _WIN64
typedef BOOL (__stdcall * SYMGETSYMFROMADDRPROC)		(HANDLE, DWORD_PTR, PDWORD_PTR,
														PIMAGEHLP_SYMBOL);
#endif // _WIN64

//typedef BOOL (__stdcall * SYMGETSEARCHPATHPROC)			(HANDLE, LPSTR, DWORD);

//typedef BOOL (__stdcall * SYMSETSEARCHPATHPROC)			(HANDLE, LPSTR);

typedef PLOADED_IMAGE (__stdcall * IMAGELOADPROC)		(LPSTR, LPSTR);

typedef BOOL (__stdcall * IMAGEUNLOADPROC)				(PLOADED_IMAGE);

typedef BOOL (__stdcall * STACKWALKPROC)				(DWORD, HANDLE, HANDLE,
														LPSTACKFRAME, LPVOID,
														PREAD_PROCESS_MEMORY_ROUTINE,
														PFUNCTION_TABLE_ACCESS_ROUTINE,
														PGET_MODULE_BASE_ROUTINE,
														PTRANSLATE_ADDRESS_ROUTINE);

typedef LPVOID (__stdcall * SYMFUNCTIONTABLEACCESSPROC)	(HANDLE, DWORD_PTR);

typedef DWORD_PTR (__stdcall * SYMGETMODULEBASEPROC)		(HANDLE, DWORD_PTR);

typedef void (__stdcall * RTLGETCALLERSADDRESSPROC)		(LPVOID*, LPVOID*);




//==================================================================================
// These are some definitions from ntrtl.h, for future reference
//==================================================================================
/*
#ifdef __cplusplus
extern "C" {
#endif

#if defined(_M_ALPHA) || defined(_M_AXP64) || defined(_M_IA64)
PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;
#else
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );
#endif

#ifdef __cplusplus
}
#endif
*/





//==================================================================================
// Globals
//==================================================================================
DWORD						g_dwTNSymInits = 0;
BOOL						g_fTNSymSomeFuncsUnavailable = FALSE;
HANDLE						g_hTNSymProcess = NULL;
#ifndef USE_STATIC_DLL_LINKS
HMODULE						g_hImageHlpDLL = NULL;
HMODULE						g_hNTDLL = NULL;
#endif // USE_STATIC_DLL_LINKS
CLStringList				g_symbolsloaded;

SYMINITIALIZEPROC			g_pfnSymInitialize = NULL;
SYMSETOPTIONSPROC			g_pfnSymSetOptions = NULL;
SYMLOADMODULEPROC			g_pfnSymLoadModule = NULL;
SYMCLEANUPPROC				g_pfnSymCleanup = NULL;
#ifdef _WIN64
SYMGETSYMFROMADDR64PROC		g_pfnSymGetSymFromAddr64 = NULL;
#else // _WIN64
SYMGETSYMFROMADDRPROC		g_pfnSymGetSymFromAddr = NULL;
#endif // _WIN64
//SYMGETSEARCHPATHPROC		g_pfnSymGetSearchPath = NULL;
//SYMSETSEARCHPATHPROC		g_pfnSymSetSearchPath = NULL;
IMAGELOADPROC				g_pfnImageLoad = NULL;
IMAGEUNLOADPROC				g_pfnImageUnload = NULL;
STACKWALKPROC				g_pfnStackWalk = NULL;
SYMFUNCTIONTABLEACCESSPROC	g_pfnSymFunctionTableAccess = NULL;
SYMGETMODULEBASEPROC		g_pfnSymGetModuleBase = NULL;
RTLGETCALLERSADDRESSPROC	g_pfnRtlGetCallersAddress = NULL;





#ifndef _XBOX // no symbol initialization
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymInitialize()"
//==================================================================================
// TNSymInitialize
//----------------------------------------------------------------------------------
//
// Description: Initializes the symbols functions for use.  Must be balanced by a
//				call to TNSymCleanup.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNSymInitialize(void)
{
	HRESULT			hr;
	OSVERSIONINFO	ovi;



	g_dwTNSymInits++;

	// If we've already been initialized, we're done.
	if (g_dwTNSymInits > 1)
	{
		return (S_OK);
	} // end if (already initted)


	// Convert the pseudo-handle that GetCurrentProcess returns into a real handle
	if (! DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(),
						GetCurrentProcess(), &g_hTNSymProcess, 0, FALSE,
						DUPLICATE_SAME_ACCESS))
	{
		hr = GetLastError();
		DPL(0, "Couldn't convert process pseudo-handle into real one!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't duplicate handle)


	// Check the registry setting for controlling symbol resolution.
	if (TNSymGetDisableSymResolutionSetting())
	{
		DPL(0, "Registry setting disables symbol resolution.", 0);
		g_fTNSymSomeFuncsUnavailable = TRUE;
		return (S_OK);
	} // end if (not using symbol resolution)



	// Check to see if we're running on an NT system.  If not, we can't use some
	// functionality.

	ZeroMemory(&ovi, sizeof (OSVERSIONINFO));
	ovi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
	if (! GetVersionEx(&ovi))
	{
		hr = GetLastError();
		DPL(0, "Couldn't get OS version!", 0);
		goto ERROR_EXIT;
	} // end if (get os version)

	if (ovi.dwPlatformId != VER_PLATFORM_WIN32_NT)
	{
		DPL(0, "WARNING: Symbol resolution unavailable on non NT based platforms (OS version = %i.%i.%i).",
			3, HIBYTE(HIWORD(ovi.dwBuildNumber)), LOBYTE(HIWORD(ovi.dwBuildNumber)),
			LOWORD(ovi.dwBuildNumber));

		g_fTNSymSomeFuncsUnavailable = TRUE;
		return (S_OK);
	} // end if (version 4 OS)
	

	g_symbolsloaded.RemoveAll();


#ifndef USE_STATIC_DLL_LINKS
	g_hImageHlpDLL = LoadLibrary("imagehlp.dll");
	if (g_hImageHlpDLL == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't load IMAGEHLP.DLL!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't load imagehlp)

	g_hNTDLL = LoadLibrary("ntdll.dll");
	if (g_hNTDLL == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't load NTDLL.DLL!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't load ntdll)


	// Grab pointers to the procedures we may use

	g_pfnSymInitialize = (SYMINITIALIZEPROC) GetProcAddress(g_hImageHlpDLL,
															"SymInitialize");
	if (g_pfnSymInitialize == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymInitialize\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnSymSetOptions = (SYMSETOPTIONSPROC) GetProcAddress(g_hImageHlpDLL,
															"SymSetOptions");
	if (g_pfnSymSetOptions == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymSetOptions\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnSymLoadModule = (SYMLOADMODULEPROC) GetProcAddress(g_hImageHlpDLL,
															"SymLoadModule");
	if (g_pfnSymLoadModule == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymLoadModule\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnSymCleanup = (SYMCLEANUPPROC) GetProcAddress(g_hImageHlpDLL,
														"SymCleanup");
	if (g_pfnSymCleanup == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymCleanup\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

#ifdef _WIN64
	g_pfnSymGetSymFromAddr64 = (SYMGETSYMFROMADDR64PROC) GetProcAddress(g_hImageHlpDLL,
																	"SymGetSymFromAddr64");
	if (g_pfnSymGetSymFromAddr64 == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymGetSymFromAddr64\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)
#else // _WIN64
	g_pfnSymGetSymFromAddr = (SYMGETSYMFROMADDRPROC) GetProcAddress(g_hImageHlpDLL,
																	"SymGetSymFromAddr");
	if (g_pfnSymGetSymFromAddr == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymGetSymFromAddr\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)
#endif // _WIN64

	/*
	g_pfnSymGetSearchPath = (SYMGETSEARCHPATHPROC) GetProcAddress(g_hImageHlpDLL,
																	"SymGetSearchPath");
	if (g_pfnSymGetSearchPath == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymGetSearchPath\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnSymSetSearchPath = (SYMSETSEARCHPATHPROC) GetProcAddress(g_hImageHlpDLL,
																	"SymSetSearchPath");
	if (g_pfnSymSetSearchPath == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymSetSearchPath\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)
	*/

	g_pfnImageLoad = (IMAGELOADPROC) GetProcAddress(g_hImageHlpDLL,
													"ImageLoad");
	if (g_pfnImageLoad == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"ImageLoad\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnImageUnload = (IMAGEUNLOADPROC) GetProcAddress(g_hImageHlpDLL,
														"ImageUnload");
	if (g_pfnImageUnload == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"ImageUnload\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnStackWalk = (STACKWALKPROC) GetProcAddress(g_hImageHlpDLL,
													"StackWalk");
	if (g_pfnStackWalk == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"StackWalk\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnSymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC) GetProcAddress(g_hImageHlpDLL,
																			"SymFunctionTableAccess");
	if (g_pfnSymFunctionTableAccess == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymFunctionTableAccess\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)

	g_pfnSymGetModuleBase = (SYMGETMODULEBASEPROC) GetProcAddress(g_hImageHlpDLL,
																	"SymGetModuleBase");
	if (g_pfnSymGetModuleBase == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"SymGetModuleBase\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)
	
	g_pfnRtlGetCallersAddress = (RTLGETCALLERSADDRESSPROC) GetProcAddress(g_hNTDLL,
																			"RtlGetCallersAddress");
	if (g_pfnRtlGetCallersAddress == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't get \"RtlGetCallersAddress\" function address!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't retrieve function)
#else // USE_STATIC_DLL_LINKS
	g_pfnSymInitialize = SymInitialize;
	g_pfnSymSetOptions = SymSetOptions;
	g_pfnSymLoadModule = SymLoadModule;
	g_pfnSymCleanup = SymCleanup;
	g_pfnSymGetSymFromAddr = SymGetSymFromAddr;
	/*
	g_pfnSymGetSearchPath = SymGetSearchPath;
	g_pfnSymSetSearchPath = SymSetSearchPath;
	*/
	g_pfnImageLoad = ImageLoad;
	g_pfnImageUnload = ImageUnload;
	g_pfnStackWalk = StackWalk;
	g_pfnSymFunctionTableAccess = SymFunctionTableAccess;
	g_pfnSymGetModuleBase = SymGetModuleBase;
	g_pfnRtlGetCallersAddress = RtlGetCallersAddress;
#endif // USE_STATIC_DLL_LINKS


	// Start IMAGEHLP.DLL cookin.  We say FALSE (don't invade process) because
	// setting it to TRUE never works.  #$%!   Who knows.............
	if (! g_pfnSymInitialize(g_hTNSymProcess, NULL, FALSE))
	{
		hr = GetLastError();
		DPL(0, "SymInitialize is a failure!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't initialize image help DLL)


	// We always want to defer loading the symbols.
	g_pfnSymSetOptions(SYMOPT_DEFERRED_LOADS);

	/*
	// We could change the symbol search path if we want...
	{
		char	szPath[1024];


		if (! g_pfnSymGetSearchPath(GetCurrentProcess(), szPath, 1024))
		{
			hr = GetLastError();
			DPL(0, "SymGetSearchPath is a failure!", 0);
			goto ERROR_EXIT;
		}
		
		DPL(0, "Symbol path currently = \"%s\"", 1, szPath);
	}
	*/


	// Now load the default symbols we want to get

	hr = TNSymLoadSymbolsForModules(_pgmptr);
	if (hr != S_OK)
	{
		DPL(0, "Loading symbols for current process (\"%s\") failed!", 1, _pgmptr);
		goto ERROR_EXIT;
	} // end if (couldn't load current process's symbols)

	hr = TNSymLoadSymbolsForModules("kernel32.dll;user32.dll;ntdll.dll");
	if (hr != S_OK)
	{
		DPL(0, "Couldn't load default symbols (\"kernel32.dll;user32.dll;ntdll.dll\")!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't load default DLL symbols)

	return (S_OK);


ERROR_EXIT:

	// Ignore errors, since we already have one
	TNSymCleanup();

	if (hr == S_OK)
	{
		DPL(0, "WARNING: Converting TNSymInitalize failure of S_OK to E_FAIL!", 0);
		hr = E_FAIL;
	} // end if (failure)

	return (hr);
} // TNSymInitialize
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no symbol initialization
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymCleanup()"
//==================================================================================
// TNSymCleanup
//----------------------------------------------------------------------------------
//
// Description: Cleans up the symbol functions (balances out a TNSymInitialize
//				call).
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNSymCleanup(void)
{
	HRESULT		hr = S_OK;



	if (g_dwTNSymInits == 0)
	{
		DPL(0, "No TNSymInitialize to balance this TNSymCleanup!  DEBUGBREAK()-ing.", 0);
		DEBUGBREAK();
		return (E_FAIL);
	} // end if (no references)

	g_dwTNSymInits--;
	// If there are still more outstanding users, we're done.
	if (g_dwTNSymInits > 0)
		return (S_OK);


#ifndef USE_STATIC_DLL_LINKS
	if (g_hImageHlpDLL != NULL)
	{
		if (g_pfnSymCleanup != NULL)
		{
			// Ignore error
			g_pfnSymCleanup(g_hTNSymProcess);
		} // end if (we successfully called SymInitialize)

		FreeLibrary(g_hImageHlpDLL);
		g_hImageHlpDLL = NULL;
	} // end if (we loaded the DLL)

	if (g_hNTDLL != NULL)
	{
		FreeLibrary(g_hNTDLL);
		g_hNTDLL = NULL;
	} // end if (we loaded the DLL)
#else // USE_STATIC_DLL_LINKS
	if (g_pfnSymCleanup != NULL)
	{
		// Ignore error
		g_pfnSymCleanup(g_hTNSymProcess);
	} // end if (we successfully called SymInitialize)
#endif // USE_STATIC_DLL_LINKS

	g_pfnSymInitialize = NULL;
	g_pfnSymSetOptions = NULL;
	g_pfnSymLoadModule = NULL;
	g_pfnSymCleanup = NULL;
#ifdef _WIN64
	g_pfnSymGetSymFromAddr64 = NULL;
#else // _WIN64
	g_pfnSymGetSymFromAddr = NULL;
#endif // _WIN64
	/*
	g_pfnSymGetSearchPath = NULL;
	g_pfnSymSetSearchPath = NULL;
	*/
	g_pfnImageLoad = NULL;
	g_pfnImageUnload = NULL;
	g_pfnStackWalk = NULL;
	g_pfnSymFunctionTableAccess = NULL;
	g_pfnSymGetModuleBase = NULL;
	g_pfnRtlGetCallersAddress = NULL;


	if (g_hTNSymProcess != NULL)
	{
		CloseHandle(g_hTNSymProcess);
		g_hTNSymProcess = NULL;
	} // end if (we have a process handle)

	g_symbolsloaded.RemoveAll();

	return (S_OK);
} // TNSymCleanup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymSetOptions()"
//==================================================================================
// TNSymSetOptions
//----------------------------------------------------------------------------------
//
// Description: Sets options for symbol resolution.
//
// Arguments:
//	BOOL fResolveUndecorated	Whether symbol names should be resolved as
//								undecorated or not (default is FALSE).
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNSymSetOptions(BOOL fResolveUndecorated)
{
	DWORD	dwOptions;


	if (g_fTNSymSomeFuncsUnavailable)
		return (S_OK);
		
	// We always want to defer loading the symbols.
	dwOptions = SYMOPT_DEFERRED_LOADS;

	if (fResolveUndecorated)
		dwOptions |= SYMOPT_UNDNAME;

	g_pfnSymSetOptions(dwOptions);

	return (S_OK);
} // TNSymSetOptions
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // not supporting symbol lookup
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymResolve()"
//==================================================================================
// TNSymResolve
//----------------------------------------------------------------------------------
//
// Description: Attempts to resolve the given pointer to a symbol and/or offset. The
//				result is stored in the specified string.  If no symbol was found or
//				symbol resolution wasn't initialized, the value of the pointer (in
//				hexadecimal) is written to the string.
//
// Arguments:
//	PVOID pvPointer		Pointer to attempt to resolve.
//	char* szString		String to store result in.
//	DWORD dwStringSize	Size of string buffer, including room for NULL termination.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNSymResolve(PVOID pvPointer, char* szString, DWORD dwStringSize)
{
	HRESULT				hr = S_OK;
#ifdef _WIN64
	PIMAGEHLP_SYMBOL64	pSym64 = NULL;
#else // _WIN64
	PIMAGEHLP_SYMBOL	pSym = NULL;
#endif // _WIN64
	DWORD_PTR			dwOffset;
	char				szModuleName[1024];


	/*
	if (g_fTNSymSomeFuncsUnavailable)
	{
		wsprintf(szString, "0x" SPRINTF_PTR, lpvPointer);
		return (S_OK);
	} // end if (unavailable)
	*/

	if (g_dwTNSymInits == 0) 
	{
		DPL(0, "TNSymInitialize was not successfully called!", 0);
		hr = TNSYMERR_UNINITIALIZED;

		// We're still going to write the pointer's value, though.
		wsprintf(szString, "0x" SPRINTF_PTR, pvPointer);

		goto DONE;
	} // end if (sym not initialized)

	if (pvPointer != NULL)
	{
		ZeroMemory(szModuleName, 1024);

		hr = TNSymGetModuleNameAndOffsetForPointer(pvPointer, szModuleName,
													1024, &dwOffset);
		if ((hr != S_OK) || (strcmp(szModuleName, "") == 0))
		{
			/*
			DPL(0, "Failed getting module name for pointer %x!", 1, pvPointer);
			goto DONE;
			*/

			// Just print the raw pointer directly
			wsprintf(szString, "0x" SPRINTF_PTR, pvPointer);
			hr = S_OK;
		} // end if (couldn't get a module name for pointer)
		else
		{
			if (g_fTNSymSomeFuncsUnavailable)
			{
				wsprintf(szString, "%s + 0x" SPRINTF_PTR " (0x" SPRINTF_PTR ")", szModuleName,
						dwOffset, pvPointer);
			} // end if (symbol functions not available)
			else
			{
#ifdef _WIN64
				pSym64 = (PIMAGEHLP_SYMBOL64) LocalAlloc(LPTR, sizeof (IMAGEHLP_SYMBOL64) + dwStringSize);
				if (pSym64 == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				pSym64->SizeOfStruct = sizeof (IMAGEHLP_SYMBOL64) + dwStringSize;
				pSym64->MaxNameLength = dwStringSize - 1;

				if (g_pfnSymGetSymFromAddr64(g_hTNSymProcess, (DWORD_PTR) pvPointer, &dwOffset, pSym64))
				{
					wsprintf(szString, "%s!%s + 0x" SPRINTF_PTR " (0x" SPRINTF_PTR ")",
							szModuleName, pSym64->Name, dwOffset, pvPointer);
				} // end if (get the symbol was successful)
#else // _WIN64
				pSym = (PIMAGEHLP_SYMBOL) LocalAlloc(LPTR, sizeof (IMAGEHLP_SYMBOL) + dwStringSize);
				if (pSym == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				pSym->SizeOfStruct = sizeof (IMAGEHLP_SYMBOL) + dwStringSize;
				pSym->MaxNameLength = dwStringSize - 1;

				if (g_pfnSymGetSymFromAddr(g_hTNSymProcess, (DWORD_PTR) pvPointer, &dwOffset, pSym))
				{
					wsprintf(szString, "%s!%s + 0x" SPRINTF_PTR " (0x" SPRINTF_PTR ")",
							szModuleName, pSym->Name, dwOffset, pvPointer);
				} // end if (get the symbol was successful)
#endif // _WIN64
				else
				{
					hr = GetLastError();
					if ((hr == ERROR_MOD_NOT_FOUND) || (hr == ERROR_INVALID_ADDRESS))
					{
						wsprintf(szString, "%s + 0x" SPRINTF_PTR " (0x" SPRINTF_PTR ")", szModuleName,
								dwOffset, pvPointer);

						// It was an error we handled, so consider it "okay"
						hr = S_OK;
					} // end if (there just wasn't a symbol there)
					else
					{
						DPL(0, "SymGetSymFromAddr (%x) is a failure!", 1, pvPointer);
						goto DONE;
					} // end else (some other error)
				} // end else (failed to find a symbol)
			} // end else (symbol functions available)
		} // end else (successfully got module name)
	} // end if (the memory is not NULL)
	else
	{
		strcpy(szString, "0x00000000");
	} // end else (the memory is NULL)

	

DONE:

#ifdef _WIN64
	if (pSym64 != NULL)
	{
		LocalFree(pSym64);
		pSym64 = NULL;
	} // end if (have symbol object)
#else // _WIN64
	if (pSym != NULL)
	{
		LocalFree(pSym);
		pSym = NULL;
	} // end if (have symbol object)
#endif // _WIN64

	return (hr);
} // TNSymResolve
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#else // ! XBOX
//#pragma BUGBUG(tristanj, "May need to come up with an alternative for symbol lookup")
#endif // XBOX



#ifndef _XBOX // no symbol initialization
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymLoadSymbolsForModules()"
//==================================================================================
// TNSymLoadSymbolsForModules
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	char* szModulesList		List of paths to modules to load symbols for, separated
//							by semicolons.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNSymLoadSymbolsForModules(char* szModulesList)
{
	HRESULT			hr = S_OK;
	char*			pszFields = NULL;
	char*			pszSymbol;
	DWORD			dwTemp;
	DWORD			dwNumFields;


	if (g_fTNSymSomeFuncsUnavailable)
		return (S_OK);
		
	if (g_dwTNSymInits == 0) 
	{
		DPL(0, "TNSymInitialize was not successfully called!", 0);
		hr = TNSYMERR_UNINITIALIZED;
		goto DONE;
	} // end if (sym not initialized)

	/*
	{
		char	szTemp[1024];


		if (g_pfnSymGetSearchPath(g_hTNSymProcess, szTemp, 1024))
		{
			DPL(0, "Sym search path = \"%s\"", 1, szTemp);
		}
	}
	*/

	dwTemp = strlen(szModulesList) + 1;
	pszFields = (char*) LocalAlloc(LPTR, dwTemp);
	if (pszFields == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	dwNumFields = StringSplitIntoFields(szModulesList, ";", pszFields, &dwTemp);

	for(dwTemp = 0; dwTemp < dwNumFields; dwTemp++)
	{
		pszSymbol = StringGetFieldPtr(pszFields, dwTemp);

		// If the symbol hasn't already been loaded, look for it
#pragma BUGBUG(vanceo, "make path tolerant")
		if (g_symbolsloaded.GetStringIndex(pszSymbol, 0, FALSE) < 0)
		{
			PLOADED_IMAGE	pLoadedImage;
			DWORD_PTR		dwModuleAddress;
			DWORD			dwModuleSize;


			DPL(0, "Loading symbols for \"%s\".", 1, pszSymbol);


			dwModuleAddress = (DWORD_PTR) GetModuleHandle(pszSymbol);

			// Load the module to retrieve its size.
			pLoadedImage = g_pfnImageLoad(pszSymbol, NULL);
			if (pLoadedImage == NULL)
			{
				hr = GetLastError();
				DPL(0, "Couldn't load \"%s\" image!", 1, pszSymbol);
				goto DONE;
			} // end if (couldn't load image)
			dwModuleSize = pLoadedImage->SizeOfImage;

			// Ignore error
			g_pfnImageUnload(pLoadedImage);
			pLoadedImage = NULL;


			// Try to load symbols the caller wants to add.
			if (! g_pfnSymLoadModule(g_hTNSymProcess, NULL, pszSymbol, NULL, dwModuleAddress, dwModuleSize))
			{
				hr = GetLastError();

				DPL(0, "Trying to load symbols for \"%s\" failed!  %e", 2, pszSymbol, hr);

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (failed loading symbols using defaults)
			
			hr = g_symbolsloaded.AddString(pszSymbol);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add string \"%s\" to symbols loaded list!", 1, pszSymbol);
				goto DONE;
			} // end if (couldn't add string)
		} // end if ()
		else
		{
			DPL(0, "Already loaded symbols for \"%s\".", 1, pszSymbol);
		} // end else ()
	} // end for (each symbol to load)


DONE:

	if (pszFields != NULL)
	{
		LocalFree(pszFields);
		pszFields = NULL;
	} // end if (allocated string)

	return (hr);
} // TNSymLoadSymbolsForModules
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no GetModuleFileName supported, so don't implement this now
#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymGetModuleNameAndOffsetForPointer()"
//==================================================================================
// TNSymGetModuleNameAndOffsetForPointer
//----------------------------------------------------------------------------------
//
// Description: Retrieves the name of the module in which the pointer lies, plus its
//				offset from the start of that module and stores it into the string
//				buffer given.
//				This function does not require TNSymInitialize to have been called
//				in order to work.
//
// Arguments:
//	PVOID pvPointer		Pointer to attempt to resolve.
//	char* pszName		String to store result in.
//	DWORD dwNameSize	Size of string buffer, including room for NULL termination.
//	DWORD* pdwOffset	Size of string buffer, including room for NULL termination.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT TNSymGetModuleNameAndOffsetForPointer(PVOID pvPointer, char* pszName,
											DWORD dwNameSize, PDWORD_PTR pdwOffset)
{
	HRESULT						hr;
	MEMORY_BASIC_INFORMATION	mbi;



	ZeroMemory(&mbi, sizeof (MEMORY_BASIC_INFORMATION));
	if (VirtualQuery(pvPointer, &mbi, sizeof (MEMORY_BASIC_INFORMATION)) == 0)
	{
		hr = GetLastError();
		//DPL(0, "VirtualQuery failed!", 0);
		return (hr);
	} // end if (geting pointer information failed)

	if ((pszName != NULL) && (dwNameSize > 0))
	{
		if (mbi.AllocationBase > 0)
		{
			if (GetModuleFileName((HMODULE) mbi.AllocationBase, pszName, dwNameSize) == 0)
			{
				hr = GetLastError();

				// This is just from observation, is this right?
				if (mbi.AllocationBase == GetProcessHeap())
				{
					strcpy(pszName, "ProcessHeap");
					hr = S_OK;
				} // end if (it's part of the process heap)
				else
				{
					//DPL(1, "Failed getting module filename!  %e", 1, hr);

					if (hr == S_OK)
						hr = E_FAIL;

					return (hr);
				} // end else (it's not part of the process heap)
			} // end if (getting module filename failed)
			else
			{
				FileGetNameWithoutExtension(pszName, pszName, FALSE);
				_strupr(pszName);
			} // end else (successfully got module filename)
		} // end if (the memory is in a module)
		else
		{
			strcpy(pszName, "");
		} // end else (the memory is not in a module)
	} // end if (the caller wants the module name)

	if (pdwOffset != NULL)
	{
		(*pdwOffset) = ((LPBYTE) pvPointer) - ((LPBYTE) mbi.AllocationBase);
	} // end if (the caller wants the offset)

	return (S_OK);
} // TNSymGetModuleNameAndOffsetForPointer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymGetDisableSymResolutionSetting()"
//==================================================================================
// TNSymGetDisableSymResolutionSetting
//----------------------------------------------------------------------------------
//
// Description: Retrieves the current DisableSymResolution setting.
//
// Arguments: None.
//
// Returns: TRUE if DisableSymResolution is set, FALSE if not.
//==================================================================================
BOOL TNSymGetDisableSymResolutionSetting(void)
{
#ifndef _XBOX // no registry supported
	HRESULT		hr;
	HKEY		hKey = NULL;
	DWORD		dwType;
	DWORD		dwValue;
	DWORD		dwValueSize;

	// Open the registry setting for controlling symbol resolution.
	hr = RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_TESTNET, &hKey);
	if (hr != ERROR_SUCCESS)
	{
		DPL(1, "WARNING: Couldn't open key HKLM\\%s!  %e",
			2, REGKEY_TESTNET, hr);
		return (FALSE);
	} // end if (couldn't open key)


	dwValueSize = sizeof (DWORD);
	hr = RegQueryValueEx(hKey, REGVALUE_DISABLESYMBOLRESOLUTION, NULL,
						&dwType, (LPBYTE) &dwValue, &dwValueSize);
	if (hr != ERROR_SUCCESS)
	{
		DPL(1, "WARNING: Couldn't query HKLM\\%s value %s!  %e",
			3, REGKEY_TESTNET, REGVALUE_DISABLESYMBOLRESOLUTION, hr);

		// Close the key since we're bailing.
		RegCloseKey(hKey);
		hKey = NULL;

		return (FALSE);
	} // end if (couldn't query value)

	
	// Close the key, we're done with it.
	RegCloseKey(hKey);
	hKey = NULL;

	if (dwType != REG_DWORD)
	{
		DPL(1, "WARNING: HKLM\\%s value %s is not a DWORD!  %e",
			3, REGKEY_TESTNET, REGVALUE_DISABLESYMBOLRESOLUTION, hr);
		return (FALSE);
	} // end if (not a DWORD)

#else // ! XBOX
#pragma TODO(tristanj, "Hardcoded to always disable symbol resolution")
	DWORD		dwValue;
	dwValue = 1;
#endif // XBOX

	// Return the setting
	return ((dwValue != 0) ? TRUE : FALSE);
} // TNSymGetDisableSymResolutionSetting
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"TNSymSetDisableSymResolutionSetting()"
//==================================================================================
// TNSymSetDisableSymResolutionSetting
//----------------------------------------------------------------------------------
//
// Description: Stores the DisableSymResolution setting specified.
//
// Arguments:
//	BOOL fDisable	Set to TRUE to disable symbol resolution, or FALSE to leave
//					enabled.
//
// Returns: None.
//==================================================================================
void TNSymSetDisableSymResolutionSetting(BOOL fDisable)
{
#ifndef _XBOX // no registry supported
	HRESULT		hr;
	HKEY		hKey = NULL;
	DWORD		dwValue;


	// Open the registry setting for controlling symbol resolution.
	hr = RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_TESTNET, &hKey);
	if (hr != ERROR_SUCCESS)
	{
		DPL(1, "WARNING: Couldn't create key HKLM\\%s!  %e",
			2, REGKEY_TESTNET, hr);
		return;
	} // end if (couldn't open key)


	dwValue = (fDisable) ? 1 : 0;
	hr = RegSetValueEx(hKey, REGVALUE_DISABLESYMBOLRESOLUTION, 0, REG_DWORD,
						((BYTE*) (&dwValue)), (sizeof (DWORD)));
	if (hr != ERROR_SUCCESS)
	{
		DPL(1, "WARNING: Couldn't save HKLM\\%s value %s!  %e",
			3, REGKEY_TESTNET, REGVALUE_DISABLESYMBOLRESOLUTION, hr);

		// Continuing...
	} // end if (couldn't query value)

	
	// Close the key, we're done with it.
	RegCloseKey(hKey);
	hKey = NULL;
#else // ! XBOX
#pragma TODO(tristanj, "Hardcoded to ignore desired symbol resolution")
#endif // XBOX

} // TNSymSetDisableSymResolutionSetting
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\strutils.h ===
#ifndef __TNCOMMON_STRUTILS__
#define __TNCOMMON_STRUTILS__





//==================================================================================
// Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#ifndef ERROR_BUFFER_TOO_SMALL
#define ERROR_BUFFER_TOO_SMALL		603L
#endif // ! ERROR_BUFFER_TOO_SMALL





//==================================================================================
// Array element definition
//==================================================================================
typedef struct tagTNFLAGTABLEITEM
{
	DWORD_PTR	dwFlag; // the flag value
	char*		szString; // textual representation of the flag
} TNFLAGTABLEITEM, * PTNFLAGTABLEITEM;





//==================================================================================
// Prototypes
//==================================================================================
DLLEXPORT BOOL StringStartsWith(char* szString, char* szPrefix, BOOL fMatchCase);

DLLEXPORT BOOL StringEndsWith(char* szString, char* szSuffix, BOOL fMatchCase);


DLLEXPORT int StringContainsChar(char* szString, char cCharToFind, BOOL fMatchCase,
								int iPos);

DLLEXPORT int StringCountNumChars(char* szString, char cCharToFind, BOOL fMatchCase);

DLLEXPORT int StringContainsOneOfChars(char* szString, char* szCharsToFind,
										BOOL fMatchCase, int iPos);

DLLEXPORT int StringContainsNonChar(char* szString, char* szCharsAllowed,
									BOOL fMatchCase, int iPos);


DLLEXPORT BOOL StringCmpNoCase(char* szString1, char* szString2);

DLLEXPORT BOOL StringMatchesWithWildcard(char* szWildcardString, char* szCompareString,
										BOOL fMatchCase);

DLLEXPORT int StringContainsString(char* szString, char* szSubstring,
									BOOL fMatchCase, int iPos);


DLLEXPORT BOOL StringIsTrue(char* szString);

DLLEXPORT void StringGetKey(char* szString, char* szResult);

DLLEXPORT char* StringGetKeyValue(char* szString);

DLLEXPORT BOOL StringIsKey(char* szString, char* szKeyName);

DLLEXPORT BOOL StringIsValueTrue(char* szString);


DLLEXPORT BOOL StringIsCharBackslashEscaped(char* szString, char* pcChar);



DLLEXPORT int StringPopLeadingChars(char* szString, char* szPopChars,
									BOOL fMatchCase);

DLLEXPORT int StringPopTrailingChars(char* szString, char* szPopChars,
									BOOL fMatchCase);


DLLEXPORT void StringPrepend(char* szString, char* szPrefix);

DLLEXPORT BOOL StringSplit(char* szString, unsigned int uiSplitPoint,
							char* szFirst, char* szLast);


DLLEXPORT unsigned int StringSplitIntoFixedFields(char* szString,
												char* szSplitChars,
												char* resultArray,
												unsigned int uiMaxResults,
												unsigned int uiStringLength);

DLLEXPORT DWORD StringSplitIntoFields(char* szString, char* szSplitChars,
									char* pszResultBuffer,
									DWORD* pdwResultBufferSize);

DLLEXPORT char* StringGetFieldPtr(char* szFieldsBuffer, DWORD dwFieldNum);


DLLEXPORT HRESULT StringGetBetween(char* szSource,
								   char* szStartToken,
									char* pszEndToken,
									BOOL fMatchCase,
									BOOL fKeepTokensInOutside,
									BOOL fKeepTokensInInside,
									BOOL fCheckForNonEscapedStart,
									BOOL fCheckForNonEscapedEnd,
									int* piPos,
									char* pszOutside,
									char* pszInside,
									BOOL* pfUnfinished);

DLLEXPORT int StringReplaceAll(char* szString, char* szSearchString,
								char* szReplaceString, BOOL fMatchCase, int iPos,
								unsigned int uiStringLength);


DLLEXPORT int StringToInt(char* szString);

DLLEXPORT DWORD StringNumDWordDigits(DWORD dwValue);

DLLEXPORT DWORD StringToDWord(char* szString);

DLLEXPORT DWORD StringHexToDWord(char* szString);

DLLEXPORT HRESULT StringToGuid(char* szString, GUID* pguidResult);

DLLEXPORT void StringDWordToIPAddress(DWORD dwValue, char* szResult);

DLLEXPORT DWORD StringNumIntDigits(int iValue);

DLLEXPORT void StringIntToZeroPaddedStr(int iNum, int iDigits, char* szString);

DLLEXPORT char StringIntToChar(int iNum);

DLLEXPORT void StringBufferToHexStr(PVOID pvBuffer, DWORD dwBufferSize, char* szResult);


DLLEXPORT HRESULT StringEnclosePathSpacesInQuotes(char* szPath,
												char* pszResultBuffer,
												DWORD* pdwResultBufferSize);


DLLEXPORT HRESULT StringURLEncode(char* szString, char* pszEncodedString,
								DWORD* pdwEncodedStringSize);


DLLEXPORT void StringGetCurrentDateStr(char* szString);

DLLEXPORT void StringGetCurrentDateStrShort(char* szString);

DLLEXPORT void StringGetCurrentTimeStr(char* szString);


DLLEXPORT void StringGetStrFromFiletime(FILETIME* pFiletime, BOOL fAbbreviated,
										char* szString);


DLLEXPORT WCHAR* StringCpyAToU(WCHAR* wszUnicodeString, char* szANSIString);

DLLEXPORT char* StringCpyUToA(char* szANSIString, WCHAR* wszUnicodeString);

DLLEXPORT WCHAR* StringCatAToU(WCHAR* wszUnicodeString, char* szANSIString);

DLLEXPORT BOOL StringCmpAToU(WCHAR* wszUnicodeString, char* szANSIString,
							BOOL fMatchCase);

DLLEXPORT DWORD_PTR StringGetFlags(char* szString, PTNFLAGTABLEITEM paFlagTable,
									DWORD_PTR dwNumFlagsInTable,
									BOOL fCaseSensitive);

DLLEXPORT HRESULT StringAddFlags(DWORD_PTR dwFlags, PTNFLAGTABLEITEM paFlagTable,
								DWORD_PTR dwNumFlagsInTable, char* pszString,
								DWORD_PTR* pdwStringSize);




#endif // __TNCOMMON_STRUTILS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\verutils.h ===
#ifndef __TNCOMMON_VERUTILS__
#define __TNCOMMON_VERUTILS__





//==================================================================================
// Common Defines
//==================================================================================
#ifdef LOCAL_TNCOMMON

	// define LOCAL_TNCOMMON when including this code directly into your project
	#ifdef DLLEXPORT
		#undef DLLEXPORT
	#endif // DLLEXPORT defined
	#define DLLEXPORT

#else // ! LOCAL_TNCOMMON

	#ifdef TNCOMMON_EXPORTS

		// define TNCOMMON_EXPORTS only when building the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllexport)

	#else // ! TNCOMMON_EXPORTS

		// default behavior is to import the functions from the TNCOMMON DLL
		#ifdef DLLEXPORT
			#undef DLLEXPORT
		#endif // DLLEXPORT defined
		#define DLLEXPORT __declspec(dllimport)

	#endif // ! TNCOMMON_EXPORTS
#endif // ! LOCAL_TNCOMMON

#ifndef DEBUG
	#ifdef _DEBUG
		#define DEBUG
	#endif // _DEBUG
#endif // DEBUG not defined



//==================================================================================
// Defines
//==================================================================================
#define VEROSID_UNKNOWN			0
#define VEROSID_WINDOWS95GOLD	1
#define VEROSID_WINDOWS95OSR2	2
#define VEROSID_WINDOWSNT4		3
#define VEROSID_WINDOWS98GOLD	4
#define VEROSID_WINDOWS98SE		5
#define VEROSID_WINDOWS2000		6
#define VEROSID_MILLENNIUM		7




//==================================================================================
// Prototypes
//==================================================================================
DLLEXPORT DWORD VerGetOSType(OSVERSIONINFO* lpOSVersion);
DLLEXPORT DWORD VerGetCurrentOSType(void);
#ifndef _XBOX
DLLEXPORT void VerGetStrFromOSVersion(OSVERSIONINFO* pOSVersion, char* szString);
#else
DLLEXPORT void VerGetStrFromOSVersion(OSVERSIONINFOA* pOSVersion, char* szString);
#endif

DLLEXPORT void VerGetStrFromCurrentOSVersion(char* szString);

#ifndef _XBOX // GetFileVersionInfo not supported
DLLEXPORT BOOL VerGetBinaryVersionInfo(char* szFile, DWORD* pdwVersionMS,
										DWORD* pdwVersionLS, BOOL* pfDebug);
#endif // ! XBOX






#endif // __TNCOMMON_STRUTILS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\classes.h ===
#ifndef __TNCONTROL_CLASSES__
#define __TNCONTROL_CLASSES__
//#pragma message("Defining __TNCONTROL_CLASSES__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// Class Typedefs
//==================================================================================
typedef class CTNBinary					CTNBinary,					* PTNBINARY;
typedef class CTNBinaryLocsList			CTNBinaryLocsList,			* PTNBINARYLOCSLIST;
typedef class CTNBinaryManager			CTNBinaryManager,			* PTNBINARYMANAGER;

typedef class CTNCOMPort				CTNCOMPort,					* PTNCOMPORT;
typedef class CTNCOMPortsList			CTNCOMPortsList,			* PTNCOMPORTSLIST;
typedef class CTNControlLayer			CTNControlLayer,			* PTNCONTROLLAYER;
typedef class CTNCtrlComm				CTNCtrlComm,				* PTNCTRLCOMM;
typedef class CTNCtrlCommTCP			CTNCtrlCommTCP,				* PTNCTRLCOMMTCP;

typedef class CTNExecutor				CTNExecutor,				* PTNEXECUTOR;
typedef class CTNExecutorPriv			CTNExecutorPriv,			* PTNEXECUTORPRIV;

typedef class CTNFaultSim				CTNFaultSim,				* PTNFAULTSIM;
typedef class CTNFaultSimIMTest			CTNFaultSimIMTest,			* PTNFAULTSIMIMTEST;
typedef class CTNFaultSimsList			CTNFaultSimsList,			* PTNFAULTSIMSLIST;

typedef class CTNIPAddress				CTNIPAddress,				* PTNIPADDRESS;
typedef class CTNIPAddressesList		CTNIPAddressesList,			* PTNIPADDRESSESLIST;

#ifndef _XBOX // no IPC supported
typedef class CTNIPCObject				CTNIPCObject,				* PTNIPCOBJECT;
typedef class CTNIPCObjectsList			CTNIPCObjectsList,			* PTNIPCOBJECTSLIST;
#endif // ! XBOX

typedef class CTNJob					CTNJob,						* PTNJOB;
typedef class CTNJobQueue				CTNJobQueue,				* PTNJOBQUEUE;

#ifndef _XBOX // no IPC supported
typedef class CTNLeech					CTNLeech,					* PTNLEECH;
typedef class CTNLeechesList			CTNLeechesList,				* PTNLEECHESLIST;
#endif // ! XBOX

typedef class CTNMachineInfo			CTNMachineInfo,				* PTNMACHINEINFO;
#ifndef _XBOX // no master supported
typedef class CTNMaster					CTNMaster,					* PTNMASTER;
typedef class CTNMasterInfo				CTNMasterInfo,				* PTNMASTERINFO;
typedef class CTNMastersList			CTNMastersList,				* PTNMASTERSLIST;
typedef class CTNMetaMaster				CTNMetaMaster,				* PTNMETAMASTER;
#endif // ! XBOX

typedef class CTNOtherMachineInfo		CTNOtherMachineInfo,		* PTNOTHERMACHINEINFO;
typedef class CTNOtherMachineInfosList	CTNOtherMachineInfosList,	* PTNOTHERMACHINEINFOSLIST;
typedef class CTNOutputVar				CTNOutputVar,				* PTNOUTPUTVAR;
typedef class CTNOutputVarsList			CTNOutputVarsList,			* PTNOUTPUTVARSLIST;

typedef class CTNPeriodicSend			CTNPeriodicSend,			* PTNPERIODICSEND;
typedef class CTNPeriodicSendsList		CTNPeriodicSendsList,		* PTNPERIODICSENDSLIST;

typedef class CTNReachCheck				CTNReachCheck,				* PTNREACHCHECK;
typedef class CTNReachChecksList		CTNReachChecksList,			* PTNREACHCHECKSLIST;
typedef class CTNReachCheckTarget		CTNReachCheckTarget,		* PTNREACHCHECKTARGET;
typedef class CTNReachCheckTargetsList	CTNReachCheckTargetsList,	* PTNREACHCHECKTARGETSLIST;

#ifndef _XBOX // reports not supported
typedef class CTNReport					CTNReport,					* PTNREPORT;
typedef class CTNReportsList			CTNReportsList,				* PTNREPORTSLIST;
#endif // ! XBOX

typedef class CTNResult					CTNResult,					* PTNRESULT;
typedef class CTNResultsChain			CTNResultsChain,			* PTNRESULTSCHAIN;

typedef class CTNSendData				CTNSendData,				* PTNSENDDATA;
typedef class CTNSendDataQueue			CTNSendDataQueue,			* PTNSENDDATAQUEUE;
typedef class CTNSlave					CTNSlave,					* PTNSLAVE;
typedef class CTNSlaveInfo				CTNSlaveInfo,				* PTNSLAVEINFO;
typedef class CTNSlavesList				CTNSlavesList,				* PTNSLAVESLIST;
typedef class CTNSoundCard				CTNSoundCard,				* PTNSOUNDCARD;
typedef class CTNSoundCardsList			CTNSoundCardsList,			* PTNSOUNDCARDSLIST;
typedef class CTNStoredData				CTNStoredData,				* PTNSTOREDDATA;
typedef class CTNStoredDataList			CTNStoredDataList,			* PTNSTOREDDATALIST;
typedef class CTNSyncData				CTNSyncData,				* PTNSYNCDATA;
typedef class CTNSyncDataList			CTNSyncDataList,			* PTNSYNCDATALIST;
typedef class CTNSystemResult			CTNSystemResult,			* PTNSYSTEMRESULT;

typedef class CTNTAPIDevice				CTNTAPIDevice,				* PTNTAPIDEVICE;
typedef class CTNTAPIDevicesList		CTNTAPIDevicesList,			* PTNTAPIDEVICESLIST;
typedef class CTNTestFromFile			CTNTestFromFile,			* PTNTESTFROMFILE;
typedef class CTNTestFromFilesList		CTNTestFromFilesList,		* PTNTESTFROMFILESLIST;
typedef class CTNTestInstanceM			CTNTestInstanceM,			* PTNTESTINSTANCEM;
typedef class CTNTestInstanceS			CTNTestInstanceS,			* PTNTESTINSTANCES;
typedef class CTNTestMsList				CTNTestMsList,				* PTNTESTMSLIST;
typedef class CTNTestSsList				CTNTestSsList,				* PTNTESTSSLIST;
typedef class CTNTestResult				CTNTestResult,				* PTNTESTRESULT;
typedef class CTNTestStats				CTNTestStats,				* PTNTESTSTATS;
typedef class CTNTestTableItem			CTNTestTableItem,			* PTNTESTTABLEITEM;
typedef class CTNTestTableCase			CTNTestTableCase,			* PTNTESTTABLECASE;
typedef class CTNTestTableGroup			CTNTestTableGroup,			* PTNTESTTABLEGROUP;
typedef class CTNTrackedBinaries		CTNTrackedBinaries,			* PTNTRACKEDBINARIES;





#else //__TNCONTROL_CLASSES__
//#pragma message("__TNCONTROL_CLASSES__ already included!")
#endif //__TNCONTROL_CLASSES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncommon\verutils.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#ifdef _XBOX // conversion functions
#include "convhelp.h"
#endif

#include "main.h"
#ifndef NO_TNCOMMON_DEBUG_SPEW
#include "debugprint.h"
#endif // ! NO_TNCOMMON_DEBUG_SPEW

#include "verutils.h"




#undef DEBUG_SECTION
#define DEBUG_SECTION	"VerGetOSType()"
//==================================================================================
// VerGetOSType
//----------------------------------------------------------------------------------
//
// Description: Returns the OS type ID for the OS described by the passed in
//				OSVERSIONINFO structure.
//
// Arguments:
//	OSVERSIONINFO* pOSVersion	Pointer to structure describing OS.
//
// Returns: ID of OS, or VEROSID_UNKNOWN if couldn't determine or an error occurred.
//==================================================================================
DWORD VerGetOSType(OSVERSIONINFO* pOSVersion)
{
	if (pOSVersion->dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		if ((pOSVersion->dwMajorVersion == 4) &&
			(pOSVersion->dwMinorVersion == 0) &&
			(pOSVersion->dwBuildNumber == 1381))
		{
			return (VEROSID_WINDOWSNT4);
		}
		else if (pOSVersion->dwMajorVersion == 5)
		{
			return (VEROSID_WINDOWS2000);
		}
	} // end if (an NT OS)
	else
	{
		if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
			(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 0) &&
			(LOWORD(pOSVersion->dwBuildNumber) == 950))
		{
			return (VEROSID_WINDOWS95GOLD);
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
			(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 0) &&
			(LOWORD(pOSVersion->dwBuildNumber) == 1111))
		{
			return (VEROSID_WINDOWS95OSR2);
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 10) &&
				(LOWORD(pOSVersion->dwBuildNumber) == 1998))
		{
			return (VEROSID_WINDOWS98GOLD);
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 10) &&
				(LOWORD(pOSVersion->dwBuildNumber) == 2222))
		{
			return (VEROSID_WINDOWS98SE);
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 90))
		{
			return (VEROSID_MILLENNIUM);
		}
	} // end else (a Win9x OS)

	return (VEROSID_UNKNOWN);
} // VerGetOSType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"VerGetCurrentOSType()"
//==================================================================================
// VerGetCurrentOSType
//----------------------------------------------------------------------------------
//
// Description: Returns the OS type ID for the OS this machine is currently running.
//
// Arguments: None.
//
// Returns: ID of OS, or VEROSID_UNKNOWN if couldn't determine or an error occurred.
//==================================================================================
DWORD VerGetCurrentOSType(void)
{
	OSVERSIONINFO		ovi;


	ZeroMemory(&ovi, sizeof (OSVERSIONINFO));
	ovi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	if (! GetVersionEx(&ovi))
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		HRESULT		hr;


		hr = GetLastError();

		DPL(0, "Couldn't get OS version information!  %e", 1, hr);
#endif // NO_TNCOMMON_DEBUG_SPEW
		return (VEROSID_UNKNOWN);
	} // end if (couldn't get OS version info)

	return (VerGetOSType(&ovi));
} // VerGetCurrentOSType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"VerGetStrFromOSVersion()"
//==================================================================================
// VerGetStrFromOSVersion
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in OS version information into a string.
//
// Arguments:
//	OSVERSIONINFO* pOSVersion	Pointer to OS information to convert to a string.
//	char* szString				The string to store the results in.
//
// Returns: None.
//==================================================================================
#ifndef _XBOX
void VerGetStrFromOSVersion(OSVERSIONINFO* pOSVersion, char* szString)
#else
void VerGetStrFromOSVersion(OSVERSIONINFOA* pOSVersion, char* szString)
#endif
{
	char	szKnownOS[256];

	ZeroMemory(szKnownOS, 256);

	if (pOSVersion->dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		wsprintf(szString, "%i.%i.%i",
				pOSVersion->dwMajorVersion,
				pOSVersion->dwMinorVersion,
				pOSVersion->dwBuildNumber);

		if ((pOSVersion->dwMajorVersion == 4) &&
			(pOSVersion->dwMinorVersion == 0) &&
			(pOSVersion->dwBuildNumber == 1381))
		{
			strcpy(szKnownOS, "Windows NT4");
		}
		else if (pOSVersion->dwMajorVersion == 5)
		{
			wsprintf(szKnownOS, "Windows 2000 build %i", pOSVersion->dwBuildNumber);
		}
		else
		{
			strcpy(szKnownOS, "Unknown NT based OS");
		}
	} // end if (an NT OS)
	else
	{
		wsprintf(szString, "%i.%i.%i",
				HIBYTE(HIWORD(pOSVersion->dwBuildNumber)),
				LOBYTE(HIWORD(pOSVersion->dwBuildNumber)),
				LOWORD(pOSVersion->dwBuildNumber));

		if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
			(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 0) &&
			(LOWORD(pOSVersion->dwBuildNumber) == 950))
		{
			strcpy(szKnownOS, "Windows 95 Gold");
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
			(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 0) &&
			(LOWORD(pOSVersion->dwBuildNumber) == 1111))
		{
			strcpy(szKnownOS, "Windows 95 OSR2");
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 10) &&
				(LOWORD(pOSVersion->dwBuildNumber) == 1998))
		{
			strcpy(szKnownOS, "Windows 98 Gold");
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 10) &&
				(LOWORD(pOSVersion->dwBuildNumber) == 2222))
		{
			strcpy(szKnownOS, "Windows 98 SE");
		}
		else if ((HIBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(pOSVersion->dwBuildNumber)) == 90))
		{
			wsprintf(szKnownOS, "Millennium build %i", LOWORD(pOSVersion->dwBuildNumber));
		}
		else
		{
			strcpy(szKnownOS, "Unknown 9x based OS");
		}
	} // end else (a Win9x OS)

	if (strcmp(pOSVersion->szCSDVersion, "") != 0)
	{
		// If there was known OS info there before, tack on a separator
		//if (strcmp(szKnownOS, "") != 0)
			strcat(szKnownOS, " - ");
		
			strcat(szKnownOS, pOSVersion->szCSDVersion);
	} // end if (there's a service pack/extra info string)

	//if (strcmp(szKnownOS, "") != 0)
	//{
		strcat(szString, " (");
		strcat(szString, szKnownOS);
		strcat(szString, ")");
	//} // end if (we know about this OS/have an extra description string)
} // VerGetStrFromOSVersion
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"VerGetStrFromCurrentOSVersion()"
//==================================================================================
// VerGetStrFromCurrentOSVersion
//----------------------------------------------------------------------------------
//
// Description: Converts the OS version information for the current machine into a
//				string.
//
// Arguments:
//	char* szString		The string to store the results in.
//
// Returns: None.
//==================================================================================
void VerGetStrFromCurrentOSVersion(char* szString)
{
	OSVERSIONINFO		ovi;
#ifdef _XBOX
	OSVERSIONINFOA		osAnsi;
#endif

	ZeroMemory(&ovi, sizeof (OSVERSIONINFO));
	ovi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	if (! GetVersionEx(&ovi))
	{
#ifndef NO_TNCOMMON_DEBUG_SPEW
		HRESULT		hr;


		hr = GetLastError();

		DPL(0, "Couldn't get string from OS version!  %e", 1, hr);
#endif // NO_TNCOMMON_DEBUG_SPEW
		return;
	} // end if (couldn't get OS version info)

#ifdef _XBOX
	osAnsi.dwBuildNumber = ovi.dwBuildNumber;
	osAnsi.dwMajorVersion = ovi.dwMajorVersion;
	osAnsi.dwMinorVersion = ovi.dwMinorVersion;
	osAnsi.dwOSVersionInfoSize = ovi.dwOSVersionInfoSize;
	osAnsi.dwPlatformId = ovi.dwPlatformId;
	wcstombs(osAnsi.szCSDVersion, ovi.szCSDVersion, wcslen(ovi.szCSDVersion));
	osAnsi.szCSDVersion[wcslen(ovi.szCSDVersion)] = 0;
	VerGetStrFromOSVersion(&osAnsi, szString);
#else
	VerGetStrFromOSVersion(&ovi, szString);
#endif
} // VerGetStrFromCurrentOSVersion
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#ifndef _XBOX // GetFileVersionInfo not supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"VerGetBinaryVersionInfo()"
//==================================================================================
// VerGetBinaryVersionInfo
//----------------------------------------------------------------------------------
//
// Description: Retrieves the version information for the binary specified, if
//				possible.  If none exists or an error occurred, FALSE is returned.
//				Any of the 3 output parameters can be NULL, in which case no data
//				will be returned for that item (duh).
//
// Arguments:
//	char* szFile			The string to store the results in.
//	DWORD* pdwVersionMS		Optional pointer to store most significant version
//							digits.
//	DWORD* pdwVersionLS		Optional pointer to store least significant version
//							digits.
//	BOOL* pfDebug			Optional pointer to boolean which will be set to TRUE if
//							the binary is a debug version, FALSE otherwise.
//
// Returns: TRUE if got version information, FALSE otherwise.
//==================================================================================
BOOL VerGetBinaryVersionInfo(char* szFile, DWORD* pdwVersionMS, DWORD* pdwVersionLS,
							BOOL* pfDebug)
{
	BOOL				fResult = FALSE;
	HRESULT				hr;
	PVOID				pvVersionInfo = NULL;
	DWORD				dwVersionInfoSize = 0;
	DWORD				dwReserved;
	VS_FIXEDFILEINFO*	pVSFFI = NULL;
	UINT				uiSize;


	// Retrieve version information about the file, if available.
	dwVersionInfoSize = GetFileVersionInfoSize(szFile, &dwReserved);
	if (dwVersionInfoSize == 0)
	{
		hr = GetLastError();

		// If the binary doesn't contain any version information, then
		// Win9x returns ERROR_BAD_FORMAT
		// NT5 returns S_OK and ERROR_RESOURCE_DATA_NOT_FOUND sometimes.
		if ((hr == S_OK) ||
			(hr == ERROR_BAD_FORMAT) ||
			(hr == ERROR_RESOURCE_DATA_NOT_FOUND))
		{
			DPL(0, "%s does not contain version information.", 1, szFile);
		} // end if (file doesn't contain version information)
		else
		{
			DPL(0, "GetFileVersionInfoSize for %s failed!  %e", 2, szFile, hr);
		} // end else (other kind of error)

		goto DONE;
	} // end if (could get file version info size)


	pvVersionInfo = LocalAlloc(LPTR, dwVersionInfoSize);
	if (pvVersionInfo == NULL)
		goto DONE;

	if (! GetFileVersionInfo(szFile, 0, dwVersionInfoSize, pvVersionInfo))
	{
		hr = GetLastError();
		DPL(0, "GetFileVersionInfo for %s failed!  %e", 2, szFile, hr);
		goto DONE;
	} // end if (getting file version info failed)

	if (! VerQueryValue(pvVersionInfo, "\\", (PVOID*) &pVSFFI, &uiSize))
	{
		hr = GetLastError();
		DPL(0, "VerQueryValue for %s failed!  %e", 1, szFile);
		goto DONE;
	} // end if (getting version value failed)


	// Store the results.

	if (pdwVersionMS != NULL)
		(*pdwVersionMS) = pVSFFI->dwFileVersionMS;

	if (pdwVersionLS != NULL)
		(*pdwVersionLS) = pVSFFI->dwFileVersionLS;

	if (pfDebug != NULL)
		(*pfDebug) = (pVSFFI->dwFileFlags & VS_FF_DEBUG) ? TRUE : FALSE;



	// If we made it here, everything's cool.
	fResult = TRUE;

	
DONE:

	if (pvVersionInfo != NULL)
	{
		LocalFree(pvVersionInfo);
		pvVersionInfo = NULL;
	} // end if (have version info buffer)


	return (fResult);
} // VerGetBinaryVersionInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\binmgmt.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\fileutils.h"
#include "..\tncommon\symbols.h"

#include "tncontrl.h"
#include "main.h"

#include "binmgmt.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinary::CTNBinary()"
//==================================================================================
// CTNBinary constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNBinary object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNBinary::CTNBinary(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNBinary));

	this->m_pszPath = NULL;
	this->m_fDebug = FALSE;
	this->m_dwMS = 0;
	this->m_dwLS = 0;
	ZeroMemory(&(this->m_createtime), sizeof (FILETIME));
	ZeroMemory(&(this->m_writetime), sizeof (FILETIME));
	this->m_dwFileSizeHigh = 0xFFFFFFFF;
	this->m_dwFileSizeLow = 0xFFFFFFFF;
} // CTNBinary::CTNBinary
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinary::~CTNBinary()"
//==================================================================================
// CTNBinary destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNBinary object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNBinary::~CTNBinary(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pszPath != NULL)
	{
		LocalFree(this->m_pszPath);
		this->m_pszPath = NULL;
	} // end if (allocated a path)
} // CTNBinary::~CTNBinary
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinary::LoadInfo()"
//==================================================================================
// CTNBinary::LoadInfo
//----------------------------------------------------------------------------------
//
// Description: Attempts to load the info for the file at the path already specified
//				for the object.
//				Based on checkver.c by unknown.
//
// Arguments: None.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNBinary::LoadInfo(void)
{
	HRESULT				hr;
	BOOL				fHasVersionInfo = TRUE;
	PVOID				pvVersionInfo = NULL;
	DWORD				dwVersionInfoSize = 0;
	DWORD				dwReserved = 0;
	VS_FIXEDFILEINFO*	pVSFFI = NULL;
	UINT				uSize = 0;
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		founddata;


	if (this->m_pszPath == NULL)
	{
		DPL(0, "Object has no file path specified!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (there's no path for this object)

#ifndef _XBOX // no versioning supported

	// Retrieve version information about the file, if available.

	dwVersionInfoSize = GetFileVersionInfoSize(this->m_pszPath, &dwReserved);
	if (dwVersionInfoSize == 0)
	{
		hr = GetLastError();

		// If the binary doesn't contain any version information, then
		// Win9x returns ERROR_BAD_FORMAT
		// NT5 returns S_OK and ERROR_RESOURCE_DATA_NOT_FOUND sometimes.
		if ((hr == S_OK) ||
			(hr == ERROR_BAD_FORMAT) ||
			(hr == ERROR_RESOURCE_DATA_NOT_FOUND))
		{
			DPL(0, "WARNING: %s does not contain version information!",
				1, this->m_pszPath);
			fHasVersionInfo = FALSE;
		} // end if (file doesn't contain version information)
		else
		{
			DPL(0, "GetFileVersionInfoSize failed for %s!", 1, this->m_pszPath);
			return (hr);
		} // end else (other kind of error)
	} // end if (could get file version info size)

	if (fHasVersionInfo)
	{
		pvVersionInfo = LocalAlloc(LPTR, dwVersionInfoSize);
		if (pvVersionInfo == NULL)
			return (E_OUTOFMEMORY);

		if (! GetFileVersionInfo(this->m_pszPath, 0, dwVersionInfoSize, pvVersionInfo))
		{
			hr = GetLastError();
			DPL(0, "GetFileVersionInfo failed for %s!", 1, this->m_pszPath);
			LocalFree(pvVersionInfo);
			pvVersionInfo = NULL;
			return (hr);
		} // end if (getting file version info failed)

		if (! VerQueryValue(pvVersionInfo, "\\", (LPVOID*) &pVSFFI, &uSize))
		{
			hr = GetLastError();
			DPL(0, "VerQueryValue failed for %s!", 1, this->m_pszPath);
			LocalFree(pvVersionInfo);
			pvVersionInfo = NULL;
			return (hr);
		} // end if (getting querying version value failed)

		this->m_fDebug = (pVSFFI->dwFileFlags & VS_FF_DEBUG) ? TRUE : FALSE;
		this->m_dwMS = pVSFFI->dwFileVersionMS;
		this->m_dwLS = pVSFFI->dwFileVersionLS;

		LocalFree(pvVersionInfo);
		pvVersionInfo = NULL;
	} // end if (the file has version information)

#else // ! XBOX
#pragma TODO(tristanj, "Currently avoiding all GetFileVersionInfo calls")
#endif // XBOX


	// We can't use the GetFileTime and GetFileSize() APIs because they
	// require a handle to an open file, and Windows yells at us if the
	// file is already in use (like a loaded DLL or executing EXE).  Thus
	// we need to grab the info from a FindFile call that searches only
	// for the specified file, because that function happens to return the
	// info we need.

#ifndef _XBOX // Damn Ascii to Unicode conversion...
	hFind = FindFirstFile(this->m_pszPath, &founddata);
#else // ! XBOX
	LPWSTR	pszWidePath = NULL;
	int     nWideSize = 0;

	//Determine the size of the wide string we should be allocating, then allocate it and copy the wide string into it
	nWideSize = MultiByteToWideChar(CP_ACP, 0, this->m_pszPath, strlen(this->m_pszPath), NULL, 0) + 1;
	pszWidePath = (LPWSTR) LocalAlloc(LPTR, nWideSize * sizeof(WCHAR));
	MultiByteToWideChar(CP_ACP, 0, this->m_pszPath, strlen(this->m_pszPath), pszWidePath, nWideSize);
#pragma TODO(tristanj, "Might want to check to make sure this worked")
	hFind = FindFirstFile(pszWidePath, &founddata);
	LocalFree(pszWidePath);
#endif // XBOX

	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		DPL(0, "Couldn't retrieve find info (times and size) for %s!",
			1, this->m_pszPath);
		return (hr);
	} // end if (couldn't find first file)

	CopyMemory(&(this->m_createtime), &(founddata.ftCreationTime), sizeof (FILETIME));
	CopyMemory(&(this->m_writetime), &(founddata.ftLastWriteTime), sizeof (FILETIME));

	this->m_dwFileSizeHigh = founddata.nFileSizeHigh;
	this->m_dwFileSizeLow = founddata.nFileSizeLow;

	if (! FindClose(hFind))
	{
		hr = GetLastError();
		DPL(0, "Couldn't close find file search for %s!",
			1, this->m_pszPath);
		return (hr);
	} // end if (couldn't close search)


	return (S_OK);
} // CTNBinary::LoadInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinary::IsEqualTo()"
//==================================================================================
// CTNBinary::IsEqualTo
//----------------------------------------------------------------------------------
//
// Description: Determines whether the info previously loaded for this object is
//				the same as the passed in object's, excluding the actual files'
//				locations. (i.e., whether the files are the same but at possibly
//				different paths).
//
// Arguments:
//	PTNBINARY pOtherBinary	Pointer to binary to compare this object with.
//
// Returns: TRUE if the files described are the same.
//==================================================================================
BOOL CTNBinary::IsEqualTo(PTNBINARY pOtherBinary)
{
#ifndef _XBOX // no versioning supported

	if (this->m_fDebug != pOtherBinary->m_fDebug)
		return (FALSE);

	if (this->m_dwMS != pOtherBinary->m_dwMS)
		return (FALSE);

	if (this->m_dwLS != pOtherBinary->m_dwLS)
		return (FALSE);

#endif // ! XBOX

	if (CompareFileTime(&(this->m_createtime), &(pOtherBinary->m_createtime)) != 0)
		return (FALSE);

	if (CompareFileTime(&(this->m_writetime), &(pOtherBinary->m_writetime)) != 0)
		return (FALSE);

	if ((this->m_dwFileSizeHigh != pOtherBinary->m_dwFileSizeHigh) ||
		(this->m_dwFileSizeLow != pOtherBinary->m_dwFileSizeLow))
	{
		return (FALSE);
	} // end if (file size isn't the same)

	return (TRUE);
} // CTNBinary::IsEqualTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryLocsList::CTNBinaryLocsList()"
//==================================================================================
// CTNBinaryLocsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNBinaryLocsList object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNBinaryLocsList::CTNBinaryLocsList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNBinaryLocsList));

	this->m_pszName = NULL;
} // CTNBinaryLocsList::CTNBinaryLocsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNBinaryLocsList::~CTNBinaryLocsList()"
//==================================================================================
// CTNBinaryLocsList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNBinaryLocsList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNBinaryLocsList::~CTNBinaryLocsList(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pszName != NULL)
	{
		LocalFree(this->m_pszName);
		this->m_pszName = NULL;
	} // end if (allocated a name)
} // CTNBinaryLocsList::~CTNBinaryLocsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::CTNTrackedBinaries()"
//==================================================================================
// CTNTrackedBinaries constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTrackedBinaries object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTrackedBinaries::CTNTrackedBinaries(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTrackedBinaries));
} // CTNTrackedBinaries::CTNTrackedBinaries
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::~CTNTrackedBinaries()"
//==================================================================================
// CTNTrackedBinaries destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTrackedBinaries object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTrackedBinaries::~CTNTrackedBinaries(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNTrackedBinaries::~CTNTrackedBinaries
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::LocateAndAddBinary()"
//==================================================================================
// CTNTrackedBinaries::LocateAndAddBinary
//----------------------------------------------------------------------------------
//
// Description: Adds all found files with the specified name to the list of tracked
//				binaries.
//
// Arguments:
//	char* szBinaryName		Name of binary to identify and manage.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTrackedBinaries::LocateAndAddBinary(char* szBinaryName)
{
#ifndef _XBOX // no binary management supported
	HRESULT				hr = S_OK;
	PTNBINARYLOCSLIST	pBinLocs = NULL;
	CLStringList		searchpaths;
	CLStringList		foundpaths;
	char*				pszTemp = NULL;
	char*				pszPathVar = NULL;
	PTNBINARY			pBin = NULL;
	DWORD				dwBufferSize = 0;
	int					i;
	DWORD				dwSize;
	DWORD				dwField;
	DWORD				dwNumFields;
	char*				pszField;

	if (szBinaryName == NULL)
	{
		DPL(0, "Attempting to add NULL data!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (the binary name doesn't exist)

	pBinLocs = new (CTNBinaryLocsList);
	if (pBinLocs == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pBinLocs->m_pszName = (char*) LocalAlloc(LPTR, (strlen(szBinaryName) + 1));
	if (pBinLocs->m_pszName == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	
	strcpy(pBinLocs->m_pszName, szBinaryName);


	// We should be checking (in order):
	//		
	//		 1. The directory from which the application loaded.
	//		 2. The current directory.
	//			Windows 95: The Windows system directory. Use the
	//				GetSystemDirectory function to get the path of this directory.
	//			Windows NT: The 32-bit Windows system directory. Use the
	//				GetSystemDirectory function to get the path of this directory.
	//				The name of this directory is SYSTEM32.
	//			Windows NT: The 16-bit Windows system directory. There is no Win32
	//				function that obtains the path of this directory, but it is
	//				searched. The name of this directory is SYSTEM.
	//		 6. The Windows directory. Use the GetWindowsDirectory function to get
	//				the path of this directory.
	//		 7. The directories that are listed in the PATH environment variable.
	//
	//		 The Windows API SearchPath() indicates the one that will be used.

	/*
	// Search C:\ for the binaries

	hr = this->SearchFor(szBinaryName, "C:\\", TRUE, &foundpaths);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't search for %s in %s!", 2, szBinaryName, "C:\\");
		goto DONE;
	} // end if (couldn't find paths)
	*/

	// Search current directory for the binaries.

	dwSize = GetCurrentDirectory(0, NULL) + 1; // +1 for possible trailing backslash

	// Increase buffer size if necessary.
	if (dwSize > dwBufferSize)
	{
		if (pszTemp != NULL)
			LocalFree(pszTemp);

		dwBufferSize = dwSize;

		pszTemp = (char*) LocalAlloc(LPTR, dwBufferSize);
		if (pszTemp == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
	} // end if (need to reallocate buffer)

	GetCurrentDirectory(dwSize, pszTemp); // ignoring error

	// Make sure it ends in a backslash to reduce number of searches.
	if (! StringEndsWith(pszTemp, "\\", TRUE))
		strcat(pszTemp, "\\");

	// Add it to the paths to search, if it's not already there.
	if (searchpaths.GetStringIndex(pszTemp, 0, FALSE) == -1)
	{
		hr = searchpaths.AddString(pszTemp);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add \"%s\" to search paths list!", 1, pszTemp);
			goto DONE;
		} // end if (couldn't add search path)
	} // end if (didn't find path)


	// Search system directory for the binaries.

	dwSize = GetSystemDirectory(NULL, 0) + 1; // +1 for possible trailing backslash

	// Increase buffer size if necessary.
	if (dwSize > dwBufferSize)
	{
		if (pszTemp != NULL)
			LocalFree(pszTemp);

		dwBufferSize = dwSize;

		pszTemp = (char*) LocalAlloc(LPTR, dwBufferSize);
		if (pszTemp == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
	} // end if (need to reallocate buffer)

	GetSystemDirectory(pszTemp, dwSize); // ignoring error

	// Make sure it ends in a backslash to reduce number of searches.
	if (! StringEndsWith(pszTemp, "\\", TRUE))
		strcat(pszTemp, "\\");

	// Add it to the paths to search, if it's not already there.
	if (searchpaths.GetStringIndex(pszTemp, 0, FALSE) == -1)
	{
		hr = searchpaths.AddString(pszTemp);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add \"%s\" to search paths list!", 1, pszTemp);
			goto DONE;
		} // end if (couldn't add search path)
	} // end if (didn't find path)


#pragma TODO(vanceo, "Check 16-bit system directory on NT")


	// Search Windows directory for the binaries.

	dwSize = GetWindowsDirectory(NULL, 0) + 1; // +1 for possible trailing backslash

	// Increase buffer size if necessary.
	if (dwSize > dwBufferSize)
	{
		if (pszTemp != NULL)
			LocalFree(pszTemp);

		dwBufferSize = dwSize;

		pszTemp = (char*) LocalAlloc(LPTR, dwBufferSize);
		if (pszTemp == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
	} // end if (need to reallocate buffer)

	GetWindowsDirectory(pszTemp, dwSize); // ignoring error

	// Make sure it ends in a backslash to reduce number of searches.
	if (! StringEndsWith(pszTemp, "\\", TRUE))
		strcat(pszTemp, "\\");

	// Add it to the paths to search, if it's not already there.
	if (searchpaths.GetStringIndex(pszTemp, 0, FALSE) == -1)
	{
		hr = searchpaths.AddString(pszTemp);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add \"%s\" to search paths list!", 1, pszTemp);
			goto DONE;
		} // end if (couldn't add search path)
	} // end if (didn't find path)




	// Get the PATH environment variable

	dwSize = GetEnvironmentVariable("PATH", NULL, 0);
	pszPathVar = (char*) LocalAlloc(LPTR, dwSize);
	if (pszPathVar == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	GetEnvironmentVariable("PATH", pszPathVar, dwSize);

	// It's okay to pass the string to split in as the output buffer because we don't
	// care if it gets destroyed.
	dwNumFields = StringSplitIntoFields(pszPathVar, ";", pszPathVar, &dwSize);

	// Loop through all the paths in the environment variable
	for(dwField = 0; dwField < dwNumFields; dwField++)
	{
		pszField = StringGetFieldPtr(pszPathVar, dwField);

		dwSize = strlen(pszField) + 2; // + 1 for possible backslash, + 1 for NULL termination

		// Increase buffer size if necessary.
		if (dwSize > dwBufferSize)
		{
			if (pszTemp != NULL)
				LocalFree(pszTemp);

			dwBufferSize = dwSize;

			pszTemp = (char*) LocalAlloc(LPTR, dwBufferSize);
			if (pszTemp == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
		} // end if (need to reallocate buffer)

		strcpy(pszTemp, pszField);

		// Make sure it ends in a backslash to reduce number of searches.
		if (! StringEndsWith(pszTemp, "\\", TRUE))
			strcat(pszTemp, "\\");

		// Add it to the paths to search, if it's not already there.
		if (searchpaths.GetStringIndex(pszTemp, 0, FALSE) == -1)
		{
			hr = searchpaths.AddString(pszTemp);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add \"%s\" to search paths list!",
					1, StringGetFieldPtr(pszTemp, dwSize));
				goto DONE;
			} // end if (couldn't add search path)
		} // end if (didn't find path)
	} // end for (each path)

	// Loop through each of the search paths we accumulated.
	for(i = 0; i < searchpaths.Count(); i++)
	{
		hr = this->SearchFor(szBinaryName, searchpaths.GetIndexedString(i),
							FALSE, &foundpaths);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't search for \"%s\" in \"%s\"!",
				2, szBinaryName, searchpaths.GetIndexedString(i));
			goto DONE;
		} // end if (couldn't find paths)
	} // end for (each path)



	// Loop through all the found binary paths and add them to our list

	while(foundpaths.Count() > 0)
	{
		pBin = new (CTNBinary);
		if (pBin == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		pBin->m_pszPath = (char*) LocalAlloc(LPTR, (strlen(foundpaths.GetIndexedString(0)) + 1));
		if (pBin->m_pszPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		
		strcpy(pBin->m_pszPath, foundpaths.GetIndexedString(0));

		foundpaths.Remove(0); // ignoring error

		hr = pBin->LoadInfo();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't load info for %s!", 1, pBin->m_pszPath);
			goto DONE;
		} // end if (add failed)

		hr = pBinLocs->m_bins.Add(pBin);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add the item to the list!", 0);
			goto DONE;
		} // end if (add failed)

		pBin = NULL; // forget about it so we don't free it below
	} // end for (each found path)

	hr = this->Add(pBinLocs);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add the binaries to the list!", 0);
		goto DONE;
	} // end if (add failed)

	pBinLocs = NULL; // forget about it so we don't free it below


DONE:

	if (pBin != NULL)
	{
		delete (pBin);
		pBin = NULL;
	} // end if (have object)

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated memory)

	if (pszPathVar != NULL)
	{
		LocalFree(pszPathVar);
		pszPathVar = NULL;
	} // end if (allocated memory)

	if (pBinLocs != NULL)
	{
		delete (pBinLocs);
		pBinLocs = NULL;
	} // end if (have object)

	return (hr);
#else // ! XBOX
	return S_OK;
#endif // XBOX
} // CTNTrackedBinaries::LocateAndAddBinary
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::GetBinary()"
//==================================================================================
// CTNTrackedBinaries::GetBinary
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to a list of all locations of tracked binaries
//				with the given name.
//
// Arguments:
//	char* szBinaryName		Binary name to retrieve.
//
// Returns: Pointer to list of locations for binary object if found, NULL if an
//			error occurred.
//==================================================================================
PTNBINARYLOCSLIST CTNTrackedBinaries::GetBinary(char* szBinaryName)
{
	int					i;
	PTNBINARYLOCSLIST	pItem = NULL;


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNBINARYLOCSLIST) this->GetItem(i);
		if (pItem == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get item %i!", 1, i);
			return (NULL);
		} // end if (couldn't get that item)

		// If we found the binary we want, return it
		if (strcmp(pItem->m_pszName, szBinaryName) == 0)
		{
			this->LeaveCritSection();
			return (pItem);
		} // end if (couldn't get that item)
	} // end for (each data item in the list)

	this->LeaveCritSection();
	DPL(0, "Couldn't find binary %s in tracked binaries list!", 1, szBinaryName);

	return (NULL);
} // CTNTrackedBinaries::GetBinary
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::FirstBinIsVersion()"
//==================================================================================
// CTNTrackedBinaries::FirstBinIsVersion
//----------------------------------------------------------------------------------
//
// Description: Sets the passed in boolean to TRUE if the first occurrence of a
//				binary is the specified version, FALSE otherwise.
//
// Arguments:
//	char* szBinaryName		Binary name to examine.
//	DWORD dwHighVersion		High DWORD of file version to compare.
//	DWORD dwLowVersion		Low DWORD of file version to compare.
//	BOOL* pfResult			Pointer to place to store result.
//
// Returns: S_OK if trying to compare was successful, error code otherwise.  Note
//			lpbResult holds the actual comparison result.
//==================================================================================
HRESULT CTNTrackedBinaries::FirstBinIsVersion(char* szBinaryName,
												DWORD dwHighVersion,
												DWORD dwLowVersion,
												BOOL* pfResult)
{
	PTNBINARYLOCSLIST	pList = NULL;
	PTNBINARY			pItem = NULL;

#ifndef _XBOX // no versioning supported

	this->EnterCritSection();

	pList = this->GetBinary(szBinaryName);
	if (pList == NULL)
	{
		this->LeaveCritSection();
		DPL(0, "Couldn't get item binary locations for \"%s\"!", 1, szBinaryName);

		//return (E_FAIL);

		(*pfResult) = FALSE;
		return (S_OK);
	} // end if (couldn't get that item)

	// We use the first instance.
	pItem = (PTNBINARY) pList->m_bins.GetItem(0);
	if (pItem == NULL)
	{
		this->LeaveCritSection();
		DPL(0, "Couldn't get first location of %s!", 1, szBinaryName);
		return (E_FAIL);
	} // end if (couldn't get that item)


	if ((pItem->m_dwMS == dwHighVersion) && (pItem->m_dwLS == dwLowVersion))
		(*pfResult) = TRUE;
	else
		(*pfResult) = FALSE;


	this->LeaveCritSection();

#else // ! XBOX
#pragma BUGBUG(tristanj, "Hardcoded FirstBinIsVersion to always return TRUE")
	(*pfResult) = TRUE;
#endif // XBOX

	return (S_OK);
} // CTNTrackedBinaries::FirstBinIsVersion
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::FirstBinIsAtLeastVersion()"
//==================================================================================
// CTNTrackedBinaries::FirstBinIsAtLeastVersion
//----------------------------------------------------------------------------------
//
// Description: Sets the passed in boolean to TRUE if the first occurrence of a
//				binary is the specified version or higher, FALSE otherwise.
//
// Arguments:
//	char* szBinaryName		Binary name to examine.
//	DWORD dwHighVersion		High DWORD of file version to compare.
//	DWORD dwLowVersion		Low DWORD of file version to compare.
//	BOOL* pfResult			Pointer to place to store result.
//
// Returns: S_OK if trying to compare was successful, error code otherwise.  Note
//			pfResult holds the actual comparison result.
//==================================================================================
HRESULT CTNTrackedBinaries::FirstBinIsAtLeastVersion(char* szBinaryName,
													DWORD dwHighVersion,
													DWORD dwLowVersion,
													BOOL* pfResult)
{
	PTNBINARYLOCSLIST	pList = NULL;
	PTNBINARY			pItem = NULL;

#ifndef _XBOX // no versioning supported

	this->EnterCritSection();

	pList = this->GetBinary(szBinaryName);
	if (pList == NULL)
	{
		this->LeaveCritSection();
		DPL(0, "Couldn't get item binary locations for \"%s\"!", 1, szBinaryName);

		//return (E_FAIL);

		(*pfResult) = FALSE;
		return (S_OK);
	} // end if (couldn't get that item)

	// We use the first instance.
	pItem = (PTNBINARY) pList->m_bins.GetItem(0);
	if (pItem == NULL)
	{
		this->LeaveCritSection();
		DPL(0, "Couldn't get first location of %s!", 1, szBinaryName);
		return (E_FAIL);
	} // end if (couldn't get that item)


	if (pItem->m_dwMS > dwHighVersion)
		(*pfResult) = TRUE;
	else if ((pItem->m_dwMS == dwHighVersion) && (pItem->m_dwLS >= dwLowVersion))
		(*pfResult) = TRUE;
	else
		(*pfResult) = FALSE;


	this->LeaveCritSection();

#else // ! XBOX
#pragma BUGBUG(tristanj, "Hardcoded FirstBinIsVersion to always return TRUE")
	(*pfResult) = TRUE;
#endif // XBOX

	return (S_OK);
} // CTNTrackedBinaries::FirstBinIsAtLeastVersion
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::LoadSymbolsForFirstBinaries()"
//==================================================================================
// CTNTrackedBinaries::LoadSymbolsForFirstBinaries
//----------------------------------------------------------------------------------
//
// Description: Attempts to load symbols for the first instance of all of the
//				DLLs (binaries that don't end in ".EXE", actually) in the list.
//
// Arguments: None.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTrackedBinaries::LoadSymbolsForFirstBinaries(void)
{
	HRESULT					hr = S_OK;
	PTNBINARYLOCSLIST		pBinaryLocsList = NULL;
	PTNBINARY				pBinary = NULL;
#ifndef _XBOX // no versioning supported
	int						i;
	char					szExtension[32];
#endif // ! XBOX

#ifndef _XBOX // no versioning supported

	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pBinaryLocsList = (PTNBINARYLOCSLIST) this->GetItem(i);
		if (pBinaryLocsList == NULL)
		{
			DPL(0, "Couldn't get binary location list item %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get item)

		pBinary = (PTNBINARY) pBinaryLocsList->m_bins.GetItem(0);
		if (pBinary == NULL)
		{
			DPL(0, "WARNING: Couldn't get first binary location for %s!",
				1, pBinaryLocsList->m_pszName);
			/*
			hr = E_FAIL;
			goto DONE;
			*/
			continue;
		} // end if (couldn't get item)

		FileGetExtension(pBinary->m_pszPath, szExtension, FALSE);

		_strlwr(szExtension);
		if (strcmp(szExtension, "exe") != 0)
		{
			hr = TNSymLoadSymbolsForModules(pBinary->m_pszPath);
			if (hr != S_OK)
			{
				DPL(0, "WARNING: Couldn't load symbols for binary \"%s\"!  %e",
					2, pBinary->m_pszPath, hr);
				//goto DONE;
				hr = S_OK;
			} // end if (couldn't load symbols for binary)
		} // end if (the object is not an executable)
		else
		{
			DPL(6, "Not loading symbols for executable \"%s\".", 1, pBinary->m_pszPath);
		} // end if (the object is an executable)
	} // end for (each binary location)

DONE:

	this->LeaveCritSection();

#else // ! XBOX
#pragma BUGBUG(tristanj, "Hardcoded to report that symbols have been loaded successfully")
#endif // XBOX

	return (hr);
} // CTNTrackedBinaries::LoadSymbolsForFirstBinaries
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::PackIntoBuffer()"
//==================================================================================
// CTNTrackedBinaries::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTrackedBinaries::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize)
{
#ifndef _XBOX // No tracked binaries supported
	LPBYTE				lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int					i;
	PTNBINARYLOCSLIST	pBinLocsList = NULL;
	int					iTemp = 0;
	int					j;
	PTNBINARY			pBinLoc = NULL;
	DWORD				dwStringLength = 0;



	(*pdwBufferSize) = 0;

	if (this->Count() <= 0)
	{
		return (S_OK);
	} // end if (there aren't any items in this list)

	this->EnterCritSection();

	// Make sure the unpacker knows how many binary location lists we have

	(*pdwBufferSize) += sizeof (int); // number of items in the list
	if (pvBuffer != NULL)
	{
		iTemp = this->Count();
		CopyAndMoveDestPointer(lpCurrent, &iTemp, sizeof (int))
	} // end if (there's a buffer to copy to)

	for(i = 0; i < this->Count(); i++)
	{
		pBinLocsList = (PTNBINARYLOCSLIST) this->GetItem(i);
		if (pBinLocsList == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get bin locs list %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		// Make sure the unpacker knows how many binaries this list has

		(*pdwBufferSize) += sizeof (int); // number of items in the list
		if (pvBuffer != NULL)
		{
			iTemp = pBinLocsList->m_bins.Count();
			CopyAndMoveDestPointer(lpCurrent, &iTemp, sizeof (int))
		} // end if (there's a buffer to copy to)



		dwStringLength = strlen(pBinLocsList->m_pszName);

		(*pdwBufferSize) += sizeof (DWORD)		// string length
							+ dwStringLength;	// actual string

		if (pvBuffer != NULL)
		{
			CopyAndMoveDestPointer(lpCurrent, &(dwStringLength), sizeof (DWORD))
			CopyAndMoveDestPointer(lpCurrent, pBinLocsList->m_pszName, dwStringLength)
		} // end if (there's a buffer to copy to)



		for(j = 0; j < pBinLocsList->m_bins.Count(); j++)
		{
			pBinLoc = (PTNBINARY) pBinLocsList->m_bins.GetItem(j);
			if (pBinLoc == NULL)
			{
				this->LeaveCritSection();
				DPL(0, "Couldn't get binary location %i!", 1, j);
				return (E_FAIL);
			} // end if (couldn't get that item)

			dwStringLength = strlen(pBinLoc->m_pszPath);

			(*pdwBufferSize) += sizeof (DWORD)			// string length
								+ dwStringLength		// actual string
								+ sizeof (BOOL)			// debug
								+ sizeof (DWORD) * 2	// version DWORDs
								+ sizeof (FILETIME)		// create time
								+ sizeof (FILETIME)		// write time
								+ sizeof (DWORD) * 2;	// file size

			if (pvBuffer != NULL)
			{
				CopyAndMoveDestPointer(lpCurrent, &(dwStringLength), sizeof (DWORD))
				CopyAndMoveDestPointer(lpCurrent, pBinLoc->m_pszPath, dwStringLength)
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_fDebug), sizeof (BOOL))
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_dwMS), sizeof (DWORD))
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_dwLS), sizeof (DWORD))
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_createtime), sizeof (FILETIME))
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_writetime), sizeof (FILETIME))
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_dwFileSizeHigh), sizeof (DWORD))
				CopyAndMoveDestPointer(lpCurrent, &(pBinLoc->m_dwFileSizeLow), sizeof (DWORD))
			} // end if (there's a buffer to copy to)
		} // end for (each binary location)
	} // end for (each group of like-named binaries)
	this->LeaveCritSection();

	if (pvBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
#else // ! XBOX
	*pdwBufferSize = 0;
	return S_OK;
#endif // XBOX
} // CTNTrackedBinaries::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::UnpackFromBuffer()"
//==================================================================================
// CTNTrackedBinaries::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD dwBufferSize		Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTrackedBinaries::UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize)
{
	HRESULT					hr;
	LPBYTE					lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int						iNumLists = 0;
	int						i;
	PTNBINARYLOCSLIST		pNewBinLocsList = NULL;
	int						iNumBins = 0;
	int						j;
	PTNBINARY				pNewBinLoc = NULL;
	DWORD					dwStringLength = 0;



	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumLists, lpCurrent, sizeof (int));

	for(i = 0; i < iNumLists; i++)
	{
		pNewBinLocsList = new (CTNBinaryLocsList);
		if (pNewBinLocsList == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		CopyAndMoveSrcPointer(&iNumBins, lpCurrent, sizeof (int));

		CopyAndMoveSrcPointer(&dwStringLength, lpCurrent, sizeof (DWORD));
		pNewBinLocsList->m_pszName = (char*) LocalAlloc(LPTR, dwStringLength + 1);
		if (pNewBinLocsList->m_pszName == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		CopyAndMoveSrcPointer(pNewBinLocsList->m_pszName, lpCurrent, dwStringLength);


		for(j = 0; j < iNumBins; j++)
		{
			pNewBinLoc = new (CTNBinary);
			if (pNewBinLoc == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate object)

			CopyAndMoveSrcPointer(&dwStringLength, lpCurrent, sizeof (DWORD));
			pNewBinLoc->m_pszPath = (char*) LocalAlloc(LPTR, dwStringLength + 1);
			if (pNewBinLoc->m_pszPath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)
	
			CopyAndMoveSrcPointer(pNewBinLoc->m_pszPath, lpCurrent, dwStringLength);


			CopyAndMoveSrcPointer(&(pNewBinLoc->m_fDebug), lpCurrent, sizeof (BOOL));
			CopyAndMoveSrcPointer(&(pNewBinLoc->m_dwMS), lpCurrent, sizeof (DWORD));
			CopyAndMoveSrcPointer(&(pNewBinLoc->m_dwLS), lpCurrent, sizeof (DWORD));
			CopyAndMoveSrcPointer(&(pNewBinLoc->m_createtime), lpCurrent, sizeof (FILETIME));
			CopyAndMoveSrcPointer(&(pNewBinLoc->m_writetime), lpCurrent, sizeof (FILETIME));
			CopyAndMoveSrcPointer(&(pNewBinLoc->m_dwFileSizeHigh), lpCurrent, sizeof (DWORD));
			CopyAndMoveSrcPointer(&(pNewBinLoc->m_dwFileSizeLow), lpCurrent, sizeof (DWORD));
			

			hr = pNewBinLocsList->m_bins.Add(pNewBinLoc);
			if (hr != S_OK)
			{
				DPL(0, "Adding binary %s failed!", 1, pNewBinLoc->m_pszPath);
				goto DONE;
			} // end if (couldn't add item)

			pNewBinLoc = NULL; // forget about it so we don't free it below
		} // end for (each binary location)
			

		hr = this->Add(pNewBinLocsList);
		if (hr != S_OK)
		{
			DPL(0, "Adding binary location list %s failed!", 1, pNewBinLocsList->m_pszName);
			goto DONE;
		} // end if (couldn't add item)

		pNewBinLocsList = NULL; // forget about it so we don't free it below
	} // end for (each binary location list)


DONE:

	this->LeaveCritSection();

	if (pNewBinLoc != NULL)
	{
		delete (pNewBinLoc);
		pNewBinLoc = NULL;
	} // end if (have a left over binary)

	if (pNewBinLocsList != NULL)
	{
		delete (pNewBinLocsList);
		pNewBinLocsList = NULL;
	} // end if (have a left over loc object)

	return (hr);
} // CTNTrackedBinaries::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#ifndef _XBOX // no file printing supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTrackedBinaries::PrintToFile()"
//==================================================================================
// CTNTrackedBinaries::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints all the objects in this list to the file specified.
//
// Arguments:
//	HANDLE hFile		File to print to.
//
// Returns: None.
//==================================================================================
void CTNTrackedBinaries::PrintToFile(HANDLE hFile)
{
	int					i;
	PTNBINARYLOCSLIST	pBinaries = NULL;
	PTNBINARY			pBinaryLoc = NULL;
	char				szBuffer[1024];
	int					j;

	FileWriteLine(hFile, "\t(Binaries)"); //ignoring errors

	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pBinaries = (PTNBINARYLOCSLIST) this->GetItem(i);
		if (pBinaries == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get binary item %i!", 1, i);
			return;
		} // end if (couldn't get that item)

		// ignoring errors
		FileSprintfWriteLine(hFile, "\t\t<%s>", 1, pBinaries->m_pszName);

		for(j = 0; j < pBinaries->m_bins.Count(); j++)
		{
			pBinaryLoc = (PTNBINARY) pBinaries->m_bins.GetItem(j);
			if (pBinaryLoc == NULL)
			{