   FILETIME  ftTimeStamp;
} ENUMSHELLIMAGESTOREDATA, * PENUMSHELLIMAGESTOREDATA;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IEnumShellImageStore

DECLARE_INTERFACE_IID_( IEnumShellImageStore, IUnknown, "6DFD582B-92E3-11D1-98A3-00C04FB687DA" )
{
    STDMETHOD ( QueryInterface ) ( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    STDMETHOD ( Reset ) ( THIS ) PURE;
    STDMETHOD ( Next ) ( THIS_ ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched ) PURE;
    STDMETHOD ( Skip ) ( THIS_ ULONG celt ) PURE;
    STDMETHOD ( Clone ) ( THIS_ IEnumShellImageStore ** ppEnum ) PURE;
};

typedef IEnumShellImageStore * LPENUMSHELLIMAGESTORE;


// flags used to determine the capabilities of the storage for the images
#define SHIMSTCAPFLAG_LOCKABLE    0x0001       // does the store require/support locking
#define SHIMSTCAPFLAG_PURGEABLE   0x0002       // does the store require dead items purging externally ?

#undef  INTERFACE
#define INTERFACE   IShellImageStore

// this interface is used to manipulate the Image cache. It can potentially be used
// in a free threaded manner in conjunction with the Lock parameter to Open and close
DECLARE_INTERFACE_IID_( IShellImageStore, IUnknown, "48C8118C-B924-11D1-98D5-00C04FB687DA" )
{
    STDMETHOD ( QueryInterface )( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    // if the lock parameter is used, then all other calls into
    // open and/or create will block until the lock is released.
    STDMETHOD ( Open ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;
    STDMETHOD ( Create ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;

    // if the lock is passed to either of these two methods, it releases the lock
    // once the operation is complete.
    STDMETHOD ( ReleaseLock ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Close ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Commit ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( IsLocked ) ( THIS ) PURE;

    STDMETHOD ( GetMode ) ( THIS_ DWORD * pdwMode ) PURE;
    STDMETHOD ( GetCapabilities ) ( THIS_ DWORD * pdwCapMask ) PURE;

    STDMETHOD ( AddEntry ) ( THIS_ LPCWSTR pszName, const FILETIME * pftTimeStamp, DWORD dwMode, HBITMAP hImage ) PURE;
    STDMETHOD ( GetEntry ) ( THIS_ LPCWSTR pszName, DWORD dwMode, HBITMAP * phImage ) PURE;
    STDMETHOD ( DeleteEntry ) ( THIS_ LPCWSTR pszName ) PURE;
    STDMETHOD ( IsEntryInStore ) ( THIS_ LPCWSTR pszName, FILETIME * pftTimeStamp ) PURE;

    STDMETHOD ( Enum ) ( THIS_ LPENUMSHELLIMAGESTORE * ppEnum ) PURE;
};

typedef IShellImageStore * LPSHELLIMAGESTORE;

#endif  // (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_VISTA)

#if (_WIN32_IE >= 0x0400)

////  IShellFolderBand

// Field mask
#define ISFB_MASK_STATE          0x00000001 // TRUE if dwStateMask and dwState is valid
#define ISFB_MASK_BKCOLOR        0x00000002 // TRUE if crBkgnd field is valid
#define ISFB_MASK_VIEWMODE       0x00000004 // TRUE if wViewMode field is valid
#define ISFB_MASK_SHELLFOLDER    0x00000008
#define ISFB_MASK_IDLIST         0x00000010
#define ISFB_MASK_COLORS         0x00000020 // TRUE if crXXXX fields are valid (except bkgnd)

#define ISFB_STATE_DEFAULT       0x00000000
#define ISFB_STATE_DEBOSSED      0x00000001
#define ISFB_STATE_ALLOWRENAME   0x00000002
#define ISFB_STATE_NOSHOWTEXT    0x00000004 // TRUE if _fNoShowText
#define ISFB_STATE_CHANNELBAR    0x00000010 // TRUE if we want NavigateTarget support
#define ISFB_STATE_QLINKSMODE    0x00000020 // TRUE if we want to turn off drag & drop onto content items
#define ISFB_STATE_FULLOPEN      0x00000040 // TRUE if band should maximize when opened
#define ISFB_STATE_NONAMESORT    0x00000080 // TRUE if band should _not_ sort icons by name
#define ISFB_STATE_BTNMINSIZE    0x00000100 // TRUE if band should report min thickness of button

#define ISFBVIEWMODE_SMALLICONS   0x0001
#define ISFBVIEWMODE_LARGEICONS   0x0002
#if (_WIN32_IE < _WIN32_IE_IE70)
#define ISFBVIEWMODE_LOGOS        0x0003
#endif

#include <pshpack8.h>

typedef struct {
    DWORD       dwMask;       // [in] ISFB_MASK mask of valid fields from crBkgnd on
    DWORD       dwStateMask;  // [in] ISFB_STATE mask of dwState bits being set/queried
    DWORD       dwState;      // [in/out] ISFB_STATE bits
    COLORREF    crBkgnd;      // [in/out]
    COLORREF    crBtnLt;      // [in/out]
    COLORREF    crBtnDk;      // [in/out]
    WORD        wViewMode;    // [in/out]
    WORD        wAlign;       // not used (yet)
    IShellFolder * psf;       // [out]
    PIDLIST_ABSOLUTE pidl;      // [out]
} BANDINFOSFB, *PBANDINFOSFB;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IShellFolderBand

DECLARE_INTERFACE_IID_(IShellFolderBand, IUnknown, "7FE80CC8-C247-11d0-B93A-00A0C90312E1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderBand Methods ***
    STDMETHOD(InitializeSFB)(THIS_ __in_opt IShellFolder *psf, __in_opt PCIDLIST_ABSOLUTE pidl) PURE;
    STDMETHOD(SetBandInfoSFB)(THIS_ __in PBANDINFOSFB pbi) PURE;
    STDMETHOD(GetBandInfoSFB)(THIS_ __inout PBANDINFOSFB pbi) PURE;
};

// Command Target IDs
enum {
    SFBID_PIDLCHANGED,
};

////  IDeskBarClient

#undef  INTERFACE
#define INTERFACE   IDeskBarClient

DECLARE_INTERFACE_IID_(IDeskBarClient, IOleWindow, "EB0FE175-1A3A-11D0-89B3-00A0C90A90AC")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ __out HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetDeskBarSite) (THIS_ __in_opt IUnknown* punkSite) PURE;
    STDMETHOD(SetModeDBC) (THIS_ DWORD dwMode) PURE;
    STDMETHOD(UIActivateDBC) (THIS_ DWORD dwState) PURE;
    STDMETHOD(GetSize) (THIS_ DWORD dwWhich, __out LPRECT prc) PURE;
};

#define DBC_GS_IDEAL          0  // get the ideal size
#define DBC_GS_SIZEDOWN       1  // clip the height of a rect to a multiple of the rebar's integral size


#define DBC_HIDE        0 // Band is hidden (being destroyed)
#define DBC_SHOW        1 // Band is visible
#define DBC_SHOWOBSCURE 2 // Band is completely obscured


enum {
    DBCID_EMPTY = 0,        // bandsite is empty
    DBCID_ONDRAG = 1,       // (down)DragMoveEnter/Leave vaIn:I4:eDrag
    DBCID_CLSIDOFBAR = 2,   // clsid of bar inside
    DBCID_RESIZE = 3,       // resize from keyboard
    DBCID_GETBAR = 4,       // returns vaOut:VT_UNKNOWN of hosting dockbar (IDeskBar)
};

#endif // _WIN32_IE > 0x0400


#if (_WIN32_IE >= 0x400)
//
// We need to make sure that WININET.H is included before this interface is
// used because the COMPONENT structure uses INTERNET_MAX_URL_LENGTH
//
#ifdef _WININET_
//
//  Flags and structures used by IActiveDesktop
//

typedef struct _tagWALLPAPEROPT
{
    DWORD   dwSize;     // size of this Structure.
    DWORD   dwStyle;    // WPSTYLE_* mentioned above
}
WALLPAPEROPT;

typedef WALLPAPEROPT  *LPWALLPAPEROPT;
typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct _tagCOMPONENTSOPT
{
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
}
COMPONENTSOPT;

typedef COMPONENTSOPT   *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct _tagCOMPPOS
{
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
}
COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;

typedef struct  _tagCOMPSTATEINFO
{
    DWORD   dwSize;             // Size of this structure.
    int     iLeft;              // Left of the top-left corner in screen co-ordinates.
    int     iTop;               // Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    DWORD   dwItemState;        // State of the component (full-screen mode or split-screen or normal state.
}
COMPSTATEINFO;

typedef COMPSTATEINFO   *LPCOMPSTATEINFO;
typedef const COMPSTATEINFO *LPCCOMPSTATEINFO;



#define COMPONENT_TOP (0x3fffffff)  // izOrder value meaning component is at the top


// iCompType values
#define COMP_TYPE_HTMLDOC       0
#define COMP_TYPE_PICTURE       1
#define COMP_TYPE_WEBSITE       2
#define COMP_TYPE_CONTROL       3
#define COMP_TYPE_CFHTML        4
#define COMP_TYPE_MAX           4

// The following is the COMPONENT structure used in IE4.01, IE4.0 and Memphis. It is kept here for compatibility
// reasons.
typedef struct _tagIE4COMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL
}
IE4COMPONENT;

typedef IE4COMPONENT *LPIE4COMPONENT;
typedef const IE4COMPONENT *LPCIE4COMPONENT;

//
// The following is the new NT5 component structure. Note that the initial portion of this component exactly
// matches the IE4COMPONENT structure. All new fields are added at the bottom and the dwSize field is used to
// distinguish between IE4COMPONENT and the new COMPONENT structures.
//
typedef struct _tagCOMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL

    //New fields are added below. Everything above here must exactly match the IE4COMPONENT Structure.
    DWORD           dwCurItemState; // Current state of the Component.
    COMPSTATEINFO   csiOriginal;    // Original state of the component when it was first added.
    COMPSTATEINFO   csiRestored;    // Restored state of the component.
}
COMPONENT;

typedef COMPONENT *LPCOMPONENT;
typedef const COMPONENT *LPCCOMPONENT;


// Defines for dwCurItemState
#define IS_NORMAL               0x00000001
#define IS_FULLSCREEN           0x00000002
#define IS_SPLIT                0x00000004
#define IS_VALIDSIZESTATEBITS   (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN)  // The set of IS_* state bits which define the "size" of the component - these bits are mutually exclusive.
#define IS_VALIDSTATEBITS       (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN | 0x80000000 | 0x40000000)  // All of the currently defined IS_* bits.

////////////////////////////////////////////
// Flags for IActiveDesktop::ApplyChanges()
#define AD_APPLY_SAVE             0x00000001
#define AD_APPLY_HTMLGEN          0x00000002
#define AD_APPLY_REFRESH          0x00000004
#define AD_APPLY_ALL              (AD_APPLY_SAVE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH)
#define AD_APPLY_FORCE            0x00000008
#define AD_APPLY_BUFFERED_REFRESH 0x00000010
#define AD_APPLY_DYNAMICREFRESH   0x00000020

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaper()
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define AD_GETWP_BMP            0x00000000
#define AD_GETWP_IMAGE          0x00000001
#define AD_GETWP_LAST_APPLIED   0x00000002
#endif

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
#define WPSTYLE_CENTER      0
#define WPSTYLE_TILE        1
#define WPSTYLE_STRETCH     2
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define WPSTYLE_KEEPASPECT  3
#define WPSTYLE_CROPTOFIT   4
#define WPSTYLE_MAX         5
#else
#define WPSTYLE_MAX         3
#endif // NTDDI_WIN7


////////////////////////////////////////////
// Flags for IActiveDesktop::ModifyComponent()

#define COMP_ELEM_TYPE          0x00000001
#define COMP_ELEM_CHECKED       0x00000002
#define COMP_ELEM_DIRTY         0x00000004
#define COMP_ELEM_NOSCROLL      0x00000008
#define COMP_ELEM_POS_LEFT      0x00000010
#define COMP_ELEM_POS_TOP       0x00000020
#define COMP_ELEM_SIZE_WIDTH    0x00000040
#define COMP_ELEM_SIZE_HEIGHT   0x00000080
#define COMP_ELEM_POS_ZINDEX    0x00000100
#define COMP_ELEM_SOURCE        0x00000200
#define COMP_ELEM_FRIENDLYNAME  0x00000400
#define COMP_ELEM_SUBSCRIBEDURL 0x00000800
#define COMP_ELEM_ORIGINAL_CSI  0x00001000
#define COMP_ELEM_RESTORED_CSI  0x00002000
#define COMP_ELEM_CURITEMSTATE  0x00004000

#define COMP_ELEM_ALL   (COMP_ELEM_TYPE | COMP_ELEM_CHECKED | COMP_ELEM_DIRTY |                     \
                         COMP_ELEM_NOSCROLL | COMP_ELEM_POS_LEFT | COMP_ELEM_SIZE_WIDTH  |          \
                         COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_POS_ZINDEX | COMP_ELEM_SOURCE |          \
                         COMP_ELEM_FRIENDLYNAME | COMP_ELEM_POS_TOP | COMP_ELEM_SUBSCRIBEDURL |     \
                         COMP_ELEM_ORIGINAL_CSI | COMP_ELEM_RESTORED_CSI | COMP_ELEM_CURITEMSTATE)


////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()
typedef enum tagDTI_ADTIWUI
{
    DTI_ADDUI_DEFAULT               = 0x00000000,
    DTI_ADDUI_DISPSUBWIZARD         = 0x00000001,
    DTI_ADDUI_POSITIONITEM          = 0x00000002,
};


////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()
#define ADDURL_SILENT           0X0001


////////////////////////////////////////////
// Default positions for ADI
#define COMPONENT_DEFAULT_LEFT    (0xFFFF)
#define COMPONENT_DEFAULT_TOP     (0xFFFF)




//
//  Interface for manipulating the Active Desktop.
//

#undef INTERFACE
#define INTERFACE IActiveDesktop

DECLARE_INTERFACE_IID_(IActiveDesktop, IUnknown, "f490eb00-1240-11d1-9888-006097deacf9")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktop methods
    STDMETHOD (ApplyChanges)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (GetWallpaper)(THIS_ __out_ecount(cchWallpaper) LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwFlags) PURE;
    STDMETHOD (SetWallpaper)(THIS_ LPCWSTR pwszWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (GetWallpaperOptions)(THIS_ __inout LPWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaperOptions)(THIS_ __in LPCWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (GetPattern)(THIS_ __out_ecount(cchPattern) LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved) PURE;
    STDMETHOD (SetPattern)(THIS_ LPCWSTR pwszPattern, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemOptions)(THIS_ __inout LPCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (SetDesktopItemOptions)(THIS_ __in LPCCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItem)(THIS_ __in LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItemWithUI)(THIS_ HWND hwnd, __in LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (ModifyDesktopItem)(THIS_ __inout LPCCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (RemoveDesktopItem)(THIS_ __in LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemCount)(THIS_ __out LPINT lpiCount, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItem)(THIS_ int nComponent, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemByID)(THIS_ ULONG_PTR dwID, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GenerateDesktopItemHtml)(THIS_ LPCWSTR pwszFileName, __in LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddUrl)(THIS_ HWND hwnd, LPCWSTR pszSource, __in LPCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (GetDesktopItemBySource)(THIS_ LPCWSTR pwszSource, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
};

typedef IActiveDesktop * LPACTIVEDESKTOP;

// Flags for SetSafeMode
#define SSM_CLEAR   0x0000
#define SSM_SET     0x0001
#define SSM_REFRESH 0x0002
#define SSM_UPDATE  0x0004

// Flags for Set/GetScheme
#define SCHEME_DISPLAY          0x0001
#define SCHEME_EDIT             0x0002
#define SCHEME_LOCAL            0x0004
#define SCHEME_GLOBAL           0x0008
#define SCHEME_REFRESH          0x0010
#define SCHEME_UPDATE           0x0020
#define SCHEME_DONOTUSE 0x0040 // used to be SCHEME_ENUMERATE; no longer supported
#define SCHEME_CREATE           0x0080

#undef INTERFACE
#define INTERFACE IActiveDesktopP

DECLARE_INTERFACE_IID_(IActiveDesktopP, IUnknown, "52502EE0-EC80-11D0-89AB-00C04FC2972D")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktopP methods
    STDMETHOD (SetSafeMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (EnsureUpdateHTML)(THIS) PURE;
    STDMETHOD (SetScheme)(THIS_ LPCWSTR pwszSchemeName, DWORD dwFlags) PURE;
    STDMETHOD (GetScheme)(THIS_ __out_ecount(*lpdwcchBuffer) LPWSTR pwszSchemeName, __inout DWORD *lpdwcchBuffer, DWORD dwFlags) PURE;
    //
};

typedef IActiveDesktopP * LPACTIVEDESKTOPP;

//Flags for GetObjectFlags
#define GADOF_DIRTY    0x00000001

#undef INTERFACE
#define INTERFACE IADesktopP2

DECLARE_INTERFACE_IID_(IADesktopP2, IUnknown, "B22754E2-4574-11d1-9888-006097DEACF9")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IADesktopP2 methods
    STDMETHOD (ReReadWallpaper)(THIS) PURE;
    STDMETHOD (GetADObjectFlags)(THIS_ __out DWORD *lpdwFlags, DWORD dwMask) PURE;
    STDMETHOD (UpdateAllDesktopSubscriptions)(THIS) PURE;
    STDMETHOD (MakeDynamicChanges)(THIS_ __in IOleObject *pOleObj) PURE;
};

typedef IADesktopP2 * LPADESKTOPP2;


#endif // _WININET_

#if (_WIN32_IE >= 0x0500)

#define MAX_COLUMN_NAME_LEN 80
#define MAX_COLUMN_DESC_LEN 128

#include <pshpack1.h>

typedef struct {
    SHCOLUMNID  scid;                           // OUT the unique identifier of this column
    VARTYPE     vt;                             // OUT the native type of the data returned
    DWORD       fmt;                            // OUT this listview format (LVCFMT_LEFT, usually)
    UINT        cChars;                         // OUT the default width of the column, in characters
    DWORD       csFlags;                        // OUT SHCOLSTATE flags
    WCHAR wszTitle[MAX_COLUMN_NAME_LEN];        // OUT the title of the column
    WCHAR wszDescription[MAX_COLUMN_DESC_LEN];  // OUT full description of this column
} SHCOLUMNINFO, *LPSHCOLUMNINFO;
typedef const SHCOLUMNINFO* LPCSHCOLUMNINFO;

#include <poppack.h>        /* Return to default */

#include <pshpack8.h>

typedef struct {
    ULONG   dwFlags;              // initialization flags
    ULONG   dwReserved;           // reserved for future use.
    WCHAR   wszFolder[MAX_PATH];  // fully qualified folder path (or empty if multiple folders)
} SHCOLUMNINIT, *LPSHCOLUMNINIT;
typedef const SHCOLUMNINIT* LPCSHCOLUMNINIT;

#define SHCDF_UPDATEITEM        0x00000001      // this flag is a hint that the file has changed since the last call to GetItemData

typedef struct {
    ULONG   dwFlags;             // combination of SHCDF_ flags.
    DWORD   dwFileAttributes;    // file attributes.
    ULONG   dwReserved;          // reserved for future use.
    WCHAR*  pwszExt;             // address of file name extension
    WCHAR   wszFile[MAX_PATH];   // Absolute path of file.
} SHCOLUMNDATA, *LPSHCOLUMNDATA;
typedef const SHCOLUMNDATA* LPCSHCOLUMNDATA;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IColumnProvider

// Note: these objects must be threadsafe!  GetItemData _will_ be called
// simultaneously from multiple threads.
DECLARE_INTERFACE_IID_(IColumnProvider, IUnknown, "E8025004-1C42-11d2-BE2C-00A0C9A83DA1")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IColumnProvider methods
    STDMETHOD (Initialize)(THIS_ LPCSHCOLUMNINIT psci) PURE;
    STDMETHOD (GetColumnInfo)(THIS_ DWORD dwIndex, __out SHCOLUMNINFO *psci) PURE;
    STDMETHOD (GetItemData)(THIS_ LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, __out VARIANT *pvarData) PURE;
};

#endif // _WIN32_IE >= 0x0500
#endif // _WIN32_IE

//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================

#define CFSTR_SHELLIDLIST                   TEXT("Shell IDList Array")                  // CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET             TEXT("Shell Object Offsets")                // CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES                  TEXT("Net Resource")                        // CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTORA               TEXT("FileGroupDescriptor")                 // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILEDESCRIPTORW               TEXT("FileGroupDescriptorW")                // CF_FILEGROUPDESCRIPTORW
#define CFSTR_FILECONTENTS                  TEXT("FileContents")                        // CF_FILECONTENTS
#define CFSTR_FILENAMEA                     TEXT("FileName")                            // CF_FILENAMEA
#define CFSTR_FILENAMEW                     TEXT("FileNameW")                           // CF_FILENAMEW
#define CFSTR_PRINTERGROUP                  TEXT("PrinterFriendlyName")                 // CF_PRINTERS
#define CFSTR_FILENAMEMAPA                  TEXT("FileNameMap")                         // CF_FILENAMEMAPA
#define CFSTR_FILENAMEMAPW                  TEXT("FileNameMapW")                        // CF_FILENAMEMAPW
#define CFSTR_SHELLURL                      TEXT("UniformResourceLocator")
#define CFSTR_INETURLA                      CFSTR_SHELLURL
#define CFSTR_INETURLW                      TEXT("UniformResourceLocatorW")
#define CFSTR_PREFERREDDROPEFFECT           TEXT("Preferred DropEffect")
#define CFSTR_PERFORMEDDROPEFFECT           TEXT("Performed DropEffect")
#define CFSTR_PASTESUCCEEDED                TEXT("Paste Succeeded")
#define CFSTR_INDRAGLOOP                    TEXT("InShellDragLoop")
#define CFSTR_MOUNTEDVOLUME                 TEXT("MountedVolume")
#define CFSTR_PERSISTEDDATAOBJECT           TEXT("PersistedDataObject")
#define CFSTR_TARGETCLSID                   TEXT("TargetCLSID")                         // HGLOBAL with a CLSID of the drop target
#define CFSTR_LOGICALPERFORMEDDROPEFFECT    TEXT("Logical Performed DropEffect")
#define CFSTR_AUTOPLAY_SHELLIDLISTS         TEXT("Autoplay Enumerated IDList Array")    // (HGLOBAL with LPIDA)
#define CFSTR_UNTRUSTEDDRAGDROP             TEXT("UntrustedDragDrop")                   //  DWORD
#define CFSTR_FILE_ATTRIBUTES_ARRAY         TEXT("File Attributes Array")               // (FILE_ATTRIBUTES_ARRAY format on HGLOBAL)
#define CFSTR_INVOKECOMMAND_DROPPARAM       TEXT("InvokeCommand DropParam")             // (HGLOBAL with LPWSTR)
#define CFSTR_SHELLDROPHANDLER              TEXT("DropHandlerCLSID")                    // (HGLOBAL with CLSID of drop handler)
#define CFSTR_DROPDESCRIPTION               TEXT("DropDescription")                     // (HGLOBAL with DROPDESCRIPTION)

#ifdef UNICODE
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORW
#define CFSTR_FILENAME          CFSTR_FILENAMEW
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPW
#define CFSTR_INETURL           CFSTR_INETURLW
#else
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORA
#define CFSTR_FILENAME          CFSTR_FILENAMEA
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPA
#define CFSTR_INETURL           CFSTR_INETURLA
#endif

#define DVASPECT_SHORTNAME      2 // use for CF_HDROP to get short name version of file paths
#define DVASPECT_COPY           3 // use to indicate format is a "Copy" of the data (FILECONTENTS, FILEDESCRIPTOR, etc)
#define DVASPECT_LINK           4 // use to indicate format is a "Shortcut" to the data (FILECONTENTS, FILEDESCRIPTOR, etc)

#include <pshpack8.h>
//
// format of CF_NETRESOURCE
//
typedef struct _NRESARRAY {     // anr
    UINT cItems;
    NETRESOURCE nr[1];
} NRESARRAY, * LPNRESARRAY;
#include <poppack.h>        /* Return to byte packing */

//
// format of CF_IDLIST
//
typedef struct _IDA {
    UINT cidl;          // number of relative IDList
    UINT aoffset[1];    // [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are valid in the FILEDESCRIPTOR struct
//
typedef enum {
    FD_CLSID            = 0x00000001,
    FD_SIZEPOINT        = 0x00000002,
    FD_ATTRIBUTES       = 0x00000004,
    FD_CREATETIME       = 0x00000008,
    FD_ACCESSTIME       = 0x00000010,
    FD_WRITESTIME       = 0x00000020,
    FD_FILESIZE         = 0x00000040,
    FD_PROGRESSUI       = 0x00004000,       // Show Progress UI w/Drag and Drop
    FD_LINKUI           = 0x00008000,       // 'link' UI is prefered
#if (NTDDI_VERSION >= NTDDI_VISTA)
    FD_UNICODE          = (int) 0x80000000,       // this descriptor is UNICODE
#endif
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA {
    DWORD dwFlags;
    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

typedef struct _FILEDESCRIPTORW {
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cFileName[ MAX_PATH ];
} FILEDESCRIPTORW, *LPFILEDESCRIPTORW;

#ifdef UNICODE
#define FILEDESCRIPTOR      FILEDESCRIPTORW
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORW
#else
#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA
#endif

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

typedef struct _FILEGROUPDESCRIPTORW { // fgd
     UINT cItems;
     FILEDESCRIPTORW fgd[1];
} FILEGROUPDESCRIPTORW, * LPFILEGROUPDESCRIPTORW;

#ifdef UNICODE
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORW
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORW
#else
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, *LPDROPFILES;


#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct
{
    UINT cItems;                    // number of items in rgdwFileAttributes array
    DWORD dwSumFileAttributes;      // all of the attributes ORed together
    DWORD dwProductFileAttributes;  // all of the attributes ANDed together
    DWORD rgdwFileAttributes[1];    // array
} FILE_ATTRIBUTES_ARRAY;            // clipboard format definition for CFSTR_FILE_ATTRIBUTES_ARRAY
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum
{
    DROPIMAGE_INVALID             = -1,                // no image preference (use default)
    DROPIMAGE_NONE                = 0,                 // red "no" circle
    DROPIMAGE_COPY                = DROPEFFECT_COPY,   // plus for copy
    DROPIMAGE_MOVE                = DROPEFFECT_MOVE,   // movement arrow for move
    DROPIMAGE_LINK                = DROPEFFECT_LINK,   // link arrow for link
    DROPIMAGE_LABEL               = 6,                 // tag icon to indicate metadata will be changed
    DROPIMAGE_WARNING             = 7,                 // yellow exclamation, something is amiss with the operation
    DROPIMAGE_NOIMAGE             = 8,                 // no image at all
} DROPIMAGETYPE;

typedef struct
{
    DROPIMAGETYPE type;                 // indicates the stock image to use

// text such as "Move to %1"
    WCHAR szMessage[MAX_PATH];

// text such as "Documents", inserted as specified by szMessage
    WCHAR szInsert[MAX_PATH];

// some UI coloring is applied to the text in szInsert, if used by specifying %1 in szMessage.
// %% and %1 are the subset of FormatMessage markers that are processed here.
} DROPDESCRIPTION;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//====== File System Notification APIs ===============================
//
typedef struct _SHChangeNotifyEntry
{
    PCIDLIST_ABSOLUTE pidl;
    BOOL   fRecursive;
} SHChangeNotifyEntry;


//
//  File System Notification flags
//

#define SHCNRF_InterruptLevel      0x0001
#define SHCNRF_ShellLevel          0x0002
#define SHCNRF_RecursiveInterrupt  0x1000
#define SHCNRF_NewDelivery         0x8000

#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT: the extended event is identified in dwItem1,
// packed in LPITEMIDLIST format (same as SHCNF_DWORD packing).
// Additional information can be passed in the dwItem2 parameter
// of SHChangeNotify (called "pidl2" below), which if present, must also
// be in LPITEMIDLIST format.
//
// Unlike the standard events, the extended events are ORDINALs, so we
// don't run out of bits.  Extended events follow the SHCNEE_* naming
// convention.
//
// The dwItem2 parameter varies according to the extended event.

#define SHCNE_EXTENDED_EVENT      0x04000000L
#endif      // _WIN32_IE >= 0x0400

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0581E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT extended events.  These events are ordinals.
// This is not a bitfield.

#define SHCNEE_ORDERCHANGED         2L  // pidl2 is the changed folder
#define SHCNEE_MSI_CHANGE           4L  // pidl2 is a SHChangeProductKeyAsIDList
#define SHCNEE_MSI_UNINSTALL        5L  // pidl2 is a SHChangeProductKeyAsIDList
#endif

// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x3000        // includes SHCNF_FLUSH

#define SHCNF_NOTIFYRECURSIVE      0x10000 // Notify clients registered for any child

#ifdef UNICODE
#define SHCNF_PATH      SHCNF_PATHW
#define SHCNF_PRINTER   SHCNF_PRINTERW
#else
#define SHCNF_PATH      SHCNF_PATHA
#define SHCNF_PRINTER   SHCNF_PRINTERA
#endif

//
//  APIs
//
SHSTDAPI_(void) SHChangeNotify(LONG wEventId, UINT uFlags, __in_opt LPCVOID dwItem1, __in_opt LPCVOID dwItem2);

//
// IShellChangeNotify
//
#undef  INTERFACE
#define INTERFACE  IShellChangeNotify

DECLARE_INTERFACE_IID_(IShellChangeNotify, IUnknown, "D82BE2B1-5764-11D0-A96E-00C04FD705A2")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellChangeNotify methods ***
    STDMETHOD(OnChange) (THIS_ LONG lEvent, PCIDLIST_ABSOLUTE pidl1, PCIDLIST_ABSOLUTE pidl2) PURE;
} ;

//
// IQueryInfo
//
//-------------------------------------------------------------------------
//
// IQueryInfo interface
//
// [Methods]
//              ::GetInfoTip()
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE  IQueryInfo

DECLARE_INTERFACE_IID_(IQueryInfo, IUnknown, "00021500-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip)(THIS_ DWORD dwFlags, __out WCHAR **ppwszTip) PURE;
    STDMETHOD(GetInfoFlags)(THIS_ __out DWORD *pdwFlags) PURE;
} ;

#define QITIPF_DEFAULT          0x00000000
#define QITIPF_USENAME          0x00000001
#define QITIPF_LINKNOTARGET     0x00000002
#define QITIPF_LINKUSETARGET    0x00000004
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define QITIPF_USESLOWTIP       0x00000008  // Flag says it's OK to take a long time generating tip
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define QITIPF_SINGLELINE       0x00000010
#endif

#define QIF_CACHED              0x00000001
#define QIF_DONTEXPANDFOLDER    0x00000002

//
// SHAddToRecentDocs
//
typedef enum
{
    SHARD_PIDL            = 0x00000001L,
    SHARD_PATHA           = 0x00000002L,
    SHARD_PATHW           = 0x00000003L,
#if (NTDDI_VERSION >= NTDDI_WIN7)
    SHARD_APPIDINFO       = 0x00000004L, // indicates the data type is a pointer to a SHARDAPPIDINFO structure
    SHARD_APPIDINFOIDLIST = 0x00000005L, // indicates the data type is a pointer to a SHARDAPPIDINFOIDLIST structure
    SHARD_LINK            = 0x00000006L, // indicates the data type is a pointer to an IShellLink instance
    SHARD_APPIDINFOLINK   = 0x00000007L, // indicates the data type is a pointer to a SHARDAPPIDINFOLINK structure 
    SHARD_SHELLITEM       = 0x00000008L, // indicates the data type is a pointer to an IShellItem instance
#endif    
} SHARD;

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct SHARDAPPIDINFO
{
    IShellItem *psi;        // The namespace location of the the item that should be added to the recent docs folder.
    PCWSTR pszAppID;        // The id of the application that should be associated with this recent doc.
} SHARDAPPIDINFO;

typedef struct SHARDAPPIDINFOIDLIST
{
    PCIDLIST_ABSOLUTE pidl; // The idlist for the shell item that should be added to the recent docs folder.
    PCWSTR pszAppID;        // The id of the application that should be associated with this recent doc.
} SHARDAPPIDINFOIDLIST;

typedef struct SHARDAPPIDINFOLINK
{
    IShellLink *psl;        // An IShellLink instance that when launched opens a recently used item in the specified 
                            // application. This link is not added to the recent docs folder, but will be added to the
                            // specified application's destination list.
    PCWSTR pszAppID;        // The id of the application that should be associated with this recent doc.
} SHARDAPPIDINFOLINK;

#endif 

#ifdef UNICODE
#define SHARD_PATH  SHARD_PATHW
#else
#define SHARD_PATH  SHARD_PATHA
#endif

// The type of the data pointed to by pv is a function of uFlags values that are SHARD_XXX values.  PV can be a PCIDLIST_ABSOLUTE, PCWSTR, PCSTR, SHARDAPPIDINFO, or SHARDAPPIDINFOIDLIST.
SHSTDAPI_(void) SHAddToRecentDocs(UINT uFlags, LPCVOID pv);

typedef struct _SHChangeDWORDAsIDList {
    USHORT   cb;
    DWORD    dwItem1;
    DWORD    dwItem2;
    USHORT   cbZero;
} SHChangeDWORDAsIDList, *LPSHChangeDWORDAsIDList;


#if (NTDDI_VERSION >= NTDDI_WIN2K)


typedef struct _SHChangeUpdateImageIDList {
    USHORT cb;
    int iIconIndex;
    int iCurIndex;
    UINT uFlags;
    DWORD dwProcessID;
    WCHAR szName[MAX_PATH];
    USHORT cbZero;
} SHChangeUpdateImageIDList, * LPSHChangeUpdateImageIDList;
SHSTDAPI_(int) SHHandleUpdateImage(__in PCIDLIST_ABSOLUTE pidlExtra);


typedef struct _SHChangeProductKeyAsIDList {
    USHORT cb;
    WCHAR wszProductKey[39];
    USHORT cbZero;
} SHChangeProductKeyAsIDList, *LPSHChangeProductKeyAsIDList;


SHSTDAPI_(void) SHUpdateImageA(__in LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
SHSTDAPI_(void) SHUpdateImageW(__in LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
#ifdef UNICODE
#define SHUpdateImage  SHUpdateImageW
#else
#define SHUpdateImage  SHUpdateImageA
#endif // !UNICODE
#endif /* NTDDI_WIN2K */

SHSTDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, __in const SHChangeNotifyEntry *pshcne);
SHSTDAPI_(BOOL) SHChangeNotifyDeregister(unsigned long ulID);

typedef enum
{
    SCNRT_ENABLE  = 0,
    SCNRT_DISABLE = 1,
} SCNRT_STATUS;

#if (NTDDI_VERSION >= NTDDI_VISTA)
//  use SHChangeNotifyRegisterThread() to enable Async Register and Deregister.
//  call with SCNRT_ENABLE at the thread proc begining and SCNRT_DISABLE at the end
//  the call with SCNRT_DISABLE can block while it synchronizes with the main ChangeNotify thread
STDAPI_(void) SHChangeNotifyRegisterThread(SCNRT_STATUS status);
#endif

SHSTDAPI_(HANDLE) SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId, __deref_opt_out_ecount(2) PIDLIST_ABSOLUTE **pppidl, __out_opt LONG *plEvent);
SHSTDAPI_(BOOL) SHChangeNotification_Unlock(HANDLE hLock);
#if (_WIN32_IE >= 0x0400)
// The pidls that are given to the view via the ChangeNotifyEvents are simple Pidls,
// SHGetRealIDL() will convert them to true PIDLs.
SHSTDAPI SHGetRealIDL(IShellFolder *psf, PCUITEMID_CHILD pidlSimple, __out PITEMID_CHILD *ppidlReal);
#endif // _WIN32_IE >= 0x0400


SHSTDAPI SHGetInstanceExplorer(__out IUnknown **ppunk);

//
// SHGetDataFromIDListA/W
//
// SHGetDataFromIDList nFormat values TCHAR
#define SHGDFIL_FINDDATA        1
#define SHGDFIL_NETRESOURCE     2
#define SHGDFIL_DESCRIPTIONID   3

#define SHDID_ROOT_REGITEM          1
#define SHDID_FS_FILE               2
#define SHDID_FS_DIRECTORY          3
#define SHDID_FS_OTHER              4
#define SHDID_COMPUTER_DRIVE35      5
#define SHDID_COMPUTER_DRIVE525     6
#define SHDID_COMPUTER_REMOVABLE    7
#define SHDID_COMPUTER_FIXED        8
#define SHDID_COMPUTER_NETDRIVE     9
#define SHDID_COMPUTER_CDROM        10
#define SHDID_COMPUTER_RAMDISK      11
#define SHDID_COMPUTER_OTHER        12
#define SHDID_NET_DOMAIN            13
#define SHDID_NET_SERVER            14
#define SHDID_NET_SHARE             15
#define SHDID_NET_RESTOFNET         16
#define SHDID_NET_OTHER             17
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SHDID_COMPUTER_IMAGING      18
#define SHDID_COMPUTER_AUDIO        19
#define SHDID_COMPUTER_SHAREDDOCS   20
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SHDID_MOBILE_DEVICE         21  // PDA/PalmPC
#endif

#include <pshpack8.h>

typedef struct _SHDESCRIPTIONID {
    DWORD   dwDescriptionId;
    CLSID   clsid;
} SHDESCRIPTIONID, *LPSHDESCRIPTIONID;

#include <poppack.h>        /* Return to byte packing */

// these delegate to IShellFolder2::GetDetailsEx()

SHSTDAPI SHGetDataFromIDListA(IShellFolder *psf, PCUITEMID_CHILD pidl, int nFormat, __out_bcount(cb) void *pv, int cb);
SHSTDAPI SHGetDataFromIDListW(IShellFolder *psf, PCUITEMID_CHILD pidl, int nFormat, __out_bcount(cb) void *pv, int cb);
#ifdef UNICODE
#define SHGetDataFromIDList  SHGetDataFromIDListW
#else
#define SHGetDataFromIDList  SHGetDataFromIDListA
#endif // !UNICODE


//===========================================================================

// PathResolve flags
#define PRF_VERIFYEXISTS            0x0001
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)
#define PRF_FIRSTDIRDEF             0x0004
#define PRF_DONTFINDLNK             0x0008      // if PRF_TRYPROGRAMEXTENSIONS is specified
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define PRF_REQUIREABSOLUTE         0x0010
#endif

SHSTDAPI_(int) RestartDialog(HWND hwnd, LPCWSTR lpPrompt, DWORD dwReturn);
#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI_(int) RestartDialogEx(HWND hwnd, LPCWSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode);
#endif

SHSTDAPI SHCoCreateInstance(__in_opt LPCWSTR pszCLSID, __in_opt const CLSID *pclsid, __in_opt IUnknown *pUnkOuter, __in REFIID riid, __deref_out void **ppv);

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHCreateDataObject(__in PCIDLIST_ABSOLUTE pidlFolder, __in UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl, __in_opt IDataObject *pdtInner, __in REFIID riid, __deref_out void **ppv);
#endif
SHSTDAPI CIDLData_CreateFromIDArray(__in PCIDLIST_ABSOLUTE pidlFolder, __in UINT cidl, __in_ecount_opt(cidl) PCUIDLIST_RELATIVE_ARRAY apidl, __deref_out IDataObject **ppdtobj);
SHSTDAPI SHCreateStdEnumFmtEtc(__in UINT cfmt, __in_ecount(cfmt) const FORMATETC afmt[], __deref_out IEnumFORMATETC **ppenumFormatEtc);
SHSTDAPI SHDoDragDrop(__in_opt HWND hwnd, __in IDataObject *pdata, __in_opt IDropSource *pdsrc, __in DWORD dwEffect, __out DWORD *pdwEffect);
// stuff for doing auto scrolling
#define NUM_POINTS      3
typedef struct {        // asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

SHSTDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT * pptOffset);
SHSTDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
SHSTDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtObject);
SHSTDAPI_(BOOL) DAD_ShowDragImage(BOOL fShow);
SHSTDAPI_(BOOL) DAD_DragMove(POINT pt);
SHSTDAPI_(BOOL) DAD_DragLeave(void);
SHSTDAPI_(BOOL) DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
typedef struct {
    WORD cLength;
    WORD nVersion;

    BOOL fFullPathTitle            : 1;
    BOOL fSaveLocalView            : 1;
    BOOL fNotShell                 : 1;
    BOOL fSimpleDefault            : 1;
    BOOL fDontShowDescBar          : 1;
    BOOL fNewWindowMode            : 1;
    BOOL fShowCompColor            : 1;  // NT: Show compressed volumes in a different colour
    BOOL fDontPrettyNames          : 1;  // NT: Do 8.3 name conversion, or not!
    BOOL fAdminsCreateCommonGroups : 1;  // NT: Administrators create comon groups
    UINT fUnusedFlags : 7;

    UINT fMenuEnumFilter;

} CABINETSTATE, * LPCABINETSTATE;

#define CABINETSTATE_VERSION 2

// APIs for reading and writing the cabinet state.
SHSTDAPI_(BOOL) ReadCabinetState(__out_bcount(cLength) CABINETSTATE *pcs, int cLength);
SHSTDAPI_(BOOL) WriteCabinetState(__in CABINETSTATE *pcs);
SHSTDAPI_(BOOL) PathMakeUniqueName(__out_ecount(cchMax) LPWSTR pszUniqueName, UINT cchMax, LPCWSTR pszTemplate, LPCWSTR pszLongPlate, LPCWSTR pszDir);
SHSTDAPI_(void) PathQualify(__inout LPWSTR psz);
SHSTDAPI_(BOOL) PathIsExe(LPCWSTR pszPath);
SHSTDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwAttr);
SHSTDAPI_(BOOL) PathIsSlowW(LPCWSTR pszFile, DWORD dwAttr);
#ifdef UNICODE
#define PathIsSlow  PathIsSlowW
#else
#define PathIsSlow  PathIsSlowA
#endif // !UNICODE
//
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL           0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED       0x00000004
#define PCS_PATHTOOLONG     0x00000008  // Always combined with FATAL

SHSTDAPI_(int) PathCleanupSpec(LPCWSTR pszDir, __inout LPWSTR pszSpec);

SHSTDAPI_(int) PathResolve(__inout_ecount(MAX_PATH) LPWSTR lpszPath, __in_opt PZPCWSTR dirs, UINT fFlags);
SHSTDAPI_(BOOL) GetFileNameFromBrowse(HWND hwnd, __inout_ecount(cchFilePath) LPWSTR pszFilePath, UINT cchFilePath,
                                      LPCWSTR pszWorkingDir, LPCWSTR pszDefExt, LPCWSTR pszFilters, LPCWSTR pszTitle);
SHSTDAPI_(int) DriveType(int iDrive);

SHSTDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(int) IsNetDrive(int iDrive);
// Flags for Shell_MergeMenus
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L
#define MM_DONTREMOVESEPS       0x00000004L

SHSTDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);


/*
 * The SHObjectProperties API provides an easy way to invoke the Properties
 *   context menu command on a subset of the shell item namespace.
 *
 *   PARAMETERS
 *
 *     hwnd              The window handle of the window which will own the dialog
 *     shopObjectType    A SHOP_ value as defined below
 *     pszObjectName     Name of the object, see SHOP_ values below
 *     pszPropertyPage   The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
SHSTDAPI_(BOOL) SHObjectProperties(__in_opt HWND hwnd, __in DWORD shopObjectType, __in PCWSTR pszObjectName, __in_opt PCWSTR pszPropertyPage);

#define SHOP_PRINTERNAME 0x00000001  // pszObjectName points to a printer friendly name
#define SHOP_FILEPATH    0x00000002  // pszObjectName points to a fully qualified path+file name
#define SHOP_VOLUMEGUID  0x00000004  // pszObjectName points to a Volume GUID


/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *               NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *               this dialog to come up as a "top level application" window.
 *               This parameter should always be non-null, this dialog is
 *               only designed to be the child of another window, not a
 *               stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *               NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *                     default format specified by the DMaint_FormatDrive
 *                     engine". If you want to FORCE a particular format
 *                     ID "up front" you will have to call
 *                     DMaint_GetFormatOptions yourself before calling
 *                     this to obtain the valid list of phys format IDs
 *                     (contents of the PhysFmtIDList array in the
 *                     FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *                SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *               The normal defualt in the Shell format dialog is
 *               "Quick Format", setting this option bit indicates that
 *               the caller wants to start with FULL format selected
 *               (this is useful for folks detecting "unformatted" disks
 *               and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *               All other bits are reserved for future expansion and
 *               must be 0.
 *
 *               Please note that this is a bit field and not a value
 *               and treat it accordingly.
 *
 *   RETURN
 *      The return is either one of the SHFMT_* values, or if the
 *      returned DWORD value is not == to one of these values, then
 *      the return is the physical format ID of the last succesful
 *      format. The LOWORD of this value can be passed on subsequent
 *      calls as the fmtID parameter to "format the same type you did
 *      last time".
 *
 */
SHSTDAPI_(DWORD) SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR     0xFFFFFFFFL     // Error on last format, drive may be formatable
#define SHFMT_CANCEL    0xFFFFFFFEL     // Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL     // Drive is not formatable

#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif
WINSHELLAPI HPSXA WINAPI SHCreatePropSheetExtArray( HKEY hKey, LPCWSTR pszSubKey, UINT max_iface );
WINSHELLAPI void WINAPI SHDestroyPropSheetExtArray(__in HPSXA hpsxa );
WINSHELLAPI UINT WINAPI SHAddFromPropSheetExtArray(__in HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT WINAPI SHReplaceFromPropSheetExtArray(__in HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
#if (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_VISTA)
#undef  INTERFACE
#define INTERFACE   IDefViewFrame
DECLARE_INTERFACE_IID_(IDefViewFrame, IUnknown, "710EB7A0-45ED-11D0-924A-0020AFC7AC4D")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ __out HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ __out IShellFolder **ppsf) PURE;
};
#endif
// shell restriction values, parameter for SHRestricted()
typedef enum RESTRICTIONS
{
    REST_NONE                       = 0x00000000,
    REST_NORUN                      = 0x00000001,
    REST_NOCLOSE                    = 0x00000002,
    REST_NOSAVESET                  = 0x00000004,
    REST_NOFILEMENU                 = 0x00000008,
    REST_NOSETFOLDERS               = 0x00000010,
    REST_NOSETTASKBAR               = 0x00000020,
    REST_NODESKTOP                  = 0x00000040,
    REST_NOFIND                     = 0x00000080,
    REST_NODRIVES                   = 0x00000100,
    REST_NODRIVEAUTORUN             = 0x00000200,
    REST_NODRIVETYPEAUTORUN         = 0x00000400,
    REST_NONETHOOD                  = 0x00000800,
    REST_STARTBANNER                = 0x00001000,
    REST_RESTRICTRUN                = 0x00002000,
    REST_NOPRINTERTABS              = 0x00004000,
    REST_NOPRINTERDELETE            = 0x00008000,
    REST_NOPRINTERADD               = 0x00010000,
    REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
    REST_MYDOCSONNET                = 0x00040000,
    REST_NOEXITTODOS                = 0x00080000,
    REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
    REST_LINKRESOLVEIGNORELINKINFO  = 0x00200000,
    REST_NOCOMMONGROUPS             = 0x00400000,
    REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
    REST_NOWEB                      = 0x01000000,
    REST_NOTRAYCONTEXTMENU          = 0x02000000,
    REST_NOVIEWCONTEXTMENU          = 0x04000000,
    REST_NONETCONNECTDISCONNECT     = 0x08000000,
    REST_STARTMENULOGOFF            = 0x10000000,
    REST_NOSETTINGSASSIST           = 0x20000000,
    REST_NOINTERNETICON             = 0x40000001,
    REST_NORECENTDOCSHISTORY        = 0x40000002,
    REST_NORECENTDOCSMENU           = 0x40000003,
    REST_NOACTIVEDESKTOP            = 0x40000004,
    REST_NOACTIVEDESKTOPCHANGES     = 0x40000005,
    REST_NOFAVORITESMENU            = 0x40000006,
    REST_CLEARRECENTDOCSONEXIT      = 0x40000007,
    REST_CLASSICSHELL               = 0x40000008,
    REST_NOCUSTOMIZEWEBVIEW         = 0x40000009,
    REST_NOHTMLWALLPAPER            = 0x40000010,
    REST_NOCHANGINGWALLPAPER        = 0x40000011,
    REST_NODESKCOMP                 = 0x40000012,
    REST_NOADDDESKCOMP              = 0x40000013,
    REST_NODELDESKCOMP              = 0x40000014,
    REST_NOCLOSEDESKCOMP            = 0x40000015,
    REST_NOCLOSE_DRAGDROPBAND       = 0x40000016,   // Disable Close and Drag & Drop on ALL Bands
    REST_NOMOVINGBAND               = 0x40000017,   // Disable Moving ALL Bands
    REST_NOEDITDESKCOMP             = 0x40000018,
    REST_NORESOLVESEARCH            = 0x40000019,
    REST_NORESOLVETRACK             = 0x4000001A,
    REST_FORCECOPYACLWITHFILE       = 0x4000001B,
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_NOLOGO3CHANNELNOTIFY       = 0x4000001C,
#endif
    REST_NOFORGETSOFTWAREUPDATE     = 0x4000001D,
    REST_NOSETACTIVEDESKTOP         = 0x4000001E,   // No Active desktop on Settings Menu
    REST_NOUPDATEWINDOWS            = 0x4000001F,   // No Windows Update on Settings Menu
    REST_NOCHANGESTARMENU           = 0x40000020,   // No Context menu or Drag and Drop on Start menu
    REST_NOFOLDEROPTIONS            = 0x40000021,   // No Folder Options on Settings Menu
    REST_HASFINDCOMPUTERS           = 0x40000022,   // Show Start/Search/Computers
    REST_INTELLIMENUS               = 0x40000023,
    REST_RUNDLGMEMCHECKBOX          = 0x40000024,
    REST_ARP_ShowPostSetup          = 0x40000025,   // ARP: Show Post-Setup page
    REST_NOCSC                      = 0x40000026,   // Disable the ClientSide caching on SM
    REST_NOCONTROLPANEL             = 0x40000027,   // Remove the Control Panel only from SM|Settings
    REST_ENUMWORKGROUP              = 0x40000028,   // Enumerate workgroup in root of nethood
    REST_ARP_NOARP                  = 0x40000029,   // ARP: Don't Allow ARP to come up at all
    REST_ARP_NOREMOVEPAGE           = 0x4000002A,   // ARP: Don't allow Remove page
    REST_ARP_NOADDPAGE              = 0x4000002B,   // ARP: Don't allow Add page
    REST_ARP_NOWINSETUPPAGE         = 0x4000002C,   // ARP: Don't allow opt components page
    REST_GREYMSIADS                 = 0x4000002D,    // SM: Allow the greying of Darwin Ads in SM
    REST_NOCHANGEMAPPEDDRIVELABEL   = 0x4000002E,   // Don't enable the UI which allows users to rename mapped drive labels
    REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x4000002F,   // Don't enable the UI which allows users to change mapped drive comments
    REST_MaxRecentDocs              = 0x40000030,
    REST_NONETWORKCONNECTIONS       = 0x40000031,   // No Start Menu | Settings |Network Connections
    REST_FORCESTARTMENULOGOFF       = 0x40000032,   // Force logoff on the Start Menu
    REST_NOWEBVIEW                  = 0x40000033,   // Disable Web View
    REST_NOCUSTOMIZETHISFOLDER      = 0x40000034,   // Disable Customize This Folder
    REST_NOENCRYPTION               = 0x40000035,   // Don't allow file encryption
//  Do NOT use me                     0x40000036,
    REST_DONTSHOWSUPERHIDDEN        = 0x40000037,   // don't show super hidden files
    REST_NOSHELLSEARCHBUTTON        = 0x40000038,
    REST_NOHARDWARETAB              = 0x40000039,   // No Hardware tab on Drives or in control panel
    REST_NORUNASINSTALLPROMPT       = 0x4000003A,   // Don't bring up "Run As" prompt for install programs
    REST_PROMPTRUNASINSTALLNETPATH  = 0x4000003B,   // Force the  "Run As" prompt for install programs on unc/network shares
    REST_NOMANAGEMYCOMPUTERVERB     = 0x4000003C,   // No Manage verb on My Computer
//  Do NOT use me                     0x4000003D,
    REST_DISALLOWRUN                = 0x4000003E,   // don't allow certain apps to be run
    REST_NOWELCOMESCREEN            = 0x4000003F,   // don't allow the welcome screen to be displayed.
    REST_RESTRICTCPL                = 0x40000040,   // only allow certain cpls to be run
    REST_DISALLOWCPL                = 0x40000041,   // don't allow certain cpls to be run
    REST_NOSMBALLOONTIP             = 0x40000042,   // No Start Menu Balloon Tip
    REST_NOSMHELP                   = 0x40000043,   // No Help on the Start Menu
    REST_NOWINKEYS                  = 0x40000044,   // No Windows-X Hot keys
    REST_NOENCRYPTONMOVE            = 0x40000045,   // Don't automatically try to encrypt files that are moved to encryped directories
    REST_NOLOCALMACHINERUN          = 0x40000046,   // ignore HKLM\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOCURRENTUSERRUN           = 0x40000047,   // ignore HKCU\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOLOCALMACHINERUNONCE      = 0x40000048,   // ignore HKLM\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_NOCURRENTUSERRUNONCE       = 0x40000049,   // ignore HKCU\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_FORCEACTIVEDESKTOPON       = 0x4000004A,   // Force ActiveDesktop to be turned ON all the time.
//  Do NOT use me                     0x4000004B,
    REST_NOVIEWONDRIVE              = 0x4000004C,   // disallows CreateViewObject() on specified drives (CFSFolder only)
#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(IE_BACKCOMPAT_VERSION)
    REST_NONETCRAWL                 = 0x4000004D,   // disables the crawling of the WNet namespace.
    REST_NOSHAREDDOCUMENTS          = 0x4000004E,   // don't auto share the Shared Documents/create link
#endif  // NTDDI_WINXP
    REST_NOSMMYDOCS                 = 0x4000004F,   // Don't show the My Documents item on the Start Menu.
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOSMMYPICS                 = 0x40000050,   // Don't show the My Pictures item on the Start Menu
    REST_ALLOWBITBUCKDRIVES         = 0x40000051,   // Bit mask indicating which which drives have bit bucket support
    REST_NONLEGACYSHELLMODE         = 0x40000052,   // new consumer shell modes
    REST_NOCONTROLPANELBARRICADE    = 0x40000053,   // The webview barricade in Control Panel
    REST_NOSTARTPAGE                = 0x40000054,   // Whistler Start Page on desktop.
    REST_NOAUTOTRAYNOTIFY           = 0x40000055,   // Whistler auto-tray notify feature
    REST_NOTASKGROUPING             = 0x40000056,   // Whistler taskbar button grouping feature
    REST_NOCDBURNING                = 0x40000057,   // whistler cd burning feature
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_MYCOMPNOPROP               = 0x40000058,   // disables Properties on My Computer's context menu
    REST_MYDOCSNOPROP               = 0x40000059,   // disables Properties on My Documents' context menu
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOSTARTPANEL               = 0x4000005A,   // Windows start panel (New start menu) for Whistler.
    REST_NODISPLAYAPPEARANCEPAGE    = 0x4000005B,   // disable Themes and Appearance tabs in the Display Control Panel.
    REST_NOTHEMESTAB                = 0x4000005C,   // disable the Themes tab in the Display Control Panel.
    REST_NOVISUALSTYLECHOICE        = 0x4000005D,   // disable the visual style drop down in the Appearance tab of the Display Control Panel.
    REST_NOSIZECHOICE               = 0x4000005E,   // disable the size drop down in the Appearance tab of the Display Control Panel.
    REST_NOCOLORCHOICE              = 0x4000005F,   // disable the color drop down in the Appearance tab of the Display Control Panel.
    REST_SETVISUALSTYLE             = 0x40000060,   // Load the specified file as the visual style.
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_STARTRUNNOHOMEPATH         = 0x40000061,   // dont use the %HOMEPATH% env var for the Start-Run dialog
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOUSERNAMEINSTARTPANEL     = 0x40000062,   // don't show the username is the startpanel.
    REST_NOMYCOMPUTERICON           = 0x40000063,   // don't show my computer anywhere, hide its contents
    REST_NOSMNETWORKPLACES          = 0x40000064,   // don't show network places in startpanel.
    REST_NOSMPINNEDLIST             = 0x40000065,   // don't show the pinned list in startpanel.
    REST_NOSMMYMUSIC                = 0x40000066,   // don't show MyMusic folder in startpanel
    REST_NOSMEJECTPC                = 0x40000067,   // don't show "Undoc PC" command in startmenu
    REST_NOSMMOREPROGRAMS           = 0x40000068,   // don't show "More Programs" button in StartPanel.
    REST_NOSMMFUPROGRAMS            = 0x40000069,   // don't show the MFU programs list in StartPanel.
    REST_NOTRAYITEMSDISPLAY         = 0x4000006A,   // disables the display of the system tray
    REST_NOTOOLBARSONTASKBAR        = 0x4000006B,   // disables toolbar display on the taskbar
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_NOSMCONFIGUREPROGRAMS      = 0x4000006F,   // No Configure Programs on Settings Menu
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_HIDECLOCK                  = 0x40000070,   // don't show the clock
    REST_NOLOWDISKSPACECHECKS       = 0x40000071,   // disable the low disk space checking
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP4)
    REST_NOENTIRENETWORK            = 0x40000072,   // removes the "Entire Network" link (i.e. from "My Network Places")
#endif  // NTDDI_WIN2KSP4
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NODESKTOPCLEANUP           = 0x40000073,   // disable the desktop cleanup wizard
    REST_BITBUCKNUKEONDELETE        = 0x40000074,   // disables recycling of files
    REST_BITBUCKCONFIRMDELETE       = 0x40000075,   // always show the delete confirmation dialog when deleting files
    REST_BITBUCKNOPROP              = 0x40000076,   // disables Properties on Recycle Bin's context menu
    REST_NODISPBACKGROUND           = 0x40000077,   // disables the Desktop tab in the Display CPL
    REST_NODISPSCREENSAVEPG         = 0x40000078,   // disables the Screen Saver tab in the Display CPL
    REST_NODISPSETTINGSPG           = 0x40000079,   // disables the Settings tab in the Display CPL
    REST_NODISPSCREENSAVEPREVIEW    = 0x4000007A,   // disables the screen saver on the Screen Saver tab in the Display CPL
    REST_NODISPLAYCPL               = 0x4000007B,   // disables the Display CPL
    REST_HIDERUNASVERB              = 0x4000007C,   // hides the "Run As..." context menu item
    REST_NOTHUMBNAILCACHE           = 0x4000007D,   // disables use of the thumbnail cache
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WINXPSP1) || defined(IE_BACKCOMPAT_VERSION)
    REST_NOSTRCMPLOGICAL            = 0x4000007E,   // dont use StrCmpLogical() instead use default CompareString()
    REST_NOPUBLISHWIZARD            = 0x4000007F,   // disables publishing wizard (WPW)
    REST_NOONLINEPRINTSWIZARD       = 0x40000080,   // disables online prints wizard (OPW)
    REST_NOWEBSERVICES              = 0x40000081,   // disables the web specified services for both OPW and WPW
#endif  // NTDDI_WINXPSP1
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_ALLOWUNHASHEDWEBVIEW       = 0x40000082,   // allow the user to be promted to accept web view templates that don't already have an md5 hash in the registry
#endif  // NTDDI_WIN2KSP3
    REST_ALLOWLEGACYWEBVIEW         = 0x40000083,   // allow legacy webview template to be shown.
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_REVERTWEBVIEWSECURITY      = 0x40000084,   // disable added webview security measures (revert to w2k functionality).
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WIN2KSP4)
    REST_INHERITCONSOLEHANDLES      = 0x40000086,   // ShellExec() will check for the current process and target process being console processes to inherit handles
#endif  // NTDDI_WIN2KSP4
#if (NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_VISTA)
    REST_SORTMAXITEMCOUNT           = 0x40000087,   // Do not sort views with more items than this key. Useful for viewing big amount of files in one folder.
#endif
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_NOREMOTERECURSIVEEVENTS    = 0x40000089,   // Dont register network change events recursively to avoid network traffic
#endif  // NTDDI_WINXPSP2
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_NOREMOTECHANGENOTIFY       = 0x40000091,   // Do not notify for remote changy notifies
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_NOSIMPLENETIDLIST          = 0x40000092,   // No simple network IDLists
#endif
    REST_NOENUMENTIRENETWORK        = 0x40000093,   // Don't enumerate entire network if we happen to get to it (in conjunction with REST_NOENTIRENETWORK)
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_NODETAILSTHUMBNAILONNETWORK= 0x40000094,   // Disable Thumbnail for Network files in DUI Details pane
#endif
    REST_NOINTERNETOPENWITH         = 0x40000095,   // dont allow looking on the internet for file associations
#endif  // NTDDI_WINXPSP2
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_DONTRETRYBADNETNAME        = 0x4000009B,   // In Network Places: if provider returns ERROR_BAD_NET_NAME, give up
    REST_ALLOWFILECLSIDJUNCTIONS    = 0x4000009C,   // re-enable legacy support for file.{guid} junctions in FileSystem Folder
    REST_NOUPNPINSTALL              = 0x4000009D,   // disable "install UPnP" task in My Net Places
#endif  // NTDDI_WINXPSP2
    REST_ARP_DONTGROUPPATCHES       = 0x400000AC,   //List individual patches in Add/Remove Programs
    REST_ARP_NOCHOOSEPROGRAMSPAGE   = 0x400000AD,   //Choose programs page

    REST_NODISCONNECT               = 0x41000001,   // No Disconnect option in Start menu
    REST_NOSECURITY                 = 0x41000002,   // No Security option in start menu
    REST_NOFILEASSOCIATE            = 0x41000003,   // Do not allow user to change file association
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_ALLOWCOMMENTTOGGLE         = 0x41000004,   // Allow the user to toggle the positions of the Comment and the Computer Name
#if (NTDDI_VERSION < NTDDI_VISTA)
    REST_USEDESKTOPINICACHE         = 0x41000005,   // Cache desktop.ini entries from network folders
#endif  // NTDDI_VISTA
#endif  // NTDDI_WINXPSP2
} RESTRICTIONS;
SHSTDAPI_(IStream *) OpenRegStream(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
SHSTDAPI_(BOOL) SHFindFiles(__in_opt PCIDLIST_ABSOLUTE pidlFolder, __in_opt PCIDLIST_ABSOLUTE pidlSaveFile);
SHSTDAPI_(void) PathGetShortPath(__inout_ecount(MAX_PATH) LPWSTR pszLongPath);
__success(return != 0)
SHSTDAPI_(BOOL) PathYetAnotherMakeUniqueName(__out_ecount(MAX_PATH) LPWSTR  pszUniqueName, LPCWSTR pszPath, LPCWSTR pszShort, LPCWSTR pszFileSpec);
SHSTDAPI_(BOOL) Win32DeleteFile(LPCWSTR pszPath);
#if (NTDDI_VERSION < NTDDI_VISTA)
//
// Path processing function
//
#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names
#define PPCF_LONGESTPOSSIBLE         0x00000080        // always find the longest possible name

SHSTDAPI_(LONG) PathProcessCommand(__in LPCWSTR lpSrc, __out_ecount(iMax) LPWSTR lpDest, __in int iMax, __in DWORD dwFlags);
#endif
SHSTDAPI_(DWORD) SHRestricted(RESTRICTIONS rest);
SHSTDAPI_(BOOL) SignalFileOpen(PCIDLIST_ABSOLUTE pidl);

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI AssocGetDetailsOfPropKey(__in IShellFolder *psf, __in PCUITEMID_CHILD pidl, __in const PROPERTYKEY *pkey, __out VARIANT *pv, __out_opt BOOL *pfFoundPropKey);
#endif

#if (NTDDI_VERSION < NTDDI_VISTA)
SHSTDAPI SHLoadOLE(LPARAM lParam);
#endif

// both ANSI and UNICODE
SHSTDAPI SHStartNetConnectionDialogA(HWND hwnd, __in_opt LPCSTR pszRemoteName, DWORD dwType);
// both ANSI and UNICODE
SHSTDAPI SHStartNetConnectionDialogW(HWND hwnd, __in_opt LPCWSTR pszRemoteName, DWORD dwType);
#ifdef UNICODE
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogW
#else
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogA
#endif // !UNICODE
SHSTDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags,
                           __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIconSize);
SHSTDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags,
                           __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIconSize);
#ifdef UNICODE
#define SHDefExtractIcon  SHDefExtractIconW
#else
#define SHDefExtractIcon  SHDefExtractIconA
#endif // !UNICODE

// Elevation

// OpenAsInfo flags
enum tagOPEN_AS_INFO_FLAGS {
    OAIF_ALLOW_REGISTRATION = 0x00000001,     // enable the "always use this file" checkbox (NOTE if you don't pass this, it will be disabled)
    OAIF_REGISTER_EXT       = 0x00000002,     // do the registration after the user hits "ok"
    OAIF_EXEC               = 0x00000004,     // execute file after registering
    OAIF_FORCE_REGISTRATION = 0x00000008,     // force the "always use this file" checkbox to be checked (normally, you won't use the OAIF_ALLOW_REGISTRATION when you pass this)
#if (NTDDI_VERSION >= NTDDI_VISTA)
    OAIF_HIDE_REGISTRATION  = 0x00000020,     // hide the "always use this file" checkbox
    OAIF_URL_PROTOCOL       = 0x00000040,     // the "extension" passed is actually a protocol, and open with should show apps registered as capable of handling that protocol
#endif
};
typedef int OPEN_AS_INFO_FLAGS;


#include <pshpack8.h>

typedef struct _openasinfo
{
    LPCWSTR pcszFile;               // [in] file name, or protocol name if
                                    //      OAIF_URL_PROTOCOL is set.
    LPCWSTR pcszClass;              // [in] file class description. NULL means
                                    //      use pcszFile's extension. ignored
                                    //      if OAIF_URL_PROTOCOL is set.
    OPEN_AS_INFO_FLAGS oaifInFlags; // [in] input flags from OPEN_AS_INFO_FLAGS enumeration
} OPENASINFO, * POPENASINFO;

#include <poppack.h>        /* Return to byte packing */

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHOpenWithDialog(__in_opt HWND hwndParent, __in const OPENASINFO* poainfo);
#endif // NTDDI_VISTA

SHSTDAPI_(BOOL) Shell_GetImageLists(__out_opt HIMAGELIST *phiml, __out_opt HIMAGELIST *phimlSmall);
SHSTDAPI_(int)  Shell_GetCachedImageIndex(LPCWSTR pwszIconPath, int iIconIndex, UINT uIconFlags);
#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI_(int)  Shell_GetCachedImageIndexA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);
SHSTDAPI_(int)  Shell_GetCachedImageIndexW(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
#ifdef UNICODE
#define Shell_GetCachedImageIndex  Shell_GetCachedImageIndexW
#else
#define Shell_GetCachedImageIndex  Shell_GetCachedImageIndexA
#endif // !UNICODE
#endif // NTDDI_VISTA

//
// IDocViewSite
//
#undef  INTERFACE
#define INTERFACE  IDocViewSite
DECLARE_INTERFACE_IID_(IDocViewSite, IUnknown, "87D605E0-C511-11CF-89A9-00A0C9054129")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocViewSite methods ***
    STDMETHOD(OnSetTitle) (THIS_ VARIANTARG *pvTitle) PURE;

} ;
#define VALIDATEUNC_CONNECT     0x0001          // connect a drive letter
#define VALIDATEUNC_NOUI        0x0002          // don't bring up UI
#define VALIDATEUNC_PRINT       0x0004          // validate as print share instead of disk share
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define VALIDATEUNC_PERSIST     0x0008          // the connection should be made persistent
#define VALIDATEUNC_VALID       0x000F          // valid flags
#else
#define VALIDATEUNC_VALID       0x0007          // valid flags
#endif

SHSTDAPI_(BOOL) SHValidateUNC(HWND hwndOwner, __inout LPWSTR pszFile, UINT fConnect);
#define OPENPROPS_NONE          0x0000
#define OPENPROPS_INHIBITPIF    0x8000
#define GETPROPS_NONE           0x0000
#define SETPROPS_NONE           0x0000
#define CLOSEPROPS_NONE         0x0000
#define CLOSEPROPS_DISCARD      0x0001

#define PIFNAMESIZE     30
#define PIFSTARTLOCSIZE 63
#define PIFDEFPATHSIZE  64
#define PIFPARAMSSIZE   64
#define PIFSHPROGSIZE   64
#define PIFSHDATASIZE   64
#define PIFDEFFILESIZE  80
#define PIFMAXFILEPATH  260

typedef struct PROPPRG {                    /* prg */
    WORD    flPrg;                          // see PRG_ flags
    WORD    flPrgInit;                      // see PRGINIT_ flags
    CHAR    achTitle[PIFNAMESIZE];          // name[30]
    CHAR    achCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// startfile[63] + params[64]
    CHAR    achWorkDir[PIFDEFPATHSIZE];     // defpath[64]
    WORD    wHotKey;                        // PfHotKeyScan thru PfHotKeyVal
    CHAR    achIconFile[PIFDEFFILESIZE];    // name of file containing icon
    WORD    wIconIndex;                     // index of icon within file
    DWORD   dwEnhModeFlags;                 // reserved enh-mode flags
    DWORD   dwRealModeFlags;                // real-mode flags (see RMOPT_*)
    CHAR    achOtherFile[PIFDEFFILESIZE];   // name of "other" file in directory
    CHAR    achPIFFile[PIFMAXFILEPATH];     // name of PIF file
} PROPPRG;
typedef UNALIGNED PROPPRG *PPROPPRG;
typedef UNALIGNED PROPPRG FAR *LPPROPPRG;
typedef const UNALIGNED PROPPRG FAR *LPCPROPPRG;

SHSTDAPI_(HANDLE) PifMgr_OpenProperties(LPCWSTR pszApp, __in_opt LPCWSTR pszPIF, UINT hInf, UINT flOpt);
SHSTDAPI_(int)    PifMgr_GetProperties(__in_opt HANDLE hProps, __in_opt LPCSTR pszGroup, __out_bcount_opt(cbProps) void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(int)    PifMgr_SetProperties(__in_opt HANDLE hProps, __in_opt LPCSTR pszGroup, __in_bcount(cbProps) const void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(HANDLE) PifMgr_CloseProperties(__in_opt HANDLE hProps, UINT flOpt);

SHSTDAPI_(void) SHSetInstanceExplorer(IUnknown *punk);
SHSTDAPI_(BOOL) IsUserAnAdmin(void);

#undef  INTERFACE
#define INTERFACE   IInitializeObject

DECLARE_INTERFACE_IID_(IInitializeObject, IUnknown, "4622AD16-FF23-11d0-8D34-00A0C90F2719")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInitializeObject methods
    STDMETHOD(Initialize)(THIS) PURE;
};


enum
{
    BMICON_LARGE = 0,
    BMICON_SMALL
};

#undef  INTERFACE
#define INTERFACE   IBanneredBar

DECLARE_INTERFACE_IID_(IBanneredBar, IUnknown, "596A9A94-013E-11d1-8D34-00A0C90F2719")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBanneredBar methods ***
    STDMETHOD(SetIconSize)(THIS_ DWORD iIcon) PURE;
    STDMETHOD(GetIconSize)(THIS_ DWORD* piIcon) PURE;
    STDMETHOD(SetBitmap)(THIS_ HBITMAP hBitmap) PURE;
    STDMETHOD(GetBitmap)(THIS_ HBITMAP* phBitmap) PURE;

};

SHSTDAPI_(LRESULT) SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);

//
// Callback interface for the IShellView object returned from SHCreateShellFolderView.

//
#undef  INTERFACE
#define INTERFACE   IShellFolderViewCB

DECLARE_INTERFACE_IID_(IShellFolderViewCB, IUnknown, "2047E320-F2A9-11CE-AE65-08002B2E1262")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewCB methods ***
    STDMETHOD(MessageSFVCB)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};


#include <pshpack8.h>

#define QCMINFO_PLACE_BEFORE    0
#define QCMINFO_PLACE_AFTER     1
typedef struct _QCMINFO_IDMAP_PLACEMENT
{
    UINT id;
    UINT fFlags;
} QCMINFO_IDMAP_PLACEMENT;

typedef struct _QCMINFO_IDMAP
{
    UINT                    nMaxIds;
    QCMINFO_IDMAP_PLACEMENT pIdList[1];
} QCMINFO_IDMAP;

typedef struct _QCMINFO
{
    HMENU       hmenu;          // in
    UINT        indexMenu;      // in
    UINT        idCmdFirst;     // in/out
    UINT        idCmdLast;      // in
    QCMINFO_IDMAP const*  pIdMap; // in / unused
} QCMINFO;
typedef QCMINFO * LPQCMINFO;

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2
#define TBIF_DEFAULT      0x00000000
#define TBIF_INTERNETBAR  0x00010000
#define TBIF_STANDARDTOOLBAR   0x00020000
#define TBIF_NOTOOLBAR  0x00030000

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO;
typedef TBINFO * LPTBINFO;


typedef struct _DETAILSINFO
{
    PCUITEMID_CHILD pidl;
    int fmt;
    int cxChar;
    STRRET str;
    int iImage;
} DETAILSINFO;
typedef DETAILSINFO *PDETAILSINFO;

typedef struct _SFVM_PROPPAGE_DATA
{
    DWORD                dwReserved;
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM               lParam;
} SFVM_PROPPAGE_DATA;

typedef struct _SFVM_HELPTOPIC_DATA
{
    WCHAR wszHelpFile[MAX_PATH];
    WCHAR wszHelpTopic[MAX_PATH];
} SFVM_HELPTOPIC_DATA;

//                                 uMsg    wParam             lParam
#define SFVM_MERGEMENU             1    // -                  LPQCMINFO
#define SFVM_INVOKECOMMAND         2    // idCmd              -
#define SFVM_GETHELPTEXT           3    // idCmd,cchMax       pszText
#define SFVM_GETTOOLTIPTEXT        4    // idCmd,cchMax       pszText
#define SFVM_GETBUTTONINFO         5    // -                  LPTBINFO
#define SFVM_GETBUTTONS            6    // idCmdFirst,cbtnMax LPTBBUTTON
#define SFVM_INITMENUPOPUP         7    // idCmdFirst,nIndex  hmenu
#define SFVM_FSNOTIFY             14    // LPCITEMIDLIST*     lEvent
#define SFVM_WINDOWCREATED        15    // hwnd               -
#define SFVM_GETDETAILSOF         23    // iColumn            DETAILSINFO*
#define SFVM_COLUMNCLICK          24    // iColumn            -
#define SFVM_QUERYFSNOTIFY        25    // -                  SHChangeNotifyEntry *
#define SFVM_DEFITEMCOUNT         26    // -                  UINT*
#define SFVM_DEFVIEWMODE          27    // -                  FOLDERVIEWMODE*
#define SFVM_UNMERGEMENU          28    // -                  hmenu
#define SFVM_UPDATESTATUSBAR      31    // fInitialize        -
#define SFVM_BACKGROUNDENUM       32    // -                  -
#define SFVM_DIDDRAGDROP          36    // dwEffect           IDataObject *
#define SFVM_SETISFV              39    // -                  IShellFolderView*
#define SFVM_THISIDLIST           41    // -                  LPITMIDLIST*
#define SFVM_ADDPROPERTYPAGES     47    // -                  SFVM_PROPPAGE_DATA *
#define SFVM_BACKGROUNDENUMDONE   48    // -                  -
#define SFVM_GETNOTIFY            49    // LPITEMIDLIST*      LONG*
#define SFVM_GETSORTDEFAULTS      53    // iDirection         iParamSort
#define SFVM_SIZE                 57    // -                  -
#define SFVM_GETZONE              58    // -                  DWORD*
#define SFVM_GETPANE              59    // Pane ID            DWORD*
#define SFVM_GETHELPTOPIC         63    // -                  SFVM_HELPTOPIC_DATA *
#define SFVM_GETANIMATION         68    // HINSTANCE *        WCHAR *

// IShellFolderView
//
// Deprecated: use IFolderView and IFolderView2 instead.
//
// IShellFolderView is supported by the IShellView object returned from SHCreateShellFolderView.
//
// Warnings:
//  - Some methods on this interface do not follow standard COM rules.
//  - Some methods can be used to configure the IShellView or cause it to behave incorrectly.
//  - Few of these methods have parameter or range validation, so callers can cause the IShellView to fault.

typedef struct _ITEMSPACING
{
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING;

// defines for IShellFolderView::SetObjectCount
#define SFVSOC_INVALIDATE_ALL   0x00000001  // Assumed to reset only what is neccessary...
#define SFVSOC_NOSCROLL         LVSICF_NOSCROLL

// defines for IShellFolderView::SelectItems()
#define SFVS_SELECT_NONE        0x0 // unselect all
#define SFVS_SELECT_ALLITEMS    0x1 // select all
#define SFVS_SELECT_INVERT      0x2 // Invert the selection

#undef  INTERFACE
#define INTERFACE   IShellFolderView

DECLARE_INTERFACE_IID_(IShellFolderView, IUnknown, "37A378C0-F82D-11CE-AE65-08002B2E1262")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderView methods ***
    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE; // use IFolderView2::SetSortColumns
    STDMETHOD(GetArrangeParam) (THIS_ LPARAM *plParamSort) PURE; // use IFolderView2::GetSortColumns
    STDMETHOD(ArrangeGrid) (THIS) PURE; // select Arrange by Grid
    STDMETHOD(AutoArrange) (THIS) PURE; // select Auto Arrange
    STDMETHOD(GetAutoArrange) (THIS) PURE; // use IFolderView::GetAutoArrange
    STDMETHOD(AddObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // items added here may disappear (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(GetObject) (THIS_ PITEMID_CHILD *ppidl, UINT uItem) PURE; // use IFolderView::Item
    STDMETHOD(RemoveObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // items removed here may reappear (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(GetObjectCount) (THIS_ UINT *puCount) PURE; // use IFolderView::ItemCount
    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE; // not implemented on Vista.  Sends LVM_SETITEMCOUNT with WPARAM=uCount and LPARAM=dwFlags to listview on XP.
    STDMETHOD(UpdateObject) (THIS_ PUITEMID_CHILD pidlOld, PUITEMID_CHILD pidlNew, UINT *puItem) PURE; // swaps ITEMID_CHILDs, returning new index.  Changes may be discarded (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(RefreshObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // tickles the listview to re-draw the item
    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE; // sends WM_SETREDRAW to the listview
    STDMETHOD(GetSelectedCount) (THIS_ UINT *puSelected) PURE; // use IFolderView2::GetSelection
    // NOTE: GetSelectedObjects hands out const pointers to internal ITEMID_CHILD structures. The caller is expected to act on them immediately (and not cache them).  LocalFree the array, but not the items it contains.
    STDMETHOD(GetSelectedObjects) (THIS_ PCUITEMID_CHILD **pppidl, UINT *puItems) PURE; // use IFolderView2::GetSelection.
    STDMETHOD(IsDropOnSource) (THIS_ IDropTarget *pDropTarget) PURE; // use IFolderView2::IsMoveInSameFolder
    STDMETHOD(GetDragPoint) (THIS_ POINT *ppt) PURE; // returns point corresponding to drag-and-drop operation
    STDMETHOD(GetDropPoint) (THIS_ POINT *ppt) PURE; // returns point corresponding to drag-and-drop operation
    STDMETHOD(MoveIcons) (THIS_ IDataObject *pDataObject) PURE; // not implemented
    STDMETHOD(SetItemPos) (THIS_ PCUITEMID_CHILD pidl, POINT *ppt) PURE; // use IFolderView::SelectAndPositionItems
    STDMETHOD(IsBkDropTarget) (THIS_ IDropTarget *pDropTarget) PURE; // returns S_OK if drag-and-drop is on the background, S_FALSE otherwise
    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE; // if bMove is TRUE, this attempts to cut (edit.cut, ctrl-x) the current selection.  bMove of FALSE is not supported.
    STDMETHOD(SetPoints) (THIS_ IDataObject *pDataObject) PURE; // copies points of current selection in to data object.  Call is not needed if drag operation was originated by the IShellView.
    STDMETHOD(GetItemSpacing) (THIS_ ITEMSPACING *pSpacing) PURE; // use IFolderView::GetSpacing instead.  GetItemSpacing returns the spacing for small and large view modes only, returning S_OK if the current view mode is is positionable, S_FALSE otherwise.
    STDMETHOD(SetCallback) (THIS_ IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB) PURE; // replace the IShellFolderViewCB that the IShellView uses
    STDMETHOD(Select) ( THIS_  UINT dwFlags ) PURE; // SFVS_ select flags: select all, select none, invert selection
    STDMETHOD(QuerySupport) (THIS_ UINT * pdwSupport ) PURE; // does nothing, returns S_OK.
    STDMETHOD(SetAutomationObject)(THIS_ IDispatch* pdisp) PURE; // replaces the IShellView's internal automation object.
} ;

// SHCreateShellFolderView struct
typedef struct _SFV_CREATE
{
    UINT            cbSize;     // must be sizeof(SFV_CREATE)
    IShellFolder*   pshf;       // IShellFolder the IShellView will use
    IShellView*     psvOuter;   // optional: IShellView to pass to psfvcb
    IShellFolderViewCB* psfvcb; // No callback if NULL
} SFV_CREATE;

SHSTDAPI SHCreateShellFolderView(__in const SFV_CREATE* pcsfv, __deref_out IShellView ** ppsv);
typedef HRESULT (CALLBACK * LPFNDFMCALLBACK)(__in_opt IShellFolder *psf, __in_opt HWND hwnd,
                                             __in_opt IDataObject *pdtobj, __in UINT uMsg, __in WPARAM wParam, __in LPARAM lParam);

SHSTDAPI CDefFolderMenu_Create2(__in_opt PCIDLIST_ABSOLUTE pidlFolder, __in_opt HWND hwnd,
                                __in_opt UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
                                __in_opt IShellFolder *psf, __in_opt LPFNDFMCALLBACK pfn,
                                __in UINT nKeys, __in_ecount_opt(nKeys) const HKEY *ahkeys,
                                __deref_out IContextMenu **ppcm);
typedef struct {
    HWND hwnd;
    IContextMenuCB *pcmcb;          // optional: callback object
    PCIDLIST_ABSOLUTE pidlFolder;   // optional: IDList to folder of the items, computed from psf if NULL
    IShellFolder *psf;              // folder of the items
    UINT cidl;                      // # of items in apidl
    PCUITEMID_CHILD_ARRAY apidl;    // items operating on, used to get IDataObject and IAssociationArray
    IUnknown *punkAssociationInfo;  // optional: IQueryAssociations, specifies where to load extensions from, computed from apidl if NULL
    UINT cKeys;                     // # of items in aKeys, may be zero
    const HKEY *aKeys;              // optional: specifies where to load extensions from
} DEFCONTEXTMENU;

// creates object that implements IContextMenu/IContextMenu2/IContextMenu3, typically
// used in the implemetnation of ::GetUIObjectOf()

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHCreateDefaultContextMenu(__in const DEFCONTEXTMENU *pdcm, __in REFIID riid, __deref_out void **ppv);
#endif // NTDDI_VISTA

SHSTDAPI_(BOOL) SHOpenPropSheetA(__in_opt LPCSTR pszCaption, __in_ecount_opt(cikeys) HKEY ahkeys[], UINT cikeys,
                                 __in_opt const CLSID * pclsidDefault, __in IDataObject *pdtobj,
                                 __in_opt IShellBrowser *psb, __in_opt LPCSTR pStartPage);
SHSTDAPI_(BOOL) SHOpenPropSheetW(__in_opt LPCWSTR pszCaption, __in_ecount_opt(cikeys) HKEY ahkeys[], UINT cikeys,
                                 __in_opt const CLSID * pclsidDefault, __in IDataObject *pdtobj,
                                 __in_opt IShellBrowser *psb, __in_opt LPCWSTR pStartPage);
#ifdef UNICODE
#define SHOpenPropSheet  SHOpenPropSheetW
#else
#define SHOpenPropSheet  SHOpenPropSheetA
#endif // !UNICODE

// structure for lParam of DFM_INFOKECOMMANDEX
typedef struct
{
    DWORD  cbSize;
    DWORD  fMask;   // CMIC_MASK_ values for the invoke
    LPARAM lParam;  // same as lParam of DFM_INFOKECOMMAND
    UINT idCmdFirst;
    UINT idDefMax;
    LPCMINVOKECOMMANDINFO pici; // the whole thing so you can re-invoke on a child
#if (NTDDI_VERSION >= NTDDI_VISTA)
    IUnknown *punkSite;         // site pointer for context menu handler
#endif
} DFMICS, *PDFMICS;

// Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM

//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_INVOKECOMMANDEX          12     // idCmd        PDFMICS
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName
#define DFM_GETDEFSTATICID           14     // idCmd *      0
#define DFM_GETVERBW                 15     // idCmd,cchMax pszText -Unicode
#define DFM_GETVERBA                 16     // idCmd,cchMax pszText -Ansi
#define DFM_MERGECONTEXTMENU_BOTTOM  17     // uFlags       LPQCMINFO
#define DFM_MODIFYQCMFLAGS           18     // uFlags       UINT *puNewFlags;   modify the CFM_XXX values passed to IContextMenu::QueryContextMenu

// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE          ((UINT)-1)
#define DFM_CMD_MOVE            ((UINT)-2)
#define DFM_CMD_COPY            ((UINT)-3)
#define DFM_CMD_LINK            ((UINT)-4)
#define DFM_CMD_PROPERTIES      ((UINT)-5)
#define DFM_CMD_NEWFOLDER       ((UINT)-6)
#define DFM_CMD_PASTE           ((UINT)-7)
#define DFM_CMD_VIEWLIST        ((UINT)-8)
#define DFM_CMD_VIEWDETAILS     ((UINT)-9)
#define DFM_CMD_PASTELINK       ((UINT)-10)
#define DFM_CMD_PASTESPECIAL    ((UINT)-11)
#define DFM_CMD_MODALPROP       ((UINT)-12)
#define DFM_CMD_RENAME          ((UINT)-13)


typedef HRESULT (CALLBACK * LPFNVIEWCALLBACK)(IShellView *psvOuter,
                                                IShellFolder *psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT              cbSize;
    IShellFolder *    pshf;
    IShellView *      psvOuter;
    PCIDLIST_ABSOLUTE pidl;
    LONG              lEvents;
    LPFNVIEWCALLBACK  pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE    fvm;
} CSFV, * LPCSFV;


// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE          0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)
// Add an OBJECT into the view
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)(_pidl))
// Remove an OBJECT into the view
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)(_pidl))

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
//
// _ppidl[1] must be a *copy* of a pidl, as control over the lifetime
// of the pidl belongs to the view after successful completion of
// this call.  (Unsuccessful completion (a -1 return) implies failure
// and the caller must free the memory.)  Win95 waits a while before
// freeing the pidl, IE4 frees the pidl immediately.
// IShellFolderView::UpdateObject does not suffer from this problem.
//
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)(_ppidl))


// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)(ppidl))
typedef struct _SFV_SETITEMPOS
{
        PCUITEMID_CHILD pidl;
        POINT pt;
} SFV_SETITEMPOS;
typedef SFV_SETITEMPOS *LPSFV_SETITEMPOS;
typedef const SFV_SETITEMPOS *PCSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS         0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{       SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
        SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}
//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))
#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)(_pdtobj))
#include <poppack.h>        /* Return to byte packing */
SHSTDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);
SHSTDAPI SHCreateShellFolderViewEx(__in LPCSFV pcsfv, __deref_out IShellView ** ppsv);


// Legacy PROPIDs for Internet Shortcuts (FMTID_Intshcut) to be used with
// IPropertySetStorage/IPropertyStorage.
//
// The known property ids and their variant types are:
//      PID_IS_URL          [VT_LPWSTR]   URL
//      PID_IS_NAME         [VT_LPWSTR]   Name of the internet shortcut
//      PID_IS_WORKINGDIR   [VT_LPWSTR]   Working directory for the shortcut
//      PID_IS_HOTKEY       [VT_UI2]      Hotkey for the shortcut
//      PID_IS_SHOWCMD      [VT_I4]       Show command for shortcut
//      PID_IS_ICONINDEX    [VT_I4]       Index into file that has icon
//      PID_IS_ICONFILE     [VT_LPWSTR]   File that has the icon
//      PID_IS_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_IS_AUTHOR       [VT_LPWSTR]   Author
//      PID_IS_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_IS_COMMENT      [VT_LPWSTR]   User annotated comment

#define PID_IS_URL           2
#define PID_IS_NAME          4
#define PID_IS_WORKINGDIR    5
#define PID_IS_HOTKEY        6
#define PID_IS_SHOWCMD       7
#define PID_IS_ICONINDEX     8
#define PID_IS_ICONFILE      9
#define PID_IS_WHATSNEW      10
#define PID_IS_AUTHOR        11
#define PID_IS_DESCRIPTION   12
#define PID_IS_COMMENT       13

// PROPIDs for Internet Sites (FMTID_InternetSite) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_INTSITE_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_INTSITE_AUTHOR       [VT_LPWSTR]   Author
//      PID_INTSITE_LASTVISIT    [VT_FILETIME] Time site was last visited
//      PID_INTSITE_LASTMOD      [VT_FILETIME] Time site was last modified
//      PID_INTSITE_VISITCOUNT   [VT_UI4]      Number of times user has visited
//      PID_INTSITE_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_INTSITE_COMMENT      [VT_LPWSTR]   User annotated comment
//      PID_INTSITE_RECURSE      [VT_UI4]      Levels to recurse (0-3)
//      PID_INTSITE_WATCH        [VT_UI4]      PIDISM_ flags
//      PID_INTSITE_SUBSCRIPTION [VT_UI8]      Subscription cookie
//      PID_INTSITE_URL          [VT_LPWSTR]   URL
//      PID_INTSITE_TITLE        [VT_LPWSTR]   Title
//      PID_INTSITE_CODEPAGE     [VT_UI4]      Codepage of the document
//      PID_INTSITE_TRACKING     [VT_UI4]      Tracking
//      PID_INTSITE_ICONINDEX    [VT_I4]       Retrieve the index to the icon
//      PID_INTSITE_ICONFILE     [VT_LPWSTR]   Retrieve the file containing the icon index.
//      PID_INTSITE_RAWURL       [VT_LPWSTR]   The raw, un-encoded, unicode url.

#define PID_INTSITE_WHATSNEW      2
#define PID_INTSITE_AUTHOR        3
#define PID_INTSITE_LASTVISIT     4
#define PID_INTSITE_LASTMOD       5
#define PID_INTSITE_VISITCOUNT    6
#define PID_INTSITE_DESCRIPTION   7
#define PID_INTSITE_COMMENT       8
#define PID_INTSITE_FLAGS         9
#define PID_INTSITE_CONTENTLEN    10
#define PID_INTSITE_CONTENTCODE   11
#define PID_INTSITE_RECURSE       12
#define PID_INTSITE_WATCH         13
#define PID_INTSITE_SUBSCRIPTION  14
#define PID_INTSITE_URL           15
#define PID_INTSITE_TITLE         16
#define PID_INTSITE_CODEPAGE      18
#define PID_INTSITE_TRACKING      19
#define PID_INTSITE_ICONINDEX     20
#define PID_INTSITE_ICONFILE      21

// Flags for PID_IS_FLAGS
#define PIDISF_RECENTLYCHANGED  0x00000001
#define PIDISF_CACHEDSTICKY     0x00000002
#define PIDISF_CACHEIMAGES      0x00000010
#define PIDISF_FOLLOWALLLINKS   0x00000020


// Values for PID_INTSITE_WATCH
#define PIDISM_GLOBAL           0       // Monitor based on global setting
#define PIDISM_WATCH            1       // User says watch
#define PIDISM_DONTWATCH        2       // User says don't watch


////////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;

    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1; // No longer used, dead bit
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;
    BOOL fNoNetCrawling : 1;

    DWORD dwWin95Unused; // Win95 only - no longer supported pszHiddenFileExts
    UINT  uWin95Unused; // Win95 only - no longer supported cbHiddenFileExts

    // Note: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG   lParamSort;
    int    iSortDirection;

    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;

    // new for Whistler.
    BOOL fStartPanelOn: 1;       //Indicates if the Whistler StartPanel mode is ON or OFF.
    BOOL fShowStartPage: 1;      //Indicates if the Whistler StartPage on desktop is ON or OFF.

    // new for Windows Vista
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    BOOL fShowTypeOverlay: 1;

    UINT fSpareFlags : 11;

} SHELLSTATEA, *LPSHELLSTATEA;

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;
    BOOL fNoNetCrawling : 1;

    DWORD dwWin95Unused; // Win95 only - no longer supported pszHiddenFileExts
    UINT  uWin95Unused; // Win95 only - no longer supported cbHiddenFileExts

    // Note: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG   lParamSort;
    int    iSortDirection;
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;

    // new for Whistler.
    BOOL fStartPanelOn: 1;       //Indicates if the Whistler StartPage mode is ON or OFF.
    BOOL fShowStartPage: 1;      //Indicates if the Whistler StartPage on desktop is ON or OFF.

    // new for Windows Vista
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    BOOL fShowTypeOverlay: 1;

    // If you need a new flag, steal a bit from from fSpareFlags.
    // Also, keep SHELLFLAGSTATE and SHGetSettings in sync when adding new flags.
    UINT fSpareFlags : 11;

} SHELLSTATEW, *LPSHELLSTATEW;

#define SHELLSTATEVERSION_IE4   9
#define SHELLSTATEVERSION_WIN2K 10

#ifdef UNICODE
#define SHELLSTATE   SHELLSTATEW
#define LPSHELLSTATE LPSHELLSTATEW
#else
#define SHELLSTATE   SHELLSTATEA
#define LPSHELLSTATE LPSHELLSTATEA
#endif

#define SHELLSTATE_SIZE_WIN95 FIELD_OFFSET(SHELLSTATE,lParamSort)
#define SHELLSTATE_SIZE_NT4   FIELD_OFFSET(SHELLSTATE,version)
#define SHELLSTATE_SIZE_IE4   FIELD_OFFSET(SHELLSTATE,uNotUsed)
#define SHELLSTATE_SIZE_WIN2K sizeof(SHELLSTATE)

SHSTDAPI_(void) SHGetSetSettings(__inout_opt LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);

//
//  SysFiles are these windows special files:
//      "dll sys vxd 386 drv"
//
//  hidden files are files with the FILE_ATTRIBUTE_HIDDEN attribute
//
//  system files are files with the FILE_ATTRIBUTE_SYSTEM attribute
//
//      fShowAllObjects fShowSysFiles   Result
//      --------------- -------------   ------
//      0               0               hide hidden + SysFiles + system files
//      0               1               hide hidden files.
//      1               0               show all files.
//      1               1               show all files.
//
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
#if (NTDDI_VERSION >= NTDDI_VISTA)
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    UINT fRestFlags : 1; // when adding additional flags keep SHELLSTATE and SHGetSettings in sync.

#else
    UINT fRestFlags : 3; // when adding additional flags keep SHELLSTATE and SHGetSettings in sync.
#endif
} SHELLFLAGSTATE, *LPSHELLFLAGSTATE;

#define SSF_SHOWALLOBJECTS          0x00000001
#define SSF_SHOWEXTENSIONS          0x00000002
#define SSF_HIDDENFILEEXTS          0x00000004
#define SSF_SERVERADMINUI           0x00000004
#define SSF_SHOWCOMPCOLOR           0x00000008
#define SSF_SORTCOLUMNS             0x00000010
#define SSF_SHOWSYSFILES            0x00000020
#define SSF_DOUBLECLICKINWEBVIEW    0x00000080
#define SSF_SHOWATTRIBCOL           0x00000100
#define SSF_DESKTOPHTML             0x00000200
#define SSF_WIN95CLASSIC            0x00000400
#define SSF_DONTPRETTYPATH          0x00000800
#define SSF_SHOWINFOTIP             0x00002000
#define SSF_MAPNETDRVBUTTON         0x00001000
#define SSF_NOCONFIRMRECYCLE        0x00008000
#define SSF_HIDEICONS               0x00004000
#define SSF_FILTER                  0x00010000
#define SSF_WEBVIEW                 0x00020000
#define SSF_SHOWSUPERHIDDEN         0x00040000
#define SSF_SEPPROCESS              0x00080000
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SSF_NONETCRAWLING           0x00100000
#define SSF_STARTPANELON            0x00200000
#define SSF_SHOWSTARTPAGE           0x00400000
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SSF_AUTOCHECKSELECT         0x00800000
#define SSF_ICONSONLY               0x01000000
#define SSF_SHOWTYPEOVERLAY         0x02000000
#endif  // NTDDI_VISTA

//
// Specify the bits you are interested in in dwMask and they will be
// filled out in the lpss structure.
//
// When these settings change, a WM_SETTINGCHANGE message is sent
// with the string lParam value of "ShellState".
//
SHSTDAPI_(void) SHGetSettings(__out SHELLFLAGSTATE *psfs, DWORD dwMask);

//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
SHSTDAPI SHBindToParent(__in PCIDLIST_ABSOLUTE pidl, __in REFIID riid, __deref_out void **ppv, __deref_opt_out PCUITEMID_CHILD *ppidlLast);

#if (NTDDI_VERSION >= NTDDI_VISTA)

// Same as SHBindToParent, except you also specify which root to use.
SHSTDAPI SHBindToFolderIDListParent(__in_opt IShellFolder *psfRoot, __in PCUIDLIST_RELATIVE pidl, __in REFIID riid, __deref_out void **ppv, __deref_opt_out PCUITEMID_CHILD *ppidlLast);

// same as SHBindToFolderIDListParent but with a IBindCtx *pbc;
SHSTDAPI SHBindToFolderIDListParentEx(__in_opt IShellFolder *psfRoot, __in PCUIDLIST_RELATIVE pidl, __in_opt IBindCtx *ppbc, __in REFIID riid, __deref_out void **ppv, __deref_opt_out PCUITEMID_CHILD *ppidlLast);

// helper function that gets the desktop object, then calls BindToObject on that
SHSTDAPI SHBindToObject(__in_opt IShellFolder *psf, __in PCUIDLIST_RELATIVE pidl, __in_opt IBindCtx *pbc, __in REFIID riid, __deref_out void **ppv);

#endif // NTDDI_VISTA

//
//  given a string it will call psfDesktop->ParseDisplayName() to try and create a pidl
//  if no pbc specified, it uses the preferred options for parsing.
//  this includes mapping file system paths to their appropriate aliased location (RegisterObjectParam(STR_PARSE_TRANSLATE_ALIASES))
//  psfgaoOut is optional for SFGAO attributes
//
#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHParseDisplayName(__in PCWSTR pszName, __in_opt IBindCtx *pbc, __deref_out PIDLIST_ABSOLUTE *ppidl, __in SFGAOF sfgaoIn, __out_opt SFGAOF *psfgaoOut);
#endif // NTDDI_WINXP

//
// This API will make its best effort to prepare the path for the caller.  This includes:
// 1. Prompting for the ejectable media to be re-inserted. (Floppy, CD-ROM, ZIP drive, etc.)
// 2. Prompting for the media to be formatted. (Floppy, hard drive, etc.)
// 3. Remount mapped drives if the connection was lost. (\\unc\share mapped to N: becomes disconnected)
// 4. If the path doesn't exist, create it.  (SHPPFW_DIRCREATE and SHPPFW_ASKDIRCREATE)
// 5. Display an error if the media is read only. (SHPPFW_NOWRITECHECK not set)
//
// PARAMETERS:
//      hwnd: Parernt window for UI.  NULL means don't display UI. OPTIONAL
//      punkEnableModless: Parent that will be set to modal during UI using IOleInPlaceActiveObject::EnableModeless(). OPTIONAL
//      pszPath: Path to verify is valid for writting.  This can be a UNC or file drive path.  The path
//               should only contain directories.  Pass SHPPFW_IGNOREFILENAME if the last path segment
//               is always filename to ignore.
//      dwFlags: SHPPFW_* Flags to modify behavior

#define SHPPFW_NONE             0x00000000
#define SHPPFW_DEFAULT          SHPPFW_DIRCREATE        // May change
#define SHPPFW_DIRCREATE        0x00000001              // Create the directory if it doesn't exist without asking the user.
#define SHPPFW_ASKDIRCREATE     0x00000002              // Create the directory if it doesn't exist after asking the user.
#define SHPPFW_IGNOREFILENAME   0x00000004              // Ignore the last item in pszPath because it's a file.  Example: pszPath="C:\DirA\DirB", only use "C:\DirA".
#define SHPPFW_NOWRITECHECK     0x00000008              // Caller only needs to read from the drive, so don't check if it's READ ONLY.
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SHPPFW_MEDIACHECKONLY   0x00000010              // do the retrys on the media (or net path), return errors if the file can't be found
#endif // NTDDI_WINXP

SHSTDAPI SHPathPrepareForWriteA(HWND hwnd, IUnknown *punkEnableModless, LPCSTR pszPath, DWORD dwFlags);
SHSTDAPI SHPathPrepareForWriteW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pszPath, DWORD dwFlags);
#ifdef UNICODE
#define SHPathPrepareForWrite  SHPathPrepareForWriteW
#else
#define SHPathPrepareForWrite  SHPathPrepareForWriteA
#endif // !UNICODE


//--------------------------------------------------------------------------
//
// Interface used for exposing the INI file methods on a shortcut file
//
//
//--------------------------------------------------------------------------
#undef  INTERFACE
#define INTERFACE  INamedPropertyBag
DECLARE_INTERFACE_IID_(INamedPropertyBag, IUnknown, "FB700430-952C-11d1-946F-000000000000")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    // *** INamedPropertyBag methods ***
    STDMETHOD(ReadPropertyNPB) (THIS_  /* [in] */ LPCWSTR pszBagname,
                            /* [in] */ LPCWSTR pszPropName,
                            /* [out][in] */ PROPVARIANT *pVar) PURE;

    STDMETHOD(WritePropertyNPB)(THIS_ /* [in] */ LPCWSTR pszBagname,
                           /* [in] */ LPCWSTR pszPropName,
                           /* [in] */ PROPVARIANT  *pVar) PURE;

    STDMETHOD(RemovePropertyNPB)(THIS_ /* [in] */ LPCWSTR pszBagname,
                          /* [in] */ LPCWSTR pszPropName) PURE;
};

#ifdef __urlmon_h__
//    NOTE: urlmon.h must be included before shlobj.h to access this function.
//
//    SoftwareUpdateMessageBox
//
//    Provides a standard message box for the alerting the user that a software
//    update is available or installed. No UI will be displayed if there is no
//    update available or if the available update version is less than or equal
//    to the Advertised update version.
//
//    hWnd                - [in] Handle of owner window
//    szDistUnit          - [in] Unique identifier string for a code distribution unit. For
//                               ActiveX controls and Active Setup installed components, this
//                               is typically a GUID string.
//    dwFlags             - [in] Must be 0.
//    psdi                - [in,out] Pointer to SOFTDISTINFO ( see URLMon.h ). May be NULL.
//                                cbSize should be initialized
//                                by the caller to sizeof(SOFTDISTINFO), dwReserved should be set to 0.
//
//    RETURNS:
//
//    IDNO     - The user chose cancel. If *pbRemind is FALSE, the caller should save the
//               update version from the SOFTDISTINFO and pass it in as the Advertised
//               version in future calls.
//
//    IDYES    - The user has selected Update Now/About Update. The caller should navigate to
//               the SOFTDISTINFO's pszHREF to initiate the install or learn about it.
//               The caller should save the update version from the SOFTDISTINFO and pass
//               it in as the Advertised version in future calls.
//
//    IDIGNORE - There is no pending software update. Note: There is
//               no Ignore button in the standard UI. This occurs if the available
//               version is less than the installed version or is not present or if the
//               Advertised version is greater than or equal to the update version.
//
//    IDABORT  - An error occured. Call GetSoftwareUpdateInfo() for a more specific HRESULT.
//               Note: There is no Abort button in the standard UI.


SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                           LPCWSTR pszDistUnit,
                                           DWORD dwFlags,
                                           __out_opt LPSOFTDISTINFO psdi );
#endif // if __urlmon_h__


//  SHPropStgCreate()
//  Wrap of IPropertySetStorage::Open/Create
//
//  This function ensures proper handling of code page retrieval/assignment
//  for the requested property set operation.
//
//  psstg,          //  Address of IPropertySetStorage vtable
//  fmtid,          //  property set ID
//  pclsid,         //  class ID associated with the set. This can be NULL
//  grfFlags,       //  PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                    //  PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT.
//  grfMode,        //  STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
//  dwDisposition,  //  OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, or CREATE_ALWAYS
//  IPropertyStorage** ppstg,  // Address to receive requested vtable
//  puCodePage      //  Optional address to receive the code page ID for the set.
//
SHSTDAPI SHPropStgCreate(__in IPropertySetStorage* psstg, __in REFFMTID fmtid, __in_opt const CLSID *pclsid, __in DWORD grfFlags, __in DWORD grfMode, __in DWORD dwDisposition, __deref_out IPropertyStorage** ppstg, __out_opt UINT* puCodePage );


//  SHPropStgReadMultiple()
//  IPropertyStorage::ReadMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, //Code page value retrieved from SHCreatePropertySet
//  cpspec,    //Count of properties being read
//  rgpspec,   //Array of the properties to be read
//  rgvar      //Array of PROPVARIANTs containing the property values on return
//
SHSTDAPI SHPropStgReadMultiple( IPropertyStorage* pps, UINT uCodePage, ULONG cpspec, __in_ecount(cpspec) PROPSPEC const rgpspec[], __out_ecount_full(cpspec) PROPVARIANT rgvar[] );


//  SHPropStgWriteMultiple()
//  IPropertyStorage::WriteMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, // code page retrieved from SHCreatePropertySet.
//  cpspec,    // The number of properties being set
//  rgpspec,   // Property specifiers
//  rgvar,     // Array of PROPVARIANT values
//  propidNameFirst // Minimum value for property identifiers. This value should be >= PID_FIRST_USABLE
//
SHSTDAPI SHPropStgWriteMultiple( IPropertyStorage* pps, __inout_opt UINT* puCodePage, ULONG cpspec, __in_ecount(cpspec) PROPSPEC const rgpspec[], __inout_ecount(cpspec) PROPVARIANT rgvar[], PROPID propidNameFirst );

#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHCreateFileExtractIconA(__in LPCSTR pszFile, __in DWORD dwFileAttributes, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateFileExtractIconW(__in LPCWSTR pszFile, __in DWORD dwFileAttributes, __in REFIID riid, __deref_out void **ppv);
#ifdef UNICODE
#define SHCreateFileExtractIcon  SHCreateFileExtractIconW
#else
#define SHCreateFileExtractIcon  SHCreateFileExtractIconA
#endif // !UNICODE
#include <pshpack8.h>
#include <poppack.h>        /* Return to byte packing */
SHSTDAPI SHLimitInputEdit(HWND hwndEdit, IShellFolder *psf);
STDAPI SHGetAttributesFromDataObject(IDataObject *pdo, DWORD dwAttributeMask, __out_opt DWORD *pdwAttributes, __out_opt UINT *pcItems);
#endif  // NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// The SHMultiFileProperties API displays a property sheet for a
// set of files specified in an IDList Array.
//
// Parameters:
//      pdtobj  - Data object containing list of files.  The data
//                object must provide the "Shell IDList Array"
//                clipboard format.  The parent folder's implementation of
//                IShellFolder::GetDisplayNameOf must return a fully-qualified
//                filesystem path for each item in response to the
//                SHGDN_FORPARSING flag.
//
//      dwFlags - Reserved for future use.  Should be set to 0.
//
// Returns:
//      S_OK
//
SHSTDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);

#endif  // NTDDI_WIN2K

// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
SHSTDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *pshf, PCUITEMID_CHILD pidl, __out_opt int *piIndexSel);

SHSTDAPI SHCLSIDFromString(LPCWSTR psz, __out CLSID *pclsid);
SHSTDAPI SHCreateQueryCancelAutoPlayMoniker(__out IMoniker** ppmoniker);    // deprecated: use CreateClassMoniker(CLSID_YourOwnClsid, ...)
STDAPI_(void) PerUserInit(void);
SHSTDAPI_(BOOL)SHRunControlPanel(LPCWSTR lpcszCmdLine, HWND hwndMsgParent);

SHSTDAPI_(int) PickIconDlg(HWND hwnd, __inout_ecount(cchIconPath) LPWSTR pszIconPath, UINT cchIconPath, __inout_opt int *piIconIndex);

#include <pshpack8.h>

typedef struct tagAAMENUFILENAME
{
  SHORT  cbTotal;
  BYTE   rgbReserved[12];
  WCHAR  szFileName[1];     // variable length string
} AASHELLMENUFILENAME, *LPAASHELLMENUFILENAME;

typedef struct tagAASHELLMENUITEM
{
  void*  lpReserved1;
  int    iReserved;
  UINT   uiReserved;
  LPAASHELLMENUFILENAME lpName; // name of file
  LPWSTR psz;           // text to use if no file
} AASHELLMENUITEM, *LPAASHELLMENUITEM;

#include <poppack.h>        /* Return to byte packing */


#if (NTDDI_VERSION >= NTDDI_WIN7)
// returns an IStream or IStorage via riid/ppv
STDAPI StgMakeUniqueName(__in IStorage *pstgParent, __in PCWSTR pszFileSpec, __in DWORD grfMode, __in REFIID riid, __deref_out void **ppv);
#endif // NTDDI_WIN7

#if (_WIN32_IE >= _WIN32_IE_IE70)
typedef enum tagIESHORTCUTFLAGS
{
    IESHORTCUT_NEWBROWSER    = 0x01,
    IESHORTCUT_OPENNEWTAB    = 0x02,
    IESHORTCUT_FORCENAVIGATE = 0x04,
    IESHORTCUT_BACKGROUNDTAB = 0x08,
} IESHORTCUTFLAGS;
#endif // _WIN32_IE_IE70

#if (_WIN32_IE >= _WIN32_IE_XP)

SHDOCAPI_(BOOL) ImportPrivacySettings(LPCWSTR pszFilename, __inout BOOL* pfParsePrivacyPreferences, __inout BOOL* pfParsePerSiteRules);
#ifndef IEnumPrivacyRecords
typedef interface IEnumPrivacyRecords IEnumPrivacyRecords;
#endif
SHDOCAPI DoPrivacyDlg(HWND hwndOwner, __in LPCWSTR pszUrl, __in IEnumPrivacyRecords *pPrivacyEnum, BOOL fReportAllSites);

#endif  // _WIN32_IE_XP

#include <poppack.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if (_MSC_VER >= 800)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#else
#pragma warning(default:4001)
#endif
#endif

#endif /* _SHLOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ShObjIdl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for shobjidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shobjidl_h__
#define __shobjidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IContextMenu_FWD_DEFINED__
#define __IContextMenu_FWD_DEFINED__
typedef interface IContextMenu IContextMenu;
#endif 	/* __IContextMenu_FWD_DEFINED__ */


#ifndef __IContextMenu2_FWD_DEFINED__
#define __IContextMenu2_FWD_DEFINED__
typedef interface IContextMenu2 IContextMenu2;
#endif 	/* __IContextMenu2_FWD_DEFINED__ */


#ifndef __IContextMenu3_FWD_DEFINED__
#define __IContextMenu3_FWD_DEFINED__
typedef interface IContextMenu3 IContextMenu3;
#endif 	/* __IContextMenu3_FWD_DEFINED__ */


#ifndef __IExecuteCommand_FWD_DEFINED__
#define __IExecuteCommand_FWD_DEFINED__
typedef interface IExecuteCommand IExecuteCommand;
#endif 	/* __IExecuteCommand_FWD_DEFINED__ */


#ifndef __IPersistFolder_FWD_DEFINED__
#define __IPersistFolder_FWD_DEFINED__
typedef interface IPersistFolder IPersistFolder;
#endif 	/* __IPersistFolder_FWD_DEFINED__ */


#ifndef __IRunnableTask_FWD_DEFINED__
#define __IRunnableTask_FWD_DEFINED__
typedef interface IRunnableTask IRunnableTask;
#endif 	/* __IRunnableTask_FWD_DEFINED__ */


#ifndef __IShellTaskScheduler_FWD_DEFINED__
#define __IShellTaskScheduler_FWD_DEFINED__
typedef interface IShellTaskScheduler IShellTaskScheduler;
#endif 	/* __IShellTaskScheduler_FWD_DEFINED__ */


#ifndef __IQueryCodePage_FWD_DEFINED__
#define __IQueryCodePage_FWD_DEFINED__
typedef interface IQueryCodePage IQueryCodePage;
#endif 	/* __IQueryCodePage_FWD_DEFINED__ */


#ifndef __IPersistFolder2_FWD_DEFINED__
#define __IPersistFolder2_FWD_DEFINED__
typedef interface IPersistFolder2 IPersistFolder2;
#endif 	/* __IPersistFolder2_FWD_DEFINED__ */


#ifndef __IPersistFolder3_FWD_DEFINED__
#define __IPersistFolder3_FWD_DEFINED__
typedef interface IPersistFolder3 IPersistFolder3;
#endif 	/* __IPersistFolder3_FWD_DEFINED__ */


#ifndef __IPersistIDList_FWD_DEFINED__
#define __IPersistIDList_FWD_DEFINED__
typedef interface IPersistIDList IPersistIDList;
#endif 	/* __IPersistIDList_FWD_DEFINED__ */


#ifndef __IEnumIDList_FWD_DEFINED__
#define __IEnumIDList_FWD_DEFINED__
typedef interface IEnumIDList IEnumIDList;
#endif 	/* __IEnumIDList_FWD_DEFINED__ */


#ifndef __IEnumFullIDList_FWD_DEFINED__
#define __IEnumFullIDList_FWD_DEFINED__
typedef interface IEnumFullIDList IEnumFullIDList;
#endif 	/* __IEnumFullIDList_FWD_DEFINED__ */


#ifndef __IObjectWithFolderEnumMode_FWD_DEFINED__
#define __IObjectWithFolderEnumMode_FWD_DEFINED__
typedef interface IObjectWithFolderEnumMode IObjectWithFolderEnumMode;
#endif 	/* __IObjectWithFolderEnumMode_FWD_DEFINED__ */


#ifndef __IParseAndCreateItem_FWD_DEFINED__
#define __IParseAndCreateItem_FWD_DEFINED__
typedef interface IParseAndCreateItem IParseAndCreateItem;
#endif 	/* __IParseAndCreateItem_FWD_DEFINED__ */


#ifndef __IShellFolder_FWD_DEFINED__
#define __IShellFolder_FWD_DEFINED__
typedef interface IShellFolder IShellFolder;
#endif 	/* __IShellFolder_FWD_DEFINED__ */


#ifndef __IEnumExtraSearch_FWD_DEFINED__
#define __IEnumExtraSearch_FWD_DEFINED__
typedef interface IEnumExtraSearch IEnumExtraSearch;
#endif 	/* __IEnumExtraSearch_FWD_DEFINED__ */


#ifndef __IShellFolder2_FWD_DEFINED__
#define __IShellFolder2_FWD_DEFINED__
typedef interface IShellFolder2 IShellFolder2;
#endif 	/* __IShellFolder2_FWD_DEFINED__ */


#ifndef __IFolderViewOptions_FWD_DEFINED__
#define __IFolderViewOptions_FWD_DEFINED__
typedef interface IFolderViewOptions IFolderViewOptions;
#endif 	/* __IFolderViewOptions_FWD_DEFINED__ */


#ifndef __IShellView_FWD_DEFINED__
#define __IShellView_FWD_DEFINED__
typedef interface IShellView IShellView;
#endif 	/* __IShellView_FWD_DEFINED__ */


#ifndef __IShellView2_FWD_DEFINED__
#define __IShellView2_FWD_DEFINED__
typedef interface IShellView2 IShellView2;
#endif 	/* __IShellView2_FWD_DEFINED__ */


#ifndef __IShellView3_FWD_DEFINED__
#define __IShellView3_FWD_DEFINED__
typedef interface IShellView3 IShellView3;
#endif 	/* __IShellView3_FWD_DEFINED__ */


#ifndef __IFolderView_FWD_DEFINED__
#define __IFolderView_FWD_DEFINED__
typedef interface IFolderView IFolderView;
#endif 	/* __IFolderView_FWD_DEFINED__ */


#ifndef __ISearchBoxInfo_FWD_DEFINED__
#define __ISearchBoxInfo_FWD_DEFINED__
typedef interface ISearchBoxInfo ISearchBoxInfo;
#endif 	/* __ISearchBoxInfo_FWD_DEFINED__ */


#ifndef __IFolderView2_FWD_DEFINED__
#define __IFolderView2_FWD_DEFINED__
typedef interface IFolderView2 IFolderView2;
#endif 	/* __IFolderView2_FWD_DEFINED__ */


#ifndef __IFolderViewSettings_FWD_DEFINED__
#define __IFolderViewSettings_FWD_DEFINED__
typedef interface IFolderViewSettings IFolderViewSettings;
#endif 	/* __IFolderViewSettings_FWD_DEFINED__ */


#ifndef __IPreviewHandlerVisuals_FWD_DEFINED__
#define __IPreviewHandlerVisuals_FWD_DEFINED__
typedef interface IPreviewHandlerVisuals IPreviewHandlerVisuals;
#endif 	/* __IPreviewHandlerVisuals_FWD_DEFINED__ */


#ifndef __IVisualProperties_FWD_DEFINED__
#define __IVisualProperties_FWD_DEFINED__
typedef interface IVisualProperties IVisualProperties;
#endif 	/* __IVisualProperties_FWD_DEFINED__ */


#ifndef __ICommDlgBrowser_FWD_DEFINED__
#define __ICommDlgBrowser_FWD_DEFINED__
typedef interface ICommDlgBrowser ICommDlgBrowser;
#endif 	/* __ICommDlgBrowser_FWD_DEFINED__ */


#ifndef __ICommDlgBrowser2_FWD_DEFINED__
#define __ICommDlgBrowser2_FWD_DEFINED__
typedef interface ICommDlgBrowser2 ICommDlgBrowser2;
#endif 	/* __ICommDlgBrowser2_FWD_DEFINED__ */


#ifndef __ICommDlgBrowser3_FWD_DEFINED__
#define __ICommDlgBrowser3_FWD_DEFINED__
typedef interface ICommDlgBrowser3 ICommDlgBrowser3;
#endif 	/* __ICommDlgBrowser3_FWD_DEFINED__ */


#ifndef __IColumnManager_FWD_DEFINED__
#define __IColumnManager_FWD_DEFINED__
typedef interface IColumnManager IColumnManager;
#endif 	/* __IColumnManager_FWD_DEFINED__ */


#ifndef __IFolderFilterSite_FWD_DEFINED__
#define __IFolderFilterSite_FWD_DEFINED__
typedef interface IFolderFilterSite IFolderFilterSite;
#endif 	/* __IFolderFilterSite_FWD_DEFINED__ */


#ifndef __IFolderFilter_FWD_DEFINED__
#define __IFolderFilter_FWD_DEFINED__
typedef interface IFolderFilter IFolderFilter;
#endif 	/* __IFolderFilter_FWD_DEFINED__ */


#ifndef __IInputObjectSite_FWD_DEFINED__
#define __IInputObjectSite_FWD_DEFINED__
typedef interface IInputObjectSite IInputObjectSite;
#endif 	/* __IInputObjectSite_FWD_DEFINED__ */


#ifndef __IInputObject_FWD_DEFINED__
#define __IInputObject_FWD_DEFINED__
typedef interface IInputObject IInputObject;
#endif 	/* __IInputObject_FWD_DEFINED__ */


#ifndef __IInputObject2_FWD_DEFINED__
#define __IInputObject2_FWD_DEFINED__
typedef interface IInputObject2 IInputObject2;
#endif 	/* __IInputObject2_FWD_DEFINED__ */


#ifndef __IShellIcon_FWD_DEFINED__
#define __IShellIcon_FWD_DEFINED__
typedef interface IShellIcon IShellIcon;
#endif 	/* __IShellIcon_FWD_DEFINED__ */


#ifndef __IShellBrowser_FWD_DEFINED__
#define __IShellBrowser_FWD_DEFINED__
typedef interface IShellBrowser IShellBrowser;
#endif 	/* __IShellBrowser_FWD_DEFINED__ */


#ifndef __IProfferService_FWD_DEFINED__
#define __IProfferService_FWD_DEFINED__
typedef interface IProfferService IProfferService;
#endif 	/* __IProfferService_FWD_DEFINED__ */


#ifndef __IShellItem_FWD_DEFINED__
#define __IShellItem_FWD_DEFINED__
typedef interface IShellItem IShellItem;
#endif 	/* __IShellItem_FWD_DEFINED__ */


#ifndef __IShellItem2_FWD_DEFINED__
#define __IShellItem2_FWD_DEFINED__
typedef interface IShellItem2 IShellItem2;
#endif 	/* __IShellItem2_FWD_DEFINED__ */


#ifndef __IShellItemImageFactory_FWD_DEFINED__
#define __IShellItemImageFactory_FWD_DEFINED__
typedef interface IShellItemImageFactory IShellItemImageFactory;
#endif 	/* __IShellItemImageFactory_FWD_DEFINED__ */


#ifndef __IUserAccountChangeCallback_FWD_DEFINED__
#define __IUserAccountChangeCallback_FWD_DEFINED__
typedef interface IUserAccountChangeCallback IUserAccountChangeCallback;
#endif 	/* __IUserAccountChangeCallback_FWD_DEFINED__ */


#ifndef __IEnumShellItems_FWD_DEFINED__
#define __IEnumShellItems_FWD_DEFINED__
typedef interface IEnumShellItems IEnumShellItems;
#endif 	/* __IEnumShellItems_FWD_DEFINED__ */


#ifndef __ITransferAdviseSink_FWD_DEFINED__
#define __ITransferAdviseSink_FWD_DEFINED__
typedef interface ITransferAdviseSink ITransferAdviseSink;
#endif 	/* __ITransferAdviseSink_FWD_DEFINED__ */


#ifndef __ITransferSource_FWD_DEFINED__
#define __ITransferSource_FWD_DEFINED__
typedef interface ITransferSource ITransferSource;
#endif 	/* __ITransferSource_FWD_DEFINED__ */


#ifndef __IEnumResources_FWD_DEFINED__
#define __IEnumResources_FWD_DEFINED__
typedef interface IEnumResources IEnumResources;
#endif 	/* __IEnumResources_FWD_DEFINED__ */


#ifndef __IShellItemResources_FWD_DEFINED__
#define __IShellItemResources_FWD_DEFINED__
typedef interface IShellItemResources IShellItemResources;
#endif 	/* __IShellItemResources_FWD_DEFINED__ */


#ifndef __ITransferDestination_FWD_DEFINED__
#define __ITransferDestination_FWD_DEFINED__
typedef interface ITransferDestination ITransferDestination;
#endif 	/* __ITransferDestination_FWD_DEFINED__ */


#ifndef __IStreamAsync_FWD_DEFINED__
#define __IStreamAsync_FWD_DEFINED__
typedef interface IStreamAsync IStreamAsync;
#endif 	/* __IStreamAsync_FWD_DEFINED__ */


#ifndef __IStreamUnbufferedInfo_FWD_DEFINED__
#define __IStreamUnbufferedInfo_FWD_DEFINED__
typedef interface IStreamUnbufferedInfo IStreamUnbufferedInfo;
#endif 	/* __IStreamUnbufferedInfo_FWD_DEFINED__ */


#ifndef __IFileOperationProgressSink_FWD_DEFINED__
#define __IFileOperationProgressSink_FWD_DEFINED__
typedef interface IFileOperationProgressSink IFileOperationProgressSink;
#endif 	/* __IFileOperationProgressSink_FWD_DEFINED__ */


#ifndef __IShellItemArray_FWD_DEFINED__
#define __IShellItemArray_FWD_DEFINED__
typedef interface IShellItemArray IShellItemArray;
#endif 	/* __IShellItemArray_FWD_DEFINED__ */


#ifndef __IInitializeWithItem_FWD_DEFINED__
#define __IInitializeWithItem_FWD_DEFINED__
typedef interface IInitializeWithItem IInitializeWithItem;
#endif 	/* __IInitializeWithItem_FWD_DEFINED__ */


#ifndef __IObjectWithSelection_FWD_DEFINED__
#define __IObjectWithSelection_FWD_DEFINED__
typedef interface IObjectWithSelection IObjectWithSelection;
#endif 	/* __IObjectWithSelection_FWD_DEFINED__ */


#ifndef __IObjectWithBackReferences_FWD_DEFINED__
#define __IObjectWithBackReferences_FWD_DEFINED__
typedef interface IObjectWithBackReferences IObjectWithBackReferences;
#endif 	/* __IObjectWithBackReferences_FWD_DEFINED__ */


#ifndef __IPropertyUI_FWD_DEFINED__
#define __IPropertyUI_FWD_DEFINED__
typedef interface IPropertyUI IPropertyUI;
#endif 	/* __IPropertyUI_FWD_DEFINED__ */


#ifndef __ICategoryProvider_FWD_DEFINED__
#define __ICategoryProvider_FWD_DEFINED__
typedef interface ICategoryProvider ICategoryProvider;
#endif 	/* __ICategoryProvider_FWD_DEFINED__ */


#ifndef __ICategorizer_FWD_DEFINED__
#define __ICategorizer_FWD_DEFINED__
typedef interface ICategorizer ICategorizer;
#endif 	/* __ICategorizer_FWD_DEFINED__ */


#ifndef __IDropTargetHelper_FWD_DEFINED__
#define __IDropTargetHelper_FWD_DEFINED__
typedef interface IDropTargetHelper IDropTargetHelper;
#endif 	/* __IDropTargetHelper_FWD_DEFINED__ */


#ifndef __IDragSourceHelper_FWD_DEFINED__
#define __IDragSourceHelper_FWD_DEFINED__
typedef interface IDragSourceHelper IDragSourceHelper;
#endif 	/* __IDragSourceHelper_FWD_DEFINED__ */


#ifndef __IDragSourceHelper2_FWD_DEFINED__
#define __IDragSourceHelper2_FWD_DEFINED__
typedef interface IDragSourceHelper2 IDragSourceHelper2;
#endif 	/* __IDragSourceHelper2_FWD_DEFINED__ */


#ifndef __IShellLinkA_FWD_DEFINED__
#define __IShellLinkA_FWD_DEFINED__
typedef interface IShellLinkA IShellLinkA;
#endif 	/* __IShellLinkA_FWD_DEFINED__ */


#ifndef __IShellLinkW_FWD_DEFINED__
#define __IShellLinkW_FWD_DEFINED__
typedef interface IShellLinkW IShellLinkW;
#endif 	/* __IShellLinkW_FWD_DEFINED__ */


#ifndef __IShellLinkDataList_FWD_DEFINED__
#define __IShellLinkDataList_FWD_DEFINED__
typedef interface IShellLinkDataList IShellLinkDataList;
#endif 	/* __IShellLinkDataList_FWD_DEFINED__ */


#ifndef __IResolveShellLink_FWD_DEFINED__
#define __IResolveShellLink_FWD_DEFINED__
typedef interface IResolveShellLink IResolveShellLink;
#endif 	/* __IResolveShellLink_FWD_DEFINED__ */


#ifndef __IActionProgressDialog_FWD_DEFINED__
#define __IActionProgressDialog_FWD_DEFINED__
typedef interface IActionProgressDialog IActionProgressDialog;
#endif 	/* __IActionProgressDialog_FWD_DEFINED__ */


#ifndef __IHWEventHandler_FWD_DEFINED__
#define __IHWEventHandler_FWD_DEFINED__
typedef interface IHWEventHandler IHWEventHandler;
#endif 	/* __IHWEventHandler_FWD_DEFINED__ */


#ifndef __IHWEventHandler2_FWD_DEFINED__
#define __IHWEventHandler2_FWD_DEFINED__
typedef interface IHWEventHandler2 IHWEventHandler2;
#endif 	/* __IHWEventHandler2_FWD_DEFINED__ */


#ifndef __IQueryCancelAutoPlay_FWD_DEFINED__
#define __IQueryCancelAutoPlay_FWD_DEFINED__
typedef interface IQueryCancelAutoPlay IQueryCancelAutoPlay;
#endif 	/* __IQueryCancelAutoPlay_FWD_DEFINED__ */


#ifndef __IDynamicHWHandler_FWD_DEFINED__
#define __IDynamicHWHandler_FWD_DEFINED__
typedef interface IDynamicHWHandler IDynamicHWHandler;
#endif 	/* __IDynamicHWHandler_FWD_DEFINED__ */


#ifndef __IActionProgress_FWD_DEFINED__
#define __IActionProgress_FWD_DEFINED__
typedef interface IActionProgress IActionProgress;
#endif 	/* __IActionProgress_FWD_DEFINED__ */


#ifndef __IShellExtInit_FWD_DEFINED__
#define __IShellExtInit_FWD_DEFINED__
typedef interface IShellExtInit IShellExtInit;
#endif 	/* __IShellExtInit_FWD_DEFINED__ */


#ifndef __IShellPropSheetExt_FWD_DEFINED__
#define __IShellPropSheetExt_FWD_DEFINED__
typedef interface IShellPropSheetExt IShellPropSheetExt;
#endif 	/* __IShellPropSheetExt_FWD_DEFINED__ */


#ifndef __IRemoteComputer_FWD_DEFINED__
#define __IRemoteComputer_FWD_DEFINED__
typedef interface IRemoteComputer IRemoteComputer;
#endif 	/* __IRemoteComputer_FWD_DEFINED__ */


#ifndef __IQueryContinue_FWD_DEFINED__
#define __IQueryContinue_FWD_DEFINED__
typedef interface IQueryContinue IQueryContinue;
#endif 	/* __IQueryContinue_FWD_DEFINED__ */


#ifndef __IObjectWithCancelEvent_FWD_DEFINED__
#define __IObjectWithCancelEvent_FWD_DEFINED__
typedef interface IObjectWithCancelEvent IObjectWithCancelEvent;
#endif 	/* __IObjectWithCancelEvent_FWD_DEFINED__ */


#ifndef __IUserNotification_FWD_DEFINED__
#define __IUserNotification_FWD_DEFINED__
typedef interface IUserNotification IUserNotification;
#endif 	/* __IUserNotification_FWD_DEFINED__ */


#ifndef __IUserNotificationCallback_FWD_DEFINED__
#define __IUserNotificationCallback_FWD_DEFINED__
typedef interface IUserNotificationCallback IUserNotificationCallback;
#endif 	/* __IUserNotificationCallback_FWD_DEFINED__ */


#ifndef __IUserNotification2_FWD_DEFINED__
#define __IUserNotification2_FWD_DEFINED__
typedef interface IUserNotification2 IUserNotification2;
#endif 	/* __IUserNotification2_FWD_DEFINED__ */


#ifndef __IItemNameLimits_FWD_DEFINED__
#define __IItemNameLimits_FWD_DEFINED__
typedef interface IItemNameLimits IItemNameLimits;
#endif 	/* __IItemNameLimits_FWD_DEFINED__ */


#ifndef __ISearchFolderItemFactory_FWD_DEFINED__
#define __ISearchFolderItemFactory_FWD_DEFINED__
typedef interface ISearchFolderItemFactory ISearchFolderItemFactory;
#endif 	/* __ISearchFolderItemFactory_FWD_DEFINED__ */


#ifndef __IExtractImage_FWD_DEFINED__
#define __IExtractImage_FWD_DEFINED__
typedef interface IExtractImage IExtractImage;
#endif 	/* __IExtractImage_FWD_DEFINED__ */


#ifndef __IExtractImage2_FWD_DEFINED__
#define __IExtractImage2_FWD_DEFINED__
typedef interface IExtractImage2 IExtractImage2;
#endif 	/* __IExtractImage2_FWD_DEFINED__ */


#ifndef __IThumbnailHandlerFactory_FWD_DEFINED__
#define __IThumbnailHandlerFactory_FWD_DEFINED__
typedef interface IThumbnailHandlerFactory IThumbnailHandlerFactory;
#endif 	/* __IThumbnailHandlerFactory_FWD_DEFINED__ */


#ifndef __IParentAndItem_FWD_DEFINED__
#define __IParentAndItem_FWD_DEFINED__
typedef interface IParentAndItem IParentAndItem;
#endif 	/* __IParentAndItem_FWD_DEFINED__ */


#ifndef __IDockingWindow_FWD_DEFINED__
#define __IDockingWindow_FWD_DEFINED__
typedef interface IDockingWindow IDockingWindow;
#endif 	/* __IDockingWindow_FWD_DEFINED__ */


#ifndef __IDeskBand_FWD_DEFINED__
#define __IDeskBand_FWD_DEFINED__
typedef interface IDeskBand IDeskBand;
#endif 	/* __IDeskBand_FWD_DEFINED__ */


#ifndef __IDeskBandInfo_FWD_DEFINED__
#define __IDeskBandInfo_FWD_DEFINED__
typedef interface IDeskBandInfo IDeskBandInfo;
#endif 	/* __IDeskBandInfo_FWD_DEFINED__ */


#ifndef __IDeskBand2_FWD_DEFINED__
#define __IDeskBand2_FWD_DEFINED__
typedef interface IDeskBand2 IDeskBand2;
#endif 	/* __IDeskBand2_FWD_DEFINED__ */


#ifndef __ITaskbarList_FWD_DEFINED__
#define __ITaskbarList_FWD_DEFINED__
typedef interface ITaskbarList ITaskbarList;
#endif 	/* __ITaskbarList_FWD_DEFINED__ */


#ifndef __ITaskbarList2_FWD_DEFINED__
#define __ITaskbarList2_FWD_DEFINED__
typedef interface ITaskbarList2 ITaskbarList2;
#endif 	/* __ITaskbarList2_FWD_DEFINED__ */


#ifndef __ITaskbarList3_FWD_DEFINED__
#define __ITaskbarList3_FWD_DEFINED__
typedef interface ITaskbarList3 ITaskbarList3;
#endif 	/* __ITaskbarList3_FWD_DEFINED__ */


#ifndef __ITaskbarList4_FWD_DEFINED__
#define __ITaskbarList4_FWD_DEFINED__
typedef interface ITaskbarList4 ITaskbarList4;
#endif 	/* __ITaskbarList4_FWD_DEFINED__ */


#ifndef __IStartMenuPinnedList_FWD_DEFINED__
#define __IStartMenuPinnedList_FWD_DEFINED__
typedef interface IStartMenuPinnedList IStartMenuPinnedList;
#endif 	/* __IStartMenuPinnedList_FWD_DEFINED__ */


#ifndef __ICDBurn_FWD_DEFINED__
#define __ICDBurn_FWD_DEFINED__
typedef interface ICDBurn ICDBurn;
#endif 	/* __ICDBurn_FWD_DEFINED__ */


#ifndef __IWizardSite_FWD_DEFINED__
#define __IWizardSite_FWD_DEFINED__
typedef interface IWizardSite IWizardSite;
#endif 	/* __IWizardSite_FWD_DEFINED__ */


#ifndef __IWizardExtension_FWD_DEFINED__
#define __IWizardExtension_FWD_DEFINED__
typedef interface IWizardExtension IWizardExtension;
#endif 	/* __IWizardExtension_FWD_DEFINED__ */


#ifndef __IWebWizardExtension_FWD_DEFINED__
#define __IWebWizardExtension_FWD_DEFINED__
typedef interface IWebWizardExtension IWebWizardExtension;
#endif 	/* __IWebWizardExtension_FWD_DEFINED__ */


#ifndef __IPublishingWizard_FWD_DEFINED__
#define __IPublishingWizard_FWD_DEFINED__
typedef interface IPublishingWizard IPublishingWizard;
#endif 	/* __IPublishingWizard_FWD_DEFINED__ */


#ifndef __IFolderViewHost_FWD_DEFINED__
#define __IFolderViewHost_FWD_DEFINED__
typedef interface IFolderViewHost IFolderViewHost;
#endif 	/* __IFolderViewHost_FWD_DEFINED__ */


#ifndef __IExplorerBrowserEvents_FWD_DEFINED__
#define __IExplorerBrowserEvents_FWD_DEFINED__
typedef interface IExplorerBrowserEvents IExplorerBrowserEvents;
#endif 	/* __IExplorerBrowserEvents_FWD_DEFINED__ */


#ifndef __IExplorerBrowser_FWD_DEFINED__
#define __IExplorerBrowser_FWD_DEFINED__
typedef interface IExplorerBrowser IExplorerBrowser;
#endif 	/* __IExplorerBrowser_FWD_DEFINED__ */


#ifndef __IAccessibleObject_FWD_DEFINED__
#define __IAccessibleObject_FWD_DEFINED__
typedef interface IAccessibleObject IAccessibleObject;
#endif 	/* __IAccessibleObject_FWD_DEFINED__ */


#ifndef __IResultsFolder_FWD_DEFINED__
#define __IResultsFolder_FWD_DEFINED__
typedef interface IResultsFolder IResultsFolder;
#endif 	/* __IResultsFolder_FWD_DEFINED__ */


#ifndef __IEnumObjects_FWD_DEFINED__
#define __IEnumObjects_FWD_DEFINED__
typedef interface IEnumObjects IEnumObjects;
#endif 	/* __IEnumObjects_FWD_DEFINED__ */


#ifndef __IOperationsProgressDialog_FWD_DEFINED__
#define __IOperationsProgressDialog_FWD_DEFINED__
typedef interface IOperationsProgressDialog IOperationsProgressDialog;
#endif 	/* __IOperationsProgressDialog_FWD_DEFINED__ */


#ifndef __IIOCancelInformation_FWD_DEFINED__
#define __IIOCancelInformation_FWD_DEFINED__
typedef interface IIOCancelInformation IIOCancelInformation;
#endif 	/* __IIOCancelInformation_FWD_DEFINED__ */


#ifndef __IFileOperation_FWD_DEFINED__
#define __IFileOperation_FWD_DEFINED__
typedef interface IFileOperation IFileOperation;
#endif 	/* __IFileOperation_FWD_DEFINED__ */


#ifndef __IObjectProvider_FWD_DEFINED__
#define __IObjectProvider_FWD_DEFINED__
typedef interface IObjectProvider IObjectProvider;
#endif 	/* __IObjectProvider_FWD_DEFINED__ */


#ifndef __INamespaceWalkCB_FWD_DEFINED__
#define __INamespaceWalkCB_FWD_DEFINED__
typedef interface INamespaceWalkCB INamespaceWalkCB;
#endif 	/* __INamespaceWalkCB_FWD_DEFINED__ */


#ifndef __INamespaceWalkCB2_FWD_DEFINED__
#define __INamespaceWalkCB2_FWD_DEFINED__
typedef interface INamespaceWalkCB2 INamespaceWalkCB2;
#endif 	/* __INamespaceWalkCB2_FWD_DEFINED__ */


#ifndef __INamespaceWalk_FWD_DEFINED__
#define __INamespaceWalk_FWD_DEFINED__
typedef interface INamespaceWalk INamespaceWalk;
#endif 	/* __INamespaceWalk_FWD_DEFINED__ */


#ifndef __IAutoCompleteDropDown_FWD_DEFINED__
#define __IAutoCompleteDropDown_FWD_DEFINED__
typedef interface IAutoCompleteDropDown IAutoCompleteDropDown;
#endif 	/* __IAutoCompleteDropDown_FWD_DEFINED__ */


#ifndef __IBandSite_FWD_DEFINED__
#define __IBandSite_FWD_DEFINED__
typedef interface IBandSite IBandSite;
#endif 	/* __IBandSite_FWD_DEFINED__ */


#ifndef __IModalWindow_FWD_DEFINED__
#define __IModalWindow_FWD_DEFINED__
typedef interface IModalWindow IModalWindow;
#endif 	/* __IModalWindow_FWD_DEFINED__ */


#ifndef __ICDBurnExt_FWD_DEFINED__
#define __ICDBurnExt_FWD_DEFINED__
typedef interface ICDBurnExt ICDBurnExt;
#endif 	/* __ICDBurnExt_FWD_DEFINED__ */


#ifndef __IContextMenuSite_FWD_DEFINED__
#define __IContextMenuSite_FWD_DEFINED__
typedef interface IContextMenuSite IContextMenuSite;
#endif 	/* __IContextMenuSite_FWD_DEFINED__ */


#ifndef __IEnumReadyCallback_FWD_DEFINED__
#define __IEnumReadyCallback_FWD_DEFINED__
typedef interface IEnumReadyCallback IEnumReadyCallback;
#endif 	/* __IEnumReadyCallback_FWD_DEFINED__ */


#ifndef __IEnumerableView_FWD_DEFINED__
#define __IEnumerableView_FWD_DEFINED__
typedef interface IEnumerableView IEnumerableView;
#endif 	/* __IEnumerableView_FWD_DEFINED__ */


#ifndef __IInsertItem_FWD_DEFINED__
#define __IInsertItem_FWD_DEFINED__
typedef interface IInsertItem IInsertItem;
#endif 	/* __IInsertItem_FWD_DEFINED__ */


#ifndef __IMenuBand_FWD_DEFINED__
#define __IMenuBand_FWD_DEFINED__
typedef interface IMenuBand IMenuBand;
#endif 	/* __IMenuBand_FWD_DEFINED__ */


#ifndef __IFolderBandPriv_FWD_DEFINED__
#define __IFolderBandPriv_FWD_DEFINED__
typedef interface IFolderBandPriv IFolderBandPriv;
#endif 	/* __IFolderBandPriv_FWD_DEFINED__ */


#ifndef __IRegTreeItem_FWD_DEFINED__
#define __IRegTreeItem_FWD_DEFINED__
typedef interface IRegTreeItem IRegTreeItem;
#endif 	/* __IRegTreeItem_FWD_DEFINED__ */


#ifndef __IImageRecompress_FWD_DEFINED__
#define __IImageRecompress_FWD_DEFINED__
typedef interface IImageRecompress IImageRecompress;
#endif 	/* __IImageRecompress_FWD_DEFINED__ */


#ifndef __IDeskBar_FWD_DEFINED__
#define __IDeskBar_FWD_DEFINED__
typedef interface IDeskBar IDeskBar;
#endif 	/* __IDeskBar_FWD_DEFINED__ */


#ifndef __IMenuPopup_FWD_DEFINED__
#define __IMenuPopup_FWD_DEFINED__
typedef interface IMenuPopup IMenuPopup;
#endif 	/* __IMenuPopup_FWD_DEFINED__ */


#ifndef __IFileIsInUse_FWD_DEFINED__
#define __IFileIsInUse_FWD_DEFINED__
typedef interface IFileIsInUse IFileIsInUse;
#endif 	/* __IFileIsInUse_FWD_DEFINED__ */


#ifndef __IFileDialogEvents_FWD_DEFINED__
#define __IFileDialogEvents_FWD_DEFINED__
typedef interface IFileDialogEvents IFileDialogEvents;
#endif 	/* __IFileDialogEvents_FWD_DEFINED__ */


#ifndef __IFileDialog_FWD_DEFINED__
#define __IFileDialog_FWD_DEFINED__
typedef interface IFileDialog IFileDialog;
#endif 	/* __IFileDialog_FWD_DEFINED__ */


#ifndef __IFileSaveDialog_FWD_DEFINED__
#define __IFileSaveDialog_FWD_DEFINED__
typedef interface IFileSaveDialog IFileSaveDialog;
#endif 	/* __IFileSaveDialog_FWD_DEFINED__ */


#ifndef __IFileOpenDialog_FWD_DEFINED__
#define __IFileOpenDialog_FWD_DEFINED__
typedef interface IFileOpenDialog IFileOpenDialog;
#endif 	/* __IFileOpenDialog_FWD_DEFINED__ */


#ifndef __IFileDialogCustomize_FWD_DEFINED__
#define __IFileDialogCustomize_FWD_DEFINED__
typedef interface IFileDialogCustomize IFileDialogCustomize;
#endif 	/* __IFileDialogCustomize_FWD_DEFINED__ */


#ifndef __IFileDialogControlEvents_FWD_DEFINED__
#define __IFileDialogControlEvents_FWD_DEFINED__
typedef interface IFileDialogControlEvents IFileDialogControlEvents;
#endif 	/* __IFileDialogControlEvents_FWD_DEFINED__ */


#ifndef __IFileDialog2_FWD_DEFINED__
#define __IFileDialog2_FWD_DEFINED__
typedef interface IFileDialog2 IFileDialog2;
#endif 	/* __IFileDialog2_FWD_DEFINED__ */


#ifndef __IApplicationAssociationRegistration_FWD_DEFINED__
#define __IApplicationAssociationRegistration_FWD_DEFINED__
typedef interface IApplicationAssociationRegistration IApplicationAssociationRegistration;
#endif 	/* __IApplicationAssociationRegistration_FWD_DEFINED__ */


#ifndef __IApplicationAssociationRegistrationUI_FWD_DEFINED__
#define __IApplicationAssociationRegistrationUI_FWD_DEFINED__
typedef interface IApplicationAssociationRegistrationUI IApplicationAssociationRegistrationUI;
#endif 	/* __IApplicationAssociationRegistrationUI_FWD_DEFINED__ */


#ifndef __IDelegateFolder_FWD_DEFINED__
#define __IDelegateFolder_FWD_DEFINED__
typedef interface IDelegateFolder IDelegateFolder;
#endif 	/* __IDelegateFolder_FWD_DEFINED__ */


#ifndef __IBrowserFrameOptions_FWD_DEFINED__
#define __IBrowserFrameOptions_FWD_DEFINED__
typedef interface IBrowserFrameOptions IBrowserFrameOptions;
#endif 	/* __IBrowserFrameOptions_FWD_DEFINED__ */


#ifndef __INewWindowManager_FWD_DEFINED__
#define __INewWindowManager_FWD_DEFINED__
typedef interface INewWindowManager INewWindowManager;
#endif 	/* __INewWindowManager_FWD_DEFINED__ */


#ifndef __IAttachmentExecute_FWD_DEFINED__
#define __IAttachmentExecute_FWD_DEFINED__
typedef interface IAttachmentExecute IAttachmentExecute;
#endif 	/* __IAttachmentExecute_FWD_DEFINED__ */


#ifndef __IShellMenuCallback_FWD_DEFINED__
#define __IShellMenuCallback_FWD_DEFINED__
typedef interface IShellMenuCallback IShellMenuCallback;
#endif 	/* __IShellMenuCallback_FWD_DEFINED__ */


#ifndef __IShellMenu_FWD_DEFINED__
#define __IShellMenu_FWD_DEFINED__
typedef interface IShellMenu IShellMenu;
#endif 	/* __IShellMenu_FWD_DEFINED__ */


#ifndef __IShellRunDll_FWD_DEFINED__
#define __IShellRunDll_FWD_DEFINED__
typedef interface IShellRunDll IShellRunDll;
#endif 	/* __IShellRunDll_FWD_DEFINED__ */


#ifndef __IKnownFolder_FWD_DEFINED__
#define __IKnownFolder_FWD_DEFINED__
typedef interface IKnownFolder IKnownFolder;
#endif 	/* __IKnownFolder_FWD_DEFINED__ */


#ifndef __IKnownFolderManager_FWD_DEFINED__
#define __IKnownFolderManager_FWD_DEFINED__
typedef interface IKnownFolderManager IKnownFolderManager;
#endif 	/* __IKnownFolderManager_FWD_DEFINED__ */


#ifndef __ISharingConfigurationManager_FWD_DEFINED__
#define __ISharingConfigurationManager_FWD_DEFINED__
typedef interface ISharingConfigurationManager ISharingConfigurationManager;
#endif 	/* __ISharingConfigurationManager_FWD_DEFINED__ */


#ifndef __IPreviousVersionsInfo_FWD_DEFINED__
#define __IPreviousVersionsInfo_FWD_DEFINED__
typedef interface IPreviousVersionsInfo IPreviousVersionsInfo;
#endif 	/* __IPreviousVersionsInfo_FWD_DEFINED__ */


#ifndef __IRelatedItem_FWD_DEFINED__
#define __IRelatedItem_FWD_DEFINED__
typedef interface IRelatedItem IRelatedItem;
#endif 	/* __IRelatedItem_FWD_DEFINED__ */


#ifndef __IIdentityName_FWD_DEFINED__
#define __IIdentityName_FWD_DEFINED__
typedef interface IIdentityName IIdentityName;
#endif 	/* __IIdentityName_FWD_DEFINED__ */


#ifndef __IDelegateItem_FWD_DEFINED__
#define __IDelegateItem_FWD_DEFINED__
typedef interface IDelegateItem IDelegateItem;
#endif 	/* __IDelegateItem_FWD_DEFINED__ */


#ifndef __ICurrentItem_FWD_DEFINED__
#define __ICurrentItem_FWD_DEFINED__
typedef interface ICurrentItem ICurrentItem;
#endif 	/* __ICurrentItem_FWD_DEFINED__ */


#ifndef __ITransferMediumItem_FWD_DEFINED__
#define __ITransferMediumItem_FWD_DEFINED__
typedef interface ITransferMediumItem ITransferMediumItem;
#endif 	/* __ITransferMediumItem_FWD_DEFINED__ */


#ifndef __IUseToBrowseItem_FWD_DEFINED__
#define __IUseToBrowseItem_FWD_DEFINED__
typedef interface IUseToBrowseItem IUseToBrowseItem;
#endif 	/* __IUseToBrowseItem_FWD_DEFINED__ */


#ifndef __IDisplayItem_FWD_DEFINED__
#define __IDisplayItem_FWD_DEFINED__
typedef interface IDisplayItem IDisplayItem;
#endif 	/* __IDisplayItem_FWD_DEFINED__ */


#ifndef __IViewStateIdentityItem_FWD_DEFINED__
#define __IViewStateIdentityItem_FWD_DEFINED__
typedef interface IViewStateIdentityItem IViewStateIdentityItem;
#endif 	/* __IViewStateIdentityItem_FWD_DEFINED__ */


#ifndef __IPreviewItem_FWD_DEFINED__
#define __IPreviewItem_FWD_DEFINED__
typedef interface IPreviewItem IPreviewItem;
#endif 	/* __IPreviewItem_FWD_DEFINED__ */


#ifndef __IDestinationStreamFactory_FWD_DEFINED__
#define __IDestinationStreamFactory_FWD_DEFINED__
typedef interface IDestinationStreamFactory IDestinationStreamFactory;
#endif 	/* __IDestinationStreamFactory_FWD_DEFINED__ */


#ifndef __INewMenuClient_FWD_DEFINED__
#define __INewMenuClient_FWD_DEFINED__
typedef interface INewMenuClient INewMenuClient;
#endif 	/* __INewMenuClient_FWD_DEFINED__ */


#ifndef __IInitializeWithBindCtx_FWD_DEFINED__
#define __IInitializeWithBindCtx_FWD_DEFINED__
typedef interface IInitializeWithBindCtx IInitializeWithBindCtx;
#endif 	/* __IInitializeWithBindCtx_FWD_DEFINED__ */


#ifndef __IShellItemFilter_FWD_DEFINED__
#define __IShellItemFilter_FWD_DEFINED__
typedef interface IShellItemFilter IShellItemFilter;
#endif 	/* __IShellItemFilter_FWD_DEFINED__ */


#ifndef __INameSpaceTreeControl_FWD_DEFINED__
#define __INameSpaceTreeControl_FWD_DEFINED__
typedef interface INameSpaceTreeControl INameSpaceTreeControl;
#endif 	/* __INameSpaceTreeControl_FWD_DEFINED__ */


#ifndef __INameSpaceTreeControl2_FWD_DEFINED__
#define __INameSpaceTreeControl2_FWD_DEFINED__
typedef interface INameSpaceTreeControl2 INameSpaceTreeControl2;
#endif 	/* __INameSpaceTreeControl2_FWD_DEFINED__ */


#ifndef __INameSpaceTreeControlEvents_FWD_DEFINED__
#define __INameSpaceTreeControlEvents_FWD_DEFINED__
typedef interface INameSpaceTreeControlEvents INameSpaceTreeControlEvents;
#endif 	/* __INameSpaceTreeControlEvents_FWD_DEFINED__ */


#ifndef __INameSpaceTreeControlDropHandler_FWD_DEFINED__
#define __INameSpaceTreeControlDropHandler_FWD_DEFINED__
typedef interface INameSpaceTreeControlDropHandler INameSpaceTreeControlDropHandler;
#endif 	/* __INameSpaceTreeControlDropHandler_FWD_DEFINED__ */


#ifndef __INameSpaceTreeAccessible_FWD_DEFINED__
#define __INameSpaceTreeAccessible_FWD_DEFINED__
typedef interface INameSpaceTreeAccessible INameSpaceTreeAccessible;
#endif 	/* __INameSpaceTreeAccessible_FWD_DEFINED__ */


#ifndef __INameSpaceTreeControlCustomDraw_FWD_DEFINED__
#define __INameSpaceTreeControlCustomDraw_FWD_DEFINED__
typedef interface INameSpaceTreeControlCustomDraw INameSpaceTreeControlCustomDraw;
#endif 	/* __INameSpaceTreeControlCustomDraw_FWD_DEFINED__ */


#ifndef __INameSpaceTreeControlFolderCapabilities_FWD_DEFINED__
#define __INameSpaceTreeControlFolderCapabilities_FWD_DEFINED__
typedef interface INameSpaceTreeControlFolderCapabilities INameSpaceTreeControlFolderCapabilities;
#endif 	/* __INameSpaceTreeControlFolderCapabilities_FWD_DEFINED__ */


#ifndef __IPreviewHandler_FWD_DEFINED__
#define __IPreviewHandler_FWD_DEFINED__
typedef interface IPreviewHandler IPreviewHandler;
#endif 	/* __IPreviewHandler_FWD_DEFINED__ */


#ifndef __IPreviewHandlerFrame_FWD_DEFINED__
#define __IPreviewHandlerFrame_FWD_DEFINED__
typedef interface IPreviewHandlerFrame IPreviewHandlerFrame;
#endif 	/* __IPreviewHandlerFrame_FWD_DEFINED__ */


#ifndef __ITrayDeskBand_FWD_DEFINED__
#define __ITrayDeskBand_FWD_DEFINED__
typedef interface ITrayDeskBand ITrayDeskBand;
#endif 	/* __ITrayDeskBand_FWD_DEFINED__ */


#ifndef __IBandHost_FWD_DEFINED__
#define __IBandHost_FWD_DEFINED__
typedef interface IBandHost IBandHost;
#endif 	/* __IBandHost_FWD_DEFINED__ */


#ifndef __IExplorerPaneVisibility_FWD_DEFINED__
#define __IExplorerPaneVisibility_FWD_DEFINED__
typedef interface IExplorerPaneVisibility IExplorerPaneVisibility;
#endif 	/* __IExplorerPaneVisibility_FWD_DEFINED__ */


#ifndef __IContextMenuCB_FWD_DEFINED__
#define __IContextMenuCB_FWD_DEFINED__
typedef interface IContextMenuCB IContextMenuCB;
#endif 	/* __IContextMenuCB_FWD_DEFINED__ */


#ifndef __IDefaultExtractIconInit_FWD_DEFINED__
#define __IDefaultExtractIconInit_FWD_DEFINED__
typedef interface IDefaultExtractIconInit IDefaultExtractIconInit;
#endif 	/* __IDefaultExtractIconInit_FWD_DEFINED__ */


#ifndef __IExplorerCommand_FWD_DEFINED__
#define __IExplorerCommand_FWD_DEFINED__
typedef interface IExplorerCommand IExplorerCommand;
#endif 	/* __IExplorerCommand_FWD_DEFINED__ */


#ifndef __IExplorerCommandState_FWD_DEFINED__
#define __IExplorerCommandState_FWD_DEFINED__
typedef interface IExplorerCommandState IExplorerCommandState;
#endif 	/* __IExplorerCommandState_FWD_DEFINED__ */


#ifndef __IInitializeCommand_FWD_DEFINED__
#define __IInitializeCommand_FWD_DEFINED__
typedef interface IInitializeCommand IInitializeCommand;
#endif 	/* __IInitializeCommand_FWD_DEFINED__ */


#ifndef __IEnumExplorerCommand_FWD_DEFINED__
#define __IEnumExplorerCommand_FWD_DEFINED__
typedef interface IEnumExplorerCommand IEnumExplorerCommand;
#endif 	/* __IEnumExplorerCommand_FWD_DEFINED__ */


#ifndef __IExplorerCommandProvider_FWD_DEFINED__
#define __IExplorerCommandProvider_FWD_DEFINED__
typedef interface IExplorerCommandProvider IExplorerCommandProvider;
#endif 	/* __IExplorerCommandProvider_FWD_DEFINED__ */


#ifndef __IMarkupCallback_FWD_DEFINED__
#define __IMarkupCallback_FWD_DEFINED__
typedef interface IMarkupCallback IMarkupCallback;
#endif 	/* __IMarkupCallback_FWD_DEFINED__ */


#ifndef __IControlMarkup_FWD_DEFINED__
#define __IControlMarkup_FWD_DEFINED__
typedef interface IControlMarkup IControlMarkup;
#endif 	/* __IControlMarkup_FWD_DEFINED__ */


#ifndef __IInitializeNetworkFolder_FWD_DEFINED__
#define __IInitializeNetworkFolder_FWD_DEFINED__
typedef interface IInitializeNetworkFolder IInitializeNetworkFolder;
#endif 	/* __IInitializeNetworkFolder_FWD_DEFINED__ */


#ifndef __IOpenControlPanel_FWD_DEFINED__
#define __IOpenControlPanel_FWD_DEFINED__
typedef interface IOpenControlPanel IOpenControlPanel;
#endif 	/* __IOpenControlPanel_FWD_DEFINED__ */


#ifndef __IComputerInfoChangeNotify_FWD_DEFINED__
#define __IComputerInfoChangeNotify_FWD_DEFINED__
typedef interface IComputerInfoChangeNotify IComputerInfoChangeNotify;
#endif 	/* __IComputerInfoChangeNotify_FWD_DEFINED__ */


#ifndef __IFileSystemBindData_FWD_DEFINED__
#define __IFileSystemBindData_FWD_DEFINED__
typedef interface IFileSystemBindData IFileSystemBindData;
#endif 	/* __IFileSystemBindData_FWD_DEFINED__ */


#ifndef __IFileSystemBindData2_FWD_DEFINED__
#define __IFileSystemBindData2_FWD_DEFINED__
typedef interface IFileSystemBindData2 IFileSystemBindData2;
#endif 	/* __IFileSystemBindData2_FWD_DEFINED__ */


#ifndef __ICustomDestinationList_FWD_DEFINED__
#define __ICustomDestinationList_FWD_DEFINED__
typedef interface ICustomDestinationList ICustomDestinationList;
#endif 	/* __ICustomDestinationList_FWD_DEFINED__ */


#ifndef __IApplicationDestinations_FWD_DEFINED__
#define __IApplicationDestinations_FWD_DEFINED__
typedef interface IApplicationDestinations IApplicationDestinations;
#endif 	/* __IApplicationDestinations_FWD_DEFINED__ */


#ifndef __IApplicationDocumentLists_FWD_DEFINED__
#define __IApplicationDocumentLists_FWD_DEFINED__
typedef interface IApplicationDocumentLists IApplicationDocumentLists;
#endif 	/* __IApplicationDocumentLists_FWD_DEFINED__ */


#ifndef __IObjectWithAppUserModelID_FWD_DEFINED__
#define __IObjectWithAppUserModelID_FWD_DEFINED__
typedef interface IObjectWithAppUserModelID IObjectWithAppUserModelID;
#endif 	/* __IObjectWithAppUserModelID_FWD_DEFINED__ */


#ifndef __IObjectWithProgID_FWD_DEFINED__
#define __IObjectWithProgID_FWD_DEFINED__
typedef interface IObjectWithProgID IObjectWithProgID;
#endif 	/* __IObjectWithProgID_FWD_DEFINED__ */


#ifndef __IUpdateIDList_FWD_DEFINED__
#define __IUpdateIDList_FWD_DEFINED__
typedef interface IUpdateIDList IUpdateIDList;
#endif 	/* __IUpdateIDList_FWD_DEFINED__ */


#ifndef __IDesktopGadget_FWD_DEFINED__
#define __IDesktopGadget_FWD_DEFINED__
typedef interface IDesktopGadget IDesktopGadget;
#endif 	/* __IDesktopGadget_FWD_DEFINED__ */


#ifndef __IHomeGroup_FWD_DEFINED__
#define __IHomeGroup_FWD_DEFINED__
typedef interface IHomeGroup IHomeGroup;
#endif 	/* __IHomeGroup_FWD_DEFINED__ */


#ifndef __IInitializeWithPropertyStore_FWD_DEFINED__
#define __IInitializeWithPropertyStore_FWD_DEFINED__
typedef interface IInitializeWithPropertyStore IInitializeWithPropertyStore;
#endif 	/* __IInitializeWithPropertyStore_FWD_DEFINED__ */


#ifndef __IOpenSearchSource_FWD_DEFINED__
#define __IOpenSearchSource_FWD_DEFINED__
typedef interface IOpenSearchSource IOpenSearchSource;
#endif 	/* __IOpenSearchSource_FWD_DEFINED__ */


#ifndef __IShellLibrary_FWD_DEFINED__
#define __IShellLibrary_FWD_DEFINED__
typedef interface IShellLibrary IShellLibrary;
#endif 	/* __IShellLibrary_FWD_DEFINED__ */


#ifndef __ShellDesktop_FWD_DEFINED__
#define __ShellDesktop_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellDesktop ShellDesktop;
#else
typedef struct ShellDesktop ShellDesktop;
#endif /* __cplusplus */

#endif 	/* __ShellDesktop_FWD_DEFINED__ */


#ifndef __ShellFSFolder_FWD_DEFINED__
#define __ShellFSFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFSFolder ShellFSFolder;
#else
typedef struct ShellFSFolder ShellFSFolder;
#endif /* __cplusplus */

#endif 	/* __ShellFSFolder_FWD_DEFINED__ */


#ifndef __NetworkPlaces_FWD_DEFINED__
#define __NetworkPlaces_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetworkPlaces NetworkPlaces;
#else
typedef struct NetworkPlaces NetworkPlaces;
#endif /* __cplusplus */

#endif 	/* __NetworkPlaces_FWD_DEFINED__ */


#ifndef __ShellLink_FWD_DEFINED__
#define __ShellLink_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLink ShellLink;
#else
typedef struct ShellLink ShellLink;
#endif /* __cplusplus */

#endif 	/* __ShellLink_FWD_DEFINED__ */


#ifndef __QueryCancelAutoPlay_FWD_DEFINED__
#define __QueryCancelAutoPlay_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryCancelAutoPlay QueryCancelAutoPlay;
#else
typedef struct QueryCancelAutoPlay QueryCancelAutoPlay;
#endif /* __cplusplus */

#endif 	/* __QueryCancelAutoPlay_FWD_DEFINED__ */


#ifndef __DriveSizeCategorizer_FWD_DEFINED__
#define __DriveSizeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DriveSizeCategorizer DriveSizeCategorizer;
#else
typedef struct DriveSizeCategorizer DriveSizeCategorizer;
#endif /* __cplusplus */

#endif 	/* __DriveSizeCategorizer_FWD_DEFINED__ */


#ifndef __DriveTypeCategorizer_FWD_DEFINED__
#define __DriveTypeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DriveTypeCategorizer DriveTypeCategorizer;
#else
typedef struct DriveTypeCategorizer DriveTypeCategorizer;
#endif /* __cplusplus */

#endif 	/* __DriveTypeCategorizer_FWD_DEFINED__ */


#ifndef __FreeSpaceCategorizer_FWD_DEFINED__
#define __FreeSpaceCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeSpaceCategorizer FreeSpaceCategorizer;
#else
typedef struct FreeSpaceCategorizer FreeSpaceCategorizer;
#endif /* __cplusplus */

#endif 	/* __FreeSpaceCategorizer_FWD_DEFINED__ */


#ifndef __TimeCategorizer_FWD_DEFINED__
#define __TimeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeCategorizer TimeCategorizer;
#else
typedef struct TimeCategorizer TimeCategorizer;
#endif /* __cplusplus */

#endif 	/* __TimeCategorizer_FWD_DEFINED__ */


#ifndef __SizeCategorizer_FWD_DEFINED__
#define __SizeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SizeCategorizer SizeCategorizer;
#else
typedef struct SizeCategorizer SizeCategorizer;
#endif /* __cplusplus */

#endif 	/* __SizeCategorizer_FWD_DEFINED__ */


#ifndef __AlphabeticalCategorizer_FWD_DEFINED__
#define __AlphabeticalCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class AlphabeticalCategorizer AlphabeticalCategorizer;
#else
typedef struct AlphabeticalCategorizer AlphabeticalCategorizer;
#endif /* __cplusplus */

#endif 	/* __AlphabeticalCategorizer_FWD_DEFINED__ */


#ifndef __MergedCategorizer_FWD_DEFINED__
#define __MergedCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class MergedCategorizer MergedCategorizer;
#else
typedef struct MergedCategorizer MergedCategorizer;
#endif /* __cplusplus */

#endif 	/* __MergedCategorizer_FWD_DEFINED__ */


#ifndef __ImageProperties_FWD_DEFINED__
#define __ImageProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageProperties ImageProperties;
#else
typedef struct ImageProperties ImageProperties;
#endif /* __cplusplus */

#endif 	/* __ImageProperties_FWD_DEFINED__ */


#ifndef __PropertiesUI_FWD_DEFINED__
#define __PropertiesUI_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertiesUI PropertiesUI;
#else
typedef struct PropertiesUI PropertiesUI;
#endif /* __cplusplus */

#endif 	/* __PropertiesUI_FWD_DEFINED__ */


#ifndef __UserNotification_FWD_DEFINED__
#define __UserNotification_FWD_DEFINED__

#ifdef __cplusplus
typedef class UserNotification UserNotification;
#else
typedef struct UserNotification UserNotification;
#endif /* __cplusplus */

#endif 	/* __UserNotification_FWD_DEFINED__ */


#ifndef __CDBurn_FWD_DEFINED__
#define __CDBurn_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDBurn CDBurn;
#else
typedef struct CDBurn CDBurn;
#endif /* __cplusplus */

#endif 	/* __CDBurn_FWD_DEFINED__ */


#ifndef __TaskbarList_FWD_DEFINED__
#define __TaskbarList_FWD_DEFINED__

#ifdef __cplusplus
typedef class TaskbarList TaskbarList;
#else
typedef struct TaskbarList TaskbarList;
#endif /* __cplusplus */

#endif 	/* __TaskbarList_FWD_DEFINED__ */


#ifndef __StartMenuPin_FWD_DEFINED__
#define __StartMenuPin_FWD_DEFINED__

#ifdef __cplusplus
typedef class StartMenuPin StartMenuPin;
#else
typedef struct StartMenuPin StartMenuPin;
#endif /* __cplusplus */

#endif 	/* __StartMenuPin_FWD_DEFINED__ */


#ifndef __WebWizardHost_FWD_DEFINED__
#define __WebWizardHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebWizardHost WebWizardHost;
#else
typedef struct WebWizardHost WebWizardHost;
#endif /* __cplusplus */

#endif 	/* __WebWizardHost_FWD_DEFINED__ */


#ifndef __PublishDropTarget_FWD_DEFINED__
#define __PublishDropTarget_FWD_DEFINED__

#ifdef __cplusplus
typedef class PublishDropTarget PublishDropTarget;
#else
typedef struct PublishDropTarget PublishDropTarget;
#endif /* __cplusplus */

#endif 	/* __PublishDropTarget_FWD_DEFINED__ */


#ifndef __PublishingWizard_FWD_DEFINED__
#define __PublishingWizard_FWD_DEFINED__

#ifdef __cplusplus
typedef class PublishingWizard PublishingWizard;
#else
typedef struct PublishingWizard PublishingWizard;
#endif /* __cplusplus */

#endif 	/* __PublishingWizard_FWD_DEFINED__ */


#ifndef __InternetPrintOrdering_FWD_DEFINED__
#define __InternetPrintOrdering_FWD_DEFINED__

#ifdef __cplusplus
typedef class InternetPrintOrdering InternetPrintOrdering;
#else
typedef struct InternetPrintOrdering InternetPrintOrdering;
#endif /* __cplusplus */

#endif 	/* __InternetPrintOrdering_FWD_DEFINED__ */


#ifndef __FolderViewHost_FWD_DEFINED__
#define __FolderViewHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class FolderViewHost FolderViewHost;
#else
typedef struct FolderViewHost FolderViewHost;
#endif /* __cplusplus */

#endif 	/* __FolderViewHost_FWD_DEFINED__ */


#ifndef __ExplorerBrowser_FWD_DEFINED__
#define __ExplorerBrowser_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExplorerBrowser ExplorerBrowser;
#else
typedef struct ExplorerBrowser ExplorerBrowser;
#endif /* __cplusplus */

#endif 	/* __ExplorerBrowser_FWD_DEFINED__ */


#ifndef __ImageRecompress_FWD_DEFINED__
#define __ImageRecompress_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageRecompress ImageRecompress;
#else
typedef struct ImageRecompress ImageRecompress;
#endif /* __cplusplus */

#endif 	/* __ImageRecompress_FWD_DEFINED__ */


#ifndef __TrayBandSiteService_FWD_DEFINED__
#define __TrayBandSiteService_FWD_DEFINED__

#ifdef __cplusplus
typedef class TrayBandSiteService TrayBandSiteService;
#else
typedef struct TrayBandSiteService TrayBandSiteService;
#endif /* __cplusplus */

#endif 	/* __TrayBandSiteService_FWD_DEFINED__ */


#ifndef __TrayDeskBand_FWD_DEFINED__
#define __TrayDeskBand_FWD_DEFINED__

#ifdef __cplusplus
typedef class TrayDeskBand TrayDeskBand;
#else
typedef struct TrayDeskBand TrayDeskBand;
#endif /* __cplusplus */

#endif 	/* __TrayDeskBand_FWD_DEFINED__ */


#ifndef __AttachmentServices_FWD_DEFINED__
#define __AttachmentServices_FWD_DEFINED__

#ifdef __cplusplus
typedef class AttachmentServices AttachmentServices;
#else
typedef struct AttachmentServices AttachmentServices;
#endif /* __cplusplus */

#endif 	/* __AttachmentServices_FWD_DEFINED__ */


#ifndef __DocPropShellExtension_FWD_DEFINED__
#define __DocPropShellExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class DocPropShellExtension DocPropShellExtension;
#else
typedef struct DocPropShellExtension DocPropShellExtension;
#endif /* __cplusplus */

#endif 	/* __DocPropShellExtension_FWD_DEFINED__ */


#ifndef __ShellItem_FWD_DEFINED__
#define __ShellItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellItem ShellItem;
#else
typedef struct ShellItem ShellItem;
#endif /* __cplusplus */

#endif 	/* __ShellItem_FWD_DEFINED__ */


#ifndef __NamespaceWalker_FWD_DEFINED__
#define __NamespaceWalker_FWD_DEFINED__

#ifdef __cplusplus
typedef class NamespaceWalker NamespaceWalker;
#else
typedef struct NamespaceWalker NamespaceWalker;
#endif /* __cplusplus */

#endif 	/* __NamespaceWalker_FWD_DEFINED__ */


#ifndef __FileOperation_FWD_DEFINED__
#define __FileOperation_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileOperation FileOperation;
#else
typedef struct FileOperation FileOperation;
#endif /* __cplusplus */

#endif 	/* __FileOperation_FWD_DEFINED__ */


#ifndef __FileOpenDialog_FWD_DEFINED__
#define __FileOpenDialog_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileOpenDialog FileOpenDialog;
#else
typedef struct FileOpenDialog FileOpenDialog;
#endif /* __cplusplus */

#endif 	/* __FileOpenDialog_FWD_DEFINED__ */


#ifndef __FileSaveDialog_FWD_DEFINED__
#define __FileSaveDialog_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileSaveDialog FileSaveDialog;
#else
typedef struct FileSaveDialog FileSaveDialog;
#endif /* __cplusplus */

#endif 	/* __FileSaveDialog_FWD_DEFINED__ */


#ifndef __KnownFolderManager_FWD_DEFINED__
#define __KnownFolderManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class KnownFolderManager KnownFolderManager;
#else
typedef struct KnownFolderManager KnownFolderManager;
#endif /* __cplusplus */

#endif 	/* __KnownFolderManager_FWD_DEFINED__ */


#ifndef __FSCopyHandler_FWD_DEFINED__
#define __FSCopyHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class FSCopyHandler FSCopyHandler;
#else
typedef struct FSCopyHandler FSCopyHandler;
#endif /* __cplusplus */

#endif 	/* __FSCopyHandler_FWD_DEFINED__ */


#ifndef __SharingConfigurationManager_FWD_DEFINED__
#define __SharingConfigurationManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharingConfigurationManager SharingConfigurationManager;
#else
typedef struct SharingConfigurationManager SharingConfigurationManager;
#endif /* __cplusplus */

#endif 	/* __SharingConfigurationManager_FWD_DEFINED__ */


#ifndef __PreviousVersions_FWD_DEFINED__
#define __PreviousVersions_FWD_DEFINED__

#ifdef __cplusplus
typedef class PreviousVersions PreviousVersions;
#else
typedef struct PreviousVersions PreviousVersions;
#endif /* __cplusplus */

#endif 	/* __PreviousVersions_FWD_DEFINED__ */


#ifndef __NetworkConnections_FWD_DEFINED__
#define __NetworkConnections_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetworkConnections NetworkConnections;
#else
typedef struct NetworkConnections NetworkConnections;
#endif /* __cplusplus */

#endif 	/* __NetworkConnections_FWD_DEFINED__ */


#ifndef __NamespaceTreeControl_FWD_DEFINED__
#define __NamespaceTreeControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class NamespaceTreeControl NamespaceTreeControl;
#else
typedef struct NamespaceTreeControl NamespaceTreeControl;
#endif /* __cplusplus */

#endif 	/* __NamespaceTreeControl_FWD_DEFINED__ */


#ifndef __IENamespaceTreeControl_FWD_DEFINED__
#define __IENamespaceTreeControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class IENamespaceTreeControl IENamespaceTreeControl;
#else
typedef struct IENamespaceTreeControl IENamespaceTreeControl;
#endif /* __cplusplus */

#endif 	/* __IENamespaceTreeControl_FWD_DEFINED__ */


#ifndef __ScheduledTasks_FWD_DEFINED__
#define __ScheduledTasks_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScheduledTasks ScheduledTasks;
#else
typedef struct ScheduledTasks ScheduledTasks;
#endif /* __cplusplus */

#endif 	/* __ScheduledTasks_FWD_DEFINED__ */


#ifndef __ApplicationAssociationRegistration_FWD_DEFINED__
#define __ApplicationAssociationRegistration_FWD_DEFINED__

#ifdef __cplusplus
typedef class ApplicationAssociationRegistration ApplicationAssociationRegistration;
#else
typedef struct ApplicationAssociationRegistration ApplicationAssociationRegistration;
#endif /* __cplusplus */

#endif 	/* __ApplicationAssociationRegistration_FWD_DEFINED__ */


#ifndef __ApplicationAssociationRegistrationUI_FWD_DEFINED__
#define __ApplicationAssociationRegistrationUI_FWD_DEFINED__

#ifdef __cplusplus
typedef class ApplicationAssociationRegistrationUI ApplicationAssociationRegistrationUI;
#else
typedef struct ApplicationAssociationRegistrationUI ApplicationAssociationRegistrationUI;
#endif /* __cplusplus */

#endif 	/* __ApplicationAssociationRegistrationUI_FWD_DEFINED__ */


#ifndef __SearchFolderItemFactory_FWD_DEFINED__
#define __SearchFolderItemFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class SearchFolderItemFactory SearchFolderItemFactory;
#else
typedef struct SearchFolderItemFactory SearchFolderItemFactory;
#endif /* __cplusplus */

#endif 	/* __SearchFolderItemFactory_FWD_DEFINED__ */


#ifndef __OpenControlPanel_FWD_DEFINED__
#define __OpenControlPanel_FWD_DEFINED__

#ifdef __cplusplus
typedef class OpenControlPanel OpenControlPanel;
#else
typedef struct OpenControlPanel OpenControlPanel;
#endif /* __cplusplus */

#endif 	/* __OpenControlPanel_FWD_DEFINED__ */


#ifndef __MailRecipient_FWD_DEFINED__
#define __MailRecipient_FWD_DEFINED__

#ifdef __cplusplus
typedef class MailRecipient MailRecipient;
#else
typedef struct MailRecipient MailRecipient;
#endif /* __cplusplus */

#endif 	/* __MailRecipient_FWD_DEFINED__ */


#ifndef __NetworkExplorerFolder_FWD_DEFINED__
#define __NetworkExplorerFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetworkExplorerFolder NetworkExplorerFolder;
#else
typedef struct NetworkExplorerFolder NetworkExplorerFolder;
#endif /* __cplusplus */

#endif 	/* __NetworkExplorerFolder_FWD_DEFINED__ */


#ifndef __DestinationList_FWD_DEFINED__
#define __DestinationList_FWD_DEFINED__

#ifdef __cplusplus
typedef class DestinationList DestinationList;
#else
typedef struct DestinationList DestinationList;
#endif /* __cplusplus */

#endif 	/* __DestinationList_FWD_DEFINED__ */


#ifndef __ApplicationDestinations_FWD_DEFINED__
#define __ApplicationDestinations_FWD_DEFINED__

#ifdef __cplusplus
typedef class ApplicationDestinations ApplicationDestinations;
#else
typedef struct ApplicationDestinations ApplicationDestinations;
#endif /* __cplusplus */

#endif 	/* __ApplicationDestinations_FWD_DEFINED__ */


#ifndef __ApplicationDocumentLists_FWD_DEFINED__
#define __ApplicationDocumentLists_FWD_DEFINED__

#ifdef __cplusplus
typedef class ApplicationDocumentLists ApplicationDocumentLists;
#else
typedef struct ApplicationDocumentLists ApplicationDocumentLists;
#endif /* __cplusplus */

#endif 	/* __ApplicationDocumentLists_FWD_DEFINED__ */


#ifndef __HomeGroup_FWD_DEFINED__
#define __HomeGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class HomeGroup HomeGroup;
#else
typedef struct HomeGroup HomeGroup;
#endif /* __cplusplus */

#endif 	/* __HomeGroup_FWD_DEFINED__ */


#ifndef __ShellLibrary_FWD_DEFINED__
#define __ShellLibrary_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLibrary ShellLibrary;
#else
typedef struct ShellLibrary ShellLibrary;
#endif /* __cplusplus */

#endif 	/* __ShellLibrary_FWD_DEFINED__ */


#ifndef __AppStartupLink_FWD_DEFINED__
#define __AppStartupLink_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppStartupLink AppStartupLink;
#else
typedef struct AppStartupLink AppStartupLink;
#endif /* __cplusplus */

#endif 	/* __AppStartupLink_FWD_DEFINED__ */


#ifndef __EnumerableObjectCollection_FWD_DEFINED__
#define __EnumerableObjectCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumerableObjectCollection EnumerableObjectCollection;
#else
typedef struct EnumerableObjectCollection EnumerableObjectCollection;
#endif /* __cplusplus */

#endif 	/* __EnumerableObjectCollection_FWD_DEFINED__ */


#ifndef __DesktopGadget_FWD_DEFINED__
#define __DesktopGadget_FWD_DEFINED__

#ifdef __cplusplus
typedef class DesktopGadget DesktopGadget;
#else
typedef struct DesktopGadget DesktopGadget;
#endif /* __cplusplus */

#endif 	/* __DesktopGadget_FWD_DEFINED__ */


#ifndef __IAssocHandlerInvoker_FWD_DEFINED__
#define __IAssocHandlerInvoker_FWD_DEFINED__
typedef interface IAssocHandlerInvoker IAssocHandlerInvoker;
#endif 	/* __IAssocHandlerInvoker_FWD_DEFINED__ */


#ifndef __IAssocHandler_FWD_DEFINED__
#define __IAssocHandler_FWD_DEFINED__
typedef interface IAssocHandler IAssocHandler;
#endif 	/* __IAssocHandler_FWD_DEFINED__ */


#ifndef __IEnumAssocHandlers_FWD_DEFINED__
#define __IEnumAssocHandlers_FWD_DEFINED__
typedef interface IEnumAssocHandlers IEnumAssocHandlers;
#endif 	/* __IEnumAssocHandlers_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "docobj.h"
#include "shtypes.h"
#include "comcat.h"
#include "propidl.h"
#include "prsht.h"
#include "propsys.h"
#include "ObjectArray.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_shobjidl_0000_0000 */
/* [local] */ 

#include <sherrors.h>
#ifndef SHSTDAPI
#if defined(_SHELL32_)
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#else
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDAPI

//===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns S_OK.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the Delete menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//    hMonitor -- Specifies the default monitor (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================

// QueryContextMenu uFlags
#define CMF_NORMAL              0x00000000
#define CMF_DEFAULTONLY         0x00000001
#define CMF_VERBSONLY           0x00000002
#define CMF_EXPLORE             0x00000004
#define CMF_NOVERBS             0x00000008
#define CMF_CANRENAME           0x00000010
#define CMF_NODEFAULT           0x00000020
#if (NTDDI_VERSION < NTDDI_VISTA)
#define CMF_INCLUDESTATIC       0x00000040
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define CMF_ITEMMENU            0x00000080
#endif
#define CMF_EXTENDEDVERBS       0x00000100
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define CMF_DISABLEDVERBS       0x00000200
#endif
#define CMF_ASYNCVERBSTATE      0x00000400
#define CMF_OPTIMIZEFORINVOKE   0x00000800
#define CMF_SYNCCASCADEMENU     0x00001000
#define CMF_DONOTPICKDEFAULT    0x00002000
#define CMF_RESERVED            0xffff0000

// GetCommandString uFlags
#define GCS_VERBA        0x00000000     // canonical verb
#define GCS_HELPTEXTA    0x00000001     // help text (for status bar)
#define GCS_VALIDATEA    0x00000002     // validate command exists
#define GCS_VERBW        0x00000004     // canonical verb (unicode)
#define GCS_HELPTEXTW    0x00000005     // help text (unicode version)
#define GCS_VALIDATEW    0x00000006     // validate command exists (unicode)
#define GCS_VERBICONW    0x00000014     // icon string (unicode)
#define GCS_UNICODE      0x00000004     // for bit testing - Unicode string

#ifdef UNICODE
#define GCS_VERB        GCS_VERBW
#define GCS_HELPTEXT    GCS_HELPTEXTW
#define GCS_VALIDATE    GCS_VALIDATEW
#else
#define GCS_VERB        GCS_VERBA
#define GCS_HELPTEXT    GCS_HELPTEXTA
#define GCS_VALIDATE    GCS_VALIDATEA
#endif

#define CMDSTR_NEWFOLDERA   "NewFolder"
#define CMDSTR_VIEWLISTA    "ViewList"
#define CMDSTR_VIEWDETAILSA "ViewDetails"
#define CMDSTR_NEWFOLDERW   L"NewFolder"
#define CMDSTR_VIEWLISTW    L"ViewList"
#define CMDSTR_VIEWDETAILSW L"ViewDetails"

#ifdef UNICODE
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERW
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTW
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSW
#else
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERA
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTA
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSA
#endif

#define CMIC_MASK_HOTKEY        SEE_MASK_HOTKEY
#define CMIC_MASK_ICON          SEE_MASK_ICON
#define CMIC_MASK_FLAG_NO_UI    SEE_MASK_FLAG_NO_UI
#define CMIC_MASK_UNICODE       SEE_MASK_UNICODE
#define CMIC_MASK_NO_CONSOLE    SEE_MASK_NO_CONSOLE
#if (NTDDI_VERSION < NTDDI_VISTA)
#define CMIC_MASK_HASLINKNAME   SEE_MASK_HASLINKNAME
#define CMIC_MASK_HASTITLE      SEE_MASK_HASTITLE
#endif  // NTDDI_VISTA
#define CMIC_MASK_FLAG_SEP_VDM  SEE_MASK_FLAG_SEPVDM
#define CMIC_MASK_ASYNCOK       SEE_MASK_ASYNCOK
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define CMIC_MASK_NOASYNC       SEE_MASK_NOASYNC
#endif
#if (_WIN32_IE >= _WIN32_IE_IE501)
#define CMIC_MASK_SHIFT_DOWN    0x10000000
#define CMIC_MASK_CONTROL_DOWN  0x40000000
#endif  // _WIN32_IE_IE501
#if (_WIN32_IE >= 0x0560)
#define CMIC_MASK_FLAG_LOG_USAGE SEE_MASK_FLAG_LOG_USAGE
#define CMIC_MASK_NOZONECHECKS  SEE_MASK_NOZONECHECKS
#endif // (_WIN32_IE >= 0x560)

#if (_WIN32_IE >= _WIN32_IE_IE40)
#define CMIC_MASK_PTINVOKE      0x20000000
#endif  // _WIN32_IE_IE40

#include <pshpack8.h>

typedef struct _CMINVOKECOMMANDINFO
    {
    DWORD cbSize;
    DWORD fMask;
    HWND hwnd;
    LPCSTR lpVerb;
    LPCSTR lpParameters;
    LPCSTR lpDirectory;
    int nShow;
    DWORD dwHotKey;
    HANDLE hIcon;
    } 	CMINVOKECOMMANDINFO;

typedef CMINVOKECOMMANDINFO *LPCMINVOKECOMMANDINFO;

typedef const CMINVOKECOMMANDINFO *PCCMINVOKECOMMANDINFO;

#if (_WIN32_IE >= _WIN32_IE_IE40)
typedef struct _CMINVOKECOMMANDINFOEX
    {
    DWORD cbSize;
    DWORD fMask;
    HWND hwnd;
    LPCSTR lpVerb;
    LPCSTR lpParameters;
    LPCSTR lpDirectory;
    int nShow;
    DWORD dwHotKey;
    HANDLE hIcon;
    LPCSTR lpTitle;
    LPCWSTR lpVerbW;
    LPCWSTR lpParametersW;
    LPCWSTR lpDirectoryW;
    LPCWSTR lpTitleW;
    POINT ptInvoke;
    } 	CMINVOKECOMMANDINFOEX;

#else
typedef struct _PRE_IE4_CMINVOKECOMMANDINFOEX
{
    DWORD cbSize;            // must be sizeof(CMINVOKECOMMANDINFOEX)
    DWORD fMask;             // any combination of CMIC_MASK_*
    HWND hwnd;               // might be NULL (indicating no owner window)
    LPCSTR lpVerb;           // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters;     // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;      // might be NULL (indicating no specific directory)
    int nShow;               // one of SW_ values for ShowWindow() API
    DWORD dwHotKey;
    HANDLE hIcon;
    LPCSTR lpTitle;         // For CreateProcess-StartupInfo.lpTitle
    LPCWSTR lpVerbW;        // Unicode verb (for those who can use it)
    LPCWSTR lpParametersW;  // Unicode parameters (for those who can use it)
    LPCWSTR lpDirectoryW;   // Unicode directory (for those who can use it)
    LPCWSTR lpTitleW;       // Unicode title (for those who can use it)
} CMINVOKECOMMANDINFOEX;
#endif   // _WIN32_IE_IE40
typedef CMINVOKECOMMANDINFOEX *LPCMINVOKECOMMANDINFOEX;

typedef const CMINVOKECOMMANDINFOEX *PCCMINVOKECOMMANDINFOEX;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0000_v0_0_s_ifspec;

#ifndef __IContextMenu_INTERFACE_DEFINED__
#define __IContextMenu_INTERFACE_DEFINED__

/* interface IContextMenu */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214e4-0000-0000-c000-000000000046")
    IContextMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContextMenu( 
            /* [annotation][in] */ 
            __in  HMENU hmenu,
            /* [annotation][in] */ 
            __in  UINT indexMenu,
            /* [annotation][in] */ 
            __in  UINT idCmdFirst,
            /* [annotation][in] */ 
            __in  UINT idCmdLast,
            /* [annotation][in] */ 
            __in  UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeCommand( 
            /* [annotation][in] */ 
            __in  CMINVOKECOMMANDINFO *pici) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommandString( 
            /* [annotation][in] */ 
            __in  UINT_PTR idCmd,
            /* [annotation][in] */ 
            __in  UINT uType,
            /* [annotation][in] */ 
            __reserved  UINT *pReserved,
            /* [annotation][out] */ 
            __out_awcount(!(uType & GCS_UNICODE), cchMax)  LPSTR pszName,
            /* [annotation][in] */ 
            __in  UINT cchMax) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMenu * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContextMenu )( 
            IContextMenu * This,
            /* [annotation][in] */ 
            __in  HMENU hmenu,
            /* [annotation][in] */ 
            __in  UINT indexMenu,
            /* [annotation][in] */ 
            __in  UINT idCmdFirst,
            /* [annotation][in] */ 
            __in  UINT idCmdLast,
            /* [annotation][in] */ 
            __in  UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeCommand )( 
            IContextMenu * This,
            /* [annotation][in] */ 
            __in  CMINVOKECOMMANDINFO *pici);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandString )( 
            IContextMenu * This,
            /* [annotation][in] */ 
            __in  UINT_PTR idCmd,
            /* [annotation][in] */ 
            __in  UINT uType,
            /* [annotation][in] */ 
            __reserved  UINT *pReserved,
            /* [annotation][out] */ 
            __out_awcount(!(uType & GCS_UNICODE), cchMax)  LPSTR pszName,
            /* [annotation][in] */ 
            __in  UINT cchMax);
        
        END_INTERFACE
    } IContextMenuVtbl;

    interface IContextMenu
    {
        CONST_VTBL struct IContextMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenu_QueryContextMenu(This,hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags)	\
    ( (This)->lpVtbl -> QueryContextMenu(This,hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags) ) 

#define IContextMenu_InvokeCommand(This,pici)	\
    ( (This)->lpVtbl -> InvokeCommand(This,pici) ) 

#define IContextMenu_GetCommandString(This,idCmd,uType,pReserved,pszName,cchMax)	\
    ( (This)->lpVtbl -> GetCommandString(This,idCmd,uType,pReserved,pszName,cchMax) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0001 */
/* [local] */ 

typedef IContextMenu *LPCONTEXTMENU;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0001_v0_0_s_ifspec;

#ifndef __IContextMenu2_INTERFACE_DEFINED__
#define __IContextMenu2_INTERFACE_DEFINED__

/* interface IContextMenu2 */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IContextMenu2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214f4-0000-0000-c000-000000000046")
    IContextMenu2 : public IContextMenu
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleMenuMsg( 
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenu2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMenu2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMenu2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMenu2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContextMenu )( 
            IContextMenu2 * This,
            /* [annotation][in] */ 
            __in  HMENU hmenu,
            /* [annotation][in] */ 
            __in  UINT indexMenu,
            /* [annotation][in] */ 
            __in  UINT idCmdFirst,
            /* [annotation][in] */ 
            __in  UINT idCmdLast,
            /* [annotation][in] */ 
            __in  UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeCommand )( 
            IContextMenu2 * This,
            /* [annotation][in] */ 
            __in  CMINVOKECOMMANDINFO *pici);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandString )( 
            IContextMenu2 * This,
            /* [annotation][in] */ 
            __in  UINT_PTR idCmd,
            /* [annotation][in] */ 
            __in  UINT uType,
            /* [annotation][in] */ 
            __reserved  UINT *pReserved,
            /* [annotation][out] */ 
            __out_awcount(!(uType & GCS_UNICODE), cchMax)  LPSTR pszName,
            /* [annotation][in] */ 
            __in  UINT cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *HandleMenuMsg )( 
            IContextMenu2 * This,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IContextMenu2Vtbl;

    interface IContextMenu2
    {
        CONST_VTBL struct IContextMenu2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenu2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenu2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenu2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenu2_QueryContextMenu(This,hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags)	\
    ( (This)->lpVtbl -> QueryContextMenu(This,hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags) ) 

#define IContextMenu2_InvokeCommand(This,pici)	\
    ( (This)->lpVtbl -> InvokeCommand(This,pici) ) 

#define IContextMenu2_GetCommandString(This,idCmd,uType,pReserved,pszName,cchMax)	\
    ( (This)->lpVtbl -> GetCommandString(This,idCmd,uType,pReserved,pszName,cchMax) ) 


#define IContextMenu2_HandleMenuMsg(This,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> HandleMenuMsg(This,uMsg,wParam,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenu2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0002 */
/* [local] */ 

typedef IContextMenu2 *LPCONTEXTMENU2;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0002_v0_0_s_ifspec;

#ifndef __IContextMenu3_INTERFACE_DEFINED__
#define __IContextMenu3_INTERFACE_DEFINED__

/* interface IContextMenu3 */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IContextMenu3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCFCE0A0-EC17-11d0-8D10-00A0C90F2719")
    IContextMenu3 : public IContextMenu2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleMenuMsg2( 
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam,
            /* [annotation][out] */ 
            __out_opt  LRESULT *plResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenu3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMenu3 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMenu3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMenu3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContextMenu )( 
            IContextMenu3 * This,
            /* [annotation][in] */ 
            __in  HMENU hmenu,
            /* [annotation][in] */ 
            __in  UINT indexMenu,
            /* [annotation][in] */ 
            __in  UINT idCmdFirst,
            /* [annotation][in] */ 
            __in  UINT idCmdLast,
            /* [annotation][in] */ 
            __in  UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeCommand )( 
            IContextMenu3 * This,
            /* [annotation][in] */ 
            __in  CMINVOKECOMMANDINFO *pici);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandString )( 
            IContextMenu3 * This,
            /* [annotation][in] */ 
            __in  UINT_PTR idCmd,
            /* [annotation][in] */ 
            __in  UINT uType,
            /* [annotation][in] */ 
            __reserved  UINT *pReserved,
            /* [annotation][out] */ 
            __out_awcount(!(uType & GCS_UNICODE), cchMax)  LPSTR pszName,
            /* [annotation][in] */ 
            __in  UINT cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *HandleMenuMsg )( 
            IContextMenu3 * This,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *HandleMenuMsg2 )( 
            IContextMenu3 * This,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam,
            /* [annotation][out] */ 
            __out_opt  LRESULT *plResult);
        
        END_INTERFACE
    } IContextMenu3Vtbl;

    interface IContextMenu3
    {
        CONST_VTBL struct IContextMenu3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenu3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenu3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenu3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenu3_QueryContextMenu(This,hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags)	\
    ( (This)->lpVtbl -> QueryContextMenu(This,hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags) ) 

#define IContextMenu3_InvokeCommand(This,pici)	\
    ( (This)->lpVtbl -> InvokeCommand(This,pici) ) 

#define IContextMenu3_GetCommandString(This,idCmd,uType,pReserved,pszName,cchMax)	\
    ( (This)->lpVtbl -> GetCommandString(This,idCmd,uType,pReserved,pszName,cchMax) ) 


#define IContextMenu3_HandleMenuMsg(This,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> HandleMenuMsg(This,uMsg,wParam,lParam) ) 


#define IContextMenu3_HandleMenuMsg2(This,uMsg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> HandleMenuMsg2(This,uMsg,wParam,lParam,plResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenu3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0003 */
/* [local] */ 

typedef IContextMenu3 *LPCONTEXTMENU3;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0003_v0_0_s_ifspec;

#ifndef __IExecuteCommand_INTERFACE_DEFINED__
#define __IExecuteCommand_INTERFACE_DEFINED__

/* interface IExecuteCommand */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IExecuteCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7F9185B0-CB92-43c5-80A9-92277A4F7B54")
    IExecuteCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetKeyState( 
            /* [in] */ DWORD grfKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParameters( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPosition( 
            /* [in] */ POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowWindow( 
            /* [in] */ int nShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoShowUI( 
            /* [in] */ BOOL fNoShowUI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirectory( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExecuteCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExecuteCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExecuteCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExecuteCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeyState )( 
            __RPC__in IExecuteCommand * This,
            /* [in] */ DWORD grfKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *SetParameters )( 
            __RPC__in IExecuteCommand * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszParameters);
        
        HRESULT ( STDMETHODCALLTYPE *SetPosition )( 
            __RPC__in IExecuteCommand * This,
            /* [in] */ POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowWindow )( 
            __RPC__in IExecuteCommand * This,
            /* [in] */ int nShow);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoShowUI )( 
            __RPC__in IExecuteCommand * This,
            /* [in] */ BOOL fNoShowUI);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectory )( 
            __RPC__in IExecuteCommand * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDirectory);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            __RPC__in IExecuteCommand * This);
        
        END_INTERFACE
    } IExecuteCommandVtbl;

    interface IExecuteCommand
    {
        CONST_VTBL struct IExecuteCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExecuteCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExecuteCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExecuteCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExecuteCommand_SetKeyState(This,grfKeyState)	\
    ( (This)->lpVtbl -> SetKeyState(This,grfKeyState) ) 

#define IExecuteCommand_SetParameters(This,pszParameters)	\
    ( (This)->lpVtbl -> SetParameters(This,pszParameters) ) 

#define IExecuteCommand_SetPosition(This,pt)	\
    ( (This)->lpVtbl -> SetPosition(This,pt) ) 

#define IExecuteCommand_SetShowWindow(This,nShow)	\
    ( (This)->lpVtbl -> SetShowWindow(This,nShow) ) 

#define IExecuteCommand_SetNoShowUI(This,fNoShowUI)	\
    ( (This)->lpVtbl -> SetNoShowUI(This,fNoShowUI) ) 

#define IExecuteCommand_SetDirectory(This,pszDirectory)	\
    ( (This)->lpVtbl -> SetDirectory(This,pszDirectory) ) 

#define IExecuteCommand_Execute(This)	\
    ( (This)->lpVtbl -> Execute(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExecuteCommand_INTERFACE_DEFINED__ */


#ifndef __IPersistFolder_INTERFACE_DEFINED__
#define __IPersistFolder_INTERFACE_DEFINED__

/* interface IPersistFolder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214EA-0000-0000-C000-000000000046")
    IPersistFolder : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPersistFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPersistFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPersistFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            __RPC__in IPersistFolder * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IPersistFolder * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        END_INTERFACE
    } IPersistFolderVtbl;

    interface IPersistFolder
    {
        CONST_VTBL struct IPersistFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistFolder_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistFolder_Initialize(This,pidl)	\
    ( (This)->lpVtbl -> Initialize(This,pidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0005 */
/* [local] */ 

typedef IPersistFolder *LPPERSISTFOLDER;

#if (_WIN32_IE >= 0x0400)
#define IRTIR_TASK_NOT_RUNNING   0
#define IRTIR_TASK_RUNNING       1
#define IRTIR_TASK_SUSPENDED     2
#define IRTIR_TASK_PENDING       3
#define IRTIR_TASK_FINISHED      4


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0005_v0_0_s_ifspec;

#ifndef __IRunnableTask_INTERFACE_DEFINED__
#define __IRunnableTask_INTERFACE_DEFINED__

/* interface IRunnableTask */
/* [local][object][uuid] */ 


EXTERN_C const IID IID_IRunnableTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85788d00-6807-11d0-b810-00c04fd706ec")
    IRunnableTask : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Kill( 
            /* [annotation][in] */ 
            __in  BOOL bWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE IsRunning( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRunnableTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRunnableTask * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRunnableTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRunnableTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IRunnableTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Kill )( 
            IRunnableTask * This,
            /* [annotation][in] */ 
            __in  BOOL bWait);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IRunnableTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IRunnableTask * This);
        
        ULONG ( STDMETHODCALLTYPE *IsRunning )( 
            IRunnableTask * This);
        
        END_INTERFACE
    } IRunnableTaskVtbl;

    interface IRunnableTask
    {
        CONST_VTBL struct IRunnableTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRunnableTask_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRunnableTask_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRunnableTask_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRunnableTask_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IRunnableTask_Kill(This,bWait)	\
    ( (This)->lpVtbl -> Kill(This,bWait) ) 

#define IRunnableTask_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IRunnableTask_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IRunnableTask_IsRunning(This)	\
    ( (This)->lpVtbl -> IsRunning(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRunnableTask_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0006 */
/* [local] */ 

#define TOID_NULL                    GUID_NULL
#define ITSAT_DEFAULT_LPARAM         ((DWORD_PTR)-1)
#define ITSAT_DEFAULT_PRIORITY       0x10000000
#define ITSAT_MAX_PRIORITY           0x7fffffff
#define ITSAT_MIN_PRIORITY           0x00000000
#define ITSSFLAG_COMPLETE_ON_DESTROY 0x0000 // wait for the current task to complete before deleting the scheduler
#define ITSSFLAG_KILL_ON_DESTROY     0x0001 // kill the current task (if there is one) when the task scheduler is deleted
#define ITSSFLAG_FLAGS_MASK          0x0003
#define ITSS_THREAD_DESTROY_DEFAULT_TIMEOUT  (10*1000)       // default milliseconds until a sleeping worker thread is released
#define ITSS_THREAD_TERMINATE_TIMEOUT        (INFINITE)      // set sleeping worker threads to never be released
#define ITSS_THREAD_TIMEOUT_NO_CHANGE        (INFINITE - 1)  // no change to the thread timeout


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0006_v0_0_s_ifspec;

#ifndef __IShellTaskScheduler_INTERFACE_DEFINED__
#define __IShellTaskScheduler_INTERFACE_DEFINED__

/* interface IShellTaskScheduler */
/* [local][object][uuid] */ 


EXTERN_C const IID IID_IShellTaskScheduler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CCB7BE0-6807-11d0-B810-00C04FD706EC")
    IShellTaskScheduler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTask( 
            /* [annotation][in] */ 
            __in  IRunnableTask *prt,
            /* [annotation][in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [annotation][in] */ 
            __in  DWORD_PTR lParam,
            /* [annotation][in] */ 
            __in  DWORD dwPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveTasks( 
            /* [annotation][in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [annotation][in] */ 
            __in  DWORD_PTR lParam,
            /* [annotation][in] */ 
            __in  BOOL bWaitIfRunning) = 0;
        
        virtual UINT STDMETHODCALLTYPE CountTasks( 
            /* [annotation][in] */ 
            __in  REFTASKOWNERID rtoid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Status( 
            /* [annotation][in] */ 
            __in  DWORD dwReleaseStatus,
            /* [annotation][in] */ 
            __in  DWORD dwThreadTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellTaskSchedulerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellTaskScheduler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellTaskScheduler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellTaskScheduler * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTask )( 
            IShellTaskScheduler * This,
            /* [annotation][in] */ 
            __in  IRunnableTask *prt,
            /* [annotation][in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [annotation][in] */ 
            __in  DWORD_PTR lParam,
            /* [annotation][in] */ 
            __in  DWORD dwPriority);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveTasks )( 
            IShellTaskScheduler * This,
            /* [annotation][in] */ 
            __in  REFTASKOWNERID rtoid,
            /* [annotation][in] */ 
            __in  DWORD_PTR lParam,
            /* [annotation][in] */ 
            __in  BOOL bWaitIfRunning);
        
        UINT ( STDMETHODCALLTYPE *CountTasks )( 
            IShellTaskScheduler * This,
            /* [annotation][in] */ 
            __in  REFTASKOWNERID rtoid);
        
        HRESULT ( STDMETHODCALLTYPE *Status )( 
            IShellTaskScheduler * This,
            /* [annotation][in] */ 
            __in  DWORD dwReleaseStatus,
            /* [annotation][in] */ 
            __in  DWORD dwThreadTimeout);
        
        END_INTERFACE
    } IShellTaskSchedulerVtbl;

    interface IShellTaskScheduler
    {
        CONST_VTBL struct IShellTaskSchedulerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellTaskScheduler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellTaskScheduler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellTaskScheduler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellTaskScheduler_AddTask(This,prt,rtoid,lParam,dwPriority)	\
    ( (This)->lpVtbl -> AddTask(This,prt,rtoid,lParam,dwPriority) ) 

#define IShellTaskScheduler_RemoveTasks(This,rtoid,lParam,bWaitIfRunning)	\
    ( (This)->lpVtbl -> RemoveTasks(This,rtoid,lParam,bWaitIfRunning) ) 

#define IShellTaskScheduler_CountTasks(This,rtoid)	\
    ( (This)->lpVtbl -> CountTasks(This,rtoid) ) 

#define IShellTaskScheduler_Status(This,dwReleaseStatus,dwThreadTimeout)	\
    ( (This)->lpVtbl -> Status(This,dwReleaseStatus,dwThreadTimeout) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellTaskScheduler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0007 */
/* [local] */ 

#define SID_ShellTaskScheduler IID_IShellTaskScheduler


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0007_v0_0_s_ifspec;

#ifndef __IQueryCodePage_INTERFACE_DEFINED__
#define __IQueryCodePage_INTERFACE_DEFINED__

/* interface IQueryCodePage */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IQueryCodePage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7B236CE-EE80-11D0-985F-006008059382")
    IQueryCodePage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodePage( 
            /* [annotation][out] */ 
            __out  UINT *puiCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCodePage( 
            /* [annotation][in] */ 
            __in  UINT uiCodePage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryCodePageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryCodePage * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryCodePage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryCodePage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePage )( 
            IQueryCodePage * This,
            /* [annotation][out] */ 
            __out  UINT *puiCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *SetCodePage )( 
            IQueryCodePage * This,
            /* [annotation][in] */ 
            __in  UINT uiCodePage);
        
        END_INTERFACE
    } IQueryCodePageVtbl;

    interface IQueryCodePage
    {
        CONST_VTBL struct IQueryCodePageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryCodePage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryCodePage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryCodePage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryCodePage_GetCodePage(This,puiCodePage)	\
    ( (This)->lpVtbl -> GetCodePage(This,puiCodePage) ) 

#define IQueryCodePage_SetCodePage(This,uiCodePage)	\
    ( (This)->lpVtbl -> SetCodePage(This,uiCodePage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryCodePage_INTERFACE_DEFINED__ */


#ifndef __IPersistFolder2_INTERFACE_DEFINED__
#define __IPersistFolder2_INTERFACE_DEFINED__

/* interface IPersistFolder2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1AC3D9F0-175C-11d1-95BE-00609797EA4F")
    IPersistFolder2 : public IPersistFolder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurFolder( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPersistFolder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPersistFolder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPersistFolder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            __RPC__in IPersistFolder2 * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IPersistFolder2 * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFolder )( 
            __RPC__in IPersistFolder2 * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        END_INTERFACE
    } IPersistFolder2Vtbl;

    interface IPersistFolder2
    {
        CONST_VTBL struct IPersistFolder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistFolder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistFolder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistFolder2_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistFolder2_Initialize(This,pidl)	\
    ( (This)->lpVtbl -> Initialize(This,pidl) ) 


#define IPersistFolder2_GetCurFolder(This,ppidl)	\
    ( (This)->lpVtbl -> GetCurFolder(This,ppidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistFolder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0009 */
/* [local] */ 

#endif
#if (_WIN32_IE >= 0x0500)
#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY
#include <pshpack8.h>
typedef struct _PERSIST_FOLDER_TARGET_INFO
    {
    PIDLIST_ABSOLUTE pidlTargetFolder;
    WCHAR szTargetParsingName[ 260 ];
    WCHAR szNetworkProvider[ 260 ];
    DWORD dwAttributes;
    int csidl;
    } 	PERSIST_FOLDER_TARGET_INFO;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0009_v0_0_s_ifspec;

#ifndef __IPersistFolder3_INTERFACE_DEFINED__
#define __IPersistFolder3_INTERFACE_DEFINED__

/* interface IPersistFolder3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CEF04FDF-FE72-11d2-87A5-00C04F6837CF")
    IPersistFolder3 : public IPersistFolder2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlRoot,
            /* [unique][in] */ __RPC__in_opt const PERSIST_FOLDER_TARGET_INFO *ppfti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderTargetInfo( 
            /* [out] */ __RPC__out PERSIST_FOLDER_TARGET_INFO *ppfti) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolder3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPersistFolder3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPersistFolder3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPersistFolder3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            __RPC__in IPersistFolder3 * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IPersistFolder3 * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFolder )( 
            __RPC__in IPersistFolder3 * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEx )( 
            __RPC__in IPersistFolder3 * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlRoot,
            /* [unique][in] */ __RPC__in_opt const PERSIST_FOLDER_TARGET_INFO *ppfti);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderTargetInfo )( 
            __RPC__in IPersistFolder3 * This,
            /* [out] */ __RPC__out PERSIST_FOLDER_TARGET_INFO *ppfti);
        
        END_INTERFACE
    } IPersistFolder3Vtbl;

    interface IPersistFolder3
    {
        CONST_VTBL struct IPersistFolder3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistFolder3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistFolder3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistFolder3_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistFolder3_Initialize(This,pidl)	\
    ( (This)->lpVtbl -> Initialize(This,pidl) ) 


#define IPersistFolder3_GetCurFolder(This,ppidl)	\
    ( (This)->lpVtbl -> GetCurFolder(This,ppidl) ) 


#define IPersistFolder3_InitializeEx(This,pbc,pidlRoot,ppfti)	\
    ( (This)->lpVtbl -> InitializeEx(This,pbc,pidlRoot,ppfti) ) 

#define IPersistFolder3_GetFolderTargetInfo(This,ppfti)	\
    ( (This)->lpVtbl -> GetFolderTargetInfo(This,ppfti) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistFolder3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0010 */
/* [local] */ 

#endif
#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0010_v0_0_s_ifspec;

#ifndef __IPersistIDList_INTERFACE_DEFINED__
#define __IPersistIDList_INTERFACE_DEFINED__

/* interface IPersistIDList */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1079acfc-29bd-11d3-8e0d-00c04f6837d5")
    IPersistIDList : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPersistIDList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPersistIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPersistIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            __RPC__in IPersistIDList * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            __RPC__in IPersistIDList * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            __RPC__in IPersistIDList * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        END_INTERFACE
    } IPersistIDListVtbl;

    interface IPersistIDList
    {
        CONST_VTBL struct IPersistIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistIDList_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistIDList_SetIDList(This,pidl)	\
    ( (This)->lpVtbl -> SetIDList(This,pidl) ) 

#define IPersistIDList_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0011 */
/* [local] */ 

#endif  // NTDDI_WINXP|| (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0011_v0_0_s_ifspec;

#ifndef __IEnumIDList_INTERFACE_DEFINED__
#define __IEnumIDList_INTERFACE_DEFINED__

/* interface IEnumIDList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F2-0000-0000-C000-000000000046")
    IEnumIDList : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  PITEMID_CHILD *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumIDList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumIDList * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumIDList * This,
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  PITEMID_CHILD *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumIDList * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumIDList * This,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenum);
        
        END_INTERFACE
    } IEnumIDListVtbl;

    interface IEnumIDList
    {
        CONST_VTBL struct IEnumIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumIDList_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumIDList_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumIDList_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumIDList_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumIDList_RemoteNext_Proxy( 
    __RPC__in IEnumIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PITEMID_CHILD *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumIDList_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0012 */
/* [local] */ 

typedef IEnumIDList *LPENUMIDLIST;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0012_v0_0_s_ifspec;

#ifndef __IEnumFullIDList_INTERFACE_DEFINED__
#define __IEnumFullIDList_INTERFACE_DEFINED__

/* interface IEnumFullIDList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumFullIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0191542-7954-4908-bc06-b2360bbe45ba")
    IEnumFullIDList : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  PIDLIST_ABSOLUTE *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumFullIDList **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFullIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumFullIDList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumFullIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumFullIDList * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFullIDList * This,
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  PIDLIST_ABSOLUTE *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumFullIDList * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumFullIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumFullIDList * This,
            /* [out] */ __RPC__deref_out_opt IEnumFullIDList **ppenum);
        
        END_INTERFACE
    } IEnumFullIDListVtbl;

    interface IEnumFullIDList
    {
        CONST_VTBL struct IEnumFullIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFullIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFullIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFullIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFullIDList_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumFullIDList_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumFullIDList_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumFullIDList_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumFullIDList_RemoteNext_Proxy( 
    __RPC__in IEnumFullIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PIDLIST_ABSOLUTE *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumFullIDList_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumFullIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0013 */
/* [local] */ 

/* [v1_enum] */ 
enum _SHGDNF
    {	SHGDN_NORMAL	= 0,
	SHGDN_INFOLDER	= 0x1,
	SHGDN_FOREDITING	= 0x1000,
	SHGDN_FORADDRESSBAR	= 0x4000,
	SHGDN_FORPARSING	= 0x8000
    } ;
typedef DWORD SHGDNF;

/* [v1_enum] */ 
enum _SHCONTF
    {	SHCONTF_CHECKING_FOR_CHILDREN	= 0x10,
	SHCONTF_FOLDERS	= 0x20,
	SHCONTF_NONFOLDERS	= 0x40,
	SHCONTF_INCLUDEHIDDEN	= 0x80,
	SHCONTF_INIT_ON_FIRST_NEXT	= 0x100,
	SHCONTF_NETPRINTERSRCH	= 0x200,
	SHCONTF_SHAREABLE	= 0x400,
	SHCONTF_STORAGE	= 0x800,
	SHCONTF_NAVIGATION_ENUM	= 0x1000,
	SHCONTF_FASTITEMS	= 0x2000,
	SHCONTF_FLATLIST	= 0x4000,
	SHCONTF_ENABLE_ASYNC	= 0x8000,
	SHCONTF_INCLUDESUPERHIDDEN	= 0x10000
    } ;
typedef DWORD SHCONTF;

#define SHCIDS_ALLFIELDS        0x80000000L
#define SHCIDS_CANONICALONLY    0x10000000L
#define SHCIDS_BITMASK          0xFFFF0000L
#define SHCIDS_COLUMNMASK       0x0000FFFFL
#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied    (0x1)
#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved     (0x2)
#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked    (0x4)
#define SFGAO_STORAGE           0x00000008L     // supports BindToObject(IID_IStorage)
#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed
#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted
#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets
#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target
#define SFGAO_CAPABILITYMASK    0x00000177L
#define SFGAO_SYSTEM            0x00001000L     // System object
#define SFGAO_ENCRYPTED         0x00002000L     // Object is encrypted (use alt color)
#define SFGAO_ISSLOW            0x00004000L     // 'Slow' object
#define SFGAO_GHOSTED           0x00008000L     // Ghosted icon
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_SHARE             0x00020000L     // Shared
#define SFGAO_READONLY          0x00040000L     // Read-only
#define SFGAO_HIDDEN            0x00080000L     // Hidden object
#define SFGAO_DISPLAYATTRMASK   0x000FC000L
#define SFGAO_FILESYSANCESTOR   0x10000000L     // May contain children with SFGAO_FILESYSTEM
#define SFGAO_FOLDER            0x20000000L     // Support BindToObject(IID_IShellFolder)
#define SFGAO_FILESYSTEM        0x40000000L     // Is a win32 file system object (file/folder/root)
#define SFGAO_HASSUBFOLDER      0x80000000L     // May contain children with SFGAO_FOLDER (may be slow)
#define SFGAO_CONTENTSMASK      0x80000000L
#define SFGAO_VALIDATE          0x01000000L     // Invalidate cached information (may be slow)
#define SFGAO_REMOVABLE         0x02000000L     // Is this removeable media?
#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)
#define SFGAO_BROWSABLE         0x08000000L     // Supports IShellFolder, but only implements CreateViewObject() (non-folder view)
#define SFGAO_NONENUMERATED     0x00100000L     // Is a non-enumerated object (should be hidden)
#define SFGAO_NEWCONTENT        0x00200000L     // Should show bold in explorer tree
#define SFGAO_CANMONIKER        0x00400000L     // Obsolete
#define SFGAO_HASSTORAGE        0x00400000L     // Obsolete
#define SFGAO_STREAM            0x00400000L     // Supports BindToObject(IID_IStream)
#define SFGAO_STORAGEANCESTOR   0x00800000L     // May contain children with SFGAO_STORAGE or SFGAO_STREAM
#define SFGAO_STORAGECAPMASK    0x70C50008L     // For determining storage capabilities, ie for open/save semantics
#define SFGAO_PKEYSFGAOMASK     0x81044000L     // Attributes that are masked out for PKEY_SFGAOFlags because they are considered to cause slow calculations or lack context (SFGAO_VALIDATE | SFGAO_ISSLOW | SFGAO_HASSUBFOLDER and others)
typedef ULONG SFGAOF;

#define STR_BIND_FORCE_FOLDER_SHORTCUT_RESOLVE   L"Force Folder Shortcut Resolve"
#define STR_AVOID_DRIVE_RESTRICTION_POLICY   L"Avoid Drive Restriction Policy"
#define STR_AVOID_DRIVE_RESTRICTION_POLICY   L"Avoid Drive Restriction Policy"
#define STR_SKIP_BINDING_CLSID      L"Skip Binding CLSID"
#define STR_PARSE_PREFER_FOLDER_BROWSING     L"Parse Prefer Folder Browsing"
#define STR_DONT_PARSE_RELATIVE              L"Don't Parse Relative"
#define STR_PARSE_TRANSLATE_ALIASES          L"Parse Translate Aliases"
#define STR_PARSE_SKIP_NET_CACHE             L"Skip Net Resource Cache"
#define STR_PARSE_SHELL_PROTOCOL_TO_FILE_OBJECTS     L"Parse Shell Protocol To File Objects"
#if (_WIN32_IE >= 0x0700)
#define STR_TRACK_CLSID                      L"Track the CLSID"
#define STR_INTERNAL_NAVIGATE                L"Internal Navigation"
#define STR_PARSE_PROPERTYSTORE             L"DelegateNamedProperties"
#define STR_NO_VALIDATE_FILENAME_CHARS      L"NoValidateFilenameChars"
#define STR_BIND_DELEGATE_CREATE_OBJECT L"Delegate Object Creation"
#define STR_PARSE_ALLOW_INTERNET_SHELL_FOLDERS   L"Allow binding to Internet shell folder handlers and negate STR_PARSE_PREFER_WEB_BROWSING"
#define STR_PARSE_PREFER_WEB_BROWSING   L"Do not bind to Internet shell folder handlers"
#define STR_PARSE_SHOW_NET_DIAGNOSTICS_UI  L"Show network diagnostics UI"
#define STR_PARSE_DONT_REQUIRE_VALIDATED_URLS  L"Do not require validated URLs"
#define STR_INTERNETFOLDER_PARSE_ONLY_URLMON_BINDABLE  L"Validate URL"
#endif // _WIN32_IE >= 0x0700
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define STR_BIND_FOLDERS_READ_ONLY L"Folders As Read Only"
#define STR_BIND_FOLDER_ENUM_MODE L"Folder Enum Mode"
typedef /* [v1_enum] */ 
enum FOLDER_ENUM_MODE
    {	FEM_VIEWRESULT	= 0,
	FEM_NAVIGATION	= 1
    } 	FOLDER_ENUM_MODE;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0013_v0_0_s_ifspec;

#ifndef __IObjectWithFolderEnumMode_INTERFACE_DEFINED__
#define __IObjectWithFolderEnumMode_INTERFACE_DEFINED__

/* interface IObjectWithFolderEnumMode */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IObjectWithFolderEnumMode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6a9d9026-0e6e-464c-b000-42ecc07de673")
    IObjectWithFolderEnumMode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ FOLDER_ENUM_MODE feMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [out] */ __RPC__out FOLDER_ENUM_MODE *pfeMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithFolderEnumModeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectWithFolderEnumMode * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectWithFolderEnumMode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectWithFolderEnumMode * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            __RPC__in IObjectWithFolderEnumMode * This,
            /* [in] */ FOLDER_ENUM_MODE feMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            __RPC__in IObjectWithFolderEnumMode * This,
            /* [out] */ __RPC__out FOLDER_ENUM_MODE *pfeMode);
        
        END_INTERFACE
    } IObjectWithFolderEnumModeVtbl;

    interface IObjectWithFolderEnumMode
    {
        CONST_VTBL struct IObjectWithFolderEnumModeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithFolderEnumMode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithFolderEnumMode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithFolderEnumMode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithFolderEnumMode_SetMode(This,feMode)	\
    ( (This)->lpVtbl -> SetMode(This,feMode) ) 

#define IObjectWithFolderEnumMode_GetMode(This,pfeMode)	\
    ( (This)->lpVtbl -> GetMode(This,pfeMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithFolderEnumMode_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0014 */
/* [local] */ 

#define STR_PARSE_WITH_EXPLICIT_PROGID L"ExplicitProgid"
#define STR_PARSE_WITH_EXPLICIT_ASSOCAPP L"ExplicitAssociationApp"
#define STR_PARSE_EXPLICIT_ASSOCIATION_SUCCESSFUL L"ExplicitAssociationSuccessful"
#define STR_PARSE_AND_CREATE_ITEM    L"ParseAndCreateItem"



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0014_v0_0_s_ifspec;

#ifndef __IParseAndCreateItem_INTERFACE_DEFINED__
#define __IParseAndCreateItem_INTERFACE_DEFINED__

/* interface IParseAndCreateItem */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IParseAndCreateItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67efed0e-e827-4408-b493-78f3982b685c")
    IParseAndCreateItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParseAndCreateItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IParseAndCreateItem * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IParseAndCreateItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IParseAndCreateItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IParseAndCreateItem * This,
            /* [in] */ IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IParseAndCreateItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IParseAndCreateItemVtbl;

    interface IParseAndCreateItem
    {
        CONST_VTBL struct IParseAndCreateItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParseAndCreateItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IParseAndCreateItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IParseAndCreateItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IParseAndCreateItem_SetItem(This,psi)	\
    ( (This)->lpVtbl -> SetItem(This,psi) ) 

#define IParseAndCreateItem_GetItem(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetItem(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IParseAndCreateItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0015 */
/* [local] */ 

#define STR_ITEM_CACHE_CONTEXT       L"ItemCacheContext"
#endif // NTDDI_VERSION >= NTDDI_WIN7



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0015_v0_0_s_ifspec;

#ifndef __IShellFolder_INTERFACE_DEFINED__
#define __IShellFolder_INTERFACE_DEFINED__

/* interface IShellFolder */
/* [unique][object][uuid] */ 






EXTERN_C const IID IID_IShellFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E6-0000-0000-C000-000000000046")
    IShellFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseDisplayName( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [string][in] */ __RPC__in_string LPWSTR pszDisplayName,
            /* [annotation][unique][out][in] */ 
            __reserved  ULONG *pchEaten,
            /* [out] */ __RPC__deref_out_opt PIDLIST_RELATIVE *ppidl,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pdwAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumObjects( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenumIDList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToStorage( 
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareIDs( 
            /* [in] */ LPARAM lParam,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl1,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewObject( 
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributesOf( 
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [out][in] */ __RPC__inout SFGAOF *rgfInOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUIObjectOf( 
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][unique][out][in] */ 
            __reserved  UINT *rgfReserved,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayNameOf( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__out STRRET *pName) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetNameOf( 
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  PCUITEMID_CHILD pidl,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName,
            /* [annotation][in] */ 
            __in  SHGDNF uFlags,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseDisplayName )( 
            __RPC__in IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [string][in] */ __RPC__in_string LPWSTR pszDisplayName,
            /* [annotation][unique][out][in] */ 
            __reserved  ULONG *pchEaten,
            /* [out] */ __RPC__deref_out_opt PIDLIST_RELATIVE *ppidl,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            __RPC__in IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            __RPC__in IShellFolder * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            __RPC__in IShellFolder * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CompareIDs )( 
            __RPC__in IShellFolder * This,
            /* [in] */ LPARAM lParam,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl1,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl2);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewObject )( 
            __RPC__in IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributesOf )( 
            __RPC__in IShellFolder * This,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [out][in] */ __RPC__inout SFGAOF *rgfInOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIObjectOf )( 
            __RPC__in IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][unique][out][in] */ 
            __reserved  UINT *rgfReserved,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameOf )( 
            __RPC__in IShellFolder * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__out STRRET *pName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNameOf )( 
            IShellFolder * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  PCUITEMID_CHILD pidl,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName,
            /* [annotation][in] */ 
            __in  SHGDNF uFlags,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlOut);
        
        END_INTERFACE
    } IShellFolderVtbl;

    interface IShellFolder
    {
        CONST_VTBL struct IShellFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolder_ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)	\
    ( (This)->lpVtbl -> ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes) ) 

#define IShellFolder_EnumObjects(This,hwnd,grfFlags,ppenumIDList)	\
    ( (This)->lpVtbl -> EnumObjects(This,hwnd,grfFlags,ppenumIDList) ) 

#define IShellFolder_BindToObject(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToObject(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder_BindToStorage(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToStorage(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder_CompareIDs(This,lParam,pidl1,pidl2)	\
    ( (This)->lpVtbl -> CompareIDs(This,lParam,pidl1,pidl2) ) 

#define IShellFolder_CreateViewObject(This,hwndOwner,riid,ppv)	\
    ( (This)->lpVtbl -> CreateViewObject(This,hwndOwner,riid,ppv) ) 

#define IShellFolder_GetAttributesOf(This,cidl,apidl,rgfInOut)	\
    ( (This)->lpVtbl -> GetAttributesOf(This,cidl,apidl,rgfInOut) ) 

#define IShellFolder_GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)	\
    ( (This)->lpVtbl -> GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv) ) 

#define IShellFolder_GetDisplayNameOf(This,pidl,uFlags,pName)	\
    ( (This)->lpVtbl -> GetDisplayNameOf(This,pidl,uFlags,pName) ) 

#define IShellFolder_SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)	\
    ( (This)->lpVtbl -> SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IShellFolder_RemoteSetNameOf_Proxy( 
    __RPC__in IShellFolder * This,
    /* [unique][in] */ __RPC__in_opt HWND hwnd,
    /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
    /* [string][in] */ __RPC__in_string LPCWSTR pszName,
    /* [in] */ SHGDNF uFlags,
    /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlOut);


void __RPC_STUB IShellFolder_RemoteSetNameOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0016 */
/* [local] */ 

typedef IShellFolder *LPSHELLFOLDER;

typedef struct EXTRASEARCH
    {
    GUID guidSearch;
    WCHAR wszFriendlyName[ 80 ];
    WCHAR wszUrl[ 2084 ];
    } 	EXTRASEARCH;

typedef struct EXTRASEARCH *LPEXTRASEARCH;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0016_v0_0_s_ifspec;

#ifndef __IEnumExtraSearch_INTERFACE_DEFINED__
#define __IEnumExtraSearch_INTERFACE_DEFINED__

/* interface IEnumExtraSearch */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumExtraSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E700BE1-9DB6-11d1-A1CE-00C04FD75D13")
    IEnumExtraSearch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) EXTRASEARCH *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumExtraSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumExtraSearch * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumExtraSearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumExtraSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumExtraSearch * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) EXTRASEARCH *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumExtraSearch * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumExtraSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumExtraSearch * This,
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum);
        
        END_INTERFACE
    } IEnumExtraSearchVtbl;

    interface IEnumExtraSearch
    {
        CONST_VTBL struct IEnumExtraSearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumExtraSearch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumExtraSearch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumExtraSearch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumExtraSearch_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumExtraSearch_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumExtraSearch_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumExtraSearch_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumExtraSearch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0017 */
/* [local] */ 

typedef IEnumExtraSearch *LPENUMEXTRASEARCH;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0017_v0_0_s_ifspec;

#ifndef __IShellFolder2_INTERFACE_DEFINED__
#define __IShellFolder2_INTERFACE_DEFINED__

/* interface IShellFolder2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellFolder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93F2F68C-1D1B-11d3-A30E-00C04F79ABD1")
    IShellFolder2 : public IShellFolder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSearchGUID( 
            /* [out] */ __RPC__out GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSearches( 
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumn( 
            /* [in] */ DWORD dwRes,
            /* [out] */ __RPC__out ULONG *pSort,
            /* [out] */ __RPC__out ULONG *pDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnState( 
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailsEx( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out VARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailsOf( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHELLDETAILS *psd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapColumnToSCID( 
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLUMNID *pscid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellFolder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellFolder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseDisplayName )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [string][in] */ __RPC__in_string LPWSTR pszDisplayName,
            /* [annotation][unique][out][in] */ 
            __reserved  ULONG *pchEaten,
            /* [out] */ __RPC__deref_out_opt PIDLIST_RELATIVE *ppidl,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ __RPC__deref_out_opt IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CompareIDs )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ LPARAM lParam,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl1,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl2);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewObject )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributesOf )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [out][in] */ __RPC__inout SFGAOF *rgfInOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIObjectOf )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][unique][out][in] */ 
            __reserved  UINT *rgfReserved,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameOf )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ __RPC__out STRRET *pName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNameOf )( 
            IShellFolder2 * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  PCUITEMID_CHILD pidl,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName,
            /* [annotation][in] */ 
            __in  SHGDNF uFlags,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSearchGUID )( 
            __RPC__in IShellFolder2 * This,
            /* [out] */ __RPC__out GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSearches )( 
            __RPC__in IShellFolder2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumExtraSearch **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumn )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ DWORD dwRes,
            /* [out] */ __RPC__out ULONG *pSort,
            /* [out] */ __RPC__out ULONG *pDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnState )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailsEx )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out VARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailsOf )( 
            __RPC__in IShellFolder2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidl,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHELLDETAILS *psd);
        
        HRESULT ( STDMETHODCALLTYPE *MapColumnToSCID )( 
            __RPC__in IShellFolder2 * This,
            /* [in] */ UINT iColumn,
            /* [out] */ __RPC__out SHCOLUMNID *pscid);
        
        END_INTERFACE
    } IShellFolder2Vtbl;

    interface IShellFolder2
    {
        CONST_VTBL struct IShellFolder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellFolder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellFolder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellFolder2_ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)	\
    ( (This)->lpVtbl -> ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes) ) 

#define IShellFolder2_EnumObjects(This,hwnd,grfFlags,ppenumIDList)	\
    ( (This)->lpVtbl -> EnumObjects(This,hwnd,grfFlags,ppenumIDList) ) 

#define IShellFolder2_BindToObject(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToObject(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder2_BindToStorage(This,pidl,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> BindToStorage(This,pidl,pbc,riid,ppv) ) 

#define IShellFolder2_CompareIDs(This,lParam,pidl1,pidl2)	\
    ( (This)->lpVtbl -> CompareIDs(This,lParam,pidl1,pidl2) ) 

#define IShellFolder2_CreateViewObject(This,hwndOwner,riid,ppv)	\
    ( (This)->lpVtbl -> CreateViewObject(This,hwndOwner,riid,ppv) ) 

#define IShellFolder2_GetAttributesOf(This,cidl,apidl,rgfInOut)	\
    ( (This)->lpVtbl -> GetAttributesOf(This,cidl,apidl,rgfInOut) ) 

#define IShellFolder2_GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)	\
    ( (This)->lpVtbl -> GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv) ) 

#define IShellFolder2_GetDisplayNameOf(This,pidl,uFlags,pName)	\
    ( (This)->lpVtbl -> GetDisplayNameOf(This,pidl,uFlags,pName) ) 

#define IShellFolder2_SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)	\
    ( (This)->lpVtbl -> SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut) ) 


#define IShellFolder2_GetDefaultSearchGUID(This,pguid)	\
    ( (This)->lpVtbl -> GetDefaultSearchGUID(This,pguid) ) 

#define IShellFolder2_EnumSearches(This,ppenum)	\
    ( (This)->lpVtbl -> EnumSearches(This,ppenum) ) 

#define IShellFolder2_GetDefaultColumn(This,dwRes,pSort,pDisplay)	\
    ( (This)->lpVtbl -> GetDefaultColumn(This,dwRes,pSort,pDisplay) ) 

#define IShellFolder2_GetDefaultColumnState(This,iColumn,pcsFlags)	\
    ( (This)->lpVtbl -> GetDefaultColumnState(This,iColumn,pcsFlags) ) 

#define IShellFolder2_GetDetailsEx(This,pidl,pscid,pv)	\
    ( (This)->lpVtbl -> GetDetailsEx(This,pidl,pscid,pv) ) 

#define IShellFolder2_GetDetailsOf(This,pidl,iColumn,psd)	\
    ( (This)->lpVtbl -> GetDetailsOf(This,pidl,iColumn,psd) ) 

#define IShellFolder2_MapColumnToSCID(This,iColumn,pscid)	\
    ( (This)->lpVtbl -> MapColumnToSCID(This,iColumn,pscid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellFolder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0018 */
/* [local] */ 

typedef char *LPVIEWSETTINGS;

typedef /* [v1_enum] */ 
enum FOLDERFLAGS
    {	FWF_NONE	= 0,
	FWF_AUTOARRANGE	= 0x1,
	FWF_ABBREVIATEDNAMES	= 0x2,
	FWF_SNAPTOGRID	= 0x4,
	FWF_OWNERDATA	= 0x8,
	FWF_BESTFITWINDOW	= 0x10,
	FWF_DESKTOP	= 0x20,
	FWF_SINGLESEL	= 0x40,
	FWF_NOSUBFOLDERS	= 0x80,
	FWF_TRANSPARENT	= 0x100,
	FWF_NOCLIENTEDGE	= 0x200,
	FWF_NOSCROLL	= 0x400,
	FWF_ALIGNLEFT	= 0x800,
	FWF_NOICONS	= 0x1000,
	FWF_SHOWSELALWAYS	= 0x2000,
	FWF_NOVISIBLE	= 0x4000,
	FWF_SINGLECLICKACTIVATE	= 0x8000,
	FWF_NOWEBVIEW	= 0x10000,
	FWF_HIDEFILENAMES	= 0x20000,
	FWF_CHECKSELECT	= 0x40000,
	FWF_NOENUMREFRESH	= 0x80000,
	FWF_NOGROUPING	= 0x100000,
	FWF_FULLROWSELECT	= 0x200000,
	FWF_NOFILTERS	= 0x400000,
	FWF_NOCOLUMNHEADER	= 0x800000,
	FWF_NOHEADERINALLVIEWS	= 0x1000000,
	FWF_EXTENDEDTILES	= 0x2000000,
	FWF_TRICHECKSELECT	= 0x4000000,
	FWF_AUTOCHECKSELECT	= 0x8000000,
	FWF_NOBROWSERVIEWSTATE	= 0x10000000,
	FWF_SUBSETGROUPS	= 0x20000000,
	FWF_USESEARCHFOLDER	= 0x40000000,
	FWF_ALLOWRTLREADING	= 0x80000000
    } 	FOLDERFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(FOLDERFLAGS)
typedef /* [v1_enum] */ 
enum FOLDERVIEWMODE
    {	FVM_AUTO	= -1,
	FVM_FIRST	= 1,
	FVM_ICON	= 1,
	FVM_SMALLICON	= 2,
	FVM_LIST	= 3,
	FVM_DETAILS	= 4,
	FVM_THUMBNAIL	= 5,
	FVM_TILE	= 6,
	FVM_THUMBSTRIP	= 7,
	FVM_CONTENT	= 8,
	FVM_LAST	= 8
    } 	FOLDERVIEWMODE;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef /* [v1_enum] */ 
enum FOLDERLOGICALVIEWMODE
    {	FLVM_UNSPECIFIED	= -1,
	FLVM_FIRST	= 1,
	FLVM_DETAILS	= 1,
	FLVM_TILES	= 2,
	FLVM_ICONS	= 3,
	FLVM_LIST	= 4,
	FLVM_CONTENT	= 5,
	FLVM_LAST	= 5
    } 	FOLDERLOGICALVIEWMODE;

#endif  // NTDDI_VISTA
typedef struct FOLDERSETTINGS
    {
    UINT ViewMode;
    UINT fFlags;
    } 	FOLDERSETTINGS;

typedef FOLDERSETTINGS *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS *LPCFOLDERSETTINGS;

typedef FOLDERSETTINGS *PFOLDERSETTINGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0018_v0_0_s_ifspec;

#ifndef __IFolderViewOptions_INTERFACE_DEFINED__
#define __IFolderViewOptions_INTERFACE_DEFINED__

/* interface IFolderViewOptions */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum FOLDERVIEWOPTIONS
    {	FVO_DEFAULT	= 0,
	FVO_VISTALAYOUT	= 0x1,
	FVO_CUSTOMPOSITION	= 0x2,
	FVO_CUSTOMORDERING	= 0x4,
	FVO_SUPPORTHYPERLINKS	= 0x8,
	FVO_NOANIMATIONS	= 0x10,
	FVO_NOSCROLLTIPS	= 0x20
    } 	FOLDERVIEWOPTIONS;

DEFINE_ENUM_FLAG_OPERATORS(FOLDERVIEWOPTIONS)

EXTERN_C const IID IID_IFolderViewOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3cc974d2-b302-4d36-ad3e-06d93f695d3f")
    IFolderViewOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFolderViewOptions( 
            /* [in] */ FOLDERVIEWOPTIONS fvoMask,
            /* [in] */ FOLDERVIEWOPTIONS fvoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderViewOptions( 
            /* [out] */ __RPC__out FOLDERVIEWOPTIONS *pfvoFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderViewOptions * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderViewOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderViewOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderViewOptions )( 
            __RPC__in IFolderViewOptions * This,
            /* [in] */ FOLDERVIEWOPTIONS fvoMask,
            /* [in] */ FOLDERVIEWOPTIONS fvoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderViewOptions )( 
            __RPC__in IFolderViewOptions * This,
            /* [out] */ __RPC__out FOLDERVIEWOPTIONS *pfvoFlags);
        
        END_INTERFACE
    } IFolderViewOptionsVtbl;

    interface IFolderViewOptions
    {
        CONST_VTBL struct IFolderViewOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewOptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderViewOptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderViewOptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderViewOptions_SetFolderViewOptions(This,fvoMask,fvoFlags)	\
    ( (This)->lpVtbl -> SetFolderViewOptions(This,fvoMask,fvoFlags) ) 

#define IFolderViewOptions_GetFolderViewOptions(This,pfvoFlags)	\
    ( (This)->lpVtbl -> GetFolderViewOptions(This,pfvoFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderViewOptions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0019 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum _SVSIF
    {	SVSI_DESELECT	= 0,
	SVSI_SELECT	= 0x1,
	SVSI_EDIT	= 0x3,
	SVSI_DESELECTOTHERS	= 0x4,
	SVSI_ENSUREVISIBLE	= 0x8,
	SVSI_FOCUSED	= 0x10,
	SVSI_TRANSLATEPT	= 0x20,
	SVSI_SELECTIONMARK	= 0x40,
	SVSI_POSITIONITEM	= 0x80,
	SVSI_CHECK	= 0x100,
	SVSI_CHECK2	= 0x200,
	SVSI_KEYBOARDSELECT	= 0x401,
	SVSI_NOTAKEFOCUS	= 0x40000000
    } 	_SVSIF;

#define SVSI_NOSTATECHANGE   ((UINT)0x80000000) // work around the use of the high bit that results in 4245: signed/unsigned mismatch
typedef UINT SVSIF;

typedef /* [v1_enum] */ 
enum _SVGIO
    {	SVGIO_BACKGROUND	= 0,
	SVGIO_SELECTION	= 0x1,
	SVGIO_ALLVIEW	= 0x2,
	SVGIO_CHECKED	= 0x3,
	SVGIO_TYPE_MASK	= 0xf,
	SVGIO_FLAG_VIEWORDER	= 0x80000000
    } 	_SVGIO;

DEFINE_ENUM_FLAG_OPERATORS(_SVGIO)
typedef int SVGIO;

typedef /* [v1_enum] */ 
enum SVUIA_STATUS
    {	SVUIA_DEACTIVATE	= 0,
	SVUIA_ACTIVATE_NOFOCUS	= 1,
	SVUIA_ACTIVATE_FOCUS	= 2,
	SVUIA_INPLACEACTIVATE	= 3
    } 	SVUIA_STATUS;

#ifdef _FIX_ENABLEMODELESS_CONFLICT
#define    EnableModeless EnableModelessSV
#endif
#ifdef _NEVER_
typedef LPARAM LPFNSVADDPROPSHEETPAGE;

#else //!_NEVER_
#include <prsht.h>
typedef LPFNADDPROPSHEETPAGE LPFNSVADDPROPSHEETPAGE;
#endif //_NEVER_



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0019_v0_0_s_ifspec;

#ifndef __IShellView_INTERFACE_DEFINED__
#define __IShellView_INTERFACE_DEFINED__

/* interface IShellView */
/* [unique][object][uuid] */ 

typedef IShellView *LPSHELLVIEW;


EXTERN_C const IID IID_IShellView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E3-0000-0000-C000-000000000046")
    IShellView : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ __RPC__in MSG *pmsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow( 
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyViewWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentInfo( 
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddPropertySheetPages( 
            /* [annotation][in] */ 
            __in  DWORD dwReserved,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [annotation][in] */ 
            __in  LPARAM lparam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemObject( 
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellView * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IShellView * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IShellView * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            __RPC__in IShellView * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            __RPC__in IShellView * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            __RPC__in IShellView * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            __RPC__in IShellView * This,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            __RPC__in IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            __RPC__in IShellView * This,
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView * This,
            /* [annotation][in] */ 
            __in  DWORD dwReserved,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [annotation][in] */ 
            __in  LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            __RPC__in IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            __RPC__in IShellView * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            __RPC__in IShellView * This,
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IShellViewVtbl;

    interface IShellView
    {
        CONST_VTBL struct IShellViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellView_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellView_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellView_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#define IShellView_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#define IShellView_UIActivate(This,uState)	\
    ( (This)->lpVtbl -> UIActivate(This,uState) ) 

#define IShellView_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IShellView_CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd)	\
    ( (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd) ) 

#define IShellView_DestroyViewWindow(This)	\
    ( (This)->lpVtbl -> DestroyViewWindow(This) ) 

#define IShellView_GetCurrentInfo(This,pfs)	\
    ( (This)->lpVtbl -> GetCurrentInfo(This,pfs) ) 

#define IShellView_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    ( (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam) ) 

#define IShellView_SaveViewState(This)	\
    ( (This)->lpVtbl -> SaveViewState(This) ) 

#define IShellView_SelectItem(This,pidlItem,uFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags) ) 

#define IShellView_GetItemObject(This,uItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellView_INTERFACE_DEFINED__ */


#ifndef __IShellView2_INTERFACE_DEFINED__
#define __IShellView2_INTERFACE_DEFINED__

/* interface IShellView2 */
/* [unique][object][uuid] */ 

typedef GUID SHELLVIEWID;

#define SV2GV_CURRENTVIEW ((UINT)-1)
#define SV2GV_DEFAULTVIEW ((UINT)-2)
#include <pshpack8.h>
typedef struct _SV2CVW2_PARAMS
    {
    DWORD cbSize;
    IShellView *psvPrev;
    LPCFOLDERSETTINGS pfs;
    IShellBrowser *psbOwner;
    RECT *prcView;
    const SHELLVIEWID *pvid;
    HWND hwndView;
    } 	SV2CVW2_PARAMS;

typedef struct _SV2CVW2_PARAMS *LPSV2CVW2_PARAMS;

#include <poppack.h>

EXTERN_C const IID IID_IShellView2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88E39E80-3578-11CF-AE69-08002B2E1262")
    IShellView2 : public IShellView
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetView( 
            /* [out][in] */ __RPC__inout SHELLVIEWID *pvid,
            /* [in] */ ULONG uView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow2( 
            /* [in] */ __RPC__in LPSV2CVW2_PARAMS lpParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRename( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndPositionItem( 
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ UINT uFlags,
            /* [unique][in] */ __RPC__in_opt POINT *ppt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellView2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellView2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellView2 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IShellView2 * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IShellView2 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            __RPC__in IShellView2 * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            __RPC__in IShellView2 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            __RPC__in IShellView2 * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            __RPC__in IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            __RPC__in IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            __RPC__in IShellView2 * This,
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView2 * This,
            /* [annotation][in] */ 
            __in  DWORD dwReserved,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [annotation][in] */ 
            __in  LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            __RPC__in IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            __RPC__in IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            __RPC__in IShellView2 * This,
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetView )( 
            __RPC__in IShellView2 * This,
            /* [out][in] */ __RPC__inout SHELLVIEWID *pvid,
            /* [in] */ ULONG uView);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow2 )( 
            __RPC__in IShellView2 * This,
            /* [in] */ __RPC__in LPSV2CVW2_PARAMS lpParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRename )( 
            __RPC__in IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlNew);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItem )( 
            __RPC__in IShellView2 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ UINT uFlags,
            /* [unique][in] */ __RPC__in_opt POINT *ppt);
        
        END_INTERFACE
    } IShellView2Vtbl;

    interface IShellView2
    {
        CONST_VTBL struct IShellView2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellView2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellView2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellView2_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellView2_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellView2_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#define IShellView2_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#define IShellView2_UIActivate(This,uState)	\
    ( (This)->lpVtbl -> UIActivate(This,uState) ) 

#define IShellView2_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IShellView2_CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd)	\
    ( (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd) ) 

#define IShellView2_DestroyViewWindow(This)	\
    ( (This)->lpVtbl -> DestroyViewWindow(This) ) 

#define IShellView2_GetCurrentInfo(This,pfs)	\
    ( (This)->lpVtbl -> GetCurrentInfo(This,pfs) ) 

#define IShellView2_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    ( (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam) ) 

#define IShellView2_SaveViewState(This)	\
    ( (This)->lpVtbl -> SaveViewState(This) ) 

#define IShellView2_SelectItem(This,pidlItem,uFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags) ) 

#define IShellView2_GetItemObject(This,uItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv) ) 


#define IShellView2_GetView(This,pvid,uView)	\
    ( (This)->lpVtbl -> GetView(This,pvid,uView) ) 

#define IShellView2_CreateViewWindow2(This,lpParams)	\
    ( (This)->lpVtbl -> CreateViewWindow2(This,lpParams) ) 

#define IShellView2_HandleRename(This,pidlNew)	\
    ( (This)->lpVtbl -> HandleRename(This,pidlNew) ) 

#define IShellView2_SelectAndPositionItem(This,pidlItem,uFlags,ppt)	\
    ( (This)->lpVtbl -> SelectAndPositionItem(This,pidlItem,uFlags,ppt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellView2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0021 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0021_v0_0_s_ifspec;

#ifndef __IShellView3_INTERFACE_DEFINED__
#define __IShellView3_INTERFACE_DEFINED__

/* interface IShellView3 */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum _SV3CVW3_FLAGS
    {	SV3CVW3_DEFAULT	= 0,
	SV3CVW3_NONINTERACTIVE	= 0x1,
	SV3CVW3_FORCEVIEWMODE	= 0x2,
	SV3CVW3_FORCEFOLDERFLAGS	= 0x4
    } ;
typedef DWORD SV3CVW3_FLAGS;


EXTERN_C const IID IID_IShellView3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec39fa88-f8af-41c5-8421-38bed28f4673")
    IShellView3 : public IShellView2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow3( 
            /* [in] */ __RPC__in_opt IShellBrowser *psbOwner,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrev,
            /* [in] */ SV3CVW3_FLAGS dwViewFlags,
            /* [in] */ FOLDERFLAGS dwMask,
            /* [in] */ FOLDERFLAGS dwFlags,
            /* [in] */ FOLDERVIEWMODE fvMode,
            /* [unique][in] */ __RPC__in_opt const SHELLVIEWID *pvid,
            /* [in] */ __RPC__in const RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phwndView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellView3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellView3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellView3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellView3 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IShellView3 * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IShellView3 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            __RPC__in IShellView3 * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            __RPC__in IShellView3 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            __RPC__in IShellView3 * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IShellView3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            __RPC__in IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrevious,
            /* [in] */ __RPC__in LPCFOLDERSETTINGS pfs,
            /* [in] */ __RPC__in_opt IShellBrowser *psb,
            /* [in] */ __RPC__in RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            __RPC__in IShellView3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            __RPC__in IShellView3 * This,
            /* [out] */ __RPC__out LPFOLDERSETTINGS pfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView3 * This,
            /* [annotation][in] */ 
            __in  DWORD dwReserved,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfn,
            /* [annotation][in] */ 
            __in  LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            __RPC__in IShellView3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            __RPC__in IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ SVSIF uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            __RPC__in IShellView3 * This,
            /* [in] */ UINT uItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetView )( 
            __RPC__in IShellView3 * This,
            /* [out][in] */ __RPC__inout SHELLVIEWID *pvid,
            /* [in] */ ULONG uView);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow2 )( 
            __RPC__in IShellView3 * This,
            /* [in] */ __RPC__in LPSV2CVW2_PARAMS lpParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRename )( 
            __RPC__in IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlNew);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItem )( 
            __RPC__in IShellView3 * This,
            /* [unique][in] */ __RPC__in_opt PCUITEMID_CHILD pidlItem,
            /* [in] */ UINT uFlags,
            /* [unique][in] */ __RPC__in_opt POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow3 )( 
            __RPC__in IShellView3 * This,
            /* [in] */ __RPC__in_opt IShellBrowser *psbOwner,
            /* [unique][in] */ __RPC__in_opt IShellView *psvPrev,
            /* [in] */ SV3CVW3_FLAGS dwViewFlags,
            /* [in] */ FOLDERFLAGS dwMask,
            /* [in] */ FOLDERFLAGS dwFlags,
            /* [in] */ FOLDERVIEWMODE fvMode,
            /* [unique][in] */ __RPC__in_opt const SHELLVIEWID *pvid,
            /* [in] */ __RPC__in const RECT *prcView,
            /* [out] */ __RPC__deref_out_opt HWND *phwndView);
        
        END_INTERFACE
    } IShellView3Vtbl;

    interface IShellView3
    {
        CONST_VTBL struct IShellView3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellView3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellView3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellView3_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellView3_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellView3_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#define IShellView3_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#define IShellView3_UIActivate(This,uState)	\
    ( (This)->lpVtbl -> UIActivate(This,uState) ) 

#define IShellView3_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IShellView3_CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd)	\
    ( (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,pfs,psb,prcView,phWnd) ) 

#define IShellView3_DestroyViewWindow(This)	\
    ( (This)->lpVtbl -> DestroyViewWindow(This) ) 

#define IShellView3_GetCurrentInfo(This,pfs)	\
    ( (This)->lpVtbl -> GetCurrentInfo(This,pfs) ) 

#define IShellView3_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    ( (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam) ) 

#define IShellView3_SaveViewState(This)	\
    ( (This)->lpVtbl -> SaveViewState(This) ) 

#define IShellView3_SelectItem(This,pidlItem,uFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags) ) 

#define IShellView3_GetItemObject(This,uItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv) ) 


#define IShellView3_GetView(This,pvid,uView)	\
    ( (This)->lpVtbl -> GetView(This,pvid,uView) ) 

#define IShellView3_CreateViewWindow2(This,lpParams)	\
    ( (This)->lpVtbl -> CreateViewWindow2(This,lpParams) ) 

#define IShellView3_HandleRename(This,pidlNew)	\
    ( (This)->lpVtbl -> HandleRename(This,pidlNew) ) 

#define IShellView3_SelectAndPositionItem(This,pidlItem,uFlags,ppt)	\
    ( (This)->lpVtbl -> SelectAndPositionItem(This,pidlItem,uFlags,ppt) ) 


#define IShellView3_CreateViewWindow3(This,psbOwner,psvPrev,dwViewFlags,dwMask,dwFlags,fvMode,pvid,prcView,phwndView)	\
    ( (This)->lpVtbl -> CreateViewWindow3(This,psbOwner,psvPrev,dwViewFlags,dwMask,dwFlags,fvMode,pvid,prcView,phwndView) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellView3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0022 */
/* [local] */ 

#endif  // NTDDI_VISTA
#ifdef _FIX_ENABLEMODELESS_CONFLICT
#undef    EnableModeless 
#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0022_v0_0_s_ifspec;

#ifndef __IFolderView_INTERFACE_DEFINED__
#define __IFolderView_INTERFACE_DEFINED__

/* interface IFolderView */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cde725b0-ccc9-4519-917e-325d72fab4ce")
    IFolderView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentViewMode( 
            /* [out] */ __RPC__out UINT *pViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentViewMode( 
            /* [in] */ UINT ViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ int iItemIndex,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemCount( 
            /* [in] */ UINT uFlags,
            /* [out] */ __RPC__out int *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Items( 
            /* [in] */ UINT uFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectionMarkedItem( 
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocusedItem( 
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemPosition( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out POINT *ppt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpacing( 
            /* [unique][out][in] */ __RPC__inout_opt POINT *ppt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSpacing( 
            /* [out] */ __RPC__out POINT *ppt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoArrange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndPositionItems( 
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][unique][in][disable_consistency_check] */ __RPC__in_ecount_full_opt(cidl) POINT *apt,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentViewMode )( 
            __RPC__in IFolderView * This,
            /* [out] */ __RPC__out UINT *pViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentViewMode )( 
            __RPC__in IFolderView * This,
            /* [in] */ UINT ViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IFolderView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            __RPC__in IFolderView * This,
            /* [in] */ int iItemIndex,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *ItemCount )( 
            __RPC__in IFolderView * This,
            /* [in] */ UINT uFlags,
            /* [out] */ __RPC__out int *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *Items )( 
            __RPC__in IFolderView * This,
            /* [in] */ UINT uFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionMarkedItem )( 
            __RPC__in IFolderView * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusedItem )( 
            __RPC__in IFolderView * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemPosition )( 
            __RPC__in IFolderView * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpacing )( 
            __RPC__in IFolderView * This,
            /* [unique][out][in] */ __RPC__inout_opt POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSpacing )( 
            __RPC__in IFolderView * This,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoArrange )( 
            __RPC__in IFolderView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            __RPC__in IFolderView * This,
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItems )( 
            __RPC__in IFolderView * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][unique][in][disable_consistency_check] */ __RPC__in_ecount_full_opt(cidl) POINT *apt,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IFolderViewVtbl;

    interface IFolderView
    {
        CONST_VTBL struct IFolderViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderView_GetCurrentViewMode(This,pViewMode)	\
    ( (This)->lpVtbl -> GetCurrentViewMode(This,pViewMode) ) 

#define IFolderView_SetCurrentViewMode(This,ViewMode)	\
    ( (This)->lpVtbl -> SetCurrentViewMode(This,ViewMode) ) 

#define IFolderView_GetFolder(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetFolder(This,riid,ppv) ) 

#define IFolderView_Item(This,iItemIndex,ppidl)	\
    ( (This)->lpVtbl -> Item(This,iItemIndex,ppidl) ) 

#define IFolderView_ItemCount(This,uFlags,pcItems)	\
    ( (This)->lpVtbl -> ItemCount(This,uFlags,pcItems) ) 

#define IFolderView_Items(This,uFlags,riid,ppv)	\
    ( (This)->lpVtbl -> Items(This,uFlags,riid,ppv) ) 

#define IFolderView_GetSelectionMarkedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetSelectionMarkedItem(This,piItem) ) 

#define IFolderView_GetFocusedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetFocusedItem(This,piItem) ) 

#define IFolderView_GetItemPosition(This,pidl,ppt)	\
    ( (This)->lpVtbl -> GetItemPosition(This,pidl,ppt) ) 

#define IFolderView_GetSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetSpacing(This,ppt) ) 

#define IFolderView_GetDefaultSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetDefaultSpacing(This,ppt) ) 

#define IFolderView_GetAutoArrange(This)	\
    ( (This)->lpVtbl -> GetAutoArrange(This) ) 

#define IFolderView_SelectItem(This,iItem,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,iItem,dwFlags) ) 

#define IFolderView_SelectAndPositionItems(This,cidl,apidl,apt,dwFlags)	\
    ( (This)->lpVtbl -> SelectAndPositionItems(This,cidl,apidl,apt,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0023 */
/* [local] */ 

#define SID_SFolderView IID_IFolderView    // folder view, usually IFolderView
#if (NTDDI_VERSION >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0023_v0_0_s_ifspec;

#ifndef __ISearchBoxInfo_INTERFACE_DEFINED__
#define __ISearchBoxInfo_INTERFACE_DEFINED__

/* interface ISearchBoxInfo */
/* [object][uuid] */ 


EXTERN_C const IID IID_ISearchBoxInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6af6e03f-d664-4ef4-9626-f7e0ed36755e")
    ISearchBoxInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCondition( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppsz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchBoxInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISearchBoxInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISearchBoxInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISearchBoxInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCondition )( 
            __RPC__in ISearchBoxInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            __RPC__in ISearchBoxInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppsz);
        
        END_INTERFACE
    } ISearchBoxInfoVtbl;

    interface ISearchBoxInfo
    {
        CONST_VTBL struct ISearchBoxInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchBoxInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchBoxInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchBoxInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchBoxInfo_GetCondition(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetCondition(This,riid,ppv) ) 

#define ISearchBoxInfo_GetText(This,ppsz)	\
    ( (This)->lpVtbl -> GetText(This,ppsz) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchBoxInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0024 */
/* [local] */ 

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
#if (NTDDI_VERSION >= NTDDI_VISTA) || (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef NO_SHOBJIDL_SORTDIRECTION
/* [v1_enum] */ 
enum tagSORTDIRECTION
    {	SORT_DESCENDING	= -1,
	SORT_ASCENDING	= 1
    } ;
#endif  // NO_SHOBJIDL_SORTDIRECTION
typedef int SORTDIRECTION;

typedef struct SORTCOLUMN
    {
    PROPERTYKEY propkey;
    SORTDIRECTION direction;
    } 	SORTCOLUMN;

typedef /* [v1_enum] */ 
enum FVTEXTTYPE
    {	FVST_EMPTYTEXT	= 0
    } 	FVTEXTTYPE;


typedef HRESULT DEPRECATED_HRESULT;

#if defined(__cplusplus)
#define DEPRECATED_HRESULT HRESULT DECLSPEC_DEPRECATED
#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0024_v0_0_s_ifspec;

#ifndef __IFolderView2_INTERFACE_DEFINED__
#define __IFolderView2_INTERFACE_DEFINED__

/* interface IFolderView2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderView2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1af3a467-214f-4298-908e-06b03e0b39f9")
    IFolderView2 : public IFolderView
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGroupBy( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ BOOL fAscending) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetGroupBy( 
            /* [annotation][out] */ 
            __out  PROPERTYKEY *pkey,
            /* [annotation][out] */ 
            __out_opt  BOOL *pfAscending) = 0;
        
        virtual DEPRECATED_HRESULT STDMETHODCALLTYPE SetViewProperty( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual DEPRECATED_HRESULT STDMETHODCALLTYPE GetViewProperty( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual DEPRECATED_HRESULT STDMETHODCALLTYPE SetTileViewProperties( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropList) = 0;
        
        virtual DEPRECATED_HRESULT STDMETHODCALLTYPE SetExtendedTileViewProperties( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ FVTEXTTYPE iType,
            /* [in] */ __RPC__in LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentFolderFlags( 
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFolderFlags( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortColumnCount( 
            /* [out] */ __RPC__out int *pcColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSortColumns( 
            /* [size_is][in] */ __RPC__in_ecount_full(cColumns) const SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortColumns( 
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int iItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisibleItem( 
            /* [in] */ int iStart,
            /* [in] */ BOOL fPrevious,
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItem( 
            /* [in] */ int iStart,
            /* [out] */ __RPC__out int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ BOOL fNoneImpliesFolder,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectionState( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeVerbOnSelection( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCSTR pszVerb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewModeAndIconSize( 
            /* [in] */ FOLDERVIEWMODE uViewMode,
            /* [in] */ int iImageSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewModeAndIconSize( 
            /* [out] */ __RPC__out FOLDERVIEWMODE *puViewMode,
            /* [out] */ __RPC__out int *piImageSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGroupSubsetCount( 
            /* [in] */ UINT cVisibleRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupSubsetCount( 
            /* [out] */ __RPC__out UINT *pcVisibleRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRedraw( 
            /* [in] */ BOOL fRedrawOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMoveInSameFolder( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoRename( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderView2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderView2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentViewMode )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out UINT *pViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentViewMode )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ UINT ViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ int iItemIndex,
            /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *ItemCount )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ UINT uFlags,
            /* [out] */ __RPC__out int *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *Items )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ UINT uFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionMarkedItem )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusedItem )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemPosition )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpacing )( 
            __RPC__in IFolderView2 * This,
            /* [unique][out][in] */ __RPC__inout_opt POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSpacing )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out POINT *ppt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoArrange )( 
            __RPC__in IFolderView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItems )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][unique][in][disable_consistency_check] */ __RPC__in_ecount_full_opt(cidl) POINT *apt,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupBy )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ BOOL fAscending);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetGroupBy )( 
            IFolderView2 * This,
            /* [annotation][out] */ 
            __out  PROPERTYKEY *pkey,
            /* [annotation][out] */ 
            __out_opt  BOOL *pfAscending);
        
        DEPRECATED_HRESULT ( STDMETHODCALLTYPE *SetViewProperty )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        DEPRECATED_HRESULT ( STDMETHODCALLTYPE *GetViewProperty )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        DEPRECATED_HRESULT ( STDMETHODCALLTYPE *SetTileViewProperties )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropList);
        
        DEPRECATED_HRESULT ( STDMETHODCALLTYPE *SetExtendedTileViewProperties )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropList);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ FVTEXTTYPE iType,
            /* [in] */ __RPC__in LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentFolderFlags )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentFolderFlags )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortColumnCount )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out int *pcColumns);
        
        HRESULT ( STDMETHODCALLTYPE *SetSortColumns )( 
            __RPC__in IFolderView2 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cColumns) const SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortColumns )( 
            __RPC__in IFolderView2 * This,
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) SORTCOLUMN *rgSortColumns,
            /* [in] */ int cColumns);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ int iItem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibleItem )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ int iStart,
            /* [in] */ BOOL fPrevious,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItem )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ int iStart,
            /* [out] */ __RPC__out int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ BOOL fNoneImpliesFolder,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsia);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionState )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeVerbOnSelection )( 
            __RPC__in IFolderView2 * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCSTR pszVerb);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewModeAndIconSize )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ FOLDERVIEWMODE uViewMode,
            /* [in] */ int iImageSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewModeAndIconSize )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out FOLDERVIEWMODE *puViewMode,
            /* [out] */ __RPC__out int *piImageSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupSubsetCount )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ UINT cVisibleRows);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupSubsetCount )( 
            __RPC__in IFolderView2 * This,
            /* [out] */ __RPC__out UINT *pcVisibleRows);
        
        HRESULT ( STDMETHODCALLTYPE *SetRedraw )( 
            __RPC__in IFolderView2 * This,
            /* [in] */ BOOL fRedrawOn);
        
        HRESULT ( STDMETHODCALLTYPE *IsMoveInSameFolder )( 
            __RPC__in IFolderView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoRename )( 
            __RPC__in IFolderView2 * This);
        
        END_INTERFACE
    } IFolderView2Vtbl;

    interface IFolderView2
    {
        CONST_VTBL struct IFolderView2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderView2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderView2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderView2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderView2_GetCurrentViewMode(This,pViewMode)	\
    ( (This)->lpVtbl -> GetCurrentViewMode(This,pViewMode) ) 

#define IFolderView2_SetCurrentViewMode(This,ViewMode)	\
    ( (This)->lpVtbl -> SetCurrentViewMode(This,ViewMode) ) 

#define IFolderView2_GetFolder(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetFolder(This,riid,ppv) ) 

#define IFolderView2_Item(This,iItemIndex,ppidl)	\
    ( (This)->lpVtbl -> Item(This,iItemIndex,ppidl) ) 

#define IFolderView2_ItemCount(This,uFlags,pcItems)	\
    ( (This)->lpVtbl -> ItemCount(This,uFlags,pcItems) ) 

#define IFolderView2_Items(This,uFlags,riid,ppv)	\
    ( (This)->lpVtbl -> Items(This,uFlags,riid,ppv) ) 

#define IFolderView2_GetSelectionMarkedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetSelectionMarkedItem(This,piItem) ) 

#define IFolderView2_GetFocusedItem(This,piItem)	\
    ( (This)->lpVtbl -> GetFocusedItem(This,piItem) ) 

#define IFolderView2_GetItemPosition(This,pidl,ppt)	\
    ( (This)->lpVtbl -> GetItemPosition(This,pidl,ppt) ) 

#define IFolderView2_GetSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetSpacing(This,ppt) ) 

#define IFolderView2_GetDefaultSpacing(This,ppt)	\
    ( (This)->lpVtbl -> GetDefaultSpacing(This,ppt) ) 

#define IFolderView2_GetAutoArrange(This)	\
    ( (This)->lpVtbl -> GetAutoArrange(This) ) 

#define IFolderView2_SelectItem(This,iItem,dwFlags)	\
    ( (This)->lpVtbl -> SelectItem(This,iItem,dwFlags) ) 

#define IFolderView2_SelectAndPositionItems(This,cidl,apidl,apt,dwFlags)	\
    ( (This)->lpVtbl -> SelectAndPositionItems(This,cidl,apidl,apt,dwFlags) ) 


#define IFolderView2_SetGroupBy(This,key,fAscending)	\
    ( (This)->lpVtbl -> SetGroupBy(This,key,fAscending) ) 

#define IFolderView2_GetGroupBy(This,pkey,pfAscending)	\
    ( (This)->lpVtbl -> GetGroupBy(This,pkey,pfAscending) ) 

#define IFolderView2_SetViewProperty(This,pidl,propkey,propvar)	\
    ( (This)->lpVtbl -> SetViewProperty(This,pidl,propkey,propvar) ) 

#define IFolderView2_GetViewProperty(This,pidl,propkey,ppropvar)	\
    ( (This)->lpVtbl -> GetViewProperty(This,pidl,propkey,ppropvar) ) 

#define IFolderView2_SetTileViewProperties(This,pidl,pszPropList)	\
    ( (This)->lpVtbl -> SetTileViewProperties(This,pidl,pszPropList) ) 

#define IFolderView2_SetExtendedTileViewProperties(This,pidl,pszPropList)	\
    ( (This)->lpVtbl -> SetExtendedTileViewProperties(This,pidl,pszPropList) ) 

#define IFolderView2_SetText(This,iType,pwszText)	\
    ( (This)->lpVtbl -> SetText(This,iType,pwszText) ) 

#define IFolderView2_SetCurrentFolderFlags(This,dwMask,dwFlags)	\
    ( (This)->lpVtbl -> SetCurrentFolderFlags(This,dwMask,dwFlags) ) 

#define IFolderView2_GetCurrentFolderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetCurrentFolderFlags(This,pdwFlags) ) 

#define IFolderView2_GetSortColumnCount(This,pcColumns)	\
    ( (This)->lpVtbl -> GetSortColumnCount(This,pcColumns) ) 

#define IFolderView2_SetSortColumns(This,rgSortColumns,cColumns)	\
    ( (This)->lpVtbl -> SetSortColumns(This,rgSortColumns,cColumns) ) 

#define IFolderView2_GetSortColumns(This,rgSortColumns,cColumns)	\
    ( (This)->lpVtbl -> GetSortColumns(This,rgSortColumns,cColumns) ) 

#define IFolderView2_GetItem(This,iItem,riid,ppv)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,riid,ppv) ) 

#define IFolderView2_GetVisibleItem(This,iStart,fPrevious,piItem)	\
    ( (This)->lpVtbl -> GetVisibleItem(This,iStart,fPrevious,piItem) ) 

#define IFolderView2_GetSelectedItem(This,iStart,piItem)	\
    ( (This)->lpVtbl -> GetSelectedItem(This,iStart,piItem) ) 

#define IFolderView2_GetSelection(This,fNoneImpliesFolder,ppsia)	\
    ( (This)->lpVtbl -> GetSelection(This,fNoneImpliesFolder,ppsia) ) 

#define IFolderView2_GetSelectionState(This,pidl,pdwFlags)	\
    ( (This)->lpVtbl -> GetSelectionState(This,pidl,pdwFlags) ) 

#define IFolderView2_InvokeVerbOnSelection(This,pszVerb)	\
    ( (This)->lpVtbl -> InvokeVerbOnSelection(This,pszVerb) ) 

#define IFolderView2_SetViewModeAndIconSize(This,uViewMode,iImageSize)	\
    ( (This)->lpVtbl -> SetViewModeAndIconSize(This,uViewMode,iImageSize) ) 

#define IFolderView2_GetViewModeAndIconSize(This,puViewMode,piImageSize)	\
    ( (This)->lpVtbl -> GetViewModeAndIconSize(This,puViewMode,piImageSize) ) 

#define IFolderView2_SetGroupSubsetCount(This,cVisibleRows)	\
    ( (This)->lpVtbl -> SetGroupSubsetCount(This,cVisibleRows) ) 

#define IFolderView2_GetGroupSubsetCount(This,pcVisibleRows)	\
    ( (This)->lpVtbl -> GetGroupSubsetCount(This,pcVisibleRows) ) 

#define IFolderView2_SetRedraw(This,fRedrawOn)	\
    ( (This)->lpVtbl -> SetRedraw(This,fRedrawOn) ) 

#define IFolderView2_IsMoveInSameFolder(This)	\
    ( (This)->lpVtbl -> IsMoveInSameFolder(This) ) 

#define IFolderView2_DoRename(This)	\
    ( (This)->lpVtbl -> DoRename(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IFolderView2_RemoteGetGroupBy_Proxy( 
    __RPC__in IFolderView2 * This,
    /* [out] */ __RPC__out PROPERTYKEY *pkey,
    /* [out] */ __RPC__out BOOL *pfAscending);


void __RPC_STUB IFolderView2_RemoteGetGroupBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderView2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0025 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0025_v0_0_s_ifspec;

#ifndef __IFolderViewSettings_INTERFACE_DEFINED__
#define __IFolderViewSettings_INTERFACE_DEFINED__

/* interface IFolderViewSettings */
/* [object][uuid] */ 


EXTERN_C const IID IID_IFolderViewSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae8c987d-8797-4ed3-be72-2a47dd938db0")
    IFolderViewSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetColumnPropertyList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupByProperty( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey,
            /* [out] */ __RPC__out BOOL *pfGroupAscending) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewMode( 
            /* [out] */ __RPC__out FOLDERLOGICALVIEWMODE *plvm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconSize( 
            /* [out] */ __RPC__out UINT *puIconSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderFlags( 
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderMask,
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortColumns( 
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cColumnsIn, *pcColumnsOut) SORTCOLUMN *rgSortColumns,
            /* [in] */ UINT cColumnsIn,
            /* [out] */ __RPC__out UINT *pcColumnsOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupSubsetCount( 
            /* [out] */ __RPC__out UINT *pcVisibleRows) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderViewSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderViewSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderViewSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnPropertyList )( 
            __RPC__in IFolderViewSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupByProperty )( 
            __RPC__in IFolderViewSettings * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey,
            /* [out] */ __RPC__out BOOL *pfGroupAscending);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewMode )( 
            __RPC__in IFolderViewSettings * This,
            /* [out] */ __RPC__out FOLDERLOGICALVIEWMODE *plvm);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconSize )( 
            __RPC__in IFolderViewSettings * This,
            /* [out] */ __RPC__out UINT *puIconSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderFlags )( 
            __RPC__in IFolderViewSettings * This,
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderMask,
            /* [out] */ __RPC__out FOLDERFLAGS *pfolderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortColumns )( 
            __RPC__in IFolderViewSettings * This,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cColumnsIn, *pcColumnsOut) SORTCOLUMN *rgSortColumns,
            /* [in] */ UINT cColumnsIn,
            /* [out] */ __RPC__out UINT *pcColumnsOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupSubsetCount )( 
            __RPC__in IFolderViewSettings * This,
            /* [out] */ __RPC__out UINT *pcVisibleRows);
        
        END_INTERFACE
    } IFolderViewSettingsVtbl;

    interface IFolderViewSettings
    {
        CONST_VTBL struct IFolderViewSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderViewSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderViewSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderViewSettings_GetColumnPropertyList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetColumnPropertyList(This,riid,ppv) ) 

#define IFolderViewSettings_GetGroupByProperty(This,pkey,pfGroupAscending)	\
    ( (This)->lpVtbl -> GetGroupByProperty(This,pkey,pfGroupAscending) ) 

#define IFolderViewSettings_GetViewMode(This,plvm)	\
    ( (This)->lpVtbl -> GetViewMode(This,plvm) ) 

#define IFolderViewSettings_GetIconSize(This,puIconSize)	\
    ( (This)->lpVtbl -> GetIconSize(This,puIconSize) ) 

#define IFolderViewSettings_GetFolderFlags(This,pfolderMask,pfolderFlags)	\
    ( (This)->lpVtbl -> GetFolderFlags(This,pfolderMask,pfolderFlags) ) 

#define IFolderViewSettings_GetSortColumns(This,rgSortColumns,cColumnsIn,pcColumnsOut)	\
    ( (This)->lpVtbl -> GetSortColumns(This,rgSortColumns,cColumnsIn,pcColumnsOut) ) 

#define IFolderViewSettings_GetGroupSubsetCount(This,pcVisibleRows)	\
    ( (This)->lpVtbl -> GetGroupSubsetCount(This,pcVisibleRows) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderViewSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0026 */
/* [local] */ 

#endif  // NTDDI_VISTA
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0026_v0_0_s_ifspec;

#ifndef __IPreviewHandlerVisuals_INTERFACE_DEFINED__
#define __IPreviewHandlerVisuals_INTERFACE_DEFINED__

/* interface IPreviewHandlerVisuals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPreviewHandlerVisuals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("196bf9a5-b346-4ef0-aa1e-5dcdb76768b1")
    IPreviewHandlerVisuals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ COLORREF color) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            /* [in] */ __RPC__in const LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextColor( 
            /* [in] */ COLORREF color) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewHandlerVisualsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPreviewHandlerVisuals * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPreviewHandlerVisuals * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPreviewHandlerVisuals * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundColor )( 
            __RPC__in IPreviewHandlerVisuals * This,
            /* [in] */ COLORREF color);
        
        HRESULT ( STDMETHODCALLTYPE *SetFont )( 
            __RPC__in IPreviewHandlerVisuals * This,
            /* [in] */ __RPC__in const LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextColor )( 
            __RPC__in IPreviewHandlerVisuals * This,
            /* [in] */ COLORREF color);
        
        END_INTERFACE
    } IPreviewHandlerVisualsVtbl;

    interface IPreviewHandlerVisuals
    {
        CONST_VTBL struct IPreviewHandlerVisualsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewHandlerVisuals_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewHandlerVisuals_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewHandlerVisuals_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewHandlerVisuals_SetBackgroundColor(This,color)	\
    ( (This)->lpVtbl -> SetBackgroundColor(This,color) ) 

#define IPreviewHandlerVisuals_SetFont(This,plf)	\
    ( (This)->lpVtbl -> SetFont(This,plf) ) 

#define IPreviewHandlerVisuals_SetTextColor(This,color)	\
    ( (This)->lpVtbl -> SetTextColor(This,color) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewHandlerVisuals_INTERFACE_DEFINED__ */


#ifndef __IVisualProperties_INTERFACE_DEFINED__
#define __IVisualProperties_INTERFACE_DEFINED__

/* interface IVisualProperties */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum VPWATERMARKFLAGS
    {	VPWF_DEFAULT	= 0,
	VPWF_ALPHABLEND	= 0x1
    } 	VPWATERMARKFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(VPWATERMARKFLAGS)
typedef /* [v1_enum] */ 
enum VPCOLORFLAGS
    {	VPCF_TEXT	= 1,
	VPCF_BACKGROUND	= 2,
	VPCF_SORTCOLUMN	= 3,
	VPCF_SUBTEXT	= 4,
	VPCF_TEXTBACKGROUND	= 5
    } 	VPCOLORFLAGS;


EXTERN_C const IID IID_IVisualProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e693cf68-d967-4112-8763-99172aee5e5a")
    IVisualProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetWatermark( 
            /* [unique][in] */ __RPC__in_opt HBITMAP hbmp,
            /* [in] */ VPWATERMARKFLAGS vpwf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColor( 
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [in] */ COLORREF cr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColor( 
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [out] */ __RPC__out COLORREF *pcr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemHeight( 
            /* [in] */ int cyItemInPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemHeight( 
            /* [out] */ __RPC__out int *cyItemInPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            /* [in] */ __RPC__in const LOGFONTW *plf,
            /* [in] */ BOOL bRedraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            /* [out] */ __RPC__out LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTheme( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszSubAppName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszSubIdList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVisualPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVisualProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVisualProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVisualProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWatermark )( 
            __RPC__in IVisualProperties * This,
            /* [unique][in] */ __RPC__in_opt HBITMAP hbmp,
            /* [in] */ VPWATERMARKFLAGS vpwf);
        
        HRESULT ( STDMETHODCALLTYPE *SetColor )( 
            __RPC__in IVisualProperties * This,
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [in] */ COLORREF cr);
        
        HRESULT ( STDMETHODCALLTYPE *GetColor )( 
            __RPC__in IVisualProperties * This,
            /* [in] */ VPCOLORFLAGS vpcf,
            /* [out] */ __RPC__out COLORREF *pcr);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemHeight )( 
            __RPC__in IVisualProperties * This,
            /* [in] */ int cyItemInPixels);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemHeight )( 
            __RPC__in IVisualProperties * This,
            /* [out] */ __RPC__out int *cyItemInPixels);
        
        HRESULT ( STDMETHODCALLTYPE *SetFont )( 
            __RPC__in IVisualProperties * This,
            /* [in] */ __RPC__in const LOGFONTW *plf,
            /* [in] */ BOOL bRedraw);
        
        HRESULT ( STDMETHODCALLTYPE *GetFont )( 
            __RPC__in IVisualProperties * This,
            /* [out] */ __RPC__out LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetTheme )( 
            __RPC__in IVisualProperties * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszSubAppName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszSubIdList);
        
        END_INTERFACE
    } IVisualPropertiesVtbl;

    interface IVisualProperties
    {
        CONST_VTBL struct IVisualPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVisualProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVisualProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVisualProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVisualProperties_SetWatermark(This,hbmp,vpwf)	\
    ( (This)->lpVtbl -> SetWatermark(This,hbmp,vpwf) ) 

#define IVisualProperties_SetColor(This,vpcf,cr)	\
    ( (This)->lpVtbl -> SetColor(This,vpcf,cr) ) 

#define IVisualProperties_GetColor(This,vpcf,pcr)	\
    ( (This)->lpVtbl -> GetColor(This,vpcf,pcr) ) 

#define IVisualProperties_SetItemHeight(This,cyItemInPixels)	\
    ( (This)->lpVtbl -> SetItemHeight(This,cyItemInPixels) ) 

#define IVisualProperties_GetItemHeight(This,cyItemInPixels)	\
    ( (This)->lpVtbl -> GetItemHeight(This,cyItemInPixels) ) 

#define IVisualProperties_SetFont(This,plf,bRedraw)	\
    ( (This)->lpVtbl -> SetFont(This,plf,bRedraw) ) 

#define IVisualProperties_GetFont(This,plf)	\
    ( (This)->lpVtbl -> GetFont(This,plf) ) 

#define IVisualProperties_SetTheme(This,pszSubAppName,pszSubIdList)	\
    ( (This)->lpVtbl -> SetTheme(This,pszSubAppName,pszSubIdList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVisualProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0028 */
/* [local] */ 

#endif  // _WIN32_IE_IE70
#define CDBOSC_SETFOCUS     0x00000000
#define CDBOSC_KILLFOCUS    0x00000001
#define CDBOSC_SELCHANGE    0x00000002
#define CDBOSC_RENAME       0x00000003
#define CDBOSC_STATECHANGE  0x00000004


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0028_v0_0_s_ifspec;

#ifndef __ICommDlgBrowser_INTERFACE_DEFINED__
#define __ICommDlgBrowser_INTERFACE_DEFINED__

/* interface ICommDlgBrowser */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICommDlgBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F1-0000-0000-C000-000000000046")
    ICommDlgBrowser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDefaultCommand( 
            /* [in] */ __RPC__in_opt IShellView *ppshv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncludeObject( 
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommDlgBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICommDlgBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICommDlgBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICommDlgBrowser * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultCommand )( 
            __RPC__in ICommDlgBrowser * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            __RPC__in ICommDlgBrowser * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeObject )( 
            __RPC__in ICommDlgBrowser * This,
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        END_INTERFACE
    } ICommDlgBrowserVtbl;

    interface ICommDlgBrowser
    {
        CONST_VTBL struct ICommDlgBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommDlgBrowser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommDlgBrowser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommDlgBrowser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommDlgBrowser_OnDefaultCommand(This,ppshv)	\
    ( (This)->lpVtbl -> OnDefaultCommand(This,ppshv) ) 

#define ICommDlgBrowser_OnStateChange(This,ppshv,uChange)	\
    ( (This)->lpVtbl -> OnStateChange(This,ppshv,uChange) ) 

#define ICommDlgBrowser_IncludeObject(This,ppshv,pidl)	\
    ( (This)->lpVtbl -> IncludeObject(This,ppshv,pidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommDlgBrowser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0029 */
/* [local] */ 

typedef ICommDlgBrowser *LPCOMMDLGBROWSER;

#define SID_SExplorerBrowserFrame IID_ICommDlgBrowser
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define CDB2N_CONTEXTMENU_DONE  0x00000001
#define CDB2N_CONTEXTMENU_START 0x00000002
#define CDB2GVF_SHOWALLFILES        0x00000001
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define CDB2GVF_ISFILESAVE          0x00000002 // is file save, else file open
#define CDB2GVF_ALLOWPREVIEWPANE    0x00000004
#define CDB2GVF_NOSELECTVERB        0x00000008
#define CDB2GVF_NOINCLUDEITEM       0x00000010
#define CDB2GVF_ISFOLDERPICKER      0x00000020
#define CDB2GVF_ADDSHIELD           0x00000040   // when CDB2GVF_NOSELECTVERB is not specified this flag controls the display of a LUA shield on the Select menu item
#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0029_v0_0_s_ifspec;

#ifndef __ICommDlgBrowser2_INTERFACE_DEFINED__
#define __ICommDlgBrowser2_INTERFACE_DEFINED__

/* interface ICommDlgBrowser2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICommDlgBrowser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10339516-2894-11d2-9039-00C04F8EEB3E")
    ICommDlgBrowser2 : public ICommDlgBrowser
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ DWORD dwNotifyType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMenuText( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchMax) LPWSTR pszText,
            /* [in] */ int cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommDlgBrowser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICommDlgBrowser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICommDlgBrowser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultCommand )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeObject )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ DWORD dwNotifyType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuText )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchMax) LPWSTR pszText,
            /* [in] */ int cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in ICommDlgBrowser2 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        END_INTERFACE
    } ICommDlgBrowser2Vtbl;

    interface ICommDlgBrowser2
    {
        CONST_VTBL struct ICommDlgBrowser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommDlgBrowser2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommDlgBrowser2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommDlgBrowser2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommDlgBrowser2_OnDefaultCommand(This,ppshv)	\
    ( (This)->lpVtbl -> OnDefaultCommand(This,ppshv) ) 

#define ICommDlgBrowser2_OnStateChange(This,ppshv,uChange)	\
    ( (This)->lpVtbl -> OnStateChange(This,ppshv,uChange) ) 

#define ICommDlgBrowser2_IncludeObject(This,ppshv,pidl)	\
    ( (This)->lpVtbl -> IncludeObject(This,ppshv,pidl) ) 


#define ICommDlgBrowser2_Notify(This,ppshv,dwNotifyType)	\
    ( (This)->lpVtbl -> Notify(This,ppshv,dwNotifyType) ) 

#define ICommDlgBrowser2_GetDefaultMenuText(This,ppshv,pszText,cchMax)	\
    ( (This)->lpVtbl -> GetDefaultMenuText(This,ppshv,pszText,cchMax) ) 

#define ICommDlgBrowser2_GetViewFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommDlgBrowser2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0030 */
/* [local] */ 

typedef ICommDlgBrowser2 *LPCOMMDLGBROWSER2;

#endif  // NTDDI_WIN2K
#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0030_v0_0_s_ifspec;

#ifndef __ICommDlgBrowser3_INTERFACE_DEFINED__
#define __ICommDlgBrowser3_INTERFACE_DEFINED__

/* interface ICommDlgBrowser3 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICommDlgBrowser3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8ad25a1-3294-41ee-8165-71174bd01c57")
    ICommDlgBrowser3 : public ICommDlgBrowser2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnColumnClicked( 
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ int iColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFilter( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchFileSpec) LPWSTR pszFileSpec,
            /* [in] */ int cchFileSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPreViewCreated( 
            /* [in] */ __RPC__in_opt IShellView *ppshv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommDlgBrowser3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICommDlgBrowser3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICommDlgBrowser3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultCommand )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ ULONG uChange);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeObject )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [unique][in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ DWORD dwNotifyType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuText )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchMax) LPWSTR pszText,
            /* [in] */ int cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnColumnClicked )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv,
            /* [in] */ int iColumn);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentFilter )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchFileSpec) LPWSTR pszFileSpec,
            /* [in] */ int cchFileSpec);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreViewCreated )( 
            __RPC__in ICommDlgBrowser3 * This,
            /* [in] */ __RPC__in_opt IShellView *ppshv);
        
        END_INTERFACE
    } ICommDlgBrowser3Vtbl;

    interface ICommDlgBrowser3
    {
        CONST_VTBL struct ICommDlgBrowser3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommDlgBrowser3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommDlgBrowser3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommDlgBrowser3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommDlgBrowser3_OnDefaultCommand(This,ppshv)	\
    ( (This)->lpVtbl -> OnDefaultCommand(This,ppshv) ) 

#define ICommDlgBrowser3_OnStateChange(This,ppshv,uChange)	\
    ( (This)->lpVtbl -> OnStateChange(This,ppshv,uChange) ) 

#define ICommDlgBrowser3_IncludeObject(This,ppshv,pidl)	\
    ( (This)->lpVtbl -> IncludeObject(This,ppshv,pidl) ) 


#define ICommDlgBrowser3_Notify(This,ppshv,dwNotifyType)	\
    ( (This)->lpVtbl -> Notify(This,ppshv,dwNotifyType) ) 

#define ICommDlgBrowser3_GetDefaultMenuText(This,ppshv,pszText,cchMax)	\
    ( (This)->lpVtbl -> GetDefaultMenuText(This,ppshv,pszText,cchMax) ) 

#define ICommDlgBrowser3_GetViewFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,pdwFlags) ) 


#define ICommDlgBrowser3_OnColumnClicked(This,ppshv,iColumn)	\
    ( (This)->lpVtbl -> OnColumnClicked(This,ppshv,iColumn) ) 

#define ICommDlgBrowser3_GetCurrentFilter(This,pszFileSpec,cchFileSpec)	\
    ( (This)->lpVtbl -> GetCurrentFilter(This,pszFileSpec,cchFileSpec) ) 

#define ICommDlgBrowser3_OnPreViewCreated(This,ppshv)	\
    ( (This)->lpVtbl -> OnPreViewCreated(This,ppshv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommDlgBrowser3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0031 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum CM_MASK
    {	CM_MASK_WIDTH	= 0x1,
	CM_MASK_DEFAULTWIDTH	= 0x2,
	CM_MASK_IDEALWIDTH	= 0x4,
	CM_MASK_NAME	= 0x8,
	CM_MASK_STATE	= 0x10
    } 	CM_MASK;

DEFINE_ENUM_FLAG_OPERATORS(CM_MASK)
typedef /* [v1_enum] */ 
enum CM_STATE
    {	CM_STATE_NONE	= 0,
	CM_STATE_VISIBLE	= 0x1,
	CM_STATE_FIXEDWIDTH	= 0x2,
	CM_STATE_NOSORTBYFOLDERNESS	= 0x4,
	CM_STATE_ALWAYSVISIBLE	= 0x8
    } 	CM_STATE;

DEFINE_ENUM_FLAG_OPERATORS(CM_STATE)
typedef /* [v1_enum] */ 
enum CM_ENUM_FLAGS
    {	CM_ENUM_ALL	= 0x1,
	CM_ENUM_VISIBLE	= 0x2
    } 	CM_ENUM_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(CM_ENUM_FLAGS)
typedef /* [v1_enum] */ 
enum CM_SET_WIDTH_VALUE
    {	CM_WIDTH_USEDEFAULT	= -1,
	CM_WIDTH_AUTOSIZE	= -2
    } 	CM_SET_WIDTH_VALUE;

typedef struct CM_COLUMNINFO
    {
    DWORD cbSize;
    DWORD dwMask;
    DWORD dwState;
    UINT uWidth;
    UINT uDefaultWidth;
    UINT uIdealWidth;
    WCHAR wszName[ 80 ];
    } 	CM_COLUMNINFO;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0031_v0_0_s_ifspec;

#ifndef __IColumnManager_INTERFACE_DEFINED__
#define __IColumnManager_INTERFACE_DEFINED__

/* interface IColumnManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IColumnManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8ec27bb-3f3b-4042-b10a-4acfd924d453")
    IColumnManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetColumnInfo( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in const CM_COLUMNINFO *pcmci) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnInfo( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out CM_COLUMNINFO *pcmci) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [out] */ __RPC__out UINT *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumns( 
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumns( 
            /* [size_is][in] */ __RPC__in_ecount_full(cVisible) const PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IColumnManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IColumnManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IColumnManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetColumnInfo )( 
            __RPC__in IColumnManager * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in const CM_COLUMNINFO *pcmci);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnInfo )( 
            __RPC__in IColumnManager * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out CM_COLUMNINFO *pcmci);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnCount )( 
            __RPC__in IColumnManager * This,
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [out] */ __RPC__out UINT *puCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumns )( 
            __RPC__in IColumnManager * This,
            /* [in] */ CM_ENUM_FLAGS dwFlags,
            /* [size_is][out] */ __RPC__out_ecount_full(cColumns) PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cColumns);
        
        HRESULT ( STDMETHODCALLTYPE *SetColumns )( 
            __RPC__in IColumnManager * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cVisible) const PROPERTYKEY *rgkeyOrder,
            /* [in] */ UINT cVisible);
        
        END_INTERFACE
    } IColumnManagerVtbl;

    interface IColumnManager
    {
        CONST_VTBL struct IColumnManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IColumnManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IColumnManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IColumnManager_SetColumnInfo(This,propkey,pcmci)	\
    ( (This)->lpVtbl -> SetColumnInfo(This,propkey,pcmci) ) 

#define IColumnManager_GetColumnInfo(This,propkey,pcmci)	\
    ( (This)->lpVtbl -> GetColumnInfo(This,propkey,pcmci) ) 

#define IColumnManager_GetColumnCount(This,dwFlags,puCount)	\
    ( (This)->lpVtbl -> GetColumnCount(This,dwFlags,puCount) ) 

#define IColumnManager_GetColumns(This,dwFlags,rgkeyOrder,cColumns)	\
    ( (This)->lpVtbl -> GetColumns(This,dwFlags,rgkeyOrder,cColumns) ) 

#define IColumnManager_SetColumns(This,rgkeyOrder,cVisible)	\
    ( (This)->lpVtbl -> SetColumns(This,rgkeyOrder,cVisible) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IColumnManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0032 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0032_v0_0_s_ifspec;

#ifndef __IFolderFilterSite_INTERFACE_DEFINED__
#define __IFolderFilterSite_INTERFACE_DEFINED__

/* interface IFolderFilterSite */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderFilterSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0A651F5-B48B-11d2-B5ED-006097C686F6")
    IFolderFilterSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderFilterSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderFilterSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderFilterSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderFilterSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            __RPC__in IFolderFilterSite * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IFolderFilterSiteVtbl;

    interface IFolderFilterSite
    {
        CONST_VTBL struct IFolderFilterSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderFilterSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderFilterSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderFilterSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderFilterSite_SetFilter(This,punk)	\
    ( (This)->lpVtbl -> SetFilter(This,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderFilterSite_INTERFACE_DEFINED__ */


#ifndef __IFolderFilter_INTERFACE_DEFINED__
#define __IFolderFilter_INTERFACE_DEFINED__

/* interface IFolderFilter */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFolderFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E")
    IFolderFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShouldShow( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumFlags( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out][in] */ __RPC__inout DWORD *pgrfFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldShow )( 
            __RPC__in IFolderFilter * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlFolder,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumFlags )( 
            __RPC__in IFolderFilter * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out][in] */ __RPC__inout DWORD *pgrfFlags);
        
        END_INTERFACE
    } IFolderFilterVtbl;

    interface IFolderFilter
    {
        CONST_VTBL struct IFolderFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderFilter_ShouldShow(This,psf,pidlFolder,pidlItem)	\
    ( (This)->lpVtbl -> ShouldShow(This,psf,pidlFolder,pidlItem) ) 

#define IFolderFilter_GetEnumFlags(This,psf,pidlFolder,phwnd,pgrfFlags)	\
    ( (This)->lpVtbl -> GetEnumFlags(This,psf,pidlFolder,phwnd,pgrfFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderFilter_INTERFACE_DEFINED__ */


#ifndef __IInputObjectSite_INTERFACE_DEFINED__
#define __IInputObjectSite_INTERFACE_DEFINED__

/* interface IInputObjectSite */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInputObjectSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1DB8392-7331-11D0-8C99-00A0C92DBFE8")
    IInputObjectSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnFocusChangeIS( 
            /* [unique][in] */ __RPC__in_opt IUnknown *punkObj,
            /* [in] */ BOOL fSetFocus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputObjectSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInputObjectSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInputObjectSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInputObjectSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFocusChangeIS )( 
            __RPC__in IInputObjectSite * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkObj,
            /* [in] */ BOOL fSetFocus);
        
        END_INTERFACE
    } IInputObjectSiteVtbl;

    interface IInputObjectSite
    {
        CONST_VTBL struct IInputObjectSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputObjectSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputObjectSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputObjectSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputObjectSite_OnFocusChangeIS(This,punkObj,fSetFocus)	\
    ( (This)->lpVtbl -> OnFocusChangeIS(This,punkObj,fSetFocus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputObjectSite_INTERFACE_DEFINED__ */


#ifndef __IInputObject_INTERFACE_DEFINED__
#define __IInputObject_INTERFACE_DEFINED__

/* interface IInputObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInputObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68284fAA-6A48-11D0-8c78-00C04fd918b4")
    IInputObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UIActivateIO( 
            /* [in] */ BOOL fActivate,
            /* [unique][in] */ __RPC__in_opt MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasFocusIO( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorIO( 
            /* [in] */ __RPC__in MSG *pMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInputObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInputObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInputObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivateIO )( 
            __RPC__in IInputObject * This,
            /* [in] */ BOOL fActivate,
            /* [unique][in] */ __RPC__in_opt MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *HasFocusIO )( 
            __RPC__in IInputObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorIO )( 
            __RPC__in IInputObject * This,
            /* [in] */ __RPC__in MSG *pMsg);
        
        END_INTERFACE
    } IInputObjectVtbl;

    interface IInputObject
    {
        CONST_VTBL struct IInputObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputObject_UIActivateIO(This,fActivate,pMsg)	\
    ( (This)->lpVtbl -> UIActivateIO(This,fActivate,pMsg) ) 

#define IInputObject_HasFocusIO(This)	\
    ( (This)->lpVtbl -> HasFocusIO(This) ) 

#define IInputObject_TranslateAcceleratorIO(This,pMsg)	\
    ( (This)->lpVtbl -> TranslateAcceleratorIO(This,pMsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputObject_INTERFACE_DEFINED__ */


#ifndef __IInputObject2_INTERFACE_DEFINED__
#define __IInputObject2_INTERFACE_DEFINED__

/* interface IInputObject2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IInputObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6915C085-510B-44cd-94AF-28DFA56CF92B")
    IInputObject2 : public IInputObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorGlobal( 
            /* [annotation][in] */ 
            __in  MSG *pMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInputObject2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInputObject2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInputObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivateIO )( 
            IInputObject2 * This,
            /* [in] */ BOOL fActivate,
            /* [unique][in] */ MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *HasFocusIO )( 
            IInputObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorIO )( 
            IInputObject2 * This,
            /* [in] */ MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorGlobal )( 
            IInputObject2 * This,
            /* [annotation][in] */ 
            __in  MSG *pMsg);
        
        END_INTERFACE
    } IInputObject2Vtbl;

    interface IInputObject2
    {
        CONST_VTBL struct IInputObject2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputObject2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputObject2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputObject2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputObject2_UIActivateIO(This,fActivate,pMsg)	\
    ( (This)->lpVtbl -> UIActivateIO(This,fActivate,pMsg) ) 

#define IInputObject2_HasFocusIO(This)	\
    ( (This)->lpVtbl -> HasFocusIO(This) ) 

#define IInputObject2_TranslateAcceleratorIO(This,pMsg)	\
    ( (This)->lpVtbl -> TranslateAcceleratorIO(This,pMsg) ) 


#define IInputObject2_TranslateAcceleratorGlobal(This,pMsg)	\
    ( (This)->lpVtbl -> TranslateAcceleratorGlobal(This,pMsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputObject2_INTERFACE_DEFINED__ */


#ifndef __IShellIcon_INTERFACE_DEFINED__
#define __IShellIcon_INTERFACE_DEFINED__

/* interface IShellIcon */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellIcon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E5-0000-0000-C000-000000000046")
    IShellIcon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIconOf( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ UINT flags,
            /* [out] */ __RPC__out int *pIconIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellIconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellIcon * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellIcon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellIcon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconOf )( 
            __RPC__in IShellIcon * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
            /* [in] */ UINT flags,
            /* [out] */ __RPC__out int *pIconIndex);
        
        END_INTERFACE
    } IShellIconVtbl;

    interface IShellIcon
    {
        CONST_VTBL struct IShellIconVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellIcon_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellIcon_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellIcon_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellIcon_GetIconOf(This,pidl,flags,pIconIndex)	\
    ( (This)->lpVtbl -> GetIconOf(This,pidl,flags,pIconIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellIcon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0038 */
/* [local] */ 

#define SBSP_DEFBROWSER         0x0000
#define SBSP_SAMEBROWSER        0x0001
#define SBSP_NEWBROWSER         0x0002
#define SBSP_DEFMODE            0x0000
#define SBSP_OPENMODE           0x0010
#define SBSP_EXPLOREMODE        0x0020
#define SBSP_HELPMODE           0x0040
#define SBSP_NOTRANSFERHIST     0x0080
#define SBSP_ABSOLUTE           0x0000
#define SBSP_RELATIVE           0x1000
#define SBSP_PARENT             0x2000
#define SBSP_NAVIGATEBACK       0x4000
#define SBSP_NAVIGATEFORWARD    0x8000
#define SBSP_ALLOW_AUTONAVIGATE   0x00010000
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SBSP_KEEPSAMETEMPLATE     0x00020000
#define SBSP_KEEPWORDWHEELTEXT    0x00040000
#define SBSP_ACTIVATE_NOFOCUS     0x00080000
#define SBSP_CREATENOHISTORY      0x00100000
#define SBSP_PLAYNOSOUND          0x00200000
#endif  // (NTDDI_VERSION >= NTDDI_VISTA)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SBSP_CALLERUNTRUSTED      0x00800000
#define SBSP_TRUSTFIRSTDOWNLOAD   0x01000000
#define SBSP_UNTRUSTEDFORDOWNLOAD 0x02000000
#endif  // _WIN32_IE_IE60SP2
#define SBSP_NOAUTOSELECT         0x04000000
#define SBSP_WRITENOHISTORY       0x08000000
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SBSP_TRUSTEDFORACTIVEX    0x10000000
#endif  // _WIN32_IE_IE60SP2
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SBSP_FEEDNAVIGATION       0x20000000
#endif  // _WIN32_IE_IE70
#define SBSP_REDIRECT                     0x40000000
#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define FCW_STATUS         0x0001
#define FCW_TOOLBAR        0x0002
#define FCW_TREE           0x0003
#define FCW_INTERNETBAR    0x0006
#define FCW_PROGRESS       0x0008
#if (_WIN32_IE >= 0x0700)
#endif
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004
#ifdef _NEVER_
typedef LPARAM LPTBBUTTONSB;

#else //!_NEVER_
#include <commctrl.h>
typedef LPTBBUTTON LPTBBUTTONSB;
#endif //_NEVER_


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0038_v0_0_s_ifspec;

#ifndef __IShellBrowser_INTERFACE_DEFINED__
#define __IShellBrowser_INTERFACE_DEFINED__

/* interface IShellBrowser */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E2-0000-0000-C000-000000000046")
    IShellBrowser : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertMenusSB( 
            /* [in] */ __RPC__in HMENU hmenuShared,
            /* [out][in] */ __RPC__inout LPOLEMENUGROUPWIDTHS lpMenuWidths) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuSB( 
            /* [unique][in] */ __RPC__in_opt HMENU hmenuShared,
            /* [unique][in] */ __RPC__in_opt HOLEMENU holemenuRes,
            /* [unique][in] */ __RPC__in_opt HWND hwndActiveObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMenusSB( 
            /* [in] */ __RPC__in HMENU hmenuShared) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusTextSB( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModelessSB( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorSB( 
            /* [in] */ __RPC__in MSG *pmsg,
            /* [in] */ WORD wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseObject( 
            /* [unique][in] */ __RPC__in_opt PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT wFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewStateStream( 
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IStream **ppStrm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlWindow( 
            /* [in] */ UINT id,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SendControlMsg( 
            /* [annotation][in] */ 
            __in  UINT id,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam,
            /* [annotation][out] */ 
            __out_opt  LRESULT *pret) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryActiveShellView( 
            /* [out] */ __RPC__deref_out_opt IShellView **ppshv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnViewWindowActive( 
            /* [in] */ __RPC__in_opt IShellView *pshv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetToolbarItems( 
            /* [annotation][in] */ 
            __in_ecount_opt(nButtons)  LPTBBUTTONSB lpButtons,
            /* [annotation][in] */ 
            __in  UINT nButtons,
            /* [annotation][in] */ 
            __in  UINT uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellBrowser * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IShellBrowser * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *InsertMenusSB )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ __RPC__in HMENU hmenuShared,
            /* [out][in] */ __RPC__inout LPOLEMENUGROUPWIDTHS lpMenuWidths);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuSB )( 
            __RPC__in IShellBrowser * This,
            /* [unique][in] */ __RPC__in_opt HMENU hmenuShared,
            /* [unique][in] */ __RPC__in_opt HOLEMENU holemenuRes,
            /* [unique][in] */ __RPC__in_opt HWND hwndActiveObject);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMenusSB )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ __RPC__in HMENU hmenuShared);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusTextSB )( 
            __RPC__in IShellBrowser * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModelessSB )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorSB )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ __RPC__in MSG *pmsg,
            /* [in] */ WORD wID);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseObject )( 
            __RPC__in IShellBrowser * This,
            /* [unique][in] */ __RPC__in_opt PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT wFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewStateStream )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IStream **ppStrm);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlWindow )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ UINT id,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SendControlMsg )( 
            IShellBrowser * This,
            /* [annotation][in] */ 
            __in  UINT id,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam,
            /* [annotation][out] */ 
            __out_opt  LRESULT *pret);
        
        HRESULT ( STDMETHODCALLTYPE *QueryActiveShellView )( 
            __RPC__in IShellBrowser * This,
            /* [out] */ __RPC__deref_out_opt IShellView **ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnViewWindowActive )( 
            __RPC__in IShellBrowser * This,
            /* [in] */ __RPC__in_opt IShellView *pshv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetToolbarItems )( 
            IShellBrowser * This,
            /* [annotation][in] */ 
            __in_ecount_opt(nButtons)  LPTBBUTTONSB lpButtons,
            /* [annotation][in] */ 
            __in  UINT nButtons,
            /* [annotation][in] */ 
            __in  UINT uFlags);
        
        END_INTERFACE
    } IShellBrowserVtbl;

    interface IShellBrowser
    {
        CONST_VTBL struct IShellBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellBrowser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellBrowser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellBrowser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellBrowser_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IShellBrowser_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IShellBrowser_InsertMenusSB(This,hmenuShared,lpMenuWidths)	\
    ( (This)->lpVtbl -> InsertMenusSB(This,hmenuShared,lpMenuWidths) ) 

#define IShellBrowser_SetMenuSB(This,hmenuShared,holemenuRes,hwndActiveObject)	\
    ( (This)->lpVtbl -> SetMenuSB(This,hmenuShared,holemenuRes,hwndActiveObject) ) 

#define IShellBrowser_RemoveMenusSB(This,hmenuShared)	\
    ( (This)->lpVtbl -> RemoveMenusSB(This,hmenuShared) ) 

#define IShellBrowser_SetStatusTextSB(This,pszStatusText)	\
    ( (This)->lpVtbl -> SetStatusTextSB(This,pszStatusText) ) 

#define IShellBrowser_EnableModelessSB(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModelessSB(This,fEnable) ) 

#define IShellBrowser_TranslateAcceleratorSB(This,pmsg,wID)	\
    ( (This)->lpVtbl -> TranslateAcceleratorSB(This,pmsg,wID) ) 

#define IShellBrowser_BrowseObject(This,pidl,wFlags)	\
    ( (This)->lpVtbl -> BrowseObject(This,pidl,wFlags) ) 

#define IShellBrowser_GetViewStateStream(This,grfMode,ppStrm)	\
    ( (This)->lpVtbl -> GetViewStateStream(This,grfMode,ppStrm) ) 

#define IShellBrowser_GetControlWindow(This,id,phwnd)	\
    ( (This)->lpVtbl -> GetControlWindow(This,id,phwnd) ) 

#define IShellBrowser_SendControlMsg(This,id,uMsg,wParam,lParam,pret)	\
    ( (This)->lpVtbl -> SendControlMsg(This,id,uMsg,wParam,lParam,pret) ) 

#define IShellBrowser_QueryActiveShellView(This,ppshv)	\
    ( (This)->lpVtbl -> QueryActiveShellView(This,ppshv) ) 

#define IShellBrowser_OnViewWindowActive(This,pshv)	\
    ( (This)->lpVtbl -> OnViewWindowActive(This,pshv) ) 

#define IShellBrowser_SetToolbarItems(This,lpButtons,nButtons,uFlags)	\
    ( (This)->lpVtbl -> SetToolbarItems(This,lpButtons,nButtons,uFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellBrowser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0039 */
/* [local] */ 

typedef IShellBrowser *LPSHELLBROWSER;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0039_v0_0_s_ifspec;

#ifndef __IProfferService_INTERFACE_DEFINED__
#define __IProfferService_INTERFACE_DEFINED__

/* interface IProfferService */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IProfferService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb728b20-f786-11ce-92ad-00aa00a74cd0")
    IProfferService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProfferService( 
            /* [in] */ __RPC__in REFGUID guidService,
            /* [in] */ __RPC__in_opt IServiceProvider *psp,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeService( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProfferServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProfferService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProfferService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProfferService * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProfferService )( 
            __RPC__in IProfferService * This,
            /* [in] */ __RPC__in REFGUID guidService,
            /* [in] */ __RPC__in_opt IServiceProvider *psp,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeService )( 
            __RPC__in IProfferService * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IProfferServiceVtbl;

    interface IProfferService
    {
        CONST_VTBL struct IProfferServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProfferService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProfferService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProfferService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProfferService_ProfferService(This,guidService,psp,pdwCookie)	\
    ( (This)->lpVtbl -> ProfferService(This,guidService,psp,pdwCookie) ) 

#define IProfferService_RevokeService(This,dwCookie)	\
    ( (This)->lpVtbl -> RevokeService(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProfferService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0040 */
/* [local] */ 

#define SID_SProfferService IID_IProfferService    // nearest service that you can proffer to
#define STR_DONT_RESOLVE_LINK      L"Don't Resolve Link"
#define STR_GET_ASYNC_HANDLER L"GetAsyncHandler"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0040_v0_0_s_ifspec;

#ifndef __IShellItem_INTERFACE_DEFINED__
#define __IShellItem_INTERFACE_DEFINED__

/* interface IShellItem */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum _SIGDN
    {	SIGDN_NORMALDISPLAY	= 0,
	SIGDN_PARENTRELATIVEPARSING	= ( int  )0x80018001,
	SIGDN_DESKTOPABSOLUTEPARSING	= ( int  )0x80028000,
	SIGDN_PARENTRELATIVEEDITING	= ( int  )0x80031001,
	SIGDN_DESKTOPABSOLUTEEDITING	= ( int  )0x8004c000,
	SIGDN_FILESYSPATH	= ( int  )0x80058000,
	SIGDN_URL	= ( int  )0x80068000,
	SIGDN_PARENTRELATIVEFORADDRESSBAR	= ( int  )0x8007c001,
	SIGDN_PARENTRELATIVE	= ( int  )0x80080001
    } 	SIGDN;

/* [v1_enum] */ 
enum _SICHINTF
    {	SICHINT_DISPLAY	= 0,
	SICHINT_ALLFIELDS	= ( int  )0x80000000,
	SICHINT_CANONICAL	= 0x10000000,
	SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL	= 0x20000000
    } ;
typedef DWORD SICHINTF;


EXTERN_C const IID IID_IShellItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43826d1e-e718-42ee-bc55-a1e261c37bfe")
    IShellItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ SICHINTF hint,
            /* [out] */ __RPC__out int *piOrder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            __RPC__in IShellItem * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            __RPC__in IShellItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IShellItem * This,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IShellItem * This,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            __RPC__in IShellItem * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ SICHINTF hint,
            /* [out] */ __RPC__out int *piOrder);
        
        END_INTERFACE
    } IShellItemVtbl;

    interface IShellItem
    {
        CONST_VTBL struct IShellItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItem_BindToHandler(This,pbc,bhid,riid,ppv)	\
    ( (This)->lpVtbl -> BindToHandler(This,pbc,bhid,riid,ppv) ) 

#define IShellItem_GetParent(This,ppsi)	\
    ( (This)->lpVtbl -> GetParent(This,ppsi) ) 

#define IShellItem_GetDisplayName(This,sigdnName,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,sigdnName,ppszName) ) 

#define IShellItem_GetAttributes(This,sfgaoMask,psfgaoAttribs)	\
    ( (This)->lpVtbl -> GetAttributes(This,sfgaoMask,psfgaoAttribs) ) 

#define IShellItem_Compare(This,psi,hint,piOrder)	\
    ( (This)->lpVtbl -> Compare(This,psi,hint,piOrder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0041 */
/* [local] */ 

SHSTDAPI_(PIDLIST_ABSOLUTE) SHSimpleIDListFromPath(LPCWSTR pszPath);
#if (_WIN32_IE >= _WIN32_IE_IE70)
// CLSID_ShellItem create and init helper APIs. produce IShellItem derived interfaces from these different expressions of an item
SHSTDAPI SHCreateItemFromIDList(__in PCIDLIST_ABSOLUTE pidl, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateItemFromParsingName(__in PCWSTR pszPath, __in_opt IBindCtx *pbc, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateItemWithParent(__in_opt PCIDLIST_ABSOLUTE pidlParent, __in_opt IShellFolder *psfParent, __in PCUITEMID_CHILD pidl, __in REFIID riid, __deref_out void **ppvItem);
SHSTDAPI SHCreateItemFromRelativeName(__in IShellItem *psiParent, __in PCWSTR pszName, __in_opt IBindCtx* pbc, __in REFIID riid, __deref_out void **ppv);
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHCreateItemInKnownFolder(REFKNOWNFOLDERID kfid, DWORD dwKFFlags, __in_opt PCWSTR pszItem, REFIID riid, __deref_out void **ppv);
// get the IDList expression from an object, works with objects that support IPersistIDlist or IPersistIDlist like CLSID_ShellItem and most shell folders
SHSTDAPI SHGetIDListFromObject(__in IUnknown *punk, __deref_out PIDLIST_ABSOLUTE *ppidl);
// similar to SHGetIDListFromObject but returns an IShellItem-based object (preferred for performance if the IDList is already bound to a folder)
SHSTDAPI SHGetItemFromObject(__in IUnknown *punk, __in REFIID riid, __deref_out void **ppv);
// these APIs return object that support IPropertyStore or related interfaces
SHSTDAPI SHGetPropertyStoreFromIDList(__in PCIDLIST_ABSOLUTE pidl, __in GETPROPERTYSTOREFLAGS flags, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHGetPropertyStoreFromParsingName(__in PCWSTR pszPath, __in_opt IBindCtx *pbc, __in GETPROPERTYSTOREFLAGS flags, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHGetNameFromIDList(__in PCIDLIST_ABSOLUTE pidl, __in SIGDN sigdnName, __deref_out PWSTR *ppszName);
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef /* [v1_enum] */ 
enum DATAOBJ_GET_ITEM_FLAGS
    {	DOGIF_DEFAULT	= 0,
	DOGIF_TRAVERSE_LINK	= 0x1,
	DOGIF_NO_HDROP	= 0x2,
	DOGIF_NO_URL	= 0x4,
	DOGIF_ONLY_IF_ONE	= 0x8
    } 	DATAOBJ_GET_ITEM_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(DATAOBJ_GET_ITEM_FLAGS)
STDAPI SHGetItemFromDataObject(__in IDataObject *pdtobj, __in DATAOBJ_GET_ITEM_FLAGS dwFlags, __in REFIID riid, __deref_out void **ppv);
#endif // (NTDDI_VERSION >= NTDDI_WIN7)
#define STR_GPS_HANDLERPROPERTIESONLY      L"GPS_HANDLERPROPERTIESONLY"
#define STR_GPS_FASTPROPERTIESONLY         L"GPS_FASTPROPERTIESONLY"
#define STR_GPS_OPENSLOWITEM               L"GPS_OPENSLOWITEM"
#define STR_GPS_DELAYCREATION              L"GPS_DELAYCREATION"
#define STR_GPS_BESTEFFORT                 L"GPS_BESTEFFORT"
#define STR_GPS_NO_OPLOCK                  L"GPS_NO_OPLOCK"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0041_v0_0_s_ifspec;

#ifndef __IShellItem2_INTERFACE_DEFINED__
#define __IShellItem2_INTERFACE_DEFINED__

/* interface IShellItem2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7e9fb0d3-919f-4307-ab2e-9b1860310c93")
    IShellItem2 : public IShellItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreWithCreateObject( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in_opt IUnknown *punkCreateObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
            /* [size_is][in] */ __RPC__in_ecount_full(cKeys) const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionList( 
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSID( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileTime( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FILETIME *pft) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInt32( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUInt32( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pui) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUInt64( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBool( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            __RPC__in IShellItem2 * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            __RPC__in IShellItem2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ SICHINTF hint,
            /* [out] */ __RPC__out int *piOrder);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreWithCreateObject )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in_opt IUnknown *punkCreateObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            __RPC__in IShellItem2 * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cKeys) const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionList )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in IShellItem2 * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTime )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FILETIME *pft);
        
        HRESULT ( STDMETHODCALLTYPE *GetInt32 )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetUInt32 )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pui);
        
        HRESULT ( STDMETHODCALLTYPE *GetUInt64 )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pull);
        
        HRESULT ( STDMETHODCALLTYPE *GetBool )( 
            __RPC__in IShellItem2 * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pf);
        
        END_INTERFACE
    } IShellItem2Vtbl;

    interface IShellItem2
    {
        CONST_VTBL struct IShellItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItem2_BindToHandler(This,pbc,bhid,riid,ppv)	\
    ( (This)->lpVtbl -> BindToHandler(This,pbc,bhid,riid,ppv) ) 

#define IShellItem2_GetParent(This,ppsi)	\
    ( (This)->lpVtbl -> GetParent(This,ppsi) ) 

#define IShellItem2_GetDisplayName(This,sigdnName,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,sigdnName,ppszName) ) 

#define IShellItem2_GetAttributes(This,sfgaoMask,psfgaoAttribs)	\
    ( (This)->lpVtbl -> GetAttributes(This,sfgaoMask,psfgaoAttribs) ) 

#define IShellItem2_Compare(This,psi,hint,piOrder)	\
    ( (This)->lpVtbl -> Compare(This,psi,hint,piOrder) ) 


#define IShellItem2_GetPropertyStore(This,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,riid,ppv) ) 

#define IShellItem2_GetPropertyStoreWithCreateObject(This,flags,punkCreateObject,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreWithCreateObject(This,flags,punkCreateObject,riid,ppv) ) 

#define IShellItem2_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 

#define IShellItem2_GetPropertyDescriptionList(This,keyType,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionList(This,keyType,riid,ppv) ) 

#define IShellItem2_Update(This,pbc)	\
    ( (This)->lpVtbl -> Update(This,pbc) ) 

#define IShellItem2_GetProperty(This,key,ppropvar)	\
    ( (This)->lpVtbl -> GetProperty(This,key,ppropvar) ) 

#define IShellItem2_GetCLSID(This,key,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,key,pclsid) ) 

#define IShellItem2_GetFileTime(This,key,pft)	\
    ( (This)->lpVtbl -> GetFileTime(This,key,pft) ) 

#define IShellItem2_GetInt32(This,key,pi)	\
    ( (This)->lpVtbl -> GetInt32(This,key,pi) ) 

#define IShellItem2_GetString(This,key,ppsz)	\
    ( (This)->lpVtbl -> GetString(This,key,ppsz) ) 

#define IShellItem2_GetUInt32(This,key,pui)	\
    ( (This)->lpVtbl -> GetUInt32(This,key,pui) ) 

#define IShellItem2_GetUInt64(This,key,pull)	\
    ( (This)->lpVtbl -> GetUInt64(This,key,pull) ) 

#define IShellItem2_GetBool(This,key,pf)	\
    ( (This)->lpVtbl -> GetBool(This,key,pf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItem2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0042 */
/* [local] */ 

/* [v1_enum] */ 
enum _SIIGBF
    {	SIIGBF_RESIZETOFIT	= 0,
	SIIGBF_BIGGERSIZEOK	= 0x1,
	SIIGBF_MEMORYONLY	= 0x2,
	SIIGBF_ICONONLY	= 0x4,
	SIIGBF_THUMBNAILONLY	= 0x8,
	SIIGBF_INCACHEONLY	= 0x10
    } ;
typedef int SIIGBF;


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0042_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0042_v0_0_s_ifspec;

#ifndef __IShellItemImageFactory_INTERFACE_DEFINED__
#define __IShellItemImageFactory_INTERFACE_DEFINED__

/* interface IShellItemImageFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellItemImageFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bcc18b79-ba16-442f-80c4-8a59c30c463b")
    IShellItemImageFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImage( 
            /* [in] */ SIZE size,
            /* [in] */ SIIGBF flags,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phbm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemImageFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellItemImageFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellItemImageFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellItemImageFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetImage )( 
            __RPC__in IShellItemImageFactory * This,
            /* [in] */ SIZE size,
            /* [in] */ SIIGBF flags,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phbm);
        
        END_INTERFACE
    } IShellItemImageFactoryVtbl;

    interface IShellItemImageFactory
    {
        CONST_VTBL struct IShellItemImageFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemImageFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemImageFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemImageFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemImageFactory_GetImage(This,size,flags,phbm)	\
    ( (This)->lpVtbl -> GetImage(This,size,flags,phbm) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemImageFactory_INTERFACE_DEFINED__ */


#ifndef __IUserAccountChangeCallback_INTERFACE_DEFINED__
#define __IUserAccountChangeCallback_INTERFACE_DEFINED__

/* interface IUserAccountChangeCallback */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IUserAccountChangeCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a561e69a-b4b8-4113-91a5-64c6bcca3430")
    IUserAccountChangeCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPictureChange( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszUserName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserAccountChangeCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUserAccountChangeCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUserAccountChangeCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUserAccountChangeCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPictureChange )( 
            __RPC__in IUserAccountChangeCallback * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszUserName);
        
        END_INTERFACE
    } IUserAccountChangeCallbackVtbl;

    interface IUserAccountChangeCallback
    {
        CONST_VTBL struct IUserAccountChangeCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserAccountChangeCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserAccountChangeCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserAccountChangeCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserAccountChangeCallback_OnPictureChange(This,pszUserName)	\
    ( (This)->lpVtbl -> OnPictureChange(This,pszUserName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserAccountChangeCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0044 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WINXP)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0044_v0_0_s_ifspec;

#ifndef __IEnumShellItems_INTERFACE_DEFINED__
#define __IEnumShellItems_INTERFACE_DEFINED__

/* interface IEnumShellItems */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumShellItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70629033-e363-4a28-a567-0db78006e6d7")
    IEnumShellItems : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IShellItem **rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumShellItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumShellItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumShellItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumShellItems * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumShellItems * This,
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IShellItem **rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumShellItems * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumShellItems * This,
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenum);
        
        END_INTERFACE
    } IEnumShellItemsVtbl;

    interface IEnumShellItems
    {
        CONST_VTBL struct IEnumShellItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumShellItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumShellItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumShellItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumShellItems_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumShellItems_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumShellItems_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumShellItems_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumShellItems_RemoteNext_Proxy( 
    __RPC__in IEnumShellItems * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IShellItem **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumShellItems_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumShellItems_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0045 */
/* [local] */ 

typedef GUID STGTRANSCONFIRMATION;

typedef GUID *LPSTGTRANSCONFIRMATION;

typedef /* [v1_enum] */ 
enum STGOP
    {	STGOP_MOVE	= 1,
	STGOP_COPY	= 2,
	STGOP_SYNC	= 3,
	STGOP_REMOVE	= 5,
	STGOP_RENAME	= 6,
	STGOP_APPLYPROPERTIES	= 8,
	STGOP_NEW	= 10
    } 	STGOP;

#endif  // NTDDI_WINXP
/* [v1_enum] */ 
enum _TRANSFER_SOURCE_FLAGS
    {	TSF_NORMAL	= 0,
	TSF_FAIL_EXIST	= 0,
	TSF_RENAME_EXIST	= 0x1,
	TSF_OVERWRITE_EXIST	= 0x2,
	TSF_ALLOW_DECRYPTION	= 0x4,
	TSF_NO_SECURITY	= 0x8,
	TSF_COPY_CREATION_TIME	= 0x10,
	TSF_COPY_WRITE_TIME	= 0x20,
	TSF_USE_FULL_ACCESS	= 0x40,
	TSF_DELETE_RECYCLE_IF_POSSIBLE	= 0x80,
	TSF_COPY_HARD_LINK	= 0x100,
	TSF_COPY_LOCALIZED_NAME	= 0x200,
	TSF_MOVE_AS_COPY_DELETE	= 0x400,
	TSF_SUSPEND_SHELLEVENTS	= 0x800
    } ;
typedef DWORD TRANSFER_SOURCE_FLAGS;

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0045_v0_0_s_ifspec;

#ifndef __ITransferAdviseSink_INTERFACE_DEFINED__
#define __ITransferAdviseSink_INTERFACE_DEFINED__

/* interface ITransferAdviseSink */
/* [object][local][unique][uuid] */ 

/* [v1_enum] */ 
enum _TRANSFER_ADVISE_STATE
    {	TS_NONE	= 0,
	TS_PERFORMING	= 0x1,
	TS_PREPARING	= 0x2,
	TS_INDETERMINATE	= 0x4
    } ;
typedef DWORD TRANSFER_ADVISE_STATE;


EXTERN_C const IID IID_ITransferAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d594d0d8-8da7-457b-b3b4-ce5dbaac0b88")
    ITransferAdviseSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [annotation][in] */ 
            __in  ULONGLONG ullSizeCurrent,
            /* [annotation][in] */ 
            __in  ULONGLONG ullSizeTotal,
            /* [annotation][in] */ 
            __in  int nFilesCurrent,
            /* [annotation][in] */ 
            __in  int nFilesTotal,
            /* [annotation][in] */ 
            __in  int nFoldersCurrent,
            /* [annotation][in] */ 
            __in  int nFoldersTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTransferState( 
            /* [annotation][in] */ 
            __in  TRANSFER_ADVISE_STATE ts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmOverwrite( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiDestParent,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmEncryptionLoss( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FileFailure( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszItem,
            /* [annotation][in] */ 
            __in  HRESULT hrError,
            /* [annotation][size_is][unique][out] */ 
            __out_ecount_opt(cchRename)  LPWSTR pszRename,
            /* [annotation][in] */ 
            __in  ULONG cchRename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubStreamFailure( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszStreamName,
            /* [annotation][in] */ 
            __in  HRESULT hrError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PropertyFailure( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][unique][in] */ 
            __in_opt  const PROPERTYKEY *pkey,
            /* [annotation][in] */ 
            __in  HRESULT hrError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferAdviseSink * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferAdviseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  ULONGLONG ullSizeCurrent,
            /* [annotation][in] */ 
            __in  ULONGLONG ullSizeTotal,
            /* [annotation][in] */ 
            __in  int nFilesCurrent,
            /* [annotation][in] */ 
            __in  int nFilesTotal,
            /* [annotation][in] */ 
            __in  int nFoldersCurrent,
            /* [annotation][in] */ 
            __in  int nFoldersTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateTransferState )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  TRANSFER_ADVISE_STATE ts);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmOverwrite )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiDestParent,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmEncryptionLoss )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource);
        
        HRESULT ( STDMETHODCALLTYPE *FileFailure )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszItem,
            /* [annotation][in] */ 
            __in  HRESULT hrError,
            /* [annotation][size_is][unique][out] */ 
            __out_ecount_opt(cchRename)  LPWSTR pszRename,
            /* [annotation][in] */ 
            __in  ULONG cchRename);
        
        HRESULT ( STDMETHODCALLTYPE *SubStreamFailure )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszStreamName,
            /* [annotation][in] */ 
            __in  HRESULT hrError);
        
        HRESULT ( STDMETHODCALLTYPE *PropertyFailure )( 
            ITransferAdviseSink * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][unique][in] */ 
            __in_opt  const PROPERTYKEY *pkey,
            /* [annotation][in] */ 
            __in  HRESULT hrError);
        
        END_INTERFACE
    } ITransferAdviseSinkVtbl;

    interface ITransferAdviseSink
    {
        CONST_VTBL struct ITransferAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferAdviseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferAdviseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferAdviseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferAdviseSink_UpdateProgress(This,ullSizeCurrent,ullSizeTotal,nFilesCurrent,nFilesTotal,nFoldersCurrent,nFoldersTotal)	\
    ( (This)->lpVtbl -> UpdateProgress(This,ullSizeCurrent,ullSizeTotal,nFilesCurrent,nFilesTotal,nFoldersCurrent,nFoldersTotal) ) 

#define ITransferAdviseSink_UpdateTransferState(This,ts)	\
    ( (This)->lpVtbl -> UpdateTransferState(This,ts) ) 

#define ITransferAdviseSink_ConfirmOverwrite(This,psiSource,psiDestParent,pszName)	\
    ( (This)->lpVtbl -> ConfirmOverwrite(This,psiSource,psiDestParent,pszName) ) 

#define ITransferAdviseSink_ConfirmEncryptionLoss(This,psiSource)	\
    ( (This)->lpVtbl -> ConfirmEncryptionLoss(This,psiSource) ) 

#define ITransferAdviseSink_FileFailure(This,psi,pszItem,hrError,pszRename,cchRename)	\
    ( (This)->lpVtbl -> FileFailure(This,psi,pszItem,hrError,pszRename,cchRename) ) 

#define ITransferAdviseSink_SubStreamFailure(This,psi,pszStreamName,hrError)	\
    ( (This)->lpVtbl -> SubStreamFailure(This,psi,pszStreamName,hrError) ) 

#define ITransferAdviseSink_PropertyFailure(This,psi,pkey,hrError)	\
    ( (This)->lpVtbl -> PropertyFailure(This,psi,pkey,hrError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferAdviseSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0046 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0046_v0_0_s_ifspec;

#ifndef __ITransferSource_INTERFACE_DEFINED__
#define __ITransferSource_INTERFACE_DEFINED__

/* interface ITransferSource */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ITransferSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00adb003-bde9-45c6-8e29-d09f9353e108")
    ITransferSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [annotation][in] */ 
            __in  ITransferAdviseSink *psink,
            /* [annotation][out] */ 
            __out  DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [annotation][in] */ 
            __in  DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [annotation][in] */ 
            __in  IPropertyChangeArray *pproparray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDst,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszNameDst,
            /* [in] */ TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecycleItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDest,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszNewName,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LinkItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDest,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszNewName,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPropertiesToItem( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultDestinationName( 
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDest,
            /* [annotation][string][out] */ 
            __deref_out  LPWSTR *ppszDestinationName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterFolder( 
            /* [annotation][in] */ 
            __in  IShellItem *psiChildFolderDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFolder( 
            /* [annotation][in] */ 
            __in  IShellItem *psiChildFolderDest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferSource * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  ITransferAdviseSink *psink,
            /* [annotation][out] */ 
            __out  DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IPropertyChangeArray *pproparray);
        
        HRESULT ( STDMETHODCALLTYPE *OpenItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *MoveItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDst,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszNameDst,
            /* [in] */ TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNew);
        
        HRESULT ( STDMETHODCALLTYPE *RecycleItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDest,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags);
        
        HRESULT ( STDMETHODCALLTYPE *RenameItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszNewName,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *LinkItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDest,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszNewName,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPropertiesToItem )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][out] */ 
            __deref_out  IShellItem **ppsiNew);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultDestinationName )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiSource,
            /* [annotation][in] */ 
            __in  IShellItem *psiParentDest,
            /* [annotation][string][out] */ 
            __deref_out  LPWSTR *ppszDestinationName);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiChildFolderDest);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            ITransferSource * This,
            /* [annotation][in] */ 
            __in  IShellItem *psiChildFolderDest);
        
        END_INTERFACE
    } ITransferSourceVtbl;

    interface ITransferSource
    {
        CONST_VTBL struct ITransferSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferSource_Advise(This,psink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,psink,pdwCookie) ) 

#define ITransferSource_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define ITransferSource_SetProperties(This,pproparray)	\
    ( (This)->lpVtbl -> SetProperties(This,pproparray) ) 

#define ITransferSource_OpenItem(This,psi,flags,riid,ppv)	\
    ( (This)->lpVtbl -> OpenItem(This,psi,flags,riid,ppv) ) 

#define ITransferSource_MoveItem(This,psi,psiParentDst,pszNameDst,flags,ppsiNew)	\
    ( (This)->lpVtbl -> MoveItem(This,psi,psiParentDst,pszNameDst,flags,ppsiNew) ) 

#define ITransferSource_RecycleItem(This,psiSource,psiParentDest,flags,ppsiNewDest)	\
    ( (This)->lpVtbl -> RecycleItem(This,psiSource,psiParentDest,flags,ppsiNewDest) ) 

#define ITransferSource_RemoveItem(This,psiSource,flags)	\
    ( (This)->lpVtbl -> RemoveItem(This,psiSource,flags) ) 

#define ITransferSource_RenameItem(This,psiSource,pszNewName,flags,ppsiNewDest)	\
    ( (This)->lpVtbl -> RenameItem(This,psiSource,pszNewName,flags,ppsiNewDest) ) 

#define ITransferSource_LinkItem(This,psiSource,psiParentDest,pszNewName,flags,ppsiNewDest)	\
    ( (This)->lpVtbl -> LinkItem(This,psiSource,psiParentDest,pszNewName,flags,ppsiNewDest) ) 

#define ITransferSource_ApplyPropertiesToItem(This,psiSource,ppsiNew)	\
    ( (This)->lpVtbl -> ApplyPropertiesToItem(This,psiSource,ppsiNew) ) 

#define ITransferSource_GetDefaultDestinationName(This,psiSource,psiParentDest,ppszDestinationName)	\
    ( (This)->lpVtbl -> GetDefaultDestinationName(This,psiSource,psiParentDest,ppszDestinationName) ) 

#define ITransferSource_EnterFolder(This,psiChildFolderDest)	\
    ( (This)->lpVtbl -> EnterFolder(This,psiChildFolderDest) ) 

#define ITransferSource_LeaveFolder(This,psiChildFolderDest)	\
    ( (This)->lpVtbl -> LeaveFolder(This,psiChildFolderDest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0047 */
/* [local] */ 

#endif  // _WIN32_IE_IE70
typedef struct SHELL_ITEM_RESOURCE
    {
    GUID guidType;
    WCHAR szName[ 260 ];
    } 	SHELL_ITEM_RESOURCE;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0047_v0_0_s_ifspec;

#ifndef __IEnumResources_INTERFACE_DEFINED__
#define __IEnumResources_INTERFACE_DEFINED__

/* interface IEnumResources */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dd81fe3-a83c-4da9-a330-47249d345ba1")
    IEnumResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) SHELL_ITEM_RESOURCE *psir,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumResources * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) SHELL_ITEM_RESOURCE *psir,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumResources * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumResources * This,
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr);
        
        END_INTERFACE
    } IEnumResourcesVtbl;

    interface IEnumResources
    {
        CONST_VTBL struct IEnumResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumResources_Next(This,celt,psir,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,psir,pceltFetched) ) 

#define IEnumResources_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumResources_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumResources_Clone(This,ppenumr)	\
    ( (This)->lpVtbl -> Clone(This,ppenumr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumResources_INTERFACE_DEFINED__ */


#ifndef __IShellItemResources_INTERFACE_DEFINED__
#define __IShellItemResources_INTERFACE_DEFINED__

/* interface IShellItemResources */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IShellItemResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff5693be-2ce0-4d48-b5c5-40817d1acdb9")
    IShellItemResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ __RPC__out DWORD *pdwAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out ULONGLONG *pullSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimes( 
            /* [out] */ __RPC__out FILETIME *pftCreation,
            /* [out] */ __RPC__out FILETIME *pftWrite,
            /* [out] */ __RPC__out FILETIME *pftAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [unique][in] */ __RPC__in_opt const FILETIME *pftCreation,
            /* [unique][in] */ __RPC__in_opt const FILETIME *pftWrite,
            /* [unique][in] */ __RPC__in_opt const FILETIME *pftAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResourceDescription( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumResources( 
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportsResource( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenResource( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateResource( 
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarkForDelete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellItemResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellItemResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellItemResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IShellItemResources * This,
            /* [out] */ __RPC__out DWORD *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IShellItemResources * This,
            /* [out] */ __RPC__out ULONGLONG *pullSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimes )( 
            __RPC__in IShellItemResources * This,
            /* [out] */ __RPC__out FILETIME *pftCreation,
            /* [out] */ __RPC__out FILETIME *pftWrite,
            /* [out] */ __RPC__out FILETIME *pftAccess);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            __RPC__in IShellItemResources * This,
            /* [unique][in] */ __RPC__in_opt const FILETIME *pftCreation,
            /* [unique][in] */ __RPC__in_opt const FILETIME *pftWrite,
            /* [unique][in] */ __RPC__in_opt const FILETIME *pftAccess);
        
        HRESULT ( STDMETHODCALLTYPE *GetResourceDescription )( 
            __RPC__in IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *EnumResources )( 
            __RPC__in IShellItemResources * This,
            /* [out] */ __RPC__deref_out_opt IEnumResources **ppenumr);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsResource )( 
            __RPC__in IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir);
        
        HRESULT ( STDMETHODCALLTYPE *OpenResource )( 
            __RPC__in IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CreateResource )( 
            __RPC__in IShellItemResources * This,
            /* [in] */ __RPC__in const SHELL_ITEM_RESOURCE *pcsir,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *MarkForDelete )( 
            __RPC__in IShellItemResources * This);
        
        END_INTERFACE
    } IShellItemResourcesVtbl;

    interface IShellItemResources
    {
        CONST_VTBL struct IShellItemResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemResources_GetAttributes(This,pdwAttributes)	\
    ( (This)->lpVtbl -> GetAttributes(This,pdwAttributes) ) 

#define IShellItemResources_GetSize(This,pullSize)	\
    ( (This)->lpVtbl -> GetSize(This,pullSize) ) 

#define IShellItemResources_GetTimes(This,pftCreation,pftWrite,pftAccess)	\
    ( (This)->lpVtbl -> GetTimes(This,pftCreation,pftWrite,pftAccess) ) 

#define IShellItemResources_SetTimes(This,pftCreation,pftWrite,pftAccess)	\
    ( (This)->lpVtbl -> SetTimes(This,pftCreation,pftWrite,pftAccess) ) 

#define IShellItemResources_GetResourceDescription(This,pcsir,ppszDescription)	\
    ( (This)->lpVtbl -> GetResourceDescription(This,pcsir,ppszDescription) ) 

#define IShellItemResources_EnumResources(This,ppenumr)	\
    ( (This)->lpVtbl -> EnumResources(This,ppenumr) ) 

#define IShellItemResources_SupportsResource(This,pcsir)	\
    ( (This)->lpVtbl -> SupportsResource(This,pcsir) ) 

#define IShellItemResources_OpenResource(This,pcsir,riid,ppv)	\
    ( (This)->lpVtbl -> OpenResource(This,pcsir,riid,ppv) ) 

#define IShellItemResources_CreateResource(This,pcsir,riid,ppv)	\
    ( (This)->lpVtbl -> CreateResource(This,pcsir,riid,ppv) ) 

#define IShellItemResources_MarkForDelete(This)	\
    ( (This)->lpVtbl -> MarkForDelete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemResources_INTERFACE_DEFINED__ */


#ifndef __ITransferDestination_INTERFACE_DEFINED__
#define __ITransferDestination_INTERFACE_DEFINED__

/* interface ITransferDestination */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ITransferDestination;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48addd32-3ca5-4124-abe3-b5a72531b207")
    ITransferDestination : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [annotation][in] */ 
            __in  ITransferAdviseSink *psink,
            /* [annotation][out] */ 
            __out  DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateItem( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName,
            /* [annotation][in] */ 
            __in  DWORD dwAttributes,
            /* [annotation][in] */ 
            __in  ULONGLONG ullSize,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][in] */ 
            __in  REFIID riidItem,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppvItem,
            /* [annotation][in] */ 
            __in  REFIID riidResources,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppvResources) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferDestinationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferDestination * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferDestination * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferDestination * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ITransferDestination * This,
            /* [annotation][in] */ 
            __in  ITransferAdviseSink *psink,
            /* [annotation][out] */ 
            __out  DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ITransferDestination * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *CreateItem )( 
            ITransferDestination * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszName,
            /* [annotation][in] */ 
            __in  DWORD dwAttributes,
            /* [annotation][in] */ 
            __in  ULONGLONG ullSize,
            /* [annotation][in] */ 
            __in  TRANSFER_SOURCE_FLAGS flags,
            /* [annotation][in] */ 
            __in  REFIID riidItem,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppvItem,
            /* [annotation][in] */ 
            __in  REFIID riidResources,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppvResources);
        
        END_INTERFACE
    } ITransferDestinationVtbl;

    interface ITransferDestination
    {
        CONST_VTBL struct ITransferDestinationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferDestination_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferDestination_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferDestination_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferDestination_Advise(This,psink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,psink,pdwCookie) ) 

#define ITransferDestination_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define ITransferDestination_CreateItem(This,pszName,dwAttributes,ullSize,flags,riidItem,ppvItem,riidResources,ppvResources)	\
    ( (This)->lpVtbl -> CreateItem(This,pszName,dwAttributes,ullSize,flags,riidItem,ppvItem,riidResources,ppvResources) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferDestination_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0050 */
/* [local] */ 

#ifdef MIDL_PASS
typedef struct _OVERLAPPED
    {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union 
        {
        struct 
            {
            DWORD Offset;
            DWORD OffsetHigh;
            } 	;
        PVOID Pointer;
        } 	;
    HANDLE hEvent;
    } 	OVERLAPPED;

typedef struct _OVERLAPPED *LPOVERLAPPED;

#endif // MIDL_PASS


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0050_v0_0_s_ifspec;

#ifndef __IStreamAsync_INTERFACE_DEFINED__
#define __IStreamAsync_INTERFACE_DEFINED__

/* interface IStreamAsync */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fe0b6665-e0ca-49b9-a178-2b5cb48d92a5")
    IStreamAsync : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadAsync( 
            /* [annotation][length_is][size_is][out] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ DWORD cb,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, cb)  LPDWORD pcbRead,
            /* [annotation][in] */ 
            __in  LPOVERLAPPED lpOverlapped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAsync( 
            /* [annotation][size_is][in] */ 
            __in_bcount(cb)  const void *lpBuffer,
            /* [in] */ DWORD cb,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, cb)  LPDWORD pcbWritten,
            /* [annotation][in] */ 
            __in  LPOVERLAPPED lpOverlapped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverlappedResult( 
            /* [annotation][in] */ 
            __in  LPOVERLAPPED lpOverlapped,
            /* [annotation][out] */ 
            __out  LPDWORD lpNumberOfBytesTransferred,
            /* [annotation][in] */ 
            __in  BOOL bWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamAsync * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamAsync * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IStreamAsync * This,
            /* [annotation] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IStreamAsync * This,
            /* [annotation] */ 
            __in_bcount(cb)  const void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IStreamAsync * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IStreamAsync * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IStreamAsync * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbRead,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IStreamAsync * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IStreamAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IStreamAsync * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IStreamAsync * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IStreamAsync * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IStreamAsync * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *ReadAsync )( 
            IStreamAsync * This,
            /* [annotation][length_is][size_is][out] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ DWORD cb,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, cb)  LPDWORD pcbRead,
            /* [annotation][in] */ 
            __in  LPOVERLAPPED lpOverlapped);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAsync )( 
            IStreamAsync * This,
            /* [annotation][size_is][in] */ 
            __in_bcount(cb)  const void *lpBuffer,
            /* [in] */ DWORD cb,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, cb)  LPDWORD pcbWritten,
            /* [annotation][in] */ 
            __in  LPOVERLAPPED lpOverlapped);
        
        HRESULT ( STDMETHODCALLTYPE *OverlappedResult )( 
            IStreamAsync * This,
            /* [annotation][in] */ 
            __in  LPOVERLAPPED lpOverlapped,
            /* [annotation][out] */ 
            __out  LPDWORD lpNumberOfBytesTransferred,
            /* [annotation][in] */ 
            __in  BOOL bWait);
        
        HRESULT ( STDMETHODCALLTYPE *CancelIo )( 
            IStreamAsync * This);
        
        END_INTERFACE
    } IStreamAsyncVtbl;

    interface IStreamAsync
    {
        CONST_VTBL struct IStreamAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamAsync_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IStreamAsync_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IStreamAsync_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IStreamAsync_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IStreamAsync_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IStreamAsync_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IStreamAsync_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IStreamAsync_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamAsync_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamAsync_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IStreamAsync_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IStreamAsync_ReadAsync(This,pv,cb,pcbRead,lpOverlapped)	\
    ( (This)->lpVtbl -> ReadAsync(This,pv,cb,pcbRead,lpOverlapped) ) 

#define IStreamAsync_WriteAsync(This,lpBuffer,cb,pcbWritten,lpOverlapped)	\
    ( (This)->lpVtbl -> WriteAsync(This,lpBuffer,cb,pcbWritten,lpOverlapped) ) 

#define IStreamAsync_OverlappedResult(This,lpOverlapped,lpNumberOfBytesTransferred,bWait)	\
    ( (This)->lpVtbl -> OverlappedResult(This,lpOverlapped,lpNumberOfBytesTransferred,bWait) ) 

#define IStreamAsync_CancelIo(This)	\
    ( (This)->lpVtbl -> CancelIo(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamAsync_INTERFACE_DEFINED__ */


#ifndef __IStreamUnbufferedInfo_INTERFACE_DEFINED__
#define __IStreamUnbufferedInfo_INTERFACE_DEFINED__

/* interface IStreamUnbufferedInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamUnbufferedInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a68fdda-1fdc-4c20-8ceb-416643b5a625")
    IStreamUnbufferedInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSectorSize( 
            /* [annotation][out] */ 
            __out  ULONG *pcbSectorSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamUnbufferedInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamUnbufferedInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamUnbufferedInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamUnbufferedInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSectorSize )( 
            IStreamUnbufferedInfo * This,
            /* [annotation][out] */ 
            __out  ULONG *pcbSectorSize);
        
        END_INTERFACE
    } IStreamUnbufferedInfoVtbl;

    interface IStreamUnbufferedInfo
    {
        CONST_VTBL struct IStreamUnbufferedInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamUnbufferedInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamUnbufferedInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamUnbufferedInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamUnbufferedInfo_GetSectorSize(This,pcbSectorSize)	\
    ( (This)->lpVtbl -> GetSectorSize(This,pcbSectorSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamUnbufferedInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0052 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0052_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0052_v0_0_s_ifspec;

#ifndef __IFileOperationProgressSink_INTERFACE_DEFINED__
#define __IFileOperationProgressSink_INTERFACE_DEFINED__

/* interface IFileOperationProgressSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileOperationProgressSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04b0f1a7-9490-44bc-96e1-4296a31252e2")
    IFileOperationProgressSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartOperations( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishOperations( 
            /* [in] */ HRESULT hrResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreRenameItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostRenameItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in_string LPCWSTR pszNewName,
            /* [in] */ HRESULT hrRename,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreMoveItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostMoveItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [in] */ HRESULT hrMove,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreCopyItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostCopyItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [in] */ HRESULT hrCopy,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreDeleteItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostDeleteItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ HRESULT hrDelete,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreNewItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostNewItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTemplateName,
            /* [in] */ DWORD dwFileAttributes,
            /* [in] */ HRESULT hrNew,
            /* [in] */ __RPC__in_opt IShellItem *psiNewItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ UINT iWorkTotal,
            /* [in] */ UINT iWorkSoFar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeTimer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileOperationProgressSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileOperationProgressSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartOperations )( 
            __RPC__in IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *FinishOperations )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ HRESULT hrResult);
        
        HRESULT ( STDMETHODCALLTYPE *PreRenameItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostRenameItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in_string LPCWSTR pszNewName,
            /* [in] */ HRESULT hrRename,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreMoveItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostMoveItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [in] */ HRESULT hrMove,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreCopyItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostCopyItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [in] */ HRESULT hrCopy,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreDeleteItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem);
        
        HRESULT ( STDMETHODCALLTYPE *PostDeleteItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ HRESULT hrDelete,
            /* [in] */ __RPC__in_opt IShellItem *psiNewlyCreated);
        
        HRESULT ( STDMETHODCALLTYPE *PreNewItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *PostNewItem )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTemplateName,
            /* [in] */ DWORD dwFileAttributes,
            /* [in] */ HRESULT hrNew,
            /* [in] */ __RPC__in_opt IShellItem *psiNewItem);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            __RPC__in IFileOperationProgressSink * This,
            /* [in] */ UINT iWorkTotal,
            /* [in] */ UINT iWorkSoFar);
        
        HRESULT ( STDMETHODCALLTYPE *ResetTimer )( 
            __RPC__in IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseTimer )( 
            __RPC__in IFileOperationProgressSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeTimer )( 
            __RPC__in IFileOperationProgressSink * This);
        
        END_INTERFACE
    } IFileOperationProgressSinkVtbl;

    interface IFileOperationProgressSink
    {
        CONST_VTBL struct IFileOperationProgressSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileOperationProgressSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileOperationProgressSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileOperationProgressSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileOperationProgressSink_StartOperations(This)	\
    ( (This)->lpVtbl -> StartOperations(This) ) 

#define IFileOperationProgressSink_FinishOperations(This,hrResult)	\
    ( (This)->lpVtbl -> FinishOperations(This,hrResult) ) 

#define IFileOperationProgressSink_PreRenameItem(This,dwFlags,psiItem,pszNewName)	\
    ( (This)->lpVtbl -> PreRenameItem(This,dwFlags,psiItem,pszNewName) ) 

#define IFileOperationProgressSink_PostRenameItem(This,dwFlags,psiItem,pszNewName,hrRename,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostRenameItem(This,dwFlags,psiItem,pszNewName,hrRename,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName)	\
    ( (This)->lpVtbl -> PreMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName) ) 

#define IFileOperationProgressSink_PostMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrMove,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostMoveItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrMove,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName)	\
    ( (This)->lpVtbl -> PreCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName) ) 

#define IFileOperationProgressSink_PostCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrCopy,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostCopyItem(This,dwFlags,psiItem,psiDestinationFolder,pszNewName,hrCopy,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreDeleteItem(This,dwFlags,psiItem)	\
    ( (This)->lpVtbl -> PreDeleteItem(This,dwFlags,psiItem) ) 

#define IFileOperationProgressSink_PostDeleteItem(This,dwFlags,psiItem,hrDelete,psiNewlyCreated)	\
    ( (This)->lpVtbl -> PostDeleteItem(This,dwFlags,psiItem,hrDelete,psiNewlyCreated) ) 

#define IFileOperationProgressSink_PreNewItem(This,dwFlags,psiDestinationFolder,pszNewName)	\
    ( (This)->lpVtbl -> PreNewItem(This,dwFlags,psiDestinationFolder,pszNewName) ) 

#define IFileOperationProgressSink_PostNewItem(This,dwFlags,psiDestinationFolder,pszNewName,pszTemplateName,dwFileAttributes,hrNew,psiNewItem)	\
    ( (This)->lpVtbl -> PostNewItem(This,dwFlags,psiDestinationFolder,pszNewName,pszTemplateName,dwFileAttributes,hrNew,psiNewItem) ) 

#define IFileOperationProgressSink_UpdateProgress(This,iWorkTotal,iWorkSoFar)	\
    ( (This)->lpVtbl -> UpdateProgress(This,iWorkTotal,iWorkSoFar) ) 

#define IFileOperationProgressSink_ResetTimer(This)	\
    ( (This)->lpVtbl -> ResetTimer(This) ) 

#define IFileOperationProgressSink_PauseTimer(This)	\
    ( (This)->lpVtbl -> PauseTimer(This) ) 

#define IFileOperationProgressSink_ResumeTimer(This)	\
    ( (This)->lpVtbl -> ResumeTimer(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileOperationProgressSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0053 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0053_v0_0_s_ifspec;

#ifndef __IShellItemArray_INTERFACE_DEFINED__
#define __IShellItemArray_INTERFACE_DEFINED__

/* interface IShellItemArray */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum SIATTRIBFLAGS
    {	SIATTRIBFLAGS_AND	= 0x1,
	SIATTRIBFLAGS_OR	= 0x2,
	SIATTRIBFLAGS_APPCOMPAT	= 0x3,
	SIATTRIBFLAGS_MASK	= 0x3,
	SIATTRIBFLAGS_ALLITEMS	= 0x4000
    } 	SIATTRIBFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(SIATTRIBFLAGS)

EXTERN_C const IID IID_IShellItemArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b63ea76d-1f85-456f-a19c-48159efa858b")
    IShellItemArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionList( 
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [in] */ SIATTRIBFLAGS AttribFlags,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out DWORD *pdwNumItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemAt( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenumShellItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellItemArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellItemArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellItemArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            __RPC__in IShellItemArray * This,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFGUID bhid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            __RPC__in IShellItemArray * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionList )( 
            __RPC__in IShellItemArray * This,
            /* [in] */ __RPC__in REFPROPERTYKEY keyType,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IShellItemArray * This,
            /* [in] */ SIATTRIBFLAGS AttribFlags,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ __RPC__out SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IShellItemArray * This,
            /* [out] */ __RPC__out DWORD *pdwNumItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemAt )( 
            __RPC__in IShellItemArray * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            __RPC__in IShellItemArray * This,
            /* [out] */ __RPC__deref_out_opt IEnumShellItems **ppenumShellItems);
        
        END_INTERFACE
    } IShellItemArrayVtbl;

    interface IShellItemArray
    {
        CONST_VTBL struct IShellItemArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemArray_BindToHandler(This,pbc,bhid,riid,ppvOut)	\
    ( (This)->lpVtbl -> BindToHandler(This,pbc,bhid,riid,ppvOut) ) 

#define IShellItemArray_GetPropertyStore(This,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,riid,ppv) ) 

#define IShellItemArray_GetPropertyDescriptionList(This,keyType,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionList(This,keyType,riid,ppv) ) 

#define IShellItemArray_GetAttributes(This,AttribFlags,sfgaoMask,psfgaoAttribs)	\
    ( (This)->lpVtbl -> GetAttributes(This,AttribFlags,sfgaoMask,psfgaoAttribs) ) 

#define IShellItemArray_GetCount(This,pdwNumItems)	\
    ( (This)->lpVtbl -> GetCount(This,pdwNumItems) ) 

#define IShellItemArray_GetItemAt(This,dwIndex,ppsi)	\
    ( (This)->lpVtbl -> GetItemAt(This,dwIndex,ppsi) ) 

#define IShellItemArray_EnumItems(This,ppenumShellItems)	\
    ( (This)->lpVtbl -> EnumItems(This,ppenumShellItems) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemArray_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0054 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)
SHSTDAPI SHCreateShellItemArray(__in_opt PCIDLIST_ABSOLUTE pidlParent, __in_opt IShellFolder *psf, __in UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY ppidl, __deref_out IShellItemArray **ppsiItemArray);
SHSTDAPI SHCreateShellItemArrayFromDataObject(__in IDataObject *pdo, __in REFIID riid, __deref_out void **ppv);
SHSTDAPI SHCreateShellItemArrayFromIDLists(__in UINT cidl, __in_ecount(cidl) PCIDLIST_ABSOLUTE_ARRAY rgpidl, __deref_out IShellItemArray **ppsiItemArray);
SHSTDAPI SHCreateShellItemArrayFromShellItem(__in IShellItem *psi, __in REFIID riid, __deref_out void **ppv);
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0054_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0054_v0_0_s_ifspec;

#ifndef __IInitializeWithItem_INTERFACE_DEFINED__
#define __IInitializeWithItem_INTERFACE_DEFINED__

/* interface IInitializeWithItem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f73be3f-fb79-493c-a6c7-7ee14e245841")
    IInitializeWithItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeWithItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeWithItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeWithItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IInitializeWithItem * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithItemVtbl;

    interface IInitializeWithItem
    {
        CONST_VTBL struct IInitializeWithItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithItem_Initialize(This,psi,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,psi,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithItem_INTERFACE_DEFINED__ */


#ifndef __IObjectWithSelection_INTERFACE_DEFINED__
#define __IObjectWithSelection_INTERFACE_DEFINED__

/* interface IObjectWithSelection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c9cd5bb-98e9-4491-a60f-31aacc72b83c")
    IObjectWithSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ __RPC__in_opt IShellItemArray *psia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectWithSelection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectWithSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectWithSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            __RPC__in IObjectWithSelection * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psia);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            __RPC__in IObjectWithSelection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IObjectWithSelectionVtbl;

    interface IObjectWithSelection
    {
        CONST_VTBL struct IObjectWithSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithSelection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithSelection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithSelection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithSelection_SetSelection(This,psia)	\
    ( (This)->lpVtbl -> SetSelection(This,psia) ) 

#define IObjectWithSelection_GetSelection(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetSelection(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithSelection_INTERFACE_DEFINED__ */


#ifndef __IObjectWithBackReferences_INTERFACE_DEFINED__
#define __IObjectWithBackReferences_INTERFACE_DEFINED__

/* interface IObjectWithBackReferences */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithBackReferences;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("321a6a6a-d61f-4bf3-97ae-14be2986bb36")
    IObjectWithBackReferences : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemoveBackReferences( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithBackReferencesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectWithBackReferences * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectWithBackReferences * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectWithBackReferences * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveBackReferences )( 
            __RPC__in IObjectWithBackReferences * This);
        
        END_INTERFACE
    } IObjectWithBackReferencesVtbl;

    interface IObjectWithBackReferences
    {
        CONST_VTBL struct IObjectWithBackReferencesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithBackReferences_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithBackReferences_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithBackReferences_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithBackReferences_RemoveBackReferences(This)	\
    ( (This)->lpVtbl -> RemoveBackReferences(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithBackReferences_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0057 */
/* [local] */ 

/* [v1_enum] */ 
enum _PROPERTYUI_NAME_FLAGS
    {	PUIFNF_DEFAULT	= 0,
	PUIFNF_MNEMONIC	= 0x1
    } ;
typedef DWORD PROPERTYUI_NAME_FLAGS;

/* [v1_enum] */ 
enum _PROPERTYUI_FLAGS
    {	PUIF_DEFAULT	= 0,
	PUIF_RIGHTALIGN	= 0x1,
	PUIF_NOLABELININFOTIP	= 0x2
    } ;
typedef DWORD PROPERTYUI_FLAGS;

/* [v1_enum] */ 
enum _PROPERTYUI_FORMAT_FLAGS
    {	PUIFFDF_DEFAULT	= 0,
	PUIFFDF_RIGHTTOLEFT	= 0x1,
	PUIFFDF_SHORTFORMAT	= 0x2,
	PUIFFDF_NOTIME	= 0x4,
	PUIFFDF_FRIENDLYDATE	= 0x8
    } ;
typedef DWORD PROPERTYUI_FORMAT_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0057_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0057_v0_0_s_ifspec;

#ifndef __IPropertyUI_INTERFACE_DEFINED__
#define __IPropertyUI_INTERFACE_DEFINED__

/* interface IPropertyUI */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("757a7d9f-919a-4118-99d7-dbb208c8cc66")
    IPropertyUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParsePropertyName( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [out] */ __RPC__out FMTID *pfmtid,
            /* [out] */ __RPC__out PROPID *ppid,
            /* [out][in] */ __RPC__inout ULONG *pchEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCannonicalName( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ PROPERTYUI_NAME_FLAGS flags,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultWidth( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out ULONG *pcxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out PROPERTYUI_FLAGS *pflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ __RPC__in const PROPVARIANT *ppropvar,
            /* [in] */ PROPERTYUI_FORMAT_FLAGS puiff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pwszHelpFile,
            /* [in] */ DWORD cch,
            /* [out] */ __RPC__out UINT *puHelpID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePropertyName )( 
            __RPC__in IPropertyUI * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [out] */ __RPC__out FMTID *pfmtid,
            /* [out] */ __RPC__out PROPID *ppid,
            /* [out][in] */ __RPC__inout ULONG *pchEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetCannonicalName )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ PROPERTYUI_NAME_FLAGS flags,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ __RPC__out_ecount_full(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultWidth )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out ULONG *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ __RPC__out PROPERTYUI_FLAGS *pflags);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ __RPC__in const PROPVARIANT *ppropvar,
            /* [in] */ PROPERTYUI_FORMAT_FLAGS puiff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpInfo )( 
            __RPC__in IPropertyUI * This,
            /* [in] */ __RPC__in REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pwszHelpFile,
            /* [in] */ DWORD cch,
            /* [out] */ __RPC__out UINT *puHelpID);
        
        END_INTERFACE
    } IPropertyUIVtbl;

    interface IPropertyUI
    {
        CONST_VTBL struct IPropertyUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyUI_ParsePropertyName(This,pszName,pfmtid,ppid,pchEaten)	\
    ( (This)->lpVtbl -> ParsePropertyName(This,pszName,pfmtid,ppid,pchEaten) ) 

#define IPropertyUI_GetCannonicalName(This,fmtid,pid,pwszText,cchText)	\
    ( (This)->lpVtbl -> GetCannonicalName(This,fmtid,pid,pwszText,cchText) ) 

#define IPropertyUI_GetDisplayName(This,fmtid,pid,flags,pwszText,cchText)	\
    ( (This)->lpVtbl -> GetDisplayName(This,fmtid,pid,flags,pwszText,cchText) ) 

#define IPropertyUI_GetPropertyDescription(This,fmtid,pid,pwszText,cchText)	\
    ( (This)->lpVtbl -> GetPropertyDescription(This,fmtid,pid,pwszText,cchText) ) 

#define IPropertyUI_GetDefaultWidth(This,fmtid,pid,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultWidth(This,fmtid,pid,pcxChars) ) 

#define IPropertyUI_GetFlags(This,fmtid,pid,pflags)	\
    ( (This)->lpVtbl -> GetFlags(This,fmtid,pid,pflags) ) 

#define IPropertyUI_FormatForDisplay(This,fmtid,pid,ppropvar,puiff,pwszText,cchText)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,fmtid,pid,ppropvar,puiff,pwszText,cchText) ) 

#define IPropertyUI_GetHelpInfo(This,fmtid,pid,pwszHelpFile,cch,puHelpID)	\
    ( (This)->lpVtbl -> GetHelpInfo(This,fmtid,pid,pwszHelpFile,cch,puHelpID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0058 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)
SHSTDAPI SHRemovePersonalPropertyValues(__in IShellItemArray *psia);
SHSTDAPI SHAddDefaultPropertiesByExt(PCWSTR pszExt, IPropertyStore *pPropStore);
SHSTDAPI SHCreateDefaultPropertiesOp(IShellItem *psi, __out IFileOperation **ppFileOp);
SHSTDAPI SHSetDefaultProperties(__in_opt HWND hwnd, IShellItem *psi, DWORD dwFileOpFlags, __in_opt IFileOperationProgressSink *pfops);
#endif  // (_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= 0x0500)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0058_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0058_v0_0_s_ifspec;

#ifndef __ICategoryProvider_INTERFACE_DEFINED__
#define __ICategoryProvider_INTERFACE_DEFINED__

/* interface ICategoryProvider */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICategoryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9af64809-5864-4c26-a720-c1f78c086ee3")
    ICategoryProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CanCategorizeOnSCID( 
            /* [in] */ __RPC__in const SHCOLUMNID *pscid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultCategory( 
            /* [out] */ __RPC__out GUID *pguid,
            /* [out] */ __RPC__out SHCOLUMNID *pscid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryForSCID( 
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [out] */ __RPC__deref_out_opt IEnumGUID **penum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryName( 
            /* [in] */ __RPC__in const GUID *pguid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCategory( 
            /* [in] */ __RPC__in const GUID *pguid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategoryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICategoryProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICategoryProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICategoryProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *CanCategorizeOnSCID )( 
            __RPC__in ICategoryProvider * This,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultCategory )( 
            __RPC__in ICategoryProvider * This,
            /* [out] */ __RPC__out GUID *pguid,
            /* [out] */ __RPC__out SHCOLUMNID *pscid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryForSCID )( 
            __RPC__in ICategoryProvider * This,
            /* [in] */ __RPC__in const SHCOLUMNID *pscid,
            /* [out] */ __RPC__out GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCategories )( 
            __RPC__in ICategoryProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **penum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryName )( 
            __RPC__in ICategoryProvider * This,
            /* [in] */ __RPC__in const GUID *pguid,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCategory )( 
            __RPC__in ICategoryProvider * This,
            /* [in] */ __RPC__in const GUID *pguid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } ICategoryProviderVtbl;

    interface ICategoryProvider
    {
        CONST_VTBL struct ICategoryProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategoryProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategoryProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategoryProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategoryProvider_CanCategorizeOnSCID(This,pscid)	\
    ( (This)->lpVtbl -> CanCategorizeOnSCID(This,pscid) ) 

#define ICategoryProvider_GetDefaultCategory(This,pguid,pscid)	\
    ( (This)->lpVtbl -> GetDefaultCategory(This,pguid,pscid) ) 

#define ICategoryProvider_GetCategoryForSCID(This,pscid,pguid)	\
    ( (This)->lpVtbl -> GetCategoryForSCID(This,pscid,pguid) ) 

#define ICategoryProvider_EnumCategories(This,penum)	\
    ( (This)->lpVtbl -> EnumCategories(This,penum) ) 

#define ICategoryProvider_GetCategoryName(This,pguid,pszName,cch)	\
    ( (This)->lpVtbl -> GetCategoryName(This,pguid,pszName,cch) ) 

#define ICategoryProvider_CreateCategory(This,pguid,riid,ppv)	\
    ( (This)->lpVtbl -> CreateCategory(This,pguid,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategoryProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0059 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum CATEGORYINFO_FLAGS
    {	CATINFO_NORMAL	= 0,
	CATINFO_COLLAPSED	= 0x1,
	CATINFO_HIDDEN	= 0x2,
	CATINFO_EXPANDED	= 0x4,
	CATINFO_NOHEADER	= 0x8,
	CATINFO_NOTCOLLAPSIBLE	= 0x10,
	CATINFO_NOHEADERCOUNT	= 0x20,
	CATINFO_SUBSETTED	= 0x40
    } 	CATEGORYINFO_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(CATEGORYINFO_FLAGS)
typedef /* [v1_enum] */ 
enum CATSORT_FLAGS
    {	CATSORT_DEFAULT	= 0,
	CATSORT_NAME	= 0x1
    } 	CATSORT_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(CATSORT_FLAGS)
typedef struct CATEGORY_INFO
    {
    CATEGORYINFO_FLAGS cif;
    WCHAR wszName[ 260 ];
    } 	CATEGORY_INFO;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0059_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0059_v0_0_s_ifspec;

#ifndef __ICategorizer_INTERFACE_DEFINED__
#define __ICategorizer_INTERFACE_DEFINED__

/* interface ICategorizer */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ICategorizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3b14589-9174-49a8-89a3-06a1ae2b9ba7")
    ICategorizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDesc,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][out] */ __RPC__out_ecount_full(cidl) DWORD *rgCategoryIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryInfo( 
            /* [in] */ DWORD dwCategoryId,
            /* [out] */ __RPC__out CATEGORY_INFO *pci) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareCategory( 
            /* [in] */ CATSORT_FLAGS csfFlags,
            /* [in] */ DWORD dwCategoryId1,
            /* [in] */ DWORD dwCategoryId2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategorizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICategorizer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICategorizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICategorizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in ICategorizer * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDesc,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            __RPC__in ICategorizer * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ __RPC__in_ecount_full(cidl) PCUITEMID_CHILD_ARRAY apidl,
            /* [size_is][out] */ __RPC__out_ecount_full(cidl) DWORD *rgCategoryIds);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryInfo )( 
            __RPC__in ICategorizer * This,
            /* [in] */ DWORD dwCategoryId,
            /* [out] */ __RPC__out CATEGORY_INFO *pci);
        
        HRESULT ( STDMETHODCALLTYPE *CompareCategory )( 
            __RPC__in ICategorizer * This,
            /* [in] */ CATSORT_FLAGS csfFlags,
            /* [in] */ DWORD dwCategoryId1,
            /* [in] */ DWORD dwCategoryId2);
        
        END_INTERFACE
    } ICategorizerVtbl;

    interface ICategorizer
    {
        CONST_VTBL struct ICategorizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategorizer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategorizer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategorizer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategorizer_GetDescription(This,pszDesc,cch)	\
    ( (This)->lpVtbl -> GetDescription(This,pszDesc,cch) ) 

#define ICategorizer_GetCategory(This,cidl,apidl,rgCategoryIds)	\
    ( (This)->lpVtbl -> GetCategory(This,cidl,apidl,rgCategoryIds) ) 

#define ICategorizer_GetCategoryInfo(This,dwCategoryId,pci)	\
    ( (This)->lpVtbl -> GetCategoryInfo(This,dwCategoryId,pci) ) 

#define ICategorizer_CompareCategory(This,csfFlags,dwCategoryId1,dwCategoryId2)	\
    ( (This)->lpVtbl -> CompareCategory(This,csfFlags,dwCategoryId1,dwCategoryId2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategorizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0060 */
/* [local] */ 

#endif // (_WIN32_IE >= 0x0500)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#include <pshpack8.h>
typedef struct SHDRAGIMAGE
    {
    SIZE sizeDragImage;
    POINT ptOffset;
    HBITMAP hbmpDragImage;
    COLORREF crColorKey;
    } 	SHDRAGIMAGE;

typedef struct SHDRAGIMAGE *LPSHDRAGIMAGE;

#include <poppack.h> // Return to byte packing
#define DI_GETDRAGIMAGE     TEXT("ShellGetDragImage")


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0060_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0060_v0_0_s_ifspec;

#ifndef __IDropTargetHelper_INTERFACE_DEFINED__
#define __IDropTargetHelper_INTERFACE_DEFINED__

/* interface IDropTargetHelper */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IDropTargetHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4657278B-411B-11D2-839A-00C04FD918D0")
    IDropTargetHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DragEnter( 
            /* [annotation][in] */ 
            __in  HWND hwndTarget,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject,
            /* [annotation][in] */ 
            __in  POINT *ppt,
            /* [annotation][in] */ 
            __in  DWORD dwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragOver( 
            /* [annotation][in] */ 
            __in  POINT *ppt,
            /* [annotation][in] */ 
            __in  DWORD dwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Drop( 
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject,
            /* [annotation][in] */ 
            __in  POINT *ppt,
            /* [annotation][in] */ 
            __in  DWORD dwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [annotation][in] */ 
            __in  BOOL fShow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropTargetHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDropTargetHelper * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDropTargetHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDropTargetHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragEnter )( 
            IDropTargetHelper * This,
            /* [annotation][in] */ 
            __in  HWND hwndTarget,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject,
            /* [annotation][in] */ 
            __in  POINT *ppt,
            /* [annotation][in] */ 
            __in  DWORD dwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *DragLeave )( 
            IDropTargetHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragOver )( 
            IDropTargetHelper * This,
            /* [annotation][in] */ 
            __in  POINT *ppt,
            /* [annotation][in] */ 
            __in  DWORD dwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *Drop )( 
            IDropTargetHelper * This,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject,
            /* [annotation][in] */ 
            __in  POINT *ppt,
            /* [annotation][in] */ 
            __in  DWORD dwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            IDropTargetHelper * This,
            /* [annotation][in] */ 
            __in  BOOL fShow);
        
        END_INTERFACE
    } IDropTargetHelperVtbl;

    interface IDropTargetHelper
    {
        CONST_VTBL struct IDropTargetHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropTargetHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDropTargetHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDropTargetHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDropTargetHelper_DragEnter(This,hwndTarget,pDataObject,ppt,dwEffect)	\
    ( (This)->lpVtbl -> DragEnter(This,hwndTarget,pDataObject,ppt,dwEffect) ) 

#define IDropTargetHelper_DragLeave(This)	\
    ( (This)->lpVtbl -> DragLeave(This) ) 

#define IDropTargetHelper_DragOver(This,ppt,dwEffect)	\
    ( (This)->lpVtbl -> DragOver(This,ppt,dwEffect) ) 

#define IDropTargetHelper_Drop(This,pDataObject,ppt,dwEffect)	\
    ( (This)->lpVtbl -> Drop(This,pDataObject,ppt,dwEffect) ) 

#define IDropTargetHelper_Show(This,fShow)	\
    ( (This)->lpVtbl -> Show(This,fShow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDropTargetHelper_INTERFACE_DEFINED__ */


#ifndef __IDragSourceHelper_INTERFACE_DEFINED__
#define __IDragSourceHelper_INTERFACE_DEFINED__

/* interface IDragSourceHelper */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IDragSourceHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE5BF786-477A-11D2-839D-00C04FD918D0")
    IDragSourceHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromBitmap( 
            /* [annotation][in] */ 
            __in  LPSHDRAGIMAGE pshdi,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromWindow( 
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][unique][in] */ 
            __in_opt  POINT *ppt,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDragSourceHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDragSourceHelper * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDragSourceHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDragSourceHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromBitmap )( 
            IDragSourceHelper * This,
            /* [annotation][in] */ 
            __in  LPSHDRAGIMAGE pshdi,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromWindow )( 
            IDragSourceHelper * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][unique][in] */ 
            __in_opt  POINT *ppt,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject);
        
        END_INTERFACE
    } IDragSourceHelperVtbl;

    interface IDragSourceHelper
    {
        CONST_VTBL struct IDragSourceHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDragSourceHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDragSourceHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDragSourceHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDragSourceHelper_InitializeFromBitmap(This,pshdi,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromBitmap(This,pshdi,pDataObject) ) 

#define IDragSourceHelper_InitializeFromWindow(This,hwnd,ppt,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromWindow(This,hwnd,ppt,pDataObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDragSourceHelper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0062 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef /* [v1_enum] */ 
enum DSH_FLAGS
    {	DSH_ALLOWDROPDESCRIPTIONTEXT	= 0x1
    } 	DSH_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(DSH_FLAGS)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0062_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0062_v0_0_s_ifspec;

#ifndef __IDragSourceHelper2_INTERFACE_DEFINED__
#define __IDragSourceHelper2_INTERFACE_DEFINED__

/* interface IDragSourceHelper2 */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IDragSourceHelper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83E07D0D-0C5F-4163-BF1A-60B274051E40")
    IDragSourceHelper2 : public IDragSourceHelper
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDragSourceHelper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDragSourceHelper2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDragSourceHelper2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDragSourceHelper2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromBitmap )( 
            IDragSourceHelper2 * This,
            /* [annotation][in] */ 
            __in  LPSHDRAGIMAGE pshdi,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromWindow )( 
            IDragSourceHelper2 * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][unique][in] */ 
            __in_opt  POINT *ppt,
            /* [annotation][in] */ 
            __in  IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IDragSourceHelper2 * This,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        END_INTERFACE
    } IDragSourceHelper2Vtbl;

    interface IDragSourceHelper2
    {
        CONST_VTBL struct IDragSourceHelper2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDragSourceHelper2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDragSourceHelper2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDragSourceHelper2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDragSourceHelper2_InitializeFromBitmap(This,pshdi,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromBitmap(This,pshdi,pDataObject) ) 

#define IDragSourceHelper2_InitializeFromWindow(This,hwnd,ppt,pDataObject)	\
    ( (This)->lpVtbl -> InitializeFromWindow(This,hwnd,ppt,pDataObject) ) 


#define IDragSourceHelper2_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDragSourceHelper2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0063 */
/* [local] */ 

#endif  // NTDDI_VISTA
#endif  // NTDDI_WIN2K
#ifdef UNICODE
#define IShellLink      IShellLinkW
#else
#define IShellLink      IShellLinkA
#endif
typedef /* [v1_enum] */ 
enum SLR_FLAGS
    {	SLR_NO_UI	= 0x1,
	SLR_ANY_MATCH	= 0x2,
	SLR_UPDATE	= 0x4,
	SLR_NOUPDATE	= 0x8,
	SLR_NOSEARCH	= 0x10,
	SLR_NOTRACK	= 0x20,
	SLR_NOLINKINFO	= 0x40,
	SLR_INVOKE_MSI	= 0x80,
	SLR_NO_UI_WITH_MSG_PUMP	= 0x101,
	SLR_OFFER_DELETE_WITHOUT_FILE	= 0x200,
	SLR_KNOWNFOLDER	= 0x400,
	SLR_MACHINE_IN_LOCAL_TARGET	= 0x800,
	SLR_UPDATE_MACHINE_AND_SID	= 0x1000
    } 	SLR_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(SLR_FLAGS)
typedef /* [v1_enum] */ 
enum SLGP_FLAGS
    {	SLGP_SHORTPATH	= 0x1,
	SLGP_UNCPRIORITY	= 0x2,
	SLGP_RAWPATH	= 0x4,
	SLGP_RELATIVEPRIORITY	= 0x8
    } 	SLGP_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(SLGP_FLAGS)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0063_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0063_v0_0_s_ifspec;

#ifndef __IShellLinkA_INTERFACE_DEFINED__
#define __IShellLinkA_INTERFACE_DEFINED__

/* interface IShellLinkA */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214EE-0000-0000-C000-000000000046")
    IShellLinkA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAA *pfd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszName,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in_string LPCSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszDir,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [string][in] */ __RPC__in_string LPCSTR pszDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArguments( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszArgs,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArguments( 
            /* [string][in] */ __RPC__in_string LPCSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotkey( 
            /* [out] */ __RPC__out WORD *pwHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotkey( 
            /* [in] */ WORD wHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowCmd( 
            /* [out] */ __RPC__out int *piShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowCmd( 
            /* [in] */ int iShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [string][in] */ __RPC__in_string LPCSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelativePath( 
            /* [string][in] */ __RPC__in_string LPCSTR pszPathRel,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [string][in] */ __RPC__in_string LPCSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellLinkA * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellLinkA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellLinkA * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            __RPC__in IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAA *pfd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            __RPC__in IShellLinkA * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            __RPC__in IShellLinkA * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszName,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            __RPC__in IShellLinkA * This,
            /* [string][in] */ __RPC__in_string LPCSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkingDirectory )( 
            __RPC__in IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszDir,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkingDirectory )( 
            __RPC__in IShellLinkA * This,
            /* [string][in] */ __RPC__in_string LPCSTR pszDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetArguments )( 
            __RPC__in IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszArgs,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetArguments )( 
            __RPC__in IShellLinkA * This,
            /* [string][in] */ __RPC__in_string LPCSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotkey )( 
            __RPC__in IShellLinkA * This,
            /* [out] */ __RPC__out WORD *pwHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotkey )( 
            __RPC__in IShellLinkA * This,
            /* [in] */ WORD wHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowCmd )( 
            __RPC__in IShellLinkA * This,
            /* [out] */ __RPC__out int *piShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowCmd )( 
            __RPC__in IShellLinkA * This,
            /* [in] */ int iShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            __RPC__in IShellLinkA * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            __RPC__in IShellLinkA * This,
            /* [string][in] */ __RPC__in_string LPCSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelativePath )( 
            __RPC__in IShellLinkA * This,
            /* [string][in] */ __RPC__in_string LPCSTR pszPathRel,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            __RPC__in IShellLinkA * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            __RPC__in IShellLinkA * This,
            /* [string][in] */ __RPC__in_string LPCSTR pszFile);
        
        END_INTERFACE
    } IShellLinkAVtbl;

    interface IShellLinkA
    {
        CONST_VTBL struct IShellLinkAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkA_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkA_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkA_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkA_GetPath(This,pszFile,cch,pfd,fFlags)	\
    ( (This)->lpVtbl -> GetPath(This,pszFile,cch,pfd,fFlags) ) 

#define IShellLinkA_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#define IShellLinkA_SetIDList(This,pidl)	\
    ( (This)->lpVtbl -> SetIDList(This,pidl) ) 

#define IShellLinkA_GetDescription(This,pszName,cch)	\
    ( (This)->lpVtbl -> GetDescription(This,pszName,cch) ) 

#define IShellLinkA_SetDescription(This,pszName)	\
    ( (This)->lpVtbl -> SetDescription(This,pszName) ) 

#define IShellLinkA_GetWorkingDirectory(This,pszDir,cch)	\
    ( (This)->lpVtbl -> GetWorkingDirectory(This,pszDir,cch) ) 

#define IShellLinkA_SetWorkingDirectory(This,pszDir)	\
    ( (This)->lpVtbl -> SetWorkingDirectory(This,pszDir) ) 

#define IShellLinkA_GetArguments(This,pszArgs,cch)	\
    ( (This)->lpVtbl -> GetArguments(This,pszArgs,cch) ) 

#define IShellLinkA_SetArguments(This,pszArgs)	\
    ( (This)->lpVtbl -> SetArguments(This,pszArgs) ) 

#define IShellLinkA_GetHotkey(This,pwHotkey)	\
    ( (This)->lpVtbl -> GetHotkey(This,pwHotkey) ) 

#define IShellLinkA_SetHotkey(This,wHotkey)	\
    ( (This)->lpVtbl -> SetHotkey(This,wHotkey) ) 

#define IShellLinkA_GetShowCmd(This,piShowCmd)	\
    ( (This)->lpVtbl -> GetShowCmd(This,piShowCmd) ) 

#define IShellLinkA_SetShowCmd(This,iShowCmd)	\
    ( (This)->lpVtbl -> SetShowCmd(This,iShowCmd) ) 

#define IShellLinkA_GetIconLocation(This,pszIconPath,cch,piIcon)	\
    ( (This)->lpVtbl -> GetIconLocation(This,pszIconPath,cch,piIcon) ) 

#define IShellLinkA_SetIconLocation(This,pszIconPath,iIcon)	\
    ( (This)->lpVtbl -> SetIconLocation(This,pszIconPath,iIcon) ) 

#define IShellLinkA_SetRelativePath(This,pszPathRel,dwReserved)	\
    ( (This)->lpVtbl -> SetRelativePath(This,pszPathRel,dwReserved) ) 

#define IShellLinkA_Resolve(This,hwnd,fFlags)	\
    ( (This)->lpVtbl -> Resolve(This,hwnd,fFlags) ) 

#define IShellLinkA_SetPath(This,pszFile)	\
    ( (This)->lpVtbl -> SetPath(This,pszFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkA_INTERFACE_DEFINED__ */


#ifndef __IShellLinkW_INTERFACE_DEFINED__
#define __IShellLinkW_INTERFACE_DEFINED__

/* interface IShellLinkW */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F9-0000-0000-C000-000000000046")
    IShellLinkW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAW *pfd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDir,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArguments( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszArgs,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArguments( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotkey( 
            /* [out] */ __RPC__out WORD *pwHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotkey( 
            /* [in] */ WORD wHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowCmd( 
            /* [out] */ __RPC__out int *piShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowCmd( 
            /* [in] */ int iShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelativePath( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPathRel,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellLinkW * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellLinkW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellLinkW * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            __RPC__in IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszFile,
            /* [in] */ int cch,
            /* [unique][out][in] */ __RPC__inout_opt WIN32_FIND_DATAW *pfd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            __RPC__in IShellLinkW * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            __RPC__in IShellLinkW * This,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszName,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            __RPC__in IShellLinkW * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkingDirectory )( 
            __RPC__in IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDir,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkingDirectory )( 
            __RPC__in IShellLinkW * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetArguments )( 
            __RPC__in IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszArgs,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetArguments )( 
            __RPC__in IShellLinkW * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotkey )( 
            __RPC__in IShellLinkW * This,
            /* [out] */ __RPC__out WORD *pwHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotkey )( 
            __RPC__in IShellLinkW * This,
            /* [in] */ WORD wHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowCmd )( 
            __RPC__in IShellLinkW * This,
            /* [out] */ __RPC__out int *piShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowCmd )( 
            __RPC__in IShellLinkW * This,
            /* [in] */ int iShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            __RPC__in IShellLinkW * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ __RPC__out int *piIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            __RPC__in IShellLinkW * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelativePath )( 
            __RPC__in IShellLinkW * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPathRel,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            __RPC__in IShellLinkW * This,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            __RPC__in IShellLinkW * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszFile);
        
        END_INTERFACE
    } IShellLinkWVtbl;

    interface IShellLinkW
    {
        CONST_VTBL struct IShellLinkWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkW_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkW_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkW_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkW_GetPath(This,pszFile,cch,pfd,fFlags)	\
    ( (This)->lpVtbl -> GetPath(This,pszFile,cch,pfd,fFlags) ) 

#define IShellLinkW_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#define IShellLinkW_SetIDList(This,pidl)	\
    ( (This)->lpVtbl -> SetIDList(This,pidl) ) 

#define IShellLinkW_GetDescription(This,pszName,cch)	\
    ( (This)->lpVtbl -> GetDescription(This,pszName,cch) ) 

#define IShellLinkW_SetDescription(This,pszName)	\
    ( (This)->lpVtbl -> SetDescription(This,pszName) ) 

#define IShellLinkW_GetWorkingDirectory(This,pszDir,cch)	\
    ( (This)->lpVtbl -> GetWorkingDirectory(This,pszDir,cch) ) 

#define IShellLinkW_SetWorkingDirectory(This,pszDir)	\
    ( (This)->lpVtbl -> SetWorkingDirectory(This,pszDir) ) 

#define IShellLinkW_GetArguments(This,pszArgs,cch)	\
    ( (This)->lpVtbl -> GetArguments(This,pszArgs,cch) ) 

#define IShellLinkW_SetArguments(This,pszArgs)	\
    ( (This)->lpVtbl -> SetArguments(This,pszArgs) ) 

#define IShellLinkW_GetHotkey(This,pwHotkey)	\
    ( (This)->lpVtbl -> GetHotkey(This,pwHotkey) ) 

#define IShellLinkW_SetHotkey(This,wHotkey)	\
    ( (This)->lpVtbl -> SetHotkey(This,wHotkey) ) 

#define IShellLinkW_GetShowCmd(This,piShowCmd)	\
    ( (This)->lpVtbl -> GetShowCmd(This,piShowCmd) ) 

#define IShellLinkW_SetShowCmd(This,iShowCmd)	\
    ( (This)->lpVtbl -> SetShowCmd(This,iShowCmd) ) 

#define IShellLinkW_GetIconLocation(This,pszIconPath,cch,piIcon)	\
    ( (This)->lpVtbl -> GetIconLocation(This,pszIconPath,cch,piIcon) ) 

#define IShellLinkW_SetIconLocation(This,pszIconPath,iIcon)	\
    ( (This)->lpVtbl -> SetIconLocation(This,pszIconPath,iIcon) ) 

#define IShellLinkW_SetRelativePath(This,pszPathRel,dwReserved)	\
    ( (This)->lpVtbl -> SetRelativePath(This,pszPathRel,dwReserved) ) 

#define IShellLinkW_Resolve(This,hwnd,fFlags)	\
    ( (This)->lpVtbl -> Resolve(This,hwnd,fFlags) ) 

#define IShellLinkW_SetPath(This,pszFile)	\
    ( (This)->lpVtbl -> SetPath(This,pszFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkW_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDataList_INTERFACE_DEFINED__
#define __IShellLinkDataList_INTERFACE_DEFINED__

/* interface IShellLinkDataList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkDataList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45e2b4ae-b1c3-11d0-b92f-00a0c90312e1")
    IShellLinkDataList : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddDataBlock( 
            /* [annotation][in] */ 
            __in  void *pDataBlock) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyDataBlock( 
            /* [annotation][in] */ 
            __in  DWORD dwSig,
            /* [annotation][out] */ 
            __deref_out  void **ppDataBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveDataBlock( 
            /* [in] */ DWORD dwSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDataListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellLinkDataList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellLinkDataList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellLinkDataList * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddDataBlock )( 
            IShellLinkDataList * This,
            /* [annotation][in] */ 
            __in  void *pDataBlock);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyDataBlock )( 
            IShellLinkDataList * This,
            /* [annotation][in] */ 
            __in  DWORD dwSig,
            /* [annotation][out] */ 
            __deref_out  void **ppDataBlock);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDataBlock )( 
            __RPC__in IShellLinkDataList * This,
            /* [in] */ DWORD dwSig);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            __RPC__in IShellLinkDataList * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IShellLinkDataList * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IShellLinkDataListVtbl;

    interface IShellLinkDataList
    {
        CONST_VTBL struct IShellLinkDataListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDataList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLinkDataList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLinkDataList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLinkDataList_AddDataBlock(This,pDataBlock)	\
    ( (This)->lpVtbl -> AddDataBlock(This,pDataBlock) ) 

#define IShellLinkDataList_CopyDataBlock(This,dwSig,ppDataBlock)	\
    ( (This)->lpVtbl -> CopyDataBlock(This,dwSig,ppDataBlock) ) 

#define IShellLinkDataList_RemoveDataBlock(This,dwSig)	\
    ( (This)->lpVtbl -> RemoveDataBlock(This,dwSig) ) 

#define IShellLinkDataList_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define IShellLinkDataList_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLinkDataList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0066 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WIN2K)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0066_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0066_v0_0_s_ifspec;

#ifndef __IResolveShellLink_INTERFACE_DEFINED__
#define __IResolveShellLink_INTERFACE_DEFINED__

/* interface IResolveShellLink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResolveShellLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5cd52983-9449-11d2-963a-00c04f79adf0")
    IResolveShellLink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResolveShellLink( 
            /* [in] */ __RPC__in_opt IUnknown *punkLink,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResolveShellLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IResolveShellLink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IResolveShellLink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IResolveShellLink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveShellLink )( 
            __RPC__in IResolveShellLink * This,
            /* [in] */ __RPC__in_opt IUnknown *punkLink,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        END_INTERFACE
    } IResolveShellLinkVtbl;

    interface IResolveShellLink
    {
        CONST_VTBL struct IResolveShellLinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResolveShellLink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResolveShellLink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResolveShellLink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResolveShellLink_ResolveShellLink(This,punkLink,hwnd,fFlags)	\
    ( (This)->lpVtbl -> ResolveShellLink(This,punkLink,hwnd,fFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResolveShellLink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0067 */
/* [local] */ 

#endif  // NTDDI_WIN2K


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0067_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0067_v0_0_s_ifspec;

#ifndef __IActionProgressDialog_INTERFACE_DEFINED__
#define __IActionProgressDialog_INTERFACE_DEFINED__

/* interface IActionProgressDialog */
/* [unique][uuid][object] */ 

/* [v1_enum] */ 
enum _SPINITF
    {	SPINITF_NORMAL	= 0,
	SPINITF_MODAL	= 0x1,
	SPINITF_NOMINIMIZE	= 0x8
    } ;
typedef DWORD SPINITF;


EXTERN_C const IID IID_IActionProgressDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ff1172-eadc-446d-9285-156453a6431c")
    IActionProgressDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ SPINITF flags,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionProgressDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActionProgressDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActionProgressDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActionProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IActionProgressDialog * This,
            /* [in] */ SPINITF flags,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszCancel);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            __RPC__in IActionProgressDialog * This);
        
        END_INTERFACE
    } IActionProgressDialogVtbl;

    interface IActionProgressDialog
    {
        CONST_VTBL struct IActionProgressDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionProgressDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActionProgressDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActionProgressDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActionProgressDialog_Initialize(This,flags,pszTitle,pszCancel)	\
    ( (This)->lpVtbl -> Initialize(This,flags,pszTitle,pszCancel) ) 

#define IActionProgressDialog_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActionProgressDialog_INTERFACE_DEFINED__ */


#ifndef __IHWEventHandler_INTERFACE_DEFINED__
#define __IHWEventHandler_INTERFACE_DEFINED__

/* interface IHWEventHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IHWEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1")
    IHWEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleEvent( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleEventWithContent( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType,
            /* [string][in] */ __RPC__in_string LPCWSTR pszContentTypeHandler,
            /* [in] */ __RPC__in_opt IDataObject *pdataobject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IHWEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IHWEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IHWEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IHWEventHandler * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEvent )( 
            __RPC__in IHWEventHandler * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEventWithContent )( 
            __RPC__in IHWEventHandler * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType,
            /* [string][in] */ __RPC__in_string LPCWSTR pszContentTypeHandler,
            /* [in] */ __RPC__in_opt IDataObject *pdataobject);
        
        END_INTERFACE
    } IHWEventHandlerVtbl;

    interface IHWEventHandler
    {
        CONST_VTBL struct IHWEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHWEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHWEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHWEventHandler_Initialize(This,pszParams)	\
    ( (This)->lpVtbl -> Initialize(This,pszParams) ) 

#define IHWEventHandler_HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType)	\
    ( (This)->lpVtbl -> HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType) ) 

#define IHWEventHandler_HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject)	\
    ( (This)->lpVtbl -> HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHWEventHandler_INTERFACE_DEFINED__ */


#ifndef __IHWEventHandler2_INTERFACE_DEFINED__
#define __IHWEventHandler2_INTERFACE_DEFINED__

/* interface IHWEventHandler2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IHWEventHandler2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CFCC809F-295D-42e8-9FFC-424B33C487E6")
    IHWEventHandler2 : public IHWEventHandler
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleEventWithHWND( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType,
            /* [in] */ __RPC__in HWND hwndOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWEventHandler2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IHWEventHandler2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IHWEventHandler2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IHWEventHandler2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEvent )( 
            __RPC__in IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEventWithContent )( 
            __RPC__in IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType,
            /* [string][in] */ __RPC__in_string LPCWSTR pszContentTypeHandler,
            /* [in] */ __RPC__in_opt IDataObject *pdataobject);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEventWithHWND )( 
            __RPC__in IHWEventHandler2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAltDeviceID,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEventType,
            /* [in] */ __RPC__in HWND hwndOwner);
        
        END_INTERFACE
    } IHWEventHandler2Vtbl;

    interface IHWEventHandler2
    {
        CONST_VTBL struct IHWEventHandler2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWEventHandler2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHWEventHandler2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHWEventHandler2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHWEventHandler2_Initialize(This,pszParams)	\
    ( (This)->lpVtbl -> Initialize(This,pszParams) ) 

#define IHWEventHandler2_HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType)	\
    ( (This)->lpVtbl -> HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType) ) 

#define IHWEventHandler2_HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject)	\
    ( (This)->lpVtbl -> HandleEventWithContent(This,pszDeviceID,pszAltDeviceID,pszEventType,pszContentTypeHandler,pdataobject) ) 


#define IHWEventHandler2_HandleEventWithHWND(This,pszDeviceID,pszAltDeviceID,pszEventType,hwndOwner)	\
    ( (This)->lpVtbl -> HandleEventWithHWND(This,pszDeviceID,pszAltDeviceID,pszEventType,hwndOwner) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHWEventHandler2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0070 */
/* [local] */ 

#define ARCONTENT_AUTORUNINF             0x00000002   // That's the one we have today, and always had
#define ARCONTENT_AUDIOCD                0x00000004   // Audio CD (not MP3 and the like, the stuff you buy at the store)
#define ARCONTENT_DVDMOVIE               0x00000008   // DVD Movie (not MPEGs, the stuff you buy at the store)
#define ARCONTENT_BLANKCD                0x00000010   // Blank CD-R/CD-RW)
#define ARCONTENT_BLANKDVD               0x00000020   // Blank DVD-R/DVD-RW
#define ARCONTENT_UNKNOWNCONTENT         0x00000040   // Whatever files.  Mean that it's formatted.
#define ARCONTENT_AUTOPLAYPIX            0x00000080   // Any files classified by shell as image. (jpg, bmp, etc.)
#define ARCONTENT_AUTOPLAYMUSIC          0x00000100   // Any files classified by shell as music. (wma, mp3, etc.)
#define ARCONTENT_AUTOPLAYVIDEO          0x00000200   // Any files classified by shell as video. (mpg, avi, etc.)
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define ARCONTENT_VCD                    0x00000400   // VCD format
#define ARCONTENT_SVCD                   0x00000800   // Super-VCD format
#define ARCONTENT_DVDAUDIO               0x00001000   // DVD-Audio
#define ARCONTENT_BLANKBD                0x00002000   // Blank BD-R/BD-RW
#define ARCONTENT_BLURAY                 0x00004000   // Blu-ray Disc
#define ARCONTENT_NONE                   0x00000000   // Empty (but formatted)
#define ARCONTENT_MASK                   0x00007FFE   // Bits that denote valid content types
#define ARCONTENT_PHASE_UNKNOWN          0x00000000   // We can be in any phase.  This is XP behavior.
#define ARCONTENT_PHASE_PRESNIFF         0x10000000   // These are contents we know w/o scanning the media for complete data (e.g. Audio track, DVD Movie).
#define ARCONTENT_PHASE_SNIFFING         0x20000000   // We are in the middle of searching the media.  There could be more contents to be found than currently reported.
#define ARCONTENT_PHASE_FINAL            0x40000000   // We have finished searching; contents we report are final.
#define ARCONTENT_PHASE_MASK             0x70000000   // Bits that denote what phase we are in the Autoplay process.
#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0070_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0070_v0_0_s_ifspec;

#ifndef __IQueryCancelAutoPlay_INTERFACE_DEFINED__
#define __IQueryCancelAutoPlay_INTERFACE_DEFINED__

/* interface IQueryCancelAutoPlay */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQueryCancelAutoPlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDEFE873-6997-4e68-BE26-39B633ADBE12")
    IQueryCancelAutoPlay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllowAutoPlay( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath,
            /* [in] */ DWORD dwContentType,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel,
            /* [in] */ DWORD dwSerialNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryCancelAutoPlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IQueryCancelAutoPlay * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IQueryCancelAutoPlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IQueryCancelAutoPlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllowAutoPlay )( 
            __RPC__in IQueryCancelAutoPlay * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath,
            /* [in] */ DWORD dwContentType,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel,
            /* [in] */ DWORD dwSerialNumber);
        
        END_INTERFACE
    } IQueryCancelAutoPlayVtbl;

    interface IQueryCancelAutoPlay
    {
        CONST_VTBL struct IQueryCancelAutoPlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryCancelAutoPlay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryCancelAutoPlay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryCancelAutoPlay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryCancelAutoPlay_AllowAutoPlay(This,pszPath,dwContentType,pszLabel,dwSerialNumber)	\
    ( (This)->lpVtbl -> AllowAutoPlay(This,pszPath,dwContentType,pszLabel,dwSerialNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryCancelAutoPlay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0071 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0071_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0071_v0_0_s_ifspec;

#ifndef __IDynamicHWHandler_INTERFACE_DEFINED__
#define __IDynamicHWHandler_INTERFACE_DEFINED__

/* interface IDynamicHWHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDynamicHWHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DC2601D7-059E-42fc-A09D-2AFD21B6D5F7")
    IDynamicHWHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDynamicInfo( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [in] */ DWORD dwContentType,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicHWHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDynamicHWHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDynamicHWHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDynamicHWHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicInfo )( 
            __RPC__in IDynamicHWHandler * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDeviceID,
            /* [in] */ DWORD dwContentType,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAction);
        
        END_INTERFACE
    } IDynamicHWHandlerVtbl;

    interface IDynamicHWHandler
    {
        CONST_VTBL struct IDynamicHWHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicHWHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDynamicHWHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDynamicHWHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDynamicHWHandler_GetDynamicInfo(This,pszDeviceID,dwContentType,ppszAction)	\
    ( (This)->lpVtbl -> GetDynamicInfo(This,pszDeviceID,dwContentType,ppszAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDynamicHWHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0072 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0072_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0072_v0_0_s_ifspec;

#ifndef __IActionProgress_INTERFACE_DEFINED__
#define __IActionProgress_INTERFACE_DEFINED__

/* interface IActionProgress */
/* [unique][uuid][object] */ 

/* [v1_enum] */ 
enum _SPBEGINF
    {	SPBEGINF_NORMAL	= 0,
	SPBEGINF_AUTOTIME	= 0x2,
	SPBEGINF_NOPROGRESSBAR	= 0x10,
	SPBEGINF_MARQUEEPROGRESS	= 0x20,
	SPBEGINF_NOCANCELBUTTON	= 0x40
    } ;
typedef DWORD SPBEGINF;

typedef /* [v1_enum] */ 
enum _SPACTION
    {	SPACTION_NONE	= 0,
	SPACTION_MOVING	= ( SPACTION_NONE + 1 ) ,
	SPACTION_COPYING	= ( SPACTION_MOVING + 1 ) ,
	SPACTION_RECYCLING	= ( SPACTION_COPYING + 1 ) ,
	SPACTION_APPLYINGATTRIBS	= ( SPACTION_RECYCLING + 1 ) ,
	SPACTION_DOWNLOADING	= ( SPACTION_APPLYINGATTRIBS + 1 ) ,
	SPACTION_SEARCHING_INTERNET	= ( SPACTION_DOWNLOADING + 1 ) ,
	SPACTION_CALCULATING	= ( SPACTION_SEARCHING_INTERNET + 1 ) ,
	SPACTION_UPLOADING	= ( SPACTION_CALCULATING + 1 ) ,
	SPACTION_SEARCHING_FILES	= ( SPACTION_UPLOADING + 1 ) ,
	SPACTION_DELETING	= ( SPACTION_SEARCHING_FILES + 1 ) ,
	SPACTION_RENAMING	= ( SPACTION_DELETING + 1 ) ,
	SPACTION_FORMATTING	= ( SPACTION_RENAMING + 1 ) ,
	SPACTION_COPY_MOVING	= ( SPACTION_FORMATTING + 1 ) 
    } 	SPACTION;

typedef /* [v1_enum] */ 
enum _SPTEXT
    {	SPTEXT_ACTIONDESCRIPTION	= 1,
	SPTEXT_ACTIONDETAIL	= ( SPTEXT_ACTIONDESCRIPTION + 1 ) 
    } 	SPTEXT;


EXTERN_C const IID IID_IActionProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ff1173-eadc-446d-9285-156453a6431c")
    IActionProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ SPACTION action,
            /* [in] */ SPBEGINF flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ ULONGLONG ulCompleted,
            /* [in] */ ULONGLONG ulTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateText( 
            /* [in] */ SPTEXT sptext,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText,
            /* [in] */ BOOL fMayCompact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCancel( 
            /* [out] */ __RPC__out BOOL *pfCancelled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetCancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActionProgress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActionProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActionProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin )( 
            __RPC__in IActionProgress * This,
            /* [in] */ SPACTION action,
            /* [in] */ SPBEGINF flags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            __RPC__in IActionProgress * This,
            /* [in] */ ULONGLONG ulCompleted,
            /* [in] */ ULONGLONG ulTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateText )( 
            __RPC__in IActionProgress * This,
            /* [in] */ SPTEXT sptext,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText,
            /* [in] */ BOOL fMayCompact);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCancel )( 
            __RPC__in IActionProgress * This,
            /* [out] */ __RPC__out BOOL *pfCancelled);
        
        HRESULT ( STDMETHODCALLTYPE *ResetCancel )( 
            __RPC__in IActionProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            __RPC__in IActionProgress * This);
        
        END_INTERFACE
    } IActionProgressVtbl;

    interface IActionProgress
    {
        CONST_VTBL struct IActionProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActionProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActionProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActionProgress_Begin(This,action,flags)	\
    ( (This)->lpVtbl -> Begin(This,action,flags) ) 

#define IActionProgress_UpdateProgress(This,ulCompleted,ulTotal)	\
    ( (This)->lpVtbl -> UpdateProgress(This,ulCompleted,ulTotal) ) 

#define IActionProgress_UpdateText(This,sptext,pszText,fMayCompact)	\
    ( (This)->lpVtbl -> UpdateText(This,sptext,pszText,fMayCompact) ) 

#define IActionProgress_QueryCancel(This,pfCancelled)	\
    ( (This)->lpVtbl -> QueryCancel(This,pfCancelled) ) 

#define IActionProgress_ResetCancel(This)	\
    ( (This)->lpVtbl -> ResetCancel(This) ) 

#define IActionProgress_End(This)	\
    ( (This)->lpVtbl -> End(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActionProgress_INTERFACE_DEFINED__ */


#ifndef __IShellExtInit_INTERFACE_DEFINED__
#define __IShellExtInit_INTERFACE_DEFINED__

/* interface IShellExtInit */
/* [unique][local][object][uuid] */ 


EXTERN_C const IID IID_IShellExtInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E8-0000-0000-C000-000000000046")
    IShellExtInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [annotation][unique][in] */ 
            __in_opt  PCIDLIST_ABSOLUTE pidlFolder,
            /* [annotation][unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [annotation][unique][in] */ 
            __in_opt  HKEY hkeyProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellExtInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellExtInit * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellExtInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellExtInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellExtInit * This,
            /* [annotation][unique][in] */ 
            __in_opt  PCIDLIST_ABSOLUTE pidlFolder,
            /* [annotation][unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [annotation][unique][in] */ 
            __in_opt  HKEY hkeyProgID);
        
        END_INTERFACE
    } IShellExtInitVtbl;

    interface IShellExtInit
    {
        CONST_VTBL struct IShellExtInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellExtInit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellExtInit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellExtInit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellExtInit_Initialize(This,pidlFolder,pdtobj,hkeyProgID)	\
    ( (This)->lpVtbl -> Initialize(This,pidlFolder,pdtobj,hkeyProgID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellExtInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0074 */
/* [local] */ 

typedef IShellExtInit *LPSHELLEXTINIT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0074_v0_0_s_ifspec;

#ifndef __IShellPropSheetExt_INTERFACE_DEFINED__
#define __IShellPropSheetExt_INTERFACE_DEFINED__

/* interface IShellPropSheetExt */
/* [unique][local][object][uuid] */ 

/* [v1_enum] */ 
enum _EXPPS
    {	EXPPS_FILETYPES	= 0x1
    } ;
typedef UINT EXPPS;


EXTERN_C const IID IID_IShellPropSheetExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E9-0000-0000-C000-000000000046")
    IShellPropSheetExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [annotation][in] */ 
            __in  LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplacePage( 
            /* [annotation][in] */ 
            __in  EXPPS uPageID,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [annotation][in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellPropSheetExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellPropSheetExt * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellPropSheetExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellPropSheetExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IShellPropSheetExt * This,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *ReplacePage )( 
            IShellPropSheetExt * This,
            /* [annotation][in] */ 
            __in  EXPPS uPageID,
            /* [annotation][in] */ 
            __in  LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IShellPropSheetExtVtbl;

    interface IShellPropSheetExt
    {
        CONST_VTBL struct IShellPropSheetExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellPropSheetExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellPropSheetExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellPropSheetExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellPropSheetExt_AddPages(This,pfnAddPage,lParam)	\
    ( (This)->lpVtbl -> AddPages(This,pfnAddPage,lParam) ) 

#define IShellPropSheetExt_ReplacePage(This,uPageID,pfnReplaceWith,lParam)	\
    ( (This)->lpVtbl -> ReplacePage(This,uPageID,pfnReplaceWith,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellPropSheetExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0075 */
/* [local] */ 

typedef IShellPropSheetExt *LPSHELLPROPSHEETEXT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0075_v0_0_s_ifspec;

#ifndef __IRemoteComputer_INTERFACE_DEFINED__
#define __IRemoteComputer_INTERFACE_DEFINED__

/* interface IRemoteComputer */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IRemoteComputer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214FE-0000-0000-C000-000000000046")
    IRemoteComputer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszMachine,
            /* [in] */ BOOL bEnumerating) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComputerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRemoteComputer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRemoteComputer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRemoteComputer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IRemoteComputer * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszMachine,
            /* [in] */ BOOL bEnumerating);
        
        END_INTERFACE
    } IRemoteComputerVtbl;

    interface IRemoteComputer
    {
        CONST_VTBL struct IRemoteComputerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComputer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteComputer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteComputer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteComputer_Initialize(This,pszMachine,bEnumerating)	\
    ( (This)->lpVtbl -> Initialize(This,pszMachine,bEnumerating) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteComputer_INTERFACE_DEFINED__ */


#ifndef __IQueryContinue_INTERFACE_DEFINED__
#define __IQueryContinue_INTERFACE_DEFINED__

/* interface IQueryContinue */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IQueryContinue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7307055c-b24a-486b-9f25-163e597a28a9")
    IQueryContinue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryContinueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IQueryContinue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IQueryContinue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IQueryContinue * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinue )( 
            __RPC__in IQueryContinue * This);
        
        END_INTERFACE
    } IQueryContinueVtbl;

    interface IQueryContinue
    {
        CONST_VTBL struct IQueryContinueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryContinue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryContinue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryContinue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryContinue_QueryContinue(This)	\
    ( (This)->lpVtbl -> QueryContinue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryContinue_INTERFACE_DEFINED__ */


#ifndef __IObjectWithCancelEvent_INTERFACE_DEFINED__
#define __IObjectWithCancelEvent_INTERFACE_DEFINED__

/* interface IObjectWithCancelEvent */
/* [unique][local][object][uuid] */ 


EXTERN_C const IID IID_IObjectWithCancelEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F279B885-0AE9-4b85-AC06-DDECF9408941")
    IObjectWithCancelEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCancelEvent( 
            /* [annotation][out] */ 
            __out  HANDLE *phEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithCancelEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithCancelEvent * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithCancelEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithCancelEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCancelEvent )( 
            IObjectWithCancelEvent * This,
            /* [annotation][out] */ 
            __out  HANDLE *phEvent);
        
        END_INTERFACE
    } IObjectWithCancelEventVtbl;

    interface IObjectWithCancelEvent
    {
        CONST_VTBL struct IObjectWithCancelEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithCancelEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithCancelEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithCancelEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithCancelEvent_GetCancelEvent(This,phEvent)	\
    ( (This)->lpVtbl -> GetCancelEvent(This,phEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithCancelEvent_INTERFACE_DEFINED__ */


#ifndef __IUserNotification_INTERFACE_DEFINED__
#define __IUserNotification_INTERFACE_DEFINED__

/* interface IUserNotification */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IUserNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba9711ba-5893-4787-a7e1-41277151550b")
    IUserNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBalloonInfo( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBalloonRetry( 
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconInfo( 
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszToolTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySound( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszSoundName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUserNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUserNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUserNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonInfo )( 
            __RPC__in IUserNotification * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonRetry )( 
            __RPC__in IUserNotification * This,
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconInfo )( 
            __RPC__in IUserNotification * This,
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            __RPC__in IUserNotification * This,
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval);
        
        HRESULT ( STDMETHODCALLTYPE *PlaySound )( 
            __RPC__in IUserNotification * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszSoundName);
        
        END_INTERFACE
    } IUserNotificationVtbl;

    interface IUserNotification
    {
        CONST_VTBL struct IUserNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserNotification_SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags)	\
    ( (This)->lpVtbl -> SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags) ) 

#define IUserNotification_SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount)	\
    ( (This)->lpVtbl -> SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount) ) 

#define IUserNotification_SetIconInfo(This,hIcon,pszToolTip)	\
    ( (This)->lpVtbl -> SetIconInfo(This,hIcon,pszToolTip) ) 

#define IUserNotification_Show(This,pqc,dwContinuePollInterval)	\
    ( (This)->lpVtbl -> Show(This,pqc,dwContinuePollInterval) ) 

#define IUserNotification_PlaySound(This,pszSoundName)	\
    ( (This)->lpVtbl -> PlaySound(This,pszSoundName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserNotification_INTERFACE_DEFINED__ */


#ifndef __IUserNotificationCallback_INTERFACE_DEFINED__
#define __IUserNotificationCallback_INTERFACE_DEFINED__

/* interface IUserNotificationCallback */
/* [object][uuid] */ 


EXTERN_C const IID IID_IUserNotificationCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19108294-0441-4AFF-8013-FA0A730B0BEA")
    IUserNotificationCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnBalloonUserClick( 
            /* [in] */ __RPC__in POINT *pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeftClick( 
            /* [in] */ __RPC__in POINT *pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnContextMenu( 
            /* [in] */ __RPC__in POINT *pt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotificationCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUserNotificationCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUserNotificationCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUserNotificationCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnBalloonUserClick )( 
            __RPC__in IUserNotificationCallback * This,
            /* [in] */ __RPC__in POINT *pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnLeftClick )( 
            __RPC__in IUserNotificationCallback * This,
            /* [in] */ __RPC__in POINT *pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnContextMenu )( 
            __RPC__in IUserNotificationCallback * This,
            /* [in] */ __RPC__in POINT *pt);
        
        END_INTERFACE
    } IUserNotificationCallbackVtbl;

    interface IUserNotificationCallback
    {
        CONST_VTBL struct IUserNotificationCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserNotificationCallback_OnBalloonUserClick(This,pt)	\
    ( (This)->lpVtbl -> OnBalloonUserClick(This,pt) ) 

#define IUserNotificationCallback_OnLeftClick(This,pt)	\
    ( (This)->lpVtbl -> OnLeftClick(This,pt) ) 

#define IUserNotificationCallback_OnContextMenu(This,pt)	\
    ( (This)->lpVtbl -> OnContextMenu(This,pt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserNotificationCallback_INTERFACE_DEFINED__ */


#ifndef __IUserNotification2_INTERFACE_DEFINED__
#define __IUserNotification2_INTERFACE_DEFINED__

/* interface IUserNotification2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IUserNotification2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("215913CC-57EB-4FAB-AB5A-E5FA7BEA2A6C")
    IUserNotification2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBalloonInfo( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBalloonRetry( 
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconInfo( 
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszToolTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval,
            /* [unique][in] */ __RPC__in_opt IUserNotificationCallback *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySound( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszSoundName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotification2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUserNotification2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUserNotification2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUserNotification2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonInfo )( 
            __RPC__in IUserNotification2 * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTitle,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonRetry )( 
            __RPC__in IUserNotification2 * This,
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconInfo )( 
            __RPC__in IUserNotification2 * This,
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            __RPC__in IUserNotification2 * This,
            /* [unique][in] */ __RPC__in_opt IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval,
            /* [unique][in] */ __RPC__in_opt IUserNotificationCallback *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *PlaySound )( 
            __RPC__in IUserNotification2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszSoundName);
        
        END_INTERFACE
    } IUserNotification2Vtbl;

    interface IUserNotification2
    {
        CONST_VTBL struct IUserNotification2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotification2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserNotification2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserNotification2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserNotification2_SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags)	\
    ( (This)->lpVtbl -> SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags) ) 

#define IUserNotification2_SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount)	\
    ( (This)->lpVtbl -> SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount) ) 

#define IUserNotification2_SetIconInfo(This,hIcon,pszToolTip)	\
    ( (This)->lpVtbl -> SetIconInfo(This,hIcon,pszToolTip) ) 

#define IUserNotification2_Show(This,pqc,dwContinuePollInterval,pSink)	\
    ( (This)->lpVtbl -> Show(This,pqc,dwContinuePollInterval,pSink) ) 

#define IUserNotification2_PlaySound(This,pszSoundName)	\
    ( (This)->lpVtbl -> PlaySound(This,pszSoundName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserNotification2_INTERFACE_DEFINED__ */


#ifndef __IItemNameLimits_INTERFACE_DEFINED__
#define __IItemNameLimits_INTERFACE_DEFINED__

/* interface IItemNameLimits */
/* [object][uuid] */ 


EXTERN_C const IID IID_IItemNameLimits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1df0d7f1-b267-4d28-8b10-12e23202a5c4")
    IItemNameLimits : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValidCharacters( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszValidChars,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszInvalidChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [out] */ __RPC__out int *piMaxNameLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemNameLimitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IItemNameLimits * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IItemNameLimits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IItemNameLimits * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetValidCharacters )( 
            __RPC__in IItemNameLimits * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszValidChars,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszInvalidChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            __RPC__in IItemNameLimits * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [out] */ __RPC__out int *piMaxNameLen);
        
        END_INTERFACE
    } IItemNameLimitsVtbl;

    interface IItemNameLimits
    {
        CONST_VTBL struct IItemNameLimitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemNameLimits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemNameLimits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemNameLimits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemNameLimits_GetValidCharacters(This,ppwszValidChars,ppwszInvalidChars)	\
    ( (This)->lpVtbl -> GetValidCharacters(This,ppwszValidChars,ppwszInvalidChars) ) 

#define IItemNameLimits_GetMaxLength(This,pszName,piMaxNameLen)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pszName,piMaxNameLen) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemNameLimits_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0082 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0082_v0_0_s_ifspec;

#ifndef __ISearchFolderItemFactory_INTERFACE_DEFINED__
#define __ISearchFolderItemFactory_INTERFACE_DEFINED__

/* interface ISearchFolderItemFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISearchFolderItemFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a0ffbc28-5482-4366-be27-3e81e78e06c2")
    ISearchFolderItemFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDisplayName( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderTypeID( 
            /* [in] */ FOLDERTYPEID ftid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderLogicalViewMode( 
            /* [in] */ FOLDERLOGICALVIEWMODE flvm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconSize( 
            /* [in] */ int iIconSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVisibleColumns( 
            /* [in] */ UINT cVisibleColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cVisibleColumns) PROPERTYKEY *rgKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSortColumns( 
            /* [in] */ UINT cSortColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cSortColumns) SORTCOLUMN *rgSortColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGroupColumn( 
            /* [in] */ __RPC__in REFPROPERTYKEY keyGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStacks( 
            /* [in] */ UINT cStackKeys,
            /* [size_is][in] */ __RPC__in_ecount_full(cStackKeys) PROPERTYKEY *rgStackKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScope( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiaScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCondition( 
            /* [in] */ __RPC__in_opt ICondition *pCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellItem( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchFolderItemFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISearchFolderItemFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISearchFolderItemFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayName )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderTypeID )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ FOLDERTYPEID ftid);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderLogicalViewMode )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ FOLDERLOGICALVIEWMODE flvm);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconSize )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ int iIconSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisibleColumns )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ UINT cVisibleColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cVisibleColumns) PROPERTYKEY *rgKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetSortColumns )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ UINT cSortColumns,
            /* [size_is][in] */ __RPC__in_ecount_full(cSortColumns) SORTCOLUMN *rgSortColumns);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupColumn )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in REFPROPERTYKEY keyGroup);
        
        HRESULT ( STDMETHODCALLTYPE *SetStacks )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ UINT cStackKeys,
            /* [size_is][in] */ __RPC__in_ecount_full(cStackKeys) PROPERTYKEY *rgStackKeys);
        
        HRESULT ( STDMETHODCALLTYPE *SetScope )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiaScope);
        
        HRESULT ( STDMETHODCALLTYPE *SetCondition )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in_opt ICondition *pCondition);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellItem )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            __RPC__in ISearchFolderItemFactory * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        END_INTERFACE
    } ISearchFolderItemFactoryVtbl;

    interface ISearchFolderItemFactory
    {
        CONST_VTBL struct ISearchFolderItemFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchFolderItemFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchFolderItemFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchFolderItemFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchFolderItemFactory_SetDisplayName(This,pszDisplayName)	\
    ( (This)->lpVtbl -> SetDisplayName(This,pszDisplayName) ) 

#define ISearchFolderItemFactory_SetFolderTypeID(This,ftid)	\
    ( (This)->lpVtbl -> SetFolderTypeID(This,ftid) ) 

#define ISearchFolderItemFactory_SetFolderLogicalViewMode(This,flvm)	\
    ( (This)->lpVtbl -> SetFolderLogicalViewMode(This,flvm) ) 

#define ISearchFolderItemFactory_SetIconSize(This,iIconSize)	\
    ( (This)->lpVtbl -> SetIconSize(This,iIconSize) ) 

#define ISearchFolderItemFactory_SetVisibleColumns(This,cVisibleColumns,rgKey)	\
    ( (This)->lpVtbl -> SetVisibleColumns(This,cVisibleColumns,rgKey) ) 

#define ISearchFolderItemFactory_SetSortColumns(This,cSortColumns,rgSortColumns)	\
    ( (This)->lpVtbl -> SetSortColumns(This,cSortColumns,rgSortColumns) ) 

#define ISearchFolderItemFactory_SetGroupColumn(This,keyGroup)	\
    ( (This)->lpVtbl -> SetGroupColumn(This,keyGroup) ) 

#define ISearchFolderItemFactory_SetStacks(This,cStackKeys,rgStackKeys)	\
    ( (This)->lpVtbl -> SetStacks(This,cStackKeys,rgStackKeys) ) 

#define ISearchFolderItemFactory_SetScope(This,psiaScope)	\
    ( (This)->lpVtbl -> SetScope(This,psiaScope) ) 

#define ISearchFolderItemFactory_SetCondition(This,pCondition)	\
    ( (This)->lpVtbl -> SetCondition(This,pCondition) ) 

#define ISearchFolderItemFactory_GetShellItem(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetShellItem(This,riid,ppv) ) 

#define ISearchFolderItemFactory_GetIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,ppidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchFolderItemFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0083 */
/* [local] */ 

#endif  // NTDDI_VISTA
#if (_WIN32_IE >= 0x0400)
#define IEI_PRIORITY_MAX        ITSAT_MAX_PRIORITY
#define IEI_PRIORITY_MIN        ITSAT_MIN_PRIORITY
#define IEIT_PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY
#define IEIFLAG_ASYNC       0x0001      // (deprecated) ask the extractor if it supports ASYNC extract (free threaded)
#define IEIFLAG_CACHE       0x0002      // returned from the extractor if it does NOT cache the thumbnail
#define IEIFLAG_ASPECT      0x0004      // passed to the extractor to beg it to render to the aspect ratio of the supplied rect
#define IEIFLAG_OFFLINE     0x0008      // if the extractor shouldn't hit the net to get any content neede for the rendering
#define IEIFLAG_GLEAM       0x0010      // does the image have a gleam ? this will be returned if it does
#define IEIFLAG_SCREEN      0x0020      // render as if for the screen  (this is exlusive with IEIFLAG_ASPECT )
#define IEIFLAG_ORIGSIZE    0x0040      // render to the approx size passed, but crop if neccessary
#define IEIFLAG_NOSTAMP     0x0080      // returned from the extractor if it does NOT want an icon stamp on the thumbnail
#define IEIFLAG_NOBORDER    0x0100      // returned from the extractor if it does NOT want an a border around the thumbnail
#define IEIFLAG_QUALITY     0x0200      // passed to the Extract method to indicate that a slower, higher quality image is desired, re-compute the thumbnail
#define IEIFLAG_REFRESH     0x0400      // returned from the extractor if it would like to have Refresh Thumbnail available


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0083_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0083_v0_0_s_ifspec;

#ifndef __IExtractImage_INTERFACE_DEFINED__
#define __IExtractImage_INTERFACE_DEFINED__

/* interface IExtractImage */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IExtractImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB2E617C-0920-11d1-9A0B-00C04FC2D6C1")
    IExtractImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLocation( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszPathBuffer,
            /* [in] */ DWORD cch,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwPriority,
            /* [in] */ __RPC__in const SIZE *prgSize,
            /* [in] */ DWORD dwRecClrDepth,
            /* [out][in] */ __RPC__inout DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Extract( 
            /* [out] */ __RPC__deref_out_opt HBITMAP *phBmpThumbnail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtractImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExtractImage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExtractImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExtractImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            __RPC__in IExtractImage * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszPathBuffer,
            /* [in] */ DWORD cch,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwPriority,
            /* [in] */ __RPC__in const SIZE *prgSize,
            /* [in] */ DWORD dwRecClrDepth,
            /* [out][in] */ __RPC__inout DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            __RPC__in IExtractImage * This,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phBmpThumbnail);
        
        END_INTERFACE
    } IExtractImageVtbl;

    interface IExtractImage
    {
        CONST_VTBL struct IExtractImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtractImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExtractImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExtractImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExtractImage_GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags)	\
    ( (This)->lpVtbl -> GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags) ) 

#define IExtractImage_Extract(This,phBmpThumbnail)	\
    ( (This)->lpVtbl -> Extract(This,phBmpThumbnail) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExtractImage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0084 */
/* [local] */ 

typedef IExtractImage *LPEXTRACTIMAGE;

#endif
#if (_WIN32_IE >= 0x0500)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0084_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0084_v0_0_s_ifspec;

#ifndef __IExtractImage2_INTERFACE_DEFINED__
#define __IExtractImage2_INTERFACE_DEFINED__

/* interface IExtractImage2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IExtractImage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("953BB1EE-93B4-11d1-98A3-00C04FB687DA")
    IExtractImage2 : public IExtractImage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDateStamp( 
            /* [out] */ __RPC__out FILETIME *pDateStamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtractImage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExtractImage2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExtractImage2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExtractImage2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            __RPC__in IExtractImage2 * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszPathBuffer,
            /* [in] */ DWORD cch,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwPriority,
            /* [in] */ __RPC__in const SIZE *prgSize,
            /* [in] */ DWORD dwRecClrDepth,
            /* [out][in] */ __RPC__inout DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            __RPC__in IExtractImage2 * This,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phBmpThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *GetDateStamp )( 
            __RPC__in IExtractImage2 * This,
            /* [out] */ __RPC__out FILETIME *pDateStamp);
        
        END_INTERFACE
    } IExtractImage2Vtbl;

    interface IExtractImage2
    {
        CONST_VTBL struct IExtractImage2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtractImage2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExtractImage2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExtractImage2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExtractImage2_GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags)	\
    ( (This)->lpVtbl -> GetLocation(This,pszPathBuffer,cch,pdwPriority,prgSize,dwRecClrDepth,pdwFlags) ) 

#define IExtractImage2_Extract(This,phBmpThumbnail)	\
    ( (This)->lpVtbl -> Extract(This,phBmpThumbnail) ) 


#define IExtractImage2_GetDateStamp(This,pDateStamp)	\
    ( (This)->lpVtbl -> GetDateStamp(This,pDateStamp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExtractImage2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0085 */
/* [local] */ 

typedef IExtractImage2 *LPEXTRACTIMAGE2;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0085_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0085_v0_0_s_ifspec;

#ifndef __IThumbnailHandlerFactory_INTERFACE_DEFINED__
#define __IThumbnailHandlerFactory_INTERFACE_DEFINED__

/* interface IThumbnailHandlerFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IThumbnailHandlerFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e35b4b2e-00da-4bc1-9f13-38bc11f5d417")
    IThumbnailHandlerFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThumbnailHandler( 
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThumbnailHandlerFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IThumbnailHandlerFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IThumbnailHandlerFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IThumbnailHandlerFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnailHandler )( 
            __RPC__in IThumbnailHandlerFactory * This,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IThumbnailHandlerFactoryVtbl;

    interface IThumbnailHandlerFactory
    {
        CONST_VTBL struct IThumbnailHandlerFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThumbnailHandlerFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IThumbnailHandlerFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IThumbnailHandlerFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IThumbnailHandlerFactory_GetThumbnailHandler(This,pidlChild,pbc,riid,ppv)	\
    ( (This)->lpVtbl -> GetThumbnailHandler(This,pidlChild,pbc,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IThumbnailHandlerFactory_INTERFACE_DEFINED__ */


#ifndef __IParentAndItem_INTERFACE_DEFINED__
#define __IParentAndItem_INTERFACE_DEFINED__

/* interface IParentAndItem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IParentAndItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3a4b685-b685-4805-99d9-5dead2873236")
    IParentAndItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetParentAndItem( 
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlParent,
            /* [unique][in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetParentAndItem( 
            /* [annotation][out] */ 
            __deref_opt_out  PIDLIST_ABSOLUTE *ppidlParent,
            /* [annotation][out] */ 
            __deref_opt_out  IShellFolder **ppsf,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlChild) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParentAndItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IParentAndItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IParentAndItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IParentAndItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetParentAndItem )( 
            __RPC__in IParentAndItem * This,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlParent,
            /* [unique][in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidlChild);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetParentAndItem )( 
            IParentAndItem * This,
            /* [annotation][out] */ 
            __deref_opt_out  PIDLIST_ABSOLUTE *ppidlParent,
            /* [annotation][out] */ 
            __deref_opt_out  IShellFolder **ppsf,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlChild);
        
        END_INTERFACE
    } IParentAndItemVtbl;

    interface IParentAndItem
    {
        CONST_VTBL struct IParentAndItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParentAndItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IParentAndItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IParentAndItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IParentAndItem_SetParentAndItem(This,pidlParent,psf,pidlChild)	\
    ( (This)->lpVtbl -> SetParentAndItem(This,pidlParent,psf,pidlChild) ) 

#define IParentAndItem_GetParentAndItem(This,ppidlParent,ppsf,ppidlChild)	\
    ( (This)->lpVtbl -> GetParentAndItem(This,ppidlParent,ppsf,ppidlChild) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IParentAndItem_RemoteGetParentAndItem_Proxy( 
    __RPC__in IParentAndItem * This,
    /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidlParent,
    /* [out] */ __RPC__deref_out_opt IShellFolder **ppsf,
    /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlChild);


void __RPC_STUB IParentAndItem_RemoteGetParentAndItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IParentAndItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0087 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0087_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0087_v0_0_s_ifspec;

#ifndef __IDockingWindow_INTERFACE_DEFINED__
#define __IDockingWindow_INTERFACE_DEFINED__

/* interface IDockingWindow */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDockingWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("012dd920-7b26-11d0-8ca9-00a0c92dbfe8")
    IDockingWindow : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowDW( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDW( 
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorderDW( 
            /* [unique][in] */ __RPC__in_opt LPCRECT prcBorder,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDockingWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDockingWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDockingWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDockingWindow * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IDockingWindow * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IDockingWindow * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            __RPC__in IDockingWindow * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            __RPC__in IDockingWindow * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            __RPC__in IDockingWindow * This,
            /* [unique][in] */ __RPC__in_opt LPCRECT prcBorder,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        END_INTERFACE
    } IDockingWindowVtbl;

    interface IDockingWindow
    {
        CONST_VTBL struct IDockingWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDockingWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDockingWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDockingWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDockingWindow_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDockingWindow_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDockingWindow_ShowDW(This,fShow)	\
    ( (This)->lpVtbl -> ShowDW(This,fShow) ) 

#define IDockingWindow_CloseDW(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseDW(This,dwReserved) ) 

#define IDockingWindow_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    ( (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDockingWindow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0088 */
/* [local] */ 

#define DBIM_MINSIZE    0x0001
#define DBIM_MAXSIZE    0x0002
#define DBIM_INTEGRAL   0x0004
#define DBIM_ACTUAL     0x0008
#define DBIM_TITLE      0x0010
#define DBIM_MODEFLAGS  0x0020
#define DBIM_BKCOLOR    0x0040
#include <pshpack8.h>
typedef struct DESKBANDINFO
    {
    DWORD dwMask;
    POINTL ptMinSize;
    POINTL ptMaxSize;
    POINTL ptIntegral;
    POINTL ptActual;
    WCHAR wszTitle[ 256 ];
    DWORD dwModeFlags;
    COLORREF crBkgnd;
    } 	DESKBANDINFO;

#include <poppack.h>
#define DBIMF_NORMAL            0x0000
#define DBIMF_FIXED             0x0001
#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)
#define DBIMF_VARIABLEHEIGHT    0x0008
#define DBIMF_UNDELETEABLE      0x0010
#define DBIMF_DEBOSSED          0x0020
#define DBIMF_BKCOLOR           0x0040
#define DBIMF_USECHEVRON        0x0080
#define DBIMF_BREAK             0x0100
#define DBIMF_ADDTOFRONT        0x0200
#define DBIMF_TOPALIGN          0x0400
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define DBIMF_NOGRIPPER         0x0800
#define DBIMF_ALWAYSGRIPPER     0x1000
#define DBIMF_NOMARGINS         0x2000
#endif  // NTDDI_VISTA
#define DBIF_VIEWMODE_NORMAL         0x0000
#define DBIF_VIEWMODE_VERTICAL       0x0001
#define DBIF_VIEWMODE_FLOATING       0x0002
#define DBIF_VIEWMODE_TRANSPARENT    0x0004

enum tagDESKBANDCID
    {	DBID_BANDINFOCHANGED	= 0,
	DBID_SHOWONLY	= 1,
	DBID_MAXIMIZEBAND	= 2,
	DBID_PUSHCHEVRON	= 3,
	DBID_DELAYINIT	= 4,
	DBID_FINISHINIT	= 5,
	DBID_SETWINDOWTHEME	= 6,
	DBID_PERMITAUTOHIDE	= 7
    } ;
#define DBPC_SELECTFIRST    (DWORD)-1
#define DBPC_SELECTLAST     (DWORD)-2
#define CGID_DeskBand IID_IDeskBand


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0088_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0088_v0_0_s_ifspec;

#ifndef __IDeskBand_INTERFACE_DEFINED__
#define __IDeskBand_INTERFACE_DEFINED__

/* interface IDeskBand */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB0FE172-1A3A-11D0-89B3-00A0C90A90AC")
    IDeskBand : public IDockingWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBandInfo( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ __RPC__inout DESKBANDINFO *pdbi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDeskBand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDeskBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDeskBand * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IDeskBand * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IDeskBand * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            __RPC__in IDeskBand * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            __RPC__in IDeskBand * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            __RPC__in IDeskBand * This,
            /* [unique][in] */ __RPC__in_opt LPCRECT prcBorder,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandInfo )( 
            __RPC__in IDeskBand * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ __RPC__inout DESKBANDINFO *pdbi);
        
        END_INTERFACE
    } IDeskBandVtbl;

    interface IDeskBand
    {
        CONST_VTBL struct IDeskBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBand_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDeskBand_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDeskBand_ShowDW(This,fShow)	\
    ( (This)->lpVtbl -> ShowDW(This,fShow) ) 

#define IDeskBand_CloseDW(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseDW(This,dwReserved) ) 

#define IDeskBand_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    ( (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved) ) 


#define IDeskBand_GetBandInfo(This,dwBandID,dwViewMode,pdbi)	\
    ( (This)->lpVtbl -> GetBandInfo(This,dwBandID,dwViewMode,pdbi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBand_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0089 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0089_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0089_v0_0_s_ifspec;

#ifndef __IDeskBandInfo_INTERFACE_DEFINED__
#define __IDeskBandInfo_INTERFACE_DEFINED__

/* interface IDeskBandInfo */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBandInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77E425FC-CBF9-4307-BA6A-BB5727745661")
    IDeskBandInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultBandWidth( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out] */ __RPC__out int *pnWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBandInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDeskBandInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDeskBandInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDeskBandInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultBandWidth )( 
            __RPC__in IDeskBandInfo * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out] */ __RPC__out int *pnWidth);
        
        END_INTERFACE
    } IDeskBandInfoVtbl;

    interface IDeskBandInfo
    {
        CONST_VTBL struct IDeskBandInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBandInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBandInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBandInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBandInfo_GetDefaultBandWidth(This,dwBandID,dwViewMode,pnWidth)	\
    ( (This)->lpVtbl -> GetDefaultBandWidth(This,dwBandID,dwViewMode,pnWidth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBandInfo_INTERFACE_DEFINED__ */


#ifndef __IDeskBand2_INTERFACE_DEFINED__
#define __IDeskBand2_INTERFACE_DEFINED__

/* interface IDeskBand2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBand2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79D16DE4-ABEE-4021-8D9D-9169B261D657")
    IDeskBand2 : public IDeskBand
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CanRenderComposited( 
            /* [out] */ __RPC__out BOOL *pfCanRenderComposited) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionState( 
            /* [in] */ BOOL fCompositionEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionState( 
            /* [out] */ __RPC__out BOOL *pfCompositionEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBand2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDeskBand2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDeskBand2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDeskBand2 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IDeskBand2 * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            __RPC__in IDeskBand2 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            __RPC__in IDeskBand2 * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            __RPC__in IDeskBand2 * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            __RPC__in IDeskBand2 * This,
            /* [unique][in] */ __RPC__in_opt LPCRECT prcBorder,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandInfo )( 
            __RPC__in IDeskBand2 * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ __RPC__inout DESKBANDINFO *pdbi);
        
        HRESULT ( STDMETHODCALLTYPE *CanRenderComposited )( 
            __RPC__in IDeskBand2 * This,
            /* [out] */ __RPC__out BOOL *pfCanRenderComposited);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionState )( 
            __RPC__in IDeskBand2 * This,
            /* [in] */ BOOL fCompositionEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionState )( 
            __RPC__in IDeskBand2 * This,
            /* [out] */ __RPC__out BOOL *pfCompositionEnabled);
        
        END_INTERFACE
    } IDeskBand2Vtbl;

    interface IDeskBand2
    {
        CONST_VTBL struct IDeskBand2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBand2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBand2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBand2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBand2_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDeskBand2_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDeskBand2_ShowDW(This,fShow)	\
    ( (This)->lpVtbl -> ShowDW(This,fShow) ) 

#define IDeskBand2_CloseDW(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseDW(This,dwReserved) ) 

#define IDeskBand2_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    ( (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved) ) 


#define IDeskBand2_GetBandInfo(This,dwBandID,dwViewMode,pdbi)	\
    ( (This)->lpVtbl -> GetBandInfo(This,dwBandID,dwViewMode,pdbi) ) 


#define IDeskBand2_CanRenderComposited(This,pfCanRenderComposited)	\
    ( (This)->lpVtbl -> CanRenderComposited(This,pfCanRenderComposited) ) 

#define IDeskBand2_SetCompositionState(This,fCompositionEnabled)	\
    ( (This)->lpVtbl -> SetCompositionState(This,fCompositionEnabled) ) 

#define IDeskBand2_GetCompositionState(This,pfCompositionEnabled)	\
    ( (This)->lpVtbl -> GetCompositionState(This,pfCompositionEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBand2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0091 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0091_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0091_v0_0_s_ifspec;

#ifndef __ITaskbarList_INTERFACE_DEFINED__
#define __ITaskbarList_INTERFACE_DEFINED__

/* interface ITaskbarList */
/* [object][uuid] */ 


EXTERN_C const IID IID_ITaskbarList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56FDF342-FD6D-11d0-958A-006097C9A090")
    ITaskbarList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HrInit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTab( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTab( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateTab( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveAlt( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskbarListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITaskbarList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITaskbarList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITaskbarList * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrInit )( 
            __RPC__in ITaskbarList * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTab )( 
            __RPC__in ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTab )( 
            __RPC__in ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateTab )( 
            __RPC__in ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveAlt )( 
            __RPC__in ITaskbarList * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        END_INTERFACE
    } ITaskbarListVtbl;

    interface ITaskbarList
    {
        CONST_VTBL struct ITaskbarListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskbarList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITaskbarList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITaskbarList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITaskbarList_HrInit(This)	\
    ( (This)->lpVtbl -> HrInit(This) ) 

#define ITaskbarList_AddTab(This,hwnd)	\
    ( (This)->lpVtbl -> AddTab(This,hwnd) ) 

#define ITaskbarList_DeleteTab(This,hwnd)	\
    ( (This)->lpVtbl -> DeleteTab(This,hwnd) ) 

#define ITaskbarList_ActivateTab(This,hwnd)	\
    ( (This)->lpVtbl -> ActivateTab(This,hwnd) ) 

#define ITaskbarList_SetActiveAlt(This,hwnd)	\
    ( (This)->lpVtbl -> SetActiveAlt(This,hwnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITaskbarList_INTERFACE_DEFINED__ */


#ifndef __ITaskbarList2_INTERFACE_DEFINED__
#define __ITaskbarList2_INTERFACE_DEFINED__

/* interface ITaskbarList2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_ITaskbarList2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("602D4995-B13A-429b-A66E-1935E44F4317")
    ITaskbarList2 : public ITaskbarList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MarkFullscreenWindow( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ BOOL fFullscreen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskbarList2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITaskbarList2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITaskbarList2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITaskbarList2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrInit )( 
            __RPC__in ITaskbarList2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTab )( 
            __RPC__in ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTab )( 
            __RPC__in ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateTab )( 
            __RPC__in ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveAlt )( 
            __RPC__in ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *MarkFullscreenWindow )( 
            __RPC__in ITaskbarList2 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ BOOL fFullscreen);
        
        END_INTERFACE
    } ITaskbarList2Vtbl;

    interface ITaskbarList2
    {
        CONST_VTBL struct ITaskbarList2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskbarList2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITaskbarList2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITaskbarList2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITaskbarList2_HrInit(This)	\
    ( (This)->lpVtbl -> HrInit(This) ) 

#define ITaskbarList2_AddTab(This,hwnd)	\
    ( (This)->lpVtbl -> AddTab(This,hwnd) ) 

#define ITaskbarList2_DeleteTab(This,hwnd)	\
    ( (This)->lpVtbl -> DeleteTab(This,hwnd) ) 

#define ITaskbarList2_ActivateTab(This,hwnd)	\
    ( (This)->lpVtbl -> ActivateTab(This,hwnd) ) 

#define ITaskbarList2_SetActiveAlt(This,hwnd)	\
    ( (This)->lpVtbl -> SetActiveAlt(This,hwnd) ) 


#define ITaskbarList2_MarkFullscreenWindow(This,hwnd,fFullscreen)	\
    ( (This)->lpVtbl -> MarkFullscreenWindow(This,hwnd,fFullscreen) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITaskbarList2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0093 */
/* [local] */ 

#ifdef MIDL_PASS
typedef IUnknown *HIMAGELIST;

#endif
typedef /* [v1_enum] */ 
enum THUMBBUTTONFLAGS
    {	THBF_ENABLED	= 0,
	THBF_DISABLED	= 0x1,
	THBF_DISMISSONCLICK	= 0x2,
	THBF_NOBACKGROUND	= 0x4,
	THBF_HIDDEN	= 0x8,
	THBF_NONINTERACTIVE	= 0x10
    } 	THUMBBUTTONFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(THUMBBUTTONFLAGS)
typedef /* [v1_enum] */ 
enum THUMBBUTTONMASK
    {	THB_BITMAP	= 0x1,
	THB_ICON	= 0x2,
	THB_TOOLTIP	= 0x4,
	THB_FLAGS	= 0x8
    } 	THUMBBUTTONMASK;

DEFINE_ENUM_FLAG_OPERATORS(THUMBBUTTONMASK)
#include <pshpack8.h>
typedef struct THUMBBUTTON
    {
    THUMBBUTTONMASK dwMask;
    UINT iId;
    UINT iBitmap;
    HICON hIcon;
    WCHAR szTip[ 260 ];
    THUMBBUTTONFLAGS dwFlags;
    } 	THUMBBUTTON;

typedef struct THUMBBUTTON *LPTHUMBBUTTON;

#include <poppack.h>
#define THBN_CLICKED        0x1800


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0093_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0093_v0_0_s_ifspec;

#ifndef __ITaskbarList3_INTERFACE_DEFINED__
#define __ITaskbarList3_INTERFACE_DEFINED__

/* interface ITaskbarList3 */
/* [object][uuid] */ 

typedef /* [v1_enum] */ 
enum TBPFLAG
    {	TBPF_NOPROGRESS	= 0,
	TBPF_INDETERMINATE	= 0x1,
	TBPF_NORMAL	= 0x2,
	TBPF_ERROR	= 0x4,
	TBPF_PAUSED	= 0x8
    } 	TBPFLAG;

DEFINE_ENUM_FLAG_OPERATORS(TBPFLAG)

EXTERN_C const IID IID_ITaskbarList3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")
    ITaskbarList3 : public ITaskbarList2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProgressValue( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ ULONGLONG ullCompleted,
            /* [in] */ ULONGLONG ullTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgressState( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ TBPFLAG tbpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterTab( 
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndMDI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterTab( 
            /* [in] */ __RPC__in HWND hwndTab) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTabOrder( 
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndInsertBefore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTabActive( 
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndMDI,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThumbBarAddButtons( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ UINT cButtons,
            /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON pButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThumbBarUpdateButtons( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ UINT cButtons,
            /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON pButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThumbBarSetImageList( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in_opt HIMAGELIST himl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOverlayIcon( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnailTooltip( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnailClip( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in RECT *prcClip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskbarList3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITaskbarList3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITaskbarList3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrInit )( 
            __RPC__in ITaskbarList3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTab )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTab )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateTab )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveAlt )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *MarkFullscreenWindow )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ BOOL fFullscreen);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressValue )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ ULONGLONG ullCompleted,
            /* [in] */ ULONGLONG ullTotal);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressState )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ TBPFLAG tbpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterTab )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndMDI);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterTab )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwndTab);
        
        HRESULT ( STDMETHODCALLTYPE *SetTabOrder )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndInsertBefore);
        
        HRESULT ( STDMETHODCALLTYPE *SetTabActive )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndMDI,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ThumbBarAddButtons )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ UINT cButtons,
            /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON pButton);
        
        HRESULT ( STDMETHODCALLTYPE *ThumbBarUpdateButtons )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ UINT cButtons,
            /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON pButton);
        
        HRESULT ( STDMETHODCALLTYPE *ThumbBarSetImageList )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in_opt HIMAGELIST himl);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlayIcon )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailTooltip )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTip);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailClip )( 
            __RPC__in ITaskbarList3 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in RECT *prcClip);
        
        END_INTERFACE
    } ITaskbarList3Vtbl;

    interface ITaskbarList3
    {
        CONST_VTBL struct ITaskbarList3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskbarList3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITaskbarList3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITaskbarList3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITaskbarList3_HrInit(This)	\
    ( (This)->lpVtbl -> HrInit(This) ) 

#define ITaskbarList3_AddTab(This,hwnd)	\
    ( (This)->lpVtbl -> AddTab(This,hwnd) ) 

#define ITaskbarList3_DeleteTab(This,hwnd)	\
    ( (This)->lpVtbl -> DeleteTab(This,hwnd) ) 

#define ITaskbarList3_ActivateTab(This,hwnd)	\
    ( (This)->lpVtbl -> ActivateTab(This,hwnd) ) 

#define ITaskbarList3_SetActiveAlt(This,hwnd)	\
    ( (This)->lpVtbl -> SetActiveAlt(This,hwnd) ) 


#define ITaskbarList3_MarkFullscreenWindow(This,hwnd,fFullscreen)	\
    ( (This)->lpVtbl -> MarkFullscreenWindow(This,hwnd,fFullscreen) ) 


#define ITaskbarList3_SetProgressValue(This,hwnd,ullCompleted,ullTotal)	\
    ( (This)->lpVtbl -> SetProgressValue(This,hwnd,ullCompleted,ullTotal) ) 

#define ITaskbarList3_SetProgressState(This,hwnd,tbpFlags)	\
    ( (This)->lpVtbl -> SetProgressState(This,hwnd,tbpFlags) ) 

#define ITaskbarList3_RegisterTab(This,hwndTab,hwndMDI)	\
    ( (This)->lpVtbl -> RegisterTab(This,hwndTab,hwndMDI) ) 

#define ITaskbarList3_UnregisterTab(This,hwndTab)	\
    ( (This)->lpVtbl -> UnregisterTab(This,hwndTab) ) 

#define ITaskbarList3_SetTabOrder(This,hwndTab,hwndInsertBefore)	\
    ( (This)->lpVtbl -> SetTabOrder(This,hwndTab,hwndInsertBefore) ) 

#define ITaskbarList3_SetTabActive(This,hwndTab,hwndMDI,dwReserved)	\
    ( (This)->lpVtbl -> SetTabActive(This,hwndTab,hwndMDI,dwReserved) ) 

#define ITaskbarList3_ThumbBarAddButtons(This,hwnd,cButtons,pButton)	\
    ( (This)->lpVtbl -> ThumbBarAddButtons(This,hwnd,cButtons,pButton) ) 

#define ITaskbarList3_ThumbBarUpdateButtons(This,hwnd,cButtons,pButton)	\
    ( (This)->lpVtbl -> ThumbBarUpdateButtons(This,hwnd,cButtons,pButton) ) 

#define ITaskbarList3_ThumbBarSetImageList(This,hwnd,himl)	\
    ( (This)->lpVtbl -> ThumbBarSetImageList(This,hwnd,himl) ) 

#define ITaskbarList3_SetOverlayIcon(This,hwnd,hIcon,pszDescription)	\
    ( (This)->lpVtbl -> SetOverlayIcon(This,hwnd,hIcon,pszDescription) ) 

#define ITaskbarList3_SetThumbnailTooltip(This,hwnd,pszTip)	\
    ( (This)->lpVtbl -> SetThumbnailTooltip(This,hwnd,pszTip) ) 

#define ITaskbarList3_SetThumbnailClip(This,hwnd,prcClip)	\
    ( (This)->lpVtbl -> SetThumbnailClip(This,hwnd,prcClip) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITaskbarList3_INTERFACE_DEFINED__ */


#ifndef __ITaskbarList4_INTERFACE_DEFINED__
#define __ITaskbarList4_INTERFACE_DEFINED__

/* interface ITaskbarList4 */
/* [object][uuid] */ 

typedef /* [v1_enum] */ 
enum STPFLAG
    {	STPF_NONE	= 0,
	STPF_USEAPPTHUMBNAILALWAYS	= 0x1,
	STPF_USEAPPTHUMBNAILWHENACTIVE	= 0x2,
	STPF_USEAPPPEEKALWAYS	= 0x4,
	STPF_USEAPPPEEKWHENACTIVE	= 0x8
    } 	STPFLAG;

DEFINE_ENUM_FLAG_OPERATORS(STPFLAG)

EXTERN_C const IID IID_ITaskbarList4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c43dc798-95d1-4bea-9030-bb99e2983a1a")
    ITaskbarList4 : public ITaskbarList3
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTabProperties( 
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ STPFLAG stpFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskbarList4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITaskbarList4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITaskbarList4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrInit )( 
            __RPC__in ITaskbarList4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTab )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTab )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateTab )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveAlt )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *MarkFullscreenWindow )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ BOOL fFullscreen);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressValue )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ ULONGLONG ullCompleted,
            /* [in] */ ULONGLONG ullTotal);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressState )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ TBPFLAG tbpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterTab )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndMDI);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterTab )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwndTab);
        
        HRESULT ( STDMETHODCALLTYPE *SetTabOrder )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndInsertBefore);
        
        HRESULT ( STDMETHODCALLTYPE *SetTabActive )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ __RPC__in HWND hwndMDI,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ThumbBarAddButtons )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ UINT cButtons,
            /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON pButton);
        
        HRESULT ( STDMETHODCALLTYPE *ThumbBarUpdateButtons )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ UINT cButtons,
            /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON pButton);
        
        HRESULT ( STDMETHODCALLTYPE *ThumbBarSetImageList )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in_opt HIMAGELIST himl);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlayIcon )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in HICON hIcon,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailTooltip )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTip);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailClip )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in RECT *prcClip);
        
        HRESULT ( STDMETHODCALLTYPE *SetTabProperties )( 
            __RPC__in ITaskbarList4 * This,
            /* [in] */ __RPC__in HWND hwndTab,
            /* [in] */ STPFLAG stpFlags);
        
        END_INTERFACE
    } ITaskbarList4Vtbl;

    interface ITaskbarList4
    {
        CONST_VTBL struct ITaskbarList4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskbarList4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITaskbarList4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITaskbarList4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITaskbarList4_HrInit(This)	\
    ( (This)->lpVtbl -> HrInit(This) ) 

#define ITaskbarList4_AddTab(This,hwnd)	\
    ( (This)->lpVtbl -> AddTab(This,hwnd) ) 

#define ITaskbarList4_DeleteTab(This,hwnd)	\
    ( (This)->lpVtbl -> DeleteTab(This,hwnd) ) 

#define ITaskbarList4_ActivateTab(This,hwnd)	\
    ( (This)->lpVtbl -> ActivateTab(This,hwnd) ) 

#define ITaskbarList4_SetActiveAlt(This,hwnd)	\
    ( (This)->lpVtbl -> SetActiveAlt(This,hwnd) ) 


#define ITaskbarList4_MarkFullscreenWindow(This,hwnd,fFullscreen)	\
    ( (This)->lpVtbl -> MarkFullscreenWindow(This,hwnd,fFullscreen) ) 


#define ITaskbarList4_SetProgressValue(This,hwnd,ullCompleted,ullTotal)	\
    ( (This)->lpVtbl -> SetProgressValue(This,hwnd,ullCompleted,ullTotal) ) 

#define ITaskbarList4_SetProgressState(This,hwnd,tbpFlags)	\
    ( (This)->lpVtbl -> SetProgressState(This,hwnd,tbpFlags) ) 

#define ITaskbarList4_RegisterTab(This,hwndTab,hwndMDI)	\
    ( (This)->lpVtbl -> RegisterTab(This,hwndTab,hwndMDI) ) 

#define ITaskbarList4_UnregisterTab(This,hwndTab)	\
    ( (This)->lpVtbl -> UnregisterTab(This,hwndTab) ) 

#define ITaskbarList4_SetTabOrder(This,hwndTab,hwndInsertBefore)	\
    ( (This)->lpVtbl -> SetTabOrder(This,hwndTab,hwndInsertBefore) ) 

#define ITaskbarList4_SetTabActive(This,hwndTab,hwndMDI,dwReserved)	\
    ( (This)->lpVtbl -> SetTabActive(This,hwndTab,hwndMDI,dwReserved) ) 

#define ITaskbarList4_ThumbBarAddButtons(This,hwnd,cButtons,pButton)	\
    ( (This)->lpVtbl -> ThumbBarAddButtons(This,hwnd,cButtons,pButton) ) 

#define ITaskbarList4_ThumbBarUpdateButtons(This,hwnd,cButtons,pButton)	\
    ( (This)->lpVtbl -> ThumbBarUpdateButtons(This,hwnd,cButtons,pButton) ) 

#define ITaskbarList4_ThumbBarSetImageList(This,hwnd,himl)	\
    ( (This)->lpVtbl -> ThumbBarSetImageList(This,hwnd,himl) ) 

#define ITaskbarList4_SetOverlayIcon(This,hwnd,hIcon,pszDescription)	\
    ( (This)->lpVtbl -> SetOverlayIcon(This,hwnd,hIcon,pszDescription) ) 

#define ITaskbarList4_SetThumbnailTooltip(This,hwnd,pszTip)	\
    ( (This)->lpVtbl -> SetThumbnailTooltip(This,hwnd,pszTip) ) 

#define ITaskbarList4_SetThumbnailClip(This,hwnd,prcClip)	\
    ( (This)->lpVtbl -> SetThumbnailClip(This,hwnd,prcClip) ) 


#define ITaskbarList4_SetTabProperties(This,hwndTab,stpFlags)	\
    ( (This)->lpVtbl -> SetTabProperties(This,hwndTab,stpFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITaskbarList4_INTERFACE_DEFINED__ */


#ifndef __IStartMenuPinnedList_INTERFACE_DEFINED__
#define __IStartMenuPinnedList_INTERFACE_DEFINED__

/* interface IStartMenuPinnedList */
/* [object][uuid] */ 


EXTERN_C const IID IID_IStartMenuPinnedList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CD19ADA-25A5-4A32-B3B7-347BEE5BE36B")
    IStartMenuPinnedList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemoveFromList( 
            /* [in] */ __RPC__in_opt IShellItem *pitem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStartMenuPinnedListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStartMenuPinnedList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStartMenuPinnedList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStartMenuPinnedList * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromList )( 
            __RPC__in IStartMenuPinnedList * This,
            /* [in] */ __RPC__in_opt IShellItem *pitem);
        
        END_INTERFACE
    } IStartMenuPinnedListVtbl;

    interface IStartMenuPinnedList
    {
        CONST_VTBL struct IStartMenuPinnedListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStartMenuPinnedList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStartMenuPinnedList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStartMenuPinnedList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStartMenuPinnedList_RemoveFromList(This,pitem)	\
    ( (This)->lpVtbl -> RemoveFromList(This,pitem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStartMenuPinnedList_INTERFACE_DEFINED__ */


#ifndef __ICDBurn_INTERFACE_DEFINED__
#define __ICDBurn_INTERFACE_DEFINED__

/* interface ICDBurn */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICDBurn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d73a659-e5d0-4d42-afc0-5121ba425c8d")
    ICDBurn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRecorderDriveLetter( 
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDrive,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Burn( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasRecordableDrive( 
            /* [out] */ __RPC__out BOOL *pfHasRecorder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICDBurnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICDBurn * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICDBurn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICDBurn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecorderDriveLetter )( 
            __RPC__in ICDBurn * This,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cch) LPWSTR pszDrive,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE *Burn )( 
            __RPC__in ICDBurn * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *HasRecordableDrive )( 
            __RPC__in ICDBurn * This,
            /* [out] */ __RPC__out BOOL *pfHasRecorder);
        
        END_INTERFACE
    } ICDBurnVtbl;

    interface ICDBurn
    {
        CONST_VTBL struct ICDBurnVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICDBurn_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICDBurn_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICDBurn_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICDBurn_GetRecorderDriveLetter(This,pszDrive,cch)	\
    ( (This)->lpVtbl -> GetRecorderDriveLetter(This,pszDrive,cch) ) 

#define ICDBurn_Burn(This,hwnd)	\
    ( (This)->lpVtbl -> Burn(This,hwnd) ) 

#define ICDBurn_HasRecordableDrive(This,pfHasRecorder)	\
    ( (This)->lpVtbl -> HasRecordableDrive(This,pfHasRecorder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICDBurn_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0097 */
/* [local] */ 

#define IDD_WIZEXTN_FIRST    0x5000
#define IDD_WIZEXTN_LAST     0x5100


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0097_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0097_v0_0_s_ifspec;

#ifndef __IWizardSite_INTERFACE_DEFINED__
#define __IWizardSite_INTERFACE_DEFINED__

/* interface IWizardSite */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IWizardSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88960f5b-422f-4e7b-8013-73415381c3c3")
    IWizardSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreviousPage( 
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPage( 
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCancelledPage( 
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWizardSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWizardSite * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWizardSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWizardSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreviousPage )( 
            IWizardSite * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextPage )( 
            IWizardSite * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetCancelledPage )( 
            IWizardSite * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        END_INTERFACE
    } IWizardSiteVtbl;

    interface IWizardSite
    {
        CONST_VTBL struct IWizardSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWizardSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWizardSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWizardSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWizardSite_GetPreviousPage(This,phpage)	\
    ( (This)->lpVtbl -> GetPreviousPage(This,phpage) ) 

#define IWizardSite_GetNextPage(This,phpage)	\
    ( (This)->lpVtbl -> GetNextPage(This,phpage) ) 

#define IWizardSite_GetCancelledPage(This,phpage)	\
    ( (This)->lpVtbl -> GetCancelledPage(This,phpage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWizardSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0098 */
/* [local] */ 

#define SID_WizardSite IID_IWizardSite


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0098_v0_0_s_ifspec;

#ifndef __IWizardExtension_INTERFACE_DEFINED__
#define __IWizardExtension_INTERFACE_DEFINED__

/* interface IWizardExtension */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IWizardExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c02ea696-86cc-491e-9b23-74394a0444a8")
    IWizardExtension : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [annotation][size_is][out] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [annotation][in] */ 
            __in  UINT cPages,
            /* [annotation][out] */ 
            __out __deref_out_range(0, cPages)  UINT *pnPagesAdded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstPage( 
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPage( 
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWizardExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWizardExtension * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWizardExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWizardExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IWizardExtension * This,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [annotation][in] */ 
            __in  UINT cPages,
            /* [annotation][out] */ 
            __out __deref_out_range(0, cPages)  UINT *pnPagesAdded);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPage )( 
            IWizardExtension * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPage )( 
            IWizardExtension * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        END_INTERFACE
    } IWizardExtensionVtbl;

    interface IWizardExtension
    {
        CONST_VTBL struct IWizardExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWizardExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWizardExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWizardExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWizardExtension_AddPages(This,aPages,cPages,pnPagesAdded)	\
    ( (This)->lpVtbl -> AddPages(This,aPages,cPages,pnPagesAdded) ) 

#define IWizardExtension_GetFirstPage(This,phpage)	\
    ( (This)->lpVtbl -> GetFirstPage(This,phpage) ) 

#define IWizardExtension_GetLastPage(This,phpage)	\
    ( (This)->lpVtbl -> GetLastPage(This,phpage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWizardExtension_INTERFACE_DEFINED__ */


#ifndef __IWebWizardExtension_INTERFACE_DEFINED__
#define __IWebWizardExtension_INTERFACE_DEFINED__

/* interface IWebWizardExtension */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IWebWizardExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e6b3f66-98d1-48c0-a222-fbde74e2fbc5")
    IWebWizardExtension : public IWizardExtension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInitialURL( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorURL( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszErrorURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebWizardExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebWizardExtension * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebWizardExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebWizardExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IWebWizardExtension * This,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [annotation][in] */ 
            __in  UINT cPages,
            /* [annotation][out] */ 
            __out __deref_out_range(0, cPages)  UINT *pnPagesAdded);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPage )( 
            IWebWizardExtension * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPage )( 
            IWebWizardExtension * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *SetInitialURL )( 
            IWebWizardExtension * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorURL )( 
            IWebWizardExtension * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszErrorURL);
        
        END_INTERFACE
    } IWebWizardExtensionVtbl;

    interface IWebWizardExtension
    {
        CONST_VTBL struct IWebWizardExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebWizardExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWebWizardExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWebWizardExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWebWizardExtension_AddPages(This,aPages,cPages,pnPagesAdded)	\
    ( (This)->lpVtbl -> AddPages(This,aPages,cPages,pnPagesAdded) ) 

#define IWebWizardExtension_GetFirstPage(This,phpage)	\
    ( (This)->lpVtbl -> GetFirstPage(This,phpage) ) 

#define IWebWizardExtension_GetLastPage(This,phpage)	\
    ( (This)->lpVtbl -> GetLastPage(This,phpage) ) 


#define IWebWizardExtension_SetInitialURL(This,pszURL)	\
    ( (This)->lpVtbl -> SetInitialURL(This,pszURL) ) 

#define IWebWizardExtension_SetErrorURL(This,pszErrorURL)	\
    ( (This)->lpVtbl -> SetErrorURL(This,pszErrorURL) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWebWizardExtension_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0100 */
/* [local] */ 

#define SID_WebWizardHost IID_IWebWizardExtension
#define SHPWHF_NORECOMPRESS             0x00000001  // don't allow/prompt for recompress of streams
#define SHPWHF_NONETPLACECREATE         0x00000002  // don't create a network place when transfer is complete
#define SHPWHF_NOFILESELECTOR           0x00000004  // don't show the file selector
#define SHPWHF_USEMRU                   0x00000008  // For OPW.  Use the Most-Recently-Used Print Provider
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define SHPWHF_ANYLOCATION              0x00000100  // allow publishing to any location
#endif  // NTDDI_VISTA
#define SHPWHF_VALIDATEVIAWEBFOLDERS    0x00010000  // enable web folders to validate network places (ANP support)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0100_v0_0_s_ifspec;

#ifndef __IPublishingWizard_INTERFACE_DEFINED__
#define __IPublishingWizard_INTERFACE_DEFINED__

/* interface IPublishingWizard */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IPublishingWizard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa9198bb-ccec-472d-beed-19a4f6733f7a")
    IPublishingWizard : public IWizardExtension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [annotation][unique][in] */ 
            __in_opt  IDataObject *pdo,
            /* [annotation][in] */ 
            __in  DWORD dwOptions,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszServiceScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransferManifest( 
            /* [annotation][out] */ 
            __out_opt  HRESULT *phrFromTransfer,
            /* [annotation][out] */ 
            __deref_opt_out  IXMLDOMDocument **pdocManifest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublishingWizardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPublishingWizard * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPublishingWizard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPublishingWizard * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IPublishingWizard * This,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(cPages, *pnPagesAdded)  HPROPSHEETPAGE *aPages,
            /* [annotation][in] */ 
            __in  UINT cPages,
            /* [annotation][out] */ 
            __out __deref_out_range(0, cPages)  UINT *pnPagesAdded);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPage )( 
            IPublishingWizard * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPage )( 
            IPublishingWizard * This,
            /* [annotation][out] */ 
            __out  HPROPSHEETPAGE *phpage);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPublishingWizard * This,
            /* [annotation][unique][in] */ 
            __in_opt  IDataObject *pdo,
            /* [annotation][in] */ 
            __in  DWORD dwOptions,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszServiceScope);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransferManifest )( 
            IPublishingWizard * This,
            /* [annotation][out] */ 
            __out_opt  HRESULT *phrFromTransfer,
            /* [annotation][out] */ 
            __deref_opt_out  IXMLDOMDocument **pdocManifest);
        
        END_INTERFACE
    } IPublishingWizardVtbl;

    interface IPublishingWizard
    {
        CONST_VTBL struct IPublishingWizardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublishingWizard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPublishingWizard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPublishingWizard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPublishingWizard_AddPages(This,aPages,cPages,pnPagesAdded)	\
    ( (This)->lpVtbl -> AddPages(This,aPages,cPages,pnPagesAdded) ) 

#define IPublishingWizard_GetFirstPage(This,phpage)	\
    ( (This)->lpVtbl -> GetFirstPage(This,phpage) ) 

#define IPublishingWizard_GetLastPage(This,phpage)	\
    ( (This)->lpVtbl -> GetLastPage(This,phpage) ) 


#define IPublishingWizard_Initialize(This,pdo,dwOptions,pszServiceScope)	\
    ( (This)->lpVtbl -> Initialize(This,pdo,dwOptions,pszServiceScope) ) 

#define IPublishingWizard_GetTransferManifest(This,phrFromTransfer,pdocManifest)	\
    ( (This)->lpVtbl -> GetTransferManifest(This,phrFromTransfer,pdocManifest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPublishingWizard_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0101 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0101_v0_0_s_ifspec;

#ifndef __IFolderViewHost_INTERFACE_DEFINED__
#define __IFolderViewHost_INTERFACE_DEFINED__

/* interface IFolderViewHost */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IFolderViewHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ea58f02-d55a-411d-b09e-9e65ac21605b")
    IFolderViewHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [annotation][in] */ 
            __in  HWND hwndParent,
            /* [annotation][in] */ 
            __in  IDataObject *pdo,
            /* [annotation][in] */ 
            __in  RECT *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderViewHost * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderViewHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderViewHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IFolderViewHost * This,
            /* [annotation][in] */ 
            __in  HWND hwndParent,
            /* [annotation][in] */ 
            __in  IDataObject *pdo,
            /* [annotation][in] */ 
            __in  RECT *prc);
        
        END_INTERFACE
    } IFolderViewHostVtbl;

    interface IFolderViewHost
    {
        CONST_VTBL struct IFolderViewHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderViewHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderViewHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderViewHost_Initialize(This,hwndParent,pdo,prc)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,pdo,prc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderViewHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0102 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0102_v0_0_s_ifspec;

#ifndef __IExplorerBrowserEvents_INTERFACE_DEFINED__
#define __IExplorerBrowserEvents_INTERFACE_DEFINED__

/* interface IExplorerBrowserEvents */
/* [object][uuid] */ 


EXTERN_C const IID IID_IExplorerBrowserEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("361bbdc7-e6ee-4e13-be58-58e2240c810f")
    IExplorerBrowserEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnNavigationPending( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnViewCreated( 
            /* [in] */ __RPC__in_opt IShellView *psv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigationComplete( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigationFailed( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerBrowserEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExplorerBrowserEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExplorerBrowserEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExplorerBrowserEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationPending )( 
            __RPC__in IExplorerBrowserEvents * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder);
        
        HRESULT ( STDMETHODCALLTYPE *OnViewCreated )( 
            __RPC__in IExplorerBrowserEvents * This,
            /* [in] */ __RPC__in_opt IShellView *psv);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationComplete )( 
            __RPC__in IExplorerBrowserEvents * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationFailed )( 
            __RPC__in IExplorerBrowserEvents * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlFolder);
        
        END_INTERFACE
    } IExplorerBrowserEventsVtbl;

    interface IExplorerBrowserEvents
    {
        CONST_VTBL struct IExplorerBrowserEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerBrowserEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerBrowserEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerBrowserEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerBrowserEvents_OnNavigationPending(This,pidlFolder)	\
    ( (This)->lpVtbl -> OnNavigationPending(This,pidlFolder) ) 

#define IExplorerBrowserEvents_OnViewCreated(This,psv)	\
    ( (This)->lpVtbl -> OnViewCreated(This,psv) ) 

#define IExplorerBrowserEvents_OnNavigationComplete(This,pidlFolder)	\
    ( (This)->lpVtbl -> OnNavigationComplete(This,pidlFolder) ) 

#define IExplorerBrowserEvents_OnNavigationFailed(This,pidlFolder)	\
    ( (This)->lpVtbl -> OnNavigationFailed(This,pidlFolder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerBrowserEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0103 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum EXPLORER_BROWSER_OPTIONS
    {	EBO_NONE	= 0,
	EBO_NAVIGATEONCE	= 0x1,
	EBO_SHOWFRAMES	= 0x2,
	EBO_ALWAYSNAVIGATE	= 0x4,
	EBO_NOTRAVELLOG	= 0x8,
	EBO_NOWRAPPERWINDOW	= 0x10,
	EBO_HTMLSHAREPOINTVIEW	= 0x20
    } 	EXPLORER_BROWSER_OPTIONS;

DEFINE_ENUM_FLAG_OPERATORS(EXPLORER_BROWSER_OPTIONS)
typedef /* [v1_enum] */ 
enum EXPLORER_BROWSER_FILL_FLAGS
    {	EBF_NONE	= 0,
	EBF_SELECTFROMDATAOBJECT	= 0x100,
	EBF_NODROPTARGET	= 0x200
    } 	EXPLORER_BROWSER_FILL_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(EXPLORER_BROWSER_FILL_FLAGS)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0103_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0103_v0_0_s_ifspec;

#ifndef __IExplorerBrowser_INTERFACE_DEFINED__
#define __IExplorerBrowser_INTERFACE_DEFINED__

/* interface IExplorerBrowser */
/* [object][uuid] */ 


EXTERN_C const IID IID_IExplorerBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dfd3b6b5-c10c-4be9-85f6-a66969f402f6")
    IExplorerBrowser : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [annotation][in] */ 
            __in  HWND hwndParent,
            /* [annotation][in] */ 
            __in  const RECT *prc,
            /* [annotation][unique][in] */ 
            __in_opt  const FOLDERSETTINGS *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetRect( 
            /* [annotation][unique][out][in] */ 
            __inout_opt  HDWP *phdwp,
            /* [annotation][in] */ 
            __in  RECT rcBrowser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyBag( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropertyBag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEmptyText( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszEmptyText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderSettings( 
            /* [in] */ __RPC__in const FOLDERSETTINGS *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IExplorerBrowserEvents *psbe,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ EXPLORER_BROWSER_OPTIONS dwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ __RPC__out EXPLORER_BROWSER_OPTIONS *pdwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseToIDList( 
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseToObject( 
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillFromObject( 
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ EXPLORER_BROWSER_FILL_FLAGS dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentView( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExplorerBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExplorerBrowser * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IExplorerBrowser * This,
            /* [annotation][in] */ 
            __in  HWND hwndParent,
            /* [annotation][in] */ 
            __in  const RECT *prc,
            /* [annotation][unique][in] */ 
            __in_opt  const FOLDERSETTINGS *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            __RPC__in IExplorerBrowser * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IExplorerBrowser * This,
            /* [annotation][unique][out][in] */ 
            __inout_opt  HDWP *phdwp,
            /* [annotation][in] */ 
            __in  RECT rcBrowser);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyBag )( 
            __RPC__in IExplorerBrowser * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropertyBag);
        
        HRESULT ( STDMETHODCALLTYPE *SetEmptyText )( 
            __RPC__in IExplorerBrowser * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszEmptyText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderSettings )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ __RPC__in const FOLDERSETTINGS *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ __RPC__in_opt IExplorerBrowserEvents *psbe,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ EXPLORER_BROWSER_OPTIONS dwFlag);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            __RPC__in IExplorerBrowser * This,
            /* [out] */ __RPC__out EXPLORER_BROWSER_OPTIONS *pdwFlag);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseToIDList )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ __RPC__in PCUIDLIST_RELATIVE pidl,
            /* [in] */ UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseToObject )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FillFromObject )( 
            __RPC__in IExplorerBrowser * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ EXPLORER_BROWSER_FILL_FLAGS dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            __RPC__in IExplorerBrowser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentView )( 
            __RPC__in IExplorerBrowser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IExplorerBrowserVtbl;

    interface IExplorerBrowser
    {
        CONST_VTBL struct IExplorerBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerBrowser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerBrowser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerBrowser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerBrowser_Initialize(This,hwndParent,prc,pfs)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,prc,pfs) ) 

#define IExplorerBrowser_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IExplorerBrowser_SetRect(This,phdwp,rcBrowser)	\
    ( (This)->lpVtbl -> SetRect(This,phdwp,rcBrowser) ) 

#define IExplorerBrowser_SetPropertyBag(This,pszPropertyBag)	\
    ( (This)->lpVtbl -> SetPropertyBag(This,pszPropertyBag) ) 

#define IExplorerBrowser_SetEmptyText(This,pszEmptyText)	\
    ( (This)->lpVtbl -> SetEmptyText(This,pszEmptyText) ) 

#define IExplorerBrowser_SetFolderSettings(This,pfs)	\
    ( (This)->lpVtbl -> SetFolderSettings(This,pfs) ) 

#define IExplorerBrowser_Advise(This,psbe,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,psbe,pdwCookie) ) 

#define IExplorerBrowser_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IExplorerBrowser_SetOptions(This,dwFlag)	\
    ( (This)->lpVtbl -> SetOptions(This,dwFlag) ) 

#define IExplorerBrowser_GetOptions(This,pdwFlag)	\
    ( (This)->lpVtbl -> GetOptions(This,pdwFlag) ) 

#define IExplorerBrowser_BrowseToIDList(This,pidl,uFlags)	\
    ( (This)->lpVtbl -> BrowseToIDList(This,pidl,uFlags) ) 

#define IExplorerBrowser_BrowseToObject(This,punk,uFlags)	\
    ( (This)->lpVtbl -> BrowseToObject(This,punk,uFlags) ) 

#define IExplorerBrowser_FillFromObject(This,punk,dwFlags)	\
    ( (This)->lpVtbl -> FillFromObject(This,punk,dwFlags) ) 

#define IExplorerBrowser_RemoveAll(This)	\
    ( (This)->lpVtbl -> RemoveAll(This) ) 

#define IExplorerBrowser_GetCurrentView(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetCurrentView(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerBrowser_INTERFACE_DEFINED__ */


#ifndef __IAccessibleObject_INTERFACE_DEFINED__
#define __IAccessibleObject_INTERFACE_DEFINED__

/* interface IAccessibleObject */
/* [object][uuid] */ 


EXTERN_C const IID IID_IAccessibleObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95A391C5-9ED4-4c28-8401-AB9E06719E11")
    IAccessibleObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAccessibleName( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAccessibleObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAccessibleObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAccessibleObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibleName )( 
            __RPC__in IAccessibleObject * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName);
        
        END_INTERFACE
    } IAccessibleObjectVtbl;

    interface IAccessibleObject
    {
        CONST_VTBL struct IAccessibleObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAccessibleObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAccessibleObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAccessibleObject_SetAccessibleName(This,pszName)	\
    ( (This)->lpVtbl -> SetAccessibleName(This,pszName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAccessibleObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0105 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0105_v0_0_s_ifspec;

#ifndef __IResultsFolder_INTERFACE_DEFINED__
#define __IResultsFolder_INTERFACE_DEFINED__

/* interface IResultsFolder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResultsFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96E5AE6D-6AE1-4b1c-900C-C6480EAA8828")
    IResultsFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddIDList( 
            /* [annotation][in] */ 
            __in  PCIDLIST_ABSOLUTE pidl,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlAdded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultsFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IResultsFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IResultsFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IResultsFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            __RPC__in IResultsFolder * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddIDList )( 
            IResultsFolder * This,
            /* [annotation][in] */ 
            __in  PCIDLIST_ABSOLUTE pidl,
            /* [annotation][out] */ 
            __deref_opt_out  PITEMID_CHILD *ppidlAdded);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            __RPC__in IResultsFolder * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveIDList )( 
            __RPC__in IResultsFolder * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            __RPC__in IResultsFolder * This);
        
        END_INTERFACE
    } IResultsFolderVtbl;

    interface IResultsFolder
    {
        CONST_VTBL struct IResultsFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultsFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResultsFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResultsFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResultsFolder_AddItem(This,psi)	\
    ( (This)->lpVtbl -> AddItem(This,psi) ) 

#define IResultsFolder_AddIDList(This,pidl,ppidlAdded)	\
    ( (This)->lpVtbl -> AddIDList(This,pidl,ppidlAdded) ) 

#define IResultsFolder_RemoveItem(This,psi)	\
    ( (This)->lpVtbl -> RemoveItem(This,psi) ) 

#define IResultsFolder_RemoveIDList(This,pidl)	\
    ( (This)->lpVtbl -> RemoveIDList(This,pidl) ) 

#define IResultsFolder_RemoveAll(This)	\
    ( (This)->lpVtbl -> RemoveAll(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IResultsFolder_RemoteAddIDList_Proxy( 
    __RPC__in IResultsFolder * This,
    /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
    /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlAdded);


void __RPC_STUB IResultsFolder_RemoteAddIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultsFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0106 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0106_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0106_v0_0_s_ifspec;

#ifndef __IEnumObjects_INTERFACE_DEFINED__
#define __IEnumObjects_INTERFACE_DEFINED__

/* interface IEnumObjects */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumObjects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e")
    IEnumObjects : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  void **rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumObjects **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumObjectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumObjects * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumObjects * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumObjects * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumObjects * This,
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  void **rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumObjects * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumObjects * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumObjects * This,
            /* [out] */ __RPC__deref_out_opt IEnumObjects **ppenum);
        
        END_INTERFACE
    } IEnumObjectsVtbl;

    interface IEnumObjects
    {
        CONST_VTBL struct IEnumObjectsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumObjects_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumObjects_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumObjects_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumObjects_Next(This,celt,riid,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,riid,rgelt,pceltFetched) ) 

#define IEnumObjects_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumObjects_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumObjects_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumObjects_RemoteNext_Proxy( 
    __RPC__in IEnumObjects * This,
    /* [in] */ ULONG celt,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) void **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumObjects_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumObjects_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0107 */
/* [local] */ 

/* [v1_enum] */ 
enum _OPPROGDLGF
    {	OPPROGDLG_DEFAULT	= 0,
	OPPROGDLG_ENABLEPAUSE	= 0x80,
	OPPROGDLG_ALLOWUNDO	= 0x100,
	OPPROGDLG_DONTDISPLAYSOURCEPATH	= 0x200,
	OPPROGDLG_DONTDISPLAYDESTPATH	= 0x400,
	OPPROGDLG_NOMULTIDAYESTIMATES	= 0x800,
	OPPROGDLG_DONTDISPLAYLOCATIONS	= 0x1000
    } ;
typedef DWORD OPPROGDLGF;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0107_v0_0_s_ifspec;

#ifndef __IOperationsProgressDialog_INTERFACE_DEFINED__
#define __IOperationsProgressDialog_INTERFACE_DEFINED__

/* interface IOperationsProgressDialog */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum _PDMODE
    {	PDM_DEFAULT	= 0,
	PDM_RUN	= 0x1,
	PDM_PREFLIGHT	= 0x2,
	PDM_UNDOING	= 0x4,
	PDM_ERRORSBLOCKING	= 0x8,
	PDM_INDETERMINATE	= 0x10
    } ;
typedef DWORD PDMODE;

typedef /* [v1_enum] */ 
enum PDOPSTATUS
    {	PDOPS_RUNNING	= 1,
	PDOPS_PAUSED	= 2,
	PDOPS_CANCELLED	= 3,
	PDOPS_STOPPED	= 4,
	PDOPS_ERRORS	= 5
    } 	PDOPSTATUS;


EXTERN_C const IID IID_IOperationsProgressDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C9FB851-E5C9-43EB-A370-F0677B13874C")
    IOperationsProgressDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartProgressDialog( 
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ OPPROGDLGF flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopProgressDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOperation( 
            /* [in] */ SPACTION action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ PDMODE mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ ULONGLONG ullPointsCurrent,
            /* [in] */ ULONGLONG ullPointsTotal,
            /* [in] */ ULONGLONG ullSizeCurrent,
            /* [in] */ ULONGLONG ullSizeTotal,
            /* [in] */ ULONGLONG ullItemsCurrent,
            /* [in] */ ULONGLONG ullItemsTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateLocations( 
            /* [unique][in] */ __RPC__in_opt IShellItem *psiSource,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiTarget,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeTimer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMilliseconds( 
            /* [out] */ __RPC__out ULONGLONG *pullElapsed,
            /* [out] */ __RPC__out ULONGLONG *pullRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOperationStatus( 
            /* [out] */ __RPC__out PDOPSTATUS *popstatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOperationsProgressDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOperationsProgressDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartProgressDialog )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ OPPROGDLGF flags);
        
        HRESULT ( STDMETHODCALLTYPE *StopProgressDialog )( 
            __RPC__in IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOperation )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [in] */ SPACTION action);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [in] */ PDMODE mode);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [in] */ ULONGLONG ullPointsCurrent,
            /* [in] */ ULONGLONG ullPointsTotal,
            /* [in] */ ULONGLONG ullSizeCurrent,
            /* [in] */ ULONGLONG ullSizeTotal,
            /* [in] */ ULONGLONG ullItemsCurrent,
            /* [in] */ ULONGLONG ullItemsTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateLocations )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiSource,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiTarget,
            /* [unique][in] */ __RPC__in_opt IShellItem *psiItem);
        
        HRESULT ( STDMETHODCALLTYPE *ResetTimer )( 
            __RPC__in IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseTimer )( 
            __RPC__in IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeTimer )( 
            __RPC__in IOperationsProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMilliseconds )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [out] */ __RPC__out ULONGLONG *pullElapsed,
            /* [out] */ __RPC__out ULONGLONG *pullRemaining);
        
        HRESULT ( STDMETHODCALLTYPE *GetOperationStatus )( 
            __RPC__in IOperationsProgressDialog * This,
            /* [out] */ __RPC__out PDOPSTATUS *popstatus);
        
        END_INTERFACE
    } IOperationsProgressDialogVtbl;

    interface IOperationsProgressDialog
    {
        CONST_VTBL struct IOperationsProgressDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOperationsProgressDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOperationsProgressDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOperationsProgressDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOperationsProgressDialog_StartProgressDialog(This,hwndOwner,flags)	\
    ( (This)->lpVtbl -> StartProgressDialog(This,hwndOwner,flags) ) 

#define IOperationsProgressDialog_StopProgressDialog(This)	\
    ( (This)->lpVtbl -> StopProgressDialog(This) ) 

#define IOperationsProgressDialog_SetOperation(This,action)	\
    ( (This)->lpVtbl -> SetOperation(This,action) ) 

#define IOperationsProgressDialog_SetMode(This,mode)	\
    ( (This)->lpVtbl -> SetMode(This,mode) ) 

#define IOperationsProgressDialog_UpdateProgress(This,ullPointsCurrent,ullPointsTotal,ullSizeCurrent,ullSizeTotal,ullItemsCurrent,ullItemsTotal)	\
    ( (This)->lpVtbl -> UpdateProgress(This,ullPointsCurrent,ullPointsTotal,ullSizeCurrent,ullSizeTotal,ullItemsCurrent,ullItemsTotal) ) 

#define IOperationsProgressDialog_UpdateLocations(This,psiSource,psiTarget,psiItem)	\
    ( (This)->lpVtbl -> UpdateLocations(This,psiSource,psiTarget,psiItem) ) 

#define IOperationsProgressDialog_ResetTimer(This)	\
    ( (This)->lpVtbl -> ResetTimer(This) ) 

#define IOperationsProgressDialog_PauseTimer(This)	\
    ( (This)->lpVtbl -> PauseTimer(This) ) 

#define IOperationsProgressDialog_ResumeTimer(This)	\
    ( (This)->lpVtbl -> ResumeTimer(This) ) 

#define IOperationsProgressDialog_GetMilliseconds(This,pullElapsed,pullRemaining)	\
    ( (This)->lpVtbl -> GetMilliseconds(This,pullElapsed,pullRemaining) ) 

#define IOperationsProgressDialog_GetOperationStatus(This,popstatus)	\
    ( (This)->lpVtbl -> GetOperationStatus(This,popstatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOperationsProgressDialog_INTERFACE_DEFINED__ */


#ifndef __IIOCancelInformation_INTERFACE_DEFINED__
#define __IIOCancelInformation_INTERFACE_DEFINED__

/* interface IIOCancelInformation */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IIOCancelInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f5b0bf81-8cb5-4b1b-9449-1a159e0c733c")
    IIOCancelInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCancelInformation( 
            /* [in] */ DWORD dwThreadID,
            /* [in] */ UINT uMsgCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCancelInformation( 
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwThreadID,
            /* [annotation][out] */ 
            __out_opt  UINT *puMsgCancel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIOCancelInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIOCancelInformation * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIOCancelInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIOCancelInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCancelInformation )( 
            IIOCancelInformation * This,
            /* [in] */ DWORD dwThreadID,
            /* [in] */ UINT uMsgCancel);
        
        HRESULT ( STDMETHODCALLTYPE *GetCancelInformation )( 
            IIOCancelInformation * This,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwThreadID,
            /* [annotation][out] */ 
            __out_opt  UINT *puMsgCancel);
        
        END_INTERFACE
    } IIOCancelInformationVtbl;

    interface IIOCancelInformation
    {
        CONST_VTBL struct IIOCancelInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIOCancelInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIOCancelInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIOCancelInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIOCancelInformation_SetCancelInformation(This,dwThreadID,uMsgCancel)	\
    ( (This)->lpVtbl -> SetCancelInformation(This,dwThreadID,uMsgCancel) ) 

#define IIOCancelInformation_GetCancelInformation(This,pdwThreadID,puMsgCancel)	\
    ( (This)->lpVtbl -> GetCancelInformation(This,pdwThreadID,puMsgCancel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIOCancelInformation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0109 */
/* [local] */ 

#define FOFX_NOSKIPJUNCTIONS         0x00010000  // Don't avoid binding to junctions (like Task folder, Recycle-Bin)
#define FOFX_PREFERHARDLINK          0x00020000  // Create hard link if possible
#define FOFX_SHOWELEVATIONPROMPT     0x00040000  // Show elevation prompts when error UI is disabled (use with FOF_NOERRORUI)
#define FOFX_EARLYFAILURE            0x00100000  // Fail operation as soon as a single error occurs rather than trying to process other items (applies only when using FOF_NOERRORUI)
#define FOFX_PRESERVEFILEEXTENSIONS  0x00200000  // Rename collisions preserve file extns (use with FOF_RENAMEONCOLLISION)
#define FOFX_KEEPNEWERFILE           0x00400000  // Keep newer file on naming conflicts
#define FOFX_NOCOPYHOOKS             0x00800000  // Don't use copy hooks
#define FOFX_NOMINIMIZEBOX           0x01000000  // Don't allow minimizing the progress dialog
#define FOFX_MOVEACLSACROSSVOLUMES   0x02000000  // Copy security information when performing a cross-volume move operation
#define FOFX_DONTDISPLAYSOURCEPATH   0x04000000  // Don't display the path of source file in progress dialog
#define FOFX_DONTDISPLAYDESTPATH     0x08000000  // Don't display the path of destination file in progress dialog
#define FOFX_REQUIREELEVATION        0x10000000  // User expects the elevation; don't show a dialog to confirm
#define FOFX_COPYASDOWNLOAD          0x40000000  // Show Downloading instead of Copying
#define FOFX_DONTDISPLAYLOCATIONS    0x80000000  // Hides the locations line in the progress dialog


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0109_v0_0_s_ifspec;

#ifndef __IFileOperation_INTERFACE_DEFINED__
#define __IFileOperation_INTERFACE_DEFINED__

/* interface IFileOperation */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("947aab5f-0a5c-4c13-b4d6-4bf7836fc9f8")
    IFileOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IFileOperationProgressSink *pfops,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOperationFlags( 
            /* [in] */ DWORD dwOperationFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgressMessage( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgressDialog( 
            /* [in] */ __RPC__in_opt IOperationsProgressDialog *popd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ __RPC__in_opt IPropertyChangeArray *pproparray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOwnerWindow( 
            /* [in] */ __RPC__in HWND hwndOwner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPropertiesToItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPropertiesToItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in_string LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameItems( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkItems,
            /* [string][in] */ __RPC__in_string LPCWSTR pszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszCopyName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItems( 
            /* [in] */ __RPC__in_opt IUnknown *punkItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [in] */ DWORD dwFileAttributes,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTemplateName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PerformOperations( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAnyOperationsAborted( 
            /* [out] */ __RPC__out BOOL *pfAnyOperationsAborted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IFileOperationProgressSink *pfops,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IFileOperation * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOperationFlags )( 
            __RPC__in IFileOperation * This,
            /* [in] */ DWORD dwOperationFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressMessage )( 
            __RPC__in IFileOperation * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszMessage);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressDialog )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IOperationsProgressDialog *popd);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IPropertyChangeArray *pproparray);
        
        HRESULT ( STDMETHODCALLTYPE *SetOwnerWindow )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPropertiesToItem )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPropertiesToItems )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems);
        
        HRESULT ( STDMETHODCALLTYPE *RenameItem )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [string][in] */ __RPC__in_string LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *RenameItems )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkItems,
            /* [string][in] */ __RPC__in_string LPCWSTR pszNewName);
        
        HRESULT ( STDMETHODCALLTYPE *MoveItem )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszNewName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *MoveItems )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder);
        
        HRESULT ( STDMETHODCALLTYPE *CopyItem )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszCopyName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *CopyItems )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiItem,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItems )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IUnknown *punkItems);
        
        HRESULT ( STDMETHODCALLTYPE *NewItem )( 
            __RPC__in IFileOperation * This,
            /* [in] */ __RPC__in_opt IShellItem *psiDestinationFolder,
            /* [in] */ DWORD dwFileAttributes,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTemplateName,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pfopsItem);
        
        HRESULT ( STDMETHODCALLTYPE *PerformOperations )( 
            __RPC__in IFileOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAnyOperationsAborted )( 
            __RPC__in IFileOperation * This,
            /* [out] */ __RPC__out BOOL *pfAnyOperationsAborted);
        
        END_INTERFACE
    } IFileOperationVtbl;

    interface IFileOperation
    {
        CONST_VTBL struct IFileOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileOperation_Advise(This,pfops,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfops,pdwCookie) ) 

#define IFileOperation_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileOperation_SetOperationFlags(This,dwOperationFlags)	\
    ( (This)->lpVtbl -> SetOperationFlags(This,dwOperationFlags) ) 

#define IFileOperation_SetProgressMessage(This,pszMessage)	\
    ( (This)->lpVtbl -> SetProgressMessage(This,pszMessage) ) 

#define IFileOperation_SetProgressDialog(This,popd)	\
    ( (This)->lpVtbl -> SetProgressDialog(This,popd) ) 

#define IFileOperation_SetProperties(This,pproparray)	\
    ( (This)->lpVtbl -> SetProperties(This,pproparray) ) 

#define IFileOperation_SetOwnerWindow(This,hwndOwner)	\
    ( (This)->lpVtbl -> SetOwnerWindow(This,hwndOwner) ) 

#define IFileOperation_ApplyPropertiesToItem(This,psiItem)	\
    ( (This)->lpVtbl -> ApplyPropertiesToItem(This,psiItem) ) 

#define IFileOperation_ApplyPropertiesToItems(This,punkItems)	\
    ( (This)->lpVtbl -> ApplyPropertiesToItems(This,punkItems) ) 

#define IFileOperation_RenameItem(This,psiItem,pszNewName,pfopsItem)	\
    ( (This)->lpVtbl -> RenameItem(This,psiItem,pszNewName,pfopsItem) ) 

#define IFileOperation_RenameItems(This,pUnkItems,pszNewName)	\
    ( (This)->lpVtbl -> RenameItems(This,pUnkItems,pszNewName) ) 

#define IFileOperation_MoveItem(This,psiItem,psiDestinationFolder,pszNewName,pfopsItem)	\
    ( (This)->lpVtbl -> MoveItem(This,psiItem,psiDestinationFolder,pszNewName,pfopsItem) ) 

#define IFileOperation_MoveItems(This,punkItems,psiDestinationFolder)	\
    ( (This)->lpVtbl -> MoveItems(This,punkItems,psiDestinationFolder) ) 

#define IFileOperation_CopyItem(This,psiItem,psiDestinationFolder,pszCopyName,pfopsItem)	\
    ( (This)->lpVtbl -> CopyItem(This,psiItem,psiDestinationFolder,pszCopyName,pfopsItem) ) 

#define IFileOperation_CopyItems(This,punkItems,psiDestinationFolder)	\
    ( (This)->lpVtbl -> CopyItems(This,punkItems,psiDestinationFolder) ) 

#define IFileOperation_DeleteItem(This,psiItem,pfopsItem)	\
    ( (This)->lpVtbl -> DeleteItem(This,psiItem,pfopsItem) ) 

#define IFileOperation_DeleteItems(This,punkItems)	\
    ( (This)->lpVtbl -> DeleteItems(This,punkItems) ) 

#define IFileOperation_NewItem(This,psiDestinationFolder,dwFileAttributes,pszName,pszTemplateName,pfopsItem)	\
    ( (This)->lpVtbl -> NewItem(This,psiDestinationFolder,dwFileAttributes,pszName,pszTemplateName,pfopsItem) ) 

#define IFileOperation_PerformOperations(This)	\
    ( (This)->lpVtbl -> PerformOperations(This) ) 

#define IFileOperation_GetAnyOperationsAborted(This,pfAnyOperationsAborted)	\
    ( (This)->lpVtbl -> GetAnyOperationsAborted(This,pfAnyOperationsAborted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileOperation_INTERFACE_DEFINED__ */


#ifndef __IObjectProvider_INTERFACE_DEFINED__
#define __IObjectProvider_INTERFACE_DEFINED__

/* interface IObjectProvider */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IObjectProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6087428-3be3-4d73-b308-7c04a540bf1a")
    IObjectProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryObject( 
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObject )( 
            __RPC__in IObjectProvider * This,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        END_INTERFACE
    } IObjectProviderVtbl;

    interface IObjectProvider
    {
        CONST_VTBL struct IObjectProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectProvider_QueryObject(This,guidObject,riid,ppvOut)	\
    ( (This)->lpVtbl -> QueryObject(This,guidObject,riid,ppvOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0111 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0111_v0_0_s_ifspec;

#ifndef __INamespaceWalkCB_INTERFACE_DEFINED__
#define __INamespaceWalkCB_INTERFACE_DEFINED__

/* interface INamespaceWalkCB */
/* [object][uuid] */ 


EXTERN_C const IID IID_INamespaceWalkCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d92995f8-cf5e-4a76-bf59-ead39ea2b97e")
    INamespaceWalkCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FoundItem( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterFolder( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFolder( 
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeProgressDialog( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTitle,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszCancel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceWalkCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INamespaceWalkCB * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INamespaceWalkCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INamespaceWalkCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *FoundItem )( 
            __RPC__in INamespaceWalkCB * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            __RPC__in INamespaceWalkCB * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            __RPC__in INamespaceWalkCB * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeProgressDialog )( 
            __RPC__in INamespaceWalkCB * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTitle,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszCancel);
        
        END_INTERFACE
    } INamespaceWalkCBVtbl;

    interface INamespaceWalkCB
    {
        CONST_VTBL struct INamespaceWalkCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceWalkCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamespaceWalkCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamespaceWalkCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamespaceWalkCB_FoundItem(This,psf,pidl)	\
    ( (This)->lpVtbl -> FoundItem(This,psf,pidl) ) 

#define INamespaceWalkCB_EnterFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> EnterFolder(This,psf,pidl) ) 

#define INamespaceWalkCB_LeaveFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> LeaveFolder(This,psf,pidl) ) 

#define INamespaceWalkCB_InitializeProgressDialog(This,ppszTitle,ppszCancel)	\
    ( (This)->lpVtbl -> InitializeProgressDialog(This,ppszTitle,ppszCancel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamespaceWalkCB_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0112 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0112_v0_0_s_ifspec;

#ifndef __INamespaceWalkCB2_INTERFACE_DEFINED__
#define __INamespaceWalkCB2_INTERFACE_DEFINED__

/* interface INamespaceWalkCB2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_INamespaceWalkCB2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7ac7492b-c38e-438a-87db-68737844ff70")
    INamespaceWalkCB2 : public INamespaceWalkCB
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WalkComplete( 
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceWalkCB2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INamespaceWalkCB2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INamespaceWalkCB2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FoundItem )( 
            __RPC__in INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            __RPC__in INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            __RPC__in INamespaceWalkCB2 * This,
            /* [in] */ __RPC__in_opt IShellFolder *psf,
            /* [in] */ __RPC__in PCUITEMID_CHILD pidl);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeProgressDialog )( 
            __RPC__in INamespaceWalkCB2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTitle,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszCancel);
        
        HRESULT ( STDMETHODCALLTYPE *WalkComplete )( 
            __RPC__in INamespaceWalkCB2 * This,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } INamespaceWalkCB2Vtbl;

    interface INamespaceWalkCB2
    {
        CONST_VTBL struct INamespaceWalkCB2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceWalkCB2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamespaceWalkCB2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamespaceWalkCB2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamespaceWalkCB2_FoundItem(This,psf,pidl)	\
    ( (This)->lpVtbl -> FoundItem(This,psf,pidl) ) 

#define INamespaceWalkCB2_EnterFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> EnterFolder(This,psf,pidl) ) 

#define INamespaceWalkCB2_LeaveFolder(This,psf,pidl)	\
    ( (This)->lpVtbl -> LeaveFolder(This,psf,pidl) ) 

#define INamespaceWalkCB2_InitializeProgressDialog(This,ppszTitle,ppszCancel)	\
    ( (This)->lpVtbl -> InitializeProgressDialog(This,ppszTitle,ppszCancel) ) 


#define INamespaceWalkCB2_WalkComplete(This,hr)	\
    ( (This)->lpVtbl -> WalkComplete(This,hr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamespaceWalkCB2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0113 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0113_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0113_v0_0_s_ifspec;

#ifndef __INamespaceWalk_INTERFACE_DEFINED__
#define __INamespaceWalk_INTERFACE_DEFINED__

/* interface INamespaceWalk */
/* [object][uuid] */ 

typedef /* [public][v1_enum] */ 
enum __MIDL_INamespaceWalk_0001
    {	NSWF_DEFAULT	= 0,
	NSWF_NONE_IMPLIES_ALL	= 0x1,
	NSWF_ONE_IMPLIES_ALL	= 0x2,
	NSWF_DONT_TRAVERSE_LINKS	= 0x4,
	NSWF_DONT_ACCUMULATE_RESULT	= 0x8,
	NSWF_TRAVERSE_STREAM_JUNCTIONS	= 0x10,
	NSWF_FILESYSTEM_ONLY	= 0x20,
	NSWF_SHOW_PROGRESS	= 0x40,
	NSWF_FLAG_VIEWORDER	= 0x80,
	NSWF_IGNORE_AUTOPLAY_HIDA	= 0x100,
	NSWF_ASYNC	= 0x200,
	NSWF_DONT_RESOLVE_LINKS	= 0x400,
	NSWF_ACCUMULATE_FOLDERS	= 0x800,
	NSWF_DONT_SORT	= 0x1000,
	NSWF_USE_TRANSFER_MEDIUM	= 0x2000,
	NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS	= 0x4000
    } 	NAMESPACEWALKFLAG;

DEFINE_ENUM_FLAG_OPERATORS(NAMESPACEWALKFLAG)

EXTERN_C const IID IID_INamespaceWalk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57ced8a7-3f4a-432c-9350-30f24483f74f")
    INamespaceWalk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Walk( 
            /* [in] */ __RPC__in_opt IUnknown *punkToWalk,
            /* [in] */ DWORD dwFlags,
            /* [in] */ int cDepth,
            /* [unique][in] */ __RPC__in_opt INamespaceWalkCB *pnswcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDArrayResult( 
            /* [out] */ __RPC__out UINT *pcItems,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItems) PIDLIST_ABSOLUTE **prgpidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceWalkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INamespaceWalk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INamespaceWalk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INamespaceWalk * This);
        
        HRESULT ( STDMETHODCALLTYPE *Walk )( 
            __RPC__in INamespaceWalk * This,
            /* [in] */ __RPC__in_opt IUnknown *punkToWalk,
            /* [in] */ DWORD dwFlags,
            /* [in] */ int cDepth,
            /* [unique][in] */ __RPC__in_opt INamespaceWalkCB *pnswcb);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDArrayResult )( 
            __RPC__in INamespaceWalk * This,
            /* [out] */ __RPC__out UINT *pcItems,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItems) PIDLIST_ABSOLUTE **prgpidl);
        
        END_INTERFACE
    } INamespaceWalkVtbl;

    interface INamespaceWalk
    {
        CONST_VTBL struct INamespaceWalkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceWalk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamespaceWalk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamespaceWalk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamespaceWalk_Walk(This,punkToWalk,dwFlags,cDepth,pnswcb)	\
    ( (This)->lpVtbl -> Walk(This,punkToWalk,dwFlags,cDepth,pnswcb) ) 

#define INamespaceWalk_GetIDArrayResult(This,pcItems,prgpidl)	\
    ( (This)->lpVtbl -> GetIDArrayResult(This,pcItems,prgpidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamespaceWalk_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0114 */
/* [local] */ 

#endif  // NTDDI_WINXP || (_WIN32_IE >= _WIN32_IE_IE70)
__inline void FreeIDListArray(__in_ecount(cItems) PIDLIST_RELATIVE *ppidls, UINT cItems)
{                                        
     UINT i;                             
     for (i = 0; i < cItems; i++)        
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        
#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
__inline void FreeIDListArrayFull(__in_ecount(cItems) PIDLIST_ABSOLUTE *ppidls, UINT cItems)
{                                        
     for (UINT i = 0; i < cItems; i++)   
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        
__inline void FreeIDListArrayChild(__in_ecount(cItems) PITEMID_CHILD *ppidls, UINT cItems)
{                                        
     for (UINT i = 0; i < cItems; i++)   
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        
#else //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#define FreeIDListArrayFull FreeIDListArray
#define FreeIDListArrayChild FreeIDListArray
#endif //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#define ACDD_VISIBLE        0x0001


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0114_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0114_v0_0_s_ifspec;

#ifndef __IAutoCompleteDropDown_INTERFACE_DEFINED__
#define __IAutoCompleteDropDown_INTERFACE_DEFINED__

/* interface IAutoCompleteDropDown */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IAutoCompleteDropDown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CD141F4-3C6A-11d2-BCAA-00C04FD929DB")
    IAutoCompleteDropDown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDropDownStatus( 
            /* [out] */ __RPC__out DWORD *pdwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetEnumerator( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoCompleteDropDownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAutoCompleteDropDown * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAutoCompleteDropDown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAutoCompleteDropDown * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDropDownStatus )( 
            __RPC__in IAutoCompleteDropDown * This,
            /* [out] */ __RPC__out DWORD *pdwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszString);
        
        HRESULT ( STDMETHODCALLTYPE *ResetEnumerator )( 
            __RPC__in IAutoCompleteDropDown * This);
        
        END_INTERFACE
    } IAutoCompleteDropDownVtbl;

    interface IAutoCompleteDropDown
    {
        CONST_VTBL struct IAutoCompleteDropDownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoCompleteDropDown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAutoCompleteDropDown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAutoCompleteDropDown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAutoCompleteDropDown_GetDropDownStatus(This,pdwFlags,ppwszString)	\
    ( (This)->lpVtbl -> GetDropDownStatus(This,pdwFlags,ppwszString) ) 

#define IAutoCompleteDropDown_ResetEnumerator(This)	\
    ( (This)->lpVtbl -> ResetEnumerator(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAutoCompleteDropDown_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0115 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE40)
#include <pshpack8.h>
typedef struct tagBANDSITEINFO
    {
    DWORD dwMask;
    DWORD dwState;
    DWORD dwStyle;
    } 	BANDSITEINFO;

#include <poppack.h>

enum tagBANDSITECID
    {	BSID_BANDADDED	= 0,
	BSID_BANDREMOVED	= ( BSID_BANDADDED + 1 ) 
    } ;
#define BSIM_STATE          0x00000001
#define BSIM_STYLE          0x00000002
#define BSSF_VISIBLE        0x00000001
#define BSSF_NOTITLE        0x00000002
#define BSSF_UNDELETEABLE   0x00001000
#define BSIS_AUTOGRIPPER               0x00000000
#define BSIS_NOGRIPPER                 0x00000001
#define BSIS_ALWAYSGRIPPER             0x00000002
#define BSIS_LEFTALIGN                 0x00000004
#define BSIS_SINGLECLICK               0x00000008
#define BSIS_NOCONTEXTMENU             0x00000010
#define BSIS_NODROPTARGET              0x00000020
#define BSIS_NOCAPTION                 0x00000040
#define BSIS_PREFERNOLINEBREAK         0x00000080
#define BSIS_LOCKED                    0x00000100
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define BSIS_PRESERVEORDERDURINGLAYOUT 0x00000200
#define BSIS_FIXEDORDER                0x00000400
#endif  // _WIN32_IE_IE70
#define SID_SBandSite IID_IBandSite
#define CGID_BandSite IID_IBandSite


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0115_v0_0_s_ifspec;

#ifndef __IBandSite_INTERFACE_DEFINED__
#define __IBandSite_INTERFACE_DEFINED__

/* interface IBandSite */
/* [uuid][object] */ 


EXTERN_C const IID IID_IBandSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CF504B0-DE96-11D0-8B3F-00A0C911E8E5")
    IBandSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddBand( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBands( 
            /* [in] */ UINT uBand,
            /* [out] */ __RPC__out DWORD *pdwBandID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryBand( 
            /* [annotation][in] */ 
            __in  DWORD dwBandID,
            /* [annotation][out] */ 
            __deref_opt_out  IDeskBand **ppstb,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwState,
            /* [annotation][size_is][string][out] */ 
            __out_ecount_opt(cchName)  LPWSTR pszName,
            /* [annotation][in] */ 
            __in  int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandState( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveBand( 
            /* [in] */ DWORD dwBandID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandObject( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandSiteInfo( 
            /* [in] */ __RPC__in const BANDSITEINFO *pbsinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandSiteInfo( 
            /* [out][in] */ __RPC__inout BANDSITEINFO *pbsinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBandSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBandSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBandSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBandSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddBand )( 
            __RPC__in IBandSite * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBands )( 
            __RPC__in IBandSite * This,
            /* [in] */ UINT uBand,
            /* [out] */ __RPC__out DWORD *pdwBandID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryBand )( 
            IBandSite * This,
            /* [annotation][in] */ 
            __in  DWORD dwBandID,
            /* [annotation][out] */ 
            __deref_opt_out  IDeskBand **ppstb,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwState,
            /* [annotation][size_is][string][out] */ 
            __out_ecount_opt(cchName)  LPWSTR pszName,
            /* [annotation][in] */ 
            __in  int cchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandState )( 
            __RPC__in IBandSite * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwState);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveBand )( 
            __RPC__in IBandSite * This,
            /* [in] */ DWORD dwBandID);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandObject )( 
            __RPC__in IBandSite * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandSiteInfo )( 
            __RPC__in IBandSite * This,
            /* [in] */ __RPC__in const BANDSITEINFO *pbsinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandSiteInfo )( 
            __RPC__in IBandSite * This,
            /* [out][in] */ __RPC__inout BANDSITEINFO *pbsinfo);
        
        END_INTERFACE
    } IBandSiteVtbl;

    interface IBandSite
    {
        CONST_VTBL struct IBandSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBandSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBandSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBandSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBandSite_AddBand(This,punk)	\
    ( (This)->lpVtbl -> AddBand(This,punk) ) 

#define IBandSite_EnumBands(This,uBand,pdwBandID)	\
    ( (This)->lpVtbl -> EnumBands(This,uBand,pdwBandID) ) 

#define IBandSite_QueryBand(This,dwBandID,ppstb,pdwState,pszName,cchName)	\
    ( (This)->lpVtbl -> QueryBand(This,dwBandID,ppstb,pdwState,pszName,cchName) ) 

#define IBandSite_SetBandState(This,dwBandID,dwMask,dwState)	\
    ( (This)->lpVtbl -> SetBandState(This,dwBandID,dwMask,dwState) ) 

#define IBandSite_RemoveBand(This,dwBandID)	\
    ( (This)->lpVtbl -> RemoveBand(This,dwBandID) ) 

#define IBandSite_GetBandObject(This,dwBandID,riid,ppv)	\
    ( (This)->lpVtbl -> GetBandObject(This,dwBandID,riid,ppv) ) 

#define IBandSite_SetBandSiteInfo(This,pbsinfo)	\
    ( (This)->lpVtbl -> SetBandSiteInfo(This,pbsinfo) ) 

#define IBandSite_GetBandSiteInfo(This,pbsinfo)	\
    ( (This)->lpVtbl -> GetBandSiteInfo(This,pbsinfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBandSite_RemoteQueryBand_Proxy( 
    __RPC__in IBandSite * This,
    /* [in] */ DWORD dwBandID,
    /* [out] */ __RPC__deref_out_opt IDeskBand **ppstb,
    /* [out] */ __RPC__out DWORD *pdwState,
    /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchName) LPWSTR pszName,
    /* [in] */ int cchName);


void __RPC_STUB IBandSite_RemoteQueryBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBandSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0116 */
/* [local] */ 

#endif // _WIN32_IE_IE40
#if (NTDDI_VERSION >= NTDDI_WINXP)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0116_v0_0_s_ifspec;

#ifndef __IModalWindow_INTERFACE_DEFINED__
#define __IModalWindow_INTERFACE_DEFINED__

/* interface IModalWindow */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IModalWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b4db1657-70d7-485e-8e3e-6fcb5a5c1802")
    IModalWindow : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IModalWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IModalWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IModalWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IModalWindow * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IModalWindow * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner);
        
        END_INTERFACE
    } IModalWindowVtbl;

    interface IModalWindow
    {
        CONST_VTBL struct IModalWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IModalWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IModalWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IModalWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IModalWindow_Show(This,hwndOwner)	\
    ( (This)->lpVtbl -> Show(This,hwndOwner) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IModalWindow_RemoteShow_Proxy( 
    __RPC__in IModalWindow * This,
    /* [unique][in] */ __RPC__in_opt HWND hwndOwner);


void __RPC_STUB IModalWindow_RemoteShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IModalWindow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0117 */
/* [local] */ 

#define PROPSTR_EXTENSIONCOMPLETIONSTATE L"ExtensionCompletionState"

enum tagCDBURNINGEXTENSIONRET
    {	CDBE_RET_DEFAULT	= 0,
	CDBE_RET_DONTRUNOTHEREXTS	= 0x1,
	CDBE_RET_STOPWIZARD	= 0x2
    } ;
#define SID_CDWizardHost IID_ICDBurnExt
/* [v1_enum] */ 
enum _CDBE_ACTIONS
    {	CDBE_TYPE_MUSIC	= 0x1,
	CDBE_TYPE_DATA	= 0x2,
	CDBE_TYPE_ALL	= ( int  )0xffffffff
    } ;
typedef DWORD CDBE_ACTIONS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0117_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0117_v0_0_s_ifspec;

#ifndef __ICDBurnExt_INTERFACE_DEFINED__
#define __ICDBurnExt_INTERFACE_DEFINED__

/* interface ICDBurnExt */
/* [object][uuid] */ 


EXTERN_C const IID IID_ICDBurnExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2271dcca-74fc-4414-8fb7-c56b05ace2d7")
    ICDBurnExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedActionTypes( 
            /* [out] */ __RPC__out CDBE_ACTIONS *pdwActions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICDBurnExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICDBurnExt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICDBurnExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICDBurnExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedActionTypes )( 
            __RPC__in ICDBurnExt * This,
            /* [out] */ __RPC__out CDBE_ACTIONS *pdwActions);
        
        END_INTERFACE
    } ICDBurnExtVtbl;

    interface ICDBurnExt
    {
        CONST_VTBL struct ICDBurnExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICDBurnExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICDBurnExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICDBurnExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICDBurnExt_GetSupportedActionTypes(This,pdwActions)	\
    ( (This)->lpVtbl -> GetSupportedActionTypes(This,pdwActions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICDBurnExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0118 */
/* [local] */ 

#endif  // NTDDI_WINXP


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0118_v0_0_s_ifspec;

#ifndef __IContextMenuSite_INTERFACE_DEFINED__
#define __IContextMenuSite_INTERFACE_DEFINED__

/* interface IContextMenuSite */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IContextMenuSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0811AEBE-0B87-4C54-9E72-548CF649016B")
    IContextMenuSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoContextMenuPopup( 
            /* [in] */ __RPC__in_opt IUnknown *punkContextMenu,
            /* [in] */ UINT fFlags,
            /* [in] */ POINT pt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IContextMenuSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IContextMenuSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IContextMenuSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoContextMenuPopup )( 
            __RPC__in IContextMenuSite * This,
            /* [in] */ __RPC__in_opt IUnknown *punkContextMenu,
            /* [in] */ UINT fFlags,
            /* [in] */ POINT pt);
        
        END_INTERFACE
    } IContextMenuSiteVtbl;

    interface IContextMenuSite
    {
        CONST_VTBL struct IContextMenuSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenuSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenuSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenuSite_DoContextMenuPopup(This,punkContextMenu,fFlags,pt)	\
    ( (This)->lpVtbl -> DoContextMenuPopup(This,punkContextMenu,fFlags,pt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenuSite_INTERFACE_DEFINED__ */


#ifndef __IEnumReadyCallback_INTERFACE_DEFINED__
#define __IEnumReadyCallback_INTERFACE_DEFINED__

/* interface IEnumReadyCallback */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumReadyCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61E00D45-8FFF-4e60-924E-6537B61612DD")
    IEnumReadyCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumReadyCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumReadyCallback * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumReadyCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumReadyCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumReady )( 
            IEnumReadyCallback * This);
        
        END_INTERFACE
    } IEnumReadyCallbackVtbl;

    interface IEnumReadyCallback
    {
        CONST_VTBL struct IEnumReadyCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumReadyCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumReadyCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumReadyCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumReadyCallback_EnumReady(This)	\
    ( (This)->lpVtbl -> EnumReady(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumReadyCallback_INTERFACE_DEFINED__ */


#ifndef __IEnumerableView_INTERFACE_DEFINED__
#define __IEnumerableView_INTERFACE_DEFINED__

/* interface IEnumerableView */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IEnumerableView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8C8BF236-1AEC-495f-9894-91D57C3C686F")
    IEnumerableView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetEnumReadyCallback( 
            /* [annotation][in] */ 
            __in  IEnumReadyCallback *percb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumIDListFromContents( 
            /* [annotation][in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder,
            /* [annotation][in] */ 
            __in  DWORD dwEnumFlags,
            /* [annotation][out] */ 
            __deref_out  IEnumIDList **ppEnumIDList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumerableViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumerableView * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumerableView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumerableView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnumReadyCallback )( 
            IEnumerableView * This,
            /* [annotation][in] */ 
            __in  IEnumReadyCallback *percb);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEnumIDListFromContents )( 
            IEnumerableView * This,
            /* [annotation][in] */ 
            __in  PCIDLIST_ABSOLUTE pidlFolder,
            /* [annotation][in] */ 
            __in  DWORD dwEnumFlags,
            /* [annotation][out] */ 
            __deref_out  IEnumIDList **ppEnumIDList);
        
        END_INTERFACE
    } IEnumerableViewVtbl;

    interface IEnumerableView
    {
        CONST_VTBL struct IEnumerableViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumerableView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumerableView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumerableView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumerableView_SetEnumReadyCallback(This,percb)	\
    ( (This)->lpVtbl -> SetEnumReadyCallback(This,percb) ) 

#define IEnumerableView_CreateEnumIDListFromContents(This,pidlFolder,dwEnumFlags,ppEnumIDList)	\
    ( (This)->lpVtbl -> CreateEnumIDListFromContents(This,pidlFolder,dwEnumFlags,ppEnumIDList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumerableView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0121 */
/* [local] */ 

#define SID_EnumerableView IID_IEnumerableView
#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0121_v0_0_s_ifspec;

#ifndef __IInsertItem_INTERFACE_DEFINED__
#define __IInsertItem_INTERFACE_DEFINED__

/* interface IInsertItem */
/* [local][object][uuid] */ 


EXTERN_C const IID IID_IInsertItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2B57227-3D23-4b95-93C0-492BD454C356")
    IInsertItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [annotation][in] */ 
            __in  PCUIDLIST_RELATIVE pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInsertItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInsertItem * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInsertItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInsertItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertItem )( 
            IInsertItem * This,
            /* [annotation][in] */ 
            __in  PCUIDLIST_RELATIVE pidl);
        
        END_INTERFACE
    } IInsertItemVtbl;

    interface IInsertItem
    {
        CONST_VTBL struct IInsertItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInsertItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInsertItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInsertItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInsertItem_InsertItem(This,pidl)	\
    ( (This)->lpVtbl -> InsertItem(This,pidl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInsertItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0122 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WINXP)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0122_v0_0_s_ifspec;

#ifndef __IMenuBand_INTERFACE_DEFINED__
#define __IMenuBand_INTERFACE_DEFINED__

/* interface IMenuBand */
/* [local][unique][object][uuid] */ 


enum tagMENUBANDHANDLERCID
    {	MBHANDCID_PIDLSELECT	= 0
    } ;

EXTERN_C const IID IID_IMenuBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("568804CD-CBD7-11d0-9816-00C04FD91972")
    IMenuBand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsMenuMessage( 
            /* [annotation][in] */ 
            __in  MSG *pmsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateMenuMessage( 
            /* [annotation][out][in] */ 
            __inout  MSG *pmsg,
            /* [annotation][out] */ 
            __out  LRESULT *plRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMenuBand * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMenuBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMenuBand * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsMenuMessage )( 
            IMenuBand * This,
            /* [annotation][in] */ 
            __in  MSG *pmsg);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateMenuMessage )( 
            IMenuBand * This,
            /* [annotation][out][in] */ 
            __inout  MSG *pmsg,
            /* [annotation][out] */ 
            __out  LRESULT *plRet);
        
        END_INTERFACE
    } IMenuBandVtbl;

    interface IMenuBand
    {
        CONST_VTBL struct IMenuBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMenuBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMenuBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMenuBand_IsMenuMessage(This,pmsg)	\
    ( (This)->lpVtbl -> IsMenuMessage(This,pmsg) ) 

#define IMenuBand_TranslateMenuMessage(This,pmsg,plRet)	\
    ( (This)->lpVtbl -> TranslateMenuMessage(This,pmsg,plRet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuBand_INTERFACE_DEFINED__ */


#ifndef __IFolderBandPriv_INTERFACE_DEFINED__
#define __IFolderBandPriv_INTERFACE_DEFINED__

/* interface IFolderBandPriv */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFolderBandPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47c01f95-e185-412c-b5c5-4f27df965aea")
    IFolderBandPriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCascade( 
            /* [in] */ BOOL fCascade) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccelerators( 
            /* [in] */ BOOL fAccelerators) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoIcons( 
            /* [in] */ BOOL fNoIcons) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoText( 
            /* [in] */ BOOL fNoText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderBandPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFolderBandPriv * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFolderBandPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFolderBandPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCascade )( 
            __RPC__in IFolderBandPriv * This,
            /* [in] */ BOOL fCascade);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccelerators )( 
            __RPC__in IFolderBandPriv * This,
            /* [in] */ BOOL fAccelerators);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoIcons )( 
            __RPC__in IFolderBandPriv * This,
            /* [in] */ BOOL fNoIcons);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoText )( 
            __RPC__in IFolderBandPriv * This,
            /* [in] */ BOOL fNoText);
        
        END_INTERFACE
    } IFolderBandPrivVtbl;

    interface IFolderBandPriv
    {
        CONST_VTBL struct IFolderBandPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderBandPriv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderBandPriv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderBandPriv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderBandPriv_SetCascade(This,fCascade)	\
    ( (This)->lpVtbl -> SetCascade(This,fCascade) ) 

#define IFolderBandPriv_SetAccelerators(This,fAccelerators)	\
    ( (This)->lpVtbl -> SetAccelerators(This,fAccelerators) ) 

#define IFolderBandPriv_SetNoIcons(This,fNoIcons)	\
    ( (This)->lpVtbl -> SetNoIcons(This,fNoIcons) ) 

#define IFolderBandPriv_SetNoText(This,fNoText)	\
    ( (This)->lpVtbl -> SetNoText(This,fNoText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderBandPriv_INTERFACE_DEFINED__ */


#ifndef __IRegTreeItem_INTERFACE_DEFINED__
#define __IRegTreeItem_INTERFACE_DEFINED__

/* interface IRegTreeItem */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IRegTreeItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9521922-0812-4d44-9EC3-7FD38C726F3D")
    IRegTreeItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCheckState( 
            /* [annotation][out] */ 
            __out  BOOL *pbCheck) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckState( 
            /* [annotation][in] */ 
            __in  BOOL bCheck) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegTreeItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegTreeItem * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegTreeItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegTreeItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckState )( 
            IRegTreeItem * This,
            /* [annotation][out] */ 
            __out  BOOL *pbCheck);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckState )( 
            IRegTreeItem * This,
            /* [annotation][in] */ 
            __in  BOOL bCheck);
        
        END_INTERFACE
    } IRegTreeItemVtbl;

    interface IRegTreeItem
    {
        CONST_VTBL struct IRegTreeItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegTreeItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRegTreeItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRegTreeItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRegTreeItem_GetCheckState(This,pbCheck)	\
    ( (This)->lpVtbl -> GetCheckState(This,pbCheck) ) 

#define IRegTreeItem_SetCheckState(This,bCheck)	\
    ( (This)->lpVtbl -> SetCheckState(This,bCheck) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegTreeItem_INTERFACE_DEFINED__ */


#ifndef __IImageRecompress_INTERFACE_DEFINED__
#define __IImageRecompress_INTERFACE_DEFINED__

/* interface IImageRecompress */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IImageRecompress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("505f1513-6b3e-4892-a272-59f8889a4d3e")
    IImageRecompress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RecompressImage( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ int iQuality,
            /* [in] */ __RPC__in_opt IStorage *pstg,
            /* [out] */ __RPC__deref_out_opt IStream **ppstrmOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageRecompressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IImageRecompress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IImageRecompress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IImageRecompress * This);
        
        HRESULT ( STDMETHODCALLTYPE *RecompressImage )( 
            __RPC__in IImageRecompress * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ int iQuality,
            /* [in] */ __RPC__in_opt IStorage *pstg,
            /* [out] */ __RPC__deref_out_opt IStream **ppstrmOut);
        
        END_INTERFACE
    } IImageRecompressVtbl;

    interface IImageRecompress
    {
        CONST_VTBL struct IImageRecompressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageRecompress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageRecompress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageRecompress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageRecompress_RecompressImage(This,psi,cx,cy,iQuality,pstg,ppstrmOut)	\
    ( (This)->lpVtbl -> RecompressImage(This,psi,cx,cy,iQuality,pstg,ppstrmOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageRecompress_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0126 */
/* [local] */ 

#endif  // NTDDI_WINXP
#endif  // NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0126_v0_0_s_ifspec;

#ifndef __IDeskBar_INTERFACE_DEFINED__
#define __IDeskBar_INTERFACE_DEFINED__

/* interface IDeskBar */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IDeskBar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB0FE173-1A3A-11D0-89B3-00A0C90A90AC")
    IDeskBar : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClient( 
            /* [annotation][in] */ 
            __in  IUnknown *punkClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClient( 
            /* [annotation][out] */ 
            __deref_out  IUnknown **ppunkClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPosRectChangeDB( 
            /* [annotation][in] */ 
            __in  RECT *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBar * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBar * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDeskBar * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDeskBar * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetClient )( 
            IDeskBar * This,
            /* [annotation][in] */ 
            __in  IUnknown *punkClient);
        
        HRESULT ( STDMETHODCALLTYPE *GetClient )( 
            IDeskBar * This,
            /* [annotation][out] */ 
            __deref_out  IUnknown **ppunkClient);
        
        HRESULT ( STDMETHODCALLTYPE *OnPosRectChangeDB )( 
            IDeskBar * This,
            /* [annotation][in] */ 
            __in  RECT *prc);
        
        END_INTERFACE
    } IDeskBarVtbl;

    interface IDeskBar
    {
        CONST_VTBL struct IDeskBarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeskBar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeskBar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeskBar_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IDeskBar_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IDeskBar_SetClient(This,punkClient)	\
    ( (This)->lpVtbl -> SetClient(This,punkClient) ) 

#define IDeskBar_GetClient(This,ppunkClient)	\
    ( (This)->lpVtbl -> GetClient(This,ppunkClient) ) 

#define IDeskBar_OnPosRectChangeDB(This,prc)	\
    ( (This)->lpVtbl -> OnPosRectChangeDB(This,prc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeskBar_INTERFACE_DEFINED__ */


#ifndef __IMenuPopup_INTERFACE_DEFINED__
#define __IMenuPopup_INTERFACE_DEFINED__

/* interface IMenuPopup */
/* [local][unique][object][uuid] */ 


enum tagMENUPOPUPSELECT
    {	MPOS_EXECUTE	= 0,
	MPOS_FULLCANCEL	= ( MPOS_EXECUTE + 1 ) ,
	MPOS_CANCELLEVEL	= ( MPOS_FULLCANCEL + 1 ) ,
	MPOS_SELECTLEFT	= ( MPOS_CANCELLEVEL + 1 ) ,
	MPOS_SELECTRIGHT	= ( MPOS_SELECTLEFT + 1 ) ,
	MPOS_CHILDTRACKING	= ( MPOS_SELECTRIGHT + 1 ) 
    } ;

enum tagMENUPOPUPPOPUPFLAGS
    {	MPPF_SETFOCUS	= 0x1,
	MPPF_INITIALSELECT	= 0x2,
	MPPF_NOANIMATE	= 0x4,
	MPPF_KEYBOARD	= 0x10,
	MPPF_REPOSITION	= 0x20,
	MPPF_FORCEZORDER	= 0x40,
	MPPF_FINALSELECT	= 0x80,
	MPPF_TOP	= 0x20000000,
	MPPF_LEFT	= 0x40000000,
	MPPF_RIGHT	= 0x60000000,
	MPPF_BOTTOM	= ( int  )0x80000000,
	MPPF_POS_MASK	= ( int  )0xe0000000,
	MPPF_ALIGN_LEFT	= 0x2000000,
	MPPF_ALIGN_RIGHT	= 0x4000000
    } ;
typedef int MP_POPUPFLAGS;


EXTERN_C const IID IID_IMenuPopup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4")
    IMenuPopup : public IDeskBar
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Popup( 
            /* [annotation][in] */ 
            __in  POINTL *ppt,
            /* [annotation][unique][in] */ 
            __in_opt  RECTL *prcExclude,
            /* [annotation][in] */ 
            __in  MP_POPUPFLAGS dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelect( 
            /* [annotation][in] */ 
            __in  DWORD dwSelectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubMenu( 
            /* [annotation][in] */ 
            __in  IMenuPopup *pmp,
            /* [annotation][in] */ 
            __in  BOOL fSet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuPopupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMenuPopup * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMenuPopup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMenuPopup * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IMenuPopup * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IMenuPopup * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetClient )( 
            IMenuPopup * This,
            /* [annotation][in] */ 
            __in  IUnknown *punkClient);
        
        HRESULT ( STDMETHODCALLTYPE *GetClient )( 
            IMenuPopup * This,
            /* [annotation][out] */ 
            __deref_out  IUnknown **ppunkClient);
        
        HRESULT ( STDMETHODCALLTYPE *OnPosRectChangeDB )( 
            IMenuPopup * This,
            /* [annotation][in] */ 
            __in  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *Popup )( 
            IMenuPopup * This,
            /* [annotation][in] */ 
            __in  POINTL *ppt,
            /* [annotation][unique][in] */ 
            __in_opt  RECTL *prcExclude,
            /* [annotation][in] */ 
            __in  MP_POPUPFLAGS dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelect )( 
            IMenuPopup * This,
            /* [annotation][in] */ 
            __in  DWORD dwSelectType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubMenu )( 
            IMenuPopup * This,
            /* [annotation][in] */ 
            __in  IMenuPopup *pmp,
            /* [annotation][in] */ 
            __in  BOOL fSet);
        
        END_INTERFACE
    } IMenuPopupVtbl;

    interface IMenuPopup
    {
        CONST_VTBL struct IMenuPopupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuPopup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMenuPopup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMenuPopup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMenuPopup_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IMenuPopup_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IMenuPopup_SetClient(This,punkClient)	\
    ( (This)->lpVtbl -> SetClient(This,punkClient) ) 

#define IMenuPopup_GetClient(This,ppunkClient)	\
    ( (This)->lpVtbl -> GetClient(This,ppunkClient) ) 

#define IMenuPopup_OnPosRectChangeDB(This,prc)	\
    ( (This)->lpVtbl -> OnPosRectChangeDB(This,prc) ) 


#define IMenuPopup_Popup(This,ppt,prcExclude,dwFlags)	\
    ( (This)->lpVtbl -> Popup(This,ppt,prcExclude,dwFlags) ) 

#define IMenuPopup_OnSelect(This,dwSelectType)	\
    ( (This)->lpVtbl -> OnSelect(This,dwSelectType) ) 

#define IMenuPopup_SetSubMenu(This,pmp,fSet)	\
    ( (This)->lpVtbl -> SetSubMenu(This,pmp,fSet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuPopup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0128 */
/* [local] */ 

#endif  // _WIN32_IE_IE60
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef /* [v1_enum] */ 
enum FILE_USAGE_TYPE
    {	FUT_PLAYING	= 0,
	FUT_EDITING	= ( FUT_PLAYING + 1 ) ,
	FUT_GENERIC	= ( FUT_EDITING + 1 ) 
    } 	FILE_USAGE_TYPE;

#define OF_CAP_CANSWITCHTO     0x0001
#define OF_CAP_CANCLOSE        0x0002


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0128_v0_0_s_ifspec;

#ifndef __IFileIsInUse_INTERFACE_DEFINED__
#define __IFileIsInUse_INTERFACE_DEFINED__

/* interface IFileIsInUse */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IFileIsInUse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64a1cbf0-3a1a-4461-9158-376969693950")
    IFileIsInUse : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAppName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUsage( 
            /* [out] */ __RPC__out FILE_USAGE_TYPE *pfut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ __RPC__out DWORD *pdwCapFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSwitchToHWND( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseFile( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileIsInUseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileIsInUse * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileIsInUse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileIsInUse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppName )( 
            __RPC__in IFileIsInUse * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetUsage )( 
            __RPC__in IFileIsInUse * This,
            /* [out] */ __RPC__out FILE_USAGE_TYPE *pfut);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            __RPC__in IFileIsInUse * This,
            /* [out] */ __RPC__out DWORD *pdwCapFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSwitchToHWND )( 
            __RPC__in IFileIsInUse * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *CloseFile )( 
            __RPC__in IFileIsInUse * This);
        
        END_INTERFACE
    } IFileIsInUseVtbl;

    interface IFileIsInUse
    {
        CONST_VTBL struct IFileIsInUseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileIsInUse_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileIsInUse_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileIsInUse_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileIsInUse_GetAppName(This,ppszName)	\
    ( (This)->lpVtbl -> GetAppName(This,ppszName) ) 

#define IFileIsInUse_GetUsage(This,pfut)	\
    ( (This)->lpVtbl -> GetUsage(This,pfut) ) 

#define IFileIsInUse_GetCapabilities(This,pdwCapFlags)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pdwCapFlags) ) 

#define IFileIsInUse_GetSwitchToHWND(This,phwnd)	\
    ( (This)->lpVtbl -> GetSwitchToHWND(This,phwnd) ) 

#define IFileIsInUse_CloseFile(This)	\
    ( (This)->lpVtbl -> CloseFile(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileIsInUse_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0129 */
/* [local] */ 


typedef /* [v1_enum] */ 
enum FDE_OVERWRITE_RESPONSE
    {	FDEOR_DEFAULT	= 0,
	FDEOR_ACCEPT	= 1,
	FDEOR_REFUSE	= 2
    } 	FDE_OVERWRITE_RESPONSE;

typedef /* [v1_enum] */ 
enum FDE_SHAREVIOLATION_RESPONSE
    {	FDESVR_DEFAULT	= 0,
	FDESVR_ACCEPT	= 1,
	FDESVR_REFUSE	= 2
    } 	FDE_SHAREVIOLATION_RESPONSE;

typedef /* [v1_enum] */ 
enum FDAP
    {	FDAP_BOTTOM	= 0,
	FDAP_TOP	= 1
    } 	FDAP;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0129_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0129_v0_0_s_ifspec;

#ifndef __IFileDialogEvents_INTERFACE_DEFINED__
#define __IFileDialogEvents_INTERFACE_DEFINED__

/* interface IFileDialogEvents */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialogEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("973510db-7d7f-452b-8975-74a85828d354")
    IFileDialogEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnFileOk( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFolderChanging( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psiFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFolderChange( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChange( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnShareViolation( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_SHAREVIOLATION_RESPONSE *pResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTypeChange( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOverwrite( 
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_OVERWRITE_RESPONSE *pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileDialogEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileDialogEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFileOk )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnFolderChanging )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psiFolder);
        
        HRESULT ( STDMETHODCALLTYPE *OnFolderChange )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChange )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnShareViolation )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_SHAREVIOLATION_RESPONSE *pResponse);
        
        HRESULT ( STDMETHODCALLTYPE *OnTypeChange )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *OnOverwrite )( 
            __RPC__in IFileDialogEvents * This,
            /* [in] */ __RPC__in_opt IFileDialog *pfd,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out FDE_OVERWRITE_RESPONSE *pResponse);
        
        END_INTERFACE
    } IFileDialogEventsVtbl;

    interface IFileDialogEvents
    {
        CONST_VTBL struct IFileDialogEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialogEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialogEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialogEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialogEvents_OnFileOk(This,pfd)	\
    ( (This)->lpVtbl -> OnFileOk(This,pfd) ) 

#define IFileDialogEvents_OnFolderChanging(This,pfd,psiFolder)	\
    ( (This)->lpVtbl -> OnFolderChanging(This,pfd,psiFolder) ) 

#define IFileDialogEvents_OnFolderChange(This,pfd)	\
    ( (This)->lpVtbl -> OnFolderChange(This,pfd) ) 

#define IFileDialogEvents_OnSelectionChange(This,pfd)	\
    ( (This)->lpVtbl -> OnSelectionChange(This,pfd) ) 

#define IFileDialogEvents_OnShareViolation(This,pfd,psi,pResponse)	\
    ( (This)->lpVtbl -> OnShareViolation(This,pfd,psi,pResponse) ) 

#define IFileDialogEvents_OnTypeChange(This,pfd)	\
    ( (This)->lpVtbl -> OnTypeChange(This,pfd) ) 

#define IFileDialogEvents_OnOverwrite(This,pfd,psi,pResponse)	\
    ( (This)->lpVtbl -> OnOverwrite(This,pfd,psi,pResponse) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialogEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0130 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0130_v0_0_s_ifspec;

#ifndef __IFileDialog_INTERFACE_DEFINED__
#define __IFileDialog_INTERFACE_DEFINED__

/* interface IFileDialog */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum _FILEOPENDIALOGOPTIONS
    {	FOS_OVERWRITEPROMPT	= 0x2,
	FOS_STRICTFILETYPES	= 0x4,
	FOS_NOCHANGEDIR	= 0x8,
	FOS_PICKFOLDERS	= 0x20,
	FOS_FORCEFILESYSTEM	= 0x40,
	FOS_ALLNONSTORAGEITEMS	= 0x80,
	FOS_NOVALIDATE	= 0x100,
	FOS_ALLOWMULTISELECT	= 0x200,
	FOS_PATHMUSTEXIST	= 0x800,
	FOS_FILEMUSTEXIST	= 0x1000,
	FOS_CREATEPROMPT	= 0x2000,
	FOS_SHAREAWARE	= 0x4000,
	FOS_NOREADONLYRETURN	= 0x8000,
	FOS_NOTESTFILECREATE	= 0x10000,
	FOS_HIDEMRUPLACES	= 0x20000,
	FOS_HIDEPINNEDPLACES	= 0x40000,
	FOS_NODEREFERENCELINKS	= 0x100000,
	FOS_DONTADDTORECENT	= 0x2000000,
	FOS_FORCESHOWHIDDEN	= 0x10000000,
	FOS_DEFAULTNOMINIMODE	= 0x20000000,
	FOS_FORCEPREVIEWPANEON	= 0x40000000
    } ;
typedef DWORD FILEOPENDIALOGOPTIONS;


EXTERN_C const IID IID_IFileDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("42f85136-db7e-439c-85f1-e4075d135fc8")
    IFileDialog : public IModalWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFileTypes( 
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileTypeIndex( 
            /* [in] */ UINT iFileType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileTypeIndex( 
            /* [out] */ __RPC__out UINT *piFileType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ FILEOPENDIALOGOPTIONS fos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ __RPC__out FILEOPENDIALOGOPTIONS *pfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSelection( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileName( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOkButtonLabel( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileNameLabel( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPlace( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultExtension( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszDefaultExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientGuid( 
            /* [in] */ __RPC__in REFGUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearClientData( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileDialog * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileDialog * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            __RPC__in IFileDialog * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            __RPC__in IFileDialog * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            __RPC__in IFileDialog * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IFileDialog * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            __RPC__in IFileDialog * This,
            /* [in] */ FILEOPENDIALOGOPTIONS fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            __RPC__in IFileDialog * This,
            /* [out] */ __RPC__out FILEOPENDIALOGOPTIONS *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IFileDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            __RPC__in IFileDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            __RPC__in IFileDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            __RPC__in IFileDialog * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            __RPC__in IFileDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            __RPC__in IFileDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            __RPC__in IFileDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            __RPC__in IFileDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            __RPC__in IFileDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IFileDialog * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            __RPC__in IFileDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            __RPC__in IFileDialog * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        END_INTERFACE
    } IFileDialogVtbl;

    interface IFileDialog
    {
        CONST_VTBL struct IFileDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialog_Show(This,hwndOwner)	\
    ( (This)->lpVtbl -> Show(This,hwndOwner) ) 


#define IFileDialog_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileDialog_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileDialog_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileDialog_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileDialog_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileDialog_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileDialog_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileDialog_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileDialog_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileDialog_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileDialog_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileDialog_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileDialog_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileDialog_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileDialog_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileDialog_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileDialog_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileDialog_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileDialog_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileDialog_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileDialog_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileDialog_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialog_INTERFACE_DEFINED__ */


#ifndef __IFileSaveDialog_INTERFACE_DEFINED__
#define __IFileSaveDialog_INTERFACE_DEFINED__

/* interface IFileSaveDialog */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileSaveDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84bccd23-5fde-4cdb-aea4-af64b83d78ab")
    IFileSaveDialog : public IFileDialog
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSaveAsItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCollectedProperties( 
            /* [in] */ __RPC__in_opt IPropertyDescriptionList *pList,
            /* [in] */ BOOL fAppendDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__deref_out_opt IPropertyStore **ppStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyProperties( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSaveDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileSaveDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileSaveDialog * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileSaveDialog * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            __RPC__in IFileSaveDialog * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ FILEOPENDIALOGOPTIONS fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            __RPC__in IFileSaveDialog * This,
            /* [out] */ __RPC__out FILEOPENDIALOGOPTIONS *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            __RPC__in IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            __RPC__in IFileSaveDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            __RPC__in IFileSaveDialog * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            __RPC__in IFileSaveDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            __RPC__in IFileSaveDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            __RPC__in IFileSaveDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            __RPC__in IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            __RPC__in IFileSaveDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            __RPC__in IFileSaveDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetSaveAsItem )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetCollectedProperties )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IPropertyDescriptionList *pList,
            /* [in] */ BOOL fAppendDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IFileSaveDialog * This,
            /* [out] */ __RPC__deref_out_opt IPropertyStore **ppStore);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyProperties )( 
            __RPC__in IFileSaveDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore,
            /* [unique][in] */ __RPC__in_opt HWND hwnd,
            /* [unique][in] */ __RPC__in_opt IFileOperationProgressSink *pSink);
        
        END_INTERFACE
    } IFileSaveDialogVtbl;

    interface IFileSaveDialog
    {
        CONST_VTBL struct IFileSaveDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSaveDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSaveDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSaveDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSaveDialog_Show(This,hwndOwner)	\
    ( (This)->lpVtbl -> Show(This,hwndOwner) ) 


#define IFileSaveDialog_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileSaveDialog_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileSaveDialog_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileSaveDialog_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileSaveDialog_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileSaveDialog_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileSaveDialog_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileSaveDialog_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileSaveDialog_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileSaveDialog_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileSaveDialog_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileSaveDialog_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileSaveDialog_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileSaveDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileSaveDialog_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileSaveDialog_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileSaveDialog_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileSaveDialog_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileSaveDialog_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileSaveDialog_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileSaveDialog_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileSaveDialog_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileSaveDialog_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 


#define IFileSaveDialog_SetSaveAsItem(This,psi)	\
    ( (This)->lpVtbl -> SetSaveAsItem(This,psi) ) 

#define IFileSaveDialog_SetProperties(This,pStore)	\
    ( (This)->lpVtbl -> SetProperties(This,pStore) ) 

#define IFileSaveDialog_SetCollectedProperties(This,pList,fAppendDefault)	\
    ( (This)->lpVtbl -> SetCollectedProperties(This,pList,fAppendDefault) ) 

#define IFileSaveDialog_GetProperties(This,ppStore)	\
    ( (This)->lpVtbl -> GetProperties(This,ppStore) ) 

#define IFileSaveDialog_ApplyProperties(This,psi,pStore,hwnd,pSink)	\
    ( (This)->lpVtbl -> ApplyProperties(This,psi,pStore,hwnd,pSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSaveDialog_INTERFACE_DEFINED__ */


#ifndef __IFileOpenDialog_INTERFACE_DEFINED__
#define __IFileOpenDialog_INTERFACE_DEFINED__

/* interface IFileOpenDialog */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileOpenDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d57c7288-d4ad-4768-be02-9d969532d960")
    IFileOpenDialog : public IFileDialog
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResults( 
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItems( 
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsai) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileOpenDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileOpenDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileOpenDialog * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileOpenDialog * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ FILEOPENDIALOGOPTIONS fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__out FILEOPENDIALOGOPTIONS *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            __RPC__in IFileOpenDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            __RPC__in IFileOpenDialog * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            __RPC__in IFileOpenDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            __RPC__in IFileOpenDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            __RPC__in IFileOpenDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            __RPC__in IFileOpenDialog * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            __RPC__in IFileOpenDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            __RPC__in IFileOpenDialog * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetResults )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItems )( 
            __RPC__in IFileOpenDialog * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsai);
        
        END_INTERFACE
    } IFileOpenDialogVtbl;

    interface IFileOpenDialog
    {
        CONST_VTBL struct IFileOpenDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileOpenDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileOpenDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileOpenDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileOpenDialog_Show(This,hwndOwner)	\
    ( (This)->lpVtbl -> Show(This,hwndOwner) ) 


#define IFileOpenDialog_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileOpenDialog_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileOpenDialog_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileOpenDialog_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileOpenDialog_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileOpenDialog_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileOpenDialog_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileOpenDialog_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileOpenDialog_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileOpenDialog_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileOpenDialog_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileOpenDialog_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileOpenDialog_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileOpenDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileOpenDialog_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileOpenDialog_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileOpenDialog_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileOpenDialog_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileOpenDialog_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileOpenDialog_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileOpenDialog_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileOpenDialog_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileOpenDialog_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 


#define IFileOpenDialog_GetResults(This,ppenum)	\
    ( (This)->lpVtbl -> GetResults(This,ppenum) ) 

#define IFileOpenDialog_GetSelectedItems(This,ppsai)	\
    ( (This)->lpVtbl -> GetSelectedItems(This,ppsai) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileOpenDialog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0133 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum CDCONTROLSTATEF
    {	CDCS_INACTIVE	= 0,
	CDCS_ENABLED	= 0x1,
	CDCS_VISIBLE	= 0x2,
	CDCS_ENABLEDVISIBLE	= 0x3
    } 	CDCONTROLSTATEF;

DEFINE_ENUM_FLAG_OPERATORS(CDCONTROLSTATEF)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0133_v0_0_s_ifspec;

#ifndef __IFileDialogCustomize_INTERFACE_DEFINED__
#define __IFileDialogCustomize_INTERFACE_DEFINED__

/* interface IFileDialogCustomize */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialogCustomize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6fdd21a-163f-4975-9c8c-a69f1ba37034")
    IFileDialogCustomize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableOpenDropDown( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMenu( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPushButton( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddComboBox( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRadioButtonList( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCheckButton( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEditBox( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSeparator( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddText( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlLabel( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ CDCONTROLSTATEF dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditBoxText( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][out] */ __RPC__deref_out_opt_string WCHAR **ppszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditBoxText( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckButtonState( 
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out BOOL *pbChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckButtonState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllControlItems( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlItemState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlItemState( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ CDCONTROLSTATEF dwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out DWORD *pdwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelectedControlItem( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartVisualGroup( 
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndVisualGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeProminent( 
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlItemText( 
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogCustomizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileDialogCustomize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileDialogCustomize * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableOpenDropDown )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddMenu )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *AddPushButton )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *AddComboBox )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddRadioButtonList )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddCheckButton )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE *AddEditBox )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *AddSeparator )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *AddText )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlLabel )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlState )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ CDCONTROLSTATEF dwState);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditBoxText )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][out] */ __RPC__deref_out_opt_string WCHAR **ppszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditBoxText )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckButtonState )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out BOOL *pbChecked);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckButtonState )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE *AddControlItem )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveControlItem )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllControlItems )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlItemState )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [out] */ __RPC__out CDCONTROLSTATEF *pdwState);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlItemState )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [in] */ CDCONTROLSTATEF dwState);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedControlItem )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [out] */ __RPC__out DWORD *pdwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectedControlItem )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *StartVisualGroup )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *EndVisualGroup )( 
            __RPC__in IFileDialogCustomize * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeProminent )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlItemText )( 
            __RPC__in IFileDialogCustomize * This,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        END_INTERFACE
    } IFileDialogCustomizeVtbl;

    interface IFileDialogCustomize
    {
        CONST_VTBL struct IFileDialogCustomizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialogCustomize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialogCustomize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialogCustomize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialogCustomize_EnableOpenDropDown(This,dwIDCtl)	\
    ( (This)->lpVtbl -> EnableOpenDropDown(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddMenu(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> AddMenu(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_AddPushButton(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> AddPushButton(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_AddComboBox(This,dwIDCtl)	\
    ( (This)->lpVtbl -> AddComboBox(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddRadioButtonList(This,dwIDCtl)	\
    ( (This)->lpVtbl -> AddRadioButtonList(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddCheckButton(This,dwIDCtl,pszLabel,bChecked)	\
    ( (This)->lpVtbl -> AddCheckButton(This,dwIDCtl,pszLabel,bChecked) ) 

#define IFileDialogCustomize_AddEditBox(This,dwIDCtl,pszText)	\
    ( (This)->lpVtbl -> AddEditBox(This,dwIDCtl,pszText) ) 

#define IFileDialogCustomize_AddSeparator(This,dwIDCtl)	\
    ( (This)->lpVtbl -> AddSeparator(This,dwIDCtl) ) 

#define IFileDialogCustomize_AddText(This,dwIDCtl,pszText)	\
    ( (This)->lpVtbl -> AddText(This,dwIDCtl,pszText) ) 

#define IFileDialogCustomize_SetControlLabel(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> SetControlLabel(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_GetControlState(This,dwIDCtl,pdwState)	\
    ( (This)->lpVtbl -> GetControlState(This,dwIDCtl,pdwState) ) 

#define IFileDialogCustomize_SetControlState(This,dwIDCtl,dwState)	\
    ( (This)->lpVtbl -> SetControlState(This,dwIDCtl,dwState) ) 

#define IFileDialogCustomize_GetEditBoxText(This,dwIDCtl,ppszText)	\
    ( (This)->lpVtbl -> GetEditBoxText(This,dwIDCtl,ppszText) ) 

#define IFileDialogCustomize_SetEditBoxText(This,dwIDCtl,pszText)	\
    ( (This)->lpVtbl -> SetEditBoxText(This,dwIDCtl,pszText) ) 

#define IFileDialogCustomize_GetCheckButtonState(This,dwIDCtl,pbChecked)	\
    ( (This)->lpVtbl -> GetCheckButtonState(This,dwIDCtl,pbChecked) ) 

#define IFileDialogCustomize_SetCheckButtonState(This,dwIDCtl,bChecked)	\
    ( (This)->lpVtbl -> SetCheckButtonState(This,dwIDCtl,bChecked) ) 

#define IFileDialogCustomize_AddControlItem(This,dwIDCtl,dwIDItem,pszLabel)	\
    ( (This)->lpVtbl -> AddControlItem(This,dwIDCtl,dwIDItem,pszLabel) ) 

#define IFileDialogCustomize_RemoveControlItem(This,dwIDCtl,dwIDItem)	\
    ( (This)->lpVtbl -> RemoveControlItem(This,dwIDCtl,dwIDItem) ) 

#define IFileDialogCustomize_RemoveAllControlItems(This,dwIDCtl)	\
    ( (This)->lpVtbl -> RemoveAllControlItems(This,dwIDCtl) ) 

#define IFileDialogCustomize_GetControlItemState(This,dwIDCtl,dwIDItem,pdwState)	\
    ( (This)->lpVtbl -> GetControlItemState(This,dwIDCtl,dwIDItem,pdwState) ) 

#define IFileDialogCustomize_SetControlItemState(This,dwIDCtl,dwIDItem,dwState)	\
    ( (This)->lpVtbl -> SetControlItemState(This,dwIDCtl,dwIDItem,dwState) ) 

#define IFileDialogCustomize_GetSelectedControlItem(This,dwIDCtl,pdwIDItem)	\
    ( (This)->lpVtbl -> GetSelectedControlItem(This,dwIDCtl,pdwIDItem) ) 

#define IFileDialogCustomize_SetSelectedControlItem(This,dwIDCtl,dwIDItem)	\
    ( (This)->lpVtbl -> SetSelectedControlItem(This,dwIDCtl,dwIDItem) ) 

#define IFileDialogCustomize_StartVisualGroup(This,dwIDCtl,pszLabel)	\
    ( (This)->lpVtbl -> StartVisualGroup(This,dwIDCtl,pszLabel) ) 

#define IFileDialogCustomize_EndVisualGroup(This)	\
    ( (This)->lpVtbl -> EndVisualGroup(This) ) 

#define IFileDialogCustomize_MakeProminent(This,dwIDCtl)	\
    ( (This)->lpVtbl -> MakeProminent(This,dwIDCtl) ) 

#define IFileDialogCustomize_SetControlItemText(This,dwIDCtl,dwIDItem,pszLabel)	\
    ( (This)->lpVtbl -> SetControlItemText(This,dwIDCtl,dwIDItem,pszLabel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialogCustomize_INTERFACE_DEFINED__ */


#ifndef __IFileDialogControlEvents_INTERFACE_DEFINED__
#define __IFileDialogControlEvents_INTERFACE_DEFINED__

/* interface IFileDialogControlEvents */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialogControlEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36116642-D713-4b97-9B83-7484A9D00433")
    IFileDialogControlEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnItemSelected( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonClicked( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCheckButtonToggled( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnControlActivating( 
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialogControlEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileDialogControlEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileDialogControlEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileDialogControlEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemSelected )( 
            __RPC__in IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ DWORD dwIDItem);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonClicked )( 
            __RPC__in IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl);
        
        HRESULT ( STDMETHODCALLTYPE *OnCheckButtonToggled )( 
            __RPC__in IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl,
            /* [in] */ BOOL bChecked);
        
        HRESULT ( STDMETHODCALLTYPE *OnControlActivating )( 
            __RPC__in IFileDialogControlEvents * This,
            /* [in] */ __RPC__in_opt IFileDialogCustomize *pfdc,
            /* [in] */ DWORD dwIDCtl);
        
        END_INTERFACE
    } IFileDialogControlEventsVtbl;

    interface IFileDialogControlEvents
    {
        CONST_VTBL struct IFileDialogControlEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialogControlEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialogControlEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialogControlEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialogControlEvents_OnItemSelected(This,pfdc,dwIDCtl,dwIDItem)	\
    ( (This)->lpVtbl -> OnItemSelected(This,pfdc,dwIDCtl,dwIDItem) ) 

#define IFileDialogControlEvents_OnButtonClicked(This,pfdc,dwIDCtl)	\
    ( (This)->lpVtbl -> OnButtonClicked(This,pfdc,dwIDCtl) ) 

#define IFileDialogControlEvents_OnCheckButtonToggled(This,pfdc,dwIDCtl,bChecked)	\
    ( (This)->lpVtbl -> OnCheckButtonToggled(This,pfdc,dwIDCtl,bChecked) ) 

#define IFileDialogControlEvents_OnControlActivating(This,pfdc,dwIDCtl)	\
    ( (This)->lpVtbl -> OnControlActivating(This,pfdc,dwIDCtl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialogControlEvents_INTERFACE_DEFINED__ */


#ifndef __IFileDialog2_INTERFACE_DEFINED__
#define __IFileDialog2_INTERFACE_DEFINED__

/* interface IFileDialog2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IFileDialog2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61744fc7-85b5-4791-a9b0-272276309b13")
    IFileDialog2 : public IFileDialog
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCancelButtonLabel( 
            /* [in] */ __RPC__in LPCWSTR pszLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNavigationRoot( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileDialog2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileDialog2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileDialog2 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            IFileDialog2 * This,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypes )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ UINT cFileTypes,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileTypes) const COMDLG_FILTERSPEC *rgFilterSpec);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileTypeIndex )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ UINT iFileType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileTypeIndex )( 
            __RPC__in IFileDialog2 * This,
            /* [out] */ __RPC__out UINT *piFileType);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in_opt IFileDialogEvents *pfde,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ FILEOPENDIALOGOPTIONS fos);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            __RPC__in IFileDialog2 * This,
            /* [out] */ __RPC__out FILEOPENDIALOGOPTIONS *pfos);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultFolder )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolder )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IFileDialog2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            __RPC__in IFileDialog2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            __RPC__in IFileDialog2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            __RPC__in IFileDialog2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            __RPC__in IFileDialog2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetOkButtonLabel )( 
            __RPC__in IFileDialog2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileNameLabel )( 
            __RPC__in IFileDialog2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            __RPC__in IFileDialog2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *AddPlace )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ FDAP fdap);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultExtension )( 
            __RPC__in IFileDialog2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszDefaultExtension);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientData )( 
            __RPC__in IFileDialog2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in_opt IShellItemFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetCancelButtonLabel )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in LPCWSTR pszLabel);
        
        HRESULT ( STDMETHODCALLTYPE *SetNavigationRoot )( 
            __RPC__in IFileDialog2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        END_INTERFACE
    } IFileDialog2Vtbl;

    interface IFileDialog2
    {
        CONST_VTBL struct IFileDialog2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileDialog2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileDialog2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileDialog2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileDialog2_Show(This,hwndOwner)	\
    ( (This)->lpVtbl -> Show(This,hwndOwner) ) 


#define IFileDialog2_SetFileTypes(This,cFileTypes,rgFilterSpec)	\
    ( (This)->lpVtbl -> SetFileTypes(This,cFileTypes,rgFilterSpec) ) 

#define IFileDialog2_SetFileTypeIndex(This,iFileType)	\
    ( (This)->lpVtbl -> SetFileTypeIndex(This,iFileType) ) 

#define IFileDialog2_GetFileTypeIndex(This,piFileType)	\
    ( (This)->lpVtbl -> GetFileTypeIndex(This,piFileType) ) 

#define IFileDialog2_Advise(This,pfde,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pfde,pdwCookie) ) 

#define IFileDialog2_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IFileDialog2_SetOptions(This,fos)	\
    ( (This)->lpVtbl -> SetOptions(This,fos) ) 

#define IFileDialog2_GetOptions(This,pfos)	\
    ( (This)->lpVtbl -> GetOptions(This,pfos) ) 

#define IFileDialog2_SetDefaultFolder(This,psi)	\
    ( (This)->lpVtbl -> SetDefaultFolder(This,psi) ) 

#define IFileDialog2_SetFolder(This,psi)	\
    ( (This)->lpVtbl -> SetFolder(This,psi) ) 

#define IFileDialog2_GetFolder(This,ppsi)	\
    ( (This)->lpVtbl -> GetFolder(This,ppsi) ) 

#define IFileDialog2_GetCurrentSelection(This,ppsi)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,ppsi) ) 

#define IFileDialog2_SetFileName(This,pszName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszName) ) 

#define IFileDialog2_GetFileName(This,pszName)	\
    ( (This)->lpVtbl -> GetFileName(This,pszName) ) 

#define IFileDialog2_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IFileDialog2_SetOkButtonLabel(This,pszText)	\
    ( (This)->lpVtbl -> SetOkButtonLabel(This,pszText) ) 

#define IFileDialog2_SetFileNameLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetFileNameLabel(This,pszLabel) ) 

#define IFileDialog2_GetResult(This,ppsi)	\
    ( (This)->lpVtbl -> GetResult(This,ppsi) ) 

#define IFileDialog2_AddPlace(This,psi,fdap)	\
    ( (This)->lpVtbl -> AddPlace(This,psi,fdap) ) 

#define IFileDialog2_SetDefaultExtension(This,pszDefaultExtension)	\
    ( (This)->lpVtbl -> SetDefaultExtension(This,pszDefaultExtension) ) 

#define IFileDialog2_Close(This,hr)	\
    ( (This)->lpVtbl -> Close(This,hr) ) 

#define IFileDialog2_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IFileDialog2_ClearClientData(This)	\
    ( (This)->lpVtbl -> ClearClientData(This) ) 

#define IFileDialog2_SetFilter(This,pFilter)	\
    ( (This)->lpVtbl -> SetFilter(This,pFilter) ) 


#define IFileDialog2_SetCancelButtonLabel(This,pszLabel)	\
    ( (This)->lpVtbl -> SetCancelButtonLabel(This,pszLabel) ) 

#define IFileDialog2_SetNavigationRoot(This,psi)	\
    ( (This)->lpVtbl -> SetNavigationRoot(This,psi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileDialog2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0136 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum ASSOCIATIONLEVEL
    {	AL_MACHINE	= 0,
	AL_EFFECTIVE	= ( AL_MACHINE + 1 ) ,
	AL_USER	= ( AL_EFFECTIVE + 1 ) 
    } 	ASSOCIATIONLEVEL;

typedef /* [v1_enum] */ 
enum ASSOCIATIONTYPE
    {	AT_FILEEXTENSION	= 0,
	AT_URLPROTOCOL	= ( AT_FILEEXTENSION + 1 ) ,
	AT_STARTMENUCLIENT	= ( AT_URLPROTOCOL + 1 ) ,
	AT_MIMETYPE	= ( AT_STARTMENUCLIENT + 1 ) 
    } 	ASSOCIATIONTYPE;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0136_v0_0_s_ifspec;

#ifndef __IApplicationAssociationRegistration_INTERFACE_DEFINED__
#define __IApplicationAssociationRegistration_INTERFACE_DEFINED__

/* interface IApplicationAssociationRegistration */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IApplicationAssociationRegistration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e530b0a-e611-4c77-a3ac-9031d022281b")
    IApplicationAssociationRegistration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryCurrentDefault( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAssociation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAppIsDefault( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAppIsDefaultAll( 
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppAsDefault( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName,
            /* [string][in] */ __RPC__in_string LPCWSTR pszSet,
            /* [in] */ ASSOCIATIONTYPE atSetType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppAsDefaultAll( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearUserAssociations( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationAssociationRegistrationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IApplicationAssociationRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IApplicationAssociationRegistration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IApplicationAssociationRegistration * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCurrentDefault )( 
            __RPC__in IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAssociation);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAppIsDefault )( 
            __RPC__in IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszQuery,
            /* [in] */ ASSOCIATIONTYPE atQueryType,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAppIsDefaultAll )( 
            __RPC__in IApplicationAssociationRegistration * This,
            /* [in] */ ASSOCIATIONLEVEL alQueryLevel,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName,
            /* [out] */ __RPC__out BOOL *pfDefault);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppAsDefault )( 
            __RPC__in IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName,
            /* [string][in] */ __RPC__in_string LPCWSTR pszSet,
            /* [in] */ ASSOCIATIONTYPE atSetType);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppAsDefaultAll )( 
            __RPC__in IApplicationAssociationRegistration * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName);
        
        HRESULT ( STDMETHODCALLTYPE *ClearUserAssociations )( 
            __RPC__in IApplicationAssociationRegistration * This);
        
        END_INTERFACE
    } IApplicationAssociationRegistrationVtbl;

    interface IApplicationAssociationRegistration
    {
        CONST_VTBL struct IApplicationAssociationRegistrationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationAssociationRegistration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationAssociationRegistration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationAssociationRegistration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationAssociationRegistration_QueryCurrentDefault(This,pszQuery,atQueryType,alQueryLevel,ppszAssociation)	\
    ( (This)->lpVtbl -> QueryCurrentDefault(This,pszQuery,atQueryType,alQueryLevel,ppszAssociation) ) 

#define IApplicationAssociationRegistration_QueryAppIsDefault(This,pszQuery,atQueryType,alQueryLevel,pszAppRegistryName,pfDefault)	\
    ( (This)->lpVtbl -> QueryAppIsDefault(This,pszQuery,atQueryType,alQueryLevel,pszAppRegistryName,pfDefault) ) 

#define IApplicationAssociationRegistration_QueryAppIsDefaultAll(This,alQueryLevel,pszAppRegistryName,pfDefault)	\
    ( (This)->lpVtbl -> QueryAppIsDefaultAll(This,alQueryLevel,pszAppRegistryName,pfDefault) ) 

#define IApplicationAssociationRegistration_SetAppAsDefault(This,pszAppRegistryName,pszSet,atSetType)	\
    ( (This)->lpVtbl -> SetAppAsDefault(This,pszAppRegistryName,pszSet,atSetType) ) 

#define IApplicationAssociationRegistration_SetAppAsDefaultAll(This,pszAppRegistryName)	\
    ( (This)->lpVtbl -> SetAppAsDefaultAll(This,pszAppRegistryName) ) 

#define IApplicationAssociationRegistration_ClearUserAssociations(This)	\
    ( (This)->lpVtbl -> ClearUserAssociations(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationAssociationRegistration_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0137 */
/* [local] */ 

SHSTDAPI SHCreateAssociationRegistration(__in REFIID riid, __deref_out void **ppv);


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0137_v0_0_s_ifspec;

#ifndef __IApplicationAssociationRegistrationUI_INTERFACE_DEFINED__
#define __IApplicationAssociationRegistrationUI_INTERFACE_DEFINED__

/* interface IApplicationAssociationRegistrationUI */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IApplicationAssociationRegistrationUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f76a169-f994-40ac-8fc8-0959e8874710")
    IApplicationAssociationRegistrationUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LaunchAdvancedAssociationUI( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationAssociationRegistrationUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IApplicationAssociationRegistrationUI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IApplicationAssociationRegistrationUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IApplicationAssociationRegistrationUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *LaunchAdvancedAssociationUI )( 
            __RPC__in IApplicationAssociationRegistrationUI * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppRegistryName);
        
        END_INTERFACE
    } IApplicationAssociationRegistrationUIVtbl;

    interface IApplicationAssociationRegistrationUI
    {
        CONST_VTBL struct IApplicationAssociationRegistrationUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationAssociationRegistrationUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationAssociationRegistrationUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationAssociationRegistrationUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationAssociationRegistrationUI_LaunchAdvancedAssociationUI(This,pszAppRegistryName)	\
    ( (This)->lpVtbl -> LaunchAdvancedAssociationUI(This,pszAppRegistryName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationAssociationRegistrationUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0138 */
/* [local] */ 

#endif  // NTDDI_VISTA
#include <pshpack1.h>
typedef struct DELEGATEITEMID
    {
    WORD cbSize;
    WORD wOuter;
    WORD cbInner;
    BYTE rgb[ 1 ];
    } 	DELEGATEITEMID;

#include <poppack.h>
typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;
typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0138_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0138_v0_0_s_ifspec;

#ifndef __IDelegateFolder_INTERFACE_DEFINED__
#define __IDelegateFolder_INTERFACE_DEFINED__

/* interface IDelegateFolder */
/* [unique][local][object][uuid] */ 


EXTERN_C const IID IID_IDelegateFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADD8BA80-002B-11D0-8F0F-00C04FD7D062")
    IDelegateFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetItemAlloc( 
            /* [annotation][in] */ 
            __in  IMalloc *pmalloc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelegateFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelegateFolder * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelegateFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelegateFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemAlloc )( 
            IDelegateFolder * This,
            /* [annotation][in] */ 
            __in  IMalloc *pmalloc);
        
        END_INTERFACE
    } IDelegateFolderVtbl;

    interface IDelegateFolder
    {
        CONST_VTBL struct IDelegateFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelegateFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelegateFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelegateFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelegateFolder_SetItemAlloc(This,pmalloc)	\
    ( (This)->lpVtbl -> SetItemAlloc(This,pmalloc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelegateFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0139 */
/* [local] */ 

#if (_WIN32_IE >= _WIN32_IE_IE60)
// INTERFACE: IBrowserFrameOptions
//
// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what
// kind of 'Behavior' is appropriate for that view.
//
//    IBrowserFrameOptions::GetBrowserOptions()
//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and
//       it's return value will always equal or will be a subset of dwMask.
//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.
//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.
//


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0139_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0139_v0_0_s_ifspec;

#ifndef __IBrowserFrameOptions_INTERFACE_DEFINED__
#define __IBrowserFrameOptions_INTERFACE_DEFINED__

/* interface IBrowserFrameOptions */
/* [local][object][uuid] */ 

typedef /* [unique] */ IBrowserFrameOptions *LPBROWSERFRAMEOPTIONS;

/* [v1_enum] */ 
enum _BROWSERFRAMEOPTIONS
    {	BFO_NONE	= 0,
	BFO_BROWSER_PERSIST_SETTINGS	= 0x1,
	BFO_RENAME_FOLDER_OPTIONS_TOINTERNET	= 0x2,
	BFO_BOTH_OPTIONS	= 0x4,
	BIF_PREFER_INTERNET_SHORTCUT	= 0x8,
	BFO_BROWSE_NO_IN_NEW_PROCESS	= 0x10,
	BFO_ENABLE_HYPERLINK_TRACKING	= 0x20,
	BFO_USE_IE_OFFLINE_SUPPORT	= 0x40,
	BFO_SUBSTITUE_INTERNET_START_PAGE	= 0x80,
	BFO_USE_IE_LOGOBANDING	= 0x100,
	BFO_ADD_IE_TOCAPTIONBAR	= 0x200,
	BFO_USE_DIALUP_REF	= 0x400,
	BFO_USE_IE_TOOLBAR	= 0x800,
	BFO_NO_PARENT_FOLDER_SUPPORT	= 0x1000,
	BFO_NO_REOPEN_NEXT_RESTART	= 0x2000,
	BFO_GO_HOME_PAGE	= 0x4000,
	BFO_PREFER_IEPROCESS	= 0x8000,
	BFO_SHOW_NAVIGATION_CANCELLED	= 0x10000,
	BFO_USE_IE_STATUSBAR	= 0x20000,
	BFO_QUERY_ALL	= ( int  )0xffffffff
    } ;
typedef DWORD BROWSERFRAMEOPTIONS;


EXTERN_C const IID IID_IBrowserFrameOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10DF43C8-1DBE-11d3-8B34-006097DF5BD4")
    IBrowserFrameOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [annotation][in] */ 
            __in  BROWSERFRAMEOPTIONS dwMask,
            /* [annotation][out] */ 
            __out  BROWSERFRAMEOPTIONS *pdwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBrowserFrameOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBrowserFrameOptions * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBrowserFrameOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBrowserFrameOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameOptions )( 
            IBrowserFrameOptions * This,
            /* [annotation][in] */ 
            __in  BROWSERFRAMEOPTIONS dwMask,
            /* [annotation][out] */ 
            __out  BROWSERFRAMEOPTIONS *pdwOptions);
        
        END_INTERFACE
    } IBrowserFrameOptionsVtbl;

    interface IBrowserFrameOptions
    {
        CONST_VTBL struct IBrowserFrameOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBrowserFrameOptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBrowserFrameOptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBrowserFrameOptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBrowserFrameOptions_GetFrameOptions(This,dwMask,pdwOptions)	\
    ( (This)->lpVtbl -> GetFrameOptions(This,dwMask,pdwOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBrowserFrameOptions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0140 */
/* [local] */ 

#endif  // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
typedef /* [v1_enum] */ 
enum NWMF
    {	NWMF_UNLOADING	= 0x1,
	NWMF_USERINITED	= 0x2,
	NWMF_FIRST	= 0x4,
	NWMF_OVERRIDEKEY	= 0x8,
	NWMF_SHOWHELP	= 0x10,
	NWMF_HTMLDIALOG	= 0x20,
	NWMF_FROMDIALOGCHILD	= 0x40,
	NWMF_USERREQUESTED	= 0x80,
	NWMF_USERALLOWED	= 0x100,
	NWMF_FORCEWINDOW	= 0x10000,
	NWMF_FORCETAB	= 0x20000,
	NWMF_SUGGESTWINDOW	= 0x40000,
	NWMF_SUGGESTTAB	= 0x80000,
	NWMF_INACTIVETAB	= 0x100000
    } 	NWMF;

DEFINE_ENUM_FLAG_OPERATORS(NWMF)
#define SID_SNewWindowManager IID_INewWindowManager


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0140_v0_0_s_ifspec;

#ifndef __INewWindowManager_INTERFACE_DEFINED__
#define __INewWindowManager_INTERFACE_DEFINED__

/* interface INewWindowManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_INewWindowManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2BC4C84-3F72-4a52-A604-7BCBF3982CBB")
    INewWindowManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EvaluateNewWindow( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszUrl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [string][in] */ __RPC__in_string LPCWSTR pszUrlContext,
            /* [string][in] */ __RPC__in_string LPCWSTR pszFeatures,
            /* [in] */ BOOL fReplace,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwUserActionTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INewWindowManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INewWindowManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INewWindowManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INewWindowManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EvaluateNewWindow )( 
            __RPC__in INewWindowManager * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszUrl,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [string][in] */ __RPC__in_string LPCWSTR pszUrlContext,
            /* [string][in] */ __RPC__in_string LPCWSTR pszFeatures,
            /* [in] */ BOOL fReplace,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwUserActionTime);
        
        END_INTERFACE
    } INewWindowManagerVtbl;

    interface INewWindowManager
    {
        CONST_VTBL struct INewWindowManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INewWindowManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INewWindowManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INewWindowManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INewWindowManager_EvaluateNewWindow(This,pszUrl,pszName,pszUrlContext,pszFeatures,fReplace,dwFlags,dwUserActionTime)	\
    ( (This)->lpVtbl -> EvaluateNewWindow(This,pszUrl,pszName,pszUrlContext,pszFeatures,fReplace,dwFlags,dwUserActionTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INewWindowManager_INTERFACE_DEFINED__ */


#ifndef __IAttachmentExecute_INTERFACE_DEFINED__
#define __IAttachmentExecute_INTERFACE_DEFINED__

/* interface IAttachmentExecute */
/* [unique][local][uuid][object] */ 

typedef /* [v1_enum] */ 
enum ATTACHMENT_PROMPT
    {	ATTACHMENT_PROMPT_NONE	= 0,
	ATTACHMENT_PROMPT_SAVE	= 0x1,
	ATTACHMENT_PROMPT_EXEC	= 0x2,
	ATTACHMENT_PROMPT_EXEC_OR_SAVE	= 0x3
    } 	ATTACHMENT_PROMPT;

typedef /* [v1_enum] */ 
enum ATTACHMENT_ACTION
    {	ATTACHMENT_ACTION_CANCEL	= 0,
	ATTACHMENT_ACTION_SAVE	= 0x1,
	ATTACHMENT_ACTION_EXEC	= 0x2
    } 	ATTACHMENT_ACTION;


EXTERN_C const IID IID_IAttachmentExecute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73db1241-1e85-4581-8e4f-a81e1d0f8c57")
    IAttachmentExecute : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClientTitle( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientGuid( 
            /* [annotation][in] */ 
            __in  REFGUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalPath( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszLocalPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileName( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReferrer( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszReferrer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckPolicy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prompt( 
            /* [annotation][in] */ 
            __in  HWND hwnd,
            /* [annotation][in] */ 
            __in  ATTACHMENT_PROMPT prompt,
            /* [annotation][out] */ 
            __out  ATTACHMENT_ACTION *paction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [annotation][in] */ 
            __in  HWND hwnd,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszVerb,
            /* [annotation][out] */ 
            __out_opt  HANDLE *phProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveWithUI( 
            /* [annotation][in] */ 
            __in  HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearClientState( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttachmentExecuteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAttachmentExecute * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAttachmentExecute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAttachmentExecute * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientTitle )( 
            IAttachmentExecute * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientGuid )( 
            IAttachmentExecute * This,
            /* [annotation][in] */ 
            __in  REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalPath )( 
            IAttachmentExecute * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszLocalPath);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IAttachmentExecute * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *SetSource )( 
            IAttachmentExecute * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszSource);
        
        HRESULT ( STDMETHODCALLTYPE *SetReferrer )( 
            IAttachmentExecute * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszReferrer);
        
        HRESULT ( STDMETHODCALLTYPE *CheckPolicy )( 
            IAttachmentExecute * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prompt )( 
            IAttachmentExecute * This,
            /* [annotation][in] */ 
            __in  HWND hwnd,
            /* [annotation][in] */ 
            __in  ATTACHMENT_PROMPT prompt,
            /* [annotation][out] */ 
            __out  ATTACHMENT_ACTION *paction);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IAttachmentExecute * This);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IAttachmentExecute * This,
            /* [annotation][in] */ 
            __in  HWND hwnd,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszVerb,
            /* [annotation][out] */ 
            __out_opt  HANDLE *phProcess);
        
        HRESULT ( STDMETHODCALLTYPE *SaveWithUI )( 
            IAttachmentExecute * This,
            /* [annotation][in] */ 
            __in  HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ClearClientState )( 
            IAttachmentExecute * This);
        
        END_INTERFACE
    } IAttachmentExecuteVtbl;

    interface IAttachmentExecute
    {
        CONST_VTBL struct IAttachmentExecuteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttachmentExecute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAttachmentExecute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAttachmentExecute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAttachmentExecute_SetClientTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetClientTitle(This,pszTitle) ) 

#define IAttachmentExecute_SetClientGuid(This,guid)	\
    ( (This)->lpVtbl -> SetClientGuid(This,guid) ) 

#define IAttachmentExecute_SetLocalPath(This,pszLocalPath)	\
    ( (This)->lpVtbl -> SetLocalPath(This,pszLocalPath) ) 

#define IAttachmentExecute_SetFileName(This,pszFileName)	\
    ( (This)->lpVtbl -> SetFileName(This,pszFileName) ) 

#define IAttachmentExecute_SetSource(This,pszSource)	\
    ( (This)->lpVtbl -> SetSource(This,pszSource) ) 

#define IAttachmentExecute_SetReferrer(This,pszReferrer)	\
    ( (This)->lpVtbl -> SetReferrer(This,pszReferrer) ) 

#define IAttachmentExecute_CheckPolicy(This)	\
    ( (This)->lpVtbl -> CheckPolicy(This) ) 

#define IAttachmentExecute_Prompt(This,hwnd,prompt,paction)	\
    ( (This)->lpVtbl -> Prompt(This,hwnd,prompt,paction) ) 

#define IAttachmentExecute_Save(This)	\
    ( (This)->lpVtbl -> Save(This) ) 

#define IAttachmentExecute_Execute(This,hwnd,pszVerb,phProcess)	\
    ( (This)->lpVtbl -> Execute(This,hwnd,pszVerb,phProcess) ) 

#define IAttachmentExecute_SaveWithUI(This,hwnd)	\
    ( (This)->lpVtbl -> SaveWithUI(This,hwnd) ) 

#define IAttachmentExecute_ClearClientState(This)	\
    ( (This)->lpVtbl -> ClearClientState(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAttachmentExecute_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0142 */
/* [local] */ 

#endif  // _WIN32_IE_IE60SP2
#if (_WIN32_IE >= _WIN32_IE_IE60)
#include <pshpack8.h>
typedef struct tagSMDATA
    {
    DWORD dwMask;
    DWORD dwFlags;
    HMENU hmenu;
    HWND hwnd;
    UINT uId;
    UINT uIdParent;
    UINT uIdAncestor;
    IUnknown *punk;
    PIDLIST_ABSOLUTE pidlFolder;
    PUITEMID_CHILD pidlItem;
    IShellFolder *psf;
    void *pvUserData;
    } 	SMDATA;

typedef struct tagSMDATA *LPSMDATA;

// Mask
#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band
#define SMDM_HMENU                     0x00000002  // This is for the Band itself
#define SMDM_TOOLBAR                   0x00000004  // Plain toolbar, not associated with a shell folder or hmenu
// Flags (bitmask)
typedef struct tagSMINFO
    {
    DWORD dwMask;
    DWORD dwType;
    DWORD dwFlags;
    int iIcon;
    } 	SMINFO;

typedef struct tagSMINFO *PSMINFO;

typedef struct SHCSCHANGENOTIFYSTRUCT
    {
    long lEvent;
    PCIDLIST_ABSOLUTE pidl1;
    PCIDLIST_ABSOLUTE pidl2;
    } 	SMCSHCHANGENOTIFYSTRUCT;

typedef struct SHCSCHANGENOTIFYSTRUCT *PSMCSHCHANGENOTIFYSTRUCT;

#include <poppack.h>

enum tagSMINFOMASK
    {	SMIM_TYPE	= 0x1,
	SMIM_FLAGS	= 0x2,
	SMIM_ICON	= 0x4
    } ;

enum tagSMINFOTYPE
    {	SMIT_SEPARATOR	= 0x1,
	SMIT_STRING	= 0x2
    } ;

enum tagSMINFOFLAGS
    {	SMIF_ICON	= 0x1,
	SMIF_ACCELERATOR	= 0x2,
	SMIF_DROPTARGET	= 0x4,
	SMIF_SUBMENU	= 0x8,
	SMIF_CHECKED	= 0x20,
	SMIF_DROPCASCADE	= 0x40,
	SMIF_HIDDEN	= 0x80,
	SMIF_DISABLED	= 0x100,
	SMIF_TRACKPOPUP	= 0x200,
	SMIF_DEMOTED	= 0x400,
	SMIF_ALTSTATE	= 0x800,
	SMIF_DRAGNDROP	= 0x1000,
	SMIF_NEW	= 0x2000
    } ;
#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband
#define SMC_CREATE              0x00000002
#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing
#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values
#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values
#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object
#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object
#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item
#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected
#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.
#define SMC_DEMOTE              0x00000011  // Demote an item
#define SMC_PROMOTE             0x00000012  // Promote an item, wParam = SMINV_* flag
#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam
#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.
#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron
#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.
#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object
#define SMC_SHCHANGENOTIFY      0x0000002E  // Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT
#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH
#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SMC_SFEXEC_MIDDLE       0x00000031  // Same as SFEXEC, but the middle mouse button caused the exec.
#define SMC_GETAUTOEXPANDSTATE  0x00000041  // callback returns the default autoexpand state lParam = LPDWORD to recieve flags
#define SMC_AUTOEXPANDCHANGE    0x00000042  // Notify that the menu is expanding/contracting
#define SMC_GETCONTEXTMENUMODIFIER 0x00000043  // Used to add items to a context menu
#define SMC_GETBKCONTEXTMENU    0x00000044  // used to get a context menu to display when user right clicks on the background
#define SMC_OPEN                0x00000045  // allows client to overwrite open/explore verb action on an item
// Flags for return value from SMC_GETAUTOEXPANDSTATE and SMC_AUTOEXPANDCHANGE:
#define SMAE_EXPANDED           0x00000001  // The menu is or should start expanded
#define SMAE_CONTRACTED         0x00000002  // The menu is or should start contracted
                                            // SMAE_EXPANDED and SMAE_CONTRACTED are mutually exclusive
#define SMAE_USER               0x00000004  // Indicates that the menu expansion/contraction is a reflection
                                            // of user choice
#define SMAE_VALID              0x00000007
#endif  // _WIN32_IE_IE70


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0142_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0142_v0_0_s_ifspec;

#ifndef __IShellMenuCallback_INTERFACE_DEFINED__
#define __IShellMenuCallback_INTERFACE_DEFINED__

/* interface IShellMenuCallback */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CA300A1-9B8D-11d1-8B22-00C04FD918D0")
    IShellMenuCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallbackSM( 
            /* [annotation][out][in] */ 
            __inout  LPSMDATA psmd,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenuCallback * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenuCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenuCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallbackSM )( 
            IShellMenuCallback * This,
            /* [annotation][out][in] */ 
            __inout  LPSMDATA psmd,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IShellMenuCallbackVtbl;

    interface IShellMenuCallback
    {
        CONST_VTBL struct IShellMenuCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenuCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellMenuCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellMenuCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellMenuCallback_CallbackSM(This,psmd,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> CallbackSM(This,psmd,uMsg,wParam,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellMenuCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0143 */
/* [local] */ 

#define SMINIT_DEFAULT              0x00000000  // No Options
#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop
#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.
#define SMINIT_CACHED               0x00000010
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SMINIT_AUTOEXPAND           0x00000100  // automatically expand/contract menu band
#define SMINIT_AUTOTOOLTIP          0x00000200  // regular tooltip support
#define SMINIT_DROPONCONTAINER      0x00000400  // allow drop on a container
#endif  // _WIN32_IE_IE70
#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu
#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)
#define ANCESTORDEFAULT      (UINT)-1
#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu
#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu
#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object
#define SMINV_REFRESH        0x00000001
#define SMINV_ID             0x00000008


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0143_v0_0_s_ifspec;

#ifndef __IShellMenu_INTERFACE_DEFINED__
#define __IShellMenu_INTERFACE_DEFINED__

/* interface IShellMenu */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1F7637-E138-11d1-8379-00C04FD918D0")
    IShellMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellMenuCallback *psmc,
            /* [annotation][in] */ 
            __in  UINT uId,
            /* [annotation][in] */ 
            __in  UINT uIdAncestor,
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuInfo( 
            /* [annotation][out] */ 
            __deref_opt_out  IShellMenuCallback **ppsmc,
            /* [annotation][out] */ 
            __out_opt  UINT *puId,
            /* [annotation][out] */ 
            __out_opt  UINT *puIdAncestor,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShellFolder( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellFolder *psf,
            /* [annotation][unique][in] */ 
            __in_opt  PCIDLIST_ABSOLUTE pidlFolder,
            /* [annotation][unique][in] */ 
            __in_opt  HKEY hKey,
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellFolder( 
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags,
            /* [annotation][out] */ 
            __deref_out  PIDLIST_ABSOLUTE *ppidl,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenu( 
            /* [annotation][unique][in] */ 
            __in_opt  HMENU hmenu,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenu( 
            /* [annotation][out] */ 
            __out_opt  HMENU *phmenu,
            /* [annotation][out] */ 
            __out_opt  HWND *phwnd,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateItem( 
            /* [annotation][in] */ 
            __in_opt  LPSMDATA psmd,
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [annotation][out] */ 
            __out  LPSMDATA psmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuToolbar( 
            /* [annotation][in] */ 
            __in  IUnknown *punk,
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenu * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellMenu * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellMenuCallback *psmc,
            /* [annotation][in] */ 
            __in  UINT uId,
            /* [annotation][in] */ 
            __in  UINT uIdAncestor,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuInfo )( 
            IShellMenu * This,
            /* [annotation][out] */ 
            __deref_opt_out  IShellMenuCallback **ppsmc,
            /* [annotation][out] */ 
            __out_opt  UINT *puId,
            /* [annotation][out] */ 
            __out_opt  UINT *puIdAncestor,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetShellFolder )( 
            IShellMenu * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellFolder *psf,
            /* [annotation][unique][in] */ 
            __in_opt  PCIDLIST_ABSOLUTE pidlFolder,
            /* [annotation][unique][in] */ 
            __in_opt  HKEY hKey,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellFolder )( 
            IShellMenu * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags,
            /* [annotation][out] */ 
            __deref_out  PIDLIST_ABSOLUTE *ppidl,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenu )( 
            IShellMenu * This,
            /* [annotation][unique][in] */ 
            __in_opt  HMENU hmenu,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            IShellMenu * This,
            /* [annotation][out] */ 
            __out_opt  HMENU *phmenu,
            /* [annotation][out] */ 
            __out_opt  HWND *phwnd,
            /* [annotation][out] */ 
            __out_opt  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateItem )( 
            IShellMenu * This,
            /* [annotation][in] */ 
            __in_opt  LPSMDATA psmd,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IShellMenu * This,
            /* [annotation][out] */ 
            __out  LPSMDATA psmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuToolbar )( 
            IShellMenu * This,
            /* [annotation][in] */ 
            __in  IUnknown *punk,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        END_INTERFACE
    } IShellMenuVtbl;

    interface IShellMenu
    {
        CONST_VTBL struct IShellMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellMenu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellMenu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellMenu_Initialize(This,psmc,uId,uIdAncestor,dwFlags)	\
    ( (This)->lpVtbl -> Initialize(This,psmc,uId,uIdAncestor,dwFlags) ) 

#define IShellMenu_GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)	\
    ( (This)->lpVtbl -> GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags) ) 

#define IShellMenu_SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)	\
    ( (This)->lpVtbl -> SetShellFolder(This,psf,pidlFolder,hKey,dwFlags) ) 

#define IShellMenu_GetShellFolder(This,pdwFlags,ppidl,riid,ppv)	\
    ( (This)->lpVtbl -> GetShellFolder(This,pdwFlags,ppidl,riid,ppv) ) 

#define IShellMenu_SetMenu(This,hmenu,hwnd,dwFlags)	\
    ( (This)->lpVtbl -> SetMenu(This,hmenu,hwnd,dwFlags) ) 

#define IShellMenu_GetMenu(This,phmenu,phwnd,pdwFlags)	\
    ( (This)->lpVtbl -> GetMenu(This,phmenu,phwnd,pdwFlags) ) 

#define IShellMenu_InvalidateItem(This,psmd,dwFlags)	\
    ( (This)->lpVtbl -> InvalidateItem(This,psmd,dwFlags) ) 

#define IShellMenu_GetState(This,psmd)	\
    ( (This)->lpVtbl -> GetState(This,psmd) ) 

#define IShellMenu_SetMenuToolbar(This,punk,dwFlags)	\
    ( (This)->lpVtbl -> SetMenuToolbar(This,punk,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0144 */
/* [local] */ 

#endif  // _WIN32_IE_IE60


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0144_v0_0_s_ifspec;

#ifndef __IShellRunDll_INTERFACE_DEFINED__
#define __IShellRunDll_INTERFACE_DEFINED__

/* interface IShellRunDll */
/* [local][ref][object][uuid] */ 


EXTERN_C const IID IID_IShellRunDll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fce4bde0-4b68-4b80-8e9c-7426315a7388")
    IShellRunDll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellRunDllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellRunDll * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellRunDll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellRunDll * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IShellRunDll * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszArgs);
        
        END_INTERFACE
    } IShellRunDllVtbl;

    interface IShellRunDll
    {
        CONST_VTBL struct IShellRunDllVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellRunDll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellRunDll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellRunDll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellRunDll_Run(This,pszArgs)	\
    ( (This)->lpVtbl -> Run(This,pszArgs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellRunDll_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0145 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef /* [v1_enum] */ 
enum KF_CATEGORY
    {	KF_CATEGORY_VIRTUAL	= 1,
	KF_CATEGORY_FIXED	= 2,
	KF_CATEGORY_COMMON	= 3,
	KF_CATEGORY_PERUSER	= 4
    } 	KF_CATEGORY;

/* [v1_enum] */ 
enum _KF_DEFINITION_FLAGS
    {	KFDF_LOCAL_REDIRECT_ONLY	= 0x2,
	KFDF_ROAMABLE	= 0x4,
	KFDF_PRECREATE	= 0x8,
	KFDF_STREAM	= 0x10,
	KFDF_PUBLISHEXPANDEDPATH	= 0x20
    } ;
typedef DWORD KF_DEFINITION_FLAGS;

/* [v1_enum] */ 
enum _KF_REDIRECT_FLAGS
    {	KF_REDIRECT_USER_EXCLUSIVE	= 0x1,
	KF_REDIRECT_COPY_SOURCE_DACL	= 0x2,
	KF_REDIRECT_OWNER_USER	= 0x4,
	KF_REDIRECT_SET_OWNER_EXPLICIT	= 0x8,
	KF_REDIRECT_CHECK_ONLY	= 0x10,
	KF_REDIRECT_WITH_UI	= 0x20,
	KF_REDIRECT_UNPIN	= 0x40,
	KF_REDIRECT_PIN	= 0x80,
	KF_REDIRECT_COPY_CONTENTS	= 0x200,
	KF_REDIRECT_DEL_SOURCE_CONTENTS	= 0x400,
	KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS	= 0x800
    } ;
typedef DWORD KF_REDIRECT_FLAGS;

/* [v1_enum] */ 
enum _KF_REDIRECTION_CAPABILITIES
    {	KF_REDIRECTION_CAPABILITIES_ALLOW_ALL	= 0xff,
	KF_REDIRECTION_CAPABILITIES_REDIRECTABLE	= 0x1,
	KF_REDIRECTION_CAPABILITIES_DENY_ALL	= 0xfff00,
	KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED	= 0x100,
	KF_REDIRECTION_CAPABILITIES_DENY_POLICY	= 0x200,
	KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS	= 0x400
    } ;
typedef DWORD KF_REDIRECTION_CAPABILITIES;

typedef struct KNOWNFOLDER_DEFINITION
    {
    KF_CATEGORY category;
    LPWSTR pszName;
    LPWSTR pszDescription;
    KNOWNFOLDERID fidParent;
    LPWSTR pszRelativePath;
    LPWSTR pszParsingName;
    LPWSTR pszTooltip;
    LPWSTR pszLocalizedName;
    LPWSTR pszIcon;
    LPWSTR pszSecurity;
    DWORD dwAttributes;
    KF_DEFINITION_FLAGS kfdFlags;
    FOLDERTYPEID ftidType;
    } 	KNOWNFOLDER_DEFINITION;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0145_v0_0_s_ifspec;

#ifndef __IKnownFolder_INTERFACE_DEFINED__
#define __IKnownFolder_INTERFACE_DEFINED__

/* interface IKnownFolder */
/* [ref][version][object][uuid] */ 


EXTERN_C const IID IID_IKnownFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3AA7AF7E-9B36-420c-A8E3-F77D4674A488")
    IKnownFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ __RPC__out KNOWNFOLDERID *pkfid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [out] */ __RPC__out KF_CATEGORY *pCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [in] */ DWORD dwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderType( 
            /* [out] */ __RPC__out FOLDERTYPEID *pftid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRedirectionCapabilities( 
            /* [out] */ __RPC__out KF_REDIRECTION_CAPABILITIES *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderDefinition( 
            /* [out] */ __RPC__out KNOWNFOLDER_DEFINITION *pKFD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKnownFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IKnownFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IKnownFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IKnownFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            __RPC__in IKnownFolder * This,
            /* [out] */ __RPC__out KNOWNFOLDERID *pkfid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            __RPC__in IKnownFolder * This,
            /* [out] */ __RPC__out KF_CATEGORY *pCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellItem )( 
            __RPC__in IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            __RPC__in IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszPath);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            __RPC__in IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            __RPC__in IKnownFolder * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderType )( 
            __RPC__in IKnownFolder * This,
            /* [out] */ __RPC__out FOLDERTYPEID *pftid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRedirectionCapabilities )( 
            __RPC__in IKnownFolder * This,
            /* [out] */ __RPC__out KF_REDIRECTION_CAPABILITIES *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderDefinition )( 
            __RPC__in IKnownFolder * This,
            /* [out] */ __RPC__out KNOWNFOLDER_DEFINITION *pKFD);
        
        END_INTERFACE
    } IKnownFolderVtbl;

    interface IKnownFolder
    {
        CONST_VTBL struct IKnownFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKnownFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKnownFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKnownFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKnownFolder_GetId(This,pkfid)	\
    ( (This)->lpVtbl -> GetId(This,pkfid) ) 

#define IKnownFolder_GetCategory(This,pCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pCategory) ) 

#define IKnownFolder_GetShellItem(This,dwFlags,riid,ppv)	\
    ( (This)->lpVtbl -> GetShellItem(This,dwFlags,riid,ppv) ) 

#define IKnownFolder_GetPath(This,dwFlags,ppszPath)	\
    ( (This)->lpVtbl -> GetPath(This,dwFlags,ppszPath) ) 

#define IKnownFolder_SetPath(This,dwFlags,pszPath)	\
    ( (This)->lpVtbl -> SetPath(This,dwFlags,pszPath) ) 

#define IKnownFolder_GetIDList(This,dwFlags,ppidl)	\
    ( (This)->lpVtbl -> GetIDList(This,dwFlags,ppidl) ) 

#define IKnownFolder_GetFolderType(This,pftid)	\
    ( (This)->lpVtbl -> GetFolderType(This,pftid) ) 

#define IKnownFolder_GetRedirectionCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetRedirectionCapabilities(This,pCapabilities) ) 

#define IKnownFolder_GetFolderDefinition(This,pKFD)	\
    ( (This)->lpVtbl -> GetFolderDefinition(This,pKFD) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKnownFolder_INTERFACE_DEFINED__ */


#ifndef __IKnownFolderManager_INTERFACE_DEFINED__
#define __IKnownFolderManager_INTERFACE_DEFINED__

/* interface IKnownFolderManager */
/* [ref][version][object][uuid] */ 

typedef /* [v1_enum] */ 
enum FFFP_MODE
    {	FFFP_EXACTMATCH	= 0,
	FFFP_NEARESTPARENTMATCH	= ( FFFP_EXACTMATCH + 1 ) 
    } 	FFFP_MODE;


EXTERN_C const IID IID_IKnownFolderManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8BE2D872-86AA-4d47-B776-32CCA40C7018")
    IKnownFolderManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FolderIdFromCsidl( 
            /* [in] */ int nCsidl,
            /* [out] */ __RPC__out KNOWNFOLDERID *pfid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FolderIdToCsidl( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__out int *pnCsidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderIds( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pCount) KNOWNFOLDERID **ppKFId,
            /* [out][in] */ __RPC__inout UINT *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderByName( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszCanonicalName,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [in] */ __RPC__in const KNOWNFOLDER_DEFINITION *pKFD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFolderFromPath( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath,
            /* [in] */ FFFP_MODE mode,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFolderFromIDList( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [annotation][in] */ 
            __in  REFKNOWNFOLDERID rfid,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  KF_REDIRECT_FLAGS flags,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszTargetPath,
            /* [annotation][in] */ 
            __in  UINT cFolders,
            /* [annotation][unique][size_is][in] */ 
            __in_ecount_opt(cFolders)  const KNOWNFOLDERID *pExclusion,
            /* [annotation][string][out] */ 
            __deref_opt_out_opt  LPWSTR *ppszError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKnownFolderManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IKnownFolderManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IKnownFolderManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *FolderIdFromCsidl )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ int nCsidl,
            /* [out] */ __RPC__out KNOWNFOLDERID *pfid);
        
        HRESULT ( STDMETHODCALLTYPE *FolderIdToCsidl )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__out int *pnCsidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderIds )( 
            __RPC__in IKnownFolderManager * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pCount) KNOWNFOLDERID **ppKFId,
            /* [out][in] */ __RPC__inout UINT *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderByName )( 
            __RPC__in IKnownFolderManager * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszCanonicalName,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFolder )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
            /* [in] */ __RPC__in const KNOWNFOLDER_DEFINITION *pKFD);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFolder )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID rfid);
        
        HRESULT ( STDMETHODCALLTYPE *FindFolderFromPath )( 
            __RPC__in IKnownFolderManager * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath,
            /* [in] */ FFFP_MODE mode,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        HRESULT ( STDMETHODCALLTYPE *FindFolderFromIDList )( 
            __RPC__in IKnownFolderManager * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
            /* [out] */ __RPC__deref_out_opt IKnownFolder **ppkf);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Redirect )( 
            IKnownFolderManager * This,
            /* [annotation][in] */ 
            __in  REFKNOWNFOLDERID rfid,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwnd,
            /* [annotation][in] */ 
            __in  KF_REDIRECT_FLAGS flags,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszTargetPath,
            /* [annotation][in] */ 
            __in  UINT cFolders,
            /* [annotation][unique][size_is][in] */ 
            __in_ecount_opt(cFolders)  const KNOWNFOLDERID *pExclusion,
            /* [annotation][string][out] */ 
            __deref_opt_out_opt  LPWSTR *ppszError);
        
        END_INTERFACE
    } IKnownFolderManagerVtbl;

    interface IKnownFolderManager
    {
        CONST_VTBL struct IKnownFolderManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKnownFolderManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKnownFolderManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKnownFolderManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKnownFolderManager_FolderIdFromCsidl(This,nCsidl,pfid)	\
    ( (This)->lpVtbl -> FolderIdFromCsidl(This,nCsidl,pfid) ) 

#define IKnownFolderManager_FolderIdToCsidl(This,rfid,pnCsidl)	\
    ( (This)->lpVtbl -> FolderIdToCsidl(This,rfid,pnCsidl) ) 

#define IKnownFolderManager_GetFolderIds(This,ppKFId,pCount)	\
    ( (This)->lpVtbl -> GetFolderIds(This,ppKFId,pCount) ) 

#define IKnownFolderManager_GetFolder(This,rfid,ppkf)	\
    ( (This)->lpVtbl -> GetFolder(This,rfid,ppkf) ) 

#define IKnownFolderManager_GetFolderByName(This,pszCanonicalName,ppkf)	\
    ( (This)->lpVtbl -> GetFolderByName(This,pszCanonicalName,ppkf) ) 

#define IKnownFolderManager_RegisterFolder(This,rfid,pKFD)	\
    ( (This)->lpVtbl -> RegisterFolder(This,rfid,pKFD) ) 

#define IKnownFolderManager_UnregisterFolder(This,rfid)	\
    ( (This)->lpVtbl -> UnregisterFolder(This,rfid) ) 

#define IKnownFolderManager_FindFolderFromPath(This,pszPath,mode,ppkf)	\
    ( (This)->lpVtbl -> FindFolderFromPath(This,pszPath,mode,ppkf) ) 

#define IKnownFolderManager_FindFolderFromIDList(This,pidl,ppkf)	\
    ( (This)->lpVtbl -> FindFolderFromIDList(This,pidl,ppkf) ) 

#define IKnownFolderManager_Redirect(This,rfid,hwnd,flags,pszTargetPath,cFolders,pExclusion,ppszError)	\
    ( (This)->lpVtbl -> Redirect(This,rfid,hwnd,flags,pszTargetPath,cFolders,pExclusion,ppszError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IKnownFolderManager_RemoteRedirect_Proxy( 
    __RPC__in IKnownFolderManager * This,
    /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
    /* [unique][in] */ __RPC__in_opt HWND hwnd,
    /* [in] */ KF_REDIRECT_FLAGS flags,
    /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTargetPath,
    /* [in] */ UINT cFolders,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cFolders) const GUID *pExclusion,
    /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszError);


void __RPC_STUB IKnownFolderManager_RemoteRedirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IKnownFolderManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0147 */
/* [local] */ 

__inline void FreeKnownFolderDefinitionFields(__in KNOWNFOLDER_DEFINITION *pKFD)
{
    CoTaskMemFree(pKFD->pszName);
    CoTaskMemFree(pKFD->pszDescription);
    CoTaskMemFree(pKFD->pszRelativePath);
    CoTaskMemFree(pKFD->pszParsingName);
    CoTaskMemFree(pKFD->pszTooltip);
    CoTaskMemFree(pKFD->pszLocalizedName);
    CoTaskMemFree(pKFD->pszIcon);
    CoTaskMemFree(pKFD->pszSecurity);
}
typedef /* [v1_enum] */ 
enum SHARE_ROLE
    {	SHARE_ROLE_INVALID	= -1,
	SHARE_ROLE_READER	= 0,
	SHARE_ROLE_CONTRIBUTOR	= 1,
	SHARE_ROLE_CO_OWNER	= 2,
	SHARE_ROLE_OWNER	= 3,
	SHARE_ROLE_CUSTOM	= 4,
	SHARE_ROLE_MIXED	= 5
    } 	SHARE_ROLE;

typedef /* [v1_enum] */ 
enum DEF_SHARE_ID
    {	DEFSHAREID_USERS	= 1,
	DEFSHAREID_PUBLIC	= 2
    } 	DEF_SHARE_ID;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0147_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0147_v0_0_s_ifspec;

#ifndef __ISharingConfigurationManager_INTERFACE_DEFINED__
#define __ISharingConfigurationManager_INTERFACE_DEFINED__

/* interface ISharingConfigurationManager */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISharingConfigurationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4CD448A-9C86-4466-9201-2E62105B87AE")
    ISharingConfigurationManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateShare( 
            /* [in] */ DEF_SHARE_ID dsid,
            /* [in] */ SHARE_ROLE role) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteShare( 
            /* [in] */ DEF_SHARE_ID dsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShareExists( 
            /* [in] */ DEF_SHARE_ID dsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSharePermissions( 
            /* [in] */ DEF_SHARE_ID dsid,
            /* [out] */ __RPC__out SHARE_ROLE *pRole) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SharePrinters( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopSharingPrinters( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArePrintersShared( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharingConfigurationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISharingConfigurationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISharingConfigurationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISharingConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateShare )( 
            __RPC__in ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid,
            /* [in] */ SHARE_ROLE role);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteShare )( 
            __RPC__in ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid);
        
        HRESULT ( STDMETHODCALLTYPE *ShareExists )( 
            __RPC__in ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharePermissions )( 
            __RPC__in ISharingConfigurationManager * This,
            /* [in] */ DEF_SHARE_ID dsid,
            /* [out] */ __RPC__out SHARE_ROLE *pRole);
        
        HRESULT ( STDMETHODCALLTYPE *SharePrinters )( 
            __RPC__in ISharingConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopSharingPrinters )( 
            __RPC__in ISharingConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ArePrintersShared )( 
            __RPC__in ISharingConfigurationManager * This);
        
        END_INTERFACE
    } ISharingConfigurationManagerVtbl;

    interface ISharingConfigurationManager
    {
        CONST_VTBL struct ISharingConfigurationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharingConfigurationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISharingConfigurationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISharingConfigurationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISharingConfigurationManager_CreateShare(This,dsid,role)	\
    ( (This)->lpVtbl -> CreateShare(This,dsid,role) ) 

#define ISharingConfigurationManager_DeleteShare(This,dsid)	\
    ( (This)->lpVtbl -> DeleteShare(This,dsid) ) 

#define ISharingConfigurationManager_ShareExists(This,dsid)	\
    ( (This)->lpVtbl -> ShareExists(This,dsid) ) 

#define ISharingConfigurationManager_GetSharePermissions(This,dsid,pRole)	\
    ( (This)->lpVtbl -> GetSharePermissions(This,dsid,pRole) ) 

#define ISharingConfigurationManager_SharePrinters(This)	\
    ( (This)->lpVtbl -> SharePrinters(This) ) 

#define ISharingConfigurationManager_StopSharingPrinters(This)	\
    ( (This)->lpVtbl -> StopSharingPrinters(This) ) 

#define ISharingConfigurationManager_ArePrintersShared(This)	\
    ( (This)->lpVtbl -> ArePrintersShared(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISharingConfigurationManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0148 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0148_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0148_v0_0_s_ifspec;

#ifndef __IPreviousVersionsInfo_INTERFACE_DEFINED__
#define __IPreviousVersionsInfo_INTERFACE_DEFINED__

/* interface IPreviousVersionsInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IPreviousVersionsInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76e54780-ad74-48e3-a695-3ba9a0aff10d")
    IPreviousVersionsInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AreSnapshotsAvailable( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszPath,
            /* [annotation][in] */ 
            __in  BOOL fOkToBeSlow,
            /* [annotation][out] */ 
            __out  BOOL *pfAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviousVersionsInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPreviousVersionsInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPreviousVersionsInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPreviousVersionsInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *AreSnapshotsAvailable )( 
            IPreviousVersionsInfo * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszPath,
            /* [annotation][in] */ 
            __in  BOOL fOkToBeSlow,
            /* [annotation][out] */ 
            __out  BOOL *pfAvailable);
        
        END_INTERFACE
    } IPreviousVersionsInfoVtbl;

    interface IPreviousVersionsInfo
    {
        CONST_VTBL struct IPreviousVersionsInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviousVersionsInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviousVersionsInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviousVersionsInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviousVersionsInfo_AreSnapshotsAvailable(This,pszPath,fOkToBeSlow,pfAvailable)	\
    ( (This)->lpVtbl -> AreSnapshotsAvailable(This,pszPath,fOkToBeSlow,pfAvailable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviousVersionsInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0149 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0149_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0149_v0_0_s_ifspec;

#ifndef __IRelatedItem_INTERFACE_DEFINED__
#define __IRelatedItem_INTERFACE_DEFINED__

/* interface IRelatedItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRelatedItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0")
    IRelatedItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemIDList( 
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRelatedItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRelatedItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRelatedItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRelatedItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IRelatedItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IRelatedItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IRelatedItemVtbl;

    interface IRelatedItem
    {
        CONST_VTBL struct IRelatedItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRelatedItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRelatedItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRelatedItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRelatedItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IRelatedItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRelatedItem_INTERFACE_DEFINED__ */


#ifndef __IIdentityName_INTERFACE_DEFINED__
#define __IIdentityName_INTERFACE_DEFINED__

/* interface IIdentityName */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IIdentityName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7d903fca-d6f9-4810-8332-946c0177e247")
    IIdentityName : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IIdentityNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IIdentityName * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IIdentityName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IIdentityName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IIdentityName * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IIdentityName * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IIdentityNameVtbl;

    interface IIdentityName
    {
        CONST_VTBL struct IIdentityNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdentityName_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIdentityName_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIdentityName_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIdentityName_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IIdentityName_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIdentityName_INTERFACE_DEFINED__ */


#ifndef __IDelegateItem_INTERFACE_DEFINED__
#define __IDelegateItem_INTERFACE_DEFINED__

/* interface IDelegateItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDelegateItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3c5a1c94-c951-4cb7-bb6d-3b93f30cce93")
    IDelegateItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDelegateItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDelegateItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDelegateItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDelegateItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IDelegateItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IDelegateItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IDelegateItemVtbl;

    interface IDelegateItem
    {
        CONST_VTBL struct IDelegateItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelegateItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelegateItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelegateItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelegateItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IDelegateItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelegateItem_INTERFACE_DEFINED__ */


#ifndef __ICurrentItem_INTERFACE_DEFINED__
#define __ICurrentItem_INTERFACE_DEFINED__

/* interface ICurrentItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICurrentItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("240a7174-d653-4a1d-a6d3-d4943cfbfe3d")
    ICurrentItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICurrentItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICurrentItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICurrentItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICurrentItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in ICurrentItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in ICurrentItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } ICurrentItemVtbl;

    interface ICurrentItem
    {
        CONST_VTBL struct ICurrentItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICurrentItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICurrentItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICurrentItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICurrentItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define ICurrentItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICurrentItem_INTERFACE_DEFINED__ */


#ifndef __ITransferMediumItem_INTERFACE_DEFINED__
#define __ITransferMediumItem_INTERFACE_DEFINED__

/* interface ITransferMediumItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransferMediumItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77f295d5-2d6f-4e19-b8ae-322f3e721ab5")
    ITransferMediumItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ITransferMediumItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransferMediumItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransferMediumItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransferMediumItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in ITransferMediumItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in ITransferMediumItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } ITransferMediumItemVtbl;

    interface ITransferMediumItem
    {
        CONST_VTBL struct ITransferMediumItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferMediumItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransferMediumItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransferMediumItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransferMediumItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define ITransferMediumItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransferMediumItem_INTERFACE_DEFINED__ */


#ifndef __IUseToBrowseItem_INTERFACE_DEFINED__
#define __IUseToBrowseItem_INTERFACE_DEFINED__

/* interface IUseToBrowseItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUseToBrowseItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05edda5c-98a3-4717-8adb-c5e7da991eb1")
    IUseToBrowseItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IUseToBrowseItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUseToBrowseItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUseToBrowseItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUseToBrowseItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IUseToBrowseItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IUseToBrowseItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IUseToBrowseItemVtbl;

    interface IUseToBrowseItem
    {
        CONST_VTBL struct IUseToBrowseItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUseToBrowseItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUseToBrowseItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUseToBrowseItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUseToBrowseItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IUseToBrowseItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUseToBrowseItem_INTERFACE_DEFINED__ */


#ifndef __IDisplayItem_INTERFACE_DEFINED__
#define __IDisplayItem_INTERFACE_DEFINED__

/* interface IDisplayItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDisplayItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6fd5997-9f6b-4888-8703-94e80e8cde3f")
    IDisplayItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDisplayItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDisplayItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDisplayItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDisplayItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IDisplayItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IDisplayItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IDisplayItemVtbl;

    interface IDisplayItem
    {
        CONST_VTBL struct IDisplayItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplayItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDisplayItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDisplayItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDisplayItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IDisplayItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDisplayItem_INTERFACE_DEFINED__ */


#ifndef __IViewStateIdentityItem_INTERFACE_DEFINED__
#define __IViewStateIdentityItem_INTERFACE_DEFINED__

/* interface IViewStateIdentityItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IViewStateIdentityItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9D264146-A94F-4195-9F9F-3BB12CE0C955")
    IViewStateIdentityItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IViewStateIdentityItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IViewStateIdentityItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IViewStateIdentityItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IViewStateIdentityItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IViewStateIdentityItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IViewStateIdentityItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IViewStateIdentityItemVtbl;

    interface IViewStateIdentityItem
    {
        CONST_VTBL struct IViewStateIdentityItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewStateIdentityItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IViewStateIdentityItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IViewStateIdentityItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IViewStateIdentityItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IViewStateIdentityItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IViewStateIdentityItem_INTERFACE_DEFINED__ */


#ifndef __IPreviewItem_INTERFACE_DEFINED__
#define __IPreviewItem_INTERFACE_DEFINED__

/* interface IPreviewItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPreviewItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36149969-0A8F-49c8-8B00-4AECB20222FB")
    IPreviewItem : public IRelatedItem
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPreviewItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPreviewItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPreviewItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPreviewItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemIDList )( 
            __RPC__in IPreviewItem * This,
            /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IPreviewItem * This,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsi);
        
        END_INTERFACE
    } IPreviewItemVtbl;

    interface IPreviewItem
    {
        CONST_VTBL struct IPreviewItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewItem_GetItemIDList(This,ppidl)	\
    ( (This)->lpVtbl -> GetItemIDList(This,ppidl) ) 

#define IPreviewItem_GetItem(This,ppsi)	\
    ( (This)->lpVtbl -> GetItem(This,ppsi) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0158 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0158_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0158_v0_0_s_ifspec;

#ifndef __IDestinationStreamFactory_INTERFACE_DEFINED__
#define __IDestinationStreamFactory_INTERFACE_DEFINED__

/* interface IDestinationStreamFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IDestinationStreamFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a87781b-39a7-4a1f-aab3-a39b9c34a7d9")
    IDestinationStreamFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDestinationStream( 
            /* [out] */ __RPC__deref_out_opt IStream **ppstm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDestinationStreamFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDestinationStreamFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDestinationStreamFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDestinationStreamFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationStream )( 
            __RPC__in IDestinationStreamFactory * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        END_INTERFACE
    } IDestinationStreamFactoryVtbl;

    interface IDestinationStreamFactory
    {
        CONST_VTBL struct IDestinationStreamFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDestinationStreamFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDestinationStreamFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDestinationStreamFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDestinationStreamFactory_GetDestinationStream(This,ppstm)	\
    ( (This)->lpVtbl -> GetDestinationStream(This,ppstm) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDestinationStreamFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0159 */
/* [local] */ 

/* [v1_enum] */ 
enum _NMCII_FLAGS
    {	NMCII_ITEMS	= 0x1,
	NMCII_FOLDERS	= 0x2
    } ;
typedef int NMCII_FLAGS;

/* [v1_enum] */ 
enum _NMCSAEI_FLAGS
    {	NMCSAEI_SELECT	= 0,
	NMCSAEI_EDIT	= 0x1
    } ;
typedef int NMCSAEI_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0159_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0159_v0_0_s_ifspec;

#ifndef __INewMenuClient_INTERFACE_DEFINED__
#define __INewMenuClient_INTERFACE_DEFINED__

/* interface INewMenuClient */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_INewMenuClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dcb07fdc-3bb5-451c-90be-966644fed7b0")
    INewMenuClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IncludeItems( 
            /* [out] */ __RPC__out NMCII_FLAGS *pflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndEditItem( 
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlItem,
            /* [in] */ NMCSAEI_FLAGS flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INewMenuClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INewMenuClient * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INewMenuClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INewMenuClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeItems )( 
            __RPC__in INewMenuClient * This,
            /* [out] */ __RPC__out NMCII_FLAGS *pflags);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndEditItem )( 
            __RPC__in INewMenuClient * This,
            /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidlItem,
            /* [in] */ NMCSAEI_FLAGS flags);
        
        END_INTERFACE
    } INewMenuClientVtbl;

    interface INewMenuClient
    {
        CONST_VTBL struct INewMenuClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INewMenuClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INewMenuClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INewMenuClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INewMenuClient_IncludeItems(This,pflags)	\
    ( (This)->lpVtbl -> IncludeItems(This,pflags) ) 

#define INewMenuClient_SelectAndEditItem(This,pidlItem,flags)	\
    ( (This)->lpVtbl -> SelectAndEditItem(This,pidlItem,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INewMenuClient_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0160 */
/* [local] */ 

#define SID_SNewMenuClient   IID_INewMenuClient
DEFINE_GUID(SID_SCommandBarState, 0xB99EAA5C, 0x3850, 0x4400, 0xBC, 0x33, 0x2C, 0xE5, 0x34, 0x04, 0x8B, 0xF8);
#if (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0160_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0160_v0_0_s_ifspec;

#ifndef __IInitializeWithBindCtx_INTERFACE_DEFINED__
#define __IInitializeWithBindCtx_INTERFACE_DEFINED__

/* interface IInitializeWithBindCtx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInitializeWithBindCtx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71c0d2bc-726d-45cc-a6c0-2e31c1db2159")
    IInitializeWithBindCtx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IBindCtx *pbc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithBindCtxVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeWithBindCtx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeWithBindCtx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeWithBindCtx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IInitializeWithBindCtx * This,
            /* [in] */ __RPC__in_opt IBindCtx *pbc);
        
        END_INTERFACE
    } IInitializeWithBindCtxVtbl;

    interface IInitializeWithBindCtx
    {
        CONST_VTBL struct IInitializeWithBindCtxVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithBindCtx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithBindCtx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithBindCtx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithBindCtx_Initialize(This,pbc)	\
    ( (This)->lpVtbl -> Initialize(This,pbc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithBindCtx_INTERFACE_DEFINED__ */


#ifndef __IShellItemFilter_INTERFACE_DEFINED__
#define __IShellItemFilter_INTERFACE_DEFINED__

/* interface IShellItemFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IShellItemFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2659B475-EEB8-48b7-8F07-B378810F48CF")
    IShellItemFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IncludeItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumFlagsForItem( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out SHCONTF *pgrfFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellItemFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellItemFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellItemFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *IncludeItem )( 
            __RPC__in IShellItemFilter * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumFlagsForItem )( 
            __RPC__in IShellItemFilter * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out SHCONTF *pgrfFlags);
        
        END_INTERFACE
    } IShellItemFilterVtbl;

    interface IShellItemFilter
    {
        CONST_VTBL struct IShellItemFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellItemFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellItemFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellItemFilter_IncludeItem(This,psi)	\
    ( (This)->lpVtbl -> IncludeItem(This,psi) ) 

#define IShellItemFilter_GetEnumFlagsForItem(This,psi,pgrfFlags)	\
    ( (This)->lpVtbl -> GetEnumFlagsForItem(This,psi,pgrfFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellItemFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0162 */
/* [local] */ 

#endif  // (_WIN32_IE >= _WIN32_IE_IE70)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0162_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0162_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControl_INTERFACE_DEFINED__
#define __INameSpaceTreeControl_INTERFACE_DEFINED__

/* interface INameSpaceTreeControl */
/* [uuid][object] */ 

/* [v1_enum] */ 
enum _NSTCSTYLE
    {	NSTCS_HASEXPANDOS	= 0x1,
	NSTCS_HASLINES	= 0x2,
	NSTCS_SINGLECLICKEXPAND	= 0x4,
	NSTCS_FULLROWSELECT	= 0x8,
	NSTCS_SPRINGEXPAND	= 0x10,
	NSTCS_HORIZONTALSCROLL	= 0x20,
	NSTCS_ROOTHASEXPANDO	= 0x40,
	NSTCS_SHOWSELECTIONALWAYS	= 0x80,
	NSTCS_NOINFOTIP	= 0x200,
	NSTCS_EVENHEIGHT	= 0x400,
	NSTCS_NOREPLACEOPEN	= 0x800,
	NSTCS_DISABLEDRAGDROP	= 0x1000,
	NSTCS_NOORDERSTREAM	= 0x2000,
	NSTCS_RICHTOOLTIP	= 0x4000,
	NSTCS_BORDER	= 0x8000,
	NSTCS_NOEDITLABELS	= 0x10000,
	NSTCS_TABSTOP	= 0x20000,
	NSTCS_FAVORITESMODE	= 0x80000,
	NSTCS_AUTOHSCROLL	= 0x100000,
	NSTCS_FADEINOUTEXPANDOS	= 0x200000,
	NSTCS_EMPTYTEXT	= 0x400000,
	NSTCS_CHECKBOXES	= 0x800000,
	NSTCS_PARTIALCHECKBOXES	= 0x1000000,
	NSTCS_EXCLUSIONCHECKBOXES	= 0x2000000,
	NSTCS_DIMMEDCHECKBOXES	= 0x4000000,
	NSTCS_NOINDENTCHECKS	= 0x8000000,
	NSTCS_ALLOWJUNCTIONS	= 0x10000000,
	NSTCS_SHOWTABSBUTTON	= 0x20000000,
	NSTCS_SHOWDELETEBUTTON	= 0x40000000,
	NSTCS_SHOWREFRESHBUTTON	= ( int  )0x80000000
    } ;
typedef DWORD NSTCSTYLE;

/* [v1_enum] */ 
enum _NSTCROOTSTYLE
    {	NSTCRS_VISIBLE	= 0,
	NSTCRS_HIDDEN	= 0x1,
	NSTCRS_EXPANDED	= 0x2
    } ;
typedef DWORD NSTCROOTSTYLE;

/* [v1_enum] */ 
enum _NSTCITEMSTATE
    {	NSTCIS_NONE	= 0,
	NSTCIS_SELECTED	= 0x1,
	NSTCIS_EXPANDED	= 0x2,
	NSTCIS_BOLD	= 0x4,
	NSTCIS_DISABLED	= 0x8,
	NSTCIS_SELECTEDNOEXPAND	= 0x10
    } ;
typedef DWORD NSTCITEMSTATE;

typedef /* [v1_enum] */ 
enum NSTCGNI
    {	NSTCGNI_NEXT	= 0,
	NSTCGNI_NEXTVISIBLE	= 1,
	NSTCGNI_PREV	= 2,
	NSTCGNI_PREVVISIBLE	= 3,
	NSTCGNI_PARENT	= 4,
	NSTCGNI_CHILD	= 5,
	NSTCGNI_FIRSTVISIBLE	= 6,
	NSTCGNI_LASTVISIBLE	= 7
    } 	NSTCGNI;


EXTERN_C const IID IID_INameSpaceTreeControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("028212A3-B627-47e9-8856-C14265554E4F")
    INameSpaceTreeControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [unique][in] */ __RPC__in_opt RECT *prc,
            /* [in] */ NSTCSTYLE nsctsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TreeAdvise( 
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TreeUnadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendRoot( 
            /* [in] */ __RPC__in_opt IShellItem *psiRoot,
            /* [in] */ SHCONTF grfEnumFlags,
            /* [in] */ NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ __RPC__in_opt IShellItemFilter *pif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertRoot( 
            /* [in] */ int iIndex,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot,
            /* [in] */ SHCONTF grfEnumFlags,
            /* [in] */ NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ __RPC__in_opt IShellItemFilter *pif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRoot( 
            /* [in] */ __RPC__in_opt IShellItem *psiRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllRoots( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootItems( 
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsiaRootItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemState( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCITEMSTATE nstcisMask,
            /* [in] */ NSTCITEMSTATE nstcisFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemState( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCITEMSTATE nstcisMask,
            /* [out] */ __RPC__out NSTCITEMSTATE *pnstcisFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItems( 
            /* [out] */ __RPC__deref_out_opt IShellItemArray **psiaItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemCustomState( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out int *piStateNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemCustomState( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int iStateNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureItemVisible( 
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTheme( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszTheme) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [unique][in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCGNI nstcgi,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ __RPC__in POINT *ppt,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemRect( 
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out RECT *prect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CollapseAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INameSpaceTreeControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INameSpaceTreeControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [unique][in] */ __RPC__in_opt RECT *prc,
            /* [in] */ NSTCSTYLE nsctsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *TreeAdvise )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *TreeUnadvise )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AppendRoot )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot,
            /* [in] */ SHCONTF grfEnumFlags,
            /* [in] */ NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ __RPC__in_opt IShellItemFilter *pif);
        
        HRESULT ( STDMETHODCALLTYPE *InsertRoot )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ int iIndex,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot,
            /* [in] */ SHCONTF grfEnumFlags,
            /* [in] */ NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ __RPC__in_opt IShellItemFilter *pif);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRoot )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllRoots )( 
            __RPC__in INameSpaceTreeControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootItems )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsiaRootItems);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemState )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCITEMSTATE nstcisMask,
            /* [in] */ NSTCITEMSTATE nstcisFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemState )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCITEMSTATE nstcisMask,
            /* [out] */ __RPC__out NSTCITEMSTATE *pnstcisFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItems )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **psiaItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemCustomState )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out int *piStateNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemCustomState )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int iStateNumber);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureItemVisible )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetTheme )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszTheme);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextItem )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [unique][in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCGNI nstcgi,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiNext);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in POINT *ppt,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemRect )( 
            __RPC__in INameSpaceTreeControl * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out RECT *prect);
        
        HRESULT ( STDMETHODCALLTYPE *CollapseAll )( 
            __RPC__in INameSpaceTreeControl * This);
        
        END_INTERFACE
    } INameSpaceTreeControlVtbl;

    interface INameSpaceTreeControl
    {
        CONST_VTBL struct INameSpaceTreeControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControl_Initialize(This,hwndParent,prc,nsctsFlags)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,prc,nsctsFlags) ) 

#define INameSpaceTreeControl_TreeAdvise(This,punk,pdwCookie)	\
    ( (This)->lpVtbl -> TreeAdvise(This,punk,pdwCookie) ) 

#define INameSpaceTreeControl_TreeUnadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> TreeUnadvise(This,dwCookie) ) 

#define INameSpaceTreeControl_AppendRoot(This,psiRoot,grfEnumFlags,grfRootStyle,pif)	\
    ( (This)->lpVtbl -> AppendRoot(This,psiRoot,grfEnumFlags,grfRootStyle,pif) ) 

#define INameSpaceTreeControl_InsertRoot(This,iIndex,psiRoot,grfEnumFlags,grfRootStyle,pif)	\
    ( (This)->lpVtbl -> InsertRoot(This,iIndex,psiRoot,grfEnumFlags,grfRootStyle,pif) ) 

#define INameSpaceTreeControl_RemoveRoot(This,psiRoot)	\
    ( (This)->lpVtbl -> RemoveRoot(This,psiRoot) ) 

#define INameSpaceTreeControl_RemoveAllRoots(This)	\
    ( (This)->lpVtbl -> RemoveAllRoots(This) ) 

#define INameSpaceTreeControl_GetRootItems(This,ppsiaRootItems)	\
    ( (This)->lpVtbl -> GetRootItems(This,ppsiaRootItems) ) 

#define INameSpaceTreeControl_SetItemState(This,psi,nstcisMask,nstcisFlags)	\
    ( (This)->lpVtbl -> SetItemState(This,psi,nstcisMask,nstcisFlags) ) 

#define INameSpaceTreeControl_GetItemState(This,psi,nstcisMask,pnstcisFlags)	\
    ( (This)->lpVtbl -> GetItemState(This,psi,nstcisMask,pnstcisFlags) ) 

#define INameSpaceTreeControl_GetSelectedItems(This,psiaItems)	\
    ( (This)->lpVtbl -> GetSelectedItems(This,psiaItems) ) 

#define INameSpaceTreeControl_GetItemCustomState(This,psi,piStateNumber)	\
    ( (This)->lpVtbl -> GetItemCustomState(This,psi,piStateNumber) ) 

#define INameSpaceTreeControl_SetItemCustomState(This,psi,iStateNumber)	\
    ( (This)->lpVtbl -> SetItemCustomState(This,psi,iStateNumber) ) 

#define INameSpaceTreeControl_EnsureItemVisible(This,psi)	\
    ( (This)->lpVtbl -> EnsureItemVisible(This,psi) ) 

#define INameSpaceTreeControl_SetTheme(This,pszTheme)	\
    ( (This)->lpVtbl -> SetTheme(This,pszTheme) ) 

#define INameSpaceTreeControl_GetNextItem(This,psi,nstcgi,ppsiNext)	\
    ( (This)->lpVtbl -> GetNextItem(This,psi,nstcgi,ppsiNext) ) 

#define INameSpaceTreeControl_HitTest(This,ppt,ppsiOut)	\
    ( (This)->lpVtbl -> HitTest(This,ppt,ppsiOut) ) 

#define INameSpaceTreeControl_GetItemRect(This,psi,prect)	\
    ( (This)->lpVtbl -> GetItemRect(This,psi,prect) ) 

#define INameSpaceTreeControl_CollapseAll(This)	\
    ( (This)->lpVtbl -> CollapseAll(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControl_INTERFACE_DEFINED__ */


#ifndef __INameSpaceTreeControl2_INTERFACE_DEFINED__
#define __INameSpaceTreeControl2_INTERFACE_DEFINED__

/* interface INameSpaceTreeControl2 */
/* [uuid][object] */ 

typedef /* [v1_enum] */ 
enum NSTCSTYLE2
    {	NSTCS2_DEFAULT	= 0,
	NSTCS2_INTERRUPTNOTIFICATIONS	= 0x1,
	NSTCS2_SHOWNULLSPACEMENU	= 0x2,
	NSTCS2_DISPLAYPADDING	= 0x4,
	NSTCS2_DISPLAYPINNEDONLY	= 0x8,
	NTSCS2_NOSINGLETONAUTOEXPAND	= 0x10,
	NTSCS2_NEVERINSERTNONENUMERATED	= 0x20
    } 	NSTCSTYLE2;

DEFINE_ENUM_FLAG_OPERATORS(NSTCSTYLE2)

EXTERN_C const IID IID_INameSpaceTreeControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7cc7aed8-290e-49bc-8945-c1401cc9306c")
    INameSpaceTreeControl2 : public INameSpaceTreeControl
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetControlStyle( 
            /* [in] */ NSTCSTYLE nstcsMask,
            /* [in] */ NSTCSTYLE nstcsStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlStyle( 
            /* [in] */ NSTCSTYLE nstcsMask,
            /* [out] */ __RPC__out NSTCSTYLE *pnstcsStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlStyle2( 
            /* [in] */ NSTCSTYLE2 nstcsMask,
            /* [in] */ NSTCSTYLE2 nstcsStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlStyle2( 
            /* [in] */ NSTCSTYLE2 nstcsMask,
            /* [out] */ __RPC__out NSTCSTYLE2 *pnstcsStyle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INameSpaceTreeControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INameSpaceTreeControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [unique][in] */ __RPC__in_opt RECT *prc,
            /* [in] */ NSTCSTYLE nsctsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *TreeAdvise )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IUnknown *punk,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *TreeUnadvise )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AppendRoot )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot,
            /* [in] */ SHCONTF grfEnumFlags,
            /* [in] */ NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ __RPC__in_opt IShellItemFilter *pif);
        
        HRESULT ( STDMETHODCALLTYPE *InsertRoot )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ int iIndex,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot,
            /* [in] */ SHCONTF grfEnumFlags,
            /* [in] */ NSTCROOTSTYLE grfRootStyle,
            /* [unique][in] */ __RPC__in_opt IShellItemFilter *pif);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRoot )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psiRoot);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllRoots )( 
            __RPC__in INameSpaceTreeControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootItems )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **ppsiaRootItems);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemState )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCITEMSTATE nstcisMask,
            /* [in] */ NSTCITEMSTATE nstcisFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemState )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCITEMSTATE nstcisMask,
            /* [out] */ __RPC__out NSTCITEMSTATE *pnstcisFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItems )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [out] */ __RPC__deref_out_opt IShellItemArray **psiaItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemCustomState )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out int *piStateNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemCustomState )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ int iStateNumber);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureItemVisible )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *SetTheme )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszTheme);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextItem )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [unique][in] */ __RPC__in_opt IShellItem *psi,
            /* [in] */ NSTCGNI nstcgi,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiNext);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in POINT *ppt,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemRect )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ __RPC__in_opt IShellItem *psi,
            /* [out] */ __RPC__out RECT *prect);
        
        HRESULT ( STDMETHODCALLTYPE *CollapseAll )( 
            __RPC__in INameSpaceTreeControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlStyle )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ NSTCSTYLE nstcsMask,
            /* [in] */ NSTCSTYLE nstcsStyle);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlStyle )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ NSTCSTYLE nstcsMask,
            /* [out] */ __RPC__out NSTCSTYLE *pnstcsStyle);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlStyle2 )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ NSTCSTYLE2 nstcsMask,
            /* [in] */ NSTCSTYLE2 nstcsStyle);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlStyle2 )( 
            __RPC__in INameSpaceTreeControl2 * This,
            /* [in] */ NSTCSTYLE2 nstcsMask,
            /* [out] */ __RPC__out NSTCSTYLE2 *pnstcsStyle);
        
        END_INTERFACE
    } INameSpaceTreeControl2Vtbl;

    interface INameSpaceTreeControl2
    {
        CONST_VTBL struct INameSpaceTreeControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControl2_Initialize(This,hwndParent,prc,nsctsFlags)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent,prc,nsctsFlags) ) 

#define INameSpaceTreeControl2_TreeAdvise(This,punk,pdwCookie)	\
    ( (This)->lpVtbl -> TreeAdvise(This,punk,pdwCookie) ) 

#define INameSpaceTreeControl2_TreeUnadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> TreeUnadvise(This,dwCookie) ) 

#define INameSpaceTreeControl2_AppendRoot(This,psiRoot,grfEnumFlags,grfRootStyle,pif)	\
    ( (This)->lpVtbl -> AppendRoot(This,psiRoot,grfEnumFlags,grfRootStyle,pif) ) 

#define INameSpaceTreeControl2_InsertRoot(This,iIndex,psiRoot,grfEnumFlags,grfRootStyle,pif)	\
    ( (This)->lpVtbl -> InsertRoot(This,iIndex,psiRoot,grfEnumFlags,grfRootStyle,pif) ) 

#define INameSpaceTreeControl2_RemoveRoot(This,psiRoot)	\
    ( (This)->lpVtbl -> RemoveRoot(This,psiRoot) ) 

#define INameSpaceTreeControl2_RemoveAllRoots(This)	\
    ( (This)->lpVtbl -> RemoveAllRoots(This) ) 

#define INameSpaceTreeControl2_GetRootItems(This,ppsiaRootItems)	\
    ( (This)->lpVtbl -> GetRootItems(This,ppsiaRootItems) ) 

#define INameSpaceTreeControl2_SetItemState(This,psi,nstcisMask,nstcisFlags)	\
    ( (This)->lpVtbl -> SetItemState(This,psi,nstcisMask,nstcisFlags) ) 

#define INameSpaceTreeControl2_GetItemState(This,psi,nstcisMask,pnstcisFlags)	\
    ( (This)->lpVtbl -> GetItemState(This,psi,nstcisMask,pnstcisFlags) ) 

#define INameSpaceTreeControl2_GetSelectedItems(This,psiaItems)	\
    ( (This)->lpVtbl -> GetSelectedItems(This,psiaItems) ) 

#define INameSpaceTreeControl2_GetItemCustomState(This,psi,piStateNumber)	\
    ( (This)->lpVtbl -> GetItemCustomState(This,psi,piStateNumber) ) 

#define INameSpaceTreeControl2_SetItemCustomState(This,psi,iStateNumber)	\
    ( (This)->lpVtbl -> SetItemCustomState(This,psi,iStateNumber) ) 

#define INameSpaceTreeControl2_EnsureItemVisible(This,psi)	\
    ( (This)->lpVtbl -> EnsureItemVisible(This,psi) ) 

#define INameSpaceTreeControl2_SetTheme(This,pszTheme)	\
    ( (This)->lpVtbl -> SetTheme(This,pszTheme) ) 

#define INameSpaceTreeControl2_GetNextItem(This,psi,nstcgi,ppsiNext)	\
    ( (This)->lpVtbl -> GetNextItem(This,psi,nstcgi,ppsiNext) ) 

#define INameSpaceTreeControl2_HitTest(This,ppt,ppsiOut)	\
    ( (This)->lpVtbl -> HitTest(This,ppt,ppsiOut) ) 

#define INameSpaceTreeControl2_GetItemRect(This,psi,prect)	\
    ( (This)->lpVtbl -> GetItemRect(This,psi,prect) ) 

#define INameSpaceTreeControl2_CollapseAll(This)	\
    ( (This)->lpVtbl -> CollapseAll(This) ) 


#define INameSpaceTreeControl2_SetControlStyle(This,nstcsMask,nstcsStyle)	\
    ( (This)->lpVtbl -> SetControlStyle(This,nstcsMask,nstcsStyle) ) 

#define INameSpaceTreeControl2_GetControlStyle(This,nstcsMask,pnstcsStyle)	\
    ( (This)->lpVtbl -> GetControlStyle(This,nstcsMask,pnstcsStyle) ) 

#define INameSpaceTreeControl2_SetControlStyle2(This,nstcsMask,nstcsStyle)	\
    ( (This)->lpVtbl -> SetControlStyle2(This,nstcsMask,nstcsStyle) ) 

#define INameSpaceTreeControl2_GetControlStyle2(This,nstcsMask,pnstcsStyle)	\
    ( (This)->lpVtbl -> GetControlStyle2(This,nstcsMask,pnstcsStyle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControl2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0164 */
/* [local] */ 

#define NSTCS2_ALLMASK (NSTCS2_INTERRUPTNOTIFICATIONS | NSTCS2_SHOWNULLSPACEMENU | NSTCS2_DISPLAYPADDING)
#define SID_SNavigationPane IID_INameSpaceTreeControl   // nearest service that you can proffer to
#define ISLBUTTON(x) (NSTCECT_LBUTTON == ((x) & NSTCECT_BUTTON))
#define ISMBUTTON(x) (NSTCECT_MBUTTON == ((x) & NSTCECT_BUTTON))
#define ISRBUTTON(x) (NSTCECT_RBUTTON == ((x) & NSTCECT_BUTTON))
#define ISDBLCLICK(x) (NSTCECT_DBLCLICK == ((x) & NSTCECT_DBLCLICK))


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0164_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControlEvents_INTERFACE_DEFINED__
#define __INameSpaceTreeControlEvents_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlEvents */
/* [local][uuid][object] */ 

/* [v1_enum] */ 
enum _NSTCEHITTEST
    {	NSTCEHT_NOWHERE	= 0x1,
	NSTCEHT_ONITEMICON	= 0x2,
	NSTCEHT_ONITEMLABEL	= 0x4,
	NSTCEHT_ONITEMINDENT	= 0x8,
	NSTCEHT_ONITEMBUTTON	= 0x10,
	NSTCEHT_ONITEMRIGHT	= 0x20,
	NSTCEHT_ONITEMSTATEICON	= 0x40,
	NSTCEHT_ONITEM	= 0x46,
	NSTCEHT_ONITEMTABBUTTON	= 0x1000
    } ;
typedef DWORD NSTCEHITTEST;

/* [v1_enum] */ 
enum _NSTCECLICKTYPE
    {	NSTCECT_LBUTTON	= 0x1,
	NSTCECT_MBUTTON	= 0x2,
	NSTCECT_RBUTTON	= 0x3,
	NSTCECT_BUTTON	= 0x3,
	NSTCECT_DBLCLICK	= 0x4
    } ;
typedef DWORD NSTCECLICKTYPE;


EXTERN_C const IID IID_INameSpaceTreeControlEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93D77985-B3D8-4484-8318-672CDDA002CE")
    INameSpaceTreeControlEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnItemClick( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  NSTCEHITTEST nstceHitTest,
            /* [annotation][in] */ 
            __in  NSTCECLICKTYPE nstceClickType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPropertyItemCommit( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemStateChanging( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemStateChanged( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChanged( 
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyboardInput( 
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeExpand( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAfterExpand( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeginLabelEdit( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndLabelEdit( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetToolTip( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][size_is][string][out] */ 
            __out_ecount(cchTip)  LPWSTR pszTip,
            /* [annotation][in] */ 
            __in  int cchTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeItemDelete( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemAdded( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  BOOL fIsRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemDeleted( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  BOOL fIsRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeContextMenu( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psi,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAfterContextMenu( 
            /* [annotation][in] */ 
            __in_opt  IShellItem *psi,
            /* [annotation][in] */ 
            __in  IContextMenu *pcmIn,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeforeStateImageChange( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetDefaultIconIndex( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][out] */ 
            __out  int *piDefaultIcon,
            /* [annotation][out] */ 
            __out  int *piOpenIcon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlEvents * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemClick )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  NSTCEHITTEST nstceHitTest,
            /* [annotation][in] */ 
            __in  NSTCECLICKTYPE nstceClickType);
        
        HRESULT ( STDMETHODCALLTYPE *OnPropertyItemCommit )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemStateChanging )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisState);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemStateChanged )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisMask,
            /* [annotation][in] */ 
            __in  NSTCITEMSTATE nstcisState);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChanged )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaSelection);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyboardInput )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeExpand )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnAfterExpand )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeginLabelEdit )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndLabelEdit )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetToolTip )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][size_is][string][out] */ 
            __out_ecount(cchTip)  LPWSTR pszTip,
            /* [annotation][in] */ 
            __in  int cchTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeItemDelete )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemAdded )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  BOOL fIsRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemDeleted )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][in] */ 
            __in  BOOL fIsRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeContextMenu )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psi,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *OnAfterContextMenu )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in_opt  IShellItem *psi,
            /* [annotation][in] */ 
            __in  IContextMenu *pcmIn,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *OnBeforeStateImageChange )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDefaultIconIndex )( 
            INameSpaceTreeControlEvents * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][out] */ 
            __out  int *piDefaultIcon,
            /* [annotation][out] */ 
            __out  int *piOpenIcon);
        
        END_INTERFACE
    } INameSpaceTreeControlEventsVtbl;

    interface INameSpaceTreeControlEvents
    {
        CONST_VTBL struct INameSpaceTreeControlEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlEvents_OnItemClick(This,psi,nstceHitTest,nstceClickType)	\
    ( (This)->lpVtbl -> OnItemClick(This,psi,nstceHitTest,nstceClickType) ) 

#define INameSpaceTreeControlEvents_OnPropertyItemCommit(This,psi)	\
    ( (This)->lpVtbl -> OnPropertyItemCommit(This,psi) ) 

#define INameSpaceTreeControlEvents_OnItemStateChanging(This,psi,nstcisMask,nstcisState)	\
    ( (This)->lpVtbl -> OnItemStateChanging(This,psi,nstcisMask,nstcisState) ) 

#define INameSpaceTreeControlEvents_OnItemStateChanged(This,psi,nstcisMask,nstcisState)	\
    ( (This)->lpVtbl -> OnItemStateChanged(This,psi,nstcisMask,nstcisState) ) 

#define INameSpaceTreeControlEvents_OnSelectionChanged(This,psiaSelection)	\
    ( (This)->lpVtbl -> OnSelectionChanged(This,psiaSelection) ) 

#define INameSpaceTreeControlEvents_OnKeyboardInput(This,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> OnKeyboardInput(This,uMsg,wParam,lParam) ) 

#define INameSpaceTreeControlEvents_OnBeforeExpand(This,psi)	\
    ( (This)->lpVtbl -> OnBeforeExpand(This,psi) ) 

#define INameSpaceTreeControlEvents_OnAfterExpand(This,psi)	\
    ( (This)->lpVtbl -> OnAfterExpand(This,psi) ) 

#define INameSpaceTreeControlEvents_OnBeginLabelEdit(This,psi)	\
    ( (This)->lpVtbl -> OnBeginLabelEdit(This,psi) ) 

#define INameSpaceTreeControlEvents_OnEndLabelEdit(This,psi)	\
    ( (This)->lpVtbl -> OnEndLabelEdit(This,psi) ) 

#define INameSpaceTreeControlEvents_OnGetToolTip(This,psi,pszTip,cchTip)	\
    ( (This)->lpVtbl -> OnGetToolTip(This,psi,pszTip,cchTip) ) 

#define INameSpaceTreeControlEvents_OnBeforeItemDelete(This,psi)	\
    ( (This)->lpVtbl -> OnBeforeItemDelete(This,psi) ) 

#define INameSpaceTreeControlEvents_OnItemAdded(This,psi,fIsRoot)	\
    ( (This)->lpVtbl -> OnItemAdded(This,psi,fIsRoot) ) 

#define INameSpaceTreeControlEvents_OnItemDeleted(This,psi,fIsRoot)	\
    ( (This)->lpVtbl -> OnItemDeleted(This,psi,fIsRoot) ) 

#define INameSpaceTreeControlEvents_OnBeforeContextMenu(This,psi,riid,ppv)	\
    ( (This)->lpVtbl -> OnBeforeContextMenu(This,psi,riid,ppv) ) 

#define INameSpaceTreeControlEvents_OnAfterContextMenu(This,psi,pcmIn,riid,ppv)	\
    ( (This)->lpVtbl -> OnAfterContextMenu(This,psi,pcmIn,riid,ppv) ) 

#define INameSpaceTreeControlEvents_OnBeforeStateImageChange(This,psi)	\
    ( (This)->lpVtbl -> OnBeforeStateImageChange(This,psi) ) 

#define INameSpaceTreeControlEvents_OnGetDefaultIconIndex(This,psi,piDefaultIcon,piOpenIcon)	\
    ( (This)->lpVtbl -> OnGetDefaultIconIndex(This,psi,piDefaultIcon,piOpenIcon) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0165 */
/* [local] */ 

#define NSTCDHPOS_ONTOP  -1


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0165_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0165_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControlDropHandler_INTERFACE_DEFINED__
#define __INameSpaceTreeControlDropHandler_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlDropHandler */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_INameSpaceTreeControlDropHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9C665D6-C2F2-4c19-BF33-8322D7352F51")
    INameSpaceTreeControlDropHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDragEnter( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  BOOL fOutsideSource,
            /* [annotation][in] */ 
            __in  DWORD grfKeyState,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDragOver( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  DWORD grfKeyState,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDragPosition( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  int iNewPosition,
            /* [annotation][in] */ 
            __in  int iOldPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDrop( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  int iPosition,
            /* [annotation][in] */ 
            __in  DWORD grfKeyState,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDropPosition( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  int iNewPosition,
            /* [annotation][in] */ 
            __in  int iOldPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDragLeave( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlDropHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlDropHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlDropHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlDropHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragEnter )( 
            INameSpaceTreeControlDropHandler * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  BOOL fOutsideSource,
            /* [annotation][in] */ 
            __in  DWORD grfKeyState,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragOver )( 
            INameSpaceTreeControlDropHandler * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  DWORD grfKeyState,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragPosition )( 
            INameSpaceTreeControlDropHandler * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  int iNewPosition,
            /* [annotation][in] */ 
            __in  int iOldPosition);
        
        HRESULT ( STDMETHODCALLTYPE *OnDrop )( 
            INameSpaceTreeControlDropHandler * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  int iPosition,
            /* [annotation][in] */ 
            __in  DWORD grfKeyState,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDropPosition )( 
            INameSpaceTreeControlDropHandler * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver,
            /* [annotation][in] */ 
            __in  IShellItemArray *psiaData,
            /* [annotation][in] */ 
            __in  int iNewPosition,
            /* [annotation][in] */ 
            __in  int iOldPosition);
        
        HRESULT ( STDMETHODCALLTYPE *OnDragLeave )( 
            INameSpaceTreeControlDropHandler * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellItem *psiOver);
        
        END_INTERFACE
    } INameSpaceTreeControlDropHandlerVtbl;

    interface INameSpaceTreeControlDropHandler
    {
        CONST_VTBL struct INameSpaceTreeControlDropHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlDropHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlDropHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlDropHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlDropHandler_OnDragEnter(This,psiOver,psiaData,fOutsideSource,grfKeyState,pdwEffect)	\
    ( (This)->lpVtbl -> OnDragEnter(This,psiOver,psiaData,fOutsideSource,grfKeyState,pdwEffect) ) 

#define INameSpaceTreeControlDropHandler_OnDragOver(This,psiOver,psiaData,grfKeyState,pdwEffect)	\
    ( (This)->lpVtbl -> OnDragOver(This,psiOver,psiaData,grfKeyState,pdwEffect) ) 

#define INameSpaceTreeControlDropHandler_OnDragPosition(This,psiOver,psiaData,iNewPosition,iOldPosition)	\
    ( (This)->lpVtbl -> OnDragPosition(This,psiOver,psiaData,iNewPosition,iOldPosition) ) 

#define INameSpaceTreeControlDropHandler_OnDrop(This,psiOver,psiaData,iPosition,grfKeyState,pdwEffect)	\
    ( (This)->lpVtbl -> OnDrop(This,psiOver,psiaData,iPosition,grfKeyState,pdwEffect) ) 

#define INameSpaceTreeControlDropHandler_OnDropPosition(This,psiOver,psiaData,iNewPosition,iOldPosition)	\
    ( (This)->lpVtbl -> OnDropPosition(This,psiOver,psiaData,iNewPosition,iOldPosition) ) 

#define INameSpaceTreeControlDropHandler_OnDragLeave(This,psiOver)	\
    ( (This)->lpVtbl -> OnDragLeave(This,psiOver) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlDropHandler_INTERFACE_DEFINED__ */


#ifndef __INameSpaceTreeAccessible_INTERFACE_DEFINED__
#define __INameSpaceTreeAccessible_INTERFACE_DEFINED__

/* interface INameSpaceTreeAccessible */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_INameSpaceTreeAccessible;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71f312de-43ed-4190-8477-e9536b82350b")
    INameSpaceTreeAccessible : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnGetDefaultAccessibilityAction( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][out] */ 
            __deref_out  BSTR *pbstrDefaultAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDoDefaultAccessibilityAction( 
            /* [annotation][in] */ 
            __in  IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetAccessibilityRole( 
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][out] */ 
            __out  VARIANT *pvarRole) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeAccessibleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeAccessible * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeAccessible * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeAccessible * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDefaultAccessibilityAction )( 
            INameSpaceTreeAccessible * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][out] */ 
            __deref_out  BSTR *pbstrDefaultAction);
        
        HRESULT ( STDMETHODCALLTYPE *OnDoDefaultAccessibilityAction )( 
            INameSpaceTreeAccessible * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetAccessibilityRole )( 
            INameSpaceTreeAccessible * This,
            /* [annotation][in] */ 
            __in  IShellItem *psi,
            /* [annotation][out] */ 
            __out  VARIANT *pvarRole);
        
        END_INTERFACE
    } INameSpaceTreeAccessibleVtbl;

    interface INameSpaceTreeAccessible
    {
        CONST_VTBL struct INameSpaceTreeAccessibleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeAccessible_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeAccessible_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeAccessible_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeAccessible_OnGetDefaultAccessibilityAction(This,psi,pbstrDefaultAction)	\
    ( (This)->lpVtbl -> OnGetDefaultAccessibilityAction(This,psi,pbstrDefaultAction) ) 

#define INameSpaceTreeAccessible_OnDoDefaultAccessibilityAction(This,psi)	\
    ( (This)->lpVtbl -> OnDoDefaultAccessibilityAction(This,psi) ) 

#define INameSpaceTreeAccessible_OnGetAccessibilityRole(This,psi,pvarRole)	\
    ( (This)->lpVtbl -> OnGetAccessibilityRole(This,psi,pvarRole) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeAccessible_INTERFACE_DEFINED__ */


#ifndef __INameSpaceTreeControlCustomDraw_INTERFACE_DEFINED__
#define __INameSpaceTreeControlCustomDraw_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlCustomDraw */
/* [local][uuid][object] */ 

typedef struct NSTCCUSTOMDRAW
    {
    IShellItem *psi;
    UINT uItemState;
    NSTCITEMSTATE nstcis;
    LPCWSTR pszText;
    int iImage;
    HIMAGELIST himl;
    int iLevel;
    int iIndent;
    } 	NSTCCUSTOMDRAW;


EXTERN_C const IID IID_INameSpaceTreeControlCustomDraw;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D3BA758-33EE-42d5-BB7B-5F3431D86C78")
    INameSpaceTreeControlCustomDraw : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrePaint( 
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc,
            /* [annotation][out] */ 
            __out  LRESULT *plres) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostPaint( 
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemPrePaint( 
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc,
            /* [annotation][in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem,
            /* [annotation][out][in] */ 
            __inout  COLORREF *pclrText,
            /* [annotation][out][in] */ 
            __inout  COLORREF *pclrTextBk,
            /* [annotation][out] */ 
            __out  LRESULT *plres) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemPostPaint( 
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc,
            /* [annotation][in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlCustomDrawVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlCustomDraw * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlCustomDraw * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrePaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc,
            /* [annotation][out] */ 
            __out  LRESULT *plres);
        
        HRESULT ( STDMETHODCALLTYPE *PostPaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *ItemPrePaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc,
            /* [annotation][in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem,
            /* [annotation][out][in] */ 
            __inout  COLORREF *pclrText,
            /* [annotation][out][in] */ 
            __inout  COLORREF *pclrTextBk,
            /* [annotation][out] */ 
            __out  LRESULT *plres);
        
        HRESULT ( STDMETHODCALLTYPE *ItemPostPaint )( 
            INameSpaceTreeControlCustomDraw * This,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  RECT *prc,
            /* [annotation][in] */ 
            __in  NSTCCUSTOMDRAW *pnstccdItem);
        
        END_INTERFACE
    } INameSpaceTreeControlCustomDrawVtbl;

    interface INameSpaceTreeControlCustomDraw
    {
        CONST_VTBL struct INameSpaceTreeControlCustomDrawVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlCustomDraw_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlCustomDraw_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlCustomDraw_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlCustomDraw_PrePaint(This,hdc,prc,plres)	\
    ( (This)->lpVtbl -> PrePaint(This,hdc,prc,plres) ) 

#define INameSpaceTreeControlCustomDraw_PostPaint(This,hdc,prc)	\
    ( (This)->lpVtbl -> PostPaint(This,hdc,prc) ) 

#define INameSpaceTreeControlCustomDraw_ItemPrePaint(This,hdc,prc,pnstccdItem,pclrText,pclrTextBk,plres)	\
    ( (This)->lpVtbl -> ItemPrePaint(This,hdc,prc,pnstccdItem,pclrText,pclrTextBk,plres) ) 

#define INameSpaceTreeControlCustomDraw_ItemPostPaint(This,hdc,prc,pnstccdItem)	\
    ( (This)->lpVtbl -> ItemPostPaint(This,hdc,prc,pnstccdItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlCustomDraw_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0168 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0168_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0168_v0_0_s_ifspec;

#ifndef __INameSpaceTreeControlFolderCapabilities_INTERFACE_DEFINED__
#define __INameSpaceTreeControlFolderCapabilities_INTERFACE_DEFINED__

/* interface INameSpaceTreeControlFolderCapabilities */
/* [local][uuid][object] */ 

typedef /* [v1_enum] */ 
enum NSTCFOLDERCAPABILITIES
    {	NSTCFC_NONE	= 0,
	NSTCFC_PINNEDITEMFILTERING	= 0x1,
	NSTCFC_DELAY_REGISTER_NOTIFY	= 0x2
    } 	NSTCFOLDERCAPABILITIES;

DEFINE_ENUM_FLAG_OPERATORS(NSTCFOLDERCAPABILITIES)

EXTERN_C const IID IID_INameSpaceTreeControlFolderCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e9701183-e6b3-4ff2-8568-813615fec7be")
    INameSpaceTreeControlFolderCapabilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFolderCapabilities( 
            /* [annotation][in] */ 
            __in  NSTCFOLDERCAPABILITIES nfcMask,
            /* [annotation][out] */ 
            __out  NSTCFOLDERCAPABILITIES *pnfcValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INameSpaceTreeControlFolderCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INameSpaceTreeControlFolderCapabilities * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INameSpaceTreeControlFolderCapabilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INameSpaceTreeControlFolderCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderCapabilities )( 
            INameSpaceTreeControlFolderCapabilities * This,
            /* [annotation][in] */ 
            __in  NSTCFOLDERCAPABILITIES nfcMask,
            /* [annotation][out] */ 
            __out  NSTCFOLDERCAPABILITIES *pnfcValue);
        
        END_INTERFACE
    } INameSpaceTreeControlFolderCapabilitiesVtbl;

    interface INameSpaceTreeControlFolderCapabilities
    {
        CONST_VTBL struct INameSpaceTreeControlFolderCapabilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INameSpaceTreeControlFolderCapabilities_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INameSpaceTreeControlFolderCapabilities_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INameSpaceTreeControlFolderCapabilities_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INameSpaceTreeControlFolderCapabilities_GetFolderCapabilities(This,nfcMask,pnfcValue)	\
    ( (This)->lpVtbl -> GetFolderCapabilities(This,nfcMask,pnfcValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INameSpaceTreeControlFolderCapabilities_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0169 */
/* [local] */ 

#endif  // NTDDI_VISTA
#define E_PREVIEWHANDLER_DRM_FAIL _HRESULT_TYPEDEF_(0x86420001L)
#define E_PREVIEWHANDLER_NOAUTH   _HRESULT_TYPEDEF_(0x86420002L)
#define E_PREVIEWHANDLER_NOTFOUND _HRESULT_TYPEDEF_(0x86420003L)
#define E_PREVIEWHANDLER_CORRUPT  _HRESULT_TYPEDEF_(0x86420004L)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0169_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0169_v0_0_s_ifspec;

#ifndef __IPreviewHandler_INTERFACE_DEFINED__
#define __IPreviewHandler_INTERFACE_DEFINED__

/* interface IPreviewHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IPreviewHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8895b1c6-b41f-4c1c-a562-0d564250836f")
    IPreviewHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetWindow( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in const RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ __RPC__in const RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoPreview( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unload( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryFocus( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ __RPC__in MSG *pmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPreviewHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPreviewHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindow )( 
            __RPC__in IPreviewHandler * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in const RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            __RPC__in IPreviewHandler * This,
            /* [in] */ __RPC__in const RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *DoPreview )( 
            __RPC__in IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unload )( 
            __RPC__in IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            __RPC__in IPreviewHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFocus )( 
            __RPC__in IPreviewHandler * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            __RPC__in IPreviewHandler * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        END_INTERFACE
    } IPreviewHandlerVtbl;

    interface IPreviewHandler
    {
        CONST_VTBL struct IPreviewHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewHandler_SetWindow(This,hwnd,prc)	\
    ( (This)->lpVtbl -> SetWindow(This,hwnd,prc) ) 

#define IPreviewHandler_SetRect(This,prc)	\
    ( (This)->lpVtbl -> SetRect(This,prc) ) 

#define IPreviewHandler_DoPreview(This)	\
    ( (This)->lpVtbl -> DoPreview(This) ) 

#define IPreviewHandler_Unload(This)	\
    ( (This)->lpVtbl -> Unload(This) ) 

#define IPreviewHandler_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IPreviewHandler_QueryFocus(This,phwnd)	\
    ( (This)->lpVtbl -> QueryFocus(This,phwnd) ) 

#define IPreviewHandler_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewHandler_INTERFACE_DEFINED__ */


#ifndef __IPreviewHandlerFrame_INTERFACE_DEFINED__
#define __IPreviewHandlerFrame_INTERFACE_DEFINED__

/* interface IPreviewHandlerFrame */
/* [unique][uuid][object] */ 

typedef /* [public][public] */ struct __MIDL_IPreviewHandlerFrame_0001
    {
    HACCEL haccel;
    UINT cAccelEntries;
    } 	PREVIEWHANDLERFRAMEINFO;


EXTERN_C const IID IID_IPreviewHandlerFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fec87aaf-35f9-447a-adb7-20234491401a")
    IPreviewHandlerFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindowContext( 
            /* [out] */ __RPC__out PREVIEWHANDLERFRAMEINFO *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ __RPC__in MSG *pmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewHandlerFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPreviewHandlerFrame * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPreviewHandlerFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPreviewHandlerFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowContext )( 
            __RPC__in IPreviewHandlerFrame * This,
            /* [out] */ __RPC__out PREVIEWHANDLERFRAMEINFO *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            __RPC__in IPreviewHandlerFrame * This,
            /* [in] */ __RPC__in MSG *pmsg);
        
        END_INTERFACE
    } IPreviewHandlerFrameVtbl;

    interface IPreviewHandlerFrame
    {
        CONST_VTBL struct IPreviewHandlerFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewHandlerFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPreviewHandlerFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPreviewHandlerFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPreviewHandlerFrame_GetWindowContext(This,pinfo)	\
    ( (This)->lpVtbl -> GetWindowContext(This,pinfo) ) 

#define IPreviewHandlerFrame_TranslateAccelerator(This,pmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,pmsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPreviewHandlerFrame_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0171 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0171_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0171_v0_0_s_ifspec;

#ifndef __ITrayDeskBand_INTERFACE_DEFINED__
#define __ITrayDeskBand_INTERFACE_DEFINED__

/* interface ITrayDeskBand */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITrayDeskBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D67E846-5B9C-4db8-9CBC-DDE12F4254F1")
    ITrayDeskBand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowDeskBand( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideDeskBand( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDeskBandShown( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeskBandRegistrationChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrayDeskBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITrayDeskBand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITrayDeskBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITrayDeskBand * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDeskBand )( 
            __RPC__in ITrayDeskBand * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *HideDeskBand )( 
            __RPC__in ITrayDeskBand * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *IsDeskBandShown )( 
            __RPC__in ITrayDeskBand * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *DeskBandRegistrationChanged )( 
            __RPC__in ITrayDeskBand * This);
        
        END_INTERFACE
    } ITrayDeskBandVtbl;

    interface ITrayDeskBand
    {
        CONST_VTBL struct ITrayDeskBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrayDeskBand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITrayDeskBand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITrayDeskBand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITrayDeskBand_ShowDeskBand(This,clsid)	\
    ( (This)->lpVtbl -> ShowDeskBand(This,clsid) ) 

#define ITrayDeskBand_HideDeskBand(This,clsid)	\
    ( (This)->lpVtbl -> HideDeskBand(This,clsid) ) 

#define ITrayDeskBand_IsDeskBandShown(This,clsid)	\
    ( (This)->lpVtbl -> IsDeskBandShown(This,clsid) ) 

#define ITrayDeskBand_DeskBandRegistrationChanged(This)	\
    ( (This)->lpVtbl -> DeskBandRegistrationChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITrayDeskBand_INTERFACE_DEFINED__ */


#ifndef __IBandHost_INTERFACE_DEFINED__
#define __IBandHost_INTERFACE_DEFINED__

/* interface IBandHost */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IBandHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9075C7C-D48E-403f-AB99-D6C77A1084AC")
    IBandHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBand( 
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable,
            /* [in] */ BOOL fVisible,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandAvailability( 
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyBand( 
            /* [in] */ __RPC__in REFCLSID rclsidBand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBandHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBandHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBandHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBandHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBand )( 
            __RPC__in IBandHost * This,
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable,
            /* [in] */ BOOL fVisible,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandAvailability )( 
            __RPC__in IBandHost * This,
            /* [in] */ __RPC__in REFCLSID rclsidBand,
            /* [in] */ BOOL fAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyBand )( 
            __RPC__in IBandHost * This,
            /* [in] */ __RPC__in REFCLSID rclsidBand);
        
        END_INTERFACE
    } IBandHostVtbl;

    interface IBandHost
    {
        CONST_VTBL struct IBandHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBandHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBandHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBandHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBandHost_CreateBand(This,rclsidBand,fAvailable,fVisible,riid,ppv)	\
    ( (This)->lpVtbl -> CreateBand(This,rclsidBand,fAvailable,fVisible,riid,ppv) ) 

#define IBandHost_SetBandAvailability(This,rclsidBand,fAvailable)	\
    ( (This)->lpVtbl -> SetBandAvailability(This,rclsidBand,fAvailable) ) 

#define IBandHost_DestroyBand(This,rclsidBand)	\
    ( (This)->lpVtbl -> DestroyBand(This,rclsidBand) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBandHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0173 */
/* [local] */ 

#define SID_SBandHost IID_IBandHost
typedef GUID EXPLORERPANE;

#if 0
typedef EXPLORERPANE *REFEXPLORERPANE;

#endif // 0
#ifdef __cplusplus
#define REFEXPLORERPANE const EXPLORERPANE &
#else // !__cplusplus
#define REFEXPLORERPANE const EXPLORERPANE * __MIDL_CONST
#endif // __cplusplus


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0173_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0173_v0_0_s_ifspec;

#ifndef __IExplorerPaneVisibility_INTERFACE_DEFINED__
#define __IExplorerPaneVisibility_INTERFACE_DEFINED__

/* interface IExplorerPaneVisibility */
/* [unique][local][uuid][object] */ 

/* [v1_enum] */ 
enum _EXPLORERPANESTATE
    {	EPS_DONTCARE	= 0,
	EPS_DEFAULT_ON	= 0x1,
	EPS_DEFAULT_OFF	= 0x2,
	EPS_STATEMASK	= 0xffff,
	EPS_INITIALSTATE	= 0x10000,
	EPS_FORCE	= 0x20000
    } ;
typedef DWORD EXPLORERPANESTATE;


EXTERN_C const IID IID_IExplorerPaneVisibility;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e07010ec-bc17-44c0-97b0-46c7c95b9edc")
    IExplorerPaneVisibility : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPaneState( 
            /* [annotation][in] */ 
            __in  REFEXPLORERPANE ep,
            /* [annotation][out] */ 
            __out  EXPLORERPANESTATE *peps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerPaneVisibilityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExplorerPaneVisibility * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExplorerPaneVisibility * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExplorerPaneVisibility * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPaneState )( 
            IExplorerPaneVisibility * This,
            /* [annotation][in] */ 
            __in  REFEXPLORERPANE ep,
            /* [annotation][out] */ 
            __out  EXPLORERPANESTATE *peps);
        
        END_INTERFACE
    } IExplorerPaneVisibilityVtbl;

    interface IExplorerPaneVisibility
    {
        CONST_VTBL struct IExplorerPaneVisibilityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerPaneVisibility_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerPaneVisibility_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerPaneVisibility_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerPaneVisibility_GetPaneState(This,ep,peps)	\
    ( (This)->lpVtbl -> GetPaneState(This,ep,peps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerPaneVisibility_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0174 */
/* [local] */ 

#define SID_ExplorerPaneVisibility IID_IExplorerPaneVisibility


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0174_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0174_v0_0_s_ifspec;

#ifndef __IContextMenuCB_INTERFACE_DEFINED__
#define __IContextMenuCB_INTERFACE_DEFINED__

/* interface IContextMenuCB */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3409E930-5A39-11d1-83FA-00A0C90DC849")
    IContextMenuCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallBack( 
            /* [annotation][unique][in] */ 
            __in_opt  IShellFolder *psf,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner,
            /* [annotation][unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMenuCB * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMenuCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMenuCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallBack )( 
            IContextMenuCB * This,
            /* [annotation][unique][in] */ 
            __in_opt  IShellFolder *psf,
            /* [annotation][unique][in] */ 
            __in_opt  HWND hwndOwner,
            /* [annotation][unique][in] */ 
            __in_opt  IDataObject *pdtobj,
            /* [annotation][in] */ 
            __in  UINT uMsg,
            /* [annotation][in] */ 
            __in  WPARAM wParam,
            /* [annotation][in] */ 
            __in  LPARAM lParam);
        
        END_INTERFACE
    } IContextMenuCBVtbl;

    interface IContextMenuCB
    {
        CONST_VTBL struct IContextMenuCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextMenuCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextMenuCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextMenuCB_CallBack(This,psf,hwndOwner,pdtobj,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> CallBack(This,psf,hwndOwner,pdtobj,uMsg,wParam,lParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextMenuCB_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0175 */
/* [local] */ 

#endif  // NTDDI_VISTA


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0175_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0175_v0_0_s_ifspec;

#ifndef __IDefaultExtractIconInit_INTERFACE_DEFINED__
#define __IDefaultExtractIconInit_INTERFACE_DEFINED__

/* interface IDefaultExtractIconInit */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDefaultExtractIconInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41ded17d-d6b3-4261-997d-88c60e4b1d58")
    IDefaultExtractIconInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [annotation][in] */ 
            __in  UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [annotation][in] */ 
            __in  HKEY hkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNormalIcon( 
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenIcon( 
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShortcutIcon( 
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultIcon( 
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefaultExtractIconInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefaultExtractIconInit * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefaultExtractIconInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefaultExtractIconInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IDefaultExtractIconInit * This,
            /* [annotation][in] */ 
            __in  UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IDefaultExtractIconInit * This,
            /* [annotation][in] */ 
            __in  HKEY hkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetNormalIcon )( 
            IDefaultExtractIconInit * This,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenIcon )( 
            IDefaultExtractIconInit * This,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetShortcutIcon )( 
            IDefaultExtractIconInit * This,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultIcon )( 
            IDefaultExtractIconInit * This,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pszFile,
            /* [annotation][in] */ 
            __in  int iIcon);
        
        END_INTERFACE
    } IDefaultExtractIconInitVtbl;

    interface IDefaultExtractIconInit
    {
        CONST_VTBL struct IDefaultExtractIconInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefaultExtractIconInit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDefaultExtractIconInit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDefaultExtractIconInit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDefaultExtractIconInit_SetFlags(This,uFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,uFlags) ) 

#define IDefaultExtractIconInit_SetKey(This,hkey)	\
    ( (This)->lpVtbl -> SetKey(This,hkey) ) 

#define IDefaultExtractIconInit_SetNormalIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetNormalIcon(This,pszFile,iIcon) ) 

#define IDefaultExtractIconInit_SetOpenIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetOpenIcon(This,pszFile,iIcon) ) 

#define IDefaultExtractIconInit_SetShortcutIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetShortcutIcon(This,pszFile,iIcon) ) 

#define IDefaultExtractIconInit_SetDefaultIcon(This,pszFile,iIcon)	\
    ( (This)->lpVtbl -> SetDefaultIcon(This,pszFile,iIcon) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDefaultExtractIconInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0176 */
/* [local] */ 

STDAPI SHCreateDefaultExtractIcon(__in REFIID riid, __deref_out void **ppv);



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0176_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0176_v0_0_s_ifspec;

#ifndef __IExplorerCommand_INTERFACE_DEFINED__
#define __IExplorerCommand_INTERFACE_DEFINED__

/* interface IExplorerCommand */
/* [object][unique][uuid] */ 

/* [v1_enum] */ 
enum _EXPCMDSTATE
    {	ECS_ENABLED	= 0,
	ECS_DISABLED	= 0x1,
	ECS_HIDDEN	= 0x2,
	ECS_CHECKBOX	= 0x4,
	ECS_CHECKED	= 0x8,
	ECS_RADIOCHECK	= 0x10
    } ;
typedef DWORD EXPCMDSTATE;

/* [v1_enum] */ 
enum _EXPCMDFLAGS
    {	ECF_DEFAULT	= 0,
	ECF_HASSUBCOMMANDS	= 0x1,
	ECF_HASSPLITBUTTON	= 0x2,
	ECF_HIDELABEL	= 0x4,
	ECF_ISSEPARATOR	= 0x8,
	ECF_HASLUASHIELD	= 0x10,
	ECF_SEPARATORBEFORE	= 0x20,
	ECF_SEPARATORAFTER	= 0x40,
	ECF_ISDROPDOWN	= 0x80
    } ;
typedef DWORD EXPCMDFLAGS;


EXTERN_C const IID IID_IExplorerCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a08ce4d0-fa25-44ab-b57c-c7b1c323e0b9")
    IExplorerCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToolTip( 
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInfotip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
            /* [out] */ __RPC__out GUID *pguidCommandName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ __RPC__out EXPCMDSTATE *pCmdState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ __RPC__out EXPCMDFLAGS *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSubCommands( 
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExplorerCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExplorerCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExplorerCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            __RPC__in IExplorerCommand * This,
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            __RPC__in IExplorerCommand * This,
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *GetToolTip )( 
            __RPC__in IExplorerCommand * This,
            /* [unique][in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInfotip);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            __RPC__in IExplorerCommand * This,
            /* [out] */ __RPC__out GUID *pguidCommandName);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            __RPC__in IExplorerCommand * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ __RPC__out EXPCMDSTATE *pCmdState);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            __RPC__in IExplorerCommand * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [unique][in] */ __RPC__in_opt IBindCtx *pbc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            __RPC__in IExplorerCommand * This,
            /* [out] */ __RPC__out EXPCMDFLAGS *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSubCommands )( 
            __RPC__in IExplorerCommand * This,
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppEnum);
        
        END_INTERFACE
    } IExplorerCommandVtbl;

    interface IExplorerCommand
    {
        CONST_VTBL struct IExplorerCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerCommand_GetTitle(This,psiItemArray,ppszName)	\
    ( (This)->lpVtbl -> GetTitle(This,psiItemArray,ppszName) ) 

#define IExplorerCommand_GetIcon(This,psiItemArray,ppszIcon)	\
    ( (This)->lpVtbl -> GetIcon(This,psiItemArray,ppszIcon) ) 

#define IExplorerCommand_GetToolTip(This,psiItemArray,ppszInfotip)	\
    ( (This)->lpVtbl -> GetToolTip(This,psiItemArray,ppszInfotip) ) 

#define IExplorerCommand_GetCanonicalName(This,pguidCommandName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,pguidCommandName) ) 

#define IExplorerCommand_GetState(This,psiItemArray,fOkToBeSlow,pCmdState)	\
    ( (This)->lpVtbl -> GetState(This,psiItemArray,fOkToBeSlow,pCmdState) ) 

#define IExplorerCommand_Invoke(This,psiItemArray,pbc)	\
    ( (This)->lpVtbl -> Invoke(This,psiItemArray,pbc) ) 

#define IExplorerCommand_GetFlags(This,pFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pFlags) ) 

#define IExplorerCommand_EnumSubCommands(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumSubCommands(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerCommand_INTERFACE_DEFINED__ */


#ifndef __IExplorerCommandState_INTERFACE_DEFINED__
#define __IExplorerCommandState_INTERFACE_DEFINED__

/* interface IExplorerCommandState */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IExplorerCommandState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bddacb60-7657-47ae-8445-d23e1acf82ae")
    IExplorerCommandState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ __RPC__out EXPCMDSTATE *pCmdState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerCommandStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExplorerCommandState * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExplorerCommandState * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExplorerCommandState * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            __RPC__in IExplorerCommandState * This,
            /* [in] */ __RPC__in_opt IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ __RPC__out EXPCMDSTATE *pCmdState);
        
        END_INTERFACE
    } IExplorerCommandStateVtbl;

    interface IExplorerCommandState
    {
        CONST_VTBL struct IExplorerCommandStateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerCommandState_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerCommandState_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerCommandState_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerCommandState_GetState(This,psiItemArray,fOkToBeSlow,pCmdState)	\
    ( (This)->lpVtbl -> GetState(This,psiItemArray,fOkToBeSlow,pCmdState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerCommandState_INTERFACE_DEFINED__ */


#ifndef __IInitializeCommand_INTERFACE_DEFINED__
#define __IInitializeCommand_INTERFACE_DEFINED__

/* interface IInitializeCommand */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInitializeCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85075acf-231f-40ea-9610-d26b7b58f638")
    IInitializeCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszCommandName,
            /* [in] */ __RPC__in_opt IPropertyBag *ppb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IInitializeCommand * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszCommandName,
            /* [in] */ __RPC__in_opt IPropertyBag *ppb);
        
        END_INTERFACE
    } IInitializeCommandVtbl;

    interface IInitializeCommand
    {
        CONST_VTBL struct IInitializeCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeCommand_Initialize(This,pszCommandName,ppb)	\
    ( (This)->lpVtbl -> Initialize(This,pszCommandName,ppb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeCommand_INTERFACE_DEFINED__ */


#ifndef __IEnumExplorerCommand_INTERFACE_DEFINED__
#define __IEnumExplorerCommand_INTERFACE_DEFINED__

/* interface IEnumExplorerCommand */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumExplorerCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a88826f8-186f-4987-aade-ea0cef8fbfe8")
    IEnumExplorerCommand : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IExplorerCommand **pUICommand,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumExplorerCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumExplorerCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumExplorerCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumExplorerCommand * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumExplorerCommand * This,
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IExplorerCommand **pUICommand,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumExplorerCommand * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumExplorerCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumExplorerCommand * This,
            /* [out] */ __RPC__deref_out_opt IEnumExplorerCommand **ppenum);
        
        END_INTERFACE
    } IEnumExplorerCommandVtbl;

    interface IEnumExplorerCommand
    {
        CONST_VTBL struct IEnumExplorerCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumExplorerCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumExplorerCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumExplorerCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumExplorerCommand_Next(This,celt,pUICommand,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pUICommand,pceltFetched) ) 

#define IEnumExplorerCommand_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumExplorerCommand_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumExplorerCommand_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumExplorerCommand_RemoteNext_Proxy( 
    __RPC__in IEnumExplorerCommand * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IExplorerCommand **pUICommand,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumExplorerCommand_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumExplorerCommand_INTERFACE_DEFINED__ */


#ifndef __IExplorerCommandProvider_INTERFACE_DEFINED__
#define __IExplorerCommandProvider_INTERFACE_DEFINED__

/* interface IExplorerCommandProvider */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IExplorerCommandProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64961751-0835-43c0-8ffe-d57686530e64")
    IExplorerCommandProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCommands( 
            /* [in] */ __RPC__in_opt IUnknown *punkSite,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [in] */ __RPC__in REFGUID rguidCommandId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplorerCommandProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExplorerCommandProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExplorerCommandProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExplorerCommandProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommands )( 
            __RPC__in IExplorerCommandProvider * This,
            /* [in] */ __RPC__in_opt IUnknown *punkSite,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommand )( 
            __RPC__in IExplorerCommandProvider * This,
            /* [in] */ __RPC__in REFGUID rguidCommandId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IExplorerCommandProviderVtbl;

    interface IExplorerCommandProvider
    {
        CONST_VTBL struct IExplorerCommandProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplorerCommandProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExplorerCommandProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExplorerCommandProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExplorerCommandProvider_GetCommands(This,punkSite,riid,ppv)	\
    ( (This)->lpVtbl -> GetCommands(This,punkSite,riid,ppv) ) 

#define IExplorerCommandProvider_GetCommand(This,rguidCommandId,riid,ppv)	\
    ( (This)->lpVtbl -> GetCommand(This,rguidCommandId,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExplorerCommandProvider_INTERFACE_DEFINED__ */


#ifndef __IMarkupCallback_INTERFACE_DEFINED__
#define __IMarkupCallback_INTERFACE_DEFINED__

/* interface IMarkupCallback */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IMarkupCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4440306e-d79a-48d0-88e6-a42692279bfb")
    IMarkupCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][in] */ 
            __in  UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][in] */ 
            __in  int nCode,
            /* [annotation][in] */ 
            __in  int iLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRect( 
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][unique][in] */ 
            __in_opt  const RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCustomDraw( 
            /* [annotation][in] */ 
            __in  DWORD dwDrawStage,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][unique][in] */ 
            __in_opt  const RECT *prc,
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uItemState,
            /* [annotation][out] */ 
            __out_opt  LRESULT *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CustomDrawText( 
            /* [annotation][in] */ 
            __in  HDC hDC,
            /* [annotation][string][in] */ 
            __in  LPCWSTR lpString,
            /* [annotation][in] */ 
            __in  int nCount,
            /* [annotation][in] */ 
            __in  RECT *pRect,
            /* [annotation][in] */ 
            __in  UINT uFormat,
            /* [annotation][in] */ 
            __in  BOOL fLink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupCallback * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMarkupCallback * This,
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][in] */ 
            __in  UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IMarkupCallback * This,
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][in] */ 
            __in  int nCode,
            /* [annotation][in] */ 
            __in  int iLink);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRect )( 
            IMarkupCallback * This,
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][unique][in] */ 
            __in_opt  const RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *OnCustomDraw )( 
            IMarkupCallback * This,
            /* [annotation][in] */ 
            __in  DWORD dwDrawStage,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][unique][in] */ 
            __in_opt  const RECT *prc,
            /* [annotation][in] */ 
            __in  DWORD dwId,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uItemState,
            /* [annotation][out] */ 
            __out_opt  LRESULT *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *CustomDrawText )( 
            IMarkupCallback * This,
            /* [annotation][in] */ 
            __in  HDC hDC,
            /* [annotation][string][in] */ 
            __in  LPCWSTR lpString,
            /* [annotation][in] */ 
            __in  int nCount,
            /* [annotation][in] */ 
            __in  RECT *pRect,
            /* [annotation][in] */ 
            __in  UINT uFormat,
            /* [annotation][in] */ 
            __in  BOOL fLink);
        
        END_INTERFACE
    } IMarkupCallbackVtbl;

    interface IMarkupCallback
    {
        CONST_VTBL struct IMarkupCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMarkupCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMarkupCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMarkupCallback_GetState(This,dwId,uState)	\
    ( (This)->lpVtbl -> GetState(This,dwId,uState) ) 

#define IMarkupCallback_Notify(This,dwId,nCode,iLink)	\
    ( (This)->lpVtbl -> Notify(This,dwId,nCode,iLink) ) 

#define IMarkupCallback_InvalidateRect(This,dwId,prc)	\
    ( (This)->lpVtbl -> InvalidateRect(This,dwId,prc) ) 

#define IMarkupCallback_OnCustomDraw(This,dwDrawStage,hdc,prc,dwId,iLink,uItemState,pdwResult)	\
    ( (This)->lpVtbl -> OnCustomDraw(This,dwDrawStage,hdc,prc,dwId,iLink,uItemState,pdwResult) ) 

#define IMarkupCallback_CustomDrawText(This,hDC,lpString,nCount,pRect,uFormat,fLink)	\
    ( (This)->lpVtbl -> CustomDrawText(This,hDC,lpString,nCount,pRect,uFormat,fLink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMarkupCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0182 */
/* [local] */ 

typedef HANDLE HTHEME;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0182_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0182_v0_0_s_ifspec;

#ifndef __IControlMarkup_INTERFACE_DEFINED__
#define __IControlMarkup_INTERFACE_DEFINED__

/* interface IControlMarkup */
/* [object][local][uuid] */ 

typedef /* [v1_enum] */ 
enum MARKUPSIZE
    {	MARKUPSIZE_CALCWIDTH	= 0,
	MARKUPSIZE_CALCHEIGHT	= ( MARKUPSIZE_CALCWIDTH + 1 ) 
    } 	MARKUPSIZE;

typedef /* [v1_enum] */ 
enum MARKUPLINKTEXT
    {	MARKUPLINKTEXT_URL	= 0,
	MARKUPLINKTEXT_ID	= ( MARKUPLINKTEXT_URL + 1 ) ,
	MARKUPLINKTEXT_TEXT	= ( MARKUPLINKTEXT_ID + 1 ) 
    } 	MARKUPLINKTEXT;

/* [v1_enum] */ 
enum _MARKUPSTATE
    {	MARKUPSTATE_FOCUSED	= 0x1,
	MARKUPSTATE_ENABLED	= 0x2,
	MARKUPSTATE_VISITED	= 0x4,
	MARKUPSTATE_HOT	= 0x8,
	MARKUPSTATE_DEFAULTCOLORS	= 0x10,
	MARKUPSTATE_ALLOWMARKUP	= 0x40000000
    } ;
typedef DWORD MARKUPSTATE;

typedef /* [v1_enum] */ 
enum MARKUPMESSAGE
    {	MARKUPMESSAGE_KEYEXECUTE	= 0,
	MARKUPMESSAGE_CLICKEXECUTE	= ( MARKUPMESSAGE_KEYEXECUTE + 1 ) ,
	MARKUPMESSAGE_WANTFOCUS	= ( MARKUPMESSAGE_CLICKEXECUTE + 1 ) 
    } 	MARKUPMESSAGE;


EXTERN_C const IID IID_IControlMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6D2FBAE-F116-458c-8C34-03569877A2D2")
    IControlMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallback( 
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppvUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            /* [annotation][in] */ 
            __in  DWORD dwId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [annotation][out] */ 
            __out  DWORD *pdwId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFonts( 
            /* [annotation][in] */ 
            __in  HFONT hFont,
            /* [annotation][in] */ 
            __in  HFONT hFontUnderline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFonts( 
            /* [annotation][out] */ 
            __out  HFONT *phFont,
            /* [annotation][out] */ 
            __out  HFONT *phFontUnderline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [annotation][in] */ 
            __in  BOOL bRaw,
            /* [annotation][size_is][string][out] */ 
            __out_ecount_part_opt(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkText( 
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uMarkupLinkText,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkText( 
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uMarkupLinkText,
            /* [annotation][size_is][string][out] */ 
            __out_ecount_part_opt(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderFlags( 
            /* [annotation][in] */ 
            __in  UINT uDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderFlags( 
            /* [annotation][out] */ 
            __out_opt  UINT *puDT,
            /* [annotation][out] */ 
            __out_opt  HTHEME *phTheme,
            /* [annotation][out] */ 
            __out_opt  int *piPartId,
            /* [annotation][out] */ 
            __out_opt  int *piStateIdNormal,
            /* [annotation][out] */ 
            __out_opt  int *piStateIdLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThemeRenderFlags( 
            /* [annotation][in] */ 
            __in  UINT uDT,
            /* [annotation][in] */ 
            __in  HTHEME hTheme,
            /* [annotation][in] */ 
            __in  int iPartId,
            /* [annotation][in] */ 
            __in  int iStateIdNormal,
            /* [annotation][in] */ 
            __in  int iStateIdLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uStateMask,
            /* [annotation][out] */ 
            __out  UINT *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uStateMask,
            /* [annotation][in] */ 
            __in  UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawText( 
            /* [annotation][in] */ 
            __in  HDC hdcClient,
            /* [annotation][in] */ 
            __in  LPCRECT prcClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkCursor( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CalcIdealSize( 
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  UINT uMarkUpCalc,
            /* [annotation][out][in] */ 
            __inout  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTabbable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonDown( 
            /* [annotation][in] */ 
            __in  POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonUp( 
            /* [annotation][in] */ 
            __in  POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            /* [annotation][in] */ 
            __in  UINT uVirtKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [annotation][in] */ 
            __in  POINT pt,
            /* [annotation][out] */ 
            __out  int *piLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkRect( 
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][out] */ 
            __out  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlRect( 
            /* [annotation][out] */ 
            __out  RECT *prcControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkCount( 
            /* [annotation][out] */ 
            __out  UINT *pcLinks) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlMarkup * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IControlMarkup * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallback )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppvUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  DWORD dwId);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IControlMarkup * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwId);
        
        HRESULT ( STDMETHODCALLTYPE *SetFonts )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  HFONT hFont,
            /* [annotation][in] */ 
            __in  HFONT hFontUnderline);
        
        HRESULT ( STDMETHODCALLTYPE *GetFonts )( 
            IControlMarkup * This,
            /* [annotation][out] */ 
            __out  HFONT *phFont,
            /* [annotation][out] */ 
            __out  HFONT *phFontUnderline);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            IControlMarkup * This,
            /* [annotation][string][unique][in] */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  BOOL bRaw,
            /* [annotation][size_is][string][out] */ 
            __out_ecount_part_opt(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwCch);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkText )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uMarkupLinkText,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkText )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uMarkupLinkText,
            /* [annotation][size_is][string][out] */ 
            __out_ecount_part_opt(*pdwCch, *pdwCch)  LPWSTR pwszText,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwCch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderFlags )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  UINT uDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderFlags )( 
            IControlMarkup * This,
            /* [annotation][out] */ 
            __out_opt  UINT *puDT,
            /* [annotation][out] */ 
            __out_opt  HTHEME *phTheme,
            /* [annotation][out] */ 
            __out_opt  int *piPartId,
            /* [annotation][out] */ 
            __out_opt  int *piStateIdNormal,
            /* [annotation][out] */ 
            __out_opt  int *piStateIdLink);
        
        HRESULT ( STDMETHODCALLTYPE *SetThemeRenderFlags )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  UINT uDT,
            /* [annotation][in] */ 
            __in  HTHEME hTheme,
            /* [annotation][in] */ 
            __in  int iPartId,
            /* [annotation][in] */ 
            __in  int iStateIdNormal,
            /* [annotation][in] */ 
            __in  int iStateIdLink);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uStateMask,
            /* [annotation][out] */ 
            __out  UINT *puState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][in] */ 
            __in  UINT uStateMask,
            /* [annotation][in] */ 
            __in  UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *DrawText )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  HDC hdcClient,
            /* [annotation][in] */ 
            __in  LPCRECT prcClient);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkCursor )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CalcIdealSize )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  HDC hdc,
            /* [annotation][in] */ 
            __in  UINT uMarkUpCalc,
            /* [annotation][out][in] */ 
            __inout  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *KillFocus )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTabbable )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonDown )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonUp )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  UINT uVirtKey);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  POINT pt,
            /* [annotation][out] */ 
            __out  int *piLink);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkRect )( 
            IControlMarkup * This,
            /* [annotation][in] */ 
            __in  int iLink,
            /* [annotation][out] */ 
            __out  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlRect )( 
            IControlMarkup * This,
            /* [annotation][out] */ 
            __out  RECT *prcControl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkCount )( 
            IControlMarkup * This,
            /* [annotation][out] */ 
            __out  UINT *pcLinks);
        
        END_INTERFACE
    } IControlMarkupVtbl;

    interface IControlMarkup
    {
        CONST_VTBL struct IControlMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlMarkup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IControlMarkup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IControlMarkup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IControlMarkup_SetCallback(This,punk)	\
    ( (This)->lpVtbl -> SetCallback(This,punk) ) 

#define IControlMarkup_GetCallback(This,riid,ppvUnk)	\
    ( (This)->lpVtbl -> GetCallback(This,riid,ppvUnk) ) 

#define IControlMarkup_SetId(This,dwId)	\
    ( (This)->lpVtbl -> SetId(This,dwId) ) 

#define IControlMarkup_GetId(This,pdwId)	\
    ( (This)->lpVtbl -> GetId(This,pdwId) ) 

#define IControlMarkup_SetFonts(This,hFont,hFontUnderline)	\
    ( (This)->lpVtbl -> SetFonts(This,hFont,hFontUnderline) ) 

#define IControlMarkup_GetFonts(This,phFont,phFontUnderline)	\
    ( (This)->lpVtbl -> GetFonts(This,phFont,phFontUnderline) ) 

#define IControlMarkup_SetText(This,pwszText)	\
    ( (This)->lpVtbl -> SetText(This,pwszText) ) 

#define IControlMarkup_GetText(This,bRaw,pwszText,pdwCch)	\
    ( (This)->lpVtbl -> GetText(This,bRaw,pwszText,pdwCch) ) 

#define IControlMarkup_SetLinkText(This,iLink,uMarkupLinkText,pwszText)	\
    ( (This)->lpVtbl -> SetLinkText(This,iLink,uMarkupLinkText,pwszText) ) 

#define IControlMarkup_GetLinkText(This,iLink,uMarkupLinkText,pwszText,pdwCch)	\
    ( (This)->lpVtbl -> GetLinkText(This,iLink,uMarkupLinkText,pwszText,pdwCch) ) 

#define IControlMarkup_SetRenderFlags(This,uDT)	\
    ( (This)->lpVtbl -> SetRenderFlags(This,uDT) ) 

#define IControlMarkup_GetRenderFlags(This,puDT,phTheme,piPartId,piStateIdNormal,piStateIdLink)	\
    ( (This)->lpVtbl -> GetRenderFlags(This,puDT,phTheme,piPartId,piStateIdNormal,piStateIdLink) ) 

#define IControlMarkup_SetThemeRenderFlags(This,uDT,hTheme,iPartId,iStateIdNormal,iStateIdLink)	\
    ( (This)->lpVtbl -> SetThemeRenderFlags(This,uDT,hTheme,iPartId,iStateIdNormal,iStateIdLink) ) 

#define IControlMarkup_GetState(This,iLink,uStateMask,puState)	\
    ( (This)->lpVtbl -> GetState(This,iLink,uStateMask,puState) ) 

#define IControlMarkup_SetState(This,iLink,uStateMask,uState)	\
    ( (This)->lpVtbl -> SetState(This,iLink,uStateMask,uState) ) 

#define IControlMarkup_DrawText(This,hdcClient,prcClient)	\
    ( (This)->lpVtbl -> DrawText(This,hdcClient,prcClient) ) 

#define IControlMarkup_SetLinkCursor(This)	\
    ( (This)->lpVtbl -> SetLinkCursor(This) ) 

#define IControlMarkup_CalcIdealSize(This,hdc,uMarkUpCalc,prc)	\
    ( (This)->lpVtbl -> CalcIdealSize(This,hdc,uMarkUpCalc,prc) ) 

#define IControlMarkup_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IControlMarkup_KillFocus(This)	\
    ( (This)->lpVtbl -> KillFocus(This) ) 

#define IControlMarkup_IsTabbable(This)	\
    ( (This)->lpVtbl -> IsTabbable(This) ) 

#define IControlMarkup_OnButtonDown(This,pt)	\
    ( (This)->lpVtbl -> OnButtonDown(This,pt) ) 

#define IControlMarkup_OnButtonUp(This,pt)	\
    ( (This)->lpVtbl -> OnButtonUp(This,pt) ) 

#define IControlMarkup_OnKeyDown(This,uVirtKey)	\
    ( (This)->lpVtbl -> OnKeyDown(This,uVirtKey) ) 

#define IControlMarkup_HitTest(This,pt,piLink)	\
    ( (This)->lpVtbl -> HitTest(This,pt,piLink) ) 

#define IControlMarkup_GetLinkRect(This,iLink,prc)	\
    ( (This)->lpVtbl -> GetLinkRect(This,iLink,prc) ) 

#define IControlMarkup_GetControlRect(This,prcControl)	\
    ( (This)->lpVtbl -> GetControlRect(This,prcControl) ) 

#define IControlMarkup_GetLinkCount(This,pcLinks)	\
    ( (This)->lpVtbl -> GetLinkCount(This,pcLinks) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IControlMarkup_INTERFACE_DEFINED__ */


#ifndef __IInitializeNetworkFolder_INTERFACE_DEFINED__
#define __IInitializeNetworkFolder_INTERFACE_DEFINED__

/* interface IInitializeNetworkFolder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInitializeNetworkFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e0f9881-42a8-4f2a-97f8-8af4e026d92d")
    IInitializeNetworkFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlTarget,
            /* [in] */ UINT uDisplayType,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszResName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszProvider) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeNetworkFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeNetworkFolder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeNetworkFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeNetworkFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IInitializeNetworkFolder * This,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidl,
            /* [unique][in] */ __RPC__in_opt PCIDLIST_ABSOLUTE pidlTarget,
            /* [in] */ UINT uDisplayType,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszResName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszProvider);
        
        END_INTERFACE
    } IInitializeNetworkFolderVtbl;

    interface IInitializeNetworkFolder
    {
        CONST_VTBL struct IInitializeNetworkFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeNetworkFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeNetworkFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeNetworkFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeNetworkFolder_Initialize(This,pidl,pidlTarget,uDisplayType,pszResName,pszProvider)	\
    ( (This)->lpVtbl -> Initialize(This,pidl,pidlTarget,uDisplayType,pszResName,pszProvider) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeNetworkFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0184 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum CPVIEW
    {	CPVIEW_CLASSIC	= 0,
	CPVIEW_ALLITEMS	= CPVIEW_CLASSIC,
	CPVIEW_CATEGORY	= 1,
	CPVIEW_HOME	= CPVIEW_CATEGORY
    } 	CPVIEW;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0184_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0184_v0_0_s_ifspec;

#ifndef __IOpenControlPanel_INTERFACE_DEFINED__
#define __IOpenControlPanel_INTERFACE_DEFINED__

/* interface IOpenControlPanel */
/* [uuid][object] */ 


EXTERN_C const IID IID_IOpenControlPanel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D11AD862-66DE-4DF4-BF6C-1F5621996AF1")
    IOpenControlPanel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszPage,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszName,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchPath) LPWSTR pszPath,
            /* [in] */ UINT cchPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentView( 
            /* [out] */ __RPC__out CPVIEW *pView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOpenControlPanelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOpenControlPanel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOpenControlPanel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOpenControlPanel * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IOpenControlPanel * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszName,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszPage,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            __RPC__in IOpenControlPanel * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszName,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchPath) LPWSTR pszPath,
            /* [in] */ UINT cchPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentView )( 
            __RPC__in IOpenControlPanel * This,
            /* [out] */ __RPC__out CPVIEW *pView);
        
        END_INTERFACE
    } IOpenControlPanelVtbl;

    interface IOpenControlPanel
    {
        CONST_VTBL struct IOpenControlPanelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOpenControlPanel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOpenControlPanel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOpenControlPanel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOpenControlPanel_Open(This,pszName,pszPage,punkSite)	\
    ( (This)->lpVtbl -> Open(This,pszName,pszPage,punkSite) ) 

#define IOpenControlPanel_GetPath(This,pszName,pszPath,cchPath)	\
    ( (This)->lpVtbl -> GetPath(This,pszName,pszPath,cchPath) ) 

#define IOpenControlPanel_GetCurrentView(This,pView)	\
    ( (This)->lpVtbl -> GetCurrentView(This,pView) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOpenControlPanel_INTERFACE_DEFINED__ */


#ifndef __IComputerInfoChangeNotify_INTERFACE_DEFINED__
#define __IComputerInfoChangeNotify_INTERFACE_DEFINED__

/* interface IComputerInfoChangeNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComputerInfoChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF60D92-6818-46d6-B358-D66170DDE466")
    IComputerInfoChangeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComputerInfoChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComputerInfoChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IComputerInfoChangeNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IComputerInfoChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IComputerInfoChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *ComputerInfoChanged )( 
            __RPC__in IComputerInfoChangeNotify * This);
        
        END_INTERFACE
    } IComputerInfoChangeNotifyVtbl;

    interface IComputerInfoChangeNotify
    {
        CONST_VTBL struct IComputerInfoChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComputerInfoChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComputerInfoChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComputerInfoChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComputerInfoChangeNotify_ComputerInfoChanged(This)	\
    ( (This)->lpVtbl -> ComputerInfoChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComputerInfoChangeNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0186 */
/* [local] */ 

#define STR_FILE_SYS_BIND_DATA      L"File System Bind Data"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0186_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0186_v0_0_s_ifspec;

#ifndef __IFileSystemBindData_INTERFACE_DEFINED__
#define __IFileSystemBindData_INTERFACE_DEFINED__

/* interface IFileSystemBindData */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSystemBindData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01E18D10-4D8B-11d2-855D-006008059367")
    IFileSystemBindData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFindData( 
            /* [in] */ const WIN32_FIND_DATAW *pfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFindData( 
            /* [out] */ WIN32_FIND_DATAW *pfd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemBindDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSystemBindData * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSystemBindData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSystemBindData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFindData )( 
            IFileSystemBindData * This,
            /* [in] */ const WIN32_FIND_DATAW *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFindData )( 
            IFileSystemBindData * This,
            /* [out] */ WIN32_FIND_DATAW *pfd);
        
        END_INTERFACE
    } IFileSystemBindDataVtbl;

    interface IFileSystemBindData
    {
        CONST_VTBL struct IFileSystemBindDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemBindData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemBindData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemBindData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemBindData_SetFindData(This,pfd)	\
    ( (This)->lpVtbl -> SetFindData(This,pfd) ) 

#define IFileSystemBindData_GetFindData(This,pfd)	\
    ( (This)->lpVtbl -> GetFindData(This,pfd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemBindData_INTERFACE_DEFINED__ */


#ifndef __IFileSystemBindData2_INTERFACE_DEFINED__
#define __IFileSystemBindData2_INTERFACE_DEFINED__

/* interface IFileSystemBindData2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSystemBindData2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3acf075f-71db-4afa-81f0-3fc4fdf2a5b8")
    IFileSystemBindData2 : public IFileSystemBindData
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFileID( 
            /* [in] */ LARGE_INTEGER liFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileID( 
            /* [out] */ LARGE_INTEGER *pliFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJunctionCLSID( 
            /* [in] */ REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJunctionCLSID( 
            /* [out] */ CLSID *pclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemBindData2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSystemBindData2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSystemBindData2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSystemBindData2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFindData )( 
            IFileSystemBindData2 * This,
            /* [in] */ const WIN32_FIND_DATAW *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFindData )( 
            IFileSystemBindData2 * This,
            /* [out] */ WIN32_FIND_DATAW *pfd);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileID )( 
            IFileSystemBindData2 * This,
            /* [in] */ LARGE_INTEGER liFileID);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileID )( 
            IFileSystemBindData2 * This,
            /* [out] */ LARGE_INTEGER *pliFileID);
        
        HRESULT ( STDMETHODCALLTYPE *SetJunctionCLSID )( 
            IFileSystemBindData2 * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetJunctionCLSID )( 
            IFileSystemBindData2 * This,
            /* [out] */ CLSID *pclsid);
        
        END_INTERFACE
    } IFileSystemBindData2Vtbl;

    interface IFileSystemBindData2
    {
        CONST_VTBL struct IFileSystemBindData2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemBindData2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemBindData2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemBindData2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemBindData2_SetFindData(This,pfd)	\
    ( (This)->lpVtbl -> SetFindData(This,pfd) ) 

#define IFileSystemBindData2_GetFindData(This,pfd)	\
    ( (This)->lpVtbl -> GetFindData(This,pfd) ) 


#define IFileSystemBindData2_SetFileID(This,liFileID)	\
    ( (This)->lpVtbl -> SetFileID(This,liFileID) ) 

#define IFileSystemBindData2_GetFileID(This,pliFileID)	\
    ( (This)->lpVtbl -> GetFileID(This,pliFileID) ) 

#define IFileSystemBindData2_SetJunctionCLSID(This,clsid)	\
    ( (This)->lpVtbl -> SetJunctionCLSID(This,clsid) ) 

#define IFileSystemBindData2_GetJunctionCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetJunctionCLSID(This,pclsid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemBindData2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0188 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0188_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0188_v0_0_s_ifspec;

#ifndef __ICustomDestinationList_INTERFACE_DEFINED__
#define __ICustomDestinationList_INTERFACE_DEFINED__

/* interface ICustomDestinationList */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum KNOWNDESTCATEGORY
    {	KDC_FREQUENT	= 1,
	KDC_RECENT	= ( KDC_FREQUENT + 1 ) 
    } 	KNOWNDESTCATEGORY;


EXTERN_C const IID IID_ICustomDestinationList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6332debf-87b5-4670-90c0-5e57b408a49e")
    ICustomDestinationList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAppID( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginList( 
            /* [out] */ __RPC__out UINT *pcMinSlots,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendCategory( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszCategory,
            /* [in] */ __RPC__in_opt IObjectArray *poa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendKnownCategory( 
            /* [in] */ KNOWNDESTCATEGORY category) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUserTasks( 
            /* [in] */ __RPC__in_opt IObjectArray *poa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitList( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemovedDestinations( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteList( 
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszAppID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICustomDestinationListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICustomDestinationList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICustomDestinationList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICustomDestinationList * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppID )( 
            __RPC__in ICustomDestinationList * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppID);
        
        HRESULT ( STDMETHODCALLTYPE *BeginList )( 
            __RPC__in ICustomDestinationList * This,
            /* [out] */ __RPC__out UINT *pcMinSlots,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *AppendCategory )( 
            __RPC__in ICustomDestinationList * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszCategory,
            /* [in] */ __RPC__in_opt IObjectArray *poa);
        
        HRESULT ( STDMETHODCALLTYPE *AppendKnownCategory )( 
            __RPC__in ICustomDestinationList * This,
            /* [in] */ KNOWNDESTCATEGORY category);
        
        HRESULT ( STDMETHODCALLTYPE *AddUserTasks )( 
            __RPC__in ICustomDestinationList * This,
            /* [in] */ __RPC__in_opt IObjectArray *poa);
        
        HRESULT ( STDMETHODCALLTYPE *CommitList )( 
            __RPC__in ICustomDestinationList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemovedDestinations )( 
            __RPC__in ICustomDestinationList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteList )( 
            __RPC__in ICustomDestinationList * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszAppID);
        
        HRESULT ( STDMETHODCALLTYPE *AbortList )( 
            __RPC__in ICustomDestinationList * This);
        
        END_INTERFACE
    } ICustomDestinationListVtbl;

    interface ICustomDestinationList
    {
        CONST_VTBL struct ICustomDestinationListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICustomDestinationList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICustomDestinationList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICustomDestinationList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICustomDestinationList_SetAppID(This,pszAppID)	\
    ( (This)->lpVtbl -> SetAppID(This,pszAppID) ) 

#define ICustomDestinationList_BeginList(This,pcMinSlots,riid,ppv)	\
    ( (This)->lpVtbl -> BeginList(This,pcMinSlots,riid,ppv) ) 

#define ICustomDestinationList_AppendCategory(This,pszCategory,poa)	\
    ( (This)->lpVtbl -> AppendCategory(This,pszCategory,poa) ) 

#define ICustomDestinationList_AppendKnownCategory(This,category)	\
    ( (This)->lpVtbl -> AppendKnownCategory(This,category) ) 

#define ICustomDestinationList_AddUserTasks(This,poa)	\
    ( (This)->lpVtbl -> AddUserTasks(This,poa) ) 

#define ICustomDestinationList_CommitList(This)	\
    ( (This)->lpVtbl -> CommitList(This) ) 

#define ICustomDestinationList_GetRemovedDestinations(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetRemovedDestinations(This,riid,ppv) ) 

#define ICustomDestinationList_DeleteList(This,pszAppID)	\
    ( (This)->lpVtbl -> DeleteList(This,pszAppID) ) 

#define ICustomDestinationList_AbortList(This)	\
    ( (This)->lpVtbl -> AbortList(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICustomDestinationList_INTERFACE_DEFINED__ */


#ifndef __IApplicationDestinations_INTERFACE_DEFINED__
#define __IApplicationDestinations_INTERFACE_DEFINED__

/* interface IApplicationDestinations */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IApplicationDestinations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12337d35-94c6-48a0-bce7-6a9c69d4d600")
    IApplicationDestinations : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAppID( 
            /* [in] */ __RPC__in LPCWSTR pszAppID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveDestination( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllDestinations( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationDestinationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IApplicationDestinations * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IApplicationDestinations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IApplicationDestinations * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppID )( 
            __RPC__in IApplicationDestinations * This,
            /* [in] */ __RPC__in LPCWSTR pszAppID);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDestination )( 
            __RPC__in IApplicationDestinations * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllDestinations )( 
            __RPC__in IApplicationDestinations * This);
        
        END_INTERFACE
    } IApplicationDestinationsVtbl;

    interface IApplicationDestinations
    {
        CONST_VTBL struct IApplicationDestinationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationDestinations_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationDestinations_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationDestinations_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationDestinations_SetAppID(This,pszAppID)	\
    ( (This)->lpVtbl -> SetAppID(This,pszAppID) ) 

#define IApplicationDestinations_RemoveDestination(This,punk)	\
    ( (This)->lpVtbl -> RemoveDestination(This,punk) ) 

#define IApplicationDestinations_RemoveAllDestinations(This)	\
    ( (This)->lpVtbl -> RemoveAllDestinations(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationDestinations_INTERFACE_DEFINED__ */


#ifndef __IApplicationDocumentLists_INTERFACE_DEFINED__
#define __IApplicationDocumentLists_INTERFACE_DEFINED__

/* interface IApplicationDocumentLists */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum APPDOCLISTTYPE
    {	ADLT_RECENT	= 0,
	ADLT_FREQUENT	= ( ADLT_RECENT + 1 ) 
    } 	APPDOCLISTTYPE;


EXTERN_C const IID IID_IApplicationDocumentLists;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3c594f9f-9f30-47a1-979a-c9e83d3d0a06")
    IApplicationDocumentLists : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAppID( 
            /* [in] */ __RPC__in LPCWSTR pszAppID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetList( 
            /* [in] */ APPDOCLISTTYPE listtype,
            /* [in] */ UINT cItemsDesired,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationDocumentListsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IApplicationDocumentLists * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IApplicationDocumentLists * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IApplicationDocumentLists * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppID )( 
            __RPC__in IApplicationDocumentLists * This,
            /* [in] */ __RPC__in LPCWSTR pszAppID);
        
        HRESULT ( STDMETHODCALLTYPE *GetList )( 
            __RPC__in IApplicationDocumentLists * This,
            /* [in] */ APPDOCLISTTYPE listtype,
            /* [in] */ UINT cItemsDesired,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IApplicationDocumentListsVtbl;

    interface IApplicationDocumentLists
    {
        CONST_VTBL struct IApplicationDocumentListsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationDocumentLists_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApplicationDocumentLists_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApplicationDocumentLists_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApplicationDocumentLists_SetAppID(This,pszAppID)	\
    ( (This)->lpVtbl -> SetAppID(This,pszAppID) ) 

#define IApplicationDocumentLists_GetList(This,listtype,cItemsDesired,riid,ppv)	\
    ( (This)->lpVtbl -> GetList(This,listtype,cItemsDesired,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApplicationDocumentLists_INTERFACE_DEFINED__ */


#ifndef __IObjectWithAppUserModelID_INTERFACE_DEFINED__
#define __IObjectWithAppUserModelID_INTERFACE_DEFINED__

/* interface IObjectWithAppUserModelID */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IObjectWithAppUserModelID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36db0196-9665-46d1-9ba7-d3709eecf9ed")
    IObjectWithAppUserModelID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAppID( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppID( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAppID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithAppUserModelIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectWithAppUserModelID * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectWithAppUserModelID * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectWithAppUserModelID * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppID )( 
            __RPC__in IObjectWithAppUserModelID * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszAppID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppID )( 
            __RPC__in IObjectWithAppUserModelID * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszAppID);
        
        END_INTERFACE
    } IObjectWithAppUserModelIDVtbl;

    interface IObjectWithAppUserModelID
    {
        CONST_VTBL struct IObjectWithAppUserModelIDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithAppUserModelID_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithAppUserModelID_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithAppUserModelID_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithAppUserModelID_SetAppID(This,pszAppID)	\
    ( (This)->lpVtbl -> SetAppID(This,pszAppID) ) 

#define IObjectWithAppUserModelID_GetAppID(This,ppszAppID)	\
    ( (This)->lpVtbl -> GetAppID(This,ppszAppID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithAppUserModelID_INTERFACE_DEFINED__ */


#ifndef __IObjectWithProgID_INTERFACE_DEFINED__
#define __IObjectWithProgID_INTERFACE_DEFINED__

/* interface IObjectWithProgID */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IObjectWithProgID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71e806fb-8dee-46fc-bf8c-7748a8a1ae13")
    IObjectWithProgID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProgID( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszProgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgID( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithProgIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectWithProgID * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectWithProgID * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectWithProgID * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgID )( 
            __RPC__in IObjectWithProgID * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszProgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgID )( 
            __RPC__in IObjectWithProgID * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszProgID);
        
        END_INTERFACE
    } IObjectWithProgIDVtbl;

    interface IObjectWithProgID
    {
        CONST_VTBL struct IObjectWithProgIDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithProgID_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithProgID_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithProgID_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithProgID_SetProgID(This,pszProgID)	\
    ( (This)->lpVtbl -> SetProgID(This,pszProgID) ) 

#define IObjectWithProgID_GetProgID(This,ppszProgID)	\
    ( (This)->lpVtbl -> GetProgID(This,ppszProgID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithProgID_INTERFACE_DEFINED__ */


#ifndef __IUpdateIDList_INTERFACE_DEFINED__
#define __IUpdateIDList_INTERFACE_DEFINED__

/* interface IUpdateIDList */
/* [object][unique][local][uuid] */ 


EXTERN_C const IID IID_IUpdateIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6589b6d2-5f8d-4b9e-b7e0-23cdd9717d8c")
    IUpdateIDList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [annotation][unique][in] */ 
            __in_opt  IBindCtx *pbc,
            /* [annotation][in] */ 
            __in  PCUITEMID_CHILD pidlIn,
            /* [annotation][out] */ 
            __deref_out  PITEMID_CHILD *ppidlOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateIDList * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IUpdateIDList * This,
            /* [annotation][unique][in] */ 
            __in_opt  IBindCtx *pbc,
            /* [annotation][in] */ 
            __in  PCUITEMID_CHILD pidlIn,
            /* [annotation][out] */ 
            __deref_out  PITEMID_CHILD *ppidlOut);
        
        END_INTERFACE
    } IUpdateIDListVtbl;

    interface IUpdateIDList
    {
        CONST_VTBL struct IUpdateIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateIDList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateIDList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateIDList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateIDList_Update(This,pbc,pidlIn,ppidlOut)	\
    ( (This)->lpVtbl -> Update(This,pbc,pidlIn,ppidlOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0194 */
/* [local] */ 

SHSTDAPI SetCurrentProcessExplicitAppUserModelID(__in PCWSTR AppID);
SHSTDAPI GetCurrentProcessExplicitAppUserModelID(__deref_out PWSTR *AppID);
#endif // NTDDI_WIN7


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0194_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0194_v0_0_s_ifspec;

#ifndef __IDesktopGadget_INTERFACE_DEFINED__
#define __IDesktopGadget_INTERFACE_DEFINED__

/* interface IDesktopGadget */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDesktopGadget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1646bc4-f298-4f91-a204-eb2dd1709d1a")
    IDesktopGadget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RunGadget( 
            /* [in] */ __RPC__in LPCWSTR gadgetPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDesktopGadgetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDesktopGadget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDesktopGadget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDesktopGadget * This);
        
        HRESULT ( STDMETHODCALLTYPE *RunGadget )( 
            __RPC__in IDesktopGadget * This,
            /* [in] */ __RPC__in LPCWSTR gadgetPath);
        
        END_INTERFACE
    } IDesktopGadgetVtbl;

    interface IDesktopGadget
    {
        CONST_VTBL struct IDesktopGadgetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDesktopGadget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDesktopGadget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDesktopGadget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDesktopGadget_RunGadget(This,gadgetPath)	\
    ( (This)->lpVtbl -> RunGadget(This,gadgetPath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDesktopGadget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0195 */
/* [local] */ 

#define HOMEGROUP_SECURITY_GROUP L"HomeUsers"


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0195_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0195_v0_0_s_ifspec;

#ifndef __IHomeGroup_INTERFACE_DEFINED__
#define __IHomeGroup_INTERFACE_DEFINED__

/* interface IHomeGroup */
/* [local][object][uuid] */ 

typedef /* [v1_enum] */ 
enum HOMEGROUPSHARINGCHOICES
    {	HGSC_NONE	= 0,
	HGSC_MUSICLIBRARY	= 0x1,
	HGSC_PICTURESLIBRARY	= 0x2,
	HGSC_VIDEOSLIBRARY	= 0x4,
	HGSC_DOCUMENTSLIBRARY	= 0x8,
	HGSC_PRINTERS	= 0x10
    } 	HOMEGROUPSHARINGCHOICES;

DEFINE_ENUM_FLAG_OPERATORS(HOMEGROUPSHARINGCHOICES)

EXTERN_C const IID IID_IHomeGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a3bd1d9-35a9-4fb3-a467-f48cac35e2d0")
    IHomeGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsMember( 
            /* [out] */ BOOL *member) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSharingWizard( 
            /* [in] */ HWND owner,
            /* [out] */ HOMEGROUPSHARINGCHOICES *sharingchoices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHomeGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHomeGroup * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHomeGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHomeGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsMember )( 
            IHomeGroup * This,
            /* [out] */ BOOL *member);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSharingWizard )( 
            IHomeGroup * This,
            /* [in] */ HWND owner,
            /* [out] */ HOMEGROUPSHARINGCHOICES *sharingchoices);
        
        END_INTERFACE
    } IHomeGroupVtbl;

    interface IHomeGroup
    {
        CONST_VTBL struct IHomeGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHomeGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHomeGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHomeGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHomeGroup_IsMember(This,member)	\
    ( (This)->lpVtbl -> IsMember(This,member) ) 

#define IHomeGroup_ShowSharingWizard(This,owner,sharingchoices)	\
    ( (This)->lpVtbl -> ShowSharingWizard(This,owner,sharingchoices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHomeGroup_INTERFACE_DEFINED__ */


#ifndef __IInitializeWithPropertyStore_INTERFACE_DEFINED__
#define __IInitializeWithPropertyStore_INTERFACE_DEFINED__

/* interface IInitializeWithPropertyStore */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IInitializeWithPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3E12EB5-7D8D-44f8-B6DD-0E77B34D6DE4")
    IInitializeWithPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IPropertyStore *pps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeWithPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeWithPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeWithPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IInitializeWithPropertyStore * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pps);
        
        END_INTERFACE
    } IInitializeWithPropertyStoreVtbl;

    interface IInitializeWithPropertyStore
    {
        CONST_VTBL struct IInitializeWithPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithPropertyStore_Initialize(This,pps)	\
    ( (This)->lpVtbl -> Initialize(This,pps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithPropertyStore_INTERFACE_DEFINED__ */


#ifndef __IOpenSearchSource_INTERFACE_DEFINED__
#define __IOpenSearchSource_INTERFACE_DEFINED__

/* interface IOpenSearchSource */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IOpenSearchSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0EE7333-E6FC-479b-9F25-A860C234A38E")
    IOpenSearchSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResults( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in LPCWSTR pszQuery,
            /* [in] */ DWORD dwStartIndex,
            /* [in] */ DWORD dwCount,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOpenSearchSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOpenSearchSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOpenSearchSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOpenSearchSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResults )( 
            __RPC__in IOpenSearchSource * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in LPCWSTR pszQuery,
            /* [in] */ DWORD dwStartIndex,
            /* [in] */ DWORD dwCount,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IOpenSearchSourceVtbl;

    interface IOpenSearchSource
    {
        CONST_VTBL struct IOpenSearchSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOpenSearchSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOpenSearchSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOpenSearchSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOpenSearchSource_GetResults(This,hwnd,pszQuery,dwStartIndex,dwCount,riid,ppv)	\
    ( (This)->lpVtbl -> GetResults(This,hwnd,pszQuery,dwStartIndex,dwCount,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOpenSearchSource_INTERFACE_DEFINED__ */


#ifndef __IShellLibrary_INTERFACE_DEFINED__
#define __IShellLibrary_INTERFACE_DEFINED__

/* interface IShellLibrary */
/* [unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum LIBRARYFOLDERFILTER
    {	LFF_FORCEFILESYSTEM	= 1,
	LFF_STORAGEITEMS	= 2,
	LFF_ALLITEMS	= 3
    } 	LIBRARYFOLDERFILTER;

typedef /* [v1_enum] */ 
enum LIBRARYOPTIONFLAGS
    {	LOF_DEFAULT	= 0,
	LOF_PINNEDTONAVPANE	= 0x1,
	LOF_MASK_ALL	= 0x1
    } 	LIBRARYOPTIONFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(LIBRARYOPTIONFLAGS)
typedef /* [v1_enum] */ 
enum DEFAULTSAVEFOLDERTYPE
    {	DSFT_DETECT	= 1,
	DSFT_PRIVATE	= ( DSFT_DETECT + 1 ) ,
	DSFT_PUBLIC	= ( DSFT_PRIVATE + 1 ) 
    } 	DEFAULTSAVEFOLDERTYPE;

typedef /* [v1_enum] */ 
enum LIBRARYSAVEFLAGS
    {	LSF_FAILIFTHERE	= 0,
	LSF_OVERRIDEEXISTING	= 0x1,
	LSF_MAKEUNIQUENAME	= 0x2
    } 	LIBRARYSAVEFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(LIBRARYSAVEFLAGS)

EXTERN_C const IID IID_IShellLibrary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11a66efa-382e-451a-9234-1e0e12ef3085")
    IShellLibrary : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadLibraryFromItem( 
            /* [in] */ __RPC__in_opt IShellItem *psiLibrary,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadLibraryFromKnownFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID kfidLibrary,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psiLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psiLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolders( 
            /* [in] */ LIBRARYFOLDERFILTER lff,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveFolder( 
            /* [in] */ __RPC__in_opt IShellItem *psiFolderToResolve,
            /* [in] */ DWORD dwTimeout,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSaveFolder( 
            /* [in] */ DEFAULTSAVEFOLDERTYPE dsft,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSaveFolder( 
            /* [in] */ DEFAULTSAVEFOLDERTYPE dsft,
            /* [in] */ __RPC__in_opt IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ __RPC__out LIBRARYOPTIONFLAGS *plofOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ LIBRARYOPTIONFLAGS lofMask,
            /* [in] */ LIBRARYOPTIONFLAGS lofOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderType( 
            /* [out] */ __RPC__out FOLDERTYPEID *pftid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFolderType( 
            /* [in] */ __RPC__in REFFOLDERTYPEID ftid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ __RPC__in_opt IShellItem *psiFolderToSaveIn,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLibraryName,
            /* [in] */ LIBRARYSAVEFLAGS lsf,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiSavedTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveInKnownFolder( 
            /* [in] */ __RPC__in REFKNOWNFOLDERID kfidToSaveIn,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLibraryName,
            /* [in] */ LIBRARYSAVEFLAGS lsf,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiSavedTo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLibraryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IShellLibrary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IShellLibrary * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadLibraryFromItem )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in_opt IShellItem *psiLibrary,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *LoadLibraryFromKnownFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID kfidLibrary,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *AddFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in_opt IShellItem *psiLocation);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in_opt IShellItem *psiLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolders )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ LIBRARYFOLDERFILTER lff,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in_opt IShellItem *psiFolderToResolve,
            /* [in] */ DWORD dwTimeout,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSaveFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ DEFAULTSAVEFOLDERTYPE dsft,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSaveFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ DEFAULTSAVEFOLDERTYPE dsft,
            /* [in] */ __RPC__in_opt IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            __RPC__in IShellLibrary * This,
            /* [out] */ __RPC__out LIBRARYOPTIONFLAGS *plofOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ LIBRARYOPTIONFLAGS lofMask,
            /* [in] */ LIBRARYOPTIONFLAGS lofOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderType )( 
            __RPC__in IShellLibrary * This,
            /* [out] */ __RPC__out FOLDERTYPEID *pftid);
        
        HRESULT ( STDMETHODCALLTYPE *SetFolderType )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in REFFOLDERTYPEID ftid);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            __RPC__in IShellLibrary * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIcon )( 
            __RPC__in IShellLibrary * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IShellLibrary * This);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in_opt IShellItem *psiFolderToSaveIn,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLibraryName,
            /* [in] */ LIBRARYSAVEFLAGS lsf,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiSavedTo);
        
        HRESULT ( STDMETHODCALLTYPE *SaveInKnownFolder )( 
            __RPC__in IShellLibrary * This,
            /* [in] */ __RPC__in REFKNOWNFOLDERID kfidToSaveIn,
            /* [string][in] */ __RPC__in_string LPCWSTR pszLibraryName,
            /* [in] */ LIBRARYSAVEFLAGS lsf,
            /* [out] */ __RPC__deref_out_opt IShellItem **ppsiSavedTo);
        
        END_INTERFACE
    } IShellLibraryVtbl;

    interface IShellLibrary
    {
        CONST_VTBL struct IShellLibraryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLibrary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IShellLibrary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IShellLibrary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IShellLibrary_LoadLibraryFromItem(This,psiLibrary,grfMode)	\
    ( (This)->lpVtbl -> LoadLibraryFromItem(This,psiLibrary,grfMode) ) 

#define IShellLibrary_LoadLibraryFromKnownFolder(This,kfidLibrary,grfMode)	\
    ( (This)->lpVtbl -> LoadLibraryFromKnownFolder(This,kfidLibrary,grfMode) ) 

#define IShellLibrary_AddFolder(This,psiLocation)	\
    ( (This)->lpVtbl -> AddFolder(This,psiLocation) ) 

#define IShellLibrary_RemoveFolder(This,psiLocation)	\
    ( (This)->lpVtbl -> RemoveFolder(This,psiLocation) ) 

#define IShellLibrary_GetFolders(This,lff,riid,ppv)	\
    ( (This)->lpVtbl -> GetFolders(This,lff,riid,ppv) ) 

#define IShellLibrary_ResolveFolder(This,psiFolderToResolve,dwTimeout,riid,ppv)	\
    ( (This)->lpVtbl -> ResolveFolder(This,psiFolderToResolve,dwTimeout,riid,ppv) ) 

#define IShellLibrary_GetDefaultSaveFolder(This,dsft,riid,ppv)	\
    ( (This)->lpVtbl -> GetDefaultSaveFolder(This,dsft,riid,ppv) ) 

#define IShellLibrary_SetDefaultSaveFolder(This,dsft,psi)	\
    ( (This)->lpVtbl -> SetDefaultSaveFolder(This,dsft,psi) ) 

#define IShellLibrary_GetOptions(This,plofOptions)	\
    ( (This)->lpVtbl -> GetOptions(This,plofOptions) ) 

#define IShellLibrary_SetOptions(This,lofMask,lofOptions)	\
    ( (This)->lpVtbl -> SetOptions(This,lofMask,lofOptions) ) 

#define IShellLibrary_GetFolderType(This,pftid)	\
    ( (This)->lpVtbl -> GetFolderType(This,pftid) ) 

#define IShellLibrary_SetFolderType(This,ftid)	\
    ( (This)->lpVtbl -> SetFolderType(This,ftid) ) 

#define IShellLibrary_GetIcon(This,ppszIcon)	\
    ( (This)->lpVtbl -> GetIcon(This,ppszIcon) ) 

#define IShellLibrary_SetIcon(This,pszIcon)	\
    ( (This)->lpVtbl -> SetIcon(This,pszIcon) ) 

#define IShellLibrary_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IShellLibrary_Save(This,psiFolderToSaveIn,pszLibraryName,lsf,ppsiSavedTo)	\
    ( (This)->lpVtbl -> Save(This,psiFolderToSaveIn,pszLibraryName,lsf,ppsiSavedTo) ) 

#define IShellLibrary_SaveInKnownFolder(This,kfidToSaveIn,pszLibraryName,lsf,ppsiSavedTo)	\
    ( (This)->lpVtbl -> SaveInKnownFolder(This,kfidToSaveIn,pszLibraryName,lsf,ppsiSavedTo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IShellLibrary_INTERFACE_DEFINED__ */



#ifndef __ShellObjects_LIBRARY_DEFINED__
#define __ShellObjects_LIBRARY_DEFINED__

/* library ShellObjects */
/* [version][lcid][uuid] */ 

#define SID_PublishingWizard CLSID_PublishingWizard

EXTERN_C const IID LIBID_ShellObjects;

EXTERN_C const CLSID CLSID_ShellDesktop;

#ifdef __cplusplus

class DECLSPEC_UUID("00021400-0000-0000-C000-000000000046")
ShellDesktop;
#endif

EXTERN_C const CLSID CLSID_ShellFSFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("F3364BA0-65B9-11CE-A9BA-00AA004AE837")
ShellFSFolder;
#endif

EXTERN_C const CLSID CLSID_NetworkPlaces;

#ifdef __cplusplus

class DECLSPEC_UUID("208D2C60-3AEA-1069-A2D7-08002B30309D")
NetworkPlaces;
#endif

EXTERN_C const CLSID CLSID_ShellLink;

#ifdef __cplusplus

class DECLSPEC_UUID("00021401-0000-0000-C000-000000000046")
ShellLink;
#endif

EXTERN_C const CLSID CLSID_QueryCancelAutoPlay;

#ifdef __cplusplus

class DECLSPEC_UUID("331F1768-05A9-4ddd-B86E-DAE34DDC998A")
QueryCancelAutoPlay;
#endif

EXTERN_C const CLSID CLSID_DriveSizeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("94357B53-CA29-4b78-83AE-E8FE7409134F")
DriveSizeCategorizer;
#endif

EXTERN_C const CLSID CLSID_DriveTypeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("B0A8F3CF-4333-4bab-8873-1CCB1CADA48B")
DriveTypeCategorizer;
#endif

EXTERN_C const CLSID CLSID_FreeSpaceCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("B5607793-24AC-44c7-82E2-831726AA6CB7")
FreeSpaceCategorizer;
#endif

EXTERN_C const CLSID CLSID_TimeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3bb4118f-ddfd-4d30-a348-9fb5d6bf1afe")
TimeCategorizer;
#endif

EXTERN_C const CLSID CLSID_SizeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("55d7b852-f6d1-42f2-aa75-8728a1b2d264")
SizeCategorizer;
#endif

EXTERN_C const CLSID CLSID_AlphabeticalCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3c2654c6-7372-4f6b-b310-55d6128f49d2")
AlphabeticalCategorizer;
#endif

EXTERN_C const CLSID CLSID_MergedCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8e827c11-33e7-4bc1-b242-8cd9a1c2b304")
MergedCategorizer;
#endif

EXTERN_C const CLSID CLSID_ImageProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("7ab770c7-0e23-4d7a-8aa2-19bfad479829")
ImageProperties;
#endif

EXTERN_C const CLSID CLSID_PropertiesUI;

#ifdef __cplusplus

class DECLSPEC_UUID("d912f8cf-0396-4915-884e-fb425d32943b")
PropertiesUI;
#endif

EXTERN_C const CLSID CLSID_UserNotification;

#ifdef __cplusplus

class DECLSPEC_UUID("0010890e-8789-413c-adbc-48f5b511b3af")
UserNotification;
#endif

EXTERN_C const CLSID CLSID_CDBurn;

#ifdef __cplusplus

class DECLSPEC_UUID("fbeb8a05-beee-4442-804e-409d6c4515e9")
CDBurn;
#endif

EXTERN_C const CLSID CLSID_TaskbarList;

#ifdef __cplusplus

class DECLSPEC_UUID("56FDF344-FD6D-11d0-958A-006097C9A090")
TaskbarList;
#endif

EXTERN_C const CLSID CLSID_StartMenuPin;

#ifdef __cplusplus

class DECLSPEC_UUID("a2a9545d-a0c2-42b4-9708-a0b2badd77c8")
StartMenuPin;
#endif

EXTERN_C const CLSID CLSID_WebWizardHost;

#ifdef __cplusplus

class DECLSPEC_UUID("c827f149-55c1-4d28-935e-57e47caed973")
WebWizardHost;
#endif

EXTERN_C const CLSID CLSID_PublishDropTarget;

#ifdef __cplusplus

class DECLSPEC_UUID("CC6EEFFB-43F6-46c5-9619-51D571967F7D")
PublishDropTarget;
#endif

EXTERN_C const CLSID CLSID_PublishingWizard;

#ifdef __cplusplus

class DECLSPEC_UUID("6b33163c-76a5-4b6c-bf21-45de9cd503a1")
PublishingWizard;
#endif

EXTERN_C const CLSID CLSID_InternetPrintOrdering;

#ifdef __cplusplus

class DECLSPEC_UUID("add36aa8-751a-4579-a266-d66f5202ccbb")
InternetPrintOrdering;
#endif

EXTERN_C const CLSID CLSID_FolderViewHost;

#ifdef __cplusplus

class DECLSPEC_UUID("20b1cb23-6968-4eb9-b7d4-a66d00d07cee")
FolderViewHost;
#endif

EXTERN_C const CLSID CLSID_ExplorerBrowser;

#ifdef __cplusplus

class DECLSPEC_UUID("71f96385-ddd6-48d3-a0c1-ae06e8b055fb")
ExplorerBrowser;
#endif

EXTERN_C const CLSID CLSID_ImageRecompress;

#ifdef __cplusplus

class DECLSPEC_UUID("6e33091c-d2f8-4740-b55e-2e11d1477a2c")
ImageRecompress;
#endif

EXTERN_C const CLSID CLSID_TrayBandSiteService;

#ifdef __cplusplus

class DECLSPEC_UUID("F60AD0A0-E5E1-45cb-B51A-E15B9F8B2934")
TrayBandSiteService;
#endif

EXTERN_C const CLSID CLSID_TrayDeskBand;

#ifdef __cplusplus

class DECLSPEC_UUID("E6442437-6C68-4f52-94DD-2CFED267EFB9")
TrayDeskBand;
#endif

EXTERN_C const CLSID CLSID_AttachmentServices;

#ifdef __cplusplus

class DECLSPEC_UUID("4125dd96-e03a-4103-8f70-e0597d803b9c")
AttachmentServices;
#endif

EXTERN_C const CLSID CLSID_DocPropShellExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("883373C3-BF89-11D1-BE35-080036B11A03")
DocPropShellExtension;
#endif

EXTERN_C const CLSID CLSID_ShellItem;

#ifdef __cplusplus

class DECLSPEC_UUID("9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917")
ShellItem;
#endif

EXTERN_C const CLSID CLSID_NamespaceWalker;

#ifdef __cplusplus

class DECLSPEC_UUID("72eb61e0-8672-4303-9175-f2e4c68b2e7c")
NamespaceWalker;
#endif

EXTERN_C const CLSID CLSID_FileOperation;

#ifdef __cplusplus

class DECLSPEC_UUID("3ad05575-8857-4850-9277-11b85bdb8e09")
FileOperation;
#endif

EXTERN_C const CLSID CLSID_FileOpenDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7")
FileOpenDialog;
#endif

EXTERN_C const CLSID CLSID_FileSaveDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("C0B4E2F3-BA21-4773-8DBA-335EC946EB8B")
FileSaveDialog;
#endif

EXTERN_C const CLSID CLSID_KnownFolderManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4df0c730-df9d-4ae3-9153-aa6b82e9795a")
KnownFolderManager;
#endif

EXTERN_C const CLSID CLSID_FSCopyHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("D197380A-0A79-4dc8-A033-ED882C2FA14B")
FSCopyHandler;
#endif

EXTERN_C const CLSID CLSID_SharingConfigurationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("49F371E1-8C5C-4d9c-9A3B-54A6827F513C")
SharingConfigurationManager;
#endif

EXTERN_C const CLSID CLSID_PreviousVersions;

#ifdef __cplusplus

class DECLSPEC_UUID("596AB062-B4D2-4215-9F74-E9109B0A8153")
PreviousVersions;
#endif

EXTERN_C const CLSID CLSID_NetworkConnections;

#ifdef __cplusplus

class DECLSPEC_UUID("7007ACC7-3202-11D1-AAD2-00805FC1270E")
NetworkConnections;
#endif

EXTERN_C const CLSID CLSID_NamespaceTreeControl;

#ifdef __cplusplus

class DECLSPEC_UUID("AE054212-3535-4430-83ED-D501AA6680E6")
NamespaceTreeControl;
#endif

EXTERN_C const CLSID CLSID_IENamespaceTreeControl;

#ifdef __cplusplus

class DECLSPEC_UUID("ACE52D03-E5CD-4b20-82FF-E71B11BEAE1D")
IENamespaceTreeControl;
#endif

EXTERN_C const CLSID CLSID_ScheduledTasks;

#ifdef __cplusplus

class DECLSPEC_UUID("D6277990-4C6A-11CF-8D87-00AA0060F5BF")
ScheduledTasks;
#endif

EXTERN_C const CLSID CLSID_ApplicationAssociationRegistration;

#ifdef __cplusplus

class DECLSPEC_UUID("591209c7-767b-42b2-9fba-44ee4615f2c7")
ApplicationAssociationRegistration;
#endif

EXTERN_C const CLSID CLSID_ApplicationAssociationRegistrationUI;

#ifdef __cplusplus

class DECLSPEC_UUID("1968106d-f3b5-44cf-890e-116fcb9ecef1")
ApplicationAssociationRegistrationUI;
#endif

EXTERN_C const CLSID CLSID_SearchFolderItemFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("14010e02-bbbd-41f0-88e3-eda371216584")
SearchFolderItemFactory;
#endif

EXTERN_C const CLSID CLSID_OpenControlPanel;

#ifdef __cplusplus

class DECLSPEC_UUID("06622D85-6856-4460-8DE1-A81921B41C4B")
OpenControlPanel;
#endif

EXTERN_C const CLSID CLSID_MailRecipient;

#ifdef __cplusplus

class DECLSPEC_UUID("9E56BE60-C50F-11CF-9A2C-00A0C90A90CE")
MailRecipient;
#endif

EXTERN_C const CLSID CLSID_NetworkExplorerFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("F02C1A0D-BE21-4350-88B0-7367FC96EF3C")
NetworkExplorerFolder;
#endif

EXTERN_C const CLSID CLSID_DestinationList;

#ifdef __cplusplus

class DECLSPEC_UUID("77f10cf0-3db5-4966-b520-b7c54fd35ed6")
DestinationList;
#endif

EXTERN_C const CLSID CLSID_ApplicationDestinations;

#ifdef __cplusplus

class DECLSPEC_UUID("86c14003-4d6b-4ef3-a7b4-0506663b2e68")
ApplicationDestinations;
#endif

EXTERN_C const CLSID CLSID_ApplicationDocumentLists;

#ifdef __cplusplus

class DECLSPEC_UUID("86bec222-30f2-47e0-9f25-60d11cd75c28")
ApplicationDocumentLists;
#endif

EXTERN_C const CLSID CLSID_HomeGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("DE77BA04-3C92-4d11-A1A5-42352A53E0E3")
HomeGroup;
#endif

EXTERN_C const CLSID CLSID_ShellLibrary;

#ifdef __cplusplus

class DECLSPEC_UUID("d9b3211d-e57f-4426-aaef-30a806add397")
ShellLibrary;
#endif

EXTERN_C const CLSID CLSID_AppStartupLink;

#ifdef __cplusplus

class DECLSPEC_UUID("273eb5e7-88b0-4843-bfef-e2c81d43aae5")
AppStartupLink;
#endif

EXTERN_C const CLSID CLSID_EnumerableObjectCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("2d3468c1-36a7-43b6-ac24-d3f02fd9607a")
EnumerableObjectCollection;
#endif

EXTERN_C const CLSID CLSID_DesktopGadget;

#ifdef __cplusplus

class DECLSPEC_UUID("924ccc1b-6562-4c85-8657-d177925222b6")
DesktopGadget;
#endif
#endif /* __ShellObjects_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shobjidl_0000_0199 */
/* [local] */ 

#if (NTDDI_VERSION >= NTDDI_VISTA)
SHSTDAPI SHGetTemporaryPropertyForItem(__in IShellItem *psi, __in REFPROPERTYKEY propkey, __out PROPVARIANT *ppropvar);
SHSTDAPI SHSetTemporaryPropertyForItem(__in IShellItem *psi, __in REFPROPERTYKEY propkey, __in REFPROPVARIANT propvar);
#endif  // NTDDI_VISTA
#if (NTDDI_VERSION >= NTDDI_WIN7)
#if (_WIN32_IE >= _WIN32_IE_IE70)
typedef /* [v1_enum] */ 
enum LIBRARYMANAGEDIALOGOPTIONS
    {	LMD_DEFAULT	= 0,
	LMD_ALLOWUNINDEXABLENETWORKLOCATIONS	= 0x1
    } 	LIBRARYMANAGEDIALOGOPTIONS;

DEFINE_ENUM_FLAG_OPERATORS(LIBRARYMANAGEDIALOGOPTIONS)
SHSTDAPI SHShowManageLibraryUI(__in IShellItem *psiLibrary, __in HWND hwndOwner, __in_opt LPCWSTR pszTitle, __in_opt LPCWSTR pszInstruction, __in LIBRARYMANAGEDIALOGOPTIONS lmdOptions);
SHSTDAPI SHResolveLibrary(__in IShellItem *psiLibrary);
#ifdef __cplusplus

__inline HRESULT SHCreateLibrary(__in REFIID riid, __deref_out void **ppv)
{
    return CoCreateInstance(CLSID_ShellLibrary, NULL, CLSCTX_INPROC_SERVER, riid, ppv);
}

__inline HRESULT SHLoadLibraryFromItem(__in IShellItem *psiLibrary, __in DWORD grfMode, __in REFIID riid, __deref_out void **ppv)
{
    *ppv = NULL;
    IShellLibrary *plib;
    HRESULT hr = CoCreateInstance(CLSID_ShellLibrary, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&plib));
    if (SUCCEEDED(hr))
    {
        hr = plib->LoadLibraryFromItem(psiLibrary, grfMode);
        if (SUCCEEDED(hr))
        {
            hr = plib->QueryInterface(riid, ppv);
        }
        plib->Release();
    }
    return hr;
}

__inline HRESULT SHLoadLibraryFromKnownFolder(__in REFKNOWNFOLDERID kfidLibrary, __in DWORD grfMode, __in REFIID riid, __deref_out void **ppv)
{
    *ppv = NULL;
    IShellLibrary *plib;
    HRESULT hr = CoCreateInstance(CLSID_ShellLibrary, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&plib));
    if (SUCCEEDED(hr))
    {
        hr = plib->LoadLibraryFromKnownFolder(kfidLibrary, grfMode);
        if (SUCCEEDED(hr))
        {
            hr = plib->QueryInterface(riid, ppv);
        }
        plib->Release();
    }
    return hr;
}

__inline HRESULT SHLoadLibraryFromParsingName(__in PCWSTR pszParsingName, __in DWORD grfMode, __in REFIID riid, __deref_out void **ppv)
{
    *ppv = NULL;
    IShellItem *psiLibrary;
    HRESULT hr = SHCreateItemFromParsingName(pszParsingName, NULL, IID_PPV_ARGS(&psiLibrary));
    if (SUCCEEDED(hr))
    {
        hr = SHLoadLibraryFromItem(psiLibrary, grfMode, riid, ppv);
        psiLibrary->Release();
    }
    return hr;
}

__inline HRESULT SHAddFolderPathToLibrary(__in IShellLibrary *plib, __in PCWSTR pszFolderPath)
{
    IShellItem *psiFolder;
    HRESULT hr = SHCreateItemFromParsingName(pszFolderPath, NULL, IID_PPV_ARGS(&psiFolder));
    if (SUCCEEDED(hr))
    {
        hr = plib->AddFolder(psiFolder);
        psiFolder->Release();
    }
    return hr;
}

__inline HRESULT SHRemoveFolderPathFromLibrary(__in IShellLibrary *plib, __in PCWSTR pszFolderPath)
{
    PIDLIST_ABSOLUTE pidlFolder = SHSimpleIDListFromPath(pszFolderPath);
    HRESULT hr = pidlFolder ? S_OK : E_INVALIDARG;
    if (SUCCEEDED(hr))
    {
        IShellItem *psiFolder;
        hr = SHCreateItemFromIDList(pidlFolder, IID_PPV_ARGS(&psiFolder));
        if (SUCCEEDED(hr))
        {
            hr = plib->RemoveFolder(psiFolder);
            psiFolder->Release();
        }
        CoTaskMemFree(pidlFolder);
    }
    return hr;
}

__inline HRESULT SHResolveFolderPathInLibrary(__in IShellLibrary *plib, __in PCWSTR pszFolderPath, __in DWORD dwTimeout, __deref_out PWSTR *ppszResolvedPath)
{
    *ppszResolvedPath = NULL;
    PIDLIST_ABSOLUTE pidlFolder = SHSimpleIDListFromPath(pszFolderPath);
    HRESULT hr = pidlFolder ? S_OK : E_INVALIDARG;
    if (SUCCEEDED(hr))
    {
        IShellItem *psiFolder;
        hr = SHCreateItemFromIDList(pidlFolder, IID_PPV_ARGS(&psiFolder));
        if (SUCCEEDED(hr))
        {
            IShellItem *psiResolved;
            hr = plib->ResolveFolder(psiFolder, dwTimeout, IID_PPV_ARGS(&psiResolved));
            if (SUCCEEDED(hr))
            {
                hr = psiResolved->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING, ppszResolvedPath);
                psiResolved->Release();
            }
            psiFolder->Release();
        }
        CoTaskMemFree(pidlFolder);
    }
    return hr;
}

__inline HRESULT SHSaveLibraryInFolderPath(__in IShellLibrary *plib, __in PCWSTR pszFolderPath, __in PCWSTR pszLibraryName, __in LIBRARYSAVEFLAGS lsf, __deref_opt_out PWSTR *ppszSavedToPath)
{
    if (ppszSavedToPath)
    {
        *ppszSavedToPath = NULL;
    }

    IShellItem *psiFolder;
    HRESULT hr = SHCreateItemFromParsingName(pszFolderPath, NULL, IID_PPV_ARGS(&psiFolder));
    if (SUCCEEDED(hr))
    {
        IShellItem *psiSavedTo;
        hr = plib->Save(psiFolder, pszLibraryName, lsf, &psiSavedTo);
        if (SUCCEEDED(hr))
        {
            if (ppszSavedToPath)
            {
                hr = psiSavedTo->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING, ppszSavedToPath);
            }
            psiSavedTo->Release();
        }
        psiFolder->Release();
    }
    return hr;
}
#endif  // __cplusplus
#endif  // _WIN32_IE >= _WIN32_IE_IE70
#endif  // NTDDI_WIN7
#if (NTDDI_VERSION >= NTDDI_VISTA)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0199_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0199_v0_0_s_ifspec;

#ifndef __IAssocHandlerInvoker_INTERFACE_DEFINED__
#define __IAssocHandlerInvoker_INTERFACE_DEFINED__

/* interface IAssocHandlerInvoker */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IAssocHandlerInvoker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92218CAB-ECAA-4335-8133-807FD234C2EE")
    IAssocHandlerInvoker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SupportsSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssocHandlerInvokerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssocHandlerInvoker * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssocHandlerInvoker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssocHandlerInvoker * This);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsSelection )( 
            IAssocHandlerInvoker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAssocHandlerInvoker * This);
        
        END_INTERFACE
    } IAssocHandlerInvokerVtbl;

    interface IAssocHandlerInvoker
    {
        CONST_VTBL struct IAssocHandlerInvokerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssocHandlerInvoker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssocHandlerInvoker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssocHandlerInvoker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssocHandlerInvoker_SupportsSelection(This)	\
    ( (This)->lpVtbl -> SupportsSelection(This) ) 

#define IAssocHandlerInvoker_Invoke(This)	\
    ( (This)->lpVtbl -> Invoke(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssocHandlerInvoker_INTERFACE_DEFINED__ */


#ifndef __IAssocHandler_INTERFACE_DEFINED__
#define __IAssocHandler_INTERFACE_DEFINED__

/* interface IAssocHandler */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IAssocHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F04061AC-1659-4a3f-A954-775AA57FC083")
    IAssocHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [annotation][out][string] */ 
            __deref_out  LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUIName( 
            /* [annotation][out][string] */ 
            __deref_out  LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [annotation][out][string] */ 
            __deref_out  LPWSTR *ppszPath,
            /* [annotation][out] */ 
            __out  int *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRecommended( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeDefault( 
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [annotation][in] */ 
            __in  IDataObject *pdo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInvoker( 
            /* [annotation][in] */ 
            __in  IDataObject *pdo,
            /* [annotation][out] */ 
            __deref_out  IAssocHandlerInvoker **ppInvoker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssocHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssocHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssocHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssocHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssocHandler * This,
            /* [annotation][out][string] */ 
            __deref_out  LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIName )( 
            IAssocHandler * This,
            /* [annotation][out][string] */ 
            __deref_out  LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IAssocHandler * This,
            /* [annotation][out][string] */ 
            __deref_out  LPWSTR *ppszPath,
            /* [annotation][out] */ 
            __out  int *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *IsRecommended )( 
            IAssocHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeDefault )( 
            IAssocHandler * This,
            /* [annotation][string][in] */ 
            __in  LPCWSTR pszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAssocHandler * This,
            /* [annotation][in] */ 
            __in  IDataObject *pdo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInvoker )( 
            IAssocHandler * This,
            /* [annotation][in] */ 
            __in  IDataObject *pdo,
            /* [annotation][out] */ 
            __deref_out  IAssocHandlerInvoker **ppInvoker);
        
        END_INTERFACE
    } IAssocHandlerVtbl;

    interface IAssocHandler
    {
        CONST_VTBL struct IAssocHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssocHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssocHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssocHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssocHandler_GetName(This,ppsz)	\
    ( (This)->lpVtbl -> GetName(This,ppsz) ) 

#define IAssocHandler_GetUIName(This,ppsz)	\
    ( (This)->lpVtbl -> GetUIName(This,ppsz) ) 

#define IAssocHandler_GetIconLocation(This,ppszPath,pIndex)	\
    ( (This)->lpVtbl -> GetIconLocation(This,ppszPath,pIndex) ) 

#define IAssocHandler_IsRecommended(This)	\
    ( (This)->lpVtbl -> IsRecommended(This) ) 

#define IAssocHandler_MakeDefault(This,pszDescription)	\
    ( (This)->lpVtbl -> MakeDefault(This,pszDescription) ) 

#define IAssocHandler_Invoke(This,pdo)	\
    ( (This)->lpVtbl -> Invoke(This,pdo) ) 

#define IAssocHandler_CreateInvoker(This,pdo,ppInvoker)	\
    ( (This)->lpVtbl -> CreateInvoker(This,pdo,ppInvoker) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssocHandler_INTERFACE_DEFINED__ */


#ifndef __IEnumAssocHandlers_INTERFACE_DEFINED__
#define __IEnumAssocHandlers_INTERFACE_DEFINED__

/* interface IEnumAssocHandlers */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumAssocHandlers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("973810ae-9599-4b88-9e4d-6ee98c9552da")
    IEnumAssocHandlers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IAssocHandler **rgelt,
            /* [annotation][out] */ 
            __out_range(0,celt) __exceptthat __maybenull  ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAssocHandlersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAssocHandlers * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAssocHandlers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAssocHandlers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAssocHandlers * This,
            /* [annotation][in] */ 
            __in  ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  IAssocHandler **rgelt,
            /* [annotation][out] */ 
            __out_range(0,celt) __exceptthat __maybenull  ULONG *pceltFetched);
        
        END_INTERFACE
    } IEnumAssocHandlersVtbl;

    interface IEnumAssocHandlers
    {
        CONST_VTBL struct IEnumAssocHandlersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAssocHandlers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAssocHandlers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAssocHandlers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAssocHandlers_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAssocHandlers_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0000_0202 */
/* [local] */ 


enum _ASSOC_FILTER
    {	ASSOC_FILTER_NONE	= 0,
	ASSOC_FILTER_RECOMMENDED	= 0x1
    } ;
typedef int ASSOC_FILTER;

SHSTDAPI SHAssocEnumHandlers(__in LPCWSTR pszExtra, __in ASSOC_FILTER afFilter, __deref_out IEnumAssocHandlers **ppEnumHandler);
#endif  // NTDDI_VISTA
#if (NTDDI_VERSION >= NTDDI_WIN7)
SHSTDAPI SHAssocEnumHandlersForProtocolByApplication(__in PCWSTR protocol, __in REFIID riid, __deref_out void **enumHandlers);
#endif  // NTDDI_WIN7

extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0202_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_0202_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HACCEL_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HACCEL * ); 
void                      __RPC_USER  HACCEL_UserFree(     __RPC__in unsigned long *, __RPC__in HACCEL * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     __RPC__in unsigned long *, __RPC__in HBITMAP * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree(     __RPC__in unsigned long *, __RPC__in HGLOBAL * ); 

unsigned long             __RPC_USER  HICON_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HICON * ); 
void                      __RPC_USER  HICON_UserFree(     __RPC__in unsigned long *, __RPC__in HICON * ); 

unsigned long             __RPC_USER  HMENU_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     __RPC__in unsigned long *, __RPC__in HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  PCIDLIST_ABSOLUTE_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PCIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PCIDLIST_ABSOLUTE_UserFree(     __RPC__in unsigned long *, __RPC__in PCIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PCUIDLIST_RELATIVE_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PCUIDLIST_RELATIVE * ); 
void                      __RPC_USER  PCUIDLIST_RELATIVE_UserFree(     __RPC__in unsigned long *, __RPC__in PCUIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PCUITEMID_CHILD_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PCUITEMID_CHILD * ); 
void                      __RPC_USER  PCUITEMID_CHILD_UserFree(     __RPC__in unsigned long *, __RPC__in PCUITEMID_CHILD * ); 

unsigned long             __RPC_USER  PIDLIST_ABSOLUTE_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PIDLIST_ABSOLUTE_UserFree(     __RPC__in unsigned long *, __RPC__in PIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PIDLIST_RELATIVE_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PIDLIST_RELATIVE * ); 
void                      __RPC_USER  PIDLIST_RELATIVE_UserFree(     __RPC__in unsigned long *, __RPC__in PIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PITEMID_CHILD_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PITEMID_CHILD * ); 
void                      __RPC_USER  PITEMID_CHILD_UserFree(     __RPC__in unsigned long *, __RPC__in PITEMID_CHILD * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HACCEL_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HACCEL * ); 
void                      __RPC_USER  HACCEL_UserFree64(     __RPC__in unsigned long *, __RPC__in HACCEL * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree64(     __RPC__in unsigned long *, __RPC__in HBITMAP * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree64(     __RPC__in unsigned long *, __RPC__in HGLOBAL * ); 

unsigned long             __RPC_USER  HICON_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HICON * ); 
void                      __RPC_USER  HICON_UserFree64(     __RPC__in unsigned long *, __RPC__in HICON * ); 

unsigned long             __RPC_USER  HMENU_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HMENU * ); 
void                      __RPC_USER  HMENU_UserFree64(     __RPC__in unsigned long *, __RPC__in HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  PCIDLIST_ABSOLUTE_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PCIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PCIDLIST_ABSOLUTE_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PCIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PCIDLIST_ABSOLUTE_UserFree64(     __RPC__in unsigned long *, __RPC__in PCIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PCUIDLIST_RELATIVE_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PCUIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PCUIDLIST_RELATIVE_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PCUIDLIST_RELATIVE * ); 
void                      __RPC_USER  PCUIDLIST_RELATIVE_UserFree64(     __RPC__in unsigned long *, __RPC__in PCUIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PCUITEMID_CHILD_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PCUITEMID_CHILD * ); 
unsigned char * __RPC_USER  PCUITEMID_CHILD_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PCUITEMID_CHILD * ); 
void                      __RPC_USER  PCUITEMID_CHILD_UserFree64(     __RPC__in unsigned long *, __RPC__in PCUITEMID_CHILD * ); 

unsigned long             __RPC_USER  PIDLIST_ABSOLUTE_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PIDLIST_ABSOLUTE * ); 
unsigned char * __RPC_USER  PIDLIST_ABSOLUTE_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PIDLIST_ABSOLUTE * ); 
void                      __RPC_USER  PIDLIST_ABSOLUTE_UserFree64(     __RPC__in unsigned long *, __RPC__in PIDLIST_ABSOLUTE * ); 

unsigned long             __RPC_USER  PIDLIST_RELATIVE_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PIDLIST_RELATIVE * ); 
unsigned char * __RPC_USER  PIDLIST_RELATIVE_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PIDLIST_RELATIVE * ); 
void                      __RPC_USER  PIDLIST_RELATIVE_UserFree64(     __RPC__in unsigned long *, __RPC__in PIDLIST_RELATIVE * ); 

unsigned long             __RPC_USER  PITEMID_CHILD_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in PITEMID_CHILD * ); 
unsigned char * __RPC_USER  PITEMID_CHILD_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out PITEMID_CHILD * ); 
void                      __RPC_USER  PITEMID_CHILD_UserFree64(     __RPC__in unsigned long *, __RPC__in PITEMID_CHILD * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumIDList_Next_Proxy( 
    IEnumIDList * This,
    /* [annotation][in] */ 
    __in  ULONG celt,
    /* [annotation][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  PITEMID_CHILD *rgelt,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumIDList_Next_Stub( 
    __RPC__in IEnumIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PITEMID_CHILD *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumFullIDList_Next_Proxy( 
    IEnumFullIDList * This,
    /* [annotation][in] */ 
    __in  ULONG celt,
    /* [annotation][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  PIDLIST_ABSOLUTE *rgelt,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumFullIDList_Next_Stub( 
    __RPC__in IEnumFullIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) PIDLIST_ABSOLUTE *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IShellFolder_SetNameOf_Proxy( 
    IShellFolder * This,
    /* [annotation][unique][in] */ 
    __in_opt  HWND hwnd,
    /* [annotation][in] */ 
    __in  PCUITEMID_CHILD pidl,
    /* [annotation][string][in] */ 
    __in  LPCWSTR pszName,
    /* [annotation][in] */ 
    __in  SHGDNF uFlags,
    /* [annotation][out] */ 
    __deref_opt_out  PITEMID_CHILD *ppidlOut);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IShellFolder_SetNameOf_Stub( 
    __RPC__in IShellFolder * This,
    /* [unique][in] */ __RPC__in_opt HWND hwnd,
    /* [in] */ __RPC__in PCUITEMID_CHILD pidl,
    /* [string][in] */ __RPC__in_string LPCWSTR pszName,
    /* [in] */ SHGDNF uFlags,
    /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlOut);

/* [local] */ HRESULT STDMETHODCALLTYPE IFolderView2_GetGroupBy_Proxy( 
    IFolderView2 * This,
    /* [annotation][out] */ 
    __out  PROPERTYKEY *pkey,
    /* [annotation][out] */ 
    __out_opt  BOOL *pfAscending);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IFolderView2_GetGroupBy_Stub( 
    __RPC__in IFolderView2 * This,
    /* [out] */ __RPC__out PROPERTYKEY *pkey,
    /* [out] */ __RPC__out BOOL *pfAscending);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumShellItems_Next_Proxy( 
    IEnumShellItems * This,
    /* [annotation][in] */ 
    __in  ULONG celt,
    /* [annotation][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  IShellItem **rgelt,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumShellItems_Next_Stub( 
    __RPC__in IEnumShellItems * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IShellItem **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IParentAndItem_GetParentAndItem_Proxy( 
    IParentAndItem * This,
    /* [annotation][out] */ 
    __deref_opt_out  PIDLIST_ABSOLUTE *ppidlParent,
    /* [annotation][out] */ 
    __deref_opt_out  IShellFolder **ppsf,
    /* [annotation][out] */ 
    __deref_opt_out  PITEMID_CHILD *ppidlChild);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IParentAndItem_GetParentAndItem_Stub( 
    __RPC__in IParentAndItem * This,
    /* [out] */ __RPC__deref_out_opt PIDLIST_ABSOLUTE *ppidlParent,
    /* [out] */ __RPC__deref_out_opt IShellFolder **ppsf,
    /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlChild);

/* [local] */ HRESULT STDMETHODCALLTYPE IResultsFolder_AddIDList_Proxy( 
    IResultsFolder * This,
    /* [annotation][in] */ 
    __in  PCIDLIST_ABSOLUTE pidl,
    /* [annotation][out] */ 
    __deref_opt_out  PITEMID_CHILD *ppidlAdded);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IResultsFolder_AddIDList_Stub( 
    __RPC__in IResultsFolder * This,
    /* [in] */ __RPC__in PCIDLIST_ABSOLUTE pidl,
    /* [out] */ __RPC__deref_out_opt PITEMID_CHILD *ppidlAdded);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumObjects_Next_Proxy( 
    IEnumObjects * This,
    /* [annotation][in] */ 
    __in  ULONG celt,
    /* [annotation][in] */ 
    __in  REFIID riid,
    /* [annotation][iid_is][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  void **rgelt,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumObjects_Next_Stub( 
    __RPC__in IEnumObjects * This,
    /* [in] */ ULONG celt,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) void **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IBandSite_QueryBand_Proxy( 
    IBandSite * This,
    /* [annotation][in] */ 
    __in  DWORD dwBandID,
    /* [annotation][out] */ 
    __deref_opt_out  IDeskBand **ppstb,
    /* [annotation][out] */ 
    __out_opt  DWORD *pdwState,
    /* [annotation][size_is][string][out] */ 
    __out_ecount_opt(cchName)  LPWSTR pszName,
    /* [annotation][in] */ 
    __in  int cchName);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBandSite_QueryBand_Stub( 
    __RPC__in IBandSite * This,
    /* [in] */ DWORD dwBandID,
    /* [out] */ __RPC__deref_out_opt IDeskBand **ppstb,
    /* [out] */ __RPC__out DWORD *pdwState,
    /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchName) LPWSTR pszName,
    /* [in] */ int cchName);

/* [local] */ HRESULT STDMETHODCALLTYPE IModalWindow_Show_Proxy( 
    IModalWindow * This,
    /* [annotation][unique][in] */ 
    __in_opt  HWND hwndOwner);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IModalWindow_Show_Stub( 
    __RPC__in IModalWindow * This,
    /* [unique][in] */ __RPC__in_opt HWND hwndOwner);

/* [local] */ HRESULT STDMETHODCALLTYPE IKnownFolderManager_Redirect_Proxy( 
    IKnownFolderManager * This,
    /* [annotation][in] */ 
    __in  REFKNOWNFOLDERID rfid,
    /* [annotation][unique][in] */ 
    __in_opt  HWND hwnd,
    /* [annotation][in] */ 
    __in  KF_REDIRECT_FLAGS flags,
    /* [annotation][string][unique][in] */ 
    __in_opt  LPCWSTR pszTargetPath,
    /* [annotation][in] */ 
    __in  UINT cFolders,
    /* [annotation][unique][size_is][in] */ 
    __in_ecount_opt(cFolders)  const KNOWNFOLDERID *pExclusion,
    /* [annotation][string][out] */ 
    __deref_opt_out_opt  LPWSTR *ppszError);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IKnownFolderManager_Redirect_Stub( 
    __RPC__in IKnownFolderManager * This,
    /* [in] */ __RPC__in REFKNOWNFOLDERID rfid,
    /* [unique][in] */ __RPC__in_opt HWND hwnd,
    /* [in] */ KF_REDIRECT_FLAGS flags,
    /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR pszTargetPath,
    /* [in] */ UINT cFolders,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cFolders) const GUID *pExclusion,
    /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszError);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumExplorerCommand_Next_Proxy( 
    IEnumExplorerCommand * This,
    /* [annotation][in] */ 
    __in  ULONG celt,
    /* [annotation][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  IExplorerCommand **pUICommand,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumExplorerCommand_Next_Stub( 
    __RPC__in IEnumExplorerCommand * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IExplorerCommand **pUICommand,
    /* [out] */ __RPC__out ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SipBase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:       sipbase.h
//
//  Contents:   Generic SIP Provider Main Include File
//
//  History:    14-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef SIPBASE_H
#define SIPBASE_H

#if _MSC_VER > 1000
#pragma once
#endif

// all moved to mssip.h
#include <mssip.h>

#endif // SIPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\simpdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for simpdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __simpdata_h__
#define __simpdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __OLEDBSimpleProviderListener_FWD_DEFINED__
#define __OLEDBSimpleProviderListener_FWD_DEFINED__
typedef interface OLEDBSimpleProviderListener OLEDBSimpleProviderListener;
#endif 	/* __OLEDBSimpleProviderListener_FWD_DEFINED__ */


#ifndef __OLEDBSimpleProvider_FWD_DEFINED__
#define __OLEDBSimpleProvider_FWD_DEFINED__
typedef interface OLEDBSimpleProvider OLEDBSimpleProvider;
#endif 	/* __OLEDBSimpleProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_simpdata_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// simpdata.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE DB Simple Provider Toolkit

#ifndef SIMPDATA_H
#define SIMPDATA_H

#ifdef _WIN64

typedef LONGLONG DBROWCOUNT;

typedef LONGLONG DB_LORDINAL;


#else

typedef LONG DBROWCOUNT;

typedef LONG DB_LORDINAL;

#endif	// _WIN64
#define OSP_IndexLabel      (0)
#define OSP_IndexAll        (~0)
#define OSP_IndexUnknown    (~0)



extern RPC_IF_HANDLE __MIDL_itf_simpdata_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_simpdata_0000_0000_v0_0_s_ifspec;


#ifndef __MSDAOSP_LIBRARY_DEFINED__
#define __MSDAOSP_LIBRARY_DEFINED__

/* library MSDAOSP */
/* [version][lcid][helpstring][uuid] */ 

typedef 
enum OSPFORMAT
    {	OSPFORMAT_RAW	= 0,
	OSPFORMAT_DEFAULT	= 0,
	OSPFORMAT_FORMATTED	= 1,
	OSPFORMAT_HTML	= 2
    } 	OSPFORMAT;

typedef 
enum OSPRW
    {	OSPRW_DEFAULT	= 1,
	OSPRW_READONLY	= 0,
	OSPRW_READWRITE	= 1,
	OSPRW_MIXED	= 2
    } 	OSPRW;

typedef 
enum OSPFIND
    {	OSPFIND_DEFAULT	= 0,
	OSPFIND_UP	= 1,
	OSPFIND_CASESENSITIVE	= 2,
	OSPFIND_UPCASESENSITIVE	= 3
    } 	OSPFIND;

typedef 
enum OSPCOMP
    {	OSPCOMP_EQ	= 1,
	OSPCOMP_DEFAULT	= 1,
	OSPCOMP_LT	= 2,
	OSPCOMP_LE	= 3,
	OSPCOMP_GE	= 4,
	OSPCOMP_GT	= 5,
	OSPCOMP_NE	= 6
    } 	OSPCOMP;

typedef 
enum OSPXFER
    {	OSPXFER_COMPLETE	= 0,
	OSPXFER_ABORT	= 1,
	OSPXFER_ERROR	= 2
    } 	OSPXFER;

typedef OLEDBSimpleProvider *LPOLEDBSimpleProvider;

EXTERN_C const IID LIBID_MSDAOSP;

#ifndef __OLEDBSimpleProviderListener_INTERFACE_DEFINED__
#define __OLEDBSimpleProviderListener_INTERFACE_DEFINED__

/* interface OLEDBSimpleProviderListener */
/* [version][oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_OLEDBSimpleProviderListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0E270C1-C0BE-11d0-8FE4-00A0C90A6341")
    OLEDBSimpleProviderListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE aboutToChangeCell( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE cellChanged( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE aboutToDeleteRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE deletedRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE aboutToInsertRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE insertedRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE rowsAvailable( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE transferComplete( 
            /* [in] */ OSPXFER xfer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct OLEDBSimpleProviderListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in OLEDBSimpleProviderListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in OLEDBSimpleProviderListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *aboutToChangeCell )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn);
        
        HRESULT ( STDMETHODCALLTYPE *cellChanged )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn);
        
        HRESULT ( STDMETHODCALLTYPE *aboutToDeleteRows )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *deletedRows )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *aboutToInsertRows )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *insertedRows )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *rowsAvailable )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows);
        
        HRESULT ( STDMETHODCALLTYPE *transferComplete )( 
            __RPC__in OLEDBSimpleProviderListener * This,
            /* [in] */ OSPXFER xfer);
        
        END_INTERFACE
    } OLEDBSimpleProviderListenerVtbl;

    interface OLEDBSimpleProviderListener
    {
        CONST_VTBL struct OLEDBSimpleProviderListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define OLEDBSimpleProviderListener_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define OLEDBSimpleProviderListener_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define OLEDBSimpleProviderListener_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define OLEDBSimpleProviderListener_aboutToChangeCell(This,iRow,iColumn)	\
    ( (This)->lpVtbl -> aboutToChangeCell(This,iRow,iColumn) ) 

#define OLEDBSimpleProviderListener_cellChanged(This,iRow,iColumn)	\
    ( (This)->lpVtbl -> cellChanged(This,iRow,iColumn) ) 

#define OLEDBSimpleProviderListener_aboutToDeleteRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> aboutToDeleteRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_deletedRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> deletedRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_aboutToInsertRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> aboutToInsertRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_insertedRows(This,iRow,cRows)	\
    ( (This)->lpVtbl -> insertedRows(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_rowsAvailable(This,iRow,cRows)	\
    ( (This)->lpVtbl -> rowsAvailable(This,iRow,cRows) ) 

#define OLEDBSimpleProviderListener_transferComplete(This,xfer)	\
    ( (This)->lpVtbl -> transferComplete(This,xfer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __OLEDBSimpleProviderListener_INTERFACE_DEFINED__ */


#ifndef __OLEDBSimpleProvider_INTERFACE_DEFINED__
#define __OLEDBSimpleProvider_INTERFACE_DEFINED__

/* interface OLEDBSimpleProvider */
/* [version][oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_OLEDBSimpleProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0E270C0-C0BE-11d0-8FE4-00A0C90A6341")
    OLEDBSimpleProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getRowCount( 
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getColumnCount( 
            /* [retval][out] */ __RPC__out DB_LORDINAL *pcColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRWStatus( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [retval][out] */ __RPC__out OSPRW *prwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [retval][out] */ __RPC__out VARIANT *pVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [in] */ VARIANT Var) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLocale( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrLocale) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE deleteRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsDeleted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE insertRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsInserted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE find( 
            /* [in] */ DBROWCOUNT iRowStart,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ VARIANT val,
            /* [in] */ OSPFIND findFlags,
            /* [in] */ OSPCOMP compType,
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRowFound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener( 
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener( 
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE isAsync( 
            /* [retval][out] */ __RPC__out BOOL *pbAsynch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEstimatedRows( 
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRows) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stopTransfer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct OLEDBSimpleProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in OLEDBSimpleProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in OLEDBSimpleProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *getRowCount )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRows);
        
        HRESULT ( STDMETHODCALLTYPE *getColumnCount )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out DB_LORDINAL *pcColumns);
        
        HRESULT ( STDMETHODCALLTYPE *getRWStatus )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [retval][out] */ __RPC__out OSPRW *prwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *getVariant )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [retval][out] */ __RPC__out VARIANT *pVar);
        
        HRESULT ( STDMETHODCALLTYPE *setVariant )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [in] */ VARIANT Var);
        
        HRESULT ( STDMETHODCALLTYPE *getLocale )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrLocale);
        
        HRESULT ( STDMETHODCALLTYPE *deleteRows )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsDeleted);
        
        HRESULT ( STDMETHODCALLTYPE *insertRows )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ __RPC__out DBROWCOUNT *pcRowsInserted);
        
        HRESULT ( STDMETHODCALLTYPE *find )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ DBROWCOUNT iRowStart,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ VARIANT val,
            /* [in] */ OSPFIND findFlags,
            /* [in] */ OSPCOMP compType,
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRowFound);
        
        HRESULT ( STDMETHODCALLTYPE *addOLEDBSimpleProviderListener )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener);
        
        HRESULT ( STDMETHODCALLTYPE *removeOLEDBSimpleProviderListener )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [in] */ __RPC__in_opt OLEDBSimpleProviderListener *pospIListener);
        
        HRESULT ( STDMETHODCALLTYPE *isAsync )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pbAsynch);
        
        HRESULT ( STDMETHODCALLTYPE *getEstimatedRows )( 
            __RPC__in OLEDBSimpleProvider * This,
            /* [retval][out] */ __RPC__out DBROWCOUNT *piRows);
        
        HRESULT ( STDMETHODCALLTYPE *stopTransfer )( 
            __RPC__in OLEDBSimpleProvider * This);
        
        END_INTERFACE
    } OLEDBSimpleProviderVtbl;

    interface OLEDBSimpleProvider
    {
        CONST_VTBL struct OLEDBSimpleProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define OLEDBSimpleProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define OLEDBSimpleProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define OLEDBSimpleProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define OLEDBSimpleProvider_getRowCount(This,pcRows)	\
    ( (This)->lpVtbl -> getRowCount(This,pcRows) ) 

#define OLEDBSimpleProvider_getColumnCount(This,pcColumns)	\
    ( (This)->lpVtbl -> getColumnCount(This,pcColumns) ) 

#define OLEDBSimpleProvider_getRWStatus(This,iRow,iColumn,prwStatus)	\
    ( (This)->lpVtbl -> getRWStatus(This,iRow,iColumn,prwStatus) ) 

#define OLEDBSimpleProvider_getVariant(This,iRow,iColumn,format,pVar)	\
    ( (This)->lpVtbl -> getVariant(This,iRow,iColumn,format,pVar) ) 

#define OLEDBSimpleProvider_setVariant(This,iRow,iColumn,format,Var)	\
    ( (This)->lpVtbl -> setVariant(This,iRow,iColumn,format,Var) ) 

#define OLEDBSimpleProvider_getLocale(This,pbstrLocale)	\
    ( (This)->lpVtbl -> getLocale(This,pbstrLocale) ) 

#define OLEDBSimpleProvider_deleteRows(This,iRow,cRows,pcRowsDeleted)	\
    ( (This)->lpVtbl -> deleteRows(This,iRow,cRows,pcRowsDeleted) ) 

#define OLEDBSimpleProvider_insertRows(This,iRow,cRows,pcRowsInserted)	\
    ( (This)->lpVtbl -> insertRows(This,iRow,cRows,pcRowsInserted) ) 

#define OLEDBSimpleProvider_find(This,iRowStart,iColumn,val,findFlags,compType,piRowFound)	\
    ( (This)->lpVtbl -> find(This,iRowStart,iColumn,val,findFlags,compType,piRowFound) ) 

#define OLEDBSimpleProvider_addOLEDBSimpleProviderListener(This,pospIListener)	\
    ( (This)->lpVtbl -> addOLEDBSimpleProviderListener(This,pospIListener) ) 

#define OLEDBSimpleProvider_removeOLEDBSimpleProviderListener(This,pospIListener)	\
    ( (This)->lpVtbl -> removeOLEDBSimpleProviderListener(This,pospIListener) ) 

#define OLEDBSimpleProvider_isAsync(This,pbAsynch)	\
    ( (This)->lpVtbl -> isAsync(This,pbAsynch) ) 

#define OLEDBSimpleProvider_getEstimatedRows(This,piRows)	\
    ( (This)->lpVtbl -> getEstimatedRows(This,piRows) ) 

#define OLEDBSimpleProvider_stopTransfer(This)	\
    ( (This)->lpVtbl -> stopTransfer(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __OLEDBSimpleProvider_INTERFACE_DEFINED__ */

#endif /* __MSDAOSP_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_simpdata_0001_0023 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_simpdata_0001_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_simpdata_0001_0023_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Shlwapi.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/


#ifndef _INC_SHLWAPI
#define _INC_SHLWAPI

#ifndef NOSHLWAPI

#include <SpecStrings.h>
#include <objbase.h>
#include <shtypes.h>



//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHLWAPI
#if !defined(_SHLWAPI_)
#define LWSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define LWSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define LWSTDAPIV         EXTERN_C DECLSPEC_IMPORT HRESULT STDAPIVCALLTYPE
#define LWSTDAPIV_(type)  EXTERN_C DECLSPEC_IMPORT type STDAPIVCALLTYPE
#else
#define LWSTDAPI          STDAPI
#define LWSTDAPI_(type)   STDAPI_(type)
#define LWSTDAPIV         STDAPIV
#define LWSTDAPIV_(type)  STDAPIV_(type)
#endif
#endif // WINSHLWAPI

#ifdef _WIN32
#include <pshpack8.h>
#endif

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(push)
#pragma warning(disable:4995)
#endif

// objidl.h
#ifndef __IBindCtx_FWD_DEFINED__
#define __IBindCtx_FWD_DEFINED__
typedef interface IBindCtx IBindCtx;
#endif  /* __IBindCtx_FWD_DEFINED__ */

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__cplusplus) && defined(STRICT_CONST)
#define USE_STRICT_CONST
#endif
//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_GDI        GDI helper functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPCSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(LPCWSTR)   StrChrNW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
LWSTDAPI_(LPCWSTR)   StrChrNIW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
#endif // _WIN32_IE_IE60
#else
LWSTDAPI_(LPSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(LPWSTR)   StrChrNW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
LWSTDAPI_(LPWSTR)   StrChrNIW(LPCWSTR lpStart, WCHAR wMatch, UINT cchMax);
#endif // _WIN32_IE_IE60
#endif
LWSTDAPI_(int)      StrCmpNA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCSpnA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(LPSTR)    StrDupA(LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrDupW(LPCWSTR lpSrch);

// StrFormatByteSizeEx takes a ULONGLONG as a byte count and formats a string
// representing that number of bytes in an appropriately concise manner, where
// "appropriate manner" is determine by several factors:
//
// 1) order - is this most appropriately expressed as KB? MB? GB?
//    for example: 1039 -> "1.01 KB", 5454608466 -> "5.08 GB", etc
//
// 2) number of whole number places shown - if there are more than a few whole
//    number places to display, decimal places are omitted.
//    for example: 1024 -> "1.00 KB", 12288 -> "12.0 KB", 125952 -> "123 KB"
//
// 3) the caller can specify whether the result should involve rounding to the
//    nearest displayed digit, or truncation of undisplayed digits. the caller
//    must specify either rounding or truncation when calling the API.
//    for example: with rounding,   2147483647 -> "2.00 GB"
//                 with truncation, 2147483647 -> "1.99 GB"

enum tagSFBS_FLAGS
{
    SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT     = 0x0001,   // round to the nearest displayed digit
    SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS  = 0x0002,   // discard undisplayed digits
};
typedef int SFBS_FLAGS;

LWSTDAPI            StrFormatByteSizeEx(__in ULONGLONG ull, __in SFBS_FLAGS flags, __out_ecount(cchBuf) LPWSTR pszBuf, __in_range(>,0) UINT cchBuf);

LWSTDAPI_(LPSTR)    StrFormatByteSizeA(DWORD dw, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPSTR)    StrFormatByteSize64A(LONGLONG qdw, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPWSTR)   StrFormatByteSizeW(LONGLONG qdw, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPWSTR)   StrFormatKBSizeW(LONGLONG qdw, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(LPSTR)    StrFormatKBSizeA(LONGLONG qdw, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(int)      StrFromTimeIntervalA(__out_ecount(cchMax) LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(int)      StrFromTimeIntervalW(__out_ecount(cchMax) LPWSTR pwszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(BOOL)     StrIsIntlEqualA(__in BOOL fCaseSens, __in LPCSTR lpString1, __in LPCSTR lpString2, __in int nChar);
LWSTDAPI_(BOOL)     StrIsIntlEqualW(__in BOOL fCaseSens, __in LPCWSTR lpString1, __in LPCWSTR lpString2, __in int nChar);
LWSTDAPI_(LPSTR)    StrNCatA(__inout_ecount(cchMax) LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrNCatW(__inout_ecount(cchMax) LPWSTR psz1, LPCWSTR psz2, int cchMax);
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)    StrPBrkA(__in LPCSTR psz, __in LPCSTR pszSet);
LWSTDAPI_(LPCWSTR)   StrPBrkW(__in LPCWSTR psz, __in LPCWSTR pszSet);
LWSTDAPI_(LPCSTR)    StrRChrA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrRChrW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPCSTR)    StrRChrIA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPCWSTR)   StrRChrIW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPCSTR)    StrRStrIA(__in LPCSTR lpSource, __in_opt LPCSTR lpLast, __in LPCSTR lpSrch);
LWSTDAPI_(LPCWSTR)   StrRStrIW(__in LPCWSTR lpSource, __in_opt LPCWSTR lpLast, __in LPCWSTR lpSrch);
#else
LWSTDAPI_(LPSTR)    StrPBrkA(__in LPCSTR psz, __in LPCSTR pszSet);
LWSTDAPI_(LPWSTR)   StrPBrkW(__in LPCWSTR psz, __in LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrRChrA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRChrIA(__in LPCSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrIW(__in LPCWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRStrIA(__in LPCSTR lpSource, __in_opt LPCSTR lpLast, __in LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrRStrIW(__in LPCWSTR lpSource, __in_opt LPCWSTR lpLast, __in LPCWSTR lpSrch);
#endif
LWSTDAPI_(int)      StrSpnA(__in LPCSTR psz, __in LPCSTR pszSet);
LWSTDAPI_(int)      StrSpnW(__in LPCWSTR psz, __in LPCWSTR pszSet);
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)    StrStrA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPCWSTR)   StrStrW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
LWSTDAPI_(LPCSTR)    StrStrIA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPCWSTR)   StrStrIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
#if (_WIN32_IE >= _WIN32_IE_IE6)
LWSTDAPI_(LPCWSTR)   StrStrNW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
LWSTDAPI_(LPCWSTR)   StrStrNIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
#endif // _WIN32_IE_IE6
#else
LWSTDAPI_(LPSTR)    StrStrA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrStrIA(__in LPCSTR lpFirst, __in LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(LPWSTR)   StrStrNW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
LWSTDAPI_(LPWSTR)   StrStrNIW(__in LPCWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax);
#endif // _WIN32_IE_IE60
#endif

#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L
typedef int STIF_FLAGS;
LWSTDAPI_(int)      StrToIntA(__in LPCSTR lpSrc);
LWSTDAPI_(int)      StrToIntW(__in LPCWSTR lpSrc);
LWSTDAPI_(BOOL)     StrToIntExA(__in LPCSTR pszString, __in STIF_FLAGS dwFlags, __out int * piRet);
LWSTDAPI_(BOOL)     StrToIntExW(__in LPCWSTR pszString, __in STIF_FLAGS dwFlags, __out int * piRet);
#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI_(BOOL)     StrToInt64ExA(__in LPCSTR pszString, __in STIF_FLAGS dwFlags, __out LONGLONG * pllRet);
LWSTDAPI_(BOOL)     StrToInt64ExW(__in LPCWSTR pszString, __in STIF_FLAGS dwFlags, __out LONGLONG * pllRet);
#endif // _WIN32_IE_IE60

LWSTDAPI_(BOOL)     StrTrimA(__inout LPSTR psz, __in LPCSTR pszTrimChars);
LWSTDAPI_(BOOL)     StrTrimW(__inout LPWSTR psz, __in LPCWSTR pszTrimChars);


LWSTDAPI_(LPWSTR)   StrCatW(__inout LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpW(__in LPCWSTR psz1, __in LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpIW(__in LPCWSTR psz1, __in LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyW(__out LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyNW(__out_ecount(cchMax) LPWSTR psz1, __in LPCWSTR psz2, __in int cchMax);

LWSTDAPI_(LPWSTR)   StrCatBuffW(__inout_ecount(cchDestBuffSize) LPWSTR pszDest, __in LPCWSTR pszSrc, __in int cchDestBuffSize);
LWSTDAPI_(LPSTR)    StrCatBuffA(__inout_ecount(cchDestBuffSize) LPSTR pszDest, __in LPCSTR pszSrc, __in int cchDestBuffSize);
LWSTDAPI_(BOOL)     ChrCmpIA(WORD w1, WORD w2);
LWSTDAPI_(BOOL)     ChrCmpIW(WCHAR w1, WCHAR w2);

LWSTDAPI_(int)      wvnsprintfA(__out_ecount(cchDest) LPSTR pszDest, __in int cchDest, __in __format_string LPCSTR pszFmt, __in va_list arglist);
LWSTDAPI_(int)      wvnsprintfW(__out_ecount(cchDest) LPWSTR pszDest, __in int cchDest, __in __format_string LPCWSTR pszFmt, __in va_list arglist);
LWSTDAPIV_(int)     wnsprintfA(__out_ecount(cchDest) LPSTR pszDest, __in int cchDest, __in __format_string LPCSTR pszFmt, ...);
LWSTDAPIV_(int)     wnsprintfW(__out_ecount(cchDest) LPWSTR pszDest, __in int cchDest, __in __format_string LPCWSTR pszFmt, ...);

#define StrIntlEqNA( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)
#define StrIntlEqNW( s1, s2, nChar) StrIsIntlEqualW( TRUE, s1, s2, nChar)
#define StrIntlEqNIA(s1, s2, nChar) StrIsIntlEqualA(FALSE, s1, s2, nChar)
#define StrIntlEqNIW(s1, s2, nChar) StrIsIntlEqualW(FALSE, s1, s2, nChar)

LWSTDAPI StrRetToStrA(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __deref_out LPSTR *ppsz);
LWSTDAPI StrRetToStrW(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __deref_out LPWSTR *ppsz);
#ifdef UNICODE
#define StrRetToStr  StrRetToStrW
#else
#define StrRetToStr  StrRetToStrA
#endif // !UNICODE
LWSTDAPI StrRetToBufA(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI StrRetToBufW(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define StrRetToBuf  StrRetToBufW
#else
#define StrRetToBuf  StrRetToBufA
#endif // !UNICODE

// helper to duplicate a string using the task allocator

LWSTDAPI SHStrDupA(__in LPCSTR psz, __deref_out LPWSTR *ppwsz);
LWSTDAPI SHStrDupW(__in LPCWSTR psz, __deref_out LPWSTR *ppwsz);
#ifdef UNICODE
#define SHStrDup  SHStrDupW
#else
#define SHStrDup  SHStrDupA
#endif // !UNICODE

#ifdef __cplusplus
// make the above helper function a bit easier to use in the HRESULT world
inline HRESULT SHLocalStrDupW(LPCWSTR psz, __out LPWSTR *ppsz)
{
    *ppsz = StrDupW(psz);
    return *ppsz ? S_OK : E_OUTOFMEMORY;
}
inline HRESULT SHLocalStrDupA(LPCSTR psz, __out LPSTR *ppsz)
{
    *ppsz = StrDupA(psz);
    return *ppsz ? S_OK : E_OUTOFMEMORY;
}
#ifdef UNICODE
#define SHLocalStrDup SHLocalStrDupW
#else
#define SHLocalStrDup SHLocalStrDupA
#endif
#endif // __cplusplus

#if (_WIN32_IE >= _WIN32_IE_IE55)
LWSTDAPI_(int) StrCmpLogicalW(__in LPCWSTR psz1, __in LPCWSTR psz2);
LWSTDAPI_(DWORD) StrCatChainW(__out_ecount(cchDst) LPWSTR pszDst, __in DWORD cchDst, __in DWORD ichAt, __in LPCWSTR pszSrc);
LWSTDAPI StrRetToBSTR(__inout STRRET *pstr, __in_opt PCUITEMID_CHILD pidl, __deref_out BSTR *pbstr);
LWSTDAPI SHLoadIndirectString(__in LPCWSTR pszSource, __out_ecount(cchOutBuf) LPWSTR pszOutBuf, __in UINT cchOutBuf, __reserved void **ppvReserved);
#endif // _WIN32_IE_IE55


#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
LWSTDAPI_(BOOL) IsCharSpaceA(__in CHAR wch);
LWSTDAPI_(BOOL) IsCharSpaceW(__in WCHAR wch);
#ifdef UNICODE
#define IsCharSpace  IsCharSpaceW
#else
#define IsCharSpace  IsCharSpaceA
#endif // !UNICODE

LWSTDAPI_(int)  StrCmpCA(__in LPCSTR pszStr1, __in LPCSTR pszStr2);
LWSTDAPI_(int)  StrCmpCW(__in LPCWSTR pszStr1, __in LPCWSTR pszStr2);
#ifdef UNICODE
#define StrCmpC  StrCmpCW
#else
#define StrCmpC  StrCmpCA
#endif // !UNICODE

LWSTDAPI_(int)  StrCmpICA(__in LPCSTR pszStr1, __in LPCSTR pszStr2);
LWSTDAPI_(int)  StrCmpICW(__in LPCWSTR pszStr1, __in LPCWSTR pszStr2);
#ifdef UNICODE
#define StrCmpIC  StrCmpICW
#else
#define StrCmpIC  StrCmpICA
#endif // !UNICODE
#endif // _WIN32_IE_IE60SP2

#ifdef UNICODE
#define StrChr                  StrChrW
#define StrRChr                 StrRChrW
#define StrChrI                 StrChrIW
#define StrRChrI                StrRChrIW
#define StrCmpN                 StrCmpNW
#define StrCmpNI                StrCmpNIW
#define StrStr                  StrStrW
#define StrStrI                 StrStrIW
#define StrDup                  StrDupW
#define StrRStrI                StrRStrIW
#define StrCSpn                 StrCSpnW
#define StrCSpnI                StrCSpnIW
#define StrSpn                  StrSpnW
#define StrToInt                StrToIntW
#define StrPBrk                 StrPBrkW
#define StrToIntEx              StrToIntExW
#if (_WIN32_IE >= 0x0600)
#define StrToInt64Ex            StrToInt64ExW
#endif
#define StrFromTimeInterval     StrFromTimeIntervalW
#define StrIntlEqN              StrIntlEqNW
#define StrIntlEqNI             StrIntlEqNIW
#define StrFormatByteSize       StrFormatByteSizeW
#define StrFormatByteSize64     StrFormatByteSizeW
#define StrFormatKBSize         StrFormatKBSizeW
#define StrNCat                 StrNCatW
#define StrTrim                 StrTrimW
#define StrCatBuff              StrCatBuffW
#define ChrCmpI                 ChrCmpIW
#define wvnsprintf              wvnsprintfW
#define wnsprintf               wnsprintfW
#define StrIsIntlEqual          StrIsIntlEqualW


#else
#define StrChr                  StrChrA
#define StrRChr                 StrRChrA
#define StrChrI                 StrChrIA
#define StrRChrI                StrRChrIA
#define StrCmpN                 StrCmpNA
#define StrCmpNI                StrCmpNIA
#define StrStr                  StrStrA
#define StrStrI                 StrStrIA
#define StrDup                  StrDupA
#define StrRStrI                StrRStrIA
#define StrCSpn                 StrCSpnA
#define StrCSpnI                StrCSpnIA
#define StrSpn                  StrSpnA
#define StrToInt                StrToIntA
#define StrPBrk                 StrPBrkA
#define StrToIntEx              StrToIntExA
#if (_WIN32_IE >= 0x0600)
#define StrToInt64Ex            StrToInt64ExA
#endif
#define StrFromTimeInterval     StrFromTimeIntervalA
#define StrIntlEqN              StrIntlEqNA
#define StrIntlEqNI             StrIntlEqNIA
#define StrFormatByteSize       StrFormatByteSizeA
#define StrFormatByteSize64     StrFormatByteSize64A
#define StrFormatKBSize         StrFormatKBSizeA
#define StrNCat                 StrNCatA
#define StrTrim                 StrTrimA
#define StrCatBuff              StrCatBuffA
#define ChrCmpI                 ChrCmpIA
#define wvnsprintf              wvnsprintfA
#define wnsprintf               wnsprintfA
#define StrIsIntlEqual          StrIsIntlEqualA
#endif

#if (_WIN32_IE >= _WIN32_IE_IE50)
// StrCmp*C* - Compare strings using C runtime collation rules.
LWSTDAPI_(int)  StrCmpNCA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, __in int nChar);
// StrCmp*C* - Compare strings using C runtime collation rules.
LWSTDAPI_(int)  StrCmpNCW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, __in int nChar);
#ifdef UNICODE
#define StrCmpNC  StrCmpNCW
#else
#define StrCmpNC  StrCmpNCA
#endif // !UNICODE
LWSTDAPI_(int)  StrCmpNICA(__in LPCSTR lpStr1, __in LPCSTR lpStr2, __in int nChar);
LWSTDAPI_(int)  StrCmpNICW(__in LPCWSTR lpStr1, __in LPCWSTR lpStr2, __in int nChar);
#ifdef UNICODE
#define StrCmpNIC  StrCmpNICW
#else
#define StrCmpNIC  StrCmpNICA
#endif // !UNICODE
#endif  // _WIN32_IE_IE50


// Backward compatible to NT's non-standard naming (strictly
// for comctl32)
//
LWSTDAPI_(BOOL)     IntlStrEqWorkerA(BOOL fCaseSens, __in_ecount(nChar) LPCSTR lpString1, __in_ecount(nChar) LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     IntlStrEqWorkerW(BOOL fCaseSens, __in_ecount(nChar) LPCWSTR lpString1, __in_ecount(nChar) LPCWSTR lpString2, int nChar);

#define IntlStrEqNA( s1, s2, nChar) IntlStrEqWorkerA( TRUE, s1, s2, nChar)
#define IntlStrEqNW( s1, s2, nChar) IntlStrEqWorkerW( TRUE, s1, s2, nChar)
#define IntlStrEqNIA(s1, s2, nChar) IntlStrEqWorkerA(FALSE, s1, s2, nChar)
#define IntlStrEqNIW(s1, s2, nChar) IntlStrEqWorkerW(FALSE, s1, s2, nChar)

#ifdef UNICODE
#define IntlStrEqN              IntlStrEqNW
#define IntlStrEqNI             IntlStrEqNIW
#else
#define IntlStrEqN              IntlStrEqNA
#define IntlStrEqNI             IntlStrEqNIA
#endif

#define SZ_CONTENTTYPE_HTMLA       "text/html"
#define SZ_CONTENTTYPE_HTMLW       L"text/html"
#define SZ_CONTENTTYPE_CDFA        "application/x-cdf"
#define SZ_CONTENTTYPE_CDFW        L"application/x-cdf"

#ifdef UNICODE
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLW
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFW
#else
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLA
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFA
#endif

#define PathIsHTMLFileA(pszPath)     PathIsContentTypeA(pszPath, SZ_CONTENTTYPE_HTMLA)
#define PathIsHTMLFileW(pszPath)     PathIsContentTypeW(pszPath, SZ_CONTENTTYPE_HTMLW)


#define StrCatA                 lstrcatA
#define StrCmpA                 lstrcmpA
#define StrCmpIA                lstrcmpiA
#define StrCpyA                 lstrcpyA
#define StrCpyNA                lstrcpynA


#define StrToLong               StrToInt
#define StrNCmp                 StrCmpN
#define StrNCmpI                StrCmpNI
#define StrNCpy                 StrCpyN
#define StrCatN                 StrNCat

#ifdef UNICODE
#define StrCat                  StrCatW
#define StrCmp                  StrCmpW
#define StrCmpI                 StrCmpIW
#define StrCpy                  StrCpyW
#define StrCpyN                 StrCpyNW
#define StrCatBuff              StrCatBuffW
#else
#define StrCat                  lstrcatA
#define StrCmp                  lstrcmpA
#define StrCmpI                 lstrcmpiA
#define StrCpy                  lstrcpyA
#define StrCpyN                 lstrcpynA
#define StrCatBuff              StrCatBuffA
#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//

LWSTDAPI_(LPSTR)  PathAddBackslashA(__inout_ecount(MAX_PATH) LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathAddBackslashW(__inout_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define PathAddBackslash  PathAddBackslashW
#else
#define PathAddBackslash  PathAddBackslashA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAddExtensionA(__inout_ecount(MAX_PATH) LPSTR pszPath, __in_opt LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathAddExtensionW(__inout_ecount(MAX_PATH) LPWSTR pszPath, __in_opt LPCWSTR pszExt);
#ifdef UNICODE
#define PathAddExtension  PathAddExtensionW
#else
#define PathAddExtension  PathAddExtensionA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAppendA(__inout_ecount(MAX_PATH) LPSTR pszPath, __in LPCSTR pMore);
LWSTDAPI_(BOOL)     PathAppendW(__inout_ecount(MAX_PATH) LPWSTR pszPath, __in LPCWSTR pMore);
LWSTDAPI_(LPSTR)  PathBuildRootA(__out_ecount(4) LPSTR pszRoot, int iDrive);
LWSTDAPI_(LPWSTR)  PathBuildRootW(__out_ecount(4) LPWSTR pszRoot, int iDrive);
#ifdef UNICODE
#define PathBuildRoot  PathBuildRootW
#else
#define PathBuildRoot  PathBuildRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, __in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathCanonicalizeW(__out_ecount(MAX_PATH) LPWSTR pszBuf, __in LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathCombineA(__out_ecount(MAX_PATH) LPSTR pszDest, __in_opt LPCSTR pszDir, __in_opt LPCSTR pszFile);
LWSTDAPI_(LPWSTR)  PathCombineW(__out_ecount(MAX_PATH) LPWSTR pszDest, __in_opt LPCWSTR pszDir, __in_opt LPCWSTR pszFile);
#ifdef UNICODE
#define PathCombine  PathCombineW
#else
#define PathCombine  PathCombineA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCompactPathA(__in_opt HDC hDC, __inout_ecount(MAX_PATH) LPSTR pszPath, __in UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathW(__in_opt HDC hDC, __inout_ecount(MAX_PATH) LPWSTR pszPath, __in UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathExA(__out_ecount(cchMax) LPSTR pszOut, __in LPCSTR pszSrc, __in UINT cchMax, __in DWORD dwFlags);
LWSTDAPI_(BOOL)     PathCompactPathExW(__out_ecount(cchMax) LPWSTR pszOut, __in LPCWSTR pszSrc, __in UINT cchMax, __in DWORD dwFlags);
LWSTDAPI_(int)      PathCommonPrefixA(__in LPCSTR pszFile1, __in LPCSTR pszFile2, __out_ecount_opt(MAX_PATH) LPSTR achPath);
LWSTDAPI_(int)      PathCommonPrefixW(__in LPCWSTR pszFile1, __in LPCWSTR pszFile2, __out_ecount_opt(MAX_PATH) LPWSTR achPath);
LWSTDAPI_(BOOL)     PathFileExistsA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathFileExistsW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFileExists  PathFileExistsW
#else
#define PathFileExists  PathFileExistsA
#endif // !UNICODE
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)  PathFindExtensionA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathFindExtensionW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPCSTR)  PathFindFileNameA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathFindFileNameW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPCSTR)  PathFindNextComponentA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathFindNextComponentW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
#else
LWSTDAPI_(LPSTR)  PathFindExtensionA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindExtensionW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindFileNameA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindFileNameW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindNextComponentA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindNextComponentW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
#endif
LWSTDAPI_(BOOL)     PathFindOnPathA(__inout_ecount(MAX_PATH) LPSTR pszPath, __in_opt PZPCSTR ppszOtherDirs);
LWSTDAPI_(BOOL)     PathFindOnPathW(__inout_ecount(MAX_PATH) LPWSTR pszPath, __in_opt PZPCWSTR ppszOtherDirs);
LWSTDAPI_(LPCSTR) PathFindSuffixArrayA(__in LPCSTR pszPath, __in_ecount(iArraySize) const LPCSTR *apszSuffix, __in int iArraySize);
LWSTDAPI_(LPCWSTR) PathFindSuffixArrayW(__in LPCWSTR pszPath, __in_ecount(iArraySize) const LPCWSTR *apszSuffix, __in int iArraySize);
#ifdef UNICODE
#define PathFindSuffixArray  PathFindSuffixArrayW
#else
#define PathFindSuffixArray  PathFindSuffixArrayA
#endif // !UNICODE
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)  PathGetArgsA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathGetArgsW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
#else
LWSTDAPI_(LPSTR)  PathGetArgsA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathGetArgsW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
#endif
LWSTDAPI_(BOOL)     PathIsLFNFileSpecA(__in LPCSTR lpName);
LWSTDAPI_(BOOL)     PathIsLFNFileSpecW(__in LPCWSTR lpName);
#ifdef UNICODE
#define PathIsLFNFileSpec  PathIsLFNFileSpecW
#else
#define PathIsLFNFileSpec  PathIsLFNFileSpecA
#endif // !UNICODE
LWSTDAPI_(UINT)     PathGetCharTypeA(__in UCHAR ch);
LWSTDAPI_(UINT)     PathGetCharTypeW(__in WCHAR ch);

// Return flags for PathGetCharType
#define GCT_INVALID             0x0000
#define GCT_LFNCHAR             0x0001
#define GCT_SHORTCHAR           0x0002
#define GCT_WILD                0x0004
#define GCT_SEPARATOR           0x0008

LWSTDAPI_(int)      PathGetDriveNumberA(__in LPCSTR pszPath);
LWSTDAPI_(int)      PathGetDriveNumberW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetDriveNumber  PathGetDriveNumberW
#else
#define PathGetDriveNumber  PathGetDriveNumberA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectory  PathIsDirectoryW
#else
#define PathIsDirectory  PathIsDirectoryA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyW
#else
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsFileSpecA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsFileSpecW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsFileSpec  PathIsFileSpecW
#else
#define PathIsFileSpec  PathIsFileSpecA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsPrefixA(__in LPCSTR pszPrefix, __in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsPrefixW(__in LPCWSTR pszPrefix, __in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsPrefix  PathIsPrefixW
#else
#define PathIsPrefix  PathIsPrefixA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRelativeA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRelativeW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRelative  PathIsRelativeW
#else
#define PathIsRelative  PathIsRelativeA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRootA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRootW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRoot  PathIsRootW
#else
#define PathIsRoot  PathIsRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSameRootA(__in LPCSTR pszPath1, __in LPCSTR pszPath2);
LWSTDAPI_(BOOL)     PathIsSameRootW(__in LPCWSTR pszPath1, __in LPCWSTR pszPath2);
#ifdef UNICODE
#define PathIsSameRoot  PathIsSameRootW
#else
#define PathIsSameRoot  PathIsSameRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNC  PathIsUNCW
#else
#define PathIsUNC  PathIsUNCA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsNetworkPathA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsNetworkPathW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsNetworkPath  PathIsNetworkPathW
#else
#define PathIsNetworkPath  PathIsNetworkPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServer  PathIsUNCServerW
#else
#define PathIsUNCServer  PathIsUNCServerA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerShareA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerShareW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServerShare  PathIsUNCServerShareW
#else
#define PathIsUNCServerShare  PathIsUNCServerShareA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsContentTypeA(__in LPCSTR pszPath, __in LPCSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsContentTypeW(__in LPCWSTR pszPath, __in LPCWSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsURLA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsURLW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsURL  PathIsURLW
#else
#define PathIsURL  PathIsURLA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathMakePrettyA(__inout LPSTR pszPath);
LWSTDAPI_(BOOL)     PathMakePrettyW(__inout LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathMatchSpecA(__in LPCSTR pszFile, __in LPCSTR pszSpec);
LWSTDAPI_(BOOL)     PathMatchSpecW(__in LPCWSTR pszFile, __in LPCWSTR pszSpec);

#if (_WIN32_IE >= _WIN32_IE_IE70)
// Flags for PathMatchSpecEx
#define PMSF_NORMAL            0x00000000
#define PMSF_MULTIPLE          0x00000001
#define PMSF_DONT_STRIP_SPACES 0x00010000  // modifies either of the above

LWSTDAPI PathMatchSpecExA(__in LPCSTR pszFile, __in LPCSTR pszSpec, __in DWORD dwFlags);
LWSTDAPI PathMatchSpecExW(__in LPCWSTR pszFile, __in LPCWSTR pszSpec, __in DWORD dwFlags);
#endif // _WIN32_IE_IE70

LWSTDAPI_(int)      PathParseIconLocationA(__inout LPSTR pszIconFile);
LWSTDAPI_(int)      PathParseIconLocationW(__inout LPWSTR pszIconFile);
LWSTDAPI_(BOOL)     PathQuoteSpacesA(__inout_ecount(MAX_PATH) LPSTR lpsz);
LWSTDAPI_(BOOL)     PathQuoteSpacesW(__inout_ecount(MAX_PATH) LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathRelativePathToA(__out_ecount(MAX_PATH) LPSTR pszPath, __in LPCSTR pszFrom, __in DWORD dwAttrFrom, __in LPCSTR pszTo, __in DWORD dwAttrTo);
LWSTDAPI_(BOOL)     PathRelativePathToW(__out_ecount(MAX_PATH) LPWSTR pszPath, __in LPCWSTR pszFrom, __in DWORD dwAttrFrom, __in LPCWSTR pszTo, __in DWORD dwAttrTo);
LWSTDAPI_(void)     PathRemoveArgsA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveArgsW(__inout LPWSTR pszPath);
LWSTDAPI_(LPSTR)  PathRemoveBackslashA(__inout LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathRemoveBackslashW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathRemoveBackslash  PathRemoveBackslashW
#else
#define PathRemoveBackslash  PathRemoveBackslashA
#endif // !UNICODE
LWSTDAPI_(void)     PathRemoveBlanksA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveBlanksW(__inout LPWSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionW(__inout LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecA(__inout LPSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecW(__inout LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRenameExtensionA(__inout_ecount(MAX_PATH) LPSTR pszPath, __in LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathRenameExtensionW(__inout_ecount(MAX_PATH) LPWSTR pszPath, __in LPCWSTR pszExt);
LWSTDAPI_(BOOL)     PathSearchAndQualifyA(__in LPCSTR pszPath, __out_ecount(cchBuf) LPSTR pszBuf, UINT __in cchBuf);
LWSTDAPI_(BOOL)     PathSearchAndQualifyW(__in LPCWSTR pszPath, __out_ecount(cchBuf) LPWSTR pszBuf, __in UINT cchBuf);
LWSTDAPI_(void)     PathSetDlgItemPathA(__in HWND hDlg, int id, LPCSTR pszPath);
LWSTDAPI_(void)     PathSetDlgItemPathW(__in HWND hDlg, int id, LPCWSTR pszPath);
#ifdef USE_STRICT_CONST
LWSTDAPI_(LPCSTR)  PathSkipRootA(__in LPCSTR pszPath);
LWSTDAPI_(LPCWSTR)  PathSkipRootW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
#else
LWSTDAPI_(LPSTR)  PathSkipRootA(__in LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathSkipRootW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
#endif
LWSTDAPI_(void)     PathStripPathA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathStripPathW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathStripPath  PathStripPathW
#else
#define PathStripPath  PathStripPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathStripToRootA(__inout LPSTR pszPath);
LWSTDAPI_(BOOL)     PathStripToRootW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathStripToRoot  PathStripToRootW
#else
#define PathStripToRoot  PathStripToRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnquoteSpacesA(__inout LPSTR lpsz);
LWSTDAPI_(BOOL)     PathUnquoteSpacesW(__inout LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathMakeSystemFolderA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathMakeSystemFolderW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathMakeSystemFolder  PathMakeSystemFolderW
#else
#define PathMakeSystemFolder  PathMakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderA(__in LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderW(__in LPCWSTR pszPath);
#ifdef UNICODE
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderW
#else
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSystemFolderA(__in_opt LPCSTR pszPath, __in DWORD dwAttrb);
LWSTDAPI_(BOOL)     PathIsSystemFolderW(__in_opt LPCWSTR pszPath, __in DWORD dwAttrb);
#ifdef UNICODE
#define PathIsSystemFolder  PathIsSystemFolderW
#else
#define PathIsSystemFolder  PathIsSystemFolderA
#endif // !UNICODE
LWSTDAPI_(void)     PathUndecorateA(__inout LPSTR pszPath);
LWSTDAPI_(void)     PathUndecorateW(__inout LPWSTR pszPath);
#ifdef UNICODE
#define PathUndecorate  PathUndecorateW
#else
#define PathUndecorate  PathUndecorateA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsA(__in LPCSTR pszPath, __out_ecount(cchBuf) LPSTR pszBuf, __in UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsW(__in LPCWSTR pszPath, __out_ecount(cchBuf) LPWSTR pszBuf, __in UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsW
#else
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsA
#endif // !UNICODE


#ifdef UNICODE
#define PathAppend              PathAppendW
#define PathCanonicalize        PathCanonicalizeW
#define PathCompactPath         PathCompactPathW
#define PathCompactPathEx       PathCompactPathExW
#define PathCommonPrefix        PathCommonPrefixW
#define PathFindOnPath          PathFindOnPathW
#define PathGetCharType         PathGetCharTypeW
#define PathIsContentType       PathIsContentTypeW
#define PathIsHTMLFile          PathIsHTMLFileW
#define PathMakePretty          PathMakePrettyW
#define PathMatchSpec           PathMatchSpecW
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PathMatchSpecEx         PathMatchSpecExW
#endif // _WIN32_IE_IE70
#define PathParseIconLocation   PathParseIconLocationW
#define PathQuoteSpaces         PathQuoteSpacesW
#define PathRelativePathTo      PathRelativePathToW
#define PathRemoveArgs          PathRemoveArgsW
#define PathRemoveBlanks        PathRemoveBlanksW
#define PathRemoveExtension     PathRemoveExtensionW
#define PathRemoveFileSpec      PathRemoveFileSpecW
#define PathRenameExtension     PathRenameExtensionW
#define PathSearchAndQualify    PathSearchAndQualifyW
#define PathSetDlgItemPath      PathSetDlgItemPathW
#define PathUnquoteSpaces       PathUnquoteSpacesW
#else
#define PathAppend              PathAppendA
#define PathCanonicalize        PathCanonicalizeA
#define PathCompactPath         PathCompactPathA
#define PathCompactPathEx       PathCompactPathExA
#define PathCommonPrefix        PathCommonPrefixA
#define PathFindOnPath          PathFindOnPathA
#define PathGetCharType         PathGetCharTypeA
#define PathIsContentType       PathIsContentTypeA
#define PathIsHTMLFile          PathIsHTMLFileA
#define PathMakePretty          PathMakePrettyA
#define PathMatchSpec           PathMatchSpecA
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PathMatchSpecEx         PathMatchSpecExA
#endif // _WIN32_IE_IE70
#define PathParseIconLocation   PathParseIconLocationA
#define PathQuoteSpaces         PathQuoteSpacesA
#define PathRelativePathTo      PathRelativePathToA
#define PathRemoveArgs          PathRemoveArgsA
#define PathRemoveBlanks        PathRemoveBlanksA
#define PathRemoveExtension     PathRemoveExtensionA
#define PathRemoveFileSpec      PathRemoveFileSpecA
#define PathRenameExtension     PathRenameExtensionA
#define PathSearchAndQualify    PathSearchAndQualifyA
#define PathSetDlgItemPath      PathSetDlgItemPathA
#define PathUnquoteSpaces       PathUnquoteSpacesA
#endif

typedef enum
{
    URL_SCHEME_INVALID     = -1,
    URL_SCHEME_UNKNOWN     =  0,
    URL_SCHEME_FTP,
    URL_SCHEME_HTTP,
    URL_SCHEME_GOPHER,
    URL_SCHEME_MAILTO,
    URL_SCHEME_NEWS,
    URL_SCHEME_NNTP,
    URL_SCHEME_TELNET,
    URL_SCHEME_WAIS,
    URL_SCHEME_FILE,
    URL_SCHEME_MK,
    URL_SCHEME_HTTPS,
    URL_SCHEME_SHELL,
    URL_SCHEME_SNEWS,
    URL_SCHEME_LOCAL,
    URL_SCHEME_JAVASCRIPT,
    URL_SCHEME_VBSCRIPT,
    URL_SCHEME_ABOUT,
    URL_SCHEME_RES,
#if (_WIN32_IE >= _WIN32_IE_IE60)
    URL_SCHEME_MSSHELLROOTED,
    URL_SCHEME_MSSHELLIDLIST,
    URL_SCHEME_MSHELP,
#endif // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE70)
    URL_SCHEME_MSSHELLDEVICE,
    URL_SCHEME_WILDCARD,
#endif // _WIN32_IE_IE70
#if (NTDDI_VERSION >= NTDDI_VISTA)
    URL_SCHEME_SEARCH_MS,
#endif
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
    URL_SCHEME_SEARCH,
#endif
#if (NTDDI_VERSION >= NTDDI_WIN7)
    URL_SCHEME_KNOWNFOLDER,
#endif
    URL_SCHEME_MAXVALUE,
} URL_SCHEME;

typedef enum
{
    URL_PART_NONE       = 0,
    URL_PART_SCHEME     = 1,
    URL_PART_HOSTNAME,
    URL_PART_USERNAME,
    URL_PART_PASSWORD,
    URL_PART_PORT,
    URL_PART_QUERY,
} URL_PART;

typedef enum
{
    URLIS_URL,
    URLIS_OPAQUE,
    URLIS_NOHISTORY,
    URLIS_FILEURL,
    URLIS_APPLIABLE,
    URLIS_DIRECTORY,
    URLIS_HASQUERY,
} URLIS;

#define URL_UNESCAPE                    0x10000000
#define URL_ESCAPE_UNSAFE               0x20000000
#define URL_PLUGGABLE_PROTOCOL          0x40000000
#define URL_WININET_COMPATIBILITY       0x80000000
#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_ESCAPE_SPACES_ONLY          0x04000000
#define URL_DONT_SIMPLIFY               0x08000000
#define URL_NO_META                     URL_DONT_SIMPLIFY
#define URL_UNESCAPE_INPLACE            0x00100000
#define URL_CONVERT_IF_DOSPATH          0x00200000
#define URL_UNESCAPE_HIGH_ANSI_ONLY     0x00400000
#define URL_INTERNAL_PATH               0x00800000  // Will escape #'s in paths
#define URL_FILE_USE_PATHURL            0x00010000
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URL_DONT_UNESCAPE               0x00020000  // Do not unescape the path/url at all
#endif // _WIN32_IE_IE60SP2
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define URL_ESCAPE_AS_UTF8              0x00040000  // Percent-encode all non-ASCII characters as their UTF-8 equivalents.
#endif // (NTDDI_VERSION >= NTDDI_WIN7)
#define URL_ESCAPE_PERCENT              0x00001000
#define URL_ESCAPE_SEGMENT_ONLY         0x00002000  // Treat the entire URL param as one URL segment.

#define URL_PARTFLAG_KEEPSCHEME         0x00000001

#define URL_APPLY_DEFAULT               0x00000001
#define URL_APPLY_GUESSSCHEME           0x00000002
#define URL_APPLY_GUESSFILE             0x00000004
#define URL_APPLY_FORCEAPPLY            0x00000008


LWSTDAPI_(int)          UrlCompareA(__in LPCSTR psz1, __in LPCSTR psz2, __in BOOL fIgnoreSlash);
LWSTDAPI_(int)          UrlCompareW(__in LPCWSTR psz1, __in  LPCWSTR psz2, __in BOOL fIgnoreSlash);
LWSTDAPI                UrlCombineA(LPCSTR pszBase, LPCSTR pszRelative, __out_ecount_opt(*pcchCombined) LPSTR pszCombined, __inout LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCombineW(LPCWSTR pszBase, LPCWSTR pszRelative, __out_ecount_opt(*pcchCombined) LPWSTR pszCombined, __inout LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeA(__in LPCSTR pszUrl, __out_ecount(*pcchCanonicalized) LPSTR pszCanonicalized, __inout LPDWORD pcchCanonicalized, __in DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeW(__in LPCWSTR pszUrl, __out_ecount(*pcchCanonicalized) LPWSTR pszCanonicalized, __inout LPDWORD pcchCanonicalized, __in DWORD dwFlags);
LWSTDAPI_(BOOL)         UrlIsOpaqueA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsOpaqueW(LPCWSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryW(LPCWSTR pszURL);
#define                 UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define                 UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)
LWSTDAPI_(BOOL)         UrlIsA(LPCSTR pszUrl, __in URLIS UrlIs);
LWSTDAPI_(BOOL)         UrlIsW(LPCWSTR pszUrl, __in URLIS UrlIs);
LWSTDAPI_(LPCSTR)       UrlGetLocationA(LPCSTR psz1);
LWSTDAPI_(LPCWSTR)      UrlGetLocationW(LPCWSTR psz1);
LWSTDAPI                UrlUnescapeA(__inout LPSTR pszUrl, __out_ecount_opt(*pcchUnescaped) LPSTR pszUnescaped, __inout_opt LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlUnescapeW(__inout LPWSTR pszUrl, __out_ecount_opt(*pcchUnescaped) LPWSTR pszUnescaped, __inout_opt LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeA(__in LPCSTR pszUrl, __out_ecount(*pcchEscaped) LPSTR pszEscaped, __inout LPDWORD pcchEscaped, __in DWORD dwFlags);
LWSTDAPI                UrlEscapeW(__in LPCWSTR pszUrl, __out_ecount(*pcchEscaped) LPWSTR pszEscaped, __inout LPDWORD pcchEscaped, __in DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathA(LPCSTR pszPath, __out_ecount(*pcchUrl) LPSTR pszUrl, __inout LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathW(LPCWSTR pszPath, __out_ecount(*pcchUrl) LPWSTR pszUrl, __inout LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlA(LPCSTR pszUrl, __out_ecount(*pcchPath) LPSTR pszPath, __inout LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlW(LPCWSTR pszUrl, __out_ecount(*pcchPath) LPWSTR pszPath, __inout LPDWORD pcchPath, DWORD dwFlags);
#if (_WIN32_IE >= _WIN32_IE_IE70)
LWSTDAPI                PathCreateFromUrlAlloc(LPCWSTR pszIn, __out LPWSTR *ppszOut, DWORD dwFlags);
#endif // _WIN32_IE_IE70
LWSTDAPI                UrlHashA(LPCSTR pszUrl, __out_ecount(cbHash) LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlHashW(LPCWSTR pszUrl, __out_ecount(cbHash) LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlGetPartW(__in LPCWSTR pszIn, __out_ecount(*pcchOut) LPWSTR pszOut, __inout LPDWORD pcchOut, __in DWORD dwPart, __in DWORD dwFlags);
LWSTDAPI                UrlGetPartA(__in LPCSTR pszIn, __out_ecount(*pcchOut) LPSTR pszOut, __inout LPDWORD pcchOut, __in DWORD dwPart, __in DWORD dwFlags);
LWSTDAPI                UrlApplySchemeA(LPCSTR pszIn, __out_ecount(*pcchOut) LPSTR pszOut, __inout LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeW(LPCWSTR pszIn, __out_ecount(*pcchOut) LPWSTR pszOut, __inout LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                HashData(__in_ecount(cbData) LPBYTE pbData, DWORD cbData, __out_ecount(cbHash) LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlFixupW(LPCWSTR pszIn, __out_ecount(cchOut) LPWSTR pszOut, DWORD cchOut);

#ifdef UNICODE
#define UrlCompare              UrlCompareW
#define UrlCombine              UrlCombineW
#define UrlCanonicalize         UrlCanonicalizeW
#define UrlIsOpaque             UrlIsOpaqueW
#define UrlIsFileUrl            UrlIsFileUrlW
#define UrlGetLocation          UrlGetLocationW
#define UrlUnescape             UrlUnescapeW
#define UrlEscape               UrlEscapeW
#define UrlCreateFromPath       UrlCreateFromPathW
#define PathCreateFromUrl       PathCreateFromUrlW
#define UrlHash                 UrlHashW
#define UrlGetPart              UrlGetPartW
#define UrlApplyScheme          UrlApplySchemeW
#define UrlIs                   UrlIsW
#define UrlFixup                UrlFixupW
#else //!UNICODE
#define UrlCompare              UrlCompareA
#define UrlCombine              UrlCombineA
#define UrlCanonicalize         UrlCanonicalizeA
#define UrlIsOpaque             UrlIsOpaqueA
#define UrlIsFileUrl            UrlIsFileUrlA
#define UrlGetLocation          UrlGetLocationA
#define UrlUnescape             UrlUnescapeA
#define UrlEscape               UrlEscapeA
#define UrlCreateFromPath       UrlCreateFromPathA
#define PathCreateFromUrl       PathCreateFromUrlA
#define UrlHash                 UrlHashA
#define UrlGetPart              UrlGetPartA
#define UrlApplyScheme          UrlApplySchemeA
#define UrlIs                   UrlIsA
// no UrlFixupA
#endif //UNICODE

#define UrlEscapeSpaces(pszUrl, pszEscaped, pcchEscaped)        UrlCanonicalize(pszUrl, pszEscaped, pcchEscaped, URL_ESCAPE_SPACES_ONLY |URL_DONT_ESCAPE_EXTRA_INFO )
#define UrlUnescapeInPlace(pszUrl, dwFlags)                     UrlUnescape(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)


#if (_WIN32_IE >= _WIN32_IE_IE50)

typedef struct tagPARSEDURLA {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCSTR    pszProtocol;
    UINT      cchProtocol;
    LPCSTR    pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLA, * PPARSEDURLA;
typedef struct tagPARSEDURLW {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCWSTR   pszProtocol;
    UINT      cchProtocol;
    LPCWSTR   pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLW, * PPARSEDURLW;
#ifdef UNICODE
typedef PARSEDURLW PARSEDURL;
typedef PPARSEDURLW PPARSEDURL;
#else
typedef PARSEDURLA PARSEDURL;
typedef PPARSEDURLA PPARSEDURL;
#endif // UNICODE

LWSTDAPI            ParseURLA(LPCSTR pcszURL, __inout PARSEDURLA * ppu);
LWSTDAPI            ParseURLW(LPCWSTR pcszURL, __inout PARSEDURLW * ppu);
#ifdef UNICODE
#define ParseURL  ParseURLW
#else
#define ParseURL  ParseURLA
#endif // !UNICODE

#endif  // _WIN32_IE_IE50


#endif //  NO_SHLWAPI_PATH



#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//


// SHDeleteEmptyKey mimics RegDeleteKey as it behaves on NT.
// SHDeleteKey mimics RegDeleteKey as it behaves on Win95.

LWSTDAPI_(LSTATUS)  SHDeleteEmptyKeyA(__in HKEY hkey, __in_opt LPCSTR pszSubKey);
LWSTDAPI_(LSTATUS)  SHDeleteEmptyKeyW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteEmptyKey  SHDeleteEmptyKeyW
#else
#define SHDeleteEmptyKey  SHDeleteEmptyKeyA
#endif // !UNICODE
LWSTDAPI_(LSTATUS)  SHDeleteKeyA(__in HKEY hkey, __in_opt LPCSTR pszSubKey);
LWSTDAPI_(LSTATUS)  SHDeleteKeyW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteKey  SHDeleteKeyW
#else
#define SHDeleteKey  SHDeleteKeyA
#endif // !UNICODE
LWSTDAPI_(HKEY)     SHRegDuplicateHKey(__in HKEY hkey);


// These functions open the key, get/set/delete the value, then close
// the key.

LWSTDAPI_(LSTATUS)    SHDeleteValueA(__in HKEY hkey, __in_opt LPCSTR pszSubKey, __in_opt LPCSTR pszValue);
LWSTDAPI_(LSTATUS)    SHDeleteValueW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue);
#ifdef UNICODE
#define SHDeleteValue  SHDeleteValueW
#else
#define SHDeleteValue  SHDeleteValueA
#endif // !UNICODE
LWSTDAPI_(LSTATUS)    SHGetValueA(
    __in                       HKEY hkey,
    __in_opt                   LPCSTR  pszSubKey,
    __in_opt                   LPCSTR  pszValue,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_opt(*pcbData) void     *pvData,
    __inout_opt                DWORD    *pcbData);
LWSTDAPI_(LSTATUS)    SHGetValueW(
    __in                       HKEY hkey,
    __in_opt                   LPCWSTR  pszSubKey,
    __in_opt                   LPCWSTR  pszValue,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_opt(*pcbData) void     *pvData,
    __inout_opt                DWORD    *pcbData);
#ifdef UNICODE
#define SHGetValue  SHGetValueW
#else
#define SHGetValue  SHGetValueA
#endif // !UNICODE
LWSTDAPI_(LSTATUS)    SHSetValueA(__in HKEY hkey, __in_opt LPCSTR pszSubKey, __in_opt LPCSTR pszValue, __in DWORD dwType,
    __in_bcount_opt(cbData) LPCVOID pvData, __in DWORD cbData);
LWSTDAPI_(LSTATUS)    SHSetValueW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue, __in DWORD dwType,
    __in_bcount_opt(cbData) LPCVOID pvData, __in DWORD cbData);
#ifdef UNICODE
#define SHSetValue  SHSetValueW
#else
#define SHSetValue  SHSetValueA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0602)
//
// SRRF - Shell Registry Routine Flags (for SHRegGetValue)
//

typedef int SRRF;

#define SRRF_RT_REG_NONE        0x00000001  // restrict type to REG_NONE      (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_SZ          0x00000002  // restrict type to REG_SZ        (other data types will not return ERROR_SUCCESS) (automatically converts REG_EXPAND_SZ to REG_SZ unless SRRF_NOEXPAND is specified)
#define SRRF_RT_REG_EXPAND_SZ   0x00000004  // restrict type to REG_EXPAND_SZ (other data types will not return ERROR_SUCCESS) (must specify SRRF_NOEXPAND or SHRegGetValue will fail with ERROR_INVALID_PARAMETER)
#define SRRF_RT_REG_BINARY      0x00000008  // restrict type to REG_BINARY    (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_DWORD       0x00000010  // restrict type to REG_DWORD     (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_MULTI_SZ    0x00000020  // restrict type to REG_MULTI_SZ  (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_QWORD       0x00000040  // restrict type to REG_QWORD     (other data types will not return ERROR_SUCCESS)

#define SRRF_RT_DWORD           (SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD) // restrict type to *32-bit* SRRF_RT_REG_BINARY or SRRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_QWORD           (SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD) // restrict type to *64-bit* SRRF_RT_REG_BINARY or SRRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_ANY             0x0000ffff                               // no type restriction

#define SRRF_RM_ANY             0x00000000  // no mode restriction (default is to allow any mode)
#define SRRF_RM_NORMAL          0x00010000  // restrict system startup mode to "normal boot"               (other startup modes will not return ERROR_SUCCESS)
#define SRRF_RM_SAFE            0x00020000  // restrict system startup mode to "safe mode"                 (other startup modes will not return ERROR_SUCCESS)
#define SRRF_RM_SAFENETWORK     0x00040000  // restrict system startup mode to "safe mode with networking" (other startup modes will not return ERROR_SUCCESS)

#define SRRF_NOEXPAND           0x10000000  // do not automatically expand environment strings if value is of type REG_EXPAND_SZ
#define SRRF_ZEROONFAILURE      0x20000000  // if pvData is not NULL, set content to all zeros on failure
#define SRRF_NOVIRT             0x40000000  // if the requested key is virtualized, then fail with ERROR_FILE_NOT_FOUND


// Function:
//
//  SHRegGetValue()
//
// Purpose:
//
//  Gets a registry value.  SHRegGetValue() provides the following benefits:
//
//  - data type checking
//  - boot mode checking
//  - auto-expansion of REG_EXPAND_SZ data
//  - guaranteed NULL termination of REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ data
//
// Parameters:
//
//  hkey        - handle to a currently open key.
//
//  pszSubKey   - pointer to a null-terminated string specifying the relative
//                path from hkey to one of its subkeys from which the data is
//                to be retrieved.  this will be opened with KEY_READ sam.
//
//                Note1: pszSubKey can be NULL or "".  In either of these two
//                       cases, the data is retrieved from the hkey itself.
//                Note2: *** PERF ***
//                       If pszSubKey is not NULL or "", the subkey will be
//                       automatically be opened and closed by this routine
//                       in order to obtain the data.  If you are retrieving
//                       multiple values from the same subkey, it is better
//                       for perf to open the subkey via RegOpenKeyEx() prior
//                       to calling this method, and using this opened key as
//                       hkey with pszSubKey set to NULL.
//
//  pszValue    - pointer to a null-terminated string specifying the name of
//                the value to query for data
//
//                Note1: pszValue can be NULL or "".  In either of these two
//                       cases, the data is retrieved from the unnamed or
//                       default value.
//
//  srrfFlags   - bitwise or of SRRF_ flags, which cannot be 0:  at least one
//                type restriction must be specified (SRRF_RT_...), or if any
//                type is desired then SRRF_RT_ANY can be specified
//
//                Note1: SRRF_RT_ANY will allow any data type to be returned.
//                Note2: The following two type restrictions have special
//                       handling semantics:
//
//                         SRRF_RT_DWORD == SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD
//                         SRRF_RT_QWORD == SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD
//
//                       If either of these are specified, with no other type
//                       restrictions, then in the prior case the restriction
//                       will limit "valid" returned data to either REG_DWORD
//                       or 32-bit REG_BINARY data, and in the latter case
//                       the restriction will limit "valid" returned data to
//                       either REG_QWORD or 64-bit REG_BINARY.
//
//  pdwType     - pointer to a dword which receives a code indicating the
//                type of data stored in the specified value
//
//                Note1: pdwType can be NULL if no type information is wanted
//                Note2: If pdwType is not NULL, and the SRRF_NOEXPAND flag
//                       has not been set, data types of REG_EXPAND_SZ will
//                       be returned as REG_SZ since they are automatically
//                       expanded in this method.
//
//  pvData      - pointer to a buffer that receives the value's data
//
//                Note1: pvData can be NULL if the data is not required.
//                       pvData is usually NULL if doing either a simple
//                       existence test, or if interested in the size only.
//                Note2: *** PERF ***
//                       Reference 'perf' note for pcbData.
//
//  pcbData     - when pvData is NULL:
//                  optional pointer to a dword that receives a size in bytes
//                  which would be sufficient to hold the registry data (note
//                  this size is not guaranteed to be exact, merely sufficient)
//                when pvData is not NULL:
//                  required pointer to a dword that specifies the size in
//                  bytes of the buffer pointed to by the pvData parameter
//                  and receives a size in bytes of:
//                  a) the number of bytes read into pvData on ERROR_SUCCESS
//                     (note this size is guaranteed to be exact)
//                  b) the number of bytes which would be sufficient to hold
//                     the registry data on ERROR_MORE_DATA -- pvData was of
//                     insufficient size (note this size is not guaranteed to
//                     be exact, merely sufficient)
//
//                Note1: pcbData can be NULL only if pvData is NULL.
//                Note2: *** PERF ***
//                       The potential for an 'extra' call to the registry to
//                       read (or re-read) in the data exists when the data
//                       type is REG_EXPAND_SZ and the SRRF_NOEXPAND flag has
//                       not been set.  The following conditions will result
//                       in this 'extra' read operation:
//                       i)  when pvData is NULL and pcbData is not NULL
//                           we must read in the data from the registry
//                           anyway in order to obtain the string and perform
//                           an expand on it to obtain and return the total
//                           required size in pcbData
//                       ii) when pvData is not NULL but is of insufficient
//                           size we must re-read in the data from the
//                           registry in order to obtain the entire string
//                           and perform an expand on it to obtain and return
//                           the total required size in pcbData
//
// Remarks:
//
//  The key identified by hkey must have been opened with KEY_QUERY_VALUE
//  access.  If pszSubKey is not NULL or "", it must be able to be opened
//  with KEY_QUERY_VALUE access in the current calling context.
//
//  If the data type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then any
//  returned data is guaranteed to take into account proper null termination.
//  For example:  if pcbData is not NULL, its returned size will include the
//  bytes for a null terminator  if pvData is not NULL, its returned data
//  will be properly null terminated.
//
//  If the data type is REG_EXPAND_SZ, then unless the SRRF_NOEXPAND flag
//  is set the data will be automatically expanded prior to being returned.
//  For example:  if pdwType is not NULL, its returned type will be changed
//  to REG_SZ,  if pcbData is not NULL, its returned size will include the
//  bytes for a properly expanded string.  if pvData is not NULL, its
//  returned data will be the expanded version of the string.
//
//  Reference MSDN documentation for RegQueryValueEx() for more information
//  of the behaviour when pdwType, pvData, and/or pcbData are equal to NULL.
//
// Return Values:
//
//  If the function succeeds, the return value is ERROR_SUCCESS and all out
//  parameters requested (pdwType, pvData, pcbData) are valid.
//
//  If the function fails due to insufficient space in a provided non-NULL
//  pvData, the return value is ERROR_MORE_DATA and only pdwType and pcbData
//  can contain valid data.  The content of pvData in this case is undefined.
//
// Examples:
//
//  1) read REG_SZ (or REG_EXPAND_SZ as REG_SZ) "string" data from the (default) value of an open hkey
//
//      TCHAR szData[128]
//      DWORD cbData = sizeof(pszData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, NULL, SRRF_RT_REG_SZ, NULL, szData, &cbData))
//      {
//          // use sz (successful read)
//      }
//
//  2) read REG_SZ (or REG_EXPAND_SZ as REG_SZ) "string" data of unknown size from the "MyValue" value of an open hkey
//
//      DWORD cbData
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_REG_SZ, NULL, NULL, &cbData))
//      {
//          TCHAR *pszData = new TCHAR[cbData/sizeof(TCHAR)]
//          if (pszData)
//          {
//              if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_REG_SZ, NULL, pszData, &cbData))
//              {
//                  // use pszData (successful read)
//              }
//              delete[] pszData
//          }
//      }
//
//  3) read "dword" data from the "MyValue" value of the "MySubKey" subkey of an open hkey
//
//      DWORD dwData
//      DWORD cbData = sizeof(dwData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, TEXT("MySubKey"), TEXT("MyValue"), SRRF_RT_REG_DWORD, NULL, &dwData, &cbData))
//      {
//          // use dwData (successful read)
//      }
//
//  4) read "dword" data from the "MyValue" value of the "MySubKey" subkey of an open hkey (32-bit binary data also ok)
//
//      DWORD dwData
//      DWORD cbData = sizeof(dwData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, TEXT("MySubKey"), TEXT("MyValue"), SRRF_RT_DWORD, NULL, &dwData, &cbData))
//      {
//          // use dwData (successful read)
//      }
//
//  5) determine existence of "MyValue" value of an open hkey
//
//      BOOL bExists = ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_ANY, NULL, NULL, NULL)

LWSTDAPI_(LSTATUS) SHRegGetValueA(__in HKEY hkey, __in_opt LPCSTR pszSubKey, __in_opt LPCSTR pszValue,
    __in SRRF srrfFlags, __out_opt DWORD *pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt DWORD *pcbData);
LWSTDAPI_(LSTATUS) SHRegGetValueW(__in HKEY hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue,
    __in SRRF srrfFlags, __out_opt DWORD *pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt DWORD *pcbData);
#ifdef UNICODE
#define SHRegGetValue  SHRegGetValueW
#else
#define SHRegGetValue  SHRegGetValueA
#endif // !UNICODE

LWSTDAPI_(LSTATUS) SHRegSetValue(__in HKEY    hkey, __in_opt LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue, __in SRRF srrfFlags,
    __in DWORD dwType, __in_bcount_opt(cbData) LPCVOID pvData, __in_opt DWORD cbData);

LWSTDAPI_(LSTATUS) SHRegGetValueFromHKCUHKLM(__in PCWSTR pwszKey, __in_opt PCWSTR pwszValue, __in SRRF srrfFlags,
                                        __out_opt DWORD* pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void* pvData,
                                        __inout_opt DWORD * pcbData);
STDAPI_(BOOL) SHRegGetBoolValueFromHKCUHKLM(__in PCWSTR pszKey, __in_opt PCWSTR pszValue, __in BOOL fDefault);
#endif  // (_WIN32_IE >= 0x0602)

// These functions behave just like RegQueryValueEx(), except if the data
// type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then the string is
// guaranteed to be properly null terminated.
//
// Additionally, if the data type is REG_EXPAND_SZ these functions will
// go ahead and expand out the string, and "massage" the returned *pdwType
// to be REG_SZ.
LWSTDAPI_(LSTATUS) SHQueryValueExA(
    __in                       HKEY      hkey,
    __in_opt                   LPCSTR  pszValue,
    __reserved                 DWORD    *pdwReserved,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_part_opt(*pcbData,*pcbData) void  *pvData,
    __inout_opt                DWORD    *pcbData);
// These functions behave just like RegQueryValueEx(), except if the data
// type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then the string is
// guaranteed to be properly null terminated.
//
// Additionally, if the data type is REG_EXPAND_SZ these functions will
// go ahead and expand out the string, and "massage" the returned *pdwType
// to be REG_SZ.
LWSTDAPI_(LSTATUS) SHQueryValueExW(
    __in                       HKEY      hkey,
    __in_opt                   LPCWSTR  pszValue,
    __reserved                 DWORD    *pdwReserved,
    __out_opt                  DWORD    *pdwType,
    __out_bcount_part_opt(*pcbData,*pcbData) void  *pvData,
    __inout_opt                DWORD    *pcbData);
#ifdef UNICODE
#define SHQueryValueEx  SHQueryValueExW
#else
#define SHQueryValueEx  SHQueryValueExA
#endif // !UNICODE

// Enumeration functions support.

LWSTDAPI_(LSTATUS)     SHEnumKeyExA(__in HKEY hkey, DWORD dwIndex, __out_ecount(*pcchName) LPSTR pszName, __inout LPDWORD pcchName);
LWSTDAPI_(LSTATUS)     SHEnumKeyExW(__in HKEY hkey, DWORD dwIndex, __out_ecount(*pcchName) LPWSTR pszName, __inout LPDWORD pcchName);
LWSTDAPI_(LSTATUS)     SHEnumValueA(__in HKEY hkey, __in DWORD dwIndex, __out_ecount_opt(*pcchValueName) PSTR pszValueName,
    __inout_opt LPDWORD pcchValueName, __out_opt LPDWORD pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt LPDWORD pcbData);
LWSTDAPI_(LSTATUS)     SHEnumValueW(__in HKEY hkey, __in DWORD dwIndex, __out_ecount_opt(*pcchValueName) PWSTR pszValueName,
    __inout_opt LPDWORD pcchValueName, __out_opt LPDWORD pdwType, __out_bcount_part_opt(*pcbData,*pcbData) __typefix(LPBYTE) void *pvData,
    __inout_opt LPDWORD pcbData);
LWSTDAPI_(LSTATUS)     SHQueryInfoKeyA(__in HKEY hkey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen);
LWSTDAPI_(LSTATUS)     SHQueryInfoKeyW(__in HKEY hkey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen);

// recursive key copy
LWSTDAPI_(LSTATUS)     SHCopyKeyA(__in HKEY hkeySrc, __in_opt LPCSTR   szSrcSubKey, __in HKEY hkeyDest, __reserved DWORD fReserved);
LWSTDAPI_(LSTATUS)     SHCopyKeyW(__in HKEY hkeySrc, __in_opt LPCWSTR wszSrcSubKey, __in HKEY hkeyDest, __reserved DWORD fReserved);

// Getting and setting file system paths with environment variables

LWSTDAPI_(LSTATUS)    SHRegGetPathA(__in HKEY hKey, __in_opt LPCSTR pcszSubKey, __in_opt LPCSTR pcszValue, __out_ecount(MAX_PATH) LPSTR pszPath, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)    SHRegGetPathW(__in HKEY hKey, __in_opt LPCWSTR pcszSubKey, __in_opt LPCWSTR pcszValue, __out_ecount(MAX_PATH) LPWSTR pszPath, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)    SHRegSetPathA(__in HKEY hKey, __in_opt LPCSTR pcszSubKey, __in_opt LPCSTR pcszValue, __in LPCSTR pcszPath, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)    SHRegSetPathW(__in HKEY hKey, __in_opt LPCWSTR pcszSubKey, __in_opt LPCWSTR pcszValue, __in LPCWSTR pcszPath, __in DWORD dwFlags);

#ifdef UNICODE
#define SHEnumKeyEx           SHEnumKeyExW
#define SHEnumValue           SHEnumValueW
#define SHQueryInfoKey        SHQueryInfoKeyW
#define SHCopyKey             SHCopyKeyW
#define SHRegGetPath          SHRegGetPathW
#define SHRegSetPath          SHRegSetPathW
#else
#define SHEnumKeyEx           SHEnumKeyExA
#define SHEnumValue           SHEnumValueA
#define SHQueryInfoKey        SHQueryInfoKeyA
#define SHCopyKey             SHCopyKeyA
#define SHRegGetPath          SHRegGetPathA
#define SHRegSetPath          SHRegSetPathA
#endif


//////////////////////////////////////////////
// User Specific Registry Access Functions
//////////////////////////////////////////////

typedef enum
{
    SHREGDEL_DEFAULT = 0x00000000,       // Delete's HKCU, or HKLM if HKCU is not found.
    SHREGDEL_HKCU    = 0x00000001,       // Delete HKCU only
    SHREGDEL_HKLM    = 0x00000010,       // Delete HKLM only.
    SHREGDEL_BOTH    = 0x00000011,       // Delete both HKCU and HKLM.
} SHREGDEL_FLAGS;

typedef enum
{
    SHREGENUM_DEFAULT = 0x00000000,       // Enumerates HKCU or HKLM if not found.
    SHREGENUM_HKCU    = 0x00000001,       // Enumerates HKCU only
    SHREGENUM_HKLM    = 0x00000010,       // Enumerates HKLM only.
    SHREGENUM_BOTH    = 0x00000011,       // Enumerates both HKCU and HKLM without duplicates.
                                          // This option is NYI.
} SHREGENUM_FLAGS;

#define     SHREGSET_HKCU           0x00000001       // Write to HKCU if empty.
#define     SHREGSET_FORCE_HKCU     0x00000002       // Write to HKCU.
#define     SHREGSET_HKLM           0x00000004       // Write to HKLM if empty.
#define     SHREGSET_FORCE_HKLM     0x00000008       // Write to HKLM.
#define     SHREGSET_DEFAULT        (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)          // Default is SHREGSET_FORCE_HKCU | SHREGSET_HKLM.

typedef HANDLE HUSKEY;  // HUSKEY is a Handle to a User Specific KEY.
typedef HUSKEY *PHUSKEY;

LWSTDAPI_(LSTATUS)     SHRegCreateUSKeyA(__in LPCSTR pszPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegCreateUSKeyW(__in LPCWSTR pwzPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegOpenUSKeyA(__in LPCSTR pszPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in BOOL fIgnoreHKCU);
LWSTDAPI_(LSTATUS)     SHRegOpenUSKeyW(__in LPCWSTR pwzPath, __in REGSAM samDesired, __in_opt HUSKEY hRelativeUSKey, __out PHUSKEY phNewUSKey, __in BOOL fIgnoreHKCU);
LWSTDAPI_(LSTATUS)     SHRegQueryUSValueA(
    __in                                      HUSKEY  hUSKey,
    __in_opt                                  LPCSTR  pszValue,
    __inout_opt                               DWORD * pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void *  pvData,
    __inout_opt                               DWORD * pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void *  pvDefaultData,
    __in_opt                                  DWORD   dwDefaultDataSize);
LWSTDAPI_(LSTATUS)     SHRegQueryUSValueW(
    __in                                      HUSKEY  hUSKey,
    __in_opt                                  LPCWSTR  pszValue,
    __inout_opt                               DWORD * pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void *  pvData,
    __inout_opt                               DWORD * pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void *  pvDefaultData,
    __in_opt                                  DWORD   dwDefaultDataSize);
LWSTDAPI_(LSTATUS)     SHRegWriteUSValueA(__in HUSKEY hUSKey, __in LPCSTR pszValue, __in DWORD dwType, __in_bcount(cbData) const void *pvData, __in DWORD cbData, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegWriteUSValueW(__in HUSKEY hUSKey, __in LPCWSTR pwzValue, __in DWORD dwType, __in_bcount(cbData) const void *pvData, __in DWORD cbData, __in DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteUSValueA(__in HUSKEY hUSKey, __in LPCSTR pszValue, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteUSValueW(__in HUSKEY hUSKey, __in LPCWSTR pwzValue, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteEmptyUSKeyW(__in HUSKEY hUSKey, __in LPCWSTR pwzSubKey, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegDeleteEmptyUSKeyA(__in HUSKEY hUSKey, __in LPCSTR pszSubKey, __in SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSKeyA(__in HUSKEY hUSKey, __in DWORD dwIndex, __out_ecount_part(*pcchName,*pcchName) LPSTR pszName, __inout LPDWORD pcchName, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSKeyW(__in HUSKEY hUSKey, __in DWORD dwIndex, __out_ecount_part(*pcchName,*pcchName) LPWSTR pwzName, __inout LPDWORD pcchName, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSValueA(__in HUSKEY hUSkey, __in DWORD dwIndex,
    __out_ecount_part(*pcchValueName,*pcchValueName) LPSTR pszValueName, __inout LPDWORD pcchValueName, __out_opt LPDWORD pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData, __inout_opt LPDWORD pcbData, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegEnumUSValueW(__in HUSKEY hUSkey, __in DWORD dwIndex,
    __out_ecount_part(*pcchValueName,*pcchValueName) LPWSTR pszValueName, __inout LPDWORD pcchValueName, __out_opt LPDWORD pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData, __inout_opt LPDWORD pcbData, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegQueryInfoUSKeyA(__in HUSKEY hUSKey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegQueryInfoUSKeyW(__in HUSKEY hUSKey, __out_opt LPDWORD pcSubKeys, __out_opt LPDWORD pcchMaxSubKeyLen, __out_opt LPDWORD pcValues, __out_opt LPDWORD pcchMaxValueNameLen, __in SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LSTATUS)     SHRegCloseUSKey(__in HUSKEY hUSKey);


// These calls are equal to an SHRegOpenUSKey, SHRegQueryUSValue, and then a SHRegCloseUSKey.
STDAPI_(LSTATUS) SHRegGetUSValueA(
    __in                                      LPCSTR  pszSubKey,
    __in_opt                                  LPCSTR  pszValue,
    __inout_opt                               DWORD  *pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void   *pvData,
    __inout_opt                               DWORD  *pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void   *pvDefaultData,
    __in                                      DWORD   dwDefaultDataSize);
STDAPI_(LSTATUS) SHRegGetUSValueW(
    __in                                      LPCWSTR  pszSubKey,
    __in_opt                                  LPCWSTR  pszValue,
    __inout_opt                               DWORD  *pdwType,
    __out_bcount_part_opt(*pcbData, *pcbData) void   *pvData,
    __inout_opt                               DWORD  *pcbData,
    __in                                      BOOL    fIgnoreHKCU,
    __in_bcount_opt(dwDefaultDataSize)        void   *pvDefaultData,
    __in                                      DWORD   dwDefaultDataSize);
LWSTDAPI_(LSTATUS)     SHRegSetUSValueA(__in LPCSTR pszSubKey, __in LPCSTR pszValue, __in DWORD dwType, __in_bcount_opt(cbData) const void *pvData, __in_opt DWORD cbData, __in_opt DWORD dwFlags);
LWSTDAPI_(LSTATUS)     SHRegSetUSValueW(__in LPCWSTR pwzSubKey, __in LPCWSTR pwzValue, __in DWORD dwType, __in_bcount_opt(cbData) const void *pvData, __in_opt DWORD cbData, __in_opt DWORD dwFlags);
LWSTDAPI_(int)         SHRegGetIntW(__in HKEY hk, __in_opt PCWSTR pwzKey, __in int iDefault);

#ifdef UNICODE
#define SHRegCreateUSKey        SHRegCreateUSKeyW
#define SHRegOpenUSKey          SHRegOpenUSKeyW
#define SHRegQueryUSValue       SHRegQueryUSValueW
#define SHRegWriteUSValue       SHRegWriteUSValueW
#define SHRegDeleteUSValue      SHRegDeleteUSValueW
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyW
#define SHRegEnumUSKey          SHRegEnumUSKeyW
#define SHRegEnumUSValue        SHRegEnumUSValueW
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyW
#define SHRegGetUSValue         SHRegGetUSValueW
#define SHRegSetUSValue         SHRegSetUSValueW
#define SHRegGetInt             SHRegGetIntW
#else
#define SHRegCreateUSKey        SHRegCreateUSKeyA
#define SHRegOpenUSKey          SHRegOpenUSKeyA
#define SHRegQueryUSValue       SHRegQueryUSValueA
#define SHRegWriteUSValue       SHRegWriteUSValueA
#define SHRegDeleteUSValue      SHRegDeleteUSValueA
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyA
#define SHRegEnumUSKey          SHRegEnumUSKeyA
#define SHRegEnumUSValue        SHRegEnumUSValueA
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyA
#define SHRegGetUSValue         SHRegGetUSValueA
#define SHRegSetUSValue         SHRegSetUSValueA
#endif

LWSTDAPI_(BOOL) SHRegGetBoolUSValueA(__in LPCSTR pszSubKey, __in_opt LPCSTR pszValue, __in BOOL fIgnoreHKCU, __in BOOL fDefault);
LWSTDAPI_(BOOL) SHRegGetBoolUSValueW(__in LPCWSTR pszSubKey, __in_opt LPCWSTR pszValue, __in BOOL fIgnoreHKCU, __in BOOL fDefault);
#ifdef UNICODE
#define SHRegGetBoolUSValue  SHRegGetBoolUSValueW
#else
#define SHRegGetBoolUSValue  SHRegGetBoolUSValueA
#endif // !UNICODE

//
//  Association APIs
//
//  these APIs are to assist in accessing the data in HKCR
//  getting the Command strings and exe paths
//  for different verbs and extensions are simplified this way
//

enum
{
    ASSOCF_INIT_NOREMAPCLSID           = 0x00000001,  //  do not remap clsids to progids
    ASSOCF_INIT_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_OPEN_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_INIT_DEFAULTTOSTAR          = 0x00000004,  //  treat "*" as the BaseClass
    ASSOCF_INIT_DEFAULTTOFOLDER        = 0x00000008,  //  treat "Folder" as the BaseClass
    ASSOCF_NOUSERSETTINGS              = 0x00000010,  //  dont use HKCU
    ASSOCF_NOTRUNCATE                  = 0x00000020,  //  dont truncate the return string
    ASSOCF_VERIFY                      = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCF_REMAPRUNDLL                 = 0x00000080,  //  actually gets info about rundlls target if applicable
    ASSOCF_NOFIXUPS                    = 0x00000100,  //  attempt to fix errors if found
    ASSOCF_IGNOREBASECLASS             = 0x00000200,  //  dont recurse into the baseclass
    ASSOCF_INIT_IGNOREUNKNOWN          = 0x00000400,  //  dont use the "Unknown" progid, instead fail
};
typedef DWORD ASSOCF;

typedef enum
{
    ASSOCSTR_COMMAND      = 1,  //  shell\verb\command string
    ASSOCSTR_EXECUTABLE,        //  the executable part of command string
    ASSOCSTR_FRIENDLYDOCNAME,   //  friendly name of the document type
    ASSOCSTR_FRIENDLYAPPNAME,   //  friendly name of executable
    ASSOCSTR_NOOPEN,            //  noopen value
    ASSOCSTR_SHELLNEWVALUE,     //  query values under the shellnew key
    ASSOCSTR_DDECOMMAND,        //  template for DDE commands
    ASSOCSTR_DDEIFEXEC,         //  DDECOMMAND to use if just create a process
    ASSOCSTR_DDEAPPLICATION,    //  Application name in DDE broadcast
    ASSOCSTR_DDETOPIC,          //  Topic Name in DDE broadcast
    ASSOCSTR_INFOTIP,           //  info tip for an item, or list of properties to create info tip from
#if (_WIN32_IE >= _WIN32_IE_IE60)
    ASSOCSTR_QUICKTIP,          //  same as ASSOCSTR_INFOTIP, except, this list contains only quickly retrievable properties
    ASSOCSTR_TILEINFO,          //  similar to ASSOCSTR_INFOTIP - lists important properties for tileview
    ASSOCSTR_CONTENTTYPE,       //  MIME Content type
    ASSOCSTR_DEFAULTICON,       //  Default icon source
    ASSOCSTR_SHELLEXTENSION,    //  Guid string pointing to the Shellex\Shellextensionhandler value.
#endif // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE80)
    ASSOCSTR_DROPTARGET,        //  The CLSID of DropTarget
    ASSOCSTR_DELEGATEEXECUTE,   //  The CLSID of DelegateExecute
#endif // _WIN32_IE_IE80
    ASSOCSTR_MAX                //  last item in enum...
} ASSOCSTR;

typedef enum
{
    ASSOCKEY_SHELLEXECCLASS = 1,  //  the key that should be passed to ShellExec(hkeyClass)
    ASSOCKEY_APP,                 //  the "Application" key for the association
    ASSOCKEY_CLASS,               //  the progid or class key
    ASSOCKEY_BASECLASS,           //  the BaseClass key
    ASSOCKEY_MAX                  //  last item in enum...
} ASSOCKEY;

typedef enum
{
    ASSOCDATA_MSIDESCRIPTOR = 1,  //  Component Descriptor to pass to MSI APIs
    ASSOCDATA_NOACTIVATEHANDLER,  //  restrict attempts to activate window
    ASSOCDATA_QUERYCLASSSTORE,    //  should check with the NT Class Store
    ASSOCDATA_HASPERUSERASSOC,    //  defaults to user specified association
#if (_WIN32_IE >= _WIN32_IE_IE60)
    ASSOCDATA_EDITFLAGS,          //  Edit flags.
    ASSOCDATA_VALUE,              //  use pszExtra as the Value name
#endif // _WIN32_IE_IE60
    ASSOCDATA_MAX
} ASSOCDATA;

typedef enum
{
    ASSOCENUM_NONE
} ASSOCENUM;

#undef INTERFACE
#define INTERFACE IQueryAssociations

DECLARE_INTERFACE_IID_( IQueryAssociations, IUnknown, "c46ca590-3c3f-11d2-bee6-0000f805ca57" )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ __in REFIID riid, __deref_out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IQueryAssociations methods
    STDMETHOD (Init)(THIS_ __in ASSOCF flags, __in_opt LPCWSTR pszAssoc, __in_opt HKEY hkProgid, __in_opt HWND hwnd) PURE;
    STDMETHOD (GetString)(THIS_ __in ASSOCF flags, __in ASSOCSTR str, __in_opt LPCWSTR pszExtra, __out_ecount_opt(*pcchOut) LPWSTR pszOut, __inout DWORD *pcchOut) PURE;
    STDMETHOD (GetKey)(THIS_ __in ASSOCF flags, __in ASSOCKEY key, __in_opt LPCWSTR pszExtra, __out HKEY *phkeyOut) PURE;
    STDMETHOD (GetData)(THIS_ __in ASSOCF flags, __in ASSOCDATA data, __in_opt LPCWSTR pszExtra, __out_bcount_opt(*pcbOut) void * pvOut, __inout_opt DWORD *pcbOut) PURE;
    STDMETHOD (GetEnum)(THIS_ __in ASSOCF flags, __in ASSOCENUM assocenum, __in_opt LPCWSTR pszExtra, __in REFIID riid, __deref_out void **ppvOut) PURE;
};


// use CLSID_QueryAssociations for clsid, object implements IQueryAssociations
// AssocCreateForClasses() is the more functional version of this API
LWSTDAPI AssocCreate(__in CLSID clsid, __in REFIID riid, __deref_out void **ppv);

//  wrappers for the interface
LWSTDAPI AssocQueryStringA(__in ASSOCF flags, __in ASSOCSTR str, __in LPCSTR pszAssoc, __in_opt LPCSTR pszExtra, __out_ecount_opt(*pcchOut) LPSTR pszOut, __inout DWORD *pcchOut);
//  wrappers for the interface
LWSTDAPI AssocQueryStringW(__in ASSOCF flags, __in ASSOCSTR str, __in LPCWSTR pszAssoc, __in_opt LPCWSTR pszExtra, __out_ecount_opt(*pcchOut) LPWSTR pszOut, __inout DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryString  AssocQueryStringW
#else
#define AssocQueryString  AssocQueryStringA
#endif // !UNICODE
LWSTDAPI AssocQueryStringByKeyA(__in ASSOCF flags, __in ASSOCSTR str, __in HKEY hkAssoc, __in_opt LPCSTR pszExtra, __out_ecount_opt(*pcchOut) LPSTR pszOut, __inout DWORD *pcchOut);
LWSTDAPI AssocQueryStringByKeyW(__in ASSOCF flags, __in ASSOCSTR str, __in HKEY hkAssoc, __in_opt LPCWSTR pszExtra, __out_ecount_opt(*pcchOut) LPWSTR pszOut, __inout DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryStringByKey  AssocQueryStringByKeyW
#else
#define AssocQueryStringByKey  AssocQueryStringByKeyA
#endif // !UNICODE
LWSTDAPI AssocQueryKeyA(__in ASSOCF flags, __in ASSOCKEY key, __in LPCSTR pszAssoc, __in_opt LPCSTR pszExtra, __out HKEY *phkeyOut);
LWSTDAPI AssocQueryKeyW(__in ASSOCF flags, __in ASSOCKEY key, __in LPCWSTR pszAssoc, __in_opt LPCWSTR pszExtra, __out HKEY *phkeyOut);
#ifdef UNICODE
#define AssocQueryKey  AssocQueryKeyW
#else
#define AssocQueryKey  AssocQueryKeyA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0601)
//  AssocIsDangerous() checks a file type to determine whether it is "Dangerous"
//      this maps to the IE download dialog's forcing a prompt to open or save.
//      dangerous file types should be handled more carefully than other file types.
//
//  Parameter:  pszAssoc - type to check.  may be an extension or progid.  (".exe" or "exefile" would both be valid)
//
//  Returns: TRUE if the file type is dangerous.
//
//  NOTES:
//
//      this API first checks a hardcoded list of known dangerous types.
//      then it checks the editflags for the file type looking for the FTA_AlwaysUnsafe bit.
//      then it checks Safer policies.
//
LWSTDAPI_(BOOL) AssocIsDangerous(LPCWSTR pszAssoc);

#endif  // _WIN32_IE >= 0x0601

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
LWSTDAPI AssocGetPerceivedType(__in LPCWSTR pszExt, __out PERCEIVED *ptype, __out PERCEIVEDFLAG *pflag, __out_opt LPWSTR *ppszType);
#endif



#endif //  NO_SHLWAPI_REG



#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//

// objidl.h
#ifndef __IStream_FWD_DEFINED__
#define __IStream_FWD_DEFINED__
typedef interface IStream IStream;
#endif  /* __IStream_FWD_DEFINED__ */

LWSTDAPI_(IStream *) SHOpenRegStreamA(__in HKEY hkey, __in_opt LPCSTR pszSubkey, __in_opt LPCSTR pszValue, __in DWORD grfMode);
LWSTDAPI_(IStream *) SHOpenRegStreamW(__in HKEY hkey, __in_opt LPCWSTR pszSubkey, __in_opt LPCWSTR pszValue, __in DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream  SHOpenRegStreamW
#else
#define SHOpenRegStream  SHOpenRegStreamA
#endif // !UNICODE
LWSTDAPI_(IStream *) SHOpenRegStream2A(__in HKEY hkey, __in_opt LPCSTR pszSubkey, __in_opt LPCSTR pszValue, __in DWORD grfMode);
LWSTDAPI_(IStream *) SHOpenRegStream2W(__in HKEY hkey, __in_opt LPCWSTR pszSubkey, __in_opt LPCWSTR pszValue, __in DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream2  SHOpenRegStream2W
#else
#define SHOpenRegStream2  SHOpenRegStream2A
#endif // !UNICODE
// New code always wants new implementation...
#undef SHOpenRegStream
#define SHOpenRegStream SHOpenRegStream2

LWSTDAPI SHCreateStreamOnFileA(__in LPCSTR pszFile, __in DWORD grfMode, __deref_out IStream **ppstm);
LWSTDAPI SHCreateStreamOnFileW(__in LPCWSTR pszFile, __in DWORD grfMode, __deref_out IStream **ppstm);
#ifdef UNICODE
#define SHCreateStreamOnFile  SHCreateStreamOnFileW
#else
#define SHCreateStreamOnFile  SHCreateStreamOnFileA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0600)

LWSTDAPI SHCreateStreamOnFileEx(__in LPCWSTR pszFile, __in DWORD grfMode, __in DWORD dwAttributes, __in BOOL fCreate, __in_opt IStream *pstmTemplate, __deref_out IStream **ppstm);

#endif // (_WIN32_IE >= 0x0600)

#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(IStream *) SHCreateMemStream(__in_bcount_opt(cbInit) const BYTE *pInit, __in UINT cbInit);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)



#endif // NO_SHLWAPI_STREAM


#ifndef NO_SHLWAPI_HTTP
//
//=============== HTTP helper Routines ===================================
//

#if (_WIN32_IE >= 0x0603)
LWSTDAPI GetAcceptLanguagesA(__out_ecount_part(*pcch, *pcch) LPSTR psz, __inout DWORD *pcch);
LWSTDAPI GetAcceptLanguagesW(__out_ecount_part(*pcch, *pcch) LPWSTR psz, __inout DWORD *pcch);
#ifdef UNICODE
#define GetAcceptLanguages  GetAcceptLanguagesW
#else
#define GetAcceptLanguages  GetAcceptLanguagesA
#endif // !UNICODE
#endif // (_WIN32_IE >= 0x0603)

#endif // NO_SHLWAPI_HTTP


#if (_WIN32_IE < _WIN32_IE_IE70) && !defined(NO_SHLWAPI_STOPWATCH)

#define SPMODE_SHELL      0x00000001
#define SPMODE_DEBUGOUT   0x00000002
#define SPMODE_TEST       0x00000004
#define SPMODE_BROWSER    0x00000008
#define SPMODE_FLUSH      0x00000010
#define SPMODE_EVENT      0x00000020
#define SPMODE_MSVM       0x00000040
#define SPMODE_FORMATTEXT 0x00000080
#define SPMODE_PROFILE    0x00000100
#define SPMODE_DEBUGBREAK 0x00000200
#define SPMODE_MSGTRACE   0x00000400
#define SPMODE_PERFTAGS   0x00000800
#define SPMODE_MEMWATCH   0x00001000
#define SPMODE_DBMON      0x00002000
#define SPMODE_MULTISTOP  0x00004000
#ifndef NO_ETW_TRACING
#define SPMODE_EVENTTRACE 0x00008000 // Event Tracing for Windows Enabled
#endif

DWORD WINAPI StopWatchMode(void);
DWORD WINAPI StopWatchFlush(void);

#endif // (_WIN32_IE < _WIN32_IE_IE70) && !defined(NO_SHLWAPI_STOPWATCH)


#if (_WIN32_IE >= _WIN32_IE_IE501)

    LWSTDAPI_(void) IUnknown_Set(__deref_inout IUnknown ** ppunk, __in_opt IUnknown * punk);
    LWSTDAPI_(void) IUnknown_AtomicRelease(__deref_opt_inout void ** ppunk);
    LWSTDAPI IUnknown_GetWindow(__in_opt IUnknown* punk, __out HWND* phwnd);
    LWSTDAPI IUnknown_SetSite(__in IUnknown *punk, __in_opt IUnknown *punkSite);
    LWSTDAPI IUnknown_GetSite(__in IUnknown *punk, __in REFIID riid, __deref_out void **ppv);
    LWSTDAPI IUnknown_QueryService(__in IUnknown* punk, __in REFGUID guidService, __in REFIID riid, __deref_out void ** ppvOut);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#if (_WIN32_IE >= _WIN32_IE_IE501)

#if !defined(__cplusplus) && defined(COBJMACROS)
#undef IStream_Read
#undef IStream_Write
#endif

LWSTDAPI IStream_Read(__in IStream *pstm, __out_bcount_full(cb) void *pv, __in ULONG cb);
LWSTDAPI IStream_Write(__in IStream *pstm, __in_bcount(cb) const void *pv, __in ULONG cb);
LWSTDAPI IStream_Reset(__in IStream *pstm);
LWSTDAPI IStream_Size(__in IStream *pstm, __out ULARGE_INTEGER *pui);

// ocidl.h
#ifndef __IConnectionPoint_FWD_DEFINED__
#define __IConnectionPoint_FWD_DEFINED__
typedef interface IConnectionPoint IConnectionPoint;
#endif  /* __IConnectionPoint_FWD_DEFINED__ */

LWSTDAPI ConnectToConnectionPoint(__in_opt IUnknown* punk, __in REFIID riidEvent, __in BOOL fConnect, __in IUnknown* punkTarget, __out DWORD* pdwCookie, __deref_opt_out IConnectionPoint** ppcpOut);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)

#if (_WIN32_IE >= _WIN32_IE_IE60)

LWSTDAPI IStream_ReadPidl(__in IStream *pstm, __deref_out PIDLIST_RELATIVE *ppidlOut);
LWSTDAPI IStream_WritePidl(__in IStream *pstm, __in PCUIDLIST_RELATIVE pidlWrite);

#endif // (_WIN32_IE >= _WIN32_IE_IE60)

#if (_WIN32_IE >= _WIN32_IE_IE70)

LWSTDAPI IStream_ReadStr(__in IStream *pstm, __deref_out PWSTR *ppsz);
LWSTDAPI IStream_WriteStr(__in IStream *pstm, __in PCWSTR psz);

LWSTDAPI IStream_Copy(__in IStream *pstmFrom, __in IStream *pstmTo, DWORD cb);

#endif // (_WIN32_IE >= _WIN32_IE_IE70)


#if (_WIN32_IE >= 0x0600)
#define SHGVSPB_PERUSER             0x00000001 // must have one of PERUSER or ALLUSERS
#define SHGVSPB_ALLUSERS            0x00000002
#define SHGVSPB_PERFOLDER           0x00000004 // must have one of PERFOLDER ALLFOLDERS or INHERIT
#define SHGVSPB_ALLFOLDERS          0x00000008
#define SHGVSPB_INHERIT             0x00000010
#define SHGVSPB_ROAM                0x00000020 // modifies the above
#define SHGVSPB_NOAUTODEFAULTS      0x80000000 // turns off read delegation to more general property bags

#define SHGVSPB_FOLDER              (SHGVSPB_PERUSER | SHGVSPB_PERFOLDER)
#define SHGVSPB_FOLDERNODEFAULTS    (SHGVSPB_PERUSER | SHGVSPB_PERFOLDER | SHGVSPB_NOAUTODEFAULTS)
#define SHGVSPB_USERDEFAULTS        (SHGVSPB_PERUSER | SHGVSPB_ALLFOLDERS)
#define SHGVSPB_GLOBALDEFAULTS      (SHGVSPB_ALLUSERS | SHGVSPB_ALLFOLDERS)

LWSTDAPI SHGetViewStatePropertyBag(__in_opt PCIDLIST_ABSOLUTE pidl, __in_opt LPCWSTR pszBagName, __in DWORD dwFlags, __in REFIID riid, __deref_out void** ppv);
#endif  // (_WIN32_IE >= 0x0600)

// SHFormatDateTime flags
//  (FDTF_SHORTDATE and FDTF_LONGDATE are mutually exclusive, as is
//   FDTF_SHORTIME and FDTF_LONGTIME.)
//
#define FDTF_SHORTTIME          0x00000001      // eg, "7:48 PM"
#define FDTF_SHORTDATE          0x00000002      // eg, "3/29/98"
#define FDTF_DEFAULT            (FDTF_SHORTDATE | FDTF_SHORTTIME) // eg, "3/29/98 7:48 PM"
#define FDTF_LONGDATE           0x00000004      // eg, "Monday, March 29, 1998"
#define FDTF_LONGTIME           0x00000008      // eg. "7:48:33 PM"
#define FDTF_RELATIVE           0x00000010      // uses "Yesterday", etc. if possible
#define FDTF_LTRDATE            0x00000100      // Left To Right reading order
#define FDTF_RTLDATE            0x00000200      // Right To Left reading order
#define FDTF_NOAUTOREADINGORDER 0x00000400      // Don't detect reading order automatically. Useful if you will be converting to Ansi and don't want Unicode reading order characters

LWSTDAPI_(int)  SHFormatDateTimeA(const FILETIME UNALIGNED * pft, __inout_opt DWORD * pdwFlags, __out_ecount(cchBuf) LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(int)  SHFormatDateTimeW(const FILETIME UNALIGNED * pft, __inout_opt DWORD * pdwFlags, __out_ecount(cchBuf) LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define SHFormatDateTime  SHFormatDateTimeW
#else
#define SHFormatDateTime  SHFormatDateTimeA
#endif // !UNICODE

#if (_WIN32_IE >= _WIN32_IE_IE501)

__success(return > 0)
LWSTDAPI_(int)  SHAnsiToUnicode(LPCSTR pszSrc, __out_ecount(cwchBuf) LPWSTR pwszDst, int cwchBuf);
__success(return > 0)
LWSTDAPI_(int)  SHAnsiToAnsi(LPCSTR pszSrc, __out_ecount(cchBuf) LPSTR pszDst, int cchBuf);
__success(return > 0)
LWSTDAPI_(int)  SHUnicodeToAnsi(LPCWSTR pwszSrc, __out_ecount(cchBuf) LPSTR pszDst, int cchBuf);
__success(return > 0)
LWSTDAPI_(int)  SHUnicodeToUnicode(LPCWSTR pwzSrc, __out_ecount(cwchBuf) LPWSTR pwzDst, int cwchBuf);

// The return value from all SH<Type>To<Type> is the size of szDest including the terminater.
#ifdef UNICODE
#define SHTCharToUnicode(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToAnsi(wzSrc, szDest, cchSize)                   SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHAnsiToTChar(szSrc, wzDest, cchSize)                   SHAnsiToUnicode(szSrc, wzDest, cchSize)
#else // UNICODE
#define SHTCharToUnicode(szSrc, wzDest, cchSize)                SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHTCharToAnsi(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, szDest, cchSize)                SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHAnsiToTChar(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#endif // UNICODE

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(int) SHMessageBoxCheckA(HWND hwnd, LPCSTR pszText, LPCSTR pszCaption, UINT uType, int iDefault, LPCSTR pszRegVal);
LWSTDAPI_(int) SHMessageBoxCheckW(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, int iDefault, LPCWSTR pszRegVal);
#ifdef UNICODE
#define SHMessageBoxCheck  SHMessageBoxCheckW
#else
#define SHMessageBoxCheck  SHMessageBoxCheckA
#endif // !UNICODE

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


#if (_WIN32_IE >= _WIN32_IE_IE501)

// Prevents hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastA(__in UINT uMsg, __in WPARAM wParam, __in LPARAM lParam);
// Prevents hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastW(__in UINT uMsg, __in WPARAM wParam, __in LPARAM lParam);
#ifdef UNICODE
#define SHSendMessageBroadcast  SHSendMessageBroadcastW
#else
#define SHSendMessageBroadcast  SHSendMessageBroadcastA
#endif // !UNICODE

LWSTDAPI_(CHAR) SHStripMneumonicA(__inout LPSTR pszMenu);
LWSTDAPI_(WCHAR) SHStripMneumonicW(__inout LPWSTR pszMenu);
#ifdef UNICODE
#define SHStripMneumonic  SHStripMneumonicW
#else
#define SHStripMneumonic  SHStripMneumonicA
#endif // !UNICODE

#ifndef NO_SHLWAPI_ISOS

// Returns TRUE/FALSE depending on question
#define OS_WINDOWS                  0           // Windows 9x vs. NT
#define OS_NT                       1           // Windows 9x vs. NT
#define OS_WIN95ORGREATER           2           // Win95 or greater
#define OS_NT4ORGREATER             3           // NT4 or greater
#define OS_WIN98ORGREATER           5           // Win98 or greater
#define OS_WIN98_GOLD               6           // Win98 Gold (Version 4.10 build 1998)
#define OS_WIN2000ORGREATER         7           // Some derivative of Win2000

// NOTE: these flags check explicitly for (dwMajorVersion == 5)
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server in "Application Server" mode (now simply called "Terminal Server")

#define OS_EMBEDDED                 13          // Embedded Windows Edition
#define OS_TERMINALCLIENT           14          // Windows Terminal Client (eg user is comming in via tsclient)
#define OS_TERMINALREMOTEADMIN      15          // Terminal Server in "Remote Administration" mode
#define OS_WIN95_GOLD               16          // Windows 95 Gold (Version 4.0 Build 1995)
#define OS_MEORGREATER              17          // Windows Millennium (Version 5.0)
#define OS_XPORGREATER              18          // Windows XP or greater
#define OS_HOME                     19          // Home Edition (eg NOT Professional, Server, Advanced Server, or Datacenter)
#define OS_PROFESSIONAL             20          // Professional     (aka Workstation; eg NOT Server, Advanced Server, or Datacenter)
#define OS_DATACENTER               21          // Datacenter       (eg NOT Server, Advanced Server, Professional, or Personal)
#define OS_ADVSERVER                22          // Advanced Server  (eg NOT Datacenter, Server, Professional, or Personal)
#define OS_SERVER                   23          // Server           (eg NOT Datacenter, Advanced Server, Professional, or Personal)
#define OS_TERMINALSERVER           24          // Terminal Server - server running in what used to be called "Application Server" mode (now simply called "Terminal Server")
#define OS_PERSONALTERMINALSERVER   25          // Personal Terminal Server - per/pro machine running in single user TS mode
#define OS_FASTUSERSWITCHING        26          // Fast User Switching
#define OS_WELCOMELOGONUI           27          // New friendly logon UI
#define OS_DOMAINMEMBER             28          // Is this machine a member of a domain (eg NOT a workgroup)
#define OS_ANYSERVER                29          // is this machine any type of server? (eg datacenter or advanced server or server)?
#define OS_WOW6432                  30          // Is this process a 32-bit process running on an 64-bit platform?
#define OS_WEBSERVER                31          // Web Edition Server
#define OS_SMALLBUSINESSSERVER      32          // SBS Server
#define OS_TABLETPC                 33          // Are we running on a TabletPC?
#define OS_SERVERADMINUI            34          // Should defaults lean towards those preferred by server administrators?
#define OS_MEDIACENTER              35          // eHome Freestyle Project
#define OS_APPLIANCE                36          // Windows .NET Appliance Server

LWSTDAPI_(BOOL) IsOS(DWORD dwOS);

#endif // NO_SHLWAPI_ISOS

#endif // (_WIN32_IE >= _WIN32_IE_IE501)


typedef enum
{
    GLOBALCOUNTER_SEARCHMANAGER,
    GLOBALCOUNTER_SEARCHOPTIONS,
    GLOBALCOUNTER_FOLDERSETTINGSCHANGE,
    GLOBALCOUNTER_RATINGS,
    GLOBALCOUNTER_APPROVEDSITES,
    GLOBALCOUNTER_RESTRICTIONS,
    GLOBALCOUNTER_SHELLSETTINGSCHANGED,
    GLOBALCOUNTER_SYSTEMPIDLCHANGE,
    GLOBALCOUNTER_OVERLAYMANAGER,
    GLOBALCOUNTER_QUERYASSOCIATIONS,
    GLOBALCOUNTER_IESESSIONS,
    GLOBALCOUNTER_IEONLY_SESSIONS,
    GLOBALCOUNTER_APPLICATION_DESTINATIONS,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS,
    GLOBALCOUNTER_BITBUCKETNUMDELETERS,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT,
    GLOBALCOUNTER_RECYCLEBINENUM,
    GLOBALCOUNTER_RECYCLEBINCORRUPTED,
    GLOBALCOUNTER_RATINGS_STATECOUNTER,
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE,
    GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT,
    GLOBALCOUNTER_FOLDERDEFINITION_CACHE,
    GLOBALCOUNTER_COMMONPLACES_LIST_CACHE,
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE,
    GLOBALCOUNTER_ASSOCCHANGED,  // throttles reading of the registry value "GlobalAssocChangedCounter" from HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer
    GLOBALCOUNTER_MAXIMUMVALUE // should always be last value
} SHGLOBALCOUNTER;

LWSTDAPI_(long) SHGlobalCounterGetValue(const SHGLOBALCOUNTER id);
LWSTDAPI_(long) SHGlobalCounterIncrement(const SHGLOBALCOUNTER id);
LWSTDAPI_(long) SHGlobalCounterDecrement(const SHGLOBALCOUNTER id);


// Shared memory apis


#if (_WIN32_IE >= 0x0603)
LWSTDAPI_(HANDLE)   SHAllocShared(__in_bcount_opt(dwSize) const void *pvData, __in DWORD dwSize, __in DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHFreeShared(__in HANDLE hData, __in DWORD dwProcessId);
LWSTDAPI_(void *)   SHLockShared(__in HANDLE hData, __in DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHUnlockShared(__in_xcount("header-preceded") void *pvData);
#endif // _WIN32_IE >= 0x0603


#if (_WIN32_IE >= _WIN32_IE_IE501)

LWSTDAPI_(UINT) WhichPlatform(void);

// Return values of WhichPlatform
#define PLATFORM_UNKNOWN     0
#define PLATFORM_IE3         1      // obsolete: use PLATFORM_BROWSERONLY
#define PLATFORM_BROWSERONLY 1      // browser-only (no new shell)
#define PLATFORM_INTEGRATED  2      // integrated shell

//***   QueryInterface helpers
// NOTES
//  ATL has a fancier version of this.  if we need to extend ours, we
//  should probably just switch to ATL's rather than reinvent.
// EXAMPLE
//  Cfoo::QI(REFIID riid, void **ppv)
//  {
//      // (the IID_xxx comments make grep'ing work!)
//      static const QITAB qit = {
//          QITABENT(Cfoo, Iiface1),    // IID_Iiface1
//          ...
//          QITABENT(Cfoo, IifaceN),    // IID_IifaceN
//          { 0 },                      // n.b. don't forget the 0
//      };
//
//      // n.b. make sure you don't cast 'this'
//      hr = QISearch(this, qit, riid, ppv);
//      if (FAILED(hr))
//          hr = SUPER::QI(riid, ppv);
//      // custom code could be added here for FAILED() case
//      return hr;
//  }
//
//  If you have an interface that is implemented multiple times,
//  the compiler will claim an ambiguous cast, so you need to give
//  some help.  For example, if your class is defined as
//
//  class CClass : public IPersistStream, public IPersistFile
//
//  then you need to say
//
//      QITABENTMULTI(CClass, IPersist, IPersistStream)
//      QITABENT(CClass, IPersistStream)
//      QITABENT(CClass, IPersistFile)
//
//  The MULTI is needed for IPersist because the compiler doesn't
//  know whether you wanted the IPersist from IPersistStream
//  or the IPersist from IPersistFile.  Unless you have played weird
//  compiler tricks, they are the same implementation, so you can
//  just pick either one, doesn't matter.
//
//  Common mistake: You do not need to use MULTI if the base interface
//  can be unambiguously determined.  E.g.,
//
//  class CSimple : public IContextMenu3
//
//      QITABENT(CClass, IContextMenu)      // do not need MULTI
//      QITABENT(CClass, IContextMenu2)     // do not need MULTI
//      QITABENT(CClass, IContextMenu3)
//
//  Do not create an entry for IUnknown; the first entry in the
//  table will be used for IUnknown.
//

typedef struct
{
    const IID * piid;
    int         dwOffset;
} QITAB, *LPQITAB;
typedef const QITAB *LPCQITAB;

#ifdef __cplusplus

#define QITABENTMULTI(Cthis, Ifoo, Iimpl) \
    { &__uuidof(Ifoo), OFFSETOFCLASS(Iimpl, Cthis) }

#else

#define QITABENTMULTI(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#endif  // __cplusplus

#define QITABENTMULTI2(Cthis, Ifoo, Iimpl) \
    { (IID*) &Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#define QITABENT(Cthis, Ifoo) QITABENTMULTI(Cthis, Ifoo, Ifoo)

STDAPI QISearch(__inout void* that, __in LPCQITAB pqit, __in REFIID riid, __deref_out void **ppv);

#endif // (_WIN32_IE >= _WIN32_IE_IE501)

#ifndef STATIC_CAST
//***   STATIC_CAST -- 'portable' static_cast<>
// NOTES
//  do *not* use SAFE_CAST (see comment in OFFSETOFCLASS)
#define STATIC_CAST(typ)   static_cast<typ>
#ifndef _X86_
    // assume only intel compiler (>=vc5) supports static_cast for now
    // we could key off of _MSC_VER >= 1100 but i'm not sure that will work
    //
    // a straight cast will give the correct result but no error checking,
    // so we'll have to catch errors on intel.
    #undef  STATIC_CAST
    #define STATIC_CAST(typ)   (typ)
#endif
#endif

#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(STATIC_CAST(base*)((derived*)8))-8)
#endif


// Types for SHIsLowMemoryMachine
#define ILMM_IE4    0       // 1997-era machine
LWSTDAPI_(BOOL) SHIsLowMemoryMachine(DWORD dwType);

// Menu Helpers
LWSTDAPI_(int)  GetMenuPosFromID(HMENU hmenu, UINT id);

LWSTDAPI        SHGetInverseCMAP(__out_bcount(cbMap) BYTE *pbMap, ULONG cbMap);


#if (_WIN32_IE >= 0x0500)

// SHAutoComplete
//      hwndEdit - HWND of editbox, ComboBox or ComboBoxEx.
//      dwFlags - Flags to indicate what to AutoAppend or AutoSuggest for the editbox.
//
// WARNING:
//    Caller needs to have called CoInitialize() or OleInitialize()
//    and cannot call CoUninit/OleUninit until after
//    WM_DESTROY on hwndEdit.
//
//  dwFlags values:
#define SHACF_DEFAULT                   0x00000000  // Currently (SHACF_FILESYSTEM | SHACF_URLALL)
#define SHACF_FILESYSTEM                0x00000001  // This includes the File System as well as the rest of the shell (Desktop\My Computer\Control Panel\)
#define SHACF_URLALL                    (SHACF_URLHISTORY | SHACF_URLMRU)
#define SHACF_URLHISTORY                0x00000002  // URLs in the User's History
#define SHACF_URLMRU                    0x00000004  // URLs in the User's Recently Used list.
#define SHACF_USETAB                    0x00000008  // Use the tab to move thru the autocomplete possibilities instead of to the next dialog/window control.
#define SHACF_FILESYS_ONLY              0x00000010  // This includes the File System
#if (_WIN32_IE >= 0x0600)
#define SHACF_FILESYS_DIRS              0x00000020  // Same as SHACF_FILESYS_ONLY except it only includes directories, UNC servers, and UNC server shares.
#endif // (_WIN32_IE >= 0x0600)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SHACF_VIRTUAL_NAMESPACE         0x00000040  // Also include the virtual namespace
#endif // _WIN32_IE_IE70
#define SHACF_AUTOSUGGEST_FORCE_ON      0x10000000  // Ignore the registry default and force the feature on.
#define SHACF_AUTOSUGGEST_FORCE_OFF     0x20000000  // Ignore the registry default and force the feature off.
#define SHACF_AUTOAPPEND_FORCE_ON       0x40000000  // Ignore the registry default and force the feature on. (Also know as AutoComplete)
#define SHACF_AUTOAPPEND_FORCE_OFF      0x80000000  // Ignore the registry default and force the feature off. (Also know as AutoComplete)

LWSTDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags);

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
LWSTDAPI SHCreateThreadRef(__inout LONG *pcRef, __deref_out IUnknown **ppunk);
#endif // _WIN32_IE_IE60SP2
LWSTDAPI SHSetThreadRef(__in_opt IUnknown *punk);
LWSTDAPI SHGetThreadRef(__deref_out IUnknown **ppunk);

LWSTDAPI_(BOOL) SHSkipJunction(__in_opt IBindCtx* pbc, __in const CLSID *pclsid);
#endif // (_WIN32_IE >= 0x0500)

enum
{
    CTF_INSIST              = 0x00000001,   // call pfnThreadProc synchronously if CreateThread() fails
    CTF_THREAD_REF          = 0x00000002,   // hold a reference to the creating thread
    CTF_PROCESS_REF         = 0x00000004,   // hold a reference to the creating process
    CTF_COINIT_STA          = 0x00000008,   // init COM as STA for the created thread
    CTF_COINIT              = 0x00000008,   // init COM as STA for the created thread
#if (_WIN32_IE >= _WIN32_IE_IE60)
    CTF_FREELIBANDEXIT      = 0x00000010,   // hold a ref to the DLL and call FreeLibraryAndExitThread() when done
    CTF_REF_COUNTED         = 0x00000020,   // thread supports ref counting via SHGetThreadRef() or CTF_THREAD_REF so that child threads can keep this thread alive
    CTF_WAIT_ALLOWCOM       = 0x00000040,   // while waiting for pfnCallback, allow COM marshaling to the blocked calling thread
#endif // _WIN32_IE_IE60
#if (_WIN32_IE >= _WIN32_IE_IE70)
    CTF_UNUSED              = 0x00000080,
    CTF_INHERITWOW64        = 0x00000100,   // new thread should inherit the wow64 disable state for the file system redirector
#endif // _WIN32_IE_IE70
#if (NTDDI_VERSION >= NTDDI_VISTA)
    CTF_WAIT_NO_REENTRANCY  = 0x00000200,   // don't allow re-entrancy when waiting for the sync proc, this won't work with marshalled objects or SendMessages() from the sync proc
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#if (NTDDI_VERSION >= NTDDI_WIN7)
    CTF_KEYBOARD_LOCALE     = 0x00000400,   // carry the keyboard locale from creating to created thread
    CTF_OLEINITIALIZE       = 0x00000800,   // init OLE on the created thread (this will also init COM as STA)
    CTF_COINIT_MTA          = 0x00001000,   // init COM as MTA for the created thread
    CTF_NOADDREFLIB         = 0x00002000,   // this flag is the opposite of CTF_FREELIBANDEXIT that is now implicit as of Vista
                                            // this avoids the LoadLibrary/FreeLibraryAndExitThread calls that result in contention for the loader lock
                                            // only use this when the thread being created has some other means to ensure that the code
                                            // of the thread proc will remain loaded. This should not be used in the context of COM objects as those
                                            // need to ensure that the DLL stays loaded as COM will unload DLLs

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
};
typedef DWORD SHCT_FLAGS;   // SHCreateThread flags values

LWSTDAPI_(BOOL) SHCreateThread(__in LPTHREAD_START_ROUTINE pfnThreadProc, __in_opt void *pData, SHCT_FLAGS flags, __in_opt LPTHREAD_START_ROUTINE pfnCallback);
LWSTDAPI_(BOOL) SHCreateThreadWithHandle(__in LPTHREAD_START_ROUTINE pfnThreadProc, __in_opt void *pData, SHCT_FLAGS flags, __in_opt LPTHREAD_START_ROUTINE pfnCallback, __out_opt HANDLE *pHandle);

#if (_WIN32_IE >= _WIN32_IE_IE60)
LWSTDAPI SHReleaseThreadRef(); // release a CTF_THREAD_REF reference earlier than the return of pfnThreadProc
#endif // _WIN32_IE_IE60

#ifndef NO_SHLWAPI_GDI
//
//====== GDI helper functions  ================================================
//

LWSTDAPI_(HPALETTE) SHCreateShellPalette(__in_opt HDC hdc);

#if (_WIN32_IE >= 0x0500)

LWSTDAPI_(void)     ColorRGBToHLS(__in COLORREF clrRGB, __out WORD* pwHue, __out WORD* pwLuminance, __out WORD* pwSaturation);
LWSTDAPI_(COLORREF) ColorHLSToRGB(__in WORD wHue, __in WORD wLuminance, __in WORD wSaturation);
LWSTDAPI_(COLORREF) ColorAdjustLuma(__in COLORREF clrRGB, int n, BOOL fScale);


#endif  // _WIN32_IE >= 0x0500

#endif // NO_SHLWAPI_GDI

//
//====== DllGetVersion  =======================================================
//

typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

#if (_WIN32_IE >= 0x0501)

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

#define DLLVER_MAJOR_MASK                    0xFFFF000000000000
#define DLLVER_MINOR_MASK                    0x0000FFFF00000000
#define DLLVER_BUILD_MASK                    0x00000000FFFF0000
#define DLLVER_QFE_MASK                      0x000000000000FFFF

#endif

#define MAKEDLLVERULL(major, minor, build, qfe) \
        (((ULONGLONG)(major) << 48) |        \
         ((ULONGLONG)(minor) << 32) |        \
         ((ULONGLONG)(build) << 16) |        \
         ((ULONGLONG)(  qfe) <<  0))

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);

// DllInstall (to be implemented by self-installing DLLs)
STDAPI DllInstall(__in BOOL bInstall, __in LPCWSTR pszCmdLine);


#if (_WIN32_IE >= 0x0602)
// Function to see if Internet Explorer Enhanced Security Configuration is active for the current user
LWSTDAPI_(BOOL) IsInternetESCEnabled();
#endif // (_WIN32_IE >= 0x0602)


#ifdef __cplusplus
}


#if defined(USE_STRICT_CONST) && !defined(NO_SHLWAPI_STRFCNS)

//=============================================================================
// C++ versions to help detect "const" violations

__inline LPSTR StrChrA(__in LPSTR lpStart, WORD wMatch)
{
    return const_cast<LPSTR>(StrChrA(const_cast<LPCSTR>(lpStart), wMatch));
}
__inline LPWSTR StrChrW(__in LPWSTR lpStart, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrChrW(const_cast<LPCWSTR>(lpStart), wMatch));
}
__inline LPSTR StrChrIA(__in LPSTR lpStart, WORD wMatch)
{
    return const_cast<LPSTR>(StrChrIA(const_cast<LPCSTR>(lpStart), wMatch));
}
__inline LPWSTR StrChrIW(__in LPWSTR lpStart, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrChrIW(const_cast<LPCWSTR>(lpStart), wMatch));
}
#if (_WIN32_IE >= _WIN32_IE_IE60)
__inline LPWSTR StrChrNW(__in LPWSTR lpStart, __in WCHAR wMatch, UINT cchMax)
{
    return const_cast<LPWSTR>(StrChrNW(const_cast<LPCWSTR>(lpStart), wMatch, cchMax));
}
__inline LPWSTR StrChrNIW(__in LPWSTR lpStart, __in WCHAR wMatch, UINT cchMax)
{
    return const_cast<LPWSTR>(StrChrNIW(const_cast<LPCWSTR>(lpStart), wMatch, cchMax));
}
#endif // _WIN32_IE_IE60
__inline LPSTR StrPBrkA(__in LPSTR psz, __in LPCSTR pszSet)
{
    return const_cast<LPSTR>(StrPBrkA(const_cast<LPCSTR>(psz), pszSet));
}
__inline LPWSTR StrPBrkW(__in LPWSTR psz, __in LPCWSTR pszSet)
{
    return const_cast<LPWSTR>(StrPBrkW(const_cast<LPCWSTR>(psz), pszSet));
}
__inline LPSTR StrRChrA(__in LPSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch)
{
    return const_cast<LPSTR>(StrRChrA(const_cast<LPCSTR>(lpStart), lpEnd, wMatch));
}
__inline LPWSTR StrRChrW(__in LPWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrRChrW(const_cast<LPCWSTR>(lpStart), lpEnd, wMatch));
}
__inline LPSTR StrRChrIA(__in LPSTR lpStart, __in_opt LPCSTR lpEnd, __in WORD wMatch)
{
    return const_cast<LPSTR>(StrRChrIA(const_cast<LPCSTR>(lpStart), lpEnd, wMatch));
}
__inline LPWSTR StrRChrIW(__in LPWSTR lpStart, __in_opt LPCWSTR lpEnd, __in WCHAR wMatch)
{
    return const_cast<LPWSTR>(StrRChrIW(const_cast<LPCWSTR>(lpStart), lpEnd, wMatch));
}
__inline LPSTR StrRStrIA(__in LPSTR lpSource, __in_opt LPCSTR lpLast, __in LPCSTR lpSrch)
{
    return const_cast<LPSTR>(StrRStrIA(const_cast<LPCSTR>(lpSource), lpLast, lpSrch));
}
__inline LPWSTR StrRStrIW(__in LPWSTR lpSource, __in_opt LPCWSTR lpLast, __in LPCWSTR lpSrch)
{
    return const_cast<LPWSTR>(StrRStrIW(const_cast<LPCWSTR>(lpSource), lpLast, lpSrch));
}
__inline LPSTR StrStrA(__in LPSTR lpFirst, __in LPCSTR lpSrch)
{
    return const_cast<LPSTR>(StrStrA(const_cast<LPCSTR>(lpFirst), lpSrch));
}
__inline LPWSTR StrStrW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch)
{
    return const_cast<LPWSTR>(StrStrW(const_cast<LPCWSTR>(lpFirst), lpSrch));
}
__inline LPSTR StrStrIA(__in LPSTR lpFirst, __in LPCSTR lpSrch)
{
    return const_cast<LPSTR>(StrStrIA(const_cast<LPCSTR>(lpFirst), lpSrch));
}
__inline LPWSTR StrStrIW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch)
{
    return const_cast<LPWSTR>(StrStrIW(const_cast<LPCWSTR>(lpFirst), lpSrch));
}
#if (_WIN32_IE >= _WIN32_IE_IE60)
__inline LPWSTR StrStrNW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax)
{
    return const_cast<LPWSTR>(StrStrNW(const_cast<LPCWSTR>(lpFirst), lpSrch, cchMax));
}
__inline LPWSTR StrStrNIW(__in LPWSTR lpFirst, __in LPCWSTR lpSrch, __in UINT cchMax)
{
    return const_cast<LPWSTR>(StrStrNIW(const_cast<LPCWSTR>(lpFirst), lpSrch, cchMax));
}
#endif
__inline LPSTR PathFindExtensionA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathFindExtensionA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathFindExtensionW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathFindExtensionW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathFindFileNameA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathFindFileNameA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathFindFileNameW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathFindFileNameW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathFindNextComponentA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathFindNextComponentA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathFindNextComponentW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathFindNextComponentW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathGetArgsA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathGetArgsA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathGetArgsW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathGetArgsW(const_cast<LPCWSTR>(pszPath)));
}
__inline LPSTR PathSkipRootA(__in LPSTR pszPath)
{
    return const_cast<LPSTR>(PathSkipRootA(const_cast<LPCSTR>(pszPath)));
}
__inline LPWSTR PathSkipRootW(__in LPWSTR pszPath)
{
    return const_cast<LPWSTR>(PathSkipRootW(const_cast<LPCWSTR>(pszPath)));
}
#endif

#endif

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(pop)
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif


#endif  // _INC_SHLWAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SMPMS.h ===
/*
 *  S M P M S . H
 *
 *  Definitions used by the Microsoft Sample Message Store Provider
 *  for service entry calls.
 *
 *  The following MAPI-defined properties are settable in service
 *  entry calls for the Sample Message Store Provider.
 *  
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SMPMS_H_
#define _SMPMS_H_

#define SMS_EXTERN_PROPID_BASE  0x6700      /* From MAPITAGS.H comments */

#define PR_SMS_PATH         PROP_TAG(PT_STRING8, SMS_EXTERN_PROPID_BASE + 0)
#define PR_SMS_PASSWORD     PROP_TAG(PT_STRING8, SMS_EXTERN_PROPID_BASE + 1)
#define PR_SMS_REMEMBER_PW  PROP_TAG(PT_BOOLEAN, SMS_EXTERN_PROPID_BASE + 2)
#define PR_SMS_CREATE       PROP_TAG(PT_BOOLEAN, SMS_EXTERN_PROPID_BASE + 3)


/* 
 *  The following is a description of each of the Sample Message Store
 *  Provider properties:
 *
 *  PR_SMS_PATH
 *      The full pathname to the root directory of the sample message store.
 *
 *  PR_SMS_PASSWORD
 *      The password needed to open the store (if already present), or the
 *      new password (if creating the store).
 *
 *  PR_SMS_REMEMBER_PW
 *      If non-zero (TRUE), this property asks the service entry to save the
 *      password in the profile, and to not prompt for it.
 *
 *  PR_SMS_CREATE
 *      If non-zero (TRUE), this property asks the service entry to create the
 *      sample store. Otherwise, the service entry will attempt to open an
 *      existing store.
 */

/*
 *  PR_MDB_PROVIDER is the GUID that represent the Sample Message Store
 *  Provider.  This guid is available as a property in the stores
 *  table and on the message store object.
 */
#define SMPMS_UID_PROVIDER      \
    {   0x38, 0x5d, 0x47, 0x5f, \
        0xec, 0xf1, 0xcd, 0x11, \
        0x93, 0xdc, 0x5a, 0xab, \
        0x3C, 0x47, 0x84, 0x37 }

#endif  /* _SMPMS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SMPXP.h ===
/*
 *  S M P X P . H
 *
 *  Definitions used by the Microsoft Sample Transport provider
 *  for service entry calls.
 *
 *  The following MAPI-defined properties are settable in service
 *  entry calls for the Sample Transport Provider.
 *  
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 */

#define BASE_ID 0x6600      /* From MAPITAGS.H comments */

#define PR_SAMPLE_DISPLAY_NAME      PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0001))
#define PR_SAMPLE_EMAIL_ADDR_TYPE   PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0002))
#define PR_SAMPLE_EMAIL_ADDRESS     PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0003))
#define PR_SAMPLE_INBOUND_DIR       PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0004))
#define PR_SAMPLE_OUTBOUND_DIR      PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0005))
#define PR_SAMPLE_FILENAME          PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0006))
#define PR_SAMPLE_DIRECTORY         PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0007))
#define PR_SAMPLE_FLAGS             PROP_TAG (PT_LONG,      (BASE_ID + 0x0008))

#define PR_SAMPLE_FLAG_PEER_TO_PEER ((ULONG) 0x00000001)
#define PR_SAMPLE_FLAG_UI_ALWAYS    ((ULONG) 0x00000002)
#define PR_SAMPLE_FLAG_LOG_EVENTS   ((ULONG) 0x00000004)
#define PR_SAMPLE_FLAG_SAVE_DATA    ((ULONG) 0x00000008)

#define PR_SAMPLE_LOGFILE           PROP_TAG (PT_TSTRING,   (BASE_ID + 0x0009))
#define PR_SAMPLE_LOGHIGHWATER      PROP_TAG (PT_LONG,      (BASE_ID + 0x000A))
#define PR_SAMPLE_LOGLOWWATER       PROP_TAG (PT_LONG,      (BASE_ID + 0x000B))

/* 
 *  The following is a description of each of the Sample Tranpsort 
 *  Provider properties:
 *
 *  PR_SAMPLE_DISPLAY_NAME
 *      Display name of user.
 *
 *  PR_SAMPLE_EMAIL_ADDR_TYPE
 *      Address type of sample transport. This will be used to construct inbound
 *      and outbound addresses where needed. It also will be used to tell the
 *      Spooler what address types we should get.
 *
 *  PR_SAMPLE_EMAIL_ADDRESS
 *      Email address. This will usually be the same as the inbound directory,
 *      although this may tend to have a more canonical form for remote access.
 *
 *  PR_SAMPLE_INBOUND_DIR
 *      Inbound directory. This is where the transport will look in order to
 *      determine whether it has received any mail.
 *
 *  PR_SAMPLE_OUTBOUND_DIR
 *      Outbound directory. The transport will store its message files here
 *      while it is in the process of sending them. The presence of a file
 *      in this directory implies that the transport still has work to do.
 *
 *  PR_SAMPLE_FILENAME
 *      Filename. This is an 8-character root for use by mail-enabled or
 *      workgroup applications to build a complete file specification (by
 *      adding an extension) for data they wish to store for this user.
 *
 *  PR_SAMPLE_DIRECTORY
 *      Directory. This is a directory in which workgroup applications may
 *      wish to store their files pertaining to this user.
 *
 *  PR_SAMPLE_FLAGS
 *      Flags. Contain various options for this transport provider.
 *      Valid values are:
 *
 *          PR_SAMPLE_FLAG_PEER_TO_PEER
 *          PR_SAMPLE_FLAG_UI_ALWAYS
 *          PR_SAMPLE_FLAG_LOG_EVENTS
 *          PR_SAMPLE_FLAG_SAVE_DATA
 *
 *  PR_SAMPLE_LOGFILE
 *      Logfile. This is where logging information will be written. If this
 *      property is not present, we will use (PR_SAMPLE_FILENAME)".LOG"
 *
 *  PR_SAMPLE_LOGHIGHWATER
 *      Logfile high water mark. This is the point at which the log writer will
 *      truncate the logfile so as not to fill up the disk.
 *
 *  PR_SAMPLE_LOGLOWWATER
 *      Logfile low water mark. This is the approximate size that the logfile
 *      writer will truncate the logfile to (modulo a line ending).
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SmtpGuid.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: smtpguid.h
//
// Contents: Event related GUIDS published from SMTPSVC
//
// Instructions: Include this file to declare the various
//               GUIDS/strings as external global variables.
//               To actually define these global variables,
//               #define SMTPINITGUID and #include <initguid.h> before this
//               header file.
//
// History:
// Jeffrey C Stamerjohn 1998/07/14 15:22:29: Created.
//
//-------------------------------------------------------------
#ifndef __SMTPGUID_H__
#define __SMTPGUID_H__

#ifdef SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    CONST WCHAR Name##[] = L##Value

#else //SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    extern CONST WCHAR Name##[]

#endif //SMTPINITGUID

// SMTP SourceType GUID
// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSourceType, "{fb65c4dc-e468-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTP_SOURCE_TYPE, 0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
** SMTP Source GUID
*/
// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSvcSource, "{1b3c0666-e470-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTPSVC_SOURCE, 0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
**  Protocol Events
*/
// SMTP OnInboundCommand
// {F6628C8D-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnInboundCommand, "{F6628C8D-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_INBOUND_COMMAND, 0xf6628c8d, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnServerResponse
// {F6628C8E-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnServerResponse, "{F6628C8E-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SERVER_RESPONSE, 0xf6628c8e, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionStart
// {F6628C8F-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionStart, "{F6628C8F-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_START, 0xf6628c8f, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnMessageStart
// {F6628C90-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnMessageStart, "{F6628C90-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_MESSAGE_START, 0xf6628c90, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnPerRecipient
// {F6628C91-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPerRecipient, "{F6628C91-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_PER_RECIPIENT, 0xf6628c91, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// Smtp OnBeforeData
// {F6628C92-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnBeforeData, "{F6628C92-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_BEFORE_DATA, 0xf6628c92, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionEnd
// {F6628C93-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionEnd, "{F6628C93-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_END, 0xf6628c93, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);


/*
** Transport Events
*/

// SMTP Store Events
// {59175850-e533-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpStoreDriver, "{59175850-e533-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(CATID_SMTP_STORE_DRIVER, 0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// SMTP OnTransportSubmission
// {FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportSubmission, "{FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_SUBMISSION, 0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP onPrecategorize
// {A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPrecategorize, "{A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_PRECATEGORIZE, 0xa3acfb0d, 0x83ff, 0x11d2, 0x9e, 0x14, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP Categorizer events
// {960252A3-0A3A-11d2-9E00-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnCategorize, "{960252A3-0A3A-11d2-9E00-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_CATEGORIZE, 0x960252a3, 0xa3a, 0x11d2, 0x9e, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP onPostcategorize
// {76719654-05A6-11d2-9DFD-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPostcategorize, "{76719654-05A6-11d2-9dfd-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_POSTCATEGORIZE,
0x76719654, 0x5a6, 0x11d2, 0x9d, 0xfd, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP OnTransportRouter
// {283430C9-1850-11d2-9E03-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportRouter, "{283430C9-1850-11d2-9E03-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_ROUTER, 0x283430c9, 0x1850, 0x11d2, 0x9e, 0x3, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP MsgTrackLog
// {c6df52aa-7db0-11d2-94f4-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMsgTrackLog, "{c6df52aa-7db0-11d2-94f4-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MSGTRACKLOG, 0xc6df52aa, 0x7db0, 0x11d2, 0x94, 0xf4, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP DnsResolver
// {bd0b4366-8e03-11d2-94f6-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDnsResolver, "{bd0b4366-8e03-11d2-94f6-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_DNSRESOLVERRECORDSINK, 0xbd0b4366, 0x8e03, 0x11d2, 0x94, 0xf6, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP MaxMsgSize
// {ebf159de-a67e-11d2-94f7-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMaxMsgSize, "{ebf159de-a67e-11d2-94f7-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MAXMSGSIZE, 0xebf159de, 0xa67e, 0x11d2, 0x94, 0xf7, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP Log
// {93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpLog, "{93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}");
DEFINE_GUID(CATID_SMTP_LOG, 0x93d0a538, 0x2c1e, 0x4b68, 0xa7, 0xc9, 0xd7, 0x3a, 0x8a, 0xa6, 0xee, 0x97);

// SMTP GET_AUX_DOMAIN_INFO_FLAGS
// {84ff368a-fab3-43d7-bcdf-692c5b46e6b1}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpGetAuxDomainInfoFlags, "{84ff368a-fab3-43d7-bcdf-692c5b46e6b1}");
DEFINE_GUID(CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS, 0x84ff368a, 0xfab3, 0x43d7, 0xbc, 0xdf, 0x69, 0x2c, 0x5b, 0x46, 0xe6, 0xb1);

//
// CLSID of the CoCreateable categorizer
//
// {B23C35B7-9219-11d2-9E17-00C04FA322BA}"
DEFINE_GUID(CLSID_SmtpCat, 0xb23c35b7, 0x9219, 0x11d2, 0x9e, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

//
// SMTP DSN
//
// {22B55731-F5F8-4d23-BD8F-87B52371A73A}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDSN, "{22B55731-F5F8-4D23-BD8F-87B52371A73A}");
DEFINE_GUID(CATID_SMTP_DSN, 0x22b55731, 0xf5f8, 0x4d23, 0xbd, 0x8f, 0x87, 0xb5, 0x23, 0x71, 0xa7, 0x3a);

#define SZ_PROGID_SMTPCAT   "Smtp.Cat"


#endif //__SMTPGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\simpdc.h ===
/* Microsoft Corporation Copyright 1999 */
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Aug 25 10:20:38 1998
 */
/* Compiler settings for S:\zen\ocp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


#ifndef I_SIMPDC_H_
#define I_SIMPDC_H_

/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISimpleDataConverter_FWD_DEFINED__
#define __ISimpleDataConverter_FWD_DEFINED__
typedef interface ISimpleDataConverter ISimpleDataConverter;
#endif 	/* __ISimpleDataConverter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ISimpleDataConverter_INTERFACE_DEFINED__
#define __ISimpleDataConverter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISimpleDataConverter
 * at Tue Aug 25 10:20:38 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [hidden][helpcontext][unique][uuid][object] */ 



DEFINE_GUID(IID_ISimpleDataConverter,0x78667670,0x3C3D,0x11d2,0x91,0xF9,0x00,0x60,0x97,0xC9,0x7F,0x9B);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78667670-3C3D-11d2-91F9-006097C97F9B")
    ISimpleDataConverter : public IUnknown
    {
    public:
        virtual /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ConvertData( 
            VARIANT varSrc,
            long vtDest,
            IUnknown __RPC_FAR *pUnknownElement,
            VARIANT __RPC_FAR *pvarDest) = 0;
        
        virtual /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CanConvertData( 
            long vt1,
            long vt2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleDataConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISimpleDataConverter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISimpleDataConverter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISimpleDataConverter __RPC_FAR * This);
        
        /* [helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertData )( 
            ISimpleDataConverter __RPC_FAR * This,
            VARIANT varSrc,
            long vtDest,
            IUnknown __RPC_FAR *pUnknownElement,
            VARIANT __RPC_FAR *pvarDest);
        
        /* [helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvertData )( 
            ISimpleDataConverter __RPC_FAR * This,
            long vt1,
            long vt2);
        
        END_INTERFACE
    } ISimpleDataConverterVtbl;

    interface ISimpleDataConverter
    {
        CONST_VTBL struct ISimpleDataConverterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleDataConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleDataConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleDataConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleDataConverter_ConvertData(This,varSrc,vtDest,pUnknownElement,pvarDest)	\
    (This)->lpVtbl -> ConvertData(This,varSrc,vtDest,pUnknownElement,pvarDest)

#define ISimpleDataConverter_CanConvertData(This,vt1,vt2)	\
    (This)->lpVtbl -> CanConvertData(This,vt1,vt2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext] */ HRESULT STDMETHODCALLTYPE ISimpleDataConverter_ConvertData_Proxy( 
    ISimpleDataConverter __RPC_FAR * This,
    VARIANT varSrc,
    long vtDest,
    IUnknown __RPC_FAR *pUnknownElement,
    VARIANT __RPC_FAR *pvarDest);


void __RPC_STUB ISimpleDataConverter_ConvertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext] */ HRESULT STDMETHODCALLTYPE ISimpleDataConverter_CanConvertData_Proxy( 
    ISimpleDataConverter __RPC_FAR * This,
    long vt1,
    long vt2);


void __RPC_STUB ISimpleDataConverter_CanConvertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleDataConverter_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif I_SIMPDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ShTypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for shtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shtypes_h__
#define __shtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_shtypes_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME
//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================
//
// SHITEMID -- Item ID  (mkid)
//     USHORT      cb;             // Size of the ID (including cb itself)
//     BYTE        abID[];         // The item ID (variable length)
//
#include <pshpack1.h>
typedef struct _SHITEMID
    {
    USHORT cb;
    BYTE abID[ 1 ];
    } 	SHITEMID;

#include <poppack.h>
#if defined(_M_IX86)
#define __unaligned
#endif // __unaligned
typedef SHITEMID __unaligned *LPSHITEMID;

typedef const SHITEMID __unaligned *LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
#include <pshpack1.h>
typedef struct _ITEMIDLIST
    {
    SHITEMID mkid;
    } 	ITEMIDLIST;

#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
typedef struct _ITEMIDLIST_RELATIVE : ITEMIDLIST {} ITEMIDLIST_RELATIVE;
typedef struct _ITEMID_CHILD : ITEMIDLIST_RELATIVE {} ITEMID_CHILD;
typedef struct _ITEMIDLIST_ABSOLUTE : ITEMIDLIST_RELATIVE {} ITEMIDLIST_ABSOLUTE;
#else // !(defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus))
typedef ITEMIDLIST ITEMIDLIST_RELATIVE;

typedef ITEMIDLIST ITEMID_CHILD;

typedef ITEMIDLIST ITEMIDLIST_ABSOLUTE;

#endif // defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#include <poppack.h>
typedef /* [unique] */  __RPC_unique_pointer BYTE_BLOB *wirePIDL;

typedef /* [wire_marshal] */ ITEMIDLIST __unaligned *LPITEMIDLIST;

typedef /* [wire_marshal] */ const ITEMIDLIST __unaligned *LPCITEMIDLIST;

#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
typedef /* [wire_marshal] */ ITEMIDLIST_ABSOLUTE *PIDLIST_ABSOLUTE;

typedef /* [wire_marshal] */ const ITEMIDLIST_ABSOLUTE *PCIDLIST_ABSOLUTE;

typedef /* [wire_marshal] */ const ITEMIDLIST_ABSOLUTE __unaligned *PCUIDLIST_ABSOLUTE;

typedef /* [wire_marshal] */ ITEMIDLIST_RELATIVE *PIDLIST_RELATIVE;

typedef /* [wire_marshal] */ const ITEMIDLIST_RELATIVE *PCIDLIST_RELATIVE;

typedef /* [wire_marshal] */ ITEMIDLIST_RELATIVE __unaligned *PUIDLIST_RELATIVE;

typedef /* [wire_marshal] */ const ITEMIDLIST_RELATIVE __unaligned *PCUIDLIST_RELATIVE;

typedef /* [wire_marshal] */ ITEMID_CHILD *PITEMID_CHILD;

typedef /* [wire_marshal] */ const ITEMID_CHILD *PCITEMID_CHILD;

typedef /* [wire_marshal] */ ITEMID_CHILD __unaligned *PUITEMID_CHILD;

typedef /* [wire_marshal] */ const ITEMID_CHILD __unaligned *PCUITEMID_CHILD;

typedef const PCUITEMID_CHILD *PCUITEMID_CHILD_ARRAY;

typedef const PCUIDLIST_RELATIVE *PCUIDLIST_RELATIVE_ARRAY;

typedef const PCIDLIST_ABSOLUTE *PCIDLIST_ABSOLUTE_ARRAY;

typedef const PCUIDLIST_ABSOLUTE *PCUIDLIST_ABSOLUTE_ARRAY;

#else // !(defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus))
#define PIDLIST_ABSOLUTE         LPITEMIDLIST
#define PCIDLIST_ABSOLUTE        LPCITEMIDLIST
#define PCUIDLIST_ABSOLUTE       LPCITEMIDLIST
#define PIDLIST_RELATIVE         LPITEMIDLIST
#define PCIDLIST_RELATIVE        LPCITEMIDLIST
#define PUIDLIST_RELATIVE        LPITEMIDLIST
#define PCUIDLIST_RELATIVE       LPCITEMIDLIST
#define PITEMID_CHILD            LPITEMIDLIST
#define PCITEMID_CHILD           LPCITEMIDLIST
#define PUITEMID_CHILD           LPITEMIDLIST
#define PCUITEMID_CHILD          LPCITEMIDLIST
#define PCUITEMID_CHILD_ARRAY    LPCITEMIDLIST *
#define PCUIDLIST_RELATIVE_ARRAY LPCITEMIDLIST *
#define PCIDLIST_ABSOLUTE_ARRAY  LPCITEMIDLIST *
#define PCUIDLIST_ABSOLUTE_ARRAY LPCITEMIDLIST *
#endif // defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)
#ifdef MIDL_PASS
typedef struct _WIN32_FIND_DATAA
    {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[ 260 ];
    CHAR cAlternateFileName[ 14 ];
    } 	WIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAA *PWIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAA *LPWIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAW
    {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[ 260 ];
    WCHAR cAlternateFileName[ 14 ];
    } 	WIN32_FIND_DATAW;

typedef struct _WIN32_FIND_DATAW *PWIN32_FIND_DATAW;

typedef struct _WIN32_FIND_DATAW *LPWIN32_FIND_DATAW;

#endif // MIDL_PASS
//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------
//
//  uType indicate which union member to use 
//    STRRET_WSTR    Use STRRET.pOleStr     must be freed by caller of GetDisplayNameOf
//    STRRET_OFFSET  Use STRRET.uOffset     Offset into SHITEMID for ANSI string 
//    STRRET_CSTR    Use STRRET.cStr        ANSI Buffer
//
typedef /* [v1_enum] */ 
enum tagSTRRET_TYPE
    {	STRRET_WSTR	= 0,
	STRRET_OFFSET	= 0x1,
	STRRET_CSTR	= 0x2
    } 	STRRET_TYPE;

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#pragma once
#endif
#include <pshpack8.h>
typedef struct _STRRET
    {
    UINT uType;
    union 
        {
        LPWSTR pOleStr;
        UINT uOffset;
        char cStr[ 260 ];
        } 	DUMMYUNIONNAME;
    } 	STRRET;

#include <poppack.h>
#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif
typedef STRRET *LPSTRRET;

//-------------------------------------------------------------------------
//
// struct SHELLDETAILS
//
// structure for returning strings from IShellDetails
//
//-------------------------------------------------------------------------
//
//  fmt;            // LVCFMT_* value (header only)
//  cxChar;         // Number of 'average' characters (header only)
//  str;            // String information
//
#include <pshpack1.h>
typedef struct _SHELLDETAILS
    {
    int fmt;
    int cxChar;
    STRRET str;
    } 	SHELLDETAILS;

typedef struct _SHELLDETAILS *LPSHELLDETAILS;

#include <poppack.h>

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
typedef /* [v1_enum] */ 
enum tagPERCEIVED
    {	PERCEIVED_TYPE_FIRST	= -3,
	PERCEIVED_TYPE_CUSTOM	= -3,
	PERCEIVED_TYPE_UNSPECIFIED	= -2,
	PERCEIVED_TYPE_FOLDER	= -1,
	PERCEIVED_TYPE_UNKNOWN	= 0,
	PERCEIVED_TYPE_TEXT	= 1,
	PERCEIVED_TYPE_IMAGE	= 2,
	PERCEIVED_TYPE_AUDIO	= 3,
	PERCEIVED_TYPE_VIDEO	= 4,
	PERCEIVED_TYPE_COMPRESSED	= 5,
	PERCEIVED_TYPE_DOCUMENT	= 6,
	PERCEIVED_TYPE_SYSTEM	= 7,
	PERCEIVED_TYPE_APPLICATION	= 8,
	PERCEIVED_TYPE_GAMEMEDIA	= 9,
	PERCEIVED_TYPE_CONTACTS	= 10,
	PERCEIVED_TYPE_LAST	= 10
    } 	PERCEIVED;

#define PERCEIVEDFLAG_UNDEFINED     0x0000
#define PERCEIVEDFLAG_SOFTCODED     0x0001
#define PERCEIVEDFLAG_HARDCODED     0x0002
#define PERCEIVEDFLAG_NATIVESUPPORT 0x0004
#define PERCEIVEDFLAG_GDIPLUS       0x0010
#define PERCEIVEDFLAG_WMSDK         0x0020
#define PERCEIVEDFLAG_ZIPFOLDER     0x0040
typedef DWORD PERCEIVEDFLAG;

#endif  // _WIN32_IE_IE60SP2

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _COMDLG_FILTERSPEC
    {
    LPCWSTR pszName;
    LPCWSTR pszSpec;
    } 	COMDLG_FILTERSPEC;

#endif  // NTDDI_VISTA
typedef GUID KNOWNFOLDERID;

#if 0
typedef KNOWNFOLDERID *REFKNOWNFOLDERID;

#endif // 0
#ifdef __cplusplus
#define REFKNOWNFOLDERID const KNOWNFOLDERID &
#else // !__cplusplus
#define REFKNOWNFOLDERID const KNOWNFOLDERID * __MIDL_CONST
#endif // __cplusplus
typedef DWORD KF_REDIRECT_FLAGS;
typedef GUID FOLDERTYPEID;

#if 0
typedef FOLDERTYPEID *REFFOLDERTYPEID;

#endif // 0
#ifdef __cplusplus
#define REFFOLDERTYPEID const FOLDERTYPEID &
#else // !__cplusplus
#define REFFOLDERTYPEID const FOLDERTYPEID * __MIDL_CONST
#endif // __cplusplus
typedef GUID TASKOWNERID;

#if 0
typedef TASKOWNERID *REFTASKOWNERID;

#endif // 0
#ifdef __cplusplus
#define REFTASKOWNERID const TASKOWNERID &
#else // !__cplusplus
#define REFTASKOWNERID const TASKOWNERID * __MIDL_CONST
#endif // __cplusplus
#ifndef LF_FACESIZE
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif // LF_FACESIZE
typedef /* [v1_enum] */ 
enum tagSHCOLSTATE
    {	SHCOLSTATE_DEFAULT	= 0,
	SHCOLSTATE_TYPE_STR	= 0x1,
	SHCOLSTATE_TYPE_INT	= 0x2,
	SHCOLSTATE_TYPE_DATE	= 0x3,
	SHCOLSTATE_TYPEMASK	= 0xf,
	SHCOLSTATE_ONBYDEFAULT	= 0x10,
	SHCOLSTATE_SLOW	= 0x20,
	SHCOLSTATE_EXTENDED	= 0x40,
	SHCOLSTATE_SECONDARYUI	= 0x80,
	SHCOLSTATE_HIDDEN	= 0x100,
	SHCOLSTATE_PREFER_VARCMP	= 0x200,
	SHCOLSTATE_PREFER_FMTCMP	= 0x400,
	SHCOLSTATE_NOSORTBYFOLDERNESS	= 0x800,
	SHCOLSTATE_VIEWONLY	= 0x10000,
	SHCOLSTATE_BATCHREAD	= 0x20000,
	SHCOLSTATE_NO_GROUPBY	= 0x40000,
	SHCOLSTATE_FIXED_WIDTH	= 0x1000,
	SHCOLSTATE_NODPISCALE	= 0x2000,
	SHCOLSTATE_FIXED_RATIO	= 0x4000,
	SHCOLSTATE_DISPLAYMASK	= 0xf000
    } 	SHCOLSTATE;

typedef DWORD SHCOLSTATEF;

typedef PROPERTYKEY SHCOLUMNID;

typedef const SHCOLUMNID *LPCSHCOLUMNID;



extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sliddefs.h ===
/*++

Copyright (C) Microsoft Corporation, 2006

Module Name:

    sliddefs.h

Abstract:

    Software Licensing GUID definitions
   
--*/
#pragma once

#ifndef _SLIDDEFS_H_
#define _SLIDDEFS_H_

#if defined(SPP_CODE_PROJECT_MARKER) || defined(SPP_CODE_PROJECT_MARKER_SECURE)
#if !defined(SPP_PUBLISHING_INCLUDED_FROM_TRAMPOLINE) && !defined(SPP_PUBLISHING_USE_FORCE_OFFICIAL)
#error this header file cannot be included directly from SPP projects; use sppinc_* prefix instead.
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINDOWS_SLID_
#define _WINDOWS_SLID_
DEFINE_GUID(WINDOWS_SLID, 0x55c92734, 0xd682, 0x4d71, 0x98, 0x3e, 0xd6, 0xec, 0x3f, 0x16, 0x05, 0x9f);
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\spapidef.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    spapidef.h

Abstract:

    Public header file for Windows NT Setup and Device Installer services Dll.

--*/

#ifndef _INC_SPAPIDEF
#define _INC_SPAPIDEF

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef SP_LOG_TOKEN
typedef DWORDLONG SP_LOG_TOKEN;
typedef DWORDLONG *PSP_LOG_TOKEN;
#endif


//
// Special txtlog token values
//

#define LOGTOKEN_TYPE_MASK              3

#define LOGTOKEN_UNSPECIFIED            0
#define LOGTOKEN_NO_LOG                 1
#define LOGTOKEN_SETUPAPI_APPLOG        2
#define LOGTOKEN_SETUPAPI_DEVLOG        3


//
// Flags for SetupCreateTextLogSection
//

#define TXTLOG_SETUPAPI_DEVLOG      0x00000001            // 1 = setupdi.log, 0 = setupapi.log
#define TXTLOG_SETUPAPI_CMDLINE     0x00000002            // log the command line

#define TXTLOG_SETUPAPI_BITS        0x00000003


//
// Flags for SetupWriteTextLog
//

//
// Event Levels (bits 0-3)
//

#define TXTLOG_ERROR                    0x1             // shows entries which indicate a real problem
#define TXTLOG_WARNING                  0x2             // shows entries which indicate a potential problem
#define TXTLOG_SYSTEM_STATE_CHANGE      0x3             // system changes only
#define TXTLOG_SUMMARY                  0x4             // show basic operation surrounding system changes
#define TXTLOG_DETAILS                  0x5             // detailed operation of the install process
#define TXTLOG_VERBOSE                  0x6             // log entries which potentially generate a lot of data
#define TXTLOG_VERY_VERBOSE             0x7             // highest level shows all log entries

//
// Bits reserved for internal use
//

#define TXTLOG_RESERVED_FLAGS   0x0000FFF0

//
// Basic flags (bits 4-31)
//

#define TXTLOG_TIMESTAMP        0x00010000
#define TXTLOG_DEPTH_INCR       0x00020000
#define TXTLOG_DEPTH_DECR       0x00040000
#define TXTLOG_TAB_1            0x00080000
#define TXTLOG_FLUSH_FILE       0x00100000

#define TXTLOG_LEVEL(flags) (flags & 0xf)


//
// Setupapi, Setupdi event categories
//

#define TXTLOG_DEVINST          0x00000001
#define TXTLOG_INF              0x00000002
#define TXTLOG_FILEQ            0x00000004
#define TXTLOG_COPYFILES        0x00000008

#define TXTLOG_SIGVERIF         0x00000020

#define TXTLOG_BACKUP           0x00000080
#define TXTLOG_UI               0x00000100
#define TXTLOG_UTIL             0x00000200
#define TXTLOG_INFDB            0x00000400

#define TXTLOG_POLICY           0x00800000
#define TXTLOG_NEWDEV           0x01000000
#define TXTLOG_UMPNPMGR         0x02000000
#define TXTLOG_DRIVER_STORE     0x04000000
#define TXTLOG_SETUP            0x08000000
#define TXTLOG_CMI              0x10000000
#define TXTLOG_DEVMGR           0x20000000

#define TXTLOG_INSTALLER        0x40000000
#define TXTLOG_VENDOR           0x80000000


#endif // _INC_SPAPIDEF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\slerror.h ===
/*++

   slerror.h --  error code definitions for the Software Licensing

   Copyright (c) Microsoft Corp.  All rights reserved.

--*/

#ifndef __SLERROR_H__
#define __SLERROR_H__

#if defined(SPP_CODE_PROJECT_MARKER) || defined(SPP_CODE_PROJECT_MARKER_SECURE)
#if !defined(SPP_PUBLISHING_INCLUDED_FROM_TRAMPOLINE) && !defined(SPP_PUBLISHING_USE_FORCE_OFFICIAL)
#error this header file cannot be included directly from SPP projects; use sppinc_* prefix instead.
#endif
#endif

#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif

#define SL_SERVER_ZONE     0xB000 // zone for SL server errors
#define SL_MSCH_ZONE       0xC000 // zone for SL clearing house errors
// 0XD000 is reserved for SP
#define SL_INTERNAL_ZONE   0xE000 // zone for SL service internal errors
#define SL_CLIENTAPI_ZONE  0xF000 // zone for SL client API errors

#define IS_SL_SERVER_ERROR(hr)     ((hr & 0xF000) == SL_SERVER_ZONE)
#define IS_SL_MSCH_ERROR(hr)       ((hr & 0xF000) == SL_MSCH_ZONE)
#define IS_SL_INTERNAL_ERROR(hr)   ((hr & 0xF000) == SL_INTERNAL_ZONE)
#define IS_SL_SERVICE_ERROR(hr)    ((hr & 0xF000) == SL_SERVICE_ZONE)
#define IS_SL_CLIENTAPI_ERROR(hr)  ((hr & 0xF000) == SL_CLIENTAPI_ZONE)

#define IS_SL_VGA_STRICT_ERROR(hr)  (((hr & 0xF000) == SL_MSCH_ZONE) && ((hr & 0xFFF) >= 0x401) && ((hr & 0xFFF) <= 0x496))
#define IS_SL_VGA_LITE_ERROR(hr)  (((hr & 0xF000) == SL_MSCH_ZONE) && ((hr & 0xFFF) >= 0x497) && ((hr & 0xFFF) <= 0x600))


//////////////////////////////////////////////////////////
//     SL Server errors
//     These error codes come from SL Server
//////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SL_ITF                  0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SL_E_SRV_INVALID_PUBLISH_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_PUBLISH_LICENSE ((HRESULT)0xC004B001L)

//
// MessageId: SL_E_SRV_INVALID_PRODUCT_KEY_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_PRODUCT_KEY_LICENSE ((HRESULT)0xC004B002L)

//
// MessageId: SL_E_SRV_INVALID_RIGHTS_ACCOUNT_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_RIGHTS_ACCOUNT_LICENSE ((HRESULT)0xC004B003L)

//
// MessageId: SL_E_SRV_INVALID_LICENSE_STRUCTURE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_LICENSE_STRUCTURE ((HRESULT)0xC004B004L)

//
// MessageId: SL_E_SRV_AUTHORIZATION_FAILED
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_AUTHORIZATION_FAILED    ((HRESULT)0xC004B005L)

//
// MessageId: SL_E_SRV_INVALID_BINDING
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_BINDING         ((HRESULT)0xC004B006L)

//
// MessageId: SL_E_SRV_SERVER_PONG
//
// MessageText:
//
// The activation server reported that the computer could not connect to the activation server.
//
#define SL_E_SRV_SERVER_PONG             ((HRESULT)0xC004B007L)

//
// MessageId: SL_E_SRV_INVALID_PAYLOAD
//
// MessageText:
//
// The activation server determined that the computer could not be activated.
//
#define SL_E_SRV_INVALID_PAYLOAD         ((HRESULT)0xC004B008L)

//
// MessageId: SL_E_SRV_INVALID_SECURITY_PROCESSOR_LICENSE
//
// MessageText:
//
// The activation server determined that the license is invalid.
//
#define SL_E_SRV_INVALID_SECURITY_PROCESSOR_LICENSE ((HRESULT)0xC004B009L)

//
// MessageId: SL_E_SRV_CLIENT_CLOCK_OUT_OF_SYNC
//
// MessageText:
//
// The activation server determined that your computer clock time is not correct. You must correct your clock before you can activate.
//
#define SL_E_SRV_CLIENT_CLOCK_OUT_OF_SYNC ((HRESULT)0xC004B011L)

//
// MessageId: SL_E_SRV_GENERAL_ERROR
//
// MessageText:
//
// The activation server determined that the computer could not be activated.
//
#define SL_E_SRV_GENERAL_ERROR           ((HRESULT)0xC004B100L)

////////////////////////////////////////////////////////////////
//     Clearing house errors
//     These error codes come from MSCH PA Implementation
////////////////////////////////////////////////////////////////

//
// MessageId: SL_E_CHPA_PRODUCT_KEY_OUT_OF_RANGE
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_PRODUCT_KEY_OUT_OF_RANGE ((HRESULT)0xC004C001L)

//
// MessageId: SL_E_CHPA_INVALID_BINDING
//
// MessageText:
//
// The activation server determined there is a problem with the specified product key.
//
#define SL_E_CHPA_INVALID_BINDING        ((HRESULT)0xC004C002L)

//
// MessageId: SL_E_CHPA_PRODUCT_KEY_BLOCKED
//
// MessageText:
//
// The activation server determined the specified product key has been blocked.
//
#define SL_E_CHPA_PRODUCT_KEY_BLOCKED    ((HRESULT)0xC004C003L)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid. 
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY    ((HRESULT)0xC004C004L)

//
// MessageId: SL_E_CHPA_BINDING_NOT_FOUND
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_BINDING_NOT_FOUND      ((HRESULT)0xC004C005L)

//
// MessageId: SL_E_CHPA_BINDING_MAPPING_NOT_FOUND
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_BINDING_MAPPING_NOT_FOUND ((HRESULT)0xC004C006L)

//
// MessageId: SL_E_CHPA_UNSUPPORTED_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_UNSUPPORTED_PRODUCT_KEY ((HRESULT)0xC004C007L)

//
// MessageId: SL_E_CHPA_MAXIMUM_UNLOCK_EXCEEDED
//
// MessageText:
//
// The activation server determined that the specified product key could not be used.
//
#define SL_E_CHPA_MAXIMUM_UNLOCK_EXCEEDED ((HRESULT)0xC004C008L)

//
// MessageId: SL_E_CHPA_ACTCONFIG_ID_NOT_FOUND
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_ACTCONFIG_ID_NOT_FOUND ((HRESULT)0xC004C009L)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_DATA_ID
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_DATA_ID ((HRESULT)0xC004C00AL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_DATA
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_DATA   ((HRESULT)0xC004C00BL)

//
// MessageId: SL_E_CHPA_SYSTEM_ERROR
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_SYSTEM_ERROR           ((HRESULT)0xC004C00CL)

//
// MessageId: SL_E_CHPA_INVALID_ACTCONFIG_ID
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_ACTCONFIG_ID   ((HRESULT)0xC004C00DL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY_LENGTH
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY_LENGTH ((HRESULT)0xC004C00EL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY_FORMAT
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY_FORMAT ((HRESULT)0xC004C00FL)

//
// MessageId: SL_E_CHPA_INVALID_PRODUCT_KEY_CHAR
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHPA_INVALID_PRODUCT_KEY_CHAR ((HRESULT)0xC004C010L)

//
// MessageId: SL_E_CHPA_INVALID_BINDING_URI
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHPA_INVALID_BINDING_URI    ((HRESULT)0xC004C011L)

//
// MessageId: SL_E_CHPA_NETWORK_ERROR
//
// MessageText:
//
// The activation server experienced a network error.
//
#define SL_E_CHPA_NETWORK_ERROR          ((HRESULT)0xC004C012L)

//
// MessageId: SL_E_CHPA_DATABASE_ERROR
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_DATABASE_ERROR         ((HRESULT)0xC004C013L)

//
// MessageId: SL_E_CHPA_INVALID_ARGUMENT
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_INVALID_ARGUMENT       ((HRESULT)0xC004C014L)

//
// MessageId: SL_E_CHPA_DMAK_LIMIT_EXCEEDED
//
// MessageText:
//
// The activation server reported that the Multiple Activation Key has exceeded its limit.
//
#define SL_E_CHPA_DMAK_LIMIT_EXCEEDED    ((HRESULT)0xC004C020L)

//
// MessageId: SL_E_CHPA_DMAK_EXTENSION_LIMIT_EXCEEDED
//
// MessageText:
//
// The activation server reported that the Multiple Activation Key extension limit has been exceeded.
//
#define SL_E_CHPA_DMAK_EXTENSION_LIMIT_EXCEEDED ((HRESULT)0xC004C021L)

//
// MessageId: SL_E_CHPA_REISSUANCE_LIMIT_NOT_FOUND
//
// MessageText:
//
// The activation server reported that the re-issuance limit was not found. 
//
#define SL_E_CHPA_REISSUANCE_LIMIT_NOT_FOUND ((HRESULT)0xC004C022L)

//
// MessageId: SL_E_CHPA_OVERRIDE_REQUEST_NOT_FOUND
//
// MessageText:
//
// The activation server reported that the override request was not found. 
//
#define SL_E_CHPA_OVERRIDE_REQUEST_NOT_FOUND ((HRESULT)0xC004C023L)

//
// MessageId: SL_E_CHPA_OEM_SLP_COA0
//
// MessageText:
//
// The activation server reported that the specified product key cannot be used for online activation.
//
#define SL_E_CHPA_OEM_SLP_COA0           ((HRESULT)0xC004C016L)

//
// MessageId: SL_E_CHPA_PRODUCT_KEY_BLOCKED_IPLOCATION
//
// MessageText:
//
// The activation server determined the specified product key has been blocked for this geographic location.
//
#define SL_E_CHPA_PRODUCT_KEY_BLOCKED_IPLOCATION ((HRESULT)0xC004C017L)

//
// MessageId: SL_E_CHPA_RESPONSE_NOT_AVAILABLE
//
// MessageText:
//
// The activation server experienced an error.
//
#define SL_E_CHPA_RESPONSE_NOT_AVAILABLE ((HRESULT)0xC004C015L)

//
// MessageId: SL_E_CHPA_GENERAL_ERROR
//
// MessageText:
//
// The activation server experienced a general error.
//
#define SL_E_CHPA_GENERAL_ERROR          ((HRESULT)0xC004C050L)

//
// MessageId: SL_E_CHPA_TIMEBASED_ACTIVATION_BEFORE_START_DATE
//
// MessageText:
//
// The activation server reported that time based activation attempted before start date.
//
#define SL_E_CHPA_TIMEBASED_ACTIVATION_BEFORE_START_DATE ((HRESULT)0xC004C030L)

//
// MessageId: SL_E_CHPA_TIMEBASED_ACTIVATION_AFTER_END_DATE
//
// MessageText:
//
// The activation server reported that time based activation attempted after end date.
//
#define SL_E_CHPA_TIMEBASED_ACTIVATION_AFTER_END_DATE ((HRESULT)0xC004C031L)

//
// MessageId: SL_E_CHPA_TIMEBASED_ACTIVATION_NOT_AVAILABLE
//
// MessageText:
//
// The activation server reported that new time based activation not available.
//
#define SL_E_CHPA_TIMEBASED_ACTIVATION_NOT_AVAILABLE ((HRESULT)0xC004C032L)

//
// MessageId: SL_E_CHPA_TIMEBASED_PRODUCT_KEY_NOT_CONFIGURED
//
// MessageText:
//
// The activation server reported that time based product key not configured for activation.
//
#define SL_E_CHPA_TIMEBASED_PRODUCT_KEY_NOT_CONFIGURED ((HRESULT)0xC004C033L)

//
// MessageId: SL_E_CHPA_NO_RULES_TO_ACTIVATE
//
// MessageText:
//
// The activation server reported that no business rules available to activate specified product key.
//
#define SL_E_CHPA_NO_RULES_TO_ACTIVATE   ((HRESULT)0xC004C04FL)

//
// MessageId: SL_E_CHPA_BUSINESS_RULE_INPUT_NOT_FOUND
//
// MessageText:
//
// The activation server reported that business rule cound not find required input.
//
#define SL_E_CHPA_BUSINESS_RULE_INPUT_NOT_FOUND ((HRESULT)0xC004C700L)

//
// MessageId: SL_E_CHPA_NULL_VALUE_FOR_PROPERTY_NAME_OR_ID
//
// MessageText:
//
// The activation server reported that NULL value specified for business property name and Id.
//
#define SL_E_CHPA_NULL_VALUE_FOR_PROPERTY_NAME_OR_ID ((HRESULT)0xC004C750L)

//
// MessageId: SL_E_CHPA_UNKNOWN_PROPERTY_NAME
//
// MessageText:
//
// The activation server reported that property name specifies unknown property.
//
#define SL_E_CHPA_UNKNOWN_PROPERTY_NAME  ((HRESULT)0xC004C751L)

//
// MessageId: SL_E_CHPA_UNKNOWN_PROPERTY_ID
//
// MessageText:
//
// The activation server reported that property Id specifies unknown property.
//
#define SL_E_CHPA_UNKNOWN_PROPERTY_ID    ((HRESULT)0xC004C752L)

//
// MessageId: SL_E_CHPA_FAILED_TO_UPDATE_PRODUCTKEY_BINDING
//
// MessageText:
//
// The activation server reported that it failed to update product key binding.
//
#define SL_E_CHPA_FAILED_TO_UPDATE_PRODUCTKEY_BINDING ((HRESULT)0xC004C755L)

//
// MessageId: SL_E_CHPA_FAILED_TO_INSERT_PRODUCTKEY_BINDING
//
// MessageText:
//
// The activation server reported that it failed to insert product key binding.
//
#define SL_E_CHPA_FAILED_TO_INSERT_PRODUCTKEY_BINDING ((HRESULT)0xC004C756L)

//
// MessageId: SL_E_CHPA_FAILED_TO_DELETE_PRODUCTKEY_BINDING
//
// MessageText:
//
// The activation server reported that it failed to delete product key binding.
//
#define SL_E_CHPA_FAILED_TO_DELETE_PRODUCTKEY_BINDING ((HRESULT)0xC004C757L)

//
// MessageId: SL_E_CHPA_FAILED_TO_PROCESS_PRODUCT_KEY_BINDINGS_XML
//
// MessageText:
//
// The activation server reported that it failed to process input XML for product key bindings.
//
#define SL_E_CHPA_FAILED_TO_PROCESS_PRODUCT_KEY_BINDINGS_XML ((HRESULT)0xC004C758L)

//
// MessageId: SL_E_CHPA_FAILED_TO_INSERT_PRODUCT_KEY_PROPERTY
//
// MessageText:
//
// The activation server reported that it failed to insert product key property.
//
#define SL_E_CHPA_FAILED_TO_INSERT_PRODUCT_KEY_PROPERTY ((HRESULT)0xC004C75AL)

//
// MessageId: SL_E_CHPA_FAILED_TO_UPDATE_PRODUCT_KEY_PROPERTY
//
// MessageText:
//
// The activation server reported that it failed to update product key property.
//
#define SL_E_CHPA_FAILED_TO_UPDATE_PRODUCT_KEY_PROPERTY ((HRESULT)0xC004C75BL)

//
// MessageId: SL_E_CHPA_FAILED_TO_DELETE_PRODUCT_KEY_PROPERTY
//
// MessageText:
//
// The activation server reported that it failed to delete product key property.
//
#define SL_E_CHPA_FAILED_TO_DELETE_PRODUCT_KEY_PROPERTY ((HRESULT)0xC004C75CL)

//
// MessageId: SL_E_CHPA_UNKNOWN_PRODUCT_KEY_TYPE
//
// MessageText:
//
// The activation server reported that the product key type is unknown.
//
#define SL_E_CHPA_UNKNOWN_PRODUCT_KEY_TYPE ((HRESULT)0xC004C764L)

//
// MessageId: SL_E_CHPA_PRODUCT_KEY_BEING_USED
//
// MessageText:
//
// The activation server reported that the product key type is being used by another user.
//
#define SL_E_CHPA_PRODUCT_KEY_BEING_USED ((HRESULT)0xC004C770L)

//
// MessageId: SL_E_CHPA_FAILED_TO_INSERT_PRODUCT_KEY_RECORD
//
// MessageText:
//
// The activation server reported that it failed to insert product key record.
//
#define SL_E_CHPA_FAILED_TO_INSERT_PRODUCT_KEY_RECORD ((HRESULT)0xC004C780L)

//
// MessageId: SL_E_CHPA_FAILED_TO_UPDATE_PRODUCT_KEY_RECORD
//
// MessageText:
//
// The activation server reported that it failed to update product key record.
//
#define SL_E_CHPA_FAILED_TO_UPDATE_PRODUCT_KEY_RECORD ((HRESULT)0xC004C781L)

////////////////////////////////////////////////////////////////
//     VGA (Vista Genuine Advantage) error code range
////////////////////////////////////////////////////////////////
//
// MessageId: SL_E_VGA_NON_GENUINE_STATUS_FIRST
//
// MessageText:
//
// The Vista Genuine Advantage Service determined that the installation is not genuine. 
//
#define SL_E_VGA_NON_GENUINE_STATUS_FIRST ((HRESULT)0xC004C401L)

//
// MessageId: SL_E_VGA_NON_GENUINE_STATUS_LAST
//
// MessageText:
//
// The Vista Genuine Advantage Service determined that the installation is not genuine. 
//
#define SL_E_VGA_NON_GENUINE_STATUS_LAST ((HRESULT)0xC004C600L)

////////////////////////////////////////////////////////////////
//     Clearing house errors
//     These error codes come from MSCH Reference Implementation
////////////////////////////////////////////////////////////////

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_KEY   ((HRESULT)0xC004C801L)

//
// MessageId: SL_E_CHREF_EXCLUDED_PRODUCT_KEY
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_EXCLUDED_PRODUCT_KEY  ((HRESULT)0xC004C802L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_REVOKED
//
// MessageText:
//
// The activation server determined the specified product key has been revoked.
//
#define SL_E_CHREF_PRODUCT_KEY_REVOKED   ((HRESULT)0xC004C803L)

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_KEY_ALGORITHM
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_KEY_ALGORITHM ((HRESULT)0xC004C804L)

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_KEY_UNIQUEID
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_KEY_UNIQUEID ((HRESULT)0xC004C805L)

//
// MessageId: SL_E_CHREF_INVALID_PRODUCT_DATA
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_INVALID_PRODUCT_DATA  ((HRESULT)0xC004C810L)

//
// MessageId: SL_E_CHREF_CANNOT_CREATE_BINDING_ASSOC
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHREF_CANNOT_CREATE_BINDING_ASSOC ((HRESULT)0xC004C811L)

//
// MessageId: SL_E_CHREF_BINDING_OUT_OF_TOLERANCE
//
// MessageText:
//
// The activation server determined that the specified product key has exceeded its activation count.
//
#define SL_E_CHREF_BINDING_OUT_OF_TOLERANCE ((HRESULT)0xC004C812L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_POLICY_MISSING
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHREF_PRODUCT_KEY_POLICY_MISSING ((HRESULT)0xC004C813L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_POLICY_OVERLAPPED
//
// MessageText:
//
// The activation server determined the specified product key is invalid.
//
#define SL_E_CHREF_PRODUCT_KEY_POLICY_OVERLAPPED ((HRESULT)0xC004C814L)

//
// MessageId: SL_E_CHREF_PRODUCT_KEY_BINDING_MISMATCH
//
// MessageText:
//
// The activation server determined the license is invalid.
//
#define SL_E_CHREF_PRODUCT_KEY_BINDING_MISMATCH ((HRESULT)0xC004C815L)

//
// MessageId: SL_E_CHREF_OEM_SLP_COA0
//
// MessageText:
//
// The activation server reported that the specified product key cannot be used for online activation.
//
#define SL_E_CHREF_OEM_SLP_COA0          ((HRESULT)0xC004C816L)

//////////////////////////////////////////////////////////
// SL service internal error
//     Internal program errors for SL develpers
//////////////////////////////////////////////////////////

//
// MessageId: SL_E_INVALID_CONTEXT
//
// MessageText:
//
// The Software Licensing Service determined that the specified context is invalid.
//
#define SL_E_INVALID_CONTEXT             ((HRESULT)0xC004E001L)

//
// MessageId: SL_E_TOKEN_STORE_INVALID_STATE
//
// MessageText:
//
// The Software Licensing Service reported that the license store contains inconsistent data.
//
#define SL_E_TOKEN_STORE_INVALID_STATE   ((HRESULT)0xC004E002L)

//
// MessageId: SL_E_EVALUATION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that license evaluation failed.
//
#define SL_E_EVALUATION_FAILED           ((HRESULT)0xC004E003L)

//
// MessageId: SL_E_NOT_EVALUATED
//
// MessageText:
//
// The Software Licensing Service reported that the license has not been evaluated.
//
#define SL_E_NOT_EVALUATED               ((HRESULT)0xC004E004L)

//
// MessageId: SL_E_NOT_ACTIVATED
//
// MessageText:
//
// The Software Licensing Service reported that the license is not activated.
//
#define SL_E_NOT_ACTIVATED               ((HRESULT)0xC004E005L)

//
// MessageId: SL_E_INVALID_GUID
//
// MessageText:
//
// The Software Licensing Service reported that the license contains invalid data.
//
#define SL_E_INVALID_GUID                ((HRESULT)0xC004E006L)

//
// MessageId: SL_E_TOKSTO_TOKEN_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the license store does not contain the requested license.
//
#define SL_E_TOKSTO_TOKEN_NOT_FOUND      ((HRESULT)0xC004E007L)

//
// MessageId: SL_E_TOKSTO_NO_PROPERTIES
//
// MessageText:
//
// The Software Licensing Service reported that the license property is invalid.
//
#define SL_E_TOKSTO_NO_PROPERTIES        ((HRESULT)0xC004E008L)

//
// MessageId: SL_E_TOKSTO_NOT_INITIALIZED
//
// MessageText:
//
// The Software Licensing Service reported that the license store is not initialized.
//
#define SL_E_TOKSTO_NOT_INITIALIZED      ((HRESULT)0xC004E009L)

//
// MessageId: SL_E_TOKSTO_ALREADY_INITIALIZED
//
// MessageText:
//
// The Software Licensing Service reported that the license store is already initialized.
//
#define SL_E_TOKSTO_ALREADY_INITIALIZED  ((HRESULT)0xC004E00AL)

//
// MessageId: SL_E_TOKSTO_NO_ID_SET
//
// MessageText:
//
// The Software Licensing Service reported that the license property is invalid.
//
#define SL_E_TOKSTO_NO_ID_SET            ((HRESULT)0xC004E00BL)

//
// MessageId: SL_E_TOKSTO_CANT_CREATE_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be opened or created.
//
#define SL_E_TOKSTO_CANT_CREATE_FILE     ((HRESULT)0xC004E00CL)

//
// MessageId: SL_E_TOKSTO_CANT_WRITE_TO_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be written.
//
#define SL_E_TOKSTO_CANT_WRITE_TO_FILE   ((HRESULT)0xC004E00DL)

//
// MessageId: SL_E_TOKSTO_CANT_READ_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license store could not read the license file.
//
#define SL_E_TOKSTO_CANT_READ_FILE       ((HRESULT)0xC004E00EL)

//
// MessageId: SL_E_TOKSTO_CANT_PARSE_PROPERTIES
//
// MessageText:
//
// The Software Licensing Service reported that the license property is corrupted.
//
#define SL_E_TOKSTO_CANT_PARSE_PROPERTIES ((HRESULT)0xC004E00FL)

//
// MessageId: SL_E_TOKSTO_PROPERTY_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the license property is missing.
//
#define SL_E_TOKSTO_PROPERTY_NOT_FOUND   ((HRESULT)0xC004E010L)

//
// MessageId: SL_E_TOKSTO_INVALID_FILE
//
// MessageText:
//
// The Software Licensing Service reported that the license store contains an invalid license file.
//
#define SL_E_TOKSTO_INVALID_FILE         ((HRESULT)0xC004E011L)

//
// MessageId: SL_E_TOKSTO_CANT_CREATE_MUTEX
//
// MessageText:
//
// The Software Licensing Service reported that the license store failed to start synchronization properly.
//
#define SL_E_TOKSTO_CANT_CREATE_MUTEX    ((HRESULT)0xC004E012L)

//
// MessageId: SL_E_TOKSTO_CANT_ACQUIRE_MUTEX
//
// MessageText:
//
// The Software Licensing Service reported that the license store failed to synchronize properly.
//
#define SL_E_TOKSTO_CANT_ACQUIRE_MUTEX   ((HRESULT)0xC004E013L)

//
// MessageId: SL_E_TOKSTO_NO_TOKEN_DATA
//
// MessageText:
//
// The Software Licensing Service reported that the license property is invalid.
//
#define SL_E_TOKSTO_NO_TOKEN_DATA        ((HRESULT)0xC004E014L)

//
// MessageId: SL_E_EUL_CONSUMPTION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that license consumption failed.
//
#define SL_E_EUL_CONSUMPTION_FAILED      ((HRESULT)0xC004E015L)

//
// MessageId: SL_E_PKEY_INVALID_CONFIG
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_PKEY_INVALID_CONFIG         ((HRESULT)0xC004E016L)

//
// MessageId: SL_E_PKEY_INVALID_UNIQUEID
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_PKEY_INVALID_UNIQUEID       ((HRESULT)0xC004E017L)

//
// MessageId: SL_E_PKEY_INVALID_ALGORITHM
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_PKEY_INVALID_ALGORITHM      ((HRESULT)0xC004E018L)

//
// MessageId: SL_E_PKEY_INTERNAL_ERROR
//
// MessageText:
//
// The Software Licensing Service determined that validation of the specified product key failed.
//
#define SL_E_PKEY_INTERNAL_ERROR         ((HRESULT)0xC004E019L)

//
// MessageId: SL_E_LICENSE_INVALID_ADDON_INFO
//
// MessageText:
//
// The Software Licensing Service reported that invalid add-on information was found. 
//
#define SL_E_LICENSE_INVALID_ADDON_INFO  ((HRESULT)0xC004E01AL)

//
// MessageId: SL_E_HWID_ERROR
//
// MessageText:
//
// The Software Licensing Service reported that not all hardware information could be collected. 
//
#define SL_E_HWID_ERROR                  ((HRESULT)0xC004E01BL)

//
// MessageId: SL_E_PKEY_INVALID_KEYCHANGE1
//
// MessageText:
//
// This evaluation product key is no longer valid.
//
#define SL_E_PKEY_INVALID_KEYCHANGE1     ((HRESULT)0xC004E01CL)

//
// MessageId: SL_E_PKEY_INVALID_KEYCHANGE2
//
// MessageText:
//
// The new product key cannot be used on this installation of Windows. Type a different product key. (CD-AB)
//
#define SL_E_PKEY_INVALID_KEYCHANGE2     ((HRESULT)0xC004E01DL)

//
// MessageId: SL_E_PKEY_INVALID_KEYCHANGE3
//
// MessageText:
//
// The new product key cannot be used on this installation of Windows. Type a different product key. (AB-AB)
//
#define SL_E_PKEY_INVALID_KEYCHANGE3     ((HRESULT)0xC004E01EL)

//
// MessageId: SL_E_PKEY_INVALID_KEYCHANGE4
//
// MessageText:
//
// The new product key cannot be used on this installation of Windows. Type a different product key. (AB-CD)
//
#define SL_E_PKEY_INVALID_KEYCHANGE4     ((HRESULT)0xC004E01FL)

//
// MessageId: SL_E_POLICY_OTHERINFO_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that there is a mismatched between a policy value and information stored in the OtherInfo section.
//
#define SL_E_POLICY_OTHERINFO_MISMATCH   ((HRESULT)0xC004E020L)

//
// MessageId: SL_E_PRODUCT_UNIQUENESS_GROUP_ID_INVALID
//
// MessageText:
//
// The Software Licensing Service reported that the Genuine information contained in the license is not consistent.
//
#define SL_E_PRODUCT_UNIQUENESS_GROUP_ID_INVALID ((HRESULT)0xC004E021L)

//
// MessageId: SL_E_SECURE_STORE_ID_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that the secure store id value in license does not match with the current value.
//
#define SL_E_SECURE_STORE_ID_MISMATCH    ((HRESULT)0xC004E022L)

////////////////////////////////////////////////////////////////
//     Internal Token Store errors
//     0xE1xx is reserved for Token Store internal errors
////////////////////////////////////////////////////////////////

//
// MessageId: SL_E_SFS_INVALID_FS_VERSION
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store file version is invalid. 
//
#define SL_E_SFS_INVALID_FS_VERSION      ((HRESULT)0x8004E101L)

//
// MessageId: SL_E_SFS_INVALID_FD_TABLE
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store contains an invalid descriptor table. 
//
#define SL_E_SFS_INVALID_FD_TABLE        ((HRESULT)0x8004E102L)

//
// MessageId: SL_E_SFS_INVALID_SYNC
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store contains a token with an invalid header/footer. 
//
#define SL_E_SFS_INVALID_SYNC            ((HRESULT)0x8004E103L)

//
// MessageId: SL_E_SFS_BAD_TOKEN_NAME
//
// MessageText:
//
// The Software Licensing Service reported that a Token Store token has an invalid name. 
//
#define SL_E_SFS_BAD_TOKEN_NAME          ((HRESULT)0x8004E104L)

//
// MessageId: SL_E_SFS_BAD_TOKEN_EXT
//
// MessageText:
//
// The Software Licensing Service reported that a Token Store token has an invalid extension. 
//
#define SL_E_SFS_BAD_TOKEN_EXT           ((HRESULT)0x8004E105L)

//
// MessageId: SL_E_SFS_DUPLICATE_TOKEN_NAME
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store contains a duplicate token. 
//
#define SL_E_SFS_DUPLICATE_TOKEN_NAME    ((HRESULT)0x8004E106L)

//
// MessageId: SL_E_SFS_TOKEN_SIZE_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that a token in the Token Store has a size mismatch. 
//
#define SL_E_SFS_TOKEN_SIZE_MISMATCH     ((HRESULT)0x8004E107L)

//
// MessageId: SL_E_SFS_INVALID_TOKEN_DATA_HASH
//
// MessageText:
//
// The Software Licensing Service reported that a token in the Token Store contains an invalid hash. 
//
#define SL_E_SFS_INVALID_TOKEN_DATA_HASH ((HRESULT)0x8004E108L)

//
// MessageId: SL_E_SFS_FILE_READ_ERROR
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store was unable to read a token. 
//
#define SL_E_SFS_FILE_READ_ERROR         ((HRESULT)0x8004E109L)

//
// MessageId: SL_E_SFS_FILE_WRITE_ERROR
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store was unable to write a token. 
//
#define SL_E_SFS_FILE_WRITE_ERROR        ((HRESULT)0x8004E10AL)

//
// MessageId: SL_E_SFS_INVALID_FILE_POSITION
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store attempted an invalid file operation. 
//
#define SL_E_SFS_INVALID_FILE_POSITION   ((HRESULT)0x8004E10BL)

//
// MessageId: SL_E_SFS_NO_ACTIVE_TRANSACTION
//
// MessageText:
//
// The Software Licensing Service reported that there is no active transaction. 
//
#define SL_E_SFS_NO_ACTIVE_TRANSACTION   ((HRESULT)0x8004E10CL)

//
// MessageId: SL_E_SFS_INVALID_FS_HEADER
//
// MessageText:
//
// The Software Licensing Service reported that the Token Store file header is invalid. 
//
#define SL_E_SFS_INVALID_FS_HEADER       ((HRESULT)0x8004E10DL)

//
// MessageId: SL_E_SFS_INVALID_TOKEN_DESCRIPTOR
//
// MessageText:
//
// The Software Licensing Service reported that a Token Store token descriptor is invalid. 
//
#define SL_E_SFS_INVALID_TOKEN_DESCRIPTOR ((HRESULT)0x8004E10EL)


//////////////////////////////////////////////////////////
// Extended SL Client API error, license evaluation errors
//////////////////////////////////////////////////////////

//
// MessageId: SL_E_INTERNAL_ERROR
//
// MessageText:
//
// The Software Licensing Service reported an internal error.
//
#define SL_E_INTERNAL_ERROR              ((HRESULT)0xC004F001L)

//
// MessageId: SL_E_RIGHT_NOT_CONSUMED
//
// MessageText:
//
// The Software Licensing Service reported that rights consumption failed.
//
#define SL_E_RIGHT_NOT_CONSUMED          ((HRESULT)0xC004F002L)

//
// MessageId: SL_E_USE_LICENSE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the required license could not be found.
//
#define SL_E_USE_LICENSE_NOT_INSTALLED   ((HRESULT)0xC004F003L)

//
// MessageId: SL_E_MISMATCHED_PKEY_RANGE
//
// MessageText:
//
// The Software Licensing Service reported that the product key does not match the range defined in the license.
//
#define SL_E_MISMATCHED_PKEY_RANGE       ((HRESULT)0xC004F004L)

//
// MessageId: SL_E_MISMATCHED_PID
//
// MessageText:
//
// The Software Licensing Service reported that the product key does not match the product key for the license.
//
#define SL_E_MISMATCHED_PID              ((HRESULT)0xC004F005L)

//
// MessageId: SL_E_EXTERNAL_SIGNATURE_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the signature file for the license is not available.
//
#define SL_E_EXTERNAL_SIGNATURE_NOT_FOUND ((HRESULT)0xC004F006L)

//
// MessageId: SL_E_RAC_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be found.
//
#define SL_E_RAC_NOT_AVAILABLE           ((HRESULT)0xC004F007L)

//
// MessageId: SL_E_SPC_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be found.
//
#define SL_E_SPC_NOT_AVAILABLE           ((HRESULT)0xC004F008L)

//
// MessageId: SL_E_GRACE_TIME_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the grace period expired.
//
#define SL_E_GRACE_TIME_EXPIRED          ((HRESULT)0xC004F009L)

//
// MessageId: SL_E_MISMATCHED_APPID
//
// MessageText:
//
// The Software Licensing Service reported that the application ID does not match the application ID for the license.
//
#define SL_E_MISMATCHED_APPID            ((HRESULT)0xC004F00AL)

//
// MessageId: SL_E_NO_PID_CONFIG_DATA
//
// MessageText:
//
// The Software Licensing Service reported that the product identification data is not available.
//
#define SL_E_NO_PID_CONFIG_DATA          ((HRESULT)0xC004F00BL)

//
// MessageId: SL_I_OOB_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid grace period.
//
#define SL_I_OOB_GRACE_PERIOD            ((HRESULT)0x4004F00CL)

//
// MessageId: SL_I_OOT_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid out of tolerance grace period.
//
#define SL_I_OOT_GRACE_PERIOD            ((HRESULT)0x4004F00DL)

//
// MessageId: SL_E_MISMATCHED_SECURITY_PROCESSOR
//
// MessageText:
//
// The Software Licensing Service determined that the license could not be used by the current version of the security processor component.
//
#define SL_E_MISMATCHED_SECURITY_PROCESSOR ((HRESULT)0xC004F00EL)

//
// MessageId: SL_E_OUT_OF_TOLERANCE
//
// MessageText:
//
// The Software Licensing Service reported that the hardware ID binding is beyond the level of tolerance.
//
#define SL_E_OUT_OF_TOLERANCE            ((HRESULT)0xC004F00FL)

//
// MessageId: SL_E_INVALID_PKEY
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_INVALID_PKEY                ((HRESULT)0xC004F010L)

//
// MessageId: SL_E_LICENSE_FILE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the license file is not installed.
//
#define SL_E_LICENSE_FILE_NOT_INSTALLED  ((HRESULT)0xC004F011L)

//
// MessageId: SL_E_VALUE_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the call has failed because the value for the input key was not found.
//
#define SL_E_VALUE_NOT_FOUND             ((HRESULT)0xC004F012L)

//
// MessageId: SL_E_RIGHT_NOT_GRANTED
//
// MessageText:
//
// The Software Licensing Service determined that there is no permission to run the software.
//
#define SL_E_RIGHT_NOT_GRANTED           ((HRESULT)0xC004F013L)

//
// MessageId: SL_E_PKEY_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the product key is not available.
//
#define SL_E_PKEY_NOT_INSTALLED          ((HRESULT)0xC004F014L)

//
// MessageId: SL_E_PRODUCT_SKU_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the license is not installed.
//
#define SL_E_PRODUCT_SKU_NOT_INSTALLED   ((HRESULT)0xC004F015L)

//
// MessageId: SL_E_NOT_SUPPORTED
//
// MessageText:
//
// The Software Licensing Service determined that the request is not supported.
//
#define SL_E_NOT_SUPPORTED               ((HRESULT)0xC004F016L)

//
// MessageId: SL_E_PUBLISHING_LICENSE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that the license is not installed.
//
#define SL_E_PUBLISHING_LICENSE_NOT_INSTALLED ((HRESULT)0xC004F017L)

//
// MessageId: SL_E_LICENSE_SERVER_URL_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the license does not contain valid location data for the activation server.
//
#define SL_E_LICENSE_SERVER_URL_NOT_FOUND ((HRESULT)0xC004F018L)

//
// MessageId: SL_E_INVALID_EVENT_ID
//
// MessageText:
//
// The Software Licensing Service determined that the requested event ID is invalid.
//
#define SL_E_INVALID_EVENT_ID            ((HRESULT)0xC004F019L)

//
// MessageId: SL_E_EVENT_NOT_REGISTERED
//
// MessageText:
//
// The Software Licensing Service determined that the requested event is not registered with the service.
//
#define SL_E_EVENT_NOT_REGISTERED        ((HRESULT)0xC004F01AL)

//
// MessageId: SL_E_EVENT_ALREADY_REGISTERED
//
// MessageText:
//
// The Software Licensing Service reported that the event ID is already registered.
//
#define SL_E_EVENT_ALREADY_REGISTERED    ((HRESULT)0xC004F01BL)

//
// MessageId: SL_E_DECRYPTION_LICENSES_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license is not installed.
//
#define SL_E_DECRYPTION_LICENSES_NOT_AVAILABLE ((HRESULT)0xC004F01CL)

//
// MessageId: SL_E_LICENSE_SIGNATURE_VERIFICATION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that the verification of the license failed.
//
#define SL_E_LICENSE_SIGNATURE_VERIFICATION_FAILED ((HRESULT)0xC004F01DL)

//
// MessageId: SL_E_DATATYPE_MISMATCHED
//
// MessageText:
//
// The Software Licensing Service determined that the input data type does not match the data type in the license.
//
#define SL_E_DATATYPE_MISMATCHED         ((HRESULT)0xC004F01EL)

//
// MessageId: SL_E_INVALID_LICENSE
//
// MessageText:
//
// The Software Licensing Service determined that the license is invalid.
//
#define SL_E_INVALID_LICENSE             ((HRESULT)0xC004F01FL)

//
// MessageId: SL_E_INVALID_PACKAGE
//
// MessageText:
//
// The Software Licensing Service determined that the license package is invalid.
//
#define SL_E_INVALID_PACKAGE             ((HRESULT)0xC004F020L)

//
// MessageId: SL_E_VALIDITY_TIME_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the validity period of the license has expired.
//
#define SL_E_VALIDITY_TIME_EXPIRED       ((HRESULT)0xC004F021L)

//
// MessageId: SL_E_LICENSE_AUTHORIZATION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that the license authorization failed.
//
#define SL_E_LICENSE_AUTHORIZATION_FAILED ((HRESULT)0xC004F022L)

//
// MessageId: SL_E_LICENSE_DECRYPTION_FAILED
//
// MessageText:
//
// The Software Licensing Service reported that the license is invalid.
//
#define SL_E_LICENSE_DECRYPTION_FAILED   ((HRESULT)0xC004F023L)

//
// MessageId: SL_E_WINDOWS_INVALID_LICENSE_STATE
//
// MessageText:
//
// The Software Licensing Service reported that the license is invalid.
//
#define SL_E_WINDOWS_INVALID_LICENSE_STATE ((HRESULT)0xC004F024L)

//
// MessageId: SL_E_LUA_ACCESSDENIED
//
// MessageText:
//
// The Software Licensing Service reported that the action requires administrator privilege.
//
#define SL_E_LUA_ACCESSDENIED            ((HRESULT)0xC004F025L)

//
// MessageId: SL_E_PROXY_KEY_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the required data is not found.
//
#define SL_E_PROXY_KEY_NOT_FOUND         ((HRESULT)0xC004F026L)

//
// MessageId: SL_E_TAMPER_DETECTED
//
// MessageText:
//
// The Software Licensing Service reported that the license is tampered.
//
#define SL_E_TAMPER_DETECTED             ((HRESULT)0xC004F027L)

//
// MessageId: SL_E_POLICY_CACHE_INVALID
//
// MessageText:
//
// The Software Licensing Service reported that the policy cache is invalid.
//
#define SL_E_POLICY_CACHE_INVALID        ((HRESULT)0xC004F028L)

//
// MessageId: SL_E_INVALID_RUNNING_MODE
//
// MessageText:
//
// The Software Licensing Service cannot be started in the current OS mode.
//
#define SL_E_INVALID_RUNNING_MODE        ((HRESULT)0xC004F029L)

//
// MessageId: SL_E_SLP_NOT_SIGNED
//
// MessageText:
//
// The Software Licensing Service reported that the license is invalid.
//
#define SL_E_SLP_NOT_SIGNED              ((HRESULT)0xC004F02AL)

//
// MessageId: SL_E_CIDIID_INVALID_DATA
//
// MessageText:
//
// The Software Licensing Service reported that the format for the offline activation data is incorrect.
//
#define SL_E_CIDIID_INVALID_DATA         ((HRESULT)0xC004F02CL)

//
// MessageId: SL_E_CIDIID_INVALID_VERSION
//
// MessageText:
//
// The Software Licensing Service determined that the version of the offline Confirmation ID (CID) is incorrect.
//
#define SL_E_CIDIID_INVALID_VERSION      ((HRESULT)0xC004F02DL)

//
// MessageId: SL_E_CIDIID_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The Software Licensing Service determined that the version of the offline Confirmation ID (CID) is not supported.
//
#define SL_E_CIDIID_VERSION_NOT_SUPPORTED ((HRESULT)0xC004F02EL)

//
// MessageId: SL_E_CIDIID_INVALID_DATA_LENGTH
//
// MessageText:
//
// The Software Licensing Service reported that the length of the offline Confirmation ID (CID) is incorrect.
//
#define SL_E_CIDIID_INVALID_DATA_LENGTH  ((HRESULT)0xC004F02FL)

//
// MessageId: SL_E_CIDIID_NOT_DEPOSITED
//
// MessageText:
//
// The Software Licensing Service determined that the Installation ID (IID) or the Confirmation ID (CID) could not been saved.
//
#define SL_E_CIDIID_NOT_DEPOSITED        ((HRESULT)0xC004F030L)

//
// MessageId: SL_E_CIDIID_MISMATCHED
//
// MessageText:
//
// The Installation ID (IID) and the Confirmation ID (CID) do not match. Please confirm the IID and reacquire a new CID if necessary.
//
#define SL_E_CIDIID_MISMATCHED           ((HRESULT)0xC004F031L)

//
// MessageId: SL_E_INVALID_BINDING_BLOB
//
// MessageText:
//
// The Software Licensing Service determined that the binding data is invalid.
//
#define SL_E_INVALID_BINDING_BLOB        ((HRESULT)0xC004F032L)

//
// MessageId: SL_E_PRODUCT_KEY_INSTALLATION_NOT_ALLOWED
//
// MessageText:
//
// The Software Licensing Service reported that the product key is not allowed to be installed. Please see the eventlog for details.
//
#define SL_E_PRODUCT_KEY_INSTALLATION_NOT_ALLOWED ((HRESULT)0xC004F033L)

//
// MessageId: SL_E_EUL_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the license could not be found or was invalid.
//
#define SL_E_EUL_NOT_AVAILABLE           ((HRESULT)0xC004F034L)

//
// MessageId: SL_E_VL_NOT_WINDOWS_SLP
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated with a Volume license product key. Volume-licensed systems require upgrading from a qualifying operating system. Please contact your system administrator or use a different type of key.
//
#define SL_E_VL_NOT_WINDOWS_SLP          ((HRESULT)0xC004F035L)

//
// MessageId: SL_E_VL_NOT_ENOUGH_COUNT
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The count reported by your Key Management Service (KMS) is insufficient. Please contact your system administrator.
//
#define SL_E_VL_NOT_ENOUGH_COUNT         ((HRESULT)0xC004F038L)

//
// MessageId: SL_E_VL_BINDING_SERVICE_NOT_ENABLED
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated.  The Key Management Service (KMS) is not enabled.
//
#define SL_E_VL_BINDING_SERVICE_NOT_ENABLED ((HRESULT)0xC004F039L)

//
// MessageId: SL_E_VL_INFO_PRODUCT_USER_RIGHT
//
// MessageText:
//
// The Software Licensing Service reported that the computer was activated but the owner should verify the Product Use Rights.
//
#define SL_E_VL_INFO_PRODUCT_USER_RIGHT  ((HRESULT)0x4004F040L)

//
// MessageId: SL_E_VL_KEY_MANAGEMENT_SERVICE_NOT_ACTIVATED
//
// MessageText:
//
// The Software Licensing Service determined that the Key Management Service (KMS) is not activated. KMS needs to be activated. Please contact system administrator.
//
#define SL_E_VL_KEY_MANAGEMENT_SERVICE_NOT_ACTIVATED ((HRESULT)0xC004F041L)

//
// MessageId: SL_E_VL_KEY_MANAGEMENT_SERVICE_ID_MISMATCH
//
// MessageText:
//
// The Software Licensing Service determined that the specified Key Management Service (KMS) cannot be used.
//
#define SL_E_VL_KEY_MANAGEMENT_SERVICE_ID_MISMATCH ((HRESULT)0xC004F042L)

//
// MessageId: SL_E_PROXY_POLICY_NOT_UPDATED
//
// MessageText:
//
// The Software Licensing Service reported that the proxy policy has not been updated.
//
#define SL_E_PROXY_POLICY_NOT_UPDATED    ((HRESULT)0xC004F047L)

//
// MessageId: SL_E_CIDIID_INVALID_CHECK_DIGITS
//
// MessageText:
//
// The Software Licensing Service determined that the Installation ID (IID) or the Confirmation ID (CID) is invalid.
//
#define SL_E_CIDIID_INVALID_CHECK_DIGITS ((HRESULT)0xC004F04DL)

//
// MessageId: SL_E_LICENSE_MANAGEMENT_DATA_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that license management information was not found in the licenses.
//
#define SL_E_LICENSE_MANAGEMENT_DATA_NOT_FOUND ((HRESULT)0xC004F04FL)

//
// MessageId: SL_E_INVALID_PRODUCT_KEY
//
// MessageText:
//
// The Software Licensing Service reported that the product key is invalid.
//
#define SL_E_INVALID_PRODUCT_KEY         ((HRESULT)0xC004F050L)

//
// MessageId: SL_E_BLOCKED_PRODUCT_KEY
//
// MessageText:
//
// The Software Licensing Service reported that the product key is blocked.
//
#define SL_E_BLOCKED_PRODUCT_KEY         ((HRESULT)0xC004F051L)

//
// MessageId: SL_E_DUPLICATE_POLICY
//
// MessageText:
//
// The Software Licensing Service reported that the licenses contain duplicated properties. 
//
#define SL_E_DUPLICATE_POLICY            ((HRESULT)0xC004F052L)

//
// MessageId: SL_E_MISSING_OVERRIDE_ONLY_ATTRIBUTE
//
// MessageText:
//
// The Software Licensing Service determined that the license is invalid. The license contains an override policy that is not configured properly.
//
#define SL_E_MISSING_OVERRIDE_ONLY_ATTRIBUTE ((HRESULT)0xC004F053L)

//
// MessageId: SL_E_LICENSE_MANAGEMENT_DATA_DUPLICATED
//
// MessageText:
//
// The Software Licensing Service reported that license management information has duplicated data. 
//
#define SL_E_LICENSE_MANAGEMENT_DATA_DUPLICATED ((HRESULT)0xC004F054L)

//
// MessageId: SL_E_BASE_SKU_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the base SKU is not available.
//
#define SL_E_BASE_SKU_NOT_AVAILABLE      ((HRESULT)0xC004F055L)

//
// MessageId: SL_E_VL_MACHINE_NOT_BOUND
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated using the Key Management Service (KMS).
//
#define SL_E_VL_MACHINE_NOT_BOUND        ((HRESULT)0xC004F056L)

//
// MessageId: SL_E_SLP_MISSING_ACPI_SLIC
//
// MessageText:
//
// The Software Licensing Service reported that the computer BIOS is missing a required license.
//
#define SL_E_SLP_MISSING_ACPI_SLIC       ((HRESULT)0xC004F057L)

//
// MessageId: SL_E_SLP_MISSING_SLP_MARKER
//
// MessageText:
//
// The Software Licensing Service reported that the computer BIOS is missing a required license.
//
#define SL_E_SLP_MISSING_SLP_MARKER      ((HRESULT)0xC004F058L)

//
// MessageId: SL_E_SLP_BAD_FORMAT
//
// MessageText:
//
// The Software Licensing Service reported that a license in the computer BIOS is invalid.
//
#define SL_E_SLP_BAD_FORMAT              ((HRESULT)0xC004F059L)

//
// MessageId: SL_E_INVALID_PACKAGE_VERSION
//
// MessageText:
//
// The Software Licensing Service determined that the version of the license package is invalid.
//
#define SL_E_INVALID_PACKAGE_VERSION     ((HRESULT)0xC004F060L)

//
// MessageId: SL_E_PKEY_INVALID_UPGRADE
//
// MessageText:
//
// The Software Licensing Service determined that this specified product key can only be used for upgrading, not for clean installations.
//
#define SL_E_PKEY_INVALID_UPGRADE        ((HRESULT)0xC004F061L)

//
// MessageId: SL_E_ISSUANCE_LICENSE_NOT_INSTALLED
//
// MessageText:
//
// The Software Licensing Service reported that a required license could not be found.
//
#define SL_E_ISSUANCE_LICENSE_NOT_INSTALLED ((HRESULT)0xC004F062L)

//
// MessageId: SL_E_SLP_OEM_CERT_MISSING
//
// MessageText:
//
// The Software Licensing Service reported that the computer BIOS is missing a required license.
//
#define SL_E_SLP_OEM_CERT_MISSING        ((HRESULT)0xC004F063L)

//
// MessageId: SL_E_NONGENUINE_GRACE_TIME_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the non-genuine grace period expired.
//
#define SL_E_NONGENUINE_GRACE_TIME_EXPIRED ((HRESULT)0xC004F064L)

//
// MessageId: SL_I_NONGENUINE_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid non-genuine grace period.
//
#define SL_I_NONGENUINE_GRACE_PERIOD     ((HRESULT)0x4004F065L)

//
// MessageId: SL_E_DEPENDENT_PROPERTY_NOT_SET
//
// MessageText:
//
// The Software Licensing Service reported that the genuine information property can not be set before dependent property been set.
//
#define SL_E_DEPENDENT_PROPERTY_NOT_SET  ((HRESULT)0xC004F066L)

//
// MessageId: SL_E_NONGENUINE_GRACE_TIME_EXPIRED_2
//
// MessageText:
//
// The Software Licensing Service reported that the non-genuine grace period expired (type 2).
//
#define SL_E_NONGENUINE_GRACE_TIME_EXPIRED_2 ((HRESULT)0xC004F067L)

//
// MessageId: SL_I_NONGENUINE_GRACE_PERIOD_2
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid non-genuine grace period (type 2).
//
#define SL_I_NONGENUINE_GRACE_PERIOD_2   ((HRESULT)0x4004F068L)

//
// MessageId: SL_E_MISMATCHED_PRODUCT_SKU
//
// MessageText:
//
// The Software Licensing Service reported that the product SKU is not found.
//
#define SL_E_MISMATCHED_PRODUCT_SKU      ((HRESULT)0xC004F069L)

//
// MessageId: SL_E_OPERATION_NOT_ALLOWED
//
// MessageText:
//
// The Software Licensing Service reported that the requested operation is not allowed.
//
#define SL_E_OPERATION_NOT_ALLOWED       ((HRESULT)0xC004F06AL)

//
// MessageId: SL_E_VL_KEY_MANAGEMENT_SERVICE_VM_NOT_SUPPORTED
//
// MessageText:
//
// The Software Licensing Service determined that it is running in a virtual machine. The Key Management Service (KMS) is not supported in this mode.
//
#define SL_E_VL_KEY_MANAGEMENT_SERVICE_VM_NOT_SUPPORTED ((HRESULT)0xC004F06BL)

//
// MessageId: SL_E_VL_INVALID_TIMESTAMP
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The Key Management Service (KMS) determined that the request timestamp is invalid.
//
#define SL_E_VL_INVALID_TIMESTAMP        ((HRESULT)0xC004F06CL)

//
// MessageId: SL_E_PLUGIN_INVALID_MANIFEST
//
// MessageText:
//
// The Software Licensing Service reported that the plug-in manifest file is incorrect.
//
#define SL_E_PLUGIN_INVALID_MANIFEST     ((HRESULT)0xC004F071L)

//
// MessageId: SL_E_APPLICATION_POLICIES_MISSING
//
// MessageText:
//
// The Software Licensing Service reported that the license policies for fast query could not be found.
//
#define SL_E_APPLICATION_POLICIES_MISSING ((HRESULT)0xC004F072L)

//
// MessageId: SL_E_APPLICATION_POLICIES_NOT_LOADED
//
// MessageText:
//
// The Software Licensing Service reported that the license policies for fast query have not been loaded.
//
#define SL_E_APPLICATION_POLICIES_NOT_LOADED ((HRESULT)0xC004F073L)

//
// MessageId: SL_E_VL_BINDING_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. No Key Management Service (KMS) could be contacted. Please see the Application Event Log for additional information.
//
#define SL_E_VL_BINDING_SERVICE_UNAVAILABLE ((HRESULT)0xC004F074L)

//
// MessageId: SL_E_SERVICE_STOPPING
//
// MessageText:
//
// The Software Licensing Service reported that the operation cannot be completed because the service is stopping.
//
#define SL_E_SERVICE_STOPPING            ((HRESULT)0xC004F075L)

//
// MessageId: SL_E_PLUGIN_NOT_REGISTERED
//
// MessageText:
//
// The Software Licensing Service reported that the requested plug-in cannot be found.
//
#define SL_E_PLUGIN_NOT_REGISTERED       ((HRESULT)0xC004F076L)

//
// MessageId: SL_E_AUTHN_WRONG_VERSION
//
// MessageText:
//
// The Software Licensing Service determined incompatible version of authentication data.
//
#define SL_E_AUTHN_WRONG_VERSION         ((HRESULT)0xC004F077L)

//
// MessageId: SL_E_AUTHN_MISMATCHED_KEY
//
// MessageText:
//
// The Software Licensing Service reported that the key is mismatched.
//
#define SL_E_AUTHN_MISMATCHED_KEY        ((HRESULT)0xC004F078L)

//
// MessageId: SL_E_AUTHN_CHALLENGE_NOT_SET
//
// MessageText:
//
// The Software Licensing Service reported that the authentication data is not set.
//
#define SL_E_AUTHN_CHALLENGE_NOT_SET     ((HRESULT)0xC004F079L)

//
// MessageId: SL_E_AUTHN_CANT_VERIFY
//
// MessageText:
//
// The Software Licensing Service reported that the verification could not be done.
//
#define SL_E_AUTHN_CANT_VERIFY           ((HRESULT)0xC004F07AL)

//
// MessageId: SL_E_SERVICE_RUNNING
//
// MessageText:
//
// The requested operation is unavailable while the Software Licensing Service is running.
//
#define SL_E_SERVICE_RUNNING             ((HRESULT)0xC004F07BL)

//
// MessageId: SL_E_SLP_INVALID_MARKER_VERSION
//
// MessageText:
//
// The Software Licensing Service determined that the version of the computer BIOS is invalid.
//
#define SL_E_SLP_INVALID_MARKER_VERSION  ((HRESULT)0xC004F07CL)

//
// MessageId: SL_E_NOT_GENUINE
//
// MessageText:
//
// The Software Licensing Service reported that current state is not genuine.
//
#define SL_E_NOT_GENUINE                 ((HRESULT)0xC004F200L)

//
// 0xF300 - 0xF3FF reserved for token-based activation
//
//
// MessageId: SL_E_TKA_CHALLENGE_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The token-based activation challenge has expired.
//
#define SL_E_TKA_CHALLENGE_EXPIRED       ((HRESULT)0xC004F301L)

//
// MessageId: SL_E_TKA_SILENT_ACTIVATION_FAILURE
//
// MessageText:
//
// The Software Licensing Service reported that Silent Activation failed. The Software Licensing Service reported that there are no certificates found in the system that could activate the product without user interaction.
//
#define SL_E_TKA_SILENT_ACTIVATION_FAILURE ((HRESULT)0xC004F302L)

//
// MessageId: SL_E_TKA_INVALID_CERT_CHAIN
//
// MessageText:
//
// The Software Licensing Service reported that the certificate chain could not be built or failed validation.
//
#define SL_E_TKA_INVALID_CERT_CHAIN      ((HRESULT)0xC004F303L)

//
// MessageId: SL_E_TKA_GRANT_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that required license could not be found.
//
#define SL_E_TKA_GRANT_NOT_FOUND         ((HRESULT)0xC004F304L)

//
// MessageId: SL_E_TKA_CERT_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that there are no certificates found in the system that could activate the product.
//
#define SL_E_TKA_CERT_NOT_FOUND          ((HRESULT)0xC004F305L)

//
// MessageId: SL_E_TKA_INVALID_SKU_ID
//
// MessageText:
//
// The Software Licensing Service reported that this software edition does not support token-based activation.
//
#define SL_E_TKA_INVALID_SKU_ID          ((HRESULT)0xC004F306L)

//
// MessageId: SL_E_TKA_INVALID_BLOB
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. Activation data is invalid.
//
#define SL_E_TKA_INVALID_BLOB            ((HRESULT)0xC004F307L)

//
// MessageId: SL_E_TKA_TAMPERED_CERT_CHAIN
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. Activation data is tampered.
//
#define SL_E_TKA_TAMPERED_CERT_CHAIN     ((HRESULT)0xC004F308L)

//
// MessageId: SL_E_TKA_CHALLENGE_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. Activation challenge and response do not match.
//
#define SL_E_TKA_CHALLENGE_MISMATCH      ((HRESULT)0xC004F309L)

//
// MessageId: SL_E_TKA_INVALID_CERTIFICATE
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The certificate does not match the conditions in the license.
//
#define SL_E_TKA_INVALID_CERTIFICATE     ((HRESULT)0xC004F30AL)

//
// MessageId: SL_E_TKA_INVALID_SMARTCARD
//
// MessageText:
//
// The Software Licensing Service reported that the inserted smartcard could not be used to activate the product.
//
#define SL_E_TKA_INVALID_SMARTCARD       ((HRESULT)0xC004F30BL)

//
// MessageId: SL_E_TKA_FAILED_GRANT_PARSING
//
// MessageText:
//
// The Software Licensing Service reported that the token-based activation license content is invalid.
//
#define SL_E_TKA_FAILED_GRANT_PARSING    ((HRESULT)0xC004F30CL)

//
// MessageId: SL_E_TKA_INVALID_THUMBPRINT
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The thumbprint is invalid.
//
#define SL_E_TKA_INVALID_THUMBPRINT      ((HRESULT)0xC004F30DL)

//
// MessageId: SL_E_TKA_THUMBPRINT_CERT_NOT_FOUND
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The thumbprint does not match any certificate.
//
#define SL_E_TKA_THUMBPRINT_CERT_NOT_FOUND ((HRESULT)0xC004F30EL)

//
// MessageId: SL_E_TKA_CRITERIA_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The certificate does not match the criteria specified in the issuance license.
//
#define SL_E_TKA_CRITERIA_MISMATCH       ((HRESULT)0xC004F30FL)

//
// MessageId: SL_E_TKA_TPID_MISMATCH
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The certificate does not match the trust point identifier (TPID) specified in the issuance license.
//
#define SL_E_TKA_TPID_MISMATCH           ((HRESULT)0xC004F310L)

//
// MessageId: SL_E_TKA_SOFT_CERT_DISALLOWED
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. A soft token cannot be used for activation.
//
#define SL_E_TKA_SOFT_CERT_DISALLOWED    ((HRESULT)0xC004F311L)

//
// MessageId: SL_E_TKA_SOFT_CERT_INVALID
//
// MessageText:
//
// The Software Licensing Service reported that the computer could not be activated. The certificate cannot be used because its private key is exportable.
//
#define SL_E_TKA_SOFT_CERT_INVALID       ((HRESULT)0xC004F312L)

//
// MessageId: SL_E_TKA_CERT_CNG_NOT_AVAILABLE
//
// MessageText:
//
// The Software Licensing Service reported that the CNG encryption library could not be loaded.  The current certificate may not be available on this version of Windows.
//
#define SL_E_TKA_CERT_CNG_NOT_AVAILABLE  ((HRESULT)0xC004F313L)

//
// End of Token-Based activation errors
//
//
// MessageId: E_RM_UNKNOWN_ERROR
//
// MessageText:
//
// A networking problem has occurred while activating your copy of Windows.
//
#define E_RM_UNKNOWN_ERROR               ((HRESULT)0xC004FC03L)

//
// MessageId: SL_I_TIMEBASED_VALIDITY_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the timebased validity period.
//
#define SL_I_TIMEBASED_VALIDITY_PERIOD   ((HRESULT)0x4004FC04L)

//
// MessageId: SL_I_PERPETUAL_OOB_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application has a perpetual grace period.
//
#define SL_I_PERPETUAL_OOB_GRACE_PERIOD  ((HRESULT)0x4004FC05L)

//
// MessageId: SL_I_TIMEBASED_EXTENDED_GRACE_PERIOD
//
// MessageText:
//
// The Software Licensing Service reported that the application is running within the valid extended grace period.
//
#define SL_I_TIMEBASED_EXTENDED_GRACE_PERIOD ((HRESULT)0x4004FC06L)

//
// MessageId: SL_E_VALIDITY_PERIOD_EXPIRED
//
// MessageText:
//
// The Software Licensing Service reported that the validity period expired.
//
#define SL_E_VALIDITY_PERIOD_EXPIRED     ((HRESULT)0xC004FC07L)

//
// MessageId: SL_E_TAMPER_RECOVERY_REQUIRES_ACTIVATION
//
// MessageText:
//
// The Software Licensing Service reported that activation is required to recover from tampering of SL Service trusted store.
//
#define SL_E_TAMPER_RECOVERY_REQUIRES_ACTIVATION ((HRESULT)0xC004FE00L)

// ******************
// ******************
//
// The following errors are mappings to the SPAPI error strings for UX messaging
//
// ******************
// ******************

//////////////////////////////////////////////////////////
//SP_PUB_GENERAL_ZONE
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_GENERAL_NOT_INITIALIZED
//
// MessageText:
//
// The security processor reported an initialization error.
//
#define SL_REMAPPING_SP_PUB_GENERAL_NOT_INITIALIZED ((HRESULT)0xC004D101L)

//
// MessageId: SL_REMAPPING_SP_STATUS_SYSTEM_TIME_SKEWED
//
// MessageText:
//
// The security processor reported that the machine time is inconsistent with the trusted time.
//
#define SL_REMAPPING_SP_STATUS_SYSTEM_TIME_SKEWED ((HRESULT)0x8004D102L)

//
// MessageId: SL_REMAPPING_SP_STATUS_GENERIC_FAILURE
//
// MessageText:
//
// The security processor reported that an error has occurred.
//
#define SL_REMAPPING_SP_STATUS_GENERIC_FAILURE ((HRESULT)0xC004D103L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALIDARG
//
// MessageText:
//
// The security processor reported that invalid data was used.
//
#define SL_REMAPPING_SP_STATUS_INVALIDARG ((HRESULT)0xC004D104L)

//
// MessageId: SL_REMAPPING_SP_STATUS_ALREADY_EXISTS
//
// MessageText:
//
// The security processor reported that the value already exists.
//
#define SL_REMAPPING_SP_STATUS_ALREADY_EXISTS ((HRESULT)0xC004D105L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The security processor reported that an insufficient buffer was used.
//
#define SL_REMAPPING_SP_STATUS_INSUFFICIENT_BUFFER ((HRESULT)0xC004D107L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALIDDATA
//
// MessageText:
//
// The security processor reported that invalid data was used.
//
#define SL_REMAPPING_SP_STATUS_INVALIDDATA ((HRESULT)0xC004D108L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALID_SPAPI_CALL
//
// MessageText:
//
// The security processor reported that an invalid call was made.
//
#define SL_REMAPPING_SP_STATUS_INVALID_SPAPI_CALL ((HRESULT)0xC004D109L)

//
// MessageId: SL_REMAPPING_SP_STATUS_INVALID_SPAPI_VERSION
//
// MessageText:
//
// The security processor reported a version mismatch error.
//
#define SL_REMAPPING_SP_STATUS_INVALID_SPAPI_VERSION ((HRESULT)0xC004D10AL)

//
// MessageId: SL_REMAPPING_SP_STATUS_DEBUGGER_DETECTED
//
// MessageText:
//
// The security processor cannot operate while a debugger is attached.
//
#define SL_REMAPPING_SP_STATUS_DEBUGGER_DETECTED ((HRESULT)0x8004D10BL)


//////////////////////////////////////////////////////////
// SP_PUB_TS_ZONE
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_TS_TAMPERED
//
// MessageText:
//
// The security processor reported that the trusted data store was tampered.
//
#define SL_REMAPPING_SP_PUB_TS_TAMPERED  ((HRESULT)0xC004D301L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_REARMED
//
// MessageText:
//
// The security processor reported that the trusted data store was rearmed.
//
#define SL_REMAPPING_SP_PUB_TS_REARMED   ((HRESULT)0xC004D302L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_RECREATED
//
// MessageText:
//
// The security processor reported that the trusted store has been recreated.
//
#define SL_REMAPPING_SP_PUB_TS_RECREATED ((HRESULT)0xC004D303L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_NOT_FOUND
//
// MessageText:
//
// The security processor reported that entry key was not found in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_NOT_FOUND ((HRESULT)0xC004D304L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_ALREADY_EXISTS
//
// MessageText:
//
// The security processor reported that the entry key already exists in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_ALREADY_EXISTS ((HRESULT)0xC004D305L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_SIZE_TOO_BIG
//
// MessageText:
//
// The security processor reported that the entry key is too big to fit in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_ENTRY_KEY_SIZE_TOO_BIG ((HRESULT)0xC004D306L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_MAX_REARM_REACHED
//
// MessageText:
//
// The security processor reported that the maximum allowed number of re-arms has been exceeded.  You must re-install the OS before trying to re-arm again.
//
#define SL_REMAPPING_SP_PUB_TS_MAX_REARM_REACHED ((HRESULT)0xC004D307L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_DATA_SIZE_TOO_BIG
//
// MessageText:
//
// The security processor has reported that entry data size is too big to fit in the trusted data store.
//
#define SL_REMAPPING_SP_PUB_TS_DATA_SIZE_TOO_BIG ((HRESULT)0xC004D308L)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_INVALID_HW_BINDING
//
// MessageText:
//
// The security processor has reported that the machine has gone out of hardware tolerance.
//
#define SL_REMAPPING_SP_PUB_TS_INVALID_HW_BINDING ((HRESULT)0xC004D309L)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_ALREADY_EXISTS
//
// MessageText:
//
// The security processor has reported that the secure timer already exists.
//
#define SL_REMAPPING_SP_PUB_TIMER_ALREADY_EXISTS ((HRESULT)0xC004D30AL)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_NOT_FOUND
//
// MessageText:
//
// The security processor has reported that the secure timer was not found.
//
#define SL_REMAPPING_SP_PUB_TIMER_NOT_FOUND ((HRESULT)0xC004D30BL)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_EXPIRED
//
// MessageText:
//
// The security processor has reported that the secure timer has expired.
//
#define SL_REMAPPING_SP_PUB_TIMER_EXPIRED ((HRESULT)0xC004D30CL)

//
// MessageId: SL_REMAPPING_SP_PUB_TIMER_NAME_SIZE_TOO_BIG
//
// MessageText:
//
// The security processor has reported that the secure timer name is too long.
//
#define SL_REMAPPING_SP_PUB_TIMER_NAME_SIZE_TOO_BIG ((HRESULT)0xC004D30DL)

//
// MessageId: SL_REMAPPING_SP_PUB_TS_FULL
//
// MessageText:
//
// The security processor reported that the trusted data store is full.
//
#define SL_REMAPPING_SP_PUB_TS_FULL      ((HRESULT)0xC004D30EL)


//////////////////////////////////////////////////////////
// SP_PUB_MODAUTH_ZONE
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_TAMPER_MODULE_AUTHENTICATION
//
// MessageText:
//
// The security processor reported a system file mismatch error.
//
#define SL_REMAPPING_SP_PUB_TAMPER_MODULE_AUTHENTICATION ((HRESULT)0xC004D401L)

//
// MessageId: SL_REMAPPING_SP_PUB_TAMPER_SECURITY_PROCESSOR_PATCHED
//
// MessageText:
//
// The security processor reported a system file mismatch error.
//
#define SL_REMAPPING_SP_PUB_TAMPER_SECURITY_PROCESSOR_PATCHED ((HRESULT)0xC004D402L)


//////////////////////////////////////////////////////////
// SP_PUB_KM_CACHE_ZONE (Error codes)
//////////////////////////////////////////////////////////

//
// MessageId: SL_REMAPPING_SP_PUB_KM_CACHE_TAMPER
//
// MessageText:
//
// The security processor reported an error with the kernel data.
//
#define SL_REMAPPING_SP_PUB_KM_CACHE_TAMPER ((HRESULT)0xC004D501L)

#endif//_SLERROR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SMPAB.h ===
/*
 *  S M P A B . H
 *  
 *  Definitions used by the Microsoft Sample Address Book
 *  provider for service entry calls
 *  
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  Property tag definitions
 */

/*      The following MAPI-defined properties are settable in service entry */
/*      calls:                                                              */
/*                                                                          */
/*          PR_SAB_FILE_NAME                                                */
/*          PR_SAB_UID                                                      */

#define PR_SAB_FILE PROP_TAG(PT_STRING8,0x6604)
#define PR_SAB_UID  PROP_TAG(PT_BINARY,0x6601)

/*
 *  PR_SAB_FILE_NAME is the full path name of the .SAB file (e.g. c:\foo\mylist.sab).
 *                   This string must be ANSI.
 *
 *  PR_SAB_UID is the UID uniquely identifying this session of the SAB.  If you have
 *             multiple SABs configured, they must have different PR_SAB_UIDs.
 */

/*
 *  The Sample Address Book's PR_AB_PROVIDER_ID
 */
#define SAB_PROVIDER_ID {0x34,0xda,0x7e,0x60,0x03,0x1b,0x11,0xce,0x95,0x74,0x00,0xaa,0x00,0x3c,0xd2,0x07}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SoftPub.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       softpub.h
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//--------------------------------------------------------------------------

#ifndef SOFTPUB_H
#define SOFTPUB_H

#include <wintrust.h>

#ifdef __cplusplus
extern "C"
{
#endif

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// Softpub Policy Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Authenticode Policy Provider
//  (WINTRUST.DLL's Policy Provider)
//

#define SP_POLICY_PROVIDER_DLL_NAME         L"WINTRUST.DLL"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_VERIFY_V2 Guid  (Authenticode)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a file/object using the Microsoft Authenticode
//  Policy Provider,
//
//          {00AAC56B-CD44-11d0-8CC2-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_VERIFY_V2                       \
            { 0xaac56b,                                         \
              0xcd44,                                           \
              0x11d0,                                           \
              { 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_INIT_FUNCTION                    L"SoftpubInitialize"
#define SP_OBJTRUST_FUNCTION                L"SoftpubLoadMessage"
#define SP_SIGTRUST_FUNCTION                L"SoftpubLoadSignature"
#define SP_CHKCERT_FUNCTION                 L"SoftpubCheckCert"
#define SP_FINALPOLICY_FUNCTION             L"SoftpubAuthenticode"
#define SP_CLEANUPPOLICY_FUNCTION           L"SoftpubCleanup"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_TRUSTPROVIDER_TEST (Authenticode TEST)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to dump
//  the CRYPT_PROVIDER_DATA structure to a file after calling the
//  Authenticode Policy Provider.
//
//          {573E31F8-DDBA-11d0-8CCB-00C04FC295EE}
//
#define WINTRUST_ACTION_TRUSTPROVIDER_TEST                      \
            { 0x573e31f8,                                       \
              0xddba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_TESTDUMPPOLICY_FUNCTION_TEST     L"SoftpubDumpStructure"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CERT_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  a certificate chain only.  This is only valid when passing in a
//  certificate context in the WinVerifyTrust input structures.
//
//          {189A3842-3041-11d1-85E1-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_CERT_VERIFY                     \
            { 0x189a3842,                                       \
              0x3041,                                           \
              0x11d1,                                           \
              { 0x85, 0xe1, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_GENERIC_CERT_INIT_FUNCTION       L"SoftpubDefCertInit"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CHAIN_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  certificate chains created from any object type: file, cert, signer, ...
//  A callback is provided to implement the final chain policy using
//  the chain context for each signer and counter signer.
//
//          {fc451c16-ac75-11d1-b4b8-00c04fb66ea0}
//
#define WINTRUST_ACTION_GENERIC_CHAIN_VERIFY                    \
            { 0xfc451c16,                                       \
              0xac75,                                           \
              0x11d1,                                           \
              { 0xb4, 0xb8, 0x00, 0xc0, 0x4f, 0xb6, 0x6e, 0xa0 }\
            }
#define GENERIC_CHAIN_FINALPOLICY_FUNCTION      L"GenericChainFinalProv"
#define GENERIC_CHAIN_CERTTRUST_FUNCTION        L"GenericChainCertificateTrust"


typedef struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO
    WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO,
        *PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO;

struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };
    PCCERT_CHAIN_CONTEXT                    pChainContext;

    // SGNR_TYPE_TIMESTAMP defined in wintrust.h
    DWORD                                   dwSignerType;
    PCMSG_SIGNER_INFO                       pMsgSignerInfo;
    DWORD                                   dwError;

    DWORD                                   cCounterSigner;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO   *rgpCounterSigner;
};

typedef HRESULT (WINAPI *PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK)(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    );

// The fields in the following data structure are passed to
// CertGetCertificateChain().
typedef struct _WTD_GENERIC_CHAIN_POLICY_CREATE_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    HCERTCHAINENGINE                        hChainEngine;
    PCERT_CHAIN_PARA                        pChainPara;
    DWORD                                   dwFlags;
    void                                    *pvReserved;
} WTD_GENERIC_CHAIN_POLICY_CREATE_INFO, *PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO;

typedef struct _WTD_GENERIC_CHAIN_POLICY_DATA {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pSignerChainInfo;
    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pCounterSignerChainInfo;
    PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK   pfnPolicyCallback;
    void                                    *pvPolicyArg;
} WTD_GENERIC_CHAIN_POLICY_DATA, *PWTD_GENERIC_CHAIN_POLICY_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// HTTPSPROV_ACTION Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  SSL/PCT connections through IE.
//
//          {573E31F8-AABA-11d0-8CCB-00C04FC295EE}
//
#define HTTPSPROV_ACTION                                        \
            { 0x573e31f8,                                       \
              0xaaba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define HTTPS_FINALPOLICY_FUNCTION          L"HTTPSFinalProv"
#define HTTPS_CHKCERT_FUNCTION              L"HTTPSCheckCertProv"
#define HTTPS_CERTTRUST_FUNCTION            L"HTTPSCertificateTrust"





//////////////////////////////////////////////////////////////////////////////
//
// OFFICESIGN_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a Structured Storage file using the Microsoft Office
//  Authenticode add-on Policy Provider,
//
//          {5555C2CD-17FB-11d1-85C4-00C04FC295EE}
//
#define     OFFICESIGN_ACTION_VERIFY                                    \
                { 0x5555c2cd,                                           \
                  0x17fb,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     OFFICE_POLICY_PROVIDER_DLL_NAME             SP_POLICY_PROVIDER_DLL_NAME
#define     OFFICE_INITPROV_FUNCTION                    L"OfficeInitializePolicy"
#define     OFFICE_CLEANUPPOLICY_FUNCTION               L"OfficeCleanupPolicy"


//////////////////////////////////////////////////////////////////////////////
//
// DRIVER_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a WHQL signed driver.  This is an Authenticode add-on
//  Policy Provider,
//
//          {F750E6C3-38EE-11d1-85E5-00C04FC295EE}
//
#define     DRIVER_ACTION_VERIFY                                        \
                { 0xf750e6c3,                                           \
                  0x38ee,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     DRIVER_INITPROV_FUNCTION                    L"DriverInitializePolicy"
#define     DRIVER_FINALPOLPROV_FUNCTION                L"DriverFinalPolicy"
#define     DRIVER_CLEANUPPOLICY_FUNCTION               L"DriverCleanupPolicy"

typedef struct DRIVER_VER_MAJORMINOR_
{
    DWORD           dwMajor;
    DWORD           dwMinor;
    
} DRIVER_VER_MAJORMINOR;

typedef struct DRIVER_VER_INFO_
{
    DWORD                               cbStruct;               // IN - set to sizeof(DRIVER_VER_INFO)

    ULONG_PTR                           dwReserved1;            // IN - set to NULL
    ULONG_PTR                           dwReserved2;            // IN - set to NULL

    DWORD                               dwPlatform;             // IN - OPTIONAL: platform to use
    DWORD                               dwVersion;              // IN - OPTIONAL: major version to use (NOT USED!!!)

    WCHAR                               wszVersion[MAX_PATH];   // OUT: version string from catalog file
    WCHAR                               wszSignedBy[MAX_PATH];  // OUT: signer display name from certificate
    PCCERT_CONTEXT                      pcSignerCertContext;    // OUT: client MUST free this!!!

    DRIVER_VER_MAJORMINOR               sOSVersionLow;          // IN - OPTIONAL: lowest compatible version
    DRIVER_VER_MAJORMINOR               sOSVersionHigh;         // IN - OPTIONAL: highest compatible version

    DWORD                               dwBuildNumberLow;       // IN - OPTIONAL: added to sOSVersionLow as 
                                                                //      third node for finer version granularity
    DWORD                               dwBuildNumberHigh;      // IN - OPTIONAL: added to sOSVersionHigh as 
                                                                //      third node for finer version granularity

    //
    // NOTES:
    // 1. dwPlatform _must_ be set to a non-zero value in order for proper version checking to be done.
    // 2. dwVersion is no longer used, sOSVersionLow and sOsVersionhigh have taken its place
    // 3. If dwBuildNumberLow and dwBuildNumberHigh are 0, they are unused.  Otherwise, they are considered 
    //    to be extensions of sOSVersionLow and sOSVersionHigh respectively.  Make special note of this when
    //    reading note 4.
    // 4. If you are validating against a single OS version, then set both sOSVersionLow and sOSVersion high,
    //    to the version you are validating against.  If sOSVersionLow and sOSVersionHigh are different, then
    //    the validation is done for the whole version range, from sOSVersionLow to sOSVersionHigh.
    //

} DRIVER_VER_INFO, *PDRIVER_VER_INFO;

#include <poppack.h>


#ifdef __cplusplus
}
#endif

#endif // SOFTPUB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Smx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**          Copyright(c) Microsoft Corporation 1992 - 1999          **/
/**********************************************************************/

/*
    smx.h
    This file contains the common messages, manifests, types, and
    structures used by Server Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.
*/



#ifndef _SMX_H_
#define _SMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define MENU_TEXT_LEN                   50



//
//  This is the current version number of the extension interface.
//

#define SME_VERSION                     0



//
//  These are the messages sent from the extension to the
//  Server Manager application.
//
//      SM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the Server Manager,
//                        this must always be zero.
//
//              lParam  - Points to an SMS_GETSELCOUNT structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//
//      SM_GETSERVERSEL[A]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Server
//                        manager uses a single-select listbox, this
//                        value must always be zero.
//
//              lParam  - Points to an SMS_GETSERVERSEL[AW] structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//      SM_GETCURFOCUS[AW]
//
//              Purpose - Retrieves the current application focus.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETCURFOCUS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      SM_GETOPTIONS
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETOPTIONS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define SM_GETSELCOUNT                  (WM_USER + 1000)
#define SM_GETSERVERSELA                (WM_USER + 1001)
#define SM_GETSERVERSELW                (WM_USER + 1002)
#define SM_GETCURFOCUSA                 (WM_USER + 1003)
#define SM_GETCURFOCUSW                 (WM_USER + 1004)
#define SM_GETOPTIONS                   (WM_USER + 1005)

#ifdef UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELW
#define SM_GETCURFOCUS                  SM_GETCURFOCUSW
#else   // !UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELA
#define SM_GETCURFOCUS                  SM_GETCURFOCUSA
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The SMS_LOADMENU[AW] structure is passed to the extension's
//  SMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to SMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the Server Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The Server Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the Server Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwServerType    - A bitmask containing the appropriate server type
//                        bit associated with the extension.  It is
//                        assumed that each extension will be associated
//                        with a unique server type.  For example,
//                        SV_TYPE_WFW represents Windows for Workgroups
//                        servers.
//
//      dwMenuDelta     - The Server Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _SMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUA, * PSMS_LOADMENUA;

typedef struct _SMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUW, * PSMS_LOADMENUW;

#ifdef UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUW
#define PSMS_LOADMENU                   PSMS_LOADMENUW
#else   // !UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUA
#define PSMS_LOADMENU                   PSMS_LOADMENUA
#endif  // UNICODE


//
//  The SMS_GETSERVERSEL[AW] structure is filled in by the
//  Server Manager when it handles SM_GETSERVERSEL[AW] messages.
//  This is used to return the current selection to the extension.
//
//      szServerName    - Will receive the UNC name of the selected
//                        server.
//
//      dwServerType    - Will receive the server type mask associated
//                        with the server.  This field may be 0 if
//                        the type is unknown.
//

typedef struct _SMS_GETSERVERSELA
{
    CHAR        szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSELA, * PSMS_GETSERVERSELA;

typedef struct _SMS_GETSERVERSELW
{
    WCHAR       szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSELW, * PSMS_GETSERVERSELW;

#ifdef UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELW
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELW
#else   // !UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELA
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELA
#endif  // UNICODE


//
//  The SMS_GETSELCOUNT structure is filled in by the Server Manager
//  when it handles the SM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  In the
//  current implementation, this will be either 0 (empty listbox)
//  or 1 (single selection).
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _SMS_GETSELCOUNT
{
    DWORD       dwItems;
} SMS_GETSELCOUNT, * PSMS_GETSELCOUNT;


//
//  The SMS_GETCURFOCUS[AW] structure is filled in by the Server Manager
//  when it handles the SM_GETCURFOCUS message.  This is used to
//  return the current focus of the User Manager application.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        SM_FOCUS_TYPE_NT_DOMAIN
//                        SM_FOCUS_TYPE_LM_DOMAIN
//                        SM_FOCUS_TYPE_UNKNOWN_DOMAIN
//                        SM_FOCUS_TYPE_NT_SERVER
//                        SM_FOCUS_TYPE_LM_SERVER
//                        SM_FOCUS_TYPE_WFW_SERVER
//                        SM_FOCUS_TYPE_UNKNOWN_SERVER
//

#define SM_FOCUS_TYPE_NT_DOMAIN         1
#define SM_FOCUS_TYPE_LM_DOMAIN         2
#define SM_FOCUS_TYPE_UNKNOWN_DOMAIN    3
#define SM_FOCUS_TYPE_NT_SERVER         4
#define SM_FOCUS_TYPE_LM_SERVER         5
#define SM_FOCUS_TYPE_WFW_SERVER        6
#define SM_FOCUS_TYPE_UNKNOWN_SERVER    7

typedef struct _SMS_GETCURFOCUSA
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSA, * PSMS_GETCURFOCUSA;

typedef struct _SMS_GETCURFOCUSW
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSW, * PSMS_GETCURFOCUSW;

#ifdef UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSW
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSW
#else   // UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSA
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSA
#endif  // UNICODE


//
//  The SMS_GETOPTIONS structure is filled in by the Server Manager
//  when it handles the SM_GETOPTIONS message.  This is used to
//  return the current option settings of the Server Manager
//  application.
//
//      fSaveSettingsOnExit     - Should Server Manager settings be saved
//                                on exit?
//
//      fConfirmation           - Should permanent and/or dangerous
//                                actions be confirmed?  In the current
//                                Server Manager implementation, this
//                                will always be TRUE.
//

typedef struct _SMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;

} SMS_GETOPTIONS, * PSMS_GETOPTIONS;


//
//  The SMS_VALIDATE[AW] structure is passed between the Server Manager
//  application and the extension to validate a particular "alien"
//  (non-LANMan) server.
//
//      pszServer       - The (UNC) name of the server to validate.  This
//                        is filled in by the Server Manager.
//
//      pszType         - The type string to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//
//      pszComment      - The comment to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//

typedef struct _SMS_VALIDATEA
{
    const CHAR * pszServer;
    CHAR       * pszType;
    CHAR       * pszComment;

} SMS_VALIDATEA, * PSMS_VALIDATEA;

typedef struct _SMS_VALIDATEW
{
    const WCHAR * pszServer;
    WCHAR       * pszType;
    WCHAR       * pszComment;

} SMS_VALIDATEW, * PSMS_VALIDATEW;

#ifdef UNICODE
#define SMS_VALIDATE                SMS_VALIDATEW
#define PSMS_VALIDATE               PSMS_VALIDATEW
#else   // UNICODE
#define SMS_VALIDATE                SMS_VALIDATEA
#define PSMS_VALIDATE               PSMS_VALIDATEA
#endif  // UNICODE



//
//  These are the names of the extension entrypoints.
//

#define SZ_SME_UNLOADMENU               "SMEUnloadMenu"
#define SZ_SME_INITIALIZEMENU           "SMEInitializeMenu"
#define SZ_SME_REFRESH                  "SMERefresh"
#define SZ_SME_MENUACTION               "SMEMenuAction"

#define SZ_SME_LOADMENUW                "SMELoadMenuW"
#define SZ_SME_GETEXTENDEDERRORSTRINGW  "SMEGetExtendedErrorStringW"
#define SZ_SME_VALIDATEW                "SMEValidateW"

#define SZ_SME_LOADMENUA                "SMELoadMenuA"
#define SZ_SME_GETEXTENDEDERRORSTRINGA  "SMEGetExtendedErrorStringA"
#define SZ_SME_VALIDATEA                "SMEValidateA"

#ifdef UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUW
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGW
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEW
#else   // !UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUA
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGA
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PSMX_LOADMENU)( HWND          hWnd,
                                        PSMS_LOADMENU psmsload );

typedef LPTSTR (PASCAL * PSMX_GETEXTENDEDERRORSTRING)( VOID );

typedef VOID (PASCAL * PSMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PSMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PSMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PSMX_MENUACTION)( HWND hwndParent, DWORD dwEventId );

typedef BOOL (PASCAL * PSMX_VALIDATE)( PSMS_VALIDATE psmsvalidate );



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL SMELoadMenuA( HWND           hWnd,
                           PSMS_LOADMENUA psmsload );

DWORD PASCAL SMELoadMenuW( HWND           hWnd,
                           PSMS_LOADMENUW psmsload );

LPSTR  PASCAL SMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL SMEGetExtendedErrorStringW( VOID );

VOID PASCAL SMEUnloadMenu( VOID );

VOID PASCAL SMEInitializeMenu( VOID );

VOID PASCAL SMERefresh( HWND hwndParent );

VOID PASCAL SMEMenuAction( HWND hwndParent, DWORD dwEventId );

BOOL PASCAL SMEValidateA( PSMS_VALIDATEA psmsValidate );

BOOL PASCAL SMEValidateW( PSMS_VALIDATEW psmsValidate );



#endif  // _SMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\slpublic.h ===
/*++

Copyright (C) Microsoft Corporation, 2006

Module Name:

    slpublic.h

Abstract:

    Software Licensing and Geniune Advantage Client public API
   
--*/
#pragma once

#ifndef _SLPUBLIC_H_
#define _SLPUBLIC_H_

#if defined(SPP_CODE_PROJECT_MARKER) || defined(SPP_CODE_PROJECT_MARKER_SECURE)
#if !defined(SPP_PUBLISHING_INCLUDED_FROM_TRAMPOLINE) && !defined(SPP_PUBLISHING_USE_FORCE_OFFICIAL)
#error this header file cannot be included directly from SPP projects; use sppinc_* prefix instead.
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define SLFreeMemory(p) LocalFree(p)
    
#define SLWGAFreeMemory(p) LocalFree(p)

typedef GUID SLID;
    
typedef enum _tagSLDATATYPE
{
    SL_DATA_NONE        = REG_NONE,
    SL_DATA_SZ          = REG_SZ,
    SL_DATA_DWORD       = REG_DWORD,
    SL_DATA_BINARY      = REG_BINARY,
    SL_DATA_MULTI_SZ    = REG_MULTI_SZ,
    SL_DATA_SUM         = 100,
} SLDATATYPE;

typedef enum _SL_GENUINE_STATE
{
    SL_GEN_STATE_IS_GENUINE         = 0,
    SL_GEN_STATE_INVALID_LICENSE,
    SL_GEN_STATE_TAMPERED,
    SL_GEN_STATE_LAST, 
} SL_GENUINE_STATE;

typedef struct _tagSL_NONGENUINE_UI_OPTIONS
{
    DWORD                       cbSize;
    CONST SLID*                 pComponentId;
    HRESULT                     hResultUI;

} SL_NONGENUINE_UI_OPTIONS;


#define SL_PROP_BRT_DATA                                    L"SL_BRT_DATA"
#define SL_PROP_BRT_COMMIT                                  L"SL_BRT_COMMIT"
#define SL_PROP_GENUINE_RESULT                              L"SL_GENUINE_RESULT"
#define SL_PROP_NONGENUINE_GRACE_FLAG                       L"SL_NONGENUINE_GRACE_FLAG"

#define SL_POLICY_EVALUATION_MODE_ENABLED                   L"Security-SPP-EvaluationModeEnabled"

__control_entrypoint(DllExport)
HRESULT 
WINAPI
SLGetWindowsInformation(
    __in                        PCWSTR                      pwszValueName,
    __out_opt                   SLDATATYPE*                 peDataType,
    __out                       UINT*                       pcbValue,
    __deref_out_bcount(*pcbValue) PBYTE*                    ppbValue
    );
/*++
Routine Description:

    This function is used to for Windows components to get 
    component policy value.
    
Arguments:

    pwszValueName
        The name of the requested value.
        
    peDataType
        Data type. Following types are supported:
            SL_DATA_SZ     - UNICODE string
            SL_DATA_DWORD  - DWORD
            SL_DATA_BINARY - Binary blob
        
    pcbValue
        Size of the allocated buffer.
        
    ppbValue
        The value. If successful, the data is returned in the buffer 
        allocated by SLC.
        The caller has to call SLFreeMemory to free the memory. 
        
Return Error:
    E_INVALIDARG
    SL_E_VALUE_NOT_FOUND
    SL_E_RIGHT_NOT_GRANTED
    
--*/

__control_entrypoint(DllExport)
HRESULT 
WINAPI
SLGetWindowsInformationDWORD(
    __in PCWSTR pwszValueName,
    __out DWORD* pdwValue
    );
/*++
Routine Description:

    This function is used to for Windows components to get 
    component policy DWORD value.

Arguments:

    pwszValueName
        The name of the requested value.
        
    pdwValue
        The buffer to receive DWORD value
        
Return Error:
    E_INVALIDARG
    SL_E_VALUE_NOT_FOUND
    SL_E_RIGHT_NOT_GRANTED
    SL_E_DATATYPE_MISMATCHED
    
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLIsGenuineLocal(
    __in                        CONST SLID*                 pAppId,
    __out                       SL_GENUINE_STATE*           pGenuineState, 
    __inout_opt                 SL_NONGENUINE_UI_OPTIONS*   pUIOptions
    );
/*++
Routine Description:

    Determines if an installation is a Genuine installation.
    It interrogates the license for pAppId and inspects the "Tampered"
    flag.  If either the license for pAppId is invalid or the "Tampered"
    flag is set, the installation is assumed to be invalid.

    pGenuineState is ONLY modified if the result is S_OK.  Otherwise, it is
    left in the state in which it was found on function entry.

Arguments:

    pAppId
        Application identifier. 

    pbGenuineState
        Output state value - one of the SL_GENUINE_STATE values

    pUIOptions
        Non genuine UI options. If NULL, no UI is displayed if 
        state is non-genuine. 

Return Error:

    S_OK
        Operation completed successfully.

    E_INVALIDARG
        pGenuineState is NULL.

--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLIsGenuineLocalEx(
    __in                        CONST SLID*                 pAppId,
    __in_opt                    CONST SLID*                 pSkuId,
    __out                       SL_GENUINE_STATE*           pGenuineState
    );
/*++
Routine Description:

    Determines if an installation is a Genuine installation.
    If the SkuId is provided, it is used for the primary check.  If the Sku license
    contains a ProductUniquenessGroupId value, that is also used.  Finally, the AppId is used.
    If the AppId, ProductUniquenessGroupId, or SkuId contains a "Tampered" flag or if the license
    state is invalid or "Tampered", the installation is assumed to be invalid.
    

    pGenuineState is ONLY modified if the result is S_OK.  Otherwise, it is
    left in the state in which it was found on function entry.

Arguments:

    pAppId
        Application identifier.
    
    pSkuId
        Sku identifier, optional.  If specified and the Sku license contains a
        ProductUniquenessGroupId then that is also checked.

    pbGenuineState
        Output state value - one of the SL_GENUINE_STATE values

Return Error:

    S_OK
        Operation completed successfully.

    E_INVALIDARG
        pGenuineState is NULL.

--*/


__control_entrypoint(DllExport)
HRESULT
WINAPI
SLAcquireGenuineTicket(
    __deref_out_bcount(*pcbTicketBlob) VOID**               ppTicketBlob,  
    __out                       UINT*                       pcbTicketBlob,
    __in                        PCWSTR                      pwszTemplateId, 
    __in                        PCWSTR                      pwszServerUrl, 
    __in_opt                    PCWSTR                      pwszClientToken 
    );
/*++
Routine Description:

    Returns genuine ticket acquired from Software Licensing Server based
    on SLWGA template blob. 
    
    The client is responsible for freeing the buffer returned in ppGenuineBlob.
    SLWGAFreeMemory should be used to free the memory.

    The output parameters are only set if the function returns S_OK.  Otherwise,
    they are left as they were when the function was entered.

Arguments:

    ppTicketBlob
        Pointer to output pointer to be returned (XrML genuine ticket).

    pcbTicketBlob
        An output pointer that will contain the size, in bytes, of the region
        returned in ppTicketBlob.

    pwszTemplateId
        Id of genuine blob template kept on the server side. 

    pwszServerUrl
        Ticket acquisition server url. 

    pwszClientToken
        Client custom token. 

Return Error:

    S_OK
        Operation completed successfully.

--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLSetGenuineInformation(
    __in                        CONST SLID*                 pAppId,
    __in                        PCWSTR                      pwszValueName,
    __in                        SLDATATYPE                  eDataType,
    __in_opt                    UINT                        cbValue,
    __in_bcount_opt(cbValue)    CONST BYTE*                 pbValue
    );
/*++
Routine Description:

    This function sets genuine information.

Arguments:

    pAppId
        Application Id. E.g. Windows AppId
        
    pwszValueName
        The name of value.
        TBD
                                                
    eType
        See SLDATATYPE
        
    cbValue
        Size of value
    
    pbValue
        Value.
        Some properties allows NULL pointer, which can be used to delete
        the property but some properties can't.

Return Value:

    HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW)
        The size of value is over expected size
    E_ACCESSDENIED
        Admin privilege required
    E_INVALIDARG
        Some property does not allow NULL value
    SL_E_NOT_SUPPORTED
        The name of value is not supported
    SL_E_DEPENDENT_PROPERTY_NOT_SET    
        If entry has been set
    SL_E_DATATYPE_MISMATCHED
        The type of data is mismatched with the expected type 
        of specified value name
--*/

__control_entrypoint(DllExport)
HRESULT
WINAPI
SLGetGenuineInformation(
    __in                        CONST SLID*                 pAppId,
    __in                        PCWSTR                      pwszValueName,
    __out_opt                   SLDATATYPE*                 peDataType,
    __out                       UINT*                       pcbValue,
    __deref_out_bcount(*pcbValue) BYTE**                    ppbValue
    );
/*++
Routine Description:

    This function gets genuine information.

Arguments:

    hSLC
        Handle to current SLC session.

    pAppId
        Application ID. E.g. Windows AppId
        
    pwszValueName
        See SLSetOfflineGenuineInformation
        
    eType
        See SLDATATYPE
        
    cbValue
        Size of value
        
    pbValue
        Value

Return Value:

    SL_E_NOT_SUPPORTED
        The name of value is not supported

    SL_E_VALUE_NOT_FOUND
        The specified value can not be found    

--*/                


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Snmp.h ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    snmp.h

Abstract:

    Definitions for SNMP development.

--*/

#ifndef _INC_SNMP
#define _INC_SNMP

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Additional Header Files                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Type Definitions                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <pshpack4.h>

typedef struct {
    BYTE * stream;
    UINT   length;
    BOOL   dynamic;
} AsnOctetString;

typedef struct {
    UINT   idLength;
    UINT * ids;
} AsnObjectIdentifier;

typedef LONG                    AsnInteger32;
typedef ULONG                   AsnUnsigned32;
typedef ULARGE_INTEGER          AsnCounter64;
typedef AsnUnsigned32           AsnCounter32;
typedef AsnUnsigned32           AsnGauge32;
typedef AsnUnsigned32           AsnTimeticks;
typedef AsnOctetString          AsnBits;
typedef AsnOctetString          AsnSequence;
typedef AsnOctetString          AsnImplicitSequence;
typedef AsnOctetString          AsnIPAddress;
typedef AsnOctetString          AsnNetworkAddress;
typedef AsnOctetString          AsnDisplayString;
typedef AsnOctetString          AsnOpaque;

typedef struct {
    BYTE asnType;
    union {
        AsnInteger32            number;     // ASN_INTEGER
                                            // ASN_INTEGER32
        AsnUnsigned32           unsigned32; // ASN_UNSIGNED32
        AsnCounter64            counter64;  // ASN_COUNTER64
        AsnOctetString          string;     // ASN_OCTETSTRING
        AsnBits                 bits;       // ASN_BITS
        AsnObjectIdentifier     object;     // ASN_OBJECTIDENTIFIER
        AsnSequence             sequence;   // ASN_SEQUENCE
        AsnIPAddress            address;    // ASN_IPADDRESS
        AsnCounter32            counter;    // ASN_COUNTER32
        AsnGauge32              gauge;      // ASN_GAUGE32
        AsnTimeticks            ticks;      // ASN_TIMETICKS
        AsnOpaque               arbitrary;  // ASN_OPAQUE
    } asnValue;
} AsnAny;

typedef AsnObjectIdentifier     AsnObjectName;
typedef AsnAny                  AsnObjectSyntax;

typedef struct {
    AsnObjectName    name;
    AsnObjectSyntax  value;
} SnmpVarBind;

typedef struct {
    SnmpVarBind * list;
    UINT          len;
} SnmpVarBindList;

#include <poppack.h>

#ifndef _INC_WINSNMP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ASN/BER Base Types                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_UNIVERSAL                   0x00
#define ASN_APPLICATION                 0x40
#define ASN_CONTEXT                     0x80
#define ASN_PRIVATE                     0xC0

#define ASN_PRIMITIVE                   0x00
#define ASN_CONSTRUCTOR                 0x20

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// PDU Type Values                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_PDU_GET                (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
#define SNMP_PDU_GETNEXT            (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
#define SNMP_PDU_RESPONSE           (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
#define SNMP_PDU_SET                (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
#define SNMP_PDU_V1TRAP             (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)
#define SNMP_PDU_GETBULK            (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
#define SNMP_PDU_INFORM             (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
#define SNMP_PDU_TRAP               (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)

#endif // _INC_WINSNMP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Simple Syntax Values                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_INTEGER                 (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x02)
#define ASN_BITS                    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x03)
#define ASN_OCTETSTRING             (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x04)
#define ASN_NULL                    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x05)
#define ASN_OBJECTIDENTIFIER        (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x06)
#define ASN_INTEGER32               ASN_INTEGER

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Constructor Syntax Values                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_SEQUENCE                (ASN_UNIVERSAL | ASN_CONSTRUCTOR | 0x10)
#define ASN_SEQUENCEOF              ASN_SEQUENCE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Application Syntax Values                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_IPADDRESS               (ASN_APPLICATION | ASN_PRIMITIVE | 0x00)
#define ASN_COUNTER32               (ASN_APPLICATION | ASN_PRIMITIVE | 0x01)
#define ASN_GAUGE32                 (ASN_APPLICATION | ASN_PRIMITIVE | 0x02)
#define ASN_TIMETICKS               (ASN_APPLICATION | ASN_PRIMITIVE | 0x03)
#define ASN_OPAQUE                  (ASN_APPLICATION | ASN_PRIMITIVE | 0x04)
#define ASN_COUNTER64               (ASN_APPLICATION | ASN_PRIMITIVE | 0x06)
#define ASN_UINTEGER32              (ASN_APPLICATION | ASN_PRIMITIVE | 0x07)
#define ASN_RFC2578_UNSIGNED32      ASN_GAUGE32

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Exception Conditions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_EXCEPTION_NOSUCHOBJECT     (ASN_CONTEXT | ASN_PRIMITIVE | 0x00)
#define SNMP_EXCEPTION_NOSUCHINSTANCE   (ASN_CONTEXT | ASN_PRIMITIVE | 0x01)
#define SNMP_EXCEPTION_ENDOFMIBVIEW     (ASN_CONTEXT | ASN_PRIMITIVE | 0x02)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Request Types (used in SnmpExtensionQueryEx)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_EXTENSION_GET          SNMP_PDU_GET
#define SNMP_EXTENSION_GET_NEXT     SNMP_PDU_GETNEXT
#define SNMP_EXTENSION_GET_BULK     SNMP_PDU_GETBULK
#define SNMP_EXTENSION_SET_TEST     (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)
#define SNMP_EXTENSION_SET_COMMIT   SNMP_PDU_SET
#define SNMP_EXTENSION_SET_UNDO     (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x1)
#define SNMP_EXTENSION_SET_CLEANUP  (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x2)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Error Codes                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_ERRORSTATUS_NOERROR                0
#define SNMP_ERRORSTATUS_TOOBIG                 1
#define SNMP_ERRORSTATUS_NOSUCHNAME             2
#define SNMP_ERRORSTATUS_BADVALUE               3
#define SNMP_ERRORSTATUS_READONLY               4
#define SNMP_ERRORSTATUS_GENERR                 5
#define SNMP_ERRORSTATUS_NOACCESS               6
#define SNMP_ERRORSTATUS_WRONGTYPE              7
#define SNMP_ERRORSTATUS_WRONGLENGTH            8
#define SNMP_ERRORSTATUS_WRONGENCODING          9
#define SNMP_ERRORSTATUS_WRONGVALUE             10
#define SNMP_ERRORSTATUS_NOCREATION             11
#define SNMP_ERRORSTATUS_INCONSISTENTVALUE      12
#define SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE    13
#define SNMP_ERRORSTATUS_COMMITFAILED           14
#define SNMP_ERRORSTATUS_UNDOFAILED             15
#define SNMP_ERRORSTATUS_AUTHORIZATIONERROR     16
#define SNMP_ERRORSTATUS_NOTWRITABLE            17
#define SNMP_ERRORSTATUS_INCONSISTENTNAME       18

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMPv1 Trap Types                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_GENERICTRAP_COLDSTART              0
#define SNMP_GENERICTRAP_WARMSTART              1
#define SNMP_GENERICTRAP_LINKDOWN               2
#define SNMP_GENERICTRAP_LINKUP                 3
#define SNMP_GENERICTRAP_AUTHFAILURE            4
#define SNMP_GENERICTRAP_EGPNEIGHLOSS           5
#define SNMP_GENERICTRAP_ENTERSPECIFIC          6

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Access Types                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_ACCESS_NONE                        0
#define SNMP_ACCESS_NOTIFY                      1
#define SNMP_ACCESS_READ_ONLY                   2
#define SNMP_ACCESS_READ_WRITE                  3
#define SNMP_ACCESS_READ_CREATE                 4

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP API Return Code Definitions                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMPAPI                                 INT
#define SNMP_FUNC_TYPE                          WINAPI

#define SNMPAPI_NOERROR                         TRUE
#define SNMPAPI_ERROR                           FALSE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Extension API Prototypes                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
SNMP_FUNC_TYPE
SnmpExtensionInit(
    DWORD                 dwUptimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionInitEx(
    AsnObjectIdentifier * pNextSupportedRegion
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionMonitor(
    LPVOID            pAgentMgmtData
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionQuery(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionQueryEx(
    UINT              nRequestType,
    UINT              nTransactionId,
    SnmpVarBindList * pVarBindList,
    AsnOctetString *  pContextInfo,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

BOOL
SNMP_FUNC_TYPE
SnmpExtensionTrap(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32 *        pGenericTrapId,
    AsnInteger32 *        pSpecificTrapId,
    AsnTimeticks *        pTimeStamp,
    SnmpVarBindList *     pVarBindList
    );

VOID
SNMP_FUNC_TYPE
SnmpExtensionClose(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Extension API Type Definitions                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONINIT)(
    DWORD                 dwUpTimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONINITEX)(
    AsnObjectIdentifier * pNextSupportedRegion
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONMONITOR)(
    LPVOID            pAgentMgmtData
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONQUERY)(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONQUERYEX)(
    UINT              nRequestType,
    UINT              nTransactionId,
    SnmpVarBindList * pVarBindList,
    AsnOctetString *  pContextInfo,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    );

typedef BOOL (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONTRAP)(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32 *        pGenericTrapId,
    AsnInteger32 *        pSpecificTrapId,
    AsnTimeticks *        pTimeStamp,
    SnmpVarBindList *     pVarBindList
    );

typedef VOID (SNMP_FUNC_TYPE * PFNSNMPEXTENSIONCLOSE)(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP API Prototypes                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidCpy(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidAppend(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidNCmp(
    AsnObjectIdentifier * pOid1,
    AsnObjectIdentifier * pOid2,
    UINT                  nSubIds
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOidCmp(
    AsnObjectIdentifier * pOid1,
    AsnObjectIdentifier * pOid2
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilOidFree(
    AsnObjectIdentifier * pOid
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCmp(
    AsnOctetString * pOctets1,
    AsnOctetString * pOctets2
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsNCmp(
    AsnOctetString * pOctets1,
    AsnOctetString * pOctets2,
    UINT             nChars
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCpy(
    AsnOctetString * pOctetsDst,
    AsnOctetString * pOctetsSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilOctetsFree(
    AsnOctetString * pOctets
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilAsnAnyCpy(
    AsnAny * pAnyDst,
    AsnAny * pAnySrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilAsnAnyFree(
    AsnAny * pAny
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilVarBindCpy(
    SnmpVarBind * pVbDst,
    SnmpVarBind * pVbSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilVarBindFree(
    SnmpVarBind * pVb
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilVarBindListCpy(
    SnmpVarBindList * pVblDst,
    SnmpVarBindList * pVblSrc
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilVarBindListFree(
    SnmpVarBindList * pVbl
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilMemFree(
    LPVOID pMem
    );

LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemAlloc(
    UINT nBytes
    );

LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemReAlloc(
    LPVOID pMem,
    UINT   nBytes
    );

LPSTR
SNMP_FUNC_TYPE
SnmpUtilOidToA(
    IN AsnObjectIdentifier *Oid
    );

LPSTR
SNMP_FUNC_TYPE
SnmpUtilIdsToA(
    IN UINT *Ids,
    IN UINT IdLength
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilPrintOid(
    IN AsnObjectIdentifier *Oid
    );

VOID
SNMP_FUNC_TYPE
SnmpUtilPrintAsnAny(
    AsnAny * pAny
    );

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptime(
    );

VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogLevel(
    INT nLogLevel
    );

VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogType(
    INT nLogType
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Debugging Definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOG_SILENT                 0x0
#define SNMP_LOG_FATAL                  0x1
#define SNMP_LOG_ERROR                  0x2
#define SNMP_LOG_WARNING                0x3
#define SNMP_LOG_TRACE                  0x4
#define SNMP_LOG_VERBOSE                0x5

#define SNMP_OUTPUT_TO_CONSOLE          0x1
#define SNMP_OUTPUT_TO_LOGFILE          0x2
#define SNMP_OUTPUT_TO_EVENTLOG         0x4  // no longer supported
#define SNMP_OUTPUT_TO_DEBUGGER         0x8

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP Debugging Prototypes                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
SnmpUtilDbgPrint(
    IN INT nLogLevel,   // see log levels above...
    __in __format_string LPSTR szFormat,
    IN ...
    );

#if DBG
#define SNMPDBG(_x_)                    SnmpUtilDbgPrint _x_
#else
#define SNMPDBG(_x_)
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFINE_SIZEOF(Array)        (sizeof(Array)/sizeof((Array)[0]))
#define DEFINE_OID(SubIdArray)      {DEFINE_SIZEOF(SubIdArray),(SubIdArray)}
#define DEFINE_NULLOID()            {0,NULL}
#define DEFINE_NULLOCTETS()         {NULL,0,FALSE}

#define DEFAULT_SNMP_PORT_UDP       161
#define DEFAULT_SNMP_PORT_IPX       36879
#define DEFAULT_SNMPTRAP_PORT_UDP   162
#define DEFAULT_SNMPTRAP_PORT_IPX   36880

#define SNMP_MAX_OID_LEN            128

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// API Error Code Definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_MEM_ALLOC_ERROR            1
#define SNMP_BERAPI_INVALID_LENGTH      10
#define SNMP_BERAPI_INVALID_TAG         11
#define SNMP_BERAPI_OVERFLOW            12
#define SNMP_BERAPI_SHORT_BUFFER        13
#define SNMP_BERAPI_INVALID_OBJELEM     14
#define SNMP_PDUAPI_UNRECOGNIZED_PDU    20
#define SNMP_PDUAPI_INVALID_ES          21
#define SNMP_PDUAPI_INVALID_GT          22
#define SNMP_AUTHAPI_INVALID_VERSION    30
#define SNMP_AUTHAPI_INVALID_MSG_TYPE   31
#define SNMP_AUTHAPI_TRIV_AUTH_FAILED   32

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Support for old definitions (support disabled via SNMPSTRICT)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef SNMPSTRICT

#define SNMP_oidcpy                     SnmpUtilOidCpy
#define SNMP_oidappend                  SnmpUtilOidAppend
#define SNMP_oidncmp                    SnmpUtilOidNCmp
#define SNMP_oidcmp                     SnmpUtilOidCmp
#define SNMP_oidfree                    SnmpUtilOidFree

#define SNMP_CopyVarBindList            SnmpUtilVarBindListCpy
#define SNMP_FreeVarBindList            SnmpUtilVarBindListFree
#define SNMP_CopyVarBind                SnmpUtilVarBindCpy
#define SNMP_FreeVarBind                SnmpUtilVarBindFree

#define SNMP_printany                   SnmpUtilPrintAsnAny

#define SNMP_free                       SnmpUtilMemFree
#define SNMP_malloc                     SnmpUtilMemAlloc
#define SNMP_realloc                    SnmpUtilMemReAlloc

#define SNMP_DBG_free                   SnmpUtilMemFree
#define SNMP_DBG_malloc                 SnmpUtilMemAlloc
#define SNMP_DBG_realloc                SnmpUtilMemReAlloc

#define ASN_RFC1155_IPADDRESS           ASN_IPADDRESS
#define ASN_RFC1155_COUNTER             ASN_COUNTER32
#define ASN_RFC1155_GAUGE               ASN_GAUGE32
#define ASN_RFC1155_TIMETICKS           ASN_TIMETICKS
#define ASN_RFC1155_OPAQUE              ASN_OPAQUE
#define ASN_RFC1213_DISPSTRING          ASN_OCTETSTRING

#define ASN_RFC1157_GETREQUEST          SNMP_PDU_GET
#define ASN_RFC1157_GETNEXTREQUEST      SNMP_PDU_GETNEXT
#define ASN_RFC1157_GETRESPONSE         SNMP_PDU_RESPONSE
#define ASN_RFC1157_SETREQUEST          SNMP_PDU_SET
#define ASN_RFC1157_TRAP                SNMP_PDU_V1TRAP

#define ASN_CONTEXTSPECIFIC             ASN_CONTEXT
#define ASN_PRIMATIVE                   ASN_PRIMITIVE

#define RFC1157VarBindList              SnmpVarBindList
#define RFC1157VarBind                  SnmpVarBind
#define AsnInteger                      AsnInteger32
#define AsnCounter                      AsnCounter32
#define AsnGauge                        AsnGauge32
#define ASN_UNSIGNED32                  ASN_UINTEGER32

#endif // SNMPSTRICT

#ifdef __cplusplus
}
#endif

#endif // _INC_SNMP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\spcollec.h ===
/*****************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPCollec.h *
*------------*
*       This header file contains the SAPI5 collection class templates. These
*   are a modified version of the MFC template classes without the dependencies.
*-----------------------------------------------------------------------------
*****************************************************************************/
#ifndef SPCollec_h
#define SPCollec_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#include <intsafe.h>

#pragma once

/////////////////////////////////////////////////////////////////////////////
#define SPASSERT_VALID( a )             // This doesn't do anything right now

typedef void* SPLISTPOS;
typedef DWORD SPLISTHANDLE;

#define SP_BEFORE_START_POSITION ((void*)-1L)

inline BOOL SPIsValidAddress(const void* lp, UINT /* nBytes */, BOOL /* bReadWrite */)
{
    return (lp != NULL);
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

inline HRESULT SPConstructElementsVoid (void *pElements, size_t sizeof_TYPE, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( nCount == 0 ||
             SPIsValidAddress( pElements, nCount * (UINT) sizeof_TYPE, TRUE ) );

    // default is bit-wise zero initialization
    memset(pElements, 0, nCount * sizeof_TYPE);
    return hr;
}

template<class TYPE>
inline HRESULT SPConstructElements(TYPE* pElements, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( nCount == 0 ||
             SPIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
    return hr;
}

inline void SPDestructElementsVoid(void* pElements, size_t sizeof_TYPE, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pElements, nCount * (UINT) sizeof_TYPE, TRUE  ) ) );
    pElements;  // not used
    nCount; // not used
    sizeof_TYPE; // not used

    // default does nothing
}

template<class TYPE>
inline void SPDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

inline HRESULT SPCopyElementsVoid(void* pDest, const void* pSrc, size_t sizeof_TYPE, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pDest, nCount * (UINT) sizeof_TYPE, TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pSrc, nCount * (UINT) sizeof_TYPE, FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof_TYPE);
    return hr;
}

template<class TYPE>
inline HRESULT SPCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    HRESULT hr = S_OK;
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
    return hr;
}

template<class TYPE, class ARG_TYPE>
BOOL SPCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( SPIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( SPIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT SPHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(DWORD_PTR)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CSPPlex

struct CSPPlex    // warning variable length structure
{
    CSPPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CSPPlex* PASCAL Create( CSPPlex*& pHead, UINT nMax, UINT cbElement )
    {
	CSPPlex* p = NULL;
	UINT cbSize;
	if (SUCCEEDED(UIntMult(nMax, cbElement, &cbSize)) && SUCCEEDED(UIntAdd(cbSize, sizeof(CSPPlex), &cbSize)))
	{
	    p = (CSPPlex*) new BYTE[cbSize];
	}
        if (p != NULL)
        {
            p->nMax = nMax;
            p->nCur = 0;
            p->pNext = pHead;
            pHead = p;  // change head (adds in reverse order for simplicity)
        }
        return p;
    }

    void FreeDataChain()
    {
        CSPPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CSPPlex* pNext = p->pNext;
            delete[] bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE>

class CSPArrayVoid // non-template base worked class for template CSPArray
{
public:
// Construction
    CSPArrayVoid();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    HRESULT SetSize(int nNewSize, int nGrowBy = -1);

    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Operations that move elements around
    void    RemoveAt(int nIndex, int nCount = 1);
    void    Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    void*  m_pData;          // the actual array of data
    int    m_nSize;          // # of elements (upperBound - 1)
    int    m_nMaxSize;       // max allocated
    int    m_nGrowBy;        // grow amount
    size_t m_sizeofTYPE;     // size of TYPE in template class
    
public:
    ~CSPArrayVoid();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPArrayVoid implementation

inline int CSPArrayVoid::GetSize() const
    { return m_nSize; }
inline int CSPArrayVoid::GetUpperBound() const
    { return m_nSize-1; }
inline void CSPArrayVoid::RemoveAll()
    { SetSize(0, -1); }

inline CSPArrayVoid::CSPArrayVoid()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

inline CSPArrayVoid::~CSPArrayVoid()
{
    SPASSERT_VALID( this );

    if (m_pData != NULL)
    {
        SPDestructElementsVoid(m_pData, m_sizeofTYPE, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

inline HRESULT CSPArrayVoid::SetSize(int nNewSize, int nGrowBy)
{
    SPASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );
    HRESULT hr = S_OK;

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            SPDestructElementsVoid(m_pData, m_sizeofTYPE, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( (UINT)nNewSize <= SIZE_T_MAX/m_sizeofTYPE );    // no overflow
#endif
        m_pData = (void *)new BYTE[nNewSize * m_sizeofTYPE];
        if( m_pData )
        {
            hr = SPConstructElementsVoid(m_pData, m_sizeofTYPE, nNewSize);
            if( SUCCEEDED( hr ) )
            {
                m_nSize = m_nMaxSize = nNewSize;
            }
            else
            {
                delete[] (BYTE*)m_pData;
                m_pData = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            hr = SPConstructElementsVoid((BYTE *)m_pData+m_nSize*m_sizeofTYPE, m_sizeofTYPE, nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            SPDestructElementsVoid((BYTE *)m_pData+nNewSize*m_sizeofTYPE, m_sizeofTYPE, m_nSize-nNewSize);
        }

        if( SUCCEEDED( hr ) )
        {
            m_nSize = nNewSize;
        }
    }
    else
    {
        // otherwise, grow array
        nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( (UINT)nNewMax <= SIZE_T_MAX/m_sizeofTYPE ); // no overflow
#endif
        void* pNewData = (void *)new BYTE[nNewMax * m_sizeofTYPE];

        if( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * m_sizeofTYPE);

            // construct remaining elements
            _ASSERT( nNewSize > m_nSize );
            hr = SPConstructElementsVoid((BYTE *)pNewData+m_nSize*m_sizeofTYPE, m_sizeofTYPE, nNewSize-m_nSize);

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

inline void CSPArrayVoid::FreeExtra()
{
    SPASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( (UINT)m_nSize <= SIZE_T_MAX/m_sizeofTYPE); // no overflow
#endif
        void* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData =  (void *)new BYTE[m_nSize * m_sizeofTYPE];
            _ASSERT(pNewData);
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * m_sizeofTYPE);
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

inline void CSPArrayVoid::RemoveAt(int nIndex, int nCount)
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    SPDestructElementsVoid((BYTE *)m_pData + nIndex*m_sizeofTYPE, m_sizeofTYPE, nCount);
    if (nMoveCount)
        memcpy((BYTE *)m_pData + nIndex*m_sizeofTYPE, (BYTE *)m_pData + (nIndex + nCount)*m_sizeofTYPE,
            nMoveCount * m_sizeofTYPE);
    m_nSize -= nCount;
}

inline void CSPArrayVoid::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    SPASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, m_sizeofTYPE, compare );
}

#ifdef _DEBUG
inline void CSPArrayVoid::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( SPIsValidAddress(m_pData, m_nMaxSize * (UINT) m_sizeofTYPE, TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// now for the derived template class

template<class TYPE, class ARG_TYPE>
class CSPArray : public CSPArrayVoid
{
public:
// Construction
    CSPArray();

// Attributes
//    int GetSize() const;       // now in base class
//    int GetUpperBound() const; // now in base class

// Operations
    // Clean up
//    void FreeExtra();          // now in base class
//    void RemoveAll();          // now in base class

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    HRESULT SetAtGrow(int nIndex, ARG_TYPE newElement);

    // the helper method add will call SetAtGrow and return the original size of the array (essentially the index of the entry you just added)
    int Add(ARG_TYPE newElement);
    // AddHR is the same as Add except it returns a HRESULT instead of the new index. Essentially the same as SetAtGrow but without requiring the target index
    HRESULT AddHR(ARG_TYPE newElement);
    int Append(const CSPArray& src);
    HRESULT Copy(const CSPArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    HRESULT InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
//    void    RemoveAt(int nIndex, int nCount = 1); // now in base class
    HRESULT InsertAt(int nStartIndex, CSPArray* pNewArray);
//    void    Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 )); // now in base class

public:
    ~CSPArray() {};
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline TYPE CSPArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return ((TYPE *)m_pData)[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CSPArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        ((TYPE *)m_pData)[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return ((TYPE *)m_pData)[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CSPArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CSPArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CSPArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline HRESULT CSPArray<TYPE, ARG_TYPE>::AddHR(ARG_TYPE newElement)
    {   return SetAtGrow(m_nSize, newElement); }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
inline CSPArray<TYPE, ARG_TYPE>::CSPArray()
{
    m_sizeofTYPE = sizeof(TYPE);
}

template<class TYPE, class ARG_TYPE>
int CSPArray<TYPE, ARG_TYPE>::Append(const CSPArray& src)
{
    SPASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    HRESULT hr = SetSize(m_nSize + src.m_nSize);
    if( SUCCEEDED( hr ) )
    {
        hr = SPCopyElements((TYPE *)m_pData + nOldSize, (TYPE *)(src.m_pData), src.m_nSize);
    }
    return ( SUCCEEDED( hr ) )?(nOldSize):(-1);
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::Copy(const CSPArray& src)
{
    SPASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    HRESULT hr = SetSize(src.m_nSize);
    if( SUCCEEDED( hr ) )
    {
        hr = SPCopyElements((TYPE *)m_pData, (TYPE *)(src.m_pData), src.m_nSize);
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    HRESULT hr = S_OK;

    if (nIndex >= m_nSize)
    {
        hr = SetSize(nIndex+1, -1);
    }

    if( SUCCEEDED( hr ) )
    {
        ((TYPE *)m_pData)[nIndex] = newElement;
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed
    HRESULT hr = S_OK;

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        hr = SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        hr = SetSize(m_nSize + nCount, -1);  // grow it to new size
        if( SUCCEEDED( hr ) )
        {
            // shift old data up to fill gap
            memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
                (nOldSize-nIndex) * sizeof(TYPE));

            // re-init slots we copied from
            hr = SPConstructElements(&m_pData[nIndex], nCount);
        }
    }

    // insert new value in the gap
    if( SUCCEEDED( hr ) )
    {
        _ASSERT( nIndex + nCount <= m_nSize );
        while (nCount--)
            ((TYPE *)m_pData)[nIndex++] = newElement;
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CSPArray* pNewArray)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );
    HRESULT hr = S_OK;

    if (pNewArray->GetSize() > 0)
    {
        hr = InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; SUCCEEDED( hr )&& (i < pNewArray->GetSize()); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CSPList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CSPList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    SPLISTPOS AddHead(ARG_TYPE newElement);
    SPLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CSPList* pNewList);
    void AddTail(CSPList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    SPLISTPOS GetHeadPosition() const;
    SPLISTPOS GetTailPosition() const;
    TYPE& GetNext(SPLISTPOS& rPosition); // return *Position++
    TYPE GetNext(SPLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(SPLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(SPLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(SPLISTPOS position);
    TYPE GetAt(SPLISTPOS position) const;
    void SetAt(SPLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(SPLISTPOS position);

    // inserting before or after a given position
    SPLISTPOS InsertBefore(SPLISTPOS position, ARG_TYPE newElement);
    SPLISTPOS InsertAfter(SPLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    SPLISTPOS Find(ARG_TYPE searchValue, SPLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    SPLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CSPPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode* pPrev, CNode* pNext)
    {
        if (m_pNodeFree == NULL)
        {
            // add another block
            CSPPlex* pNewBlock = CSPPlex::Create(m_pBlocks, m_nBlockSize,sizeof(CNode));
            if (pNewBlock != NULL)
            {
                // chain them into free list
                CNode* pNode = (CNode*) pNewBlock->data();
                // free in reverse order to make it easier to debug
                pNode += m_nBlockSize - 1;
                for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
                {
                    pNode->pNext = m_pNodeFree;
                    m_pNodeFree = pNode;
                }
            }
        }

        CNode* pNode = m_pNodeFree;
        if( pNode )
        {
            if( SUCCEEDED( SPConstructElements(&pNode->data, 1) ) )
            {
                m_pNodeFree  = m_pNodeFree->pNext;
                pNode->pPrev = pPrev;
                pNode->pNext = pNext;
                m_nCount++;
                _ASSERT( m_nCount > 0 );  // make sure we don't overflow
            }
        }
        return pNode;
    }
    void FreeNode(CNode* pNode)
    {
        SPDestructElements(&pNode->data, 1);
        pNode->pNext = m_pNodeFree;
        m_pNodeFree = pNode;
        m_nCount--;
        _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
    }

public:
    ~CSPList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CSPList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CSPList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline SPLISTPOS CSPList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (SPLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline SPLISTPOS CSPList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (SPLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetNext(SPLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetNext(SPLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetPrev(SPLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetPrev(SPLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetAt(SPLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetAt(SPLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CSPList<TYPE, ARG_TYPE>::SetAt(SPLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::CSPList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::RemoveAll()
{
    SPASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        SPDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    
    if (m_pBlocks != NULL)
    {
        m_pBlocks->FreeDataChain();
        m_pBlocks = NULL;
    }
}

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::~CSPList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CSPPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CSPPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CSPPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    if( pNewNode )
    {
        pNewNode->data = newElement;
        if (m_pNodeHead != NULL)
            m_pNodeHead->pPrev = pNewNode;
        else
            m_pNodeTail = pNewNode;
        m_pNodeHead = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    if( pNewNode )
    {
        pNewNode->data = newElement;
        if (m_pNodeTail != NULL)
            m_pNodeTail->pNext = pNewNode;
        else
            m_pNodeHead = pNewNode;
        m_pNodeTail = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AddHead(CSPList* pNewList)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    SPLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AddTail(CSPList* pNewList)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewList );

    // add a list of same elements
    SPLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CSPList<TYPE, ARG_TYPE>::RemoveHead()
{
    SPASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( SPIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CSPList<TYPE, ARG_TYPE>::RemoveTail()
{
    SPASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( SPIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::InsertBefore(SPLISTPOS position, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    if( pNewNode )
    {
        pNewNode->data = newElement;

        if (pOldNode->pPrev != NULL)
        {
            _ASSERT( SPIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
            pOldNode->pPrev->pNext = pNewNode;
        }
        else
        {
            _ASSERT( pOldNode == m_pNodeHead );
            m_pNodeHead = pNewNode;
        }
        pOldNode->pPrev = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::InsertAfter(SPLISTPOS position, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( SPIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    if( pNewNode )
    {
        pNewNode->data = newElement;

        if (pOldNode->pNext != NULL)
        {
            _ASSERT( SPIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
            pOldNode->pNext->pPrev = pNewNode;
        }
        else
        {
            _ASSERT( pOldNode == m_pNodeTail );
            m_pNodeTail = pNewNode;
        }
        pOldNode->pNext = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::RemoveAt(SPLISTPOS position)
{
    SPASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( SPIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( SPIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( SPIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    SPASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (SPLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, SPLISTPOS startAfter) const
{
    SPASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (SPCompareElements(&pNode->data, &searchValue))
            return (SPLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( SPIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( SPIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG


#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\spddkhlp.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPDDKHLP.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*
*
*******************************************************************************/
#ifndef SPDDKHLP_h
#define SPDDKHLP_h

#include <tchar.h>

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#include <sapiddk.h>

//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))

#define SP_IS_BAD_WRITE_PTR(p)     ( !(p) || SPIsBadWritePtr( p, sizeof(*(p)) ))
#define SP_IS_BAD_READ_PTR(p)      ( !(p) || SPIsBadReadPtr(  p, sizeof(*(p)) ))
#define SP_IS_BAD_CODE_PTR(p)      ( (FARPROC)(p) == 0 )
#define SP_IS_BAD_INTERFACE_PTR(p) ( SPIsBadInterfacePtr( (p) )  )
#define SP_IS_BAD_VARIANT_PTR(p)   ( SPIsBadVARIANTPtr( (p) ) )
#define SP_IS_BAD_STRING_PTR(p)    ( SPIsBadStringPtr( (p) ) )

#define SP_IS_BAD_OPTIONAL_WRITE_PTR(p)     ((p) && SPIsBadWritePtr( p, sizeof(*(p)) ))
#define SP_IS_BAD_OPTIONAL_READ_PTR(p)      ((p) && SPIsBadReadPtr(  p, sizeof(*(p)) ))
#define SP_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && SPIsBadInterfacePtr(p))
#define SP_IS_BAD_OPTIONAL_STRING_PTR(p)    ((p) && SPIsBadStringPtr(p))

#define SP_IS_BAD_READ_ARRAY(p,cElements)     ( SPIsBadReadArray( p, cElements, sizeof(*p) ) )
#define SP_IS_BAD_WRITE_ARRAY(p,cElements)     ( SPIsBadWriteArray( p, cElements, sizeof(*p) ) )

#define SP_DOES_PTR_ADDITION_WRAP(p)    ( SPDoesPtrAdditionWrap( p, sizeof(*p) ) )
#define SP_IS_PTR_OUT_OF_BOUNDS(p,pBound)    ( SPIsPtrOutOfBounds( p, sizeof(*p), pBound ) )

#define sp_sgn(x) ( (x) == 0 ? 0 : ( (x)>0 ? 1 : -1 ) )

//=== Class, Enum, Struct, Template, and Union Declarations ==================

//=== Inlines ================================================================

/*** Pointer validation functions
*/

inline BOOL SPIsBadStringPtr( const WCHAR * psz, ULONG cMaxChars = 0xFFFFF )
{
    return ((psz == NULL) || (wcslen(psz) + 1 > cMaxChars));
}

inline BOOL SPIsBadReadPtr( __in_bcount(Size) const void* pMem, size_t Size )
{
    return (pMem == NULL) && (Size != 0);
}

inline BOOL SPIsBadWritePtr( __in_bcount(Size) void* pMem, size_t Size )
{
    return (pMem == NULL) && (Size != 0);
}

inline BOOL SPIsBadInterfacePtr( const IUnknown* pUnknown )
{
    return (pUnknown == NULL);
}

inline BOOL SPIsBadVARIANTPtr( const VARIANT* pVar )
{
    return (pVar == NULL);
}

inline BOOL SPDoesPtrAdditionWrap( __in_bcount(Size) const void* pMem, size_t Size )
{
    return ((const BYTE*)pMem + Size) < (const BYTE*)pMem;
}

inline BOOL SPIsBadReadArray( const void* pMem, ULONG cElementCount, size_t cBytesPerElement)
{
    size_t cByteCount = cBytesPerElement * cElementCount;

    if ( // Does the multiplication operation overflow?
         ( ( cByteCount / cBytesPerElement ) != cElementCount ) ||
         // Does the pointer addition wrap?
         ( SPDoesPtrAdditionWrap ( pMem, cByteCount ) ) ||
         // Can we read from the pointer?
         ( SPIsBadReadPtr ( pMem, cByteCount ) ) )
    {
        // One of the preconditions didn't hold.
        // YES, this IS a BAD Read array.
        return TRUE;
    }
    else
    {
        // NO, this is NOT a BAD Read array.
        return FALSE;
    }
}

inline BOOL SPIsBadWriteArray( void* pMem, ULONG cElementCount, size_t cBytesPerElement)
{
    size_t cByteCount = cBytesPerElement * cElementCount;

    if ( // Did the multiplication operation overflow?
         ( ( cByteCount / cBytesPerElement ) != cElementCount ) ||
         // Does the pointer addition wrap?
         ( SPDoesPtrAdditionWrap ( pMem, cByteCount ) ) ||
         // Can we write to this pointer?
         ( SPIsBadWritePtr ( pMem, cByteCount ) ) )
    {
        // One of the preconditions didn't hold.
        // YES, this IS a BAD Write array.
        return TRUE;
    }
    else
    {
        // NO, this is NOT a BAD Write array.
        return FALSE;
    }
}

/************************************************************************
* SPIsPtrOutOfBounds     *
* -------------------------------*
* Description:
*   Ensures that ( n_pStart + n_cBytes ) doesn't wrap/overflow, and
*   doesn't scroll up to or past n_pBound. 
*
*   Returns:
*   FALSE               Memory block is in bounds
*   TRUE                Pointer arithmetic overflow, or
*                         ( n_pStart + n_cBytes ) >= n_pBound
*   
************************************************************** mishav ***/
inline BOOL SPIsPtrOutOfBounds(__in_bcount(n_cBytes) const void* n_pStart,
                                  size_t n_cBytes, 
                                  const void* n_pBound)
{
    const void* pEnd = (const BYTE*)n_pStart + n_cBytes;

    // In order to be valid, the pointers MUST be arranged
    // in the following order:
    // n_pStart <= pEnd < n_pBound.

    if ( ( n_pStart <= pEnd ) &&
         ( pEnd <= n_pBound) )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


inline BOOL SPIsArrayOutOfBounds(const void* n_pStart,
                                 ULONG n_cElements,
                                 size_t n_cBytesPerElement,
                                 const void* n_pBound)
{
    // Perform and check the multiplication
    size_t cBytesTotal = n_cElements * n_cBytesPerElement;
    if ( ( cBytesTotal / n_cElements ) != n_cBytesPerElement )
    {
        return FALSE;
    }
    else
    {
        return SPIsPtrOutOfBounds(n_pStart, cBytesTotal, n_pBound);
    }
}

inline BOOL SPIsStringOutOfBounds(const WCHAR* n_pwcszString,
                                  const void* n_pBound = NULL,
                                  const void* n_pLowerBound = NULL)
{
    BOOL br = FALSE;
    
    const WCHAR* pwcszBound = (const WCHAR*)n_pBound;
    const WCHAR* pwcszLowerBound = (const WCHAR*)n_pLowerBound;

    // Pointers must be in the following order: 
    // Lower bound, String, Upper bound
    if ( (pwcszLowerBound && (pwcszLowerBound > n_pwcszString) ) ||
         (pwcszBound && (n_pwcszString >= pwcszBound) ) ||
         SP_IS_BAD_STRING_PTR(n_pwcszString) )
    {
        br = TRUE;
    }
    else if (pwcszBound)
    {
        const size_t cStrMaxLen = pwcszBound - n_pwcszString;
        const size_t cStrActualLen = wcslen(n_pwcszString);

        if (cStrActualLen > cStrMaxLen)
        {
            br = TRUE;
        }
    }
    else
    {
        br = FALSE;
    }

    return br;
}

/************************************************************
* SpSafePtrAdd   *
*----------------*
* Description:
*   Advances the n_ppBase pointer by n_cBytes bytes.
* Returns E_INVALIDARG on pointer wraparound or if
* the pointer exceeds the bound (presuming the bound
* is specified).
******************************************* mishav *********/

template <class _C>
inline HRESULT SpSafePtrAdd (_C** n_ppBase, size_t n_cBytes, const void* n_pBound = NULL)
{
    HRESULT hr = S_OK;

    // Perform the addition
    const BYTE* pByteCast = (const BYTE*)(*n_ppBase);
    const BYTE* pByteAdded = pByteCast + n_cBytes;

    // Check for wrapping
    // Check for a bound having been specified, and make sure it doesn't exceed it.
    if ( (pByteAdded < pByteCast) ||
         (n_pBound!=NULL && pByteAdded>n_pBound) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *n_ppBase = (_C*)(pByteAdded);    
    }

    return hr;
}

/************************************************************
* SpSafePtrMultiplyAdd   *
*---------------------*
* Description:
*   Advances the n_ppBase pointer by (n_cElements * n_cBytesPerElement) bytes.
* Returns E_INVALIDARG on pointer wraparound or if
* the pointer exceeds the bound (presuming the bound
* is specified).
******************************************* mishav *********/

template <class _C>
inline HRESULT SpSafePtrMultiplyAdd (_C** n_ppBase, 
                                     ULONG n_cElements,
                                     size_t n_cBytesPerElement, 
                                     const void* n_pBound = NULL)
{
    HRESULT hr = S_OK;

    // Perform and check the multiplication
    ULONG cBytesTotal = n_cElements * n_cBytesPerElement;
    if ( ( cBytesTotal / n_cElements ) != n_cBytesPerElement )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SpSafePtrAdd(n_ppBase, cBytesTotal, n_pBound);
    }

    return hr;
}




#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

//
//  Helper functions can be used to implement GetObjectToken/SetObjectToken for objects that 
//  support ISpObjectWithToken
//
inline HRESULT SpGenericSetObjectToken(ISpObjectToken * pCallersToken, CComPtr<ISpObjectToken> & cpObjToken)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_INTERFACE_PTR(pCallersToken))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (cpObjToken)
        {
            hr = SPERR_ALREADY_INITIALIZED;
        }
        else
        {
            cpObjToken = pCallersToken;
        }
    }
    return hr;
}


inline HRESULT SpGenericGetObjectToken(ISpObjectToken ** ppCallersToken, CComPtr<ISpObjectToken> & cpObjToken)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(ppCallersToken))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppCallersToken = cpObjToken;
        if (*ppCallersToken)
        {
            (*ppCallersToken)->AddRef();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

#endif  // __ATLCOM_H__


//
//  Helper class for SPSTATEINFO sturcture automatically initializes and cleans up
//  the structure + provides a few helper functions.
//
class CSpStateInfo : public SPSTATEINFO
{
public:
    CSpStateInfo()
    {
        cAllocatedEntries = NULL;
        pTransitions = NULL;
    }
    ~CSpStateInfo()
    {
        ::CoTaskMemFree(pTransitions);
    }
    SPTRANSITIONENTRY * FirstEpsilon()
    {
        return pTransitions;
    }
    SPTRANSITIONENTRY * FirstRule()
    {
        return pTransitions + cEpsilons;
    }
    SPTRANSITIONENTRY * FirstWord()
    {
        return pTransitions + cEpsilons + cRules;
    }
    SPTRANSITIONENTRY * FirstSpecialTransition()
    {
        return pTransitions + cEpsilons + cRules + cWords;
    }
};


//
//  This basic queue implementation can be used to maintin linked lists of classes.  The class T
//  must contain the member m_pNext which is used by this template to point to the next element.
//  If the bPurgeWhenDeleted is TRUE then all of the elements in the queue will be deleted
//  when the queue is deleted, otherwise they will not.
//  If bMaintainCount is TRUE then a running count will be maintained, and GetCount() will be
//  efficent.  If it is FALSE then a running count will not be maintained, and GetCount() will
//  be an order N operation.  If you do not require a count, then 
//

template <class T, BOOL bPurgeWhenDeleted> class CSpBasicList;

template <class T, BOOL bPurgeWhenDeleted = TRUE, BOOL bMaintainCount = FALSE>
class CSpBasicQueue
{
public:
    T     * m_pHead;
    T     * m_pTail;
    ULONG   m_cElements;    // Warning!  Use GetCount() -- Not maintained if bMaintainCount is FALSE.

    CSpBasicQueue() 
    {
        m_pHead = NULL;
        if (bMaintainCount)
        {
            m_cElements = 0;
        }
    }

    ~CSpBasicQueue()
    {
        if (bPurgeWhenDeleted)
        {
            Purge();
        }
    }

    HRESULT CreateNode(T ** ppNode)
    {
        *ppNode = new T;
        if (*ppNode)
        {
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    T * GetNext(const T * pNode)
    {
        return pNode->m_pNext;
    }


    T * Item(ULONG i)
    {
        T * pNode = m_pHead;
        while (pNode && i)
        {
            i--;
            pNode = pNode->m_pNext;
        }
        return pNode;
    }

    void InsertAfter(T * pPrev, T * pNewNode)
    {
        if (pPrev)
        {
            pNewNode->m_pNext = pPrev->m_pNext;
            pPrev->m_pNext = pNewNode;
            if (pNewNode->m_pNext == NULL)
            {
                m_pTail = pNewNode;
            }
            if (bMaintainCount) ++m_cElements;
        }
        else
        {
            InsertHead(pNewNode);
        }
    }

    void InsertTail(T * pNode)
    {
        pNode->m_pNext = NULL;
        if (m_pHead)
        {
            m_pTail->m_pNext = pNode;
        }
        else
        {
            m_pHead = pNode;
        }
        m_pTail = pNode;
        if (bMaintainCount) ++m_cElements;
    }

    void InsertHead(T * pNode)
    {
        pNode->m_pNext = m_pHead;
        if (m_pHead == NULL)
        {
            m_pTail = pNode;
        }
        m_pHead = pNode;
        if (bMaintainCount) ++m_cElements;
    }

    T * RemoveHead()
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            m_pHead = pNode->m_pNext;
            if (bMaintainCount) --m_cElements;
        }
        return pNode;
    }

    T * RemoveTail()
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            if (pNode == m_pTail)
            {
                m_pHead = NULL;
            }
            else
            {
                T * pPrev;
                do
                {
                    pPrev = pNode;
                    pNode = pNode->m_pNext;
                } while ( pNode != m_pTail );
                pPrev->m_pNext = NULL;
                m_pTail = pPrev;
            }
            if (bMaintainCount) --m_cElements;
        }
        return pNode;
    }

    void Purge()
    {
        while (m_pHead)
        {
            T * pDie = m_pHead;
            m_pHead = pDie->m_pNext;
            delete pDie;
        }
        if (bMaintainCount) m_cElements = 0;
    }

    void ExplicitPurge()
    {
        T * pDie;
        BYTE * pb;

        while (m_pHead)
        {
            pDie = m_pHead;
            m_pHead = pDie->m_pNext;

            pDie->~T();

            pb = reinterpret_cast<BYTE *>(pDie);
            delete [] pb;
        }
        if (bMaintainCount) m_cElements = 0;
    }


    T * GetTail() const
    {
        if (m_pHead)
        {
            return m_pTail;
        }
        return NULL;
    }

    T * GetHead() const
    {
        return m_pHead;
    }

    BOOL IsEmpty() const
    {
        return m_pHead == NULL; 
    }

    BOOL Remove(T * pNode)
    {
        if (m_pHead == pNode)
        {
            m_pHead = pNode->m_pNext;
            if (bMaintainCount) --m_cElements;
            return TRUE;
        }
        else
        {
            T * pCur = m_pHead;
            while (pCur)
            {
                T * pNext = pCur->m_pNext;
                if (pNext == pNode)
                {
                    if ((pCur->m_pNext = pNode->m_pNext) == NULL)
                    {
                        m_pTail = pCur;
                    }
                    if (bMaintainCount) --m_cElements;
                    return TRUE;
                }
                pCur = pNext;
            }
        }
        return FALSE;
    }

    void MoveAllToHeadOf(CSpBasicQueue & DestQueue)
    {
        if (m_pHead)
        {
            m_pTail->m_pNext = DestQueue.m_pHead;
            if (DestQueue.m_pHead == NULL)
            {
                DestQueue.m_pTail = m_pTail;
            }
            DestQueue.m_pHead = m_pHead;
            m_pHead = NULL;
            if (bMaintainCount)
            {
                DestQueue.m_cElements += m_cElements;
                m_cElements = 0;
            }
        }
    }

    void MoveAllToList(CSpBasicList<T, bPurgeWhenDeleted> & List)
    {
        if (m_pHead)
        {
            m_pTail->m_pNext = List.m_pFirst;
            List.m_pFirst = m_pHead;
            m_pHead = NULL;
        }
        if (bMaintainCount)
        {
            m_cElements = 0;
        }
    }

    BOOL MoveToList(T * pNode, CSpBasicList<T, bPurgeWhenDeleted> & List)
    {
        BOOL bFound = Remove(pNode);
        if (bFound)
        {
            List.AddNode(pNode);
        }
        return bFound;
    }

    ULONG GetCount() const
    {
        if (bMaintainCount)
        {
            return m_cElements;
        }
        else
        {
            ULONG c = 0;
            for (T * pNode = m_pHead;
                 pNode;
                 pNode = pNode->m_pNext, c++) {}
            return c;
        }
    }

    //
    //  The following functions require the class T to implement a static function:
    //
    //      LONG Compare(const T * pElem1, const T * pElem2)
    //
    //  which returns < 0 if pElem1 is less than pElem2, 0 if they are equal, and > 0 if
    //  pElem1 is greater than pElem2.
    //
    void InsertSorted(T * pNode)
    {
        if (m_pHead)
        {
            if (T::Compare(pNode, m_pTail) >= 0)
            {
                pNode->m_pNext = NULL;
                m_pTail->m_pNext = pNode;
                m_pTail = pNode;
            }
            else
            {
                //
                //  We don't have to worry about walking off of the end of the list here since
                //  we have already checked the tail.
                //
                T ** ppNext = &m_pHead;
                while (T::Compare(pNode, *ppNext) >= 0)
                {
                    ppNext = &((*ppNext)->m_pNext);
                }
                pNode->m_pNext = *ppNext;
                *ppNext = pNode;
            }
        }
        else
        {
            pNode->m_pNext = NULL;
            m_pHead = m_pTail = pNode;
        }
        if (bMaintainCount) ++m_cElements;
    }

    HRESULT InsertSortedUnique(T * pNode)
    {
        HRESULT hr = S_OK;
        if (m_pHead)
        {
            if (T::Compare(pNode, m_pTail) > 0)
            {
                pNode->m_pNext = NULL;
                m_pTail->m_pNext = pNode;
                m_pTail = pNode;
            }
            else
            {
                //
                //  We don't have to worry about walking off of the end of the list here since
                //  we have already checked the tail.
                //
                T ** ppNext = &m_pHead;
                while (T::Compare(pNode, *ppNext) > 0)
                {
                    ppNext = &((*ppNext)->m_pNext);
                }
                if (T::Compare(pNode, *ppNext) != 0)
                {
                    pNode->m_pNext = *ppNext;
                    *ppNext = pNode;
                }
                else
                {
                    delete pNode;
                    hr = S_FALSE;
                }
            }
        }
        else
        {
            pNode->m_pNext = NULL;
            m_pHead = m_pTail = pNode;
        }
        if (bMaintainCount) ++m_cElements;
        return hr;
    }

    //
    //  These functions must support the "==" operator for the TFIND type.
    //
    template <class TFIND> 
    T * Find(TFIND & FindVal) const 
    {
        T * pNode = m_pHead;
        for (; pNode && (!(*pNode == FindVal)); pNode = pNode->m_pNext)
        {}
        return pNode;
    }

    template <class TFIND> 
    T * FindNext(const T * pCurNode, TFIND & FindVal) const 
    {
        for (T * pNode = pCurNode->m_pNext; pNode && (!(*pNode == FindVal)); pNode = pNode->m_pNext)
        {}
        return pNode;
    }

    //
    //  Searches for and removes a single list element
    //  
    template <class TFIND> 
    T * FindAndRemove(TFIND & FindVal)
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            if (*pNode == FindVal)
            {
                m_pHead = pNode->m_pNext;
                if (bMaintainCount) --m_cElements;
            }
            else
            {
                T * pPrev = pNode;
                for (pNode = pNode->m_pNext;
                     pNode;
                     pPrev = pNode, pNode = pNode->m_pNext)
                {
                    if (*pNode == FindVal)
                    {
                        pPrev->m_pNext = pNode->m_pNext;
                        if (pNode->m_pNext == NULL)
                        {
                            m_pTail = pPrev;
                        }
                        if (bMaintainCount) --m_cElements;
                        break;
                    }
                }
            }
        }
        return pNode;
    }

    //
    //  Searches for and deletes all list elements that match
    //  
    template <class TFIND> 
    void FindAndDeleteAll(TFIND & FindVal)
    {
        T * pNode = m_pHead;
        while (pNode && *pNode == FindVal)
        {
            m_pHead = pNode->m_pNext;
            delete pNode;
            if (bMaintainCount) --m_cElements;
            pNode = m_pHead;
        }
        T * pPrev = pNode;
        while (pNode)
        {
            T * pNext = pNode->m_pNext;
            if (*pNode == FindVal)
            {
                pPrev->m_pNext = pNext;
                delete pNode;
                if (bMaintainCount) --m_cElements;
            }
            else
            {
                pPrev = pNode;
            }
            pNode = pNext;
        }
        m_pTail = pPrev;    // Just always set it in case we removed the tail.
    }


};

template <class T, BOOL bPurgeWhenDeleted = TRUE>
class CSpBasicList
{
public:
    T * m_pFirst;
    CSpBasicList() : m_pFirst(NULL) {}
    ~CSpBasicList()
    {
        if (bPurgeWhenDeleted)
        {
            Purge();
        }
    }

    void Purge()
    {
        while (m_pFirst)
        {
            T * pNext = m_pFirst->m_pNext;
            delete m_pFirst;
            m_pFirst = pNext;
        }
    }

    void ExplicitPurge()
    {
        T * pDie;
        BYTE * pb;

        while (m_pFirst)
        {
            pDie = m_pFirst;
            m_pFirst = pDie->m_pNext;

            pDie->~T();

            pb = reinterpret_cast<BYTE *>(pDie);
            delete [] pb;
        }
    }

    HRESULT RemoveFirstOrAllocateNew(T ** ppNode)
    {
        if (m_pFirst)
        {
            *ppNode = m_pFirst;
            m_pFirst = m_pFirst->m_pNext;
        }
        else
        {
            *ppNode = new T;
            if (*ppNode == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        return S_OK;
    }

    void AddNode(T * pNode)
    {
        pNode->m_pNext = m_pFirst;
        m_pFirst = pNode;
    }
    T * GetFirst()
    {
        return m_pFirst;
    }
    T * RemoveFirst()
    {
        T * pNode = m_pFirst;
        if (pNode)
        {
            m_pFirst = pNode->m_pNext;
        }
        return pNode;
    }
};

#define STACK_ALLOC(TYPE, COUNT) (TYPE *)_alloca(sizeof(TYPE) * (COUNT))
#define STACK_ALLOC_AND_ZERO(TYPE, COUNT) (TYPE *)memset(_alloca(sizeof(TYPE) * (COUNT)), 0, (sizeof(TYPE) * (COUNT)))
#define STACK_ALLOC_AND_COPY(TYPE, COUNT, SOURCE) (TYPE *)memcpy(_alloca(sizeof(TYPE) * (COUNT)), (SOURCE), (sizeof(TYPE) * (COUNT)))

inline HRESULT SpGetSubTokenFromToken(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{

    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pToken) ||
        SP_IS_BAD_STRING_PTR(pszSubKeyName) ||
        SP_IS_BAD_WRITE_PTR(ppToken))
    {
        hr = E_POINTER;
    }

    // First, either create or open the datakey for the new token
    CComPtr<ISpDataKey> cpDataKeyForNewToken;
    if (SUCCEEDED(hr))
    {
        if (fCreateIfNotExist)
        {
            hr = pToken->CreateKey(pszSubKeyName, &cpDataKeyForNewToken);
        }
        else
        {
            hr = pToken->OpenKey(pszSubKeyName, &cpDataKeyForNewToken);
        }
    }

    // The sub token's category will be the token id of it's parent token
    CSpDynamicString dstrCategoryId;
    if (SUCCEEDED(hr))
    {
        hr = pToken->GetId(&dstrCategoryId);
    }

    // The sub token's token id will be it's category id + "\\" the key name
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = dstrCategoryId;
        dstrTokenId.Append2(L"\\", pszSubKeyName);
    }

    // Now create the token and initalize it
    CComPtr<ISpObjectTokenInit> cpTokenInit;
    if (SUCCEEDED(hr))
    {
        hr = cpTokenInit.CoCreateInstance(CLSID_SpObjectToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpTokenInit->InitFromDataKey(dstrCategoryId, dstrTokenId, cpDataKeyForNewToken);
    }

    if (SUCCEEDED(hr))
    {
        *ppToken = cpTokenInit.Detach();
    }

    return hr;
}

template<class T>
HRESULT SpCreateObjectFromSubToken(ISpObjectToken * pToken, const WCHAR * pszSubKeyName, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{

    HRESULT hr;

    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken);
    
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpSubToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    return hr;
}


__inline HRESULT GetObjectToken(const WCHAR* pszTokenCat, 
                       const WCHAR* pszTokenName, 
                       CComPtr<ISpObjectToken> &cpToken)
{
    cpToken = NULL;

    CComPtr<IEnumSpObjectTokens> cpEnum;
    ISpObjectToken* pToken      = NULL;

    if (SUCCEEDED(SpEnumTokens(pszTokenCat, NULL, NULL, &cpEnum)))
    {
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            CSpDynamicString dstrDesc;
            if (SUCCEEDED(SpGetDescription(pToken, &dstrDesc)))
            {
                if (! wcscmp(dstrDesc.m_psz, pszTokenName))
                {
                    cpToken = pToken;
                    goto Exit;
                }
            }

            if (pToken)
            {
                pToken->Release();
                pToken = NULL;
            }
        }
    }

Exit:
    if (pToken)
    {
        pToken->Release();
    }

    if (cpToken == NULL)
    {
        return E_FAIL;
    }

    return S_OK;
}

// Return a token enumerator containing all tokens that match the primary language
// of a particular language id. pszRequiredAttributes can be used to specify additional attributes all tokens must have.
inline HRESULT SpEnumTokensMatchingPrimaryLangID(const LPCWSTR pszCategoryId, LANGID priLangID, LPCWSTR pszRequiredAtts,
                                                 IEnumSpObjectTokens **ppEnum)
{
    HRESULT hr = S_OK;

    // First enumerate the tokens using pszRequiredAtts.
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    CComPtr<IEnumSpObjectTokens> cpEnum;
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->EnumTokens(pszRequiredAtts, NULL, &cpEnum);
    }

    ULONG ulTokens;
    if (SUCCEEDED(hr))
    {
        hr = cpEnum->GetCount(&ulTokens);
    }

    // Create enumerator to store new tokens.
    CComPtr<ISpObjectTokenEnumBuilder> cpBuilder;
    if (SUCCEEDED(hr))
    {
        hr = cpBuilder.CoCreateInstance(CLSID_SpObjectTokenEnum);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpBuilder->SetAttribs(NULL, NULL);
    }

    // Now, for each token, check language string to see if it matches.
    for (ULONG ul = 0; SUCCEEDED(hr) && ul < ulTokens; ul++)
    {
        LANGID tokenLangID;
        CComPtr<ISpObjectToken> cpToken;
        hr = cpEnum->Item(ul, &cpToken);
        if (SUCCEEDED(hr))
        {
            // Just look at the first language id
            hr = SpGetLanguageFromToken(cpToken, &tokenLangID);
        }

        if (SUCCEEDED(hr) && PRIMARYLANGID(tokenLangID) == PRIMARYLANGID(priLangID))
        {
            // Add to builder
            hr = cpBuilder->AddTokens(1, &(cpToken.p));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = cpBuilder->Reset();
    }
    if (SUCCEEDED(hr))
    {
        *ppEnum = cpBuilder.Detach();
    }

    return hr;
}




#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\specstrings.h ===
#ifndef SPECSTRINGS_H
#define SPECSTRINGS_H
#include "sal_supp.h"
#include "specstrings_supp.h"
/*************************************************************************
* See specstrings_strict.h for documentation of all user visible macros.
*************************************************************************/
#if _MSC_VER
#pragma once
#endif
#include <sal.h>

#ifndef __SAL_H_FULL_VER
#define __SAL_H_FULL_VER 140050727
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* version specific fixes to bring sal.h upto date */
#if __SAL_H_FULL_VER <= 140050727

#if !defined(__midl) && defined(_PREFAST_) && _MSC_VER >= 1000

/* Missing from RTM sal.h */
#define __inexpressible_readableTo(size)  __declspec("SAL_readableTo(inexpressibleCount('" SPECSTRINGIZE(size) "'))")
#define __inexpressible_writableTo(size)  __declspec("SAL_writableTo(inexpressibleCount('" SPECSTRINGIZE(size) "'))")
#define __inner_bound                     __declspec("SAL_bound")
#define __inner_range(lb,ub)              __declspec("SAL_range(" SPECSTRINGIZE(lb) "," SPECSTRINGIZE(ub) ")")
#define __inner_assume_bound_dec          __inline __nothrow void __AssumeBoundInt(__post __inner_bound int i) {i;}
#define __inner_assume_bound(i)           __AssumeBoundInt(i);
#define __inner_allocator                 __declspec("SAL_allocator")
#else
#define __inexpressible_readableTo(size)
#define __inexpressible_writableTo(size)
#define __inner_bound
#define __inner_range(lb,ub)
#define __inner_assume_bound_dec
#define __inner_assume_bound(i)
#define __inner_allocator
#endif

#define __xcount(size)                                          __notnull __inexpressible_writableTo(size)
#define __in_xcount(size)                                       __in __pre __inexpressible_readableTo(size)
#define __out_xcount(size)                                      __xcount(size) __post __valid __refparam
#define __out_xcount_part(size,length)                          __out_xcount(size) __post __inexpressible_readableTo(length)
#define __out_xcount_full(size)                                 __out_xcount_part(size,size)
#define __inout_xcount(size)                                    __out_xcount(size) __pre __valid
#define __inout_xcount_part(size,length)                        __out_xcount_part(size,length) __pre __valid __pre __inexpressible_readableTo(length)
#define __inout_xcount_full(size)                               __inout_xcount_part(size,size)
#define __xcount_opt(size)                                      __xcount(size)                              __exceptthat __maybenull
#define __in_xcount_opt(size)                                   __in_xcount(size)                           __exceptthat __maybenull
#define __out_xcount_opt(size)                                  __out_xcount(size)                          __exceptthat __maybenull
#define __out_xcount_part_opt(size,length)                      __out_xcount_part(size,length)              __exceptthat __maybenull
#define __out_xcount_full_opt(size)                             __out_xcount_full(size)                     __exceptthat __maybenull
#define __inout_xcount_opt(size)                                __inout_xcount(size)                        __exceptthat __maybenull
#define __inout_xcount_part_opt(size,length)                    __inout_xcount_part(size,length)            __exceptthat __maybenull
#define __inout_xcount_full_opt(size)                           __inout_xcount_full(size)                   __exceptthat __maybenull
#define __deref_xcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size)
#define __deref_in                                              __in __pre __deref __deref __readonly
#define __deref_in_ecount(size)                                 __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size)                                 __deref_in __pre __deref __byte_readableTo(size)
#define __deref_in_xcount(size)                                 __deref_in __pre __deref __inexpressible_readableTo(size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __deref_out_xcount_part(size,length)                    __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length)
#define __deref_out_xcount_full(size)                           __deref_out_xcount_part(size,size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __inout_xcount_opt(size)                                __inout_xcount(size)                        __exceptthat __maybenull
#define __inout_xcount_part_opt(size,length)                    __inout_xcount_part(size,length)            __exceptthat __maybenull
#define __inout_xcount_full_opt(size)                           __inout_xcount_full(size)                   __exceptthat __maybenull
#define __deref_xcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size)
#define __deref_in                                              __in __pre __deref __deref __readonly
#define __deref_in_ecount(size)                                 __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size)                                 __deref_in __pre __deref __byte_readableTo(size)
#define __deref_in_xcount(size)                                 __deref_in __pre __deref __inexpressible_readableTo(size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __deref_out_xcount_part(size,length)                    __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length)
#define __deref_out_xcount_full(size)                           __deref_out_xcount_part(size,size)
#define __deref_out_xcount(size)                                __deref_xcount(size) __post __deref __valid __refparam
#define __deref_inout_xcount(size)                              __deref_inout __pre __deref __inexpressible_writableTo(size) __post __deref __inexpressible_writableTo(size)
#define __deref_inout_xcount_part(size,length)                  __deref_inout_xcount(size) __pre __deref __inexpressible_readableTo(length) __post __deref __inexpressible_readableTo(length)
#define __deref_inout_xcount_full(size)                         __deref_inout_xcount_part(size,size)
#define __deref_xcount_opt(size)                                __deref_xcount(size)                        __post __deref __exceptthat __maybenull
#define __deref_in_opt                                          __deref_in                                  __pre __deref __exceptthat __maybenull
#define __deref_in_opt_out                                      __deref_inout                               __pre __deref __exceptthat __maybenull  __post __deref __notnull
#define __deref_in_ecount_opt(size)                             __deref_in_ecount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_in_bcount_opt(size)                             __deref_in_bcount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_in_xcount_opt(size)                             __deref_in_xcount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_out_xcount_opt(size)                            __deref_out_xcount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_xcount_part_opt(size,length)                __deref_out_xcount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_xcount_full_opt(size)                       __deref_out_xcount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_opt(size)                          __deref_inout_xcount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_part_opt(size,length)              __deref_inout_xcount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_full_opt(size)                     __deref_inout_xcount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_opt_xcount(size)                                __deref_xcount(size)                        __exceptthat __maybenull
#define __deref_opt_in                                          __deref_in                                  __exceptthat __maybenull
#define __deref_opt_in_ecount(size)                             __deref_in_ecount(size)                     __exceptthat __maybenull
#define __deref_opt_in_bcount(size)                             __deref_in_bcount(size)                     __exceptthat __maybenull
#define __deref_opt_in_xcount(size)                             __deref_in_xcount(size)                     __exceptthat __maybenull
#define __deref_opt_out_xcount(size)                            __deref_out_xcount(size)                    __exceptthat __maybenull
#define __deref_opt_out_xcount_part(size,length)                __deref_out_xcount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_xcount_full(size)                       __deref_out_xcount_full(size)               __exceptthat __maybenull
#define __deref_opt_inout_xcount(size)                          __deref_inout_xcount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_xcount_part(size,length)              __deref_inout_xcount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_xcount_full(size)                     __deref_inout_xcount_full(size)             __exceptthat __maybenull
#define __deref_opt_xcount_opt(size)                            __deref_xcount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_in_opt                                      __deref_in_opt                              __exceptthat __maybenull
#define __deref_opt_in_ecount_opt(size)                         __deref_in_ecount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_in_bcount_opt(size)                         __deref_in_bcount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_in_xcount_opt(size)                         __deref_in_xcount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_out_xcount_opt(size)                        __deref_out_xcount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_xcount_part_opt(size,length)            __deref_out_xcount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_xcount_full_opt(size)                   __deref_out_xcount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_inout_xcount_opt(size)                      __deref_inout_xcount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_xcount_part_opt(size,length)          __deref_inout_xcount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_xcount_full_opt(size)                 __deref_inout_xcount_full_opt(size)         __exceptthat __maybenull
/* Must protect redfinitions of macros to workaround rc.exe issues. */
#ifndef RC_INVOKED
#undef __nullnullterminated
#define __nullnullterminated __inexpressible_readableTo("string terminated by two nulls") __nullterminated
#undef __checkReturn
#define __checkReturn __post __inner_checkReturn
#endif
#endif  //__SAL_H_FULL_VER <= 140050727

/************************************************************************
 New extensions to sal.h follow here.
*************************************************************************/

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)
#define __file_parser(typ)                  __declspec("SAL_file_parser(\"function\", " #typ ")")
#define __file_parser_class(typ)            __declspec("SAL_file_parser(\"class\", " #typ ")")
#define __file_parser_library(typ)          extern int __declspec("SAL_file_parser(\"library\", " #typ ")") __iSALFileParserLibrary##typ;
#define __source_code_content(typ)          extern int __declspec("SAL_source_code_content(" #typ ")") __iSAL_Source_Code_Content##typ;
#define __class_code_content(typ)           __declspec("SAL_class_code_content(" #typ ")")
#define __analysis_assert(e)                __assume(e)
#define __analysis_hint(hint)               __declspec("SAL_analysisHint(" #hint ")")
// For "breakpoint": doesn't return as far as analysis is concerned.
#define __analysis_noreturn                 __declspec(noreturn)
/* Internal defintions */
#define __inner_data_source(src_raw)        __declspec("SAL_untrusted_data_source(" src_raw ")")
#define __inner_this_data_source(src_raw)   __declspec("SAL_untrusted_data_source_this(" src_raw ")")
#define __inner_out_validated(typ_raw)      __declspec("SAL_post") __declspec("SAL_validated(" typ_raw ")")
#define __inner_this_out_validated(typ_raw) __declspec("SAL_validated_this(" typ_raw ")")
#define __inner_assume_validated_dec        __inline __nothrow void __AssumeValidated(__inner_out_validated("BY_DESIGN") const void *p) {p;}
#define __inner_assume_validated(p)         __AssumeValidated(p)
#define __inner_transfer(formal)            __declspec("SAL_transfer_adt_property_from(" SPECSTRINGIZE(formal) ")")
#define __inner_encoded                     __declspec("SAL_encoded")

#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#define __inner_adt_prop(adt,prop)               __declspec("SAL_adt("#adt","#prop")")
#define __inner_adt_add_prop(adt,prop)           __declspec("SAL_add_adt_property("#adt","#prop")")
#define __inner_adt_remove_prop(adt,prop)        __declspec("SAL_remove_adt_property("#adt","#prop")")
#define __inner_adt_transfer_prop(arg)           __declspec("SAL_transfer_adt_property_from("#arg")")
#define __inner_adt_type_props(typ)              __declspec("SAL_post_type("#typ")")
#define __inner_volatile                         __declspec("SAL_volatile")
#define __inner_nonvolatile                      __declspec("SAL_nonvolatile")
#define __inner_possibly_notnullterminated       __declspec("SAL_nullTerminated(sometimes)")
#define __inner_analysis_assume_nullterminated_dec __inline __nothrow void __AnalysisAssumeNullterminated(__post __nullterminated void *p) {*(char*)p=0;}
#define __inner_analysis_assume_nullterminated(x) __AnalysisAssumeNullterminated(x);
#endif
#else
#define __file_parser(typ)
#define __file_parser_class(typ)
#define __file_parser_library(typ)
#define __source_code_content(typ)
#define __class_code_content(typ)
#define __analysis_assert(e)
#define __analysis_hint(hint)
#define __analysis_noreturn
/* Internal defintions */
#define __inner_data_source(src_raw)
#define __inner_this_data_source(src_raw)
#define __inner_out_validated(typ_raw)
#define __inner_this_out_validated(typ_raw)
#define __inner_assume_validated_dec
#define __inner_assume_validated(p)
#define __inner_transfer(formal)
#define __inner_encoded
#define __inner_adt_prop(adt,prop)
#define __inner_adt_add_prop(adt,prop)
#define __inner_adt_remove_prop(adt,prop)
#define __inner_adt_transfer_prop(arg)
#define __inner_adt_type_props(typ)
#define __inner_volatile
#define __inner_nonvolatile
#define __inner_possibly_notnullterminated
#define __inner_analysis_assume_nullterminated_dec
#define __inner_analysis_assume_nullterminated(x)
#endif // #if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)

#define __field_ecount(size)                __notnull __elem_writableTo(size)
#define __field_bcount(size)                __notnull __byte_writableTo(size)
#define __field_xcount(size)                __notnull __inexpressible_writableTo(size)

#define __field_ecount_opt(size)            __maybenull __elem_writableTo(size)
#define __field_bcount_opt(size)            __maybenull __byte_writableTo(size)
#define __field_xcount_opt(size)            __maybenull __inexpressible_writableTo(size)

#define __field_ecount_part(size,init)      __notnull __elem_writableTo(size) __elem_readableTo(init)
#define __field_bcount_part(size,init)      __notnull __byte_writableTo(size) __byte_readableTo(init)
#define __field_xcount_part(size,init)      __notnull __inexpressible_writableTo(size) __inexpressible_readableTo(init)

#define __field_ecount_part_opt(size,init)  __maybenull __elem_writableTo(size) __elem_readableTo(init)
#define __field_bcount_part_opt(size,init)  __maybenull __byte_writableTo(size) __byte_readableTo(init)
#define __field_xcount_part_opt(size,init)  __maybenull __inexpressible_writableTo(size) __inexpressible_readableTo(init)

#define __field_ecount_full(size)           __field_ecount_part(size,size)
#define __field_bcount_full(size)           __field_bcount_part(size,size)
#define __field_xcount_full(size)           __field_xcount_part(size,size)

#define __field_ecount_full_opt(size)       __field_ecount_part_opt(size,size)
#define __field_bcount_full_opt(size)       __field_bcount_part_opt(size,size)
#define __field_xcount_full_opt(size)       __field_xcount_part_opt(size,size)

#define __field_nullterminated              __nullterminated

#define __struct_bcount(size)               __byte_writableTo(size)
#define __struct_xcount(size)               __inexpressible_writableTo(size)

#define __out_awcount(expr,size)            __pre __notnull \
					    __byte_writableTo((expr) ? (size) : (size) * 2) \
                                            __post __valid __refparam
#define __in_awcount(expr,size)             __pre __valid \
                                            __pre __deref __readonly \
				            __byte_readableTo((expr) ? (size) : (size) * 2)
#define __post_invalid                      __post __notvalid
/* integer related macros */
#define __allocator                         __inner_allocator
#define __deallocate(kind)                  __pre __notnull __post_invalid
#define __deallocate_opt(kind)              __pre __maybenull __post_invalid
#define __bound                             __inner_bound
#define __range(lb,ub)                      __inner_range(lb,ub)
#define __in_bound                          __pre __inner_bound
#define __out_bound                         __post __inner_bound
#define __deref_out_bound                   __post __deref __inner_bound
#define __in_range(lb,ub)                   __pre __inner_range(lb,ub)
#define __out_range(lb,ub)                  __post __inner_range(lb,ub)
#define __deref_in_range(lb,ub)             __pre __deref __inner_range(lb,ub)
#define __deref_out_range(lb,ub)            __post __deref __inner_range(lb,ub)
#define __deref_inout_range(lb,ub)          __deref_in_range(lb,ub) __deref_out_range(lb,ub)
#define __field_range(lb,ub)                __range(lb,ub)
#define __field_data_source(src_sym)        __inner_data_source(#src_sym)

#define __range_max(a,b)                    __range(>=,a) __range(>=,b)
#define __range_min(a,b)                    __range(<=,a) __range(<=,b)

/* Penetration review macros */
#define __in_data_source(src_sym)           __pre __inner_data_source(#src_sym)
#define __out_data_source(src_sym)          __post __inner_data_source(#src_sym)
#define __out_validated(typ_sym)            __inner_out_validated(#typ_sym)
#define __this_out_data_source(src_sym)     __inner_this_data_source(#src_sym)
#define __this_out_validated(typ_sym)       __inner_this_out_validated(#typ_sym)
#define __transfer(formal)                  __post __inner_transfer(formal)
#define __rpc_entry                         __inner_control_entrypoint(RPC)
#define __kernel_entry                      __inner_control_entrypoint(UserToKernel)
#define __gdi_entry                         __inner_control_entrypoint(GDI)
#define __encoded_pointer                   __inner_encoded
#define __encoded_array                     __inner_encoded
#define __field_encoded_pointer             __inner_encoded
#define __field_encoded_array               __inner_encoded
#if defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)
#define __type_has_adt_prop(adt,prop)       __inner_adt_prop(adt,prop)
#define __out_has_adt_prop(adt,prop)        __post __inner_adt_add_prop(adt,prop)
#define __out_not_has_adt_prop(adt,prop)    __post __inner_adt_remove_prop(adt,prop)
#define __out_transfer_adt_prop(arg)        __post __inner_adt_transfer_prop(arg)
#define __out_has_type_adt_props(typ)       __post __inner_adt_type_props(typ)

/* useful PFD related macros */
#define __possibly_notnullterminated        __inner_possibly_notnullterminated

/* Windows Internal */
#define __volatile                          __inner_volatile
#define __nonvolatile                       __inner_nonvolatile
#else
#define __out_has_type_adt_props(typ)       /* nothing */
#endif
#define __deref_volatile                    __deref __volatile
#define __deref_nonvolatile                 __deref __nonvolatile

/* declare stub functions for macros */
__inner_assume_validated_dec
__inner_assume_bound_dec
__inner_analysis_assume_nullterminated_dec
#define __analysis_assume_nullterminated(x) __inner_analysis_assume_nullterminated(x)
#define __assume_validated(p) __inner_assume_validated(p)
#define __assume_bound(i) __inner_assume_bound(i)

#ifdef  __cplusplus
}
#endif

#ifdef _PREFIX_
/**************************************************************************
* Defintion of __pfx_assume and __pfx_assert. Thse should be the only
* defintions of these functions.
***************************************************************************/
#if __cplusplus
extern "C" void __pfx_assert(bool, const char *);
extern "C" void __pfx_assume(bool, const char *);
#else
void __pfx_assert(int, const char *);
void __pfx_assume(int, const char *);
#endif
/**************************************************************************
* Redefintion of __analysis_assume and __analysis_assert for PREFIX build
**************************************************************************/
#undef  __analysis_assume
#undef  __analysis_assert
#define __analysis_assume(e) (__pfx_assume(e,"pfx_assume"),__assume(e));
#define __analysis_assert(e) (__pfx_assert(e,"pfx_assert"),__assume(e));
#endif /* ifdef _PREFIX_ */

/**************************************************************************
* This include should always be the last thing in this file.
* Must avoid redfinitions of macros to workaround rc.exe issues.
***************************************************************************/
#if !(defined(RC_INVOKED) || defined(SORTPP_PASS))
#include <specstrings_strict.h>
#endif /* if !(defined(RC_INVOKED) || defined(SORTPP_PASS)) */

#include <driverspecs.h>

#endif /* #ifndef SPECSTRINGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SpOrder.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sporder.h

Abstract:

    This header prototypes the 32-Bit Windows functions that are used
    to change the order or WinSock2 transport service providers and
    name space providers.

Revision History:

--*/

#ifndef __SPORDER_H__
#define __SPORDER_H__

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

int
WSPAPI
WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

typedef
int
(WSPAPI * LPWSCWRITEPROVIDERORDER)(
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

#if(_WIN32_WINNT >= 0x0501)
#ifdef _WIN64
int
WSPAPI
WSCWriteProviderOrder32 (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );
#endif //_WIN64
#endif //_WIN32_WINNT >= 0x0501

int
WSPAPI
WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

typedef 
int
(WSPAPI * LPWSCWRITENAMESPACEORDER)(
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

#if(_WIN32_WINNT >= 0x0501)
#ifdef _WIN64
int
WSPAPI
WSCWriteNameSpaceOrder32 (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );
#endif //_WIN64
#endif //_WIN32_WINNT >= 0x0501

#ifdef __cplusplus
}
#endif

#endif      // __SPORDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\spuihelp.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPUIHelp.h *
*------------*
*   Description:
*       This is the header file for user-interface helper functions.  Note that
*       unlike SpHelper.H, this file requires the use of ATL.
*-------------------------------------------------------------------------------
*******************************************************************************/

#ifndef SPUIHelp_h
#define SPUIHelp_h

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPHelper_h
#include <SPHelper.h>
#endif

#ifndef __ATLBASE_H__
#include <ATLBASE.h>
#endif

#ifndef __ATLCONV_H__
#include <ATLCONV.H>
#endif

/****************************************************************************
* 
*
*
*****************************************************************************/

//
//  Dont call this function directly.  Use SpInitTokenComboBox or SpInitTokenListBox.
//
inline HRESULT SpInitTokenList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel,
                               HWND hwnd, const WCHAR * pszCatName,
                               const WCHAR * pszRequiredAttrib, const WCHAR * pszOptionalAttrib)
{
    HRESULT hr;
    ISpObjectToken * pToken;        // NOTE:  Not a CComPtr!  Be Careful.
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens(pszCatName, pszRequiredAttrib, pszOptionalAttrib, &cpEnum);
    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            CSpDynamicString dstrDesc;
            hr = SpGetDescription(pToken, &dstrDesc);
            if (SUCCEEDED(hr))
            {
                LRESULT i = ::SendMessageW(hwnd, MsgAddString, 0, (LPARAM)dstrDesc.m_psz);
                if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    ::SendMessageW(hwnd, MsgSetItemData, i, (LPARAM)pToken);
                    if (!fSetDefault)
                    {
                        ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
                        fSetDefault = true;
                    }
                }
            }
            if (FAILED(hr))
            {
                pToken->Release();
            }
        }
    }
    else
    {
        hr = SPERR_NO_MORE_ITEMS;
    }
    return hr;
}

inline HRESULT SpInitTokenComboBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return SpInitTokenList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

inline HRESULT SpInitTokenListBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return SpInitTokenList(LB_ADDSTRING, LB_SETITEMDATA, LB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

//
//  Dont call this function directly.  Use SpDestoyTokenComboBox or SpDestroyTokenListBox.
//
inline void SpDestroyTokenList(UINT MsgGetCount, UINT MsgGetItemData, HWND hwnd)
{
    LRESULT c = ::SendMessageW(hwnd, MsgGetCount, 0, 0);
    for (LRESULT i = 0; i < c; i++)
    {
        IUnknown * pUnkObj = (IUnknown *)::SendMessageW(hwnd, MsgGetItemData, i, 0);
        if (pUnkObj)
        {
            pUnkObj->Release();
        }
    }
}

inline void SpDestroyTokenComboBox(HWND hwnd)
{
    SpDestroyTokenList(CB_GETCOUNT, CB_GETITEMDATA, hwnd);
}

inline void SpDestroyTokenListBox(HWND hwnd)
{
    SpDestroyTokenList(LB_GETCOUNT, LB_GETITEMDATA, hwnd);
}


inline ISpObjectToken * SpGetComboBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessageW(hwnd, CB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * SpGetListBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessageW(hwnd, LB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * SpGetCurSelComboBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessageW(hwnd, CB_GETCURSEL, 0, 0);
    return (i == CB_ERR) ? NULL : SpGetComboBoxToken(hwnd, i);
}

inline ISpObjectToken * SpGetCurSelListBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessageW(hwnd, LB_GETCURSEL, 0, 0);
    return (i == LB_ERR) ? NULL : SpGetListBoxToken(hwnd, i);
}

//
//  Don't call this directly.  Use SpUpdateCurSelComboBoxToken or SpUpdateCurSelListBoxToken
//
inline HRESULT SpUpdateCurSelToken(UINT MsgDelString, UINT MsgInsertString, UINT MsgGetItemData, UINT MsgSetItemData, UINT MsgGetCurSel, UINT MsgSetCurSel,
                                   HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessageW(hwnd, MsgGetCurSel, 0, 0);
    if (i != CB_ERR)
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessageW(hwnd, MsgGetItemData, i, 0);
        CSpDynamicString dstrDesc;
        hr = SpGetDescription(pToken, &dstrDesc);
        if (SUCCEEDED(hr))
        {
            ::SendMessageW(hwnd, MsgDelString, i, 0);
            ::SendMessageW(hwnd, MsgInsertString, i, (LPARAM)dstrDesc.m_psz);
            ::SendMessageW(hwnd, MsgSetItemData, i, (LPARAM)pToken);
            ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
        }
    }
    return hr;
}

inline HRESULT SpUpdateCurSelComboBoxToken(HWND hwnd)
{
    return SpUpdateCurSelToken(CB_DELETESTRING, CB_INSERTSTRING, CB_GETITEMDATA, CB_SETITEMDATA, CB_GETCURSEL, CB_SETCURSEL, hwnd);
}

inline HRESULT SpUpdateCurSelListBoxToken(HWND hwnd)
{
    return SpUpdateCurSelToken(LB_DELETESTRING, LB_INSERTSTRING, LB_GETITEMDATA, LB_SETITEMDATA, LB_GETCURSEL, LB_SETCURSEL, hwnd);
}

inline HRESULT SpAddTokenToList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel, HWND hwnd, ISpObjectToken * pToken)
{
    CSpDynamicString dstrDesc;
    HRESULT hr = SpGetDescription(pToken, &dstrDesc);
    if (SUCCEEDED(hr))
    {
        LRESULT i = ::SendMessageW(hwnd, MsgAddString, 0, (LPARAM)dstrDesc.m_psz);
        if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            ::SendMessageW(hwnd, MsgSetItemData, i, (LPARAM)pToken);
            ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
            pToken->AddRef();
        }
    }
    return hr;
}

inline HRESULT SpAddTokenToComboBox(HWND hwnd, ISpObjectToken * pToken)
{
    return SpAddTokenToList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pToken);
}

inline HRESULT SpAddTokenToListBox(HWND hwnd, ISpObjectToken * pToken)
{
    return SpAddTokenToList(LB_ADDSTRING, LB_SETITEMDATA, LB_SETCURSEL, hwnd, pToken);
}


inline HRESULT SpDeleteCurSelToken(UINT MsgGetCurSel, UINT MsgSetCurSel, UINT MsgGetItemData, UINT MsgDeleteString, HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessageW(hwnd, MsgGetCurSel, 0, 0);
    if (i == CB_ERR)
    {
        hr = S_FALSE;
    }
    else
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessageW(hwnd, MsgGetItemData, i, 0);
        if (pToken)
        {
            pToken->Release();
        }
        ::SendMessageW(hwnd, MsgDeleteString, i, 0);
        ::SendMessageW(hwnd, MsgSetCurSel, i, 0);
    }
    return hr;
}

inline HRESULT SpDeleteCurSelComboBoxToken(HWND hwnd)
{
    return SpDeleteCurSelToken(CB_GETCURSEL, CB_SETCURSEL, CB_GETITEMDATA, CB_DELETESTRING, hwnd);
}

inline HRESULT SpDeleteCurSelListBoxToken(HWND hwnd)
{
    return SpDeleteCurSelToken(LB_GETCURSEL, CB_SETCURSEL, LB_GETITEMDATA, LB_DELETESTRING, hwnd);
}

#endif /* #ifndef SPUIHelp_h -- This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\specstrings_strict.h ===
/************************************************************************* 
*  This file documents all the macros approved for use in windows source
*  code. It includes some experimental macros which should only be used by
*  experts.
*
*  DO NOT include this file directly.  This file is include after
*  specstrings.h. So we can undefine every possible old definition including
*  private internal macros people should not be using, as well as macros from
*  sal.h.  Macros are redefined here in a way to cause syntax errors when used
*  incorrectly during a normal build when specstrings.h is included and
*  __SPECSTRINGS_STRICT_LEVEL is defined.
*
*  There are several levels of strictness, each level includes the behavior of
*  all previous levels.
*
*  0 - Disable strict checking 
*  1 - Break on unapproved macros and misuse of statement 
*      macros such as __fallthrough (default)
*  2 - Deprecated some old macros that should not be used
*  3 - Use VS 2005 Source Annotation to make sure every macro 
*      is used in the right context. For example placing __in on a return 
*      parameter will result in an error.
************************************************************************/
#ifndef __SPECSTRINGS_STRICT_LEVEL
#define __SPECSTRINGS_STRICT_LEVEL 1
#endif
/************************************************************************
*  Introduction
*
*  specstrings.h provides a set of annotations to describe how a function uses
*  its parameters - the assumptions it makes about them, and the guarantees it
*  makes upon finishing.
* 
*  Annotations must be placed before a function parameter's type or its return
*  type. There are two basic classes of common annotations buffer annotations
*  and advanced annotations.  Buffer annotations describe how functions use
*  their pointer parameters, and advanced annotations either describe
*  complex/unusual buffer behavior, or provide additional information about a
*  parameter that is not otherwise expressible.
* 
*  Buffer Annotations
* 
*  The most important annotations in SpecStrings.h provide a consistent way to
*  annotate buffer parameters or return values for a function. Each of these
*  annotations describes a single buffer (which could be a string, a
*  fixed-length or variable-length array, or just a pointer) that the function
*  interacts with: where it is, how large it is, how much is initialized, and
*  what the function does with it.
* 
*  The appropriate macro for a given buffer can be constructed using the table
*  below.  Just pick the appropriate values from each category, and combine
*  them together with a leading underscore. Some combinations of values do not
*  make sense as buffer annotations. Only meaningful annotations can be added
*  to your code; for a list of these, see the buffer annotation definitions
*  section.
* 
*  Only a single buffer annotation should be used for each parameter.
* 
*  |------------|------------|---------|--------|----------|---------------|
*  |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |
*  |------------|------------|---------|--------|----------|---------------|
*  | <>         | <>         | <>      | <>     | <>       | <>            |
*  | _deref     | _in        | _ecount | _full  | _opt     | (size)        |
*  | _deref_opt | _out       | _bcount | _part  |          | (size,length) |
*  |            | _inout     |         |        |          |               |
*  |            |            |         |        |          |               |
*  |------------|------------|---------|--------|----------|---------------|
*
*  Note: "<>" represents the empty string.
* 
*  Level: Describes the buffer pointer's level of indirection from the
*  parameter or return value 'p'.
* 
*  <>         : p is the buffer pointer.
*  _deref     : *p is the buffer pointer. p must not be NULL.
*  _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the 
*               rest of the annotation is ignored.
* 
*  Usage: Describes how the function uses the buffer.
* 
*  <> : The buffer is not accessed. If used on the return value or with
*  _deref, the function will provide the buffer, and it will be uninitialized
*  at exit.  Otherwise, the caller must provide the buffer. This should only
*  be used for alloc and free functions.
*
*  _in : The function will only read from the buffer. The caller must provide
*  the buffer and initialize it.
*
*  _out : The function will only write to the buffer. If used on the return
*  value or with _deref, the function will provide the buffer and initialize
*  it.  Otherwise, the caller must provide the buffer, and the function will
*  initialize it.
*
*  _inout : The function may freely read from and write to the buffer. The
*  caller must provide the buffer and initialize it. If used with _deref, the
*  buffer may be reallocated by the function.
*
*  Size: Describes the total size of the buffer. This may be less than the
*  space actually allocated for the buffer, in which case it describes the
*  accessible amount.
* 
*  <> : No buffer size is given. If the type specifies the buffer size (such
*  as with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is
*  one element long. Must be used with _in, _out, or _inout.
*
*  _ecount : The buffer size is an explicit element count.
*
*  _bcount : The buffer size is an explicit byte count.
* 
*  Output: Describes how much of the buffer will be initialized by the
*  function. For _inout buffers, this also describes how much is initialized
*  at entry. Omit this category for _in buffers; they must be fully
*  initialized by the caller.
* 
*  <> : The type specifies how much is initialized. For instance, a function
*  initializing an LPWSTR must NULL-terminate the string.
*
*  _full : The function initializes the entire buffer.
*
*  _part : The function initializes part of the buffer, and explicitly
*  indicates how much.
* 
*  Optional: Describes if the buffer itself is optional.
* 
*  <>   : The pointer to the buffer must not be NULL.
*
*  _opt : The pointer to the buffer might be NULL. It will be checked before
*  being dereferenced.
* 
*  Parameters: Gives explicit counts for the size and length of the buffer.
* 
*  <> : There is no explicit count. Use when neither _ecount nor _bcount is
*  used.
*
*  (size) : Only the buffer's total size is given. Use with _ecount or _bcount
*  but not _part.
*
*  (size,length) : The buffer's total size and initialized length are
*  given. Use with _ecount_part and _bcount_part.
* 
*  ----------------------------------------------------------------------------
*  Buffer Annotation Examples
* 
*  LWSTDAPI_(BOOL) StrToIntExA(
*      LPCSTR pszString,  //  No annotation required, const implies __in.
*      DWORD dwFlags,
*      __out int *piRet   // A pointer whose dereference will be filled in.
*  );
* 
*  void MyPaintingFunction(
*      __in HWND hwndControl,     //  An initialized read-only parameter.
*      __in_opt HDC hdcOptional,  //  An initialized read-only parameter that 
*                                 //  might be NULL.
*      __inout IPropertyStore *ppsStore // An initialized parameter that 
*                                       // may be freely used and modified.
*  );
* 
*  LWSTDAPI_(BOOL) PathCompactPathExA(
*      __out_ecount(cchMax) LPSTR pszOut, //  A string buffer with cch elements
*                                         //  that will be '\0' terminated 
*                                         //  on exit.
*      LPCSTR pszSrc,                     //  No annotation required, 
*                                         //  const implies __in.
*      UINT cchMax,                              
*      DWORD dwFlags
*  );
* 
*  HRESULT SHLocalAllocBytes(
*      size_t cb,
*      __deref_bcount(cb) T **ppv //  A pointer whose dereference will be set
*                                 //  to an uninitialized buffer with cb bytes.
*  );
* 
*  __inout_bcount_full(cb) : A buffer with cb elements that is fully
*  initialized at entry and exit, and may be written to by this function.
* 
*  __out_ecount_part(count, *countOut) : A buffer with count elements that
*  will be partially initialized by this function. The function indicates how
*  much it initialized by setting *countOut.
* 
************************************************************************/
#if (_MSC_VER >= 1400) && !defined(__midl) && !defined(_PREFAST_) && (__SPECSTRINGS_STRICT_LEVEL > 0)
#pragma once
#include <specstrings_undef.h>
#define __ecount(size)                                __allowed(on_return)
#define __bcount(size)                                __allowed(on_return)
#define __xcount(size)                                __allowed(on_return)
#define __in                                          __allowed(on_parameter)
#define __in_ecount(size)                             __allowed(on_parameter)
#define __in_bcount(size)                             __allowed(on_parameter)
#define __in_xcount(size)                             __allowed(on_parameter)
#define __in_z                                        __allowed(on_parameter)
#define __in_ecount_z(size)                           __allowed(on_parameter)
#define __in_bcount_z(size)                           __allowed(on_parameter)
#define __out                                         __allowed(on_parameter)
#define __out_ecount(size)                            __allowed(on_parameter)
#define __out_bcount(size)                            __allowed(on_parameter)
#define __out_xcount(size)                            __allowed(on_parameter)
#define __out_ecount_part(size,len)                   __allowed(on_parameter)
#define __out_bcount_part(size,len)                   __allowed(on_parameter)
#define __out_xcount_part(size,len)                   __allowed(on_parameter)
#define __out_ecount_full(size)                       __allowed(on_parameter)
#define __out_bcount_full(size)                       __allowed(on_parameter)
#define __out_xcount_full(size)                       __allowed(on_parameter)
#define __out_z				              __allowed(on_parameter)
#define __out_ecount_z(size)                          __allowed(on_parameter)
#define __out_bcount_z(size)                          __allowed(on_parameter)
#define __inout                                       __allowed(on_parameter)
#define __inout_ecount(size)                          __allowed(on_parameter)
#define __inout_bcount(size)                          __allowed(on_parameter)
#define __inout_xcount(size)                          __allowed(on_parameter)
#define __inout_ecount_part(size,len)                 __allowed(on_parameter)
#define __inout_bcount_part(size,len)                 __allowed(on_parameter)
#define __inout_xcount_part(size,len)                 __allowed(on_parameter)
#define __inout_ecount_full(size)                     __allowed(on_parameter)
#define __inout_bcount_full(size)                     __allowed(on_parameter)
#define __inout_xcount_full(size)                     __allowed(on_parameter)
#define __inout_z                                     __allowed(on_parameter)
#define __inout_ecount_z(size)                        __allowed(on_parameter)
#define __inout_bcount_z(size)                        __allowed(on_parameter)
#define __ecount_opt(size)                            __allowed(on_parameter)
#define __bcount_opt(size)                            __allowed(on_parameter)
#define __xcount_opt(size)                            __allowed(on_parameter)
#define __in_opt                                      __allowed(on_parameter)
#define __in_ecount_opt(size)                         __allowed(on_parameter)
#define __in_bcount_opt(size)                         __allowed(on_parameter)
#define __in_z_opt                                    __allowed(on_parameter)
#define __in_ecount_z_opt(size)                       __allowed(on_parameter)
#define __in_bcount_z_opt(size)                       __allowed(on_parameter)
#define __in_xcount_opt(size)                         __allowed(on_parameter)
#define __out_opt                                     __allowed(on_parameter)
#define __out_ecount_opt(size)                        __allowed(on_parameter)
#define __out_bcount_opt(size)                        __allowed(on_parameter)
#define __out_xcount_opt(size)                        __allowed(on_parameter)
#define __out_ecount_part_opt(size,len)               __allowed(on_parameter)
#define __out_bcount_part_opt(size,len)               __allowed(on_parameter)
#define __out_xcount_part_opt(size,len)               __allowed(on_parameter)
#define __out_ecount_full_opt(size)                   __allowed(on_parameter)
#define __out_bcount_full_opt(size)                   __allowed(on_parameter)
#define __out_xcount_full_opt(size)                   __allowed(on_parameter)
#define __out_ecount_z_opt(size)                      __allowed(on_parameter)
#define __out_bcount_z_opt(size)                      __allowed(on_parameter)
#define __inout_opt                                   __allowed(on_parameter)
#define __inout_ecount_opt(size)                      __allowed(on_parameter)
#define __inout_bcount_opt(size)                      __allowed(on_parameter)
#define __inout_xcount_opt(size)                      __allowed(on_parameter)
#define __inout_ecount_part_opt(size,len)             __allowed(on_parameter)
#define __inout_bcount_part_opt(size,len)             __allowed(on_parameter)
#define __inout_xcount_part_opt(size,len)             __allowed(on_parameter)
#define __inout_ecount_full_opt(size)                 __allowed(on_parameter)
#define __inout_bcount_full_opt(size)                 __allowed(on_parameter)
#define __inout_xcount_full_opt(size)                 __allowed(on_parameter)
#define __inout_z_opt                                 __allowed(on_parameter)
#define __inout_ecount_z_opt(size)                    __allowed(on_parameter)
#define __inout_ecount_z_opt(size)                    __allowed(on_parameter)
#define __inout_bcount_z_opt(size)                    __allowed(on_parameter)
#define __deref_ecount(size)                          __allowed(on_parameter)
#define __deref_bcount(size)                          __allowed(on_parameter)
#define __deref_xcount(size)                          __allowed(on_parameter)
#define __deref_in                                    __allowed(on_parameter)
#define __deref_in_ecount(size)                       __allowed(on_parameter)
#define __deref_in_bcount(size)                       __allowed(on_parameter)
#define __deref_in_xcount(size)                       __allowed(on_parameter)
#define __deref_out                                   __allowed(on_parameter)
#define __deref_out_ecount(size)                      __allowed(on_parameter)
#define __deref_out_bcount(size)                      __allowed(on_parameter)
#define __deref_out_xcount(size)                      __allowed(on_parameter)
#define __deref_out_ecount_part(size,len)             __allowed(on_parameter)
#define __deref_out_bcount_part(size,len)             __allowed(on_parameter)
#define __deref_out_xcount_part(size,len)             __allowed(on_parameter)
#define __deref_out_ecount_full(size)                 __allowed(on_parameter)
#define __deref_out_bcount_full(size)                 __allowed(on_parameter)
#define __deref_out_xcount_full(size)                 __allowed(on_parameter)
#define __deref_out_z                                 __allowed(on_parameter)
#define __deref_out_ecount_z(size)                    __allowed(on_parameter)
#define __deref_out_bcount_z(size)                    __allowed(on_parameter)
#define __deref_out_xcount(size)                      __allowed(on_parameter)
#define __deref_inout                                 __allowed(on_parameter)
#define __deref_inout_ecount(size)                    __allowed(on_parameter)
#define __deref_inout_bcount(size)                    __allowed(on_parameter)
#define __deref_inout_xcount(size)                    __allowed(on_parameter)
#define __deref_inout_ecount_part(size,len)           __allowed(on_parameter)
#define __deref_inout_bcount_part(size,len)           __allowed(on_parameter)
#define __deref_inout_xcount_part(size,len)           __allowed(on_parameter)
#define __deref_inout_ecount_full(size)               __allowed(on_parameter)
#define __deref_inout_bcount_full(size)               __allowed(on_parameter)
#define __deref_inout_xcount_full(size)               __allowed(on_parameter)
#define __deref_inout_z                               __allowed(on_parameter)
#define __deref_inout_ecount_z(size)                  __allowed(on_parameter)
#define __deref_inout_bcount_z(size)                  __allowed(on_parameter)
#define __deref_ecount_opt(size)                      __allowed(on_parameter)
#define __deref_bcount_opt(size)                      __allowed(on_parameter)
#define __deref_xcount_opt(size)                      __allowed(on_parameter)
#define __deref_in_opt                                __allowed(on_parameter)
#define __deref_in_opt_out                            __allowed(on_parameter)
#define __deref_in_ecount_opt(size)                   __allowed(on_parameter)
#define __deref_in_bcount_opt(size)                   __allowed(on_parameter)
#define __deref_in_xcount_opt(size)                   __allowed(on_parameter)
#define __deref_out_opt                               __allowed(on_parameter)
#define __deref_out_ecount_opt(size)                  __allowed(on_parameter)
#define __deref_out_bcount_opt(size)                  __allowed(on_parameter)
#define __deref_out_xcount_opt(size)                  __allowed(on_parameter)
#define __deref_out_ecount_part_opt(size,len)         __allowed(on_parameter)
#define __deref_out_bcount_part_opt(size,len)         __allowed(on_parameter)
#define __deref_out_xcount_part_opt(size,len)         __allowed(on_parameter)
#define __deref_out_ecount_full_opt(size)             __allowed(on_parameter)
#define __deref_out_bcount_full_opt(size)             __allowed(on_parameter)
#define __deref_out_xcount_full_opt(size)             __allowed(on_parameter)
#define __deref_out_z_opt                             __allowed(on_parameter)
#define __deref_out_ecount_z_opt(size)                __allowed(on_parameter)
#define __deref_out_bcount_z_opt(size)                __allowed(on_parameter)
#define __deref_inout_opt                             __allowed(on_parameter)
#define __deref_inout_ecount_opt(size)                __allowed(on_parameter)
#define __deref_inout_bcount_opt(size)                __allowed(on_parameter)
#define __deref_inout_xcount_opt(size)                __allowed(on_parameter)
#define __deref_inout_ecount_part_opt(size,len)       __allowed(on_parameter)
#define __deref_inout_bcount_part_opt(size,len)       __allowed(on_parameter)
#define __deref_inout_xcount_part_opt(size,len)       __allowed(on_parameter)
#define __deref_inout_ecount_full_opt(size)           __allowed(on_parameter)
#define __deref_inout_bcount_full_opt(size)           __allowed(on_parameter)
#define __deref_inout_xcount_full_opt(size)           __allowed(on_parameter)
#define __deref_inout_z_opt                           __allowed(on_parameter)
#define __deref_inout_ecount_z_opt(size)              __allowed(on_parameter)
#define __deref_inout_bcount_z_opt(size)              __allowed(on_parameter)
#define __deref_opt_ecount(size)                      __allowed(on_parameter)
#define __deref_opt_bcount(size)                      __allowed(on_parameter)
#define __deref_opt_xcount(size)                      __allowed(on_parameter)
#define __deref_opt_in                                __allowed(on_parameter)
#define __deref_opt_in_ecount(size)                   __allowed(on_parameter)
#define __deref_opt_in_bcount(size)                   __allowed(on_parameter)
#define __deref_opt_in_xcount(size)                   __allowed(on_parameter)
#define __deref_opt_out                               __allowed(on_parameter)
#define __deref_opt_out_ecount(size)                  __allowed(on_parameter)
#define __deref_opt_out_bcount(size)                  __allowed(on_parameter)
#define __deref_opt_out_xcount(size)                  __allowed(on_parameter)
#define __deref_opt_out_ecount_part(size,len)         __allowed(on_parameter)
#define __deref_opt_out_bcount_part(size,len)         __allowed(on_parameter)
#define __deref_opt_out_xcount_part(size,len)         __allowed(on_parameter)
#define __deref_opt_out_ecount_full(size)             __allowed(on_parameter)
#define __deref_opt_out_bcount_full(size)             __allowed(on_parameter)
#define __deref_opt_out_xcount_full(size)             __allowed(on_parameter)
#define __deref_opt_inout                             __allowed(on_parameter)
#define __deref_opt_inout_ecount(size)                __allowed(on_parameter)
#define __deref_opt_inout_bcount(size)                __allowed(on_parameter)
#define __deref_opt_inout_xcount(size)                __allowed(on_parameter)
#define __deref_opt_inout_ecount_part(size,len)       __allowed(on_parameter)
#define __deref_opt_inout_bcount_part(size,len)       __allowed(on_parameter)
#define __deref_opt_inout_xcount_part(size,len)       __allowed(on_parameter)
#define __deref_opt_inout_ecount_full(size)           __allowed(on_parameter)
#define __deref_opt_inout_bcount_full(size)           __allowed(on_parameter)
#define __deref_opt_inout_xcount_full(size)           __allowed(on_parameter)
#define __deref_opt_inout_z                           __allowed(on_parameter)
#define __deref_opt_inout_ecount_z(size)              __allowed(on_parameter)
#define __deref_opt_inout_bcount_z(size)              __allowed(on_parameter)
#define __deref_opt_ecount_opt(size)                  __allowed(on_parameter)
#define __deref_opt_bcount_opt(size)                  __allowed(on_parameter)
#define __deref_opt_xcount_opt(size)                  __allowed(on_parameter)
#define __deref_opt_in_opt                            __allowed(on_parameter)
#define __deref_opt_in_ecount_opt(size)               __allowed(on_parameter)
#define __deref_opt_in_bcount_opt(size)               __allowed(on_parameter)
#define __deref_opt_in_xcount_opt(size)               __allowed(on_parameter)
#define __deref_opt_out_opt                           __allowed(on_parameter)
#define __deref_opt_out_ecount_opt(size)              __allowed(on_parameter)
#define __deref_opt_out_bcount_opt(size)              __allowed(on_parameter)
#define __deref_opt_out_xcount_opt(size)              __allowed(on_parameter)
#define __deref_opt_out_ecount_part_opt(size,len)     __allowed(on_parameter)
#define __deref_opt_out_bcount_part_opt(size,len)     __allowed(on_parameter)
#define __deref_opt_out_xcount_part_opt(size,len)     __allowed(on_parameter)
#define __deref_opt_out_ecount_full_opt(size)         __allowed(on_parameter)
#define __deref_opt_out_bcount_full_opt(size)         __allowed(on_parameter)
#define __deref_opt_out_xcount_full_opt(size)         __allowed(on_parameter)  
#define __deref_opt_out_z_opt                         __allowed(on_parameter)
#define __deref_opt_out_ecount_z_opt(size)            __allowed(on_parameter)
#define __deref_opt_out_bcount_z_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_opt                         __allowed(on_parameter)
#define __deref_opt_inout_ecount_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_bcount_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_xcount_opt(size)            __allowed(on_parameter)
#define __deref_opt_inout_ecount_part_opt(size,len)   __allowed(on_parameter) 
#define __deref_opt_inout_bcount_part_opt(size,len)   __allowed(on_parameter)
#define __deref_opt_inout_xcount_part_opt(size,len)   __allowed(on_parameter)
#define __deref_opt_inout_ecount_full_opt(size)       __allowed(on_parameter)
#define __deref_opt_inout_bcount_full_opt(size)       __allowed(on_parameter)
#define __deref_opt_inout_xcount_full_opt(size)       __allowed(on_parameter)
#define __deref_opt_inout_z_opt                       __allowed(on_parameter)
#define __deref_opt_inout_ecount_z_opt(size)          __allowed(on_parameter)
#define __deref_opt_inout_bcount_z_opt(size)          __allowed(on_parameter)
/************************************************************************
*  Advanced Annotations
* 
*  Advanced annotations describe behavior that is not expressible with the
*  regular buffer macros. These may be used either to annotate buffer
*  parameters that involve complex or conditional behavior, or to enrich
*  existing annotations with additional information.
* 
*  __success(expr) T f() : <expr> indicates whether function f succeeded or
*  not. If <expr> is true at exit, all the function's guarantees (as given
*  by other annotations) must hold. If <expr> is false at exit, the caller
*  should not expect any of the function's guarantees to hold. If not used,
*  the function must always satisfy its guarantees. Added automatically to
*  functions that indicate success in standard ways, such as by returning an
*  HRESULT.
* 
*  __out_awcount(expr, size) T *p : Pointer p is a buffer whose size may be
*  given in either bytes or elements. If <expr> is true, this acts like
*  __out_bcount. If <expr> is false, this acts like __out_ecount. This
*  should only be used to annotate old APIs.
* 
*  __in_awcount(expr, size) T* p : Pointer p is a buffer whose size may be given
*  in either bytes or elements. If <expr> is true, this acts like
*  __in_bcount. If <expr> is false, this acts like __in_ecount. This should
*  only be used to annotate old APIs.
* 
*  __nullterminated T* p : Pointer p is a buffer that may be read or written
*  up to and including the first '\0' character or pointer. May be used on
*  typedefs, which marks valid (properly initialized) instances of that type
*  as being null-terminated.
* 
*  __nullnullterminated T* p : Pointer p is a buffer that may be read or
*  written up to and including the first sequence of two '\0' characters or
*  pointers. May be used on typedefs, which marks valid instances of that
*  type as being double-null terminated.
* 
*  __reserved T v : Value v must be 0/NULL, reserved for future use.
* 
*  __checkReturn T f(); : Return value of f must not be ignored by callers
*  of this function.
* 
*  __typefix(ctype) T v : Value v should be treated as an instance of ctype,
*  rather than its declared type when considering validity.
* 
*  __override T f(); : Specify C#-style 'override' behaviour for overriding
*  virtual methods.
* 
*  __callback T f(); : Function f can be used as a function pointer.
* 
*  __format_string T p : Pointer p is a string that contains % markers in
*  the style of printf.
* 
*  __blocksOn(resource) f(); : Function f blocks on the resource 'resource'.
* 
*  __fallthrough : Annotates switch statement labels where fall-through is
*  desired, to distinguish from forgotten break statements.
* 
*  __range(low_bnd, up_bnd) int f(): The return from the function "f" must
*  be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __in_range(low_bnd, up_bnd) int i : Precondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __out_range(low_bnd, up_bnd) int i : Postcondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __deref_in_range(low_bnd, up_bnd) int* pi : Precondition that integer *pi
*  must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_out_range(low_bnd, up_bnd) int* pi : Postcondition that integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_inout_range(low_bnd, up_bnd) int* pi : Invariant that the integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  The first argument of a range macro may also be a C relational operator
*  (<,>,!=, ==, <=, >=).
*  
*  __range(rel_op, j) int f(): Postcondition that "f() rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
*
*  __in_range(rel_op, j) int i : Precondition that "i rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
* 
*  __out_range(rel_op, j) int i : Postcondition that integer "i rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
* 
*  __deref_in_range(rel_op, j) int *pi : Precondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_out_range(rel_op, j) int *pi : Postcondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_inout_range(rel_op, j) int *pi : Invariant that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __range_max(a, b) int f(): Postcondition f acts as 'max', returns larger
*  of a and b.  Note that a and b may be expressions known only at runtime.
*
*  __range_min(a, b) int f(): Postcondition f acts as 'min', returns smaller
*  of a and b.  Note that a and b may be expressions known only at runtime.
*
*  __in_bound int i : Precondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __in_range should be
*  used if the range can be explicitly stated.
*
*  __out_bound int i : Postcondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __out_range should be
*  used if the range can be explicitly stated.
* 
*  __deref_out_bound int pi : Postcondition that integer *pi must be bound,
*  but the exact range can't be specified at compile time.
*  __deref_out_range should be used if the range can be explicitly stated.
* 
*  __assume_bound(expr); : Assume that the expression is bound to some known
*  range. This can be used to suppress integer overflow warnings on integral
*  expressions that are known to be bound due to reasons not explicit in the
*  code. Use as a statement in the body of a function.
*
*  __analysis_assume_nulltermianted(expr); : Assume that the expression is
*  a null terminated buffer. Use this to suppress tool noise specific to
*  nulltermination warnings, and capture deeper invariants tools can not
*  discover. 
* 
*  __allocator void f(): Function allocates memory using an integral size
*  argument
*
*  void myfree(__deallocate(Mem) void *p) : Memory is freed, no longer usable
*  upon return, and p may not be null.
*
*  void myfree(__deallocate_opt(Mem) void *p) : Memory is freed, no longer
*  usable upon return, and p may be null.
*
*  void free(__post_invalid void* x): Mark memory as untouchable when 
*  function returns.
*
*  ----------------------------------------------------------------------------
*  Advanced Annotation Examples
* 
*  __success(return == TRUE) LWSTDAPI_(BOOL) 
*  PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath);
*  //  pszBuf is only guaranteed to be null-terminated when TRUE is returned.
* 
*  // Initialized LPWSTRs are null-terminated strings.
*  typedef __nullterminated WCHAR* LPWSTR;
* 
*  __out_ecount(cch) __typefix(LPWSTR) void *psz;
*  // psz is a buffer parameter which will be a null-terminated WCHAR string 
*  // at exit, and which initially contains cch WCHARs.
* 
************************************************************************/
#define __success(expr)          __allowed(on_function_or_typedecl)
#define __out_awcount(expr,size) __allowed(on_parameter) 
#define __in_awcount(expr,size)  __allowed(on_parameter)   
#define __nullterminated         __allowed(on_typedecl)
#define __nullnullterminated     __allowed(on_typedecl)
#define __reserved               __allowed(on_parameter)
#define __checkReturn            __allowed(on_function)
#define __typefix(ctype)         __allowed(on_parameter_or_return) 
#define __override               __allowed(on_function) 
#define __callback               __allowed(on_function) 
#define __format_string          __allowed(on_parameter_or_return) 
#define __blocksOn(resource)     __allowed(on_function) 
#define __fallthrough            __allowed(as_statement)
#define __range(lb,ub)           __allowed(on_return) 
#define __in_range(lb,ub)        __allowed(on_parameter) 
#define __out_range(lb,ub)       __allowed(on_parameter) 
#define __deref_in_range(lb,ub)  __allowed(on_parameter) 
#define __deref_out_range(lb,ub) __allowed(on_parameter) 
#define __deref_inout_range(lb,ub) __allowed(on_parameter) 
#define __field_range(lb,ub)     __allowed(on_field)
#define __range_max(a,b)         __allowed(on_return) 
#define __range_min(a,b)         __allowed(on_return) 
#define __bound                  __allowed(on_return) 
#define __in_bound               __allowed(on_parameter) 
#define __out_bound              __allowed(on_parameter) 
#define __deref_out_bound        __allowed(on_parameter) 
#define __assume_bound(i)        __allowed(as_statement_with_arg(i))
#define __analysis_assume_nullterminated(x) \
                                 __allowed(as_statement_with_arg(x))
#define __allocator              __allowed(on_function) 
#define __deallocate(kind)       __allowed(on_parameter) 
#define __deallocate_opt(kind)   __allowed(on_parameter) 
#define __post_invalid           __allowed(on_parameter_or_return) 
/*************************************************************************** 
* Expert Macros
***************************************************************************/
#define __null                  __allowed(on_typedecl)
#define __notnull               __allowed(on_typedecl)
#define __maybenull             __allowed(on_typedecl)
#define __exceptthat            __allowed(on_typedecl)
/*************************************************************************** 
* Macros to classify fields of structures.
*                          Structure Annotations
*
*   The buffer annotations are a convenient way of describing
*   relationships between buffers and their size on a function by
*   function basis. Very often struct or class data members have similar
*   invariants, which can be expressed directly on the type.
*
*   Similar to our buffer annotations we can summarize all the various
*   structure annotations by one choosing an element from each column of
*   this table to build a composite annotation.
*
*           +--------------------------------------------------+
*           | Selector |  Units  |    Size/Init     | Optional |
*           |----------+---------+------------------+----------|
*           | __field  | _ecount | (size)           | empty    |
*           |----------+---------+------------------+----------|
*           | __struct | _bcount | _full(size)      | _opt     |
*           |----------+---------+------------------+----------|
*           |          | _xcount | _part(size,init) |          |
*           +--------------------------------------------------+
*
*   Note that empty represents the empty string. Sometime arguments need
*   to be "floated" to the left to give us a valid annotation name. For
*   example the naive combination __field_ecount(size)_opt is actually
*   written as __field_ecount_opt(size). Not all possible combinations
*   are currently supported or sensible. See specstrings_strict.h for
*   the currently supported set. Those that are supported are documented
*   below.
*
*Summary of Elements
*
*   Selector
*
*                __field
*                        The annotation should only be placed in front
*                        of data members of structures and classes. The
*                        data members are pointers to a block of data.
*                        The annotations describe properties about the
*                        size of the block of data. This can be used for
*
*                __struct
*                        The annotation should only be placed at the
*                        beginning of the definition of a structure or
*                        class. These annotations are used when a struct
*                        or class is used as a "header" that is
*                        allocated inline with a block of data and there
*                        is no apparent field that represents the tail
*                        end of the structure.
*
*   Units
*
*                _ecount
*                        All size and initialization values are in terms
*                        of elements of the appropriate type
*
*                _bcount
*                        All size and initialization values are in terms
*                        of raw byte sizes.
*
*                _xcount
*                        The size or initialization values cannot be
*                        properly expressed as a simple byte or element
*                        count, and instead a place holder is used to
*                        document the relationship.
*
*   Size/Init
*           All the size/init expressions can contain references to
*           other fields in the struct or class.
*
*                (size)
*                        The size of the buffer is determined by the
*                        expression size. Unless, the type of the buffer
*                        provides more information nothing is know about
*                        how much of this data is initialized. For
*                        example, if the data member happens to be a
*                        string type such as LPSTR. It is assumed that
*                        the data is initialized to the first '\0'.
*
*                _full(size)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized.
*
*                _part(size,init)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized up to init
*                        elements or bytes.
*
*   Optional
*
*                empty
*                        The pointer to the block of memory is never
*                        NULL
*
*                _opt
*                        The pointer to the block of memory is may be
*                        NULL
*
*     
*   // Basic Usage of Struct Annotations                         
*   #include <stdio.h>                                           
*   #include <stdlib.h>                                          
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount_full(sz)                                     
*    char *buf;                                                  
*   };                                                           
*   void InitBuf(__out struct *buf_s b,int sz) {                 
*        b->buf = calloc(sz,sizeof(char));                       
*        b->sz = sz;                                             
*   }                                                            
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(b->buf,b->sz,sizeof(char),fp);                      
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(b->buf,b->sz,sizeof(char),fp);                       
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Inline Allocated Buffer                                   
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount(sz)                                          
*    char buf[1];                                                
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&(b->buf),b->sz,sizeof(char),fp);                   
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&(b->buf),b->sz,sizeof(char),fp);                    
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Embedded Header Structure                                 
*   __struct_bcount(sz)                                          
*   struct buf_s {                                               
*    int sz;                                                     
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&b,b->sz,sizeof(char),fp);                          
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&b,b->sz,sizeof(char),fp);                           
*   }                                                            
*
*
****************************************************************************/
#define __field_ecount(size)               __allowed(on_field)
#define __field_bcount(size)               __allowed(on_field)
#define __field_xcount(size)               __allowed(on_field)
#define __field_ecount_opt(size)           __allowed(on_field)
#define __field_bcount_opt(size)           __allowed(on_field)
#define __field_xcount_opt(size)           __allowed(on_field)
#define __field_ecount_part(size,init)     __allowed(on_field)
#define __field_bcount_part(size,init)     __allowed(on_field)
#define __field_xcount_part(size,init)     __allowed(on_field)
#define __field_ecount_part_opt(size,init) __allowed(on_field)
#define __field_bcount_part_opt(size,init) __allowed(on_field)
#define __field_xcount_part_opt(size,init) __allowed(on_field)
#define __field_ecount_full(size)          __allowed(on_field)
#define __field_bcount_full(size)          __allowed(on_field)
#define __field_xcount_full(size)          __allowed(on_field)
#define __field_ecount_full_opt(size)      __allowed(on_field)
#define __field_bcount_full_opt(size)      __allowed(on_field) 
#define __field_xcount_full_opt(size)      __allowed(on_field)
#define __field_nullterminated             __allowed(on_field)
#define __struct_bcount(size)              __allowed(on_struct) 
#define __struct_xcount(size)              __allowed(on_struct) 

/*************************************************************************** 
* Macros to classify the entrypoints and indicate their category.
*
* Pre-defined control point categories include: RPC, KERNEL, GDI.
*
* Pre-defined control point macros include:
*  __rpc_entry, __kernel_entry, __gdi_entry.
***************************************************************************/
#define __control_entrypoint(category)     __allowed(on_function) 
#define __rpc_entry                        __allowed(on_function) 
#define __kernel_entry                     __allowed(on_function) 
#define __gdi_entry                        __allowed(on_function)  

/*************************************************************************** 
* Macros to track untrusted data and their validation. The list of untrusted
* sources include:
*
* FILE                     - File reading stream or API
* NETWORK                  - Socket readers
* INTERNET                 - WinInet and WinHttp readers
* USER_REGISTRY            - HKCU portions of the registry
* USER_MODE                - Parameters to kernel entry points
* RPC                      - Parameters to RPC entry points 
* DRIVER                   - Device driver 
***************************************************************************/
#define __in_data_source(src_sym)       __allowed(on_parameter) 
#define __out_data_source(src_sym)      __allowed(on_parameter) 
#define __field_data_source(src_sym)    __allowed(on_field)
#define __this_out_data_source(src_syn) __allowed(on_function)

/************************************************************************** 
* Macros to tag file parsing code. Predefined formats include:
*  PNG                     - Portable Network Graphics
*  JPEG                    - Joint Photographic Experts Group
*  BMP                     - Bitmap
*  RC_BMP                  - Resource bitmap
*  WMF                     - Windows Metafile
*  EMF                     - Windows Enhanced Metafile
*  GIF                     - Graphics Interchange Format
*  MIME_TYPE               - MIME type from header tokens
*  MAIL_MONIKER            - MAIL information refered by URL moniker
*  HTML                    - HyperText Markup Language
*  WMPHOTO                 - Windows media photo
*  OE_VCARD                - Outlook Express virtual card
*  OE_CONTACT              - Outlook Express contact
*  MIDI                    - Musical Instrument Digital Interface
*  LDIF                    - LDAP Data Interchange Format
*  AVI                     - Audio Visual Interchange
*  ACM                     - Audio Compression Manager
**************************************************************************/
#define __out_validated(filetype_sym)         __allowed(on_parameter) 
#define __this_out_validated(filetype_sym)    __allowed(on_function)   
#define __file_parser(filetype_sym)           __allowed(on_function) 
#define __file_parser_class(filetype_sym)     __allowed(on_struct)  
#define __file_parser_library(filetype_sym)   __allowed(as_global_decl)  

/*************************************************************************** 
* Macros to track the code content in the file. The type of code
* contents currently tracked:
*
* NDIS_DRIVER                   - NDIS Device driver 
***************************************************************************/
#define __source_code_content(codetype_sym)     __allowed(as_global_decl) 

/*************************************************************************** 
* Macros to track the code content in the class. The type of code
* contents currently tracked:
*
* DCOM                          - Class implementing DCOM
***************************************************************************/
#define __class_code_content(codetype_sym)    __allowed(on_struct) 

/*************************************************************************
* Macros to tag encoded function pointers
**************************************************************************/
#define __encoded_pointer                 
#define __encoded_array                   
#define __field_encoded_pointer           __allowed(on_field)
#define __field_encoded_array             __allowed(on_field)

#define __transfer(formal)                __allowed(on_parameter_or_return) 
#define __assume_validated(exp)           __allowed(as_statement_with_arg(exp))

/************************************************************************* 
* __analysis_assume(expr) : Expert macro use only when directed. Use this to
* tell static analysis tools like PREfix and PREfast about a non-coded
* assumption that you wish the tools to assume. The assumption will be
* understood by those tools. By default there is no dynamic checking or
* static checking of the assumption in any build.
*
* To obtain dynamic checking wrap this macro in your local version of a debug
* assert.
* Please do not put function calls in the expression because this is not
* supported by all tools:
*  __analysis_assume(GetObject () != NULL); // DO NOT DO THIS
*
*************************************************************************/
#define __analysis_assume(expr) __allowed(as_statement_with_arg(expr))
#define __analysis_assert(expr) __allowed(as_statement_with_arg(expr))

/************************************************************************* 
* __analysis_hint(hint_sym) : Expert macro use only when
* directed. Use this to influence certain analysis heuristics
* used by the tools. These hints do not describe the semantics
* of functions but simply direct the tools to act in a certain
* way.
*
* Current hints that are supported are:
*
* INLINE   - inline this function during analysis overrides any
*            default heuristics 
* NOINLINE - do not inline this function during analysis overrides 
*            and default heuristics
*************************************************************************/
#define __analysis_hint(hint) __allowed(on_function)

/************************************************************************* 
* Macros to encode abstract properties of values. Used by SALadt.h
*************************************************************************/
#define __type_has_adt_prop(adt,prop)     __allowed(on_typdecl)
#define __out_has_adt_prop(adt,prop)      __allowed(on_parameter)
#define __out_not_has_adt_prop(adt,prop)  __allowed(on_parameter)
#define __out_transfer_adt_prop(arg)      __allowed(on_parameter)
#define __out_has_type_adt_props(typ)     __allowed(on_parameter)

/************************************************************************* 
* Macros used by Prefast for Drivers 
* 
*  __possibly_notnullterminated :
*
*  Used for return values of parameters or functions that do not
*  guarantee nulltermination in all cases.
*
*************************************************************************/
#define __possibly_notnullterminated    __allowed(on_parameter_or_return)

/************************************************************************* 
* Advanced macros
* 
*  __volatile 
* The __volatile annotation identifies a global variable or
* structure field that: 
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* The __deref_volatile annotation identifies a global variable
* or structure field that stores a pointer to some data that:
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* Prefast uses these annotations to find patterns of code that
* may result in unexpected re-fetching of the global variable
* into a local variable.
*
* We also provide two complimentary annotations __nonvolatile
* and __deref_nonvolatile that could be used to suppress Prefast
*
* re-fetching warnings on variables that are known either:
*   1) not to be in danger of being re-fetched or,
*   2) not to lead to incorrect results if they are re-fetched
*
*************************************************************************/
#define __volatile                       __allowed(on_global_or_field)
#define __deref_volatile                 __allowed(on_global_or_field)
#define __nonvolatile                    __allowed(on_global_or_field)
#define __deref_nonvolatile              __allowed(on_global_or_field)

/************************************************************************* 
* Macros deprecated with strict level greater then 1.
**************************************************************************/
#if (__SPECSTRINGS_STRICT_LEVEL > 1)
/* Must come before macro defintions */
#pragma deprecated(__in_nz)
#pragma deprecated(__in_ecount_nz)
#pragma deprecated(__in_bcount_nz)
#pragma deprecated(__out_nz)
#pragma deprecated(__out_nz_opt)
#pragma deprecated(__out_ecount_nz)
#pragma deprecated(__out_bcount_nz)
#pragma deprecated(__inout_nz)
#pragma deprecated(__inout_ecount_nz)
#pragma deprecated(__inout_bcount_nz)
#pragma deprecated(__in_nz_opt)          
#pragma deprecated(__in_ecount_nz_opt)
#pragma deprecated(__in_bcount_nz_opt)
#pragma deprecated(__out_ecount_nz_opt)
#pragma deprecated(__out_bcount_nz_opt)
#pragma deprecated(__inout_nz_opt)       
#pragma deprecated(__inout_ecount_nz_opt)
#pragma deprecated(__inout_bcount_nz_opt)
#pragma deprecated(__deref_out_nz)                 
#pragma deprecated(__deref_out_ecount_nz)
#pragma deprecated(__deref_out_bcount_nz)
#pragma deprecated(__deref_inout_nz)               
#pragma deprecated(__deref_inout_ecount_nz)
#pragma deprecated(__deref_inout_bcount_nz)
#pragma deprecated(__deref_out_nz_opt)             
#pragma deprecated(__deref_out_ecount_nz_opt)
#pragma deprecated(__deref_out_bcount_nz_opt)
#pragma deprecated(__deref_inout_nz_opt)           
#pragma deprecated(__deref_inout_ecount_nz_opt)
#pragma deprecated(__deref_inout_bcount_nz_opt)
#pragma deprecated(__deref_opt_inout_nz)           
#pragma deprecated(__deref_opt_inout_ecount_nz)
#pragma deprecated(__deref_opt_inout_bcount_nz)
#pragma deprecated(__deref_opt_out_nz_opt)         
#pragma deprecated(__deref_opt_out_ecount_nz_opt)
#pragma deprecated(__deref_opt_out_bcount_nz_opt)
#pragma deprecated(__deref_opt_inout_nz_opt)       
#pragma deprecated(__deref_opt_inout_ecount_nz_opt)
#pragma deprecated(__deref_opt_inout_bcount_nz_opt)
#pragma deprecated(__deref)
#pragma deprecated(__pre)
#pragma deprecated(__post)
#pragma deprecated(__readableTo)
#pragma deprecated(__writableTo)
#pragma deprecated(__maybevalid)
#pragma deprecated(__data_entrypoint)
#pragma deprecated(__inexpressible_readableTo)
#pragma deprecated(__readonly)
#pragma deprecated(__byte_writableTo)
#pragma deprecated(__byte_readableTo)
#pragma deprecated(__elem_readableTo)
#pragma deprecated(__elem_writableTo)
#pragma deprecated(__valid)
#pragma deprecated(__notvalid)
#pragma deprecated(__refparam)
#pragma deprecated(__precond)
#endif
/* Define soon to be deprecated macros to nops. */
#define __in_nz                                       
#define __in_ecount_nz(size)                          
#define __in_bcount_nz(size)                          
#define __out_nz                                      
#define __out_nz_opt                                  
#define __out_ecount_nz(size)                         
#define __out_bcount_nz(size)                         
#define __inout_nz                                    
#define __inout_ecount_nz(size)                       
#define __inout_bcount_nz(size)                       
#define __in_nz_opt                                   
#define __in_ecount_nz_opt(size)                      
#define __in_bcount_nz_opt(size)                      
#define __out_ecount_nz_opt(size)                     
#define __out_bcount_nz_opt(size)                     
#define __inout_nz_opt                                
#define __inout_ecount_nz_opt(size)                   
#define __inout_bcount_nz_opt(size)                   
#define __deref_out_nz                                
#define __deref_out_ecount_nz(size)                   
#define __deref_out_bcount_nz(size)                   
#define __deref_inout_nz                              
#define __deref_inout_ecount_nz(size)                 
#define __deref_inout_bcount_nz(size)                 
#define __deref_out_nz_opt                            
#define __deref_out_ecount_nz_opt(size)               
#define __deref_out_bcount_nz_opt(size)               
#define __deref_inout_nz_opt                          
#define __deref_inout_ecount_nz_opt(size)             
#define __deref_inout_bcount_nz_opt(size)             
#define __deref_opt_inout_nz                          
#define __deref_opt_inout_ecount_nz(size)             
#define __deref_opt_inout_bcount_nz(size)             
#define __deref_opt_out_nz_opt                        
#define __deref_opt_out_ecount_nz_opt(size)           
#define __deref_opt_out_bcount_nz_opt(size)           
#define __deref_opt_inout_nz_opt                      
#define __deref_opt_inout_ecount_nz_opt(size)         
#define __deref_opt_inout_bcount_nz_opt(size)         
#define __deref             
#define __pre               
#define __post              
#define __readableTo(count) 
#define __writableTo(count) 
#define __maybevalid        
#define __inexpressible_readableTo(string) 
#define __data_entrypoint(category)
#define __readonly
#define __byte_writableTo(count)
#define __byte_readableTo(count)
#define __elem_readableTo(count)
#define __elem_writableTo(count)
#define __valid
#define __notvalid
#define __refparam
#define __precond(condition)

/************************************************************************* 
* Definitions to force a compile error when macros are used improperly.
* Relies on VS 2005 source annotations.
*************************************************************************/
#if !defined(_MSC_EXTENSIONS) && !defined(_PREFAST_) && !defined(OACR)
#define __allowed(p) /* nothing */
#else
#define __allowed(p) __$allowed_##p
#define __$allowed_as_global_decl /* empty */
#define __$allowed_as_statement_with_arg(x) \
    __pragma(warning(push)) __pragma(warning(disable : 4548)) \
        do {__noop(x);} while((0,0) __pragma(warning(pop)) )
#define __$allowed_as_statement __$allowed_as_statement_with_arg(1)

/**************************************************************************
*  This should go away. It's only for __success which we should split into.
*  __success and __typdecl_sucess
***************************************************************************/
#define __$allowed_on_function_or_typedecl /* empty */
#if (__SPECSTRINGS_STRICT_LEVEL == 1) || (__SPECSTRINGS_STRICT_LEVEL == 2)
#define __$allowed_on_typedecl /* empty */
#define __$allowed_on_return /* empty */
#define __$allowed_on_parameter /* empty */
#define __$allowed_on_function /* empty */
#define __$allowed_on_struct /* empty */
#define __$allowed_on_field /* empty */
#define __$allowed_on_parameter_or_return /* empty */
#define __$allowed_on_global_or_field /* empty */
#elif __SPECSTRINGS_STRICT_LEVEL == 3
#define __$allowed_on_typedecl /* empty */
/* Define dummy source attributes. Still needs more testing */
#define __$allowed_on_return [returnvalue: OnReturnOnly]
#define __$allowed_on_parameter [OnParameterOnly]
#define __$allowed_on_function [method: OnFunctionOnly]
#define __$allowed_on_struct [OnStructOnly]
#define __$allowed_on_field [OnFieldOnly]
#define __$allowed_on_parameter_or_return [OnParameterOrReturnOnly] 
#define __$allowed_on_global_or_field /* empty */
#pragma push_macro( "DECL_SA" )
#pragma push_macro( "SA" )
#ifdef __cplusplus
#define SA(x) x
#define DECL_SA(name,loc) \
  [repeatable] \
  [source_annotation_attribute( loc )] \
  struct name##Attribute { name##Attribute(); const char* ignored; }; 
#else
#define SA(x) SA_##x
#define DECL_SA(name,loc) \
  [source_annotation_attribute( loc )] \
  struct name { const char* ignored; };\
  typedef struct name name;
#endif  /* #endif  __cplusplus */
DECL_SA(OnParameterOnly,SA(Parameter));
DECL_SA(OnReturnOnly,SA(ReturnValue));
DECL_SA(OnFunctionOnly,SA(Method));
DECL_SA(OnStructOnly,SA(Struct));
DECL_SA(OnFieldOnly,SA(Field));
DECL_SA(OnParameterOrReturnOnly,SA(Parameter) | SA(ReturnValue));
#pragma pop_macro( "SA" )
#pragma pop_macro( "DECL_SA" )
#endif 
#endif 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\specstrings_undef.h ===
#undef __allocator
#undef __analysis_assert
#undef __analysis_assume
#undef __analysis_assume_nullterminated
#undef __analysis_hint
#undef __assume_bound
#undef __assume_validated
#undef __bcount
#undef __bcount_opt
#undef __blocksOn
#undef __bound
#undef __byte_readableTo
#undef __byte_writableTo
#undef __callback
#undef __checkReturn
#undef __class_code_content
#undef __control_entrypoint
#undef __data_entrypoint
#undef __deallocate
#undef __deallocate_opt
#undef __deref
#undef __deref_bcount
#undef __deref_bcount_opt
#undef __deref_ecount
#undef __deref_ecount_opt
#undef __deref_in
#undef __deref_in_bcount
#undef __deref_in_bcount_opt
#undef __deref_in_ecount
#undef __deref_in_ecount_opt
#undef __deref_in_opt
#undef __deref_in_opt_out
#undef __deref_in_range
#undef __deref_in_xcount
#undef __deref_in_xcount_opt
#undef __deref_inout
#undef __deref_inout_bcount
#undef __deref_inout_bcount_full
#undef __deref_inout_bcount_full_opt
#undef __deref_inout_bcount_nz
#undef __deref_inout_bcount_nz_opt
#undef __deref_inout_bcount_opt
#undef __deref_inout_bcount_part
#undef __deref_inout_bcount_part_opt
#undef __deref_inout_bcount_z
#undef __deref_inout_bcount_z_opt
#undef __deref_inout_ecount
#undef __deref_inout_ecount_full
#undef __deref_inout_ecount_full_opt
#undef __deref_inout_ecount_nz
#undef __deref_inout_ecount_nz_opt
#undef __deref_inout_ecount_opt
#undef __deref_inout_ecount_part
#undef __deref_inout_ecount_part_opt
#undef __deref_inout_ecount_z
#undef __deref_inout_ecount_z_opt
#undef __deref_inout_nz
#undef __deref_inout_nz_opt
#undef __deref_inout_opt
#undef __deref_inout_range
#undef __deref_inout_xcount
#undef __deref_inout_xcount_full
#undef __deref_inout_xcount_full_opt
#undef __deref_inout_xcount_opt
#undef __deref_inout_xcount_part
#undef __deref_inout_xcount_part_opt
#undef __deref_inout_z
#undef __deref_inout_z_opt
#undef __deref_nonvolatile
#undef __deref_opt_bcount
#undef __deref_opt_bcount_opt
#undef __deref_opt_ecount
#undef __deref_opt_ecount_opt
#undef __deref_opt_in
#undef __deref_opt_in_bcount
#undef __deref_opt_in_bcount_opt
#undef __deref_opt_in_ecount
#undef __deref_opt_in_ecount_opt
#undef __deref_opt_in_opt
#undef __deref_opt_in_xcount
#undef __deref_opt_in_xcount_opt
#undef __deref_opt_inout
#undef __deref_opt_inout_bcount
#undef __deref_opt_inout_bcount_full
#undef __deref_opt_inout_bcount_full_opt
#undef __deref_opt_inout_bcount_nz
#undef __deref_opt_inout_bcount_nz_opt
#undef __deref_opt_inout_bcount_opt
#undef __deref_opt_inout_bcount_part
#undef __deref_opt_inout_bcount_part_opt
#undef __deref_opt_inout_bcount_z
#undef __deref_opt_inout_bcount_z_opt
#undef __deref_opt_inout_ecount
#undef __deref_opt_inout_ecount_full
#undef __deref_opt_inout_ecount_full_opt
#undef __deref_opt_inout_ecount_nz
#undef __deref_opt_inout_ecount_nz_opt
#undef __deref_opt_inout_ecount_opt
#undef __deref_opt_inout_ecount_part
#undef __deref_opt_inout_ecount_part_opt
#undef __deref_opt_inout_ecount_z
#undef __deref_opt_inout_ecount_z_opt
#undef __deref_opt_inout_nz
#undef __deref_opt_inout_nz_opt
#undef __deref_opt_inout_opt
#undef __deref_opt_inout_xcount
#undef __deref_opt_inout_xcount_full
#undef __deref_opt_inout_xcount_full_opt
#undef __deref_opt_inout_xcount_opt
#undef __deref_opt_inout_xcount_part
#undef __deref_opt_inout_xcount_part_opt
#undef __deref_opt_inout_z
#undef __deref_opt_inout_z_opt
#undef __deref_opt_out
#undef __deref_opt_out_bcount
#undef __deref_opt_out_bcount_full
#undef __deref_opt_out_bcount_full_opt
#undef __deref_opt_out_bcount_nz_opt
#undef __deref_opt_out_bcount_opt
#undef __deref_opt_out_bcount_part
#undef __deref_opt_out_bcount_part_opt
#undef __deref_opt_out_bcount_z_opt
#undef __deref_opt_out_ecount
#undef __deref_opt_out_ecount_full
#undef __deref_opt_out_ecount_full_opt
#undef __deref_opt_out_ecount_nz_opt
#undef __deref_opt_out_ecount_opt
#undef __deref_opt_out_ecount_part
#undef __deref_opt_out_ecount_part_opt
#undef __deref_opt_out_ecount_z_opt
#undef __deref_opt_out_nz_opt
#undef __deref_opt_out_opt
#undef __deref_opt_out_xcount
#undef __deref_opt_out_xcount_full
#undef __deref_opt_out_xcount_full_opt
#undef __deref_opt_out_xcount_opt
#undef __deref_opt_out_xcount_part
#undef __deref_opt_out_xcount_part_opt
#undef __deref_opt_out_z_opt
#undef __deref_opt_xcount
#undef __deref_opt_xcount_opt
#undef __deref_out
#undef __deref_out_bcount
#undef __deref_out_bcount_full
#undef __deref_out_bcount_full_opt
#undef __deref_out_bcount_nz
#undef __deref_out_bcount_nz_opt
#undef __deref_out_bcount_opt
#undef __deref_out_bcount_part
#undef __deref_out_bcount_part_opt
#undef __deref_out_bcount_z
#undef __deref_out_bcount_z_opt
#undef __deref_out_bound
#undef __deref_out_ecount
#undef __deref_out_ecount_full
#undef __deref_out_ecount_full_opt
#undef __deref_out_ecount_nz
#undef __deref_out_ecount_nz_opt
#undef __deref_out_ecount_opt
#undef __deref_out_ecount_part
#undef __deref_out_ecount_part_opt
#undef __deref_out_ecount_z
#undef __deref_out_ecount_z_opt
#undef __deref_out_nz
#undef __deref_out_nz_opt
#undef __deref_out_opt
#undef __deref_out_range
#undef __deref_out_range
#undef __deref_out_xcount
#undef __deref_out_xcount
#undef __deref_out_xcount_full
#undef __deref_out_xcount_full_opt
#undef __deref_out_xcount_opt
#undef __deref_out_xcount_part
#undef __deref_out_xcount_part_opt
#undef __deref_out_z
#undef __deref_out_z_opt
#undef __deref_volatile
#undef __deref_xcount
#undef __deref_xcount_opt
#undef __ecount
#undef __ecount_opt
#undef __elem_readableTo
#undef __elem_writableTo
#undef __encoded_array
#undef __encoded_pointer
#undef __exceptthat
#undef __fallthrough
#undef __field_bcount
#undef __field_bcount_full
#undef __field_bcount_full_opt
#undef __field_bcount_opt
#undef __field_bcount_part
#undef __field_bcount_part_opt
#undef __field_data_source
#undef __field_ecount
#undef __field_ecount_full
#undef __field_ecount_full_opt
#undef __field_ecount_opt
#undef __field_ecount_part
#undef __field_ecount_part_opt
#undef __field_encoded_array
#undef __field_encoded_pointer
#undef __field_nullterminated
#undef __field_range
#undef __field_xcount
#undef __field_xcount_full
#undef __field_xcount_full_opt
#undef __field_xcount_opt
#undef __field_xcount_part
#undef __field_xcount_part_opt
#undef __file_parser
#undef __file_parser_class
#undef __file_parser_library
#undef __format_string
#undef __format_string
#undef __gdi_entry
#undef __in
#undef __in_awcount
#undef __in_bcount
#undef __in_bcount_nz
#undef __in_bcount_nz_opt
#undef __in_bcount_opt
#undef __in_bcount_z
#undef __in_bcount_z_opt
#undef __in_bound
#undef __in_data_source
#undef __in_ecount
#undef __in_ecount_nz
#undef __in_ecount_nz_opt
#undef __in_ecount_opt
#undef __in_ecount_z
#undef __in_ecount_z_opt
#undef __in_nz
#undef __in_nz_opt
#undef __in_opt
#undef __in_range
#undef __in_xcount
#undef __in_xcount_opt
#undef __in_z
#undef __in_z_opt
#undef __inexpressible_readableTo
#undef __inexpressible_writableTo
#undef __inner_adt_add_prop
#undef __inner_adt_prop
#undef __inner_adt_remove_prop
#undef __inner_adt_transfer_prop
#undef __inner_adt_type_props
#undef __inner_analysis_assume_nulltermianted_dec
#undef __inner_analysis_assume_nullterminated               
#undef __inner_assume_bound
#undef __inner_assume_bound_dec
#undef __inner_assume_validated
#undef __inner_assume_validated_dec
#undef __inner_blocksOn
#undef __inner_bound
#undef __inner_callback
#undef __inner_checkReturn
#undef __inner_compname_props
#undef __inner_control_entrypoint
#undef __inner_data_entrypoint
#undef __inner_data_source
#undef __inner_encoded
#undef __inner_fallthrough
#undef __inner_fallthrough_dec
#undef __inner_nonvolatile
#undef __inner_out_validated
#undef __inner_override
#undef __inner_possibly_notnullterminated
#undef __inner_range
#undef __inner_success
#undef __inner_transfer
#undef __inner_typefix
#undef __inner_volatile
#undef __inout
#undef __inout_bcount
#undef __inout_bcount_full
#undef __inout_bcount_full_opt
#undef __inout_bcount_nz
#undef __inout_bcount_nz_opt
#undef __inout_bcount_opt
#undef __inout_bcount_part
#undef __inout_bcount_part_opt
#undef __inout_bcount_z
#undef __inout_bcount_z_opt
#undef __inout_ecount
#undef __inout_ecount_full
#undef __inout_ecount_full_opt
#undef __inout_ecount_nz
#undef __inout_ecount_nz_opt
#undef __inout_ecount_opt
#undef __inout_ecount_part
#undef __inout_ecount_part_opt
#undef __inout_ecount_z
#undef __inout_ecount_z_opt
#undef __inout_ecount_z_opt
#undef __inout_nz
#undef __inout_nz_opt
#undef __inout_opt
#undef __inout_xcount
#undef __inout_xcount_full
#undef __inout_xcount_full_opt
#undef __inout_xcount_opt
#undef __inout_xcount_part
#undef __inout_xcount_part_opt
#undef __inout_z
#undef __inout_z_opt
#undef __kernel_entry
#undef __maybenull
#undef __maybereadonly
#undef __maybevalid
#undef __range_max
#undef __range_min
#undef __nonvolatile
#undef __notnull
#undef __notreadonly
#undef __notvalid
#undef __null
#undef __nullnullterminated
#undef __nullterminated
#undef __out
#undef __out_awcount
#undef __out_bcount
#undef __out_bcount_full
#undef __out_bcount_full_opt
#undef __out_bcount_nz
#undef __out_bcount_nz_opt
#undef __out_bcount_opt
#undef __out_bcount_part
#undef __out_bcount_part_opt
#undef __out_bcount_z
#undef __out_bcount_z_opt
#undef __out_bound
#undef __out_data_source
#undef __out_ecount
#undef __out_ecount_full
#undef __out_ecount_full_opt
#undef __out_ecount_nz
#undef __out_ecount_nz_opt
#undef __out_ecount_opt
#undef __out_ecount_part
#undef __out_ecount_part_opt
#undef __out_ecount_z
#undef __out_ecount_z_opt
#undef __out_has_adt_prop
#undef __out_has_type_adt_props
#undef __out_not_has_adt_prop
#undef __out_nz
#undef __out_nz_opt
#undef __out_opt
#undef __out_range
#undef __out_transfer_adt_prop
#undef __out_validated
#undef __out_xcount
#undef __out_xcount_full
#undef __out_xcount_full_opt
#undef __out_xcount_opt
#undef __out_xcount_part
#undef __out_xcount_part_opt
#undef __out_z
#undef __override
#undef __possibly_notnullterminated
#undef __post
#undef __post_invalid
#undef __postcond
#undef __pre
#undef __precond
#undef __range
#undef __readableTo
#undef __readonly
#undef __refparam
#undef __reserved
#undef __rpc_entry
#undef __source_code_content
#undef __struct_bcount
#undef __struct_xcount
#undef __success
#undef __this_out_data_source
#undef __this_out_validated
#undef __transfer
#undef __type_has_adt_prop
#undef __typefix
#undef __valid
#undef __volatile
#undef __writableTo
#undef __xcount
#undef __xcount_opt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\specstrings_supp.h ===
// A temporary header to supplement specstrings.h with things that currently 
// cannot be put into specstrings.h.
// This is designed to be included at the beginning of a compilation unit
// (via force-include) if necessary.

#ifndef SPECSTRING_SUPP_H // [
#define SPECSTRING_SUPP_H

#if !defined(__midl) && defined(_PREFAST_) && _MSC_VER >= 1000 // [

#include "sal_supp.h"

#ifdef  __cplusplus
extern "C" {
#endif

__ANNOTATION(SAL_bound(void));
__ANNOTATION(SAL_range(__int64,__int64));
__ANNOTATION(SAL_allocator(void));   //??? resolve with PFD
__ANNOTATION(SAL_file_parser(__AuToQuOtE __xin char *, __xin char *));
__ANNOTATION(SAL_source_code_content(__xin char *));
__ANNOTATION(SAL_analysisHint(__AuToQuOtE char *));
__ANNOTATION(SAL_untrusted_data_source(__AuToQuOtE char *));
__ANNOTATION(SAL_untrusted_data_source_this(__AuToQuOtE char *));
__ANNOTATION(SAL_validated(__AuToQuOtE char *));
__ANNOTATION(SAL_validated_this(__AuToQuOtE char *));
__ANNOTATION(SAL_encoded(void));
__ANNOTATION(SAL_adt(__AuToQuOtE __xin char *, __AuToQuOtE __xin char *));
__ANNOTATION(SAL_add_adt_property(__AuToQuOtE __xin char *, __AuToQuOtE __xin char *));
__ANNOTATION(SAL_remove_adt_property(__AuToQuOtE __xin char *, __AuToQuOtE __xin char *));
__ANNOTATION(SAL_transfer_adt_property_from(__AuToQuOtE __xin char *));
__ANNOTATION(SAL_post_type(__AuToQuOtE __xin char *));
__ANNOTATION(SAL_volatile(void));
__ANNOTATION(SAL_nonvolatile(void));
__ANNOTATION(SAL_nullTerminated(enum __SAL_YesNo));



#define ___group(annotes)													\
	__declspec("SAL_begin") annotes __drv_declspec("SAL_end")

#define ___nop(x) x

#define __static_context(ctx, annotes)										\
	__declspec("SAL_context(" SPECSTRINGIZE(ctx)")") ___group(___nop(annotes))

#define __failure(x) __static_context(SAL_return_convention,			\
	__declspec("SAL_failure(" SPECSTRINGIZE(x) ")"))
// __success should look like that when we can override it; in the meantime
// the parser allows it in POST.

#define __applyTo_return(annotes) 											\
	__static_context(SAL_return_convention, annotes )

#define __on_failure(annotes) 												\
	__static_context(SAL_failed, __post ___group(annotes) )

enum __SAL_failureKind{__failureUnspecified = 0, __failureUndefined = 1};

__ANNOTATION(SAL_failureDefault(enum __SAL_failureKind));
#define __failureDefault(kind) __static_context(SAL_return_convention,	\
	__declspec("SAL_failureDefault(" SPECSTRINGIZE(kind) ")"))

__ANNOTATION(SAL_valueUndefined());

#define __valueUndefined __declspec("SAL_valueUndefined()")

#ifdef  __cplusplus
}
#endif

#else // ][

#define __failure(x)
#define __static_context(ctx, annotes)
#define __applyTo_return(annotes) 
#define __on_failure(annotes)
#define __failureDefault(kind)
#define __valueUndefined

#endif // ]

#endif // ]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sphelper.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*******************************************************************************/
#ifndef SPHelper_h
#define SPHelper_h

#ifndef _INC_MALLOC
#include <malloc.h>
#endif


#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef __sapiddk_h__
#include <sapiddk.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_MMSYSTEM
#include <mmsystem.h>
#endif

#ifndef __comcat_h__
#include <comcat.h>
#endif

#ifndef _INC_MMREG
#include <mmreg.h>
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#include <wchar.h>
#include <tchar.h>

#include <strsafe.h>
#include <intsafe.h>

#ifndef _PREFAST_ 
#pragma warning(disable:4068) 
#endif

#ifndef REG_MUI_STRING_TRUNCATE
#define REG_MUI_STRING_TRUNCATE     0x00000001
#endif

//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))

/*** CSpDynamicString helper class
*
*/
class CSpDynamicString 
{
public:

    WCHAR *     m_psz;
    CSpDynamicString()
    {
        m_psz = NULL;
    }
    CSpDynamicString(ULONG cchReserve)
    {
        ULONGLONG ullAllocSize = (ULONGLONG) cchReserve * sizeof(WCHAR);
        if ((ullAllocSize > cchReserve) && ((ULONG) ullAllocSize == ullAllocSize))
        {
            m_psz = (WCHAR *)::CoTaskMemAlloc((ULONG)ullAllocSize);
        }
    }
    WCHAR * operator=(const CSpDynamicString& src)
    {
        if(this != &src)
        {
            _ASSERT((m_psz == NULL) || (m_psz != src.m_psz));
            ::CoTaskMemFree(m_psz);
            m_psz = src.Copy();
        }
        return m_psz;
    }
    WCHAR * operator=(const WCHAR * pSrc)
    {
        if(pSrc != m_psz)
        {
            Clear();
            if (pSrc)
            {
                size_t cbNeeded = (wcslen(pSrc) + 1) * sizeof(WCHAR);
                
                if (cbNeeded == (ULONG) cbNeeded)
                {
                    m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
                    if (m_psz == NULL)
                    {
                        SetLastError(ERROR_OUTOFMEMORY);
                    }
                    else
                    {
                        memcpy(m_psz, pSrc, cbNeeded);
                    }
                }
            }
        }
        return m_psz;
    }

    WCHAR * operator=(const char * pSrc)
    {
        Clear();
        if (pSrc)
        {
            size_t cbNeeded = (::lstrlenA(pSrc) + 1) * sizeof(WCHAR);
            if ((ULONG) cbNeeded == cbNeeded)
            {
                m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
                if (m_psz == NULL)
                {
                    SetLastError(ERROR_OUTOFMEMORY);
                }
                else
                {
                    ::MultiByteToWideChar(CP_ACP, 0, pSrc, -1, m_psz, (ULONG) cbNeeded/sizeof(WCHAR));
                }
            }
        }
        return m_psz;
    }

    WCHAR * operator=(REFGUID rguid)
    {
        Clear();
        ::StringFromCLSID(rguid, &m_psz);
        return m_psz;
    }


    /*explicit*/ CSpDynamicString(const WCHAR * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const char * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const CSpDynamicString& src)
    {
        m_psz = src.Copy();
    }
    /*explicit*/ CSpDynamicString(REFGUID rguid)
    {
        ::StringFromCLSID(rguid, &m_psz);
    }


    ~CSpDynamicString()
    {
        ::CoTaskMemFree(m_psz);
    }
    unsigned int Length() const
    {
        if (m_psz == NULL)
            return 0;
        
        size_t cch = wcslen(m_psz);

        if ((unsigned int) cch != cch)
        {
            _ASSERT((unsigned int) cch == cch);    // Too long
            SetLastError(ERROR_ARITHMETIC_OVERFLOW);
            return MAXDWORD;
        }

        return (unsigned int) cch;
    }

    operator WCHAR * () const
    {
        return m_psz;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the m_psz member explicitly.
    WCHAR ** operator&()
    {
        _ASSERT(m_psz == NULL);
        return &m_psz;
    }

    // Versions of Append that return HRESULT
    HRESULT AppendHR(const WCHAR * pszSrc, const ULONG lenSrc)
    {
        HRESULT hr = S_OK;
        if (pszSrc && (lenSrc || !m_psz))
        {
            ULONG lenMe = Length();
            ULONGLONG ullcbNew = ((ULONGLONG) lenMe + lenSrc + 1) * sizeof(WCHAR);

            if (ullcbNew > ((ULONGLONG)lenMe + lenSrc + 1) && ((ULONG) ullcbNew == ullcbNew))
            {
                WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((ULONG)ullcbNew);
                if (pszNew)
                {
                    if (m_psz)  // Could append to an empty string so check...
                    {
                        if (lenMe)
                        {
                            memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                        }
                        ::CoTaskMemFree(m_psz);
                    }
                    memcpy(pszNew + lenMe, pszSrc, lenSrc * sizeof(WCHAR));
                    *(pszNew + lenMe + lenSrc) = L'\0';
                    m_psz = pszNew;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        return hr;
    }

    HRESULT AppendHR(const WCHAR * pszSrc)
    {
        HRESULT hr = S_OK;
        if (pszSrc)
        {
            size_t lenSrc = wcslen(pszSrc);
            if ((ULONG) lenSrc != lenSrc)
                return E_OUTOFMEMORY;
            
            hr = AppendHR(pszSrc, (ULONG) lenSrc);
        }
        return hr;
    }

    // Original versions of Append that do not return HRESULTs
    WCHAR * Append(const WCHAR * pszSrc)
    {
        if(pszSrc && FAILED(AppendHR(pszSrc)))
        {
            _ASSERT(FALSE);
        }
        return m_psz;
    }

    WCHAR * Append(const WCHAR * pszSrc, const ULONG lenSrc)
    {
        if(FAILED(AppendHR(pszSrc, lenSrc)))
        {
            _ASSERT(FALSE);
        }
        return m_psz;
    }

    // Version of Append2 that returns HRESULT
    HRESULT Append2HR(const WCHAR * pszSrc1, const WCHAR * pszSrc2)
    {
        HRESULT hr = S_OK;
        size_t lenSrc1 = pszSrc1 ? wcslen(pszSrc1) : 0;
        size_t lenSrc2 = pszSrc2 ? wcslen(pszSrc2) : 0;
    
        if (lenSrc1 || lenSrc2 || !m_psz)
        {
            ULONG lenMe = Length();
            size_t cbNew = (lenMe + lenSrc1 + lenSrc2 + 1) * sizeof(WCHAR);
            if ((ULONG) cbNew != cbNew)
                return E_OUTOFMEMORY;
            
            WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc(cbNew);
            if (pszNew)
            {
                if (m_psz)  // Could append to an empty string so check...
                {
                    if (lenMe)
                    {
                        memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                    }
                    ::CoTaskMemFree(m_psz);
                }
                // In both of these cases, we copy the trailing NULL so that we're sure it gets
                // there (if lenSrc2 is 0 then we better copy it from pszSrc1).
                if (lenSrc1)
                {
                    memcpy(pszNew + lenMe, pszSrc1, (lenSrc1 + 1) * sizeof(WCHAR));
                }
                if (lenSrc2)
                {
                    memcpy(pszNew + lenMe + lenSrc1, pszSrc2, (lenSrc2 + 1) * sizeof(WCHAR));
                }
                m_psz = pszNew;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        return hr;
    }

    // Original version of Append2 that does not return HRESULT
    WCHAR * Append2(const WCHAR * pszSrc1, const WCHAR * pszSrc2)
    {
        if(FAILED(Append2HR(pszSrc1, pszSrc2)))
        {
            _ASSERT(FALSE);
        }
        return m_psz;
    }

    WCHAR * Copy() const
    {
        if (m_psz)
        {
            CSpDynamicString szNew(m_psz);
            return szNew.Detach();
        }
        return NULL;
    }
    CHAR * CopyToChar() const
    {
        if (m_psz)
        {
            CHAR* psz;
            ULONG cbNeeded = ::WideCharToMultiByte(CP_ACP, 0, m_psz, -1, NULL, NULL, NULL, NULL);
            psz = (CHAR *)::CoTaskMemAlloc(cbNeeded);
            if (psz == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
            }
            else
            {
                ::WideCharToMultiByte(CP_ACP, 0, m_psz, -1, psz, cbNeeded/sizeof(CHAR), NULL, NULL);
            }
            return psz;
        }
        return NULL;
    }
    void Attach(WCHAR __in * pszSrc)
    {
        _ASSERT(m_psz == NULL);
        m_psz = pszSrc;
    }
    WCHAR * Detach()
    {
        WCHAR * s = m_psz;
        m_psz = NULL;
        return s;
    }
    void Clear()
    {
        ::CoTaskMemFree(m_psz);
        m_psz = NULL;
    }
    bool operator!() const
    {
        return (m_psz == NULL);
    }
    HRESULT CopyToBSTR(BSTR * pbstr)
    {
        if (m_psz)
        {
            *pbstr = ::SysAllocString(m_psz);
            if (*pbstr == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            *pbstr = NULL;
        }
        return S_OK;
    }
    void TrimToSize(ULONG ulNumChars)
    {
        if (m_psz && ulNumChars < Length())
        {
            m_psz[ulNumChars] = 0;
        }
    }
    WCHAR * Compact()
    {
        if (m_psz)
        {
            ULONG cch = (ULONG) wcslen(m_psz);
            m_psz = (WCHAR *)::CoTaskMemRealloc(m_psz, (cch + 1) * sizeof(WCHAR));
        }
        return m_psz;
    }
    WCHAR * ClearAndGrowTo(ULONG cch)
    {
        if (m_psz)
        {
            Clear();
        }
        
        ULONGLONG ullcbNew = (ULONGLONG) cch * sizeof(WCHAR);
        if ((ullcbNew > cch) && ((ULONG) ullcbNew == ullcbNew))
        {
            m_psz = (WCHAR *)::CoTaskMemAlloc((ULONG)ullcbNew);
            if (m_psz)
            {
                memset(m_psz, 0, (ULONG)ullcbNew);
            }
        }
        
        return m_psz;
    }
    WCHAR * LTrim()
    {
        if (m_psz)
        {
            WCHAR * pszRead = m_psz;
            while (iswspace(*pszRead))
            {
                pszRead++;
            }
            if (pszRead != m_psz)
            {
                WCHAR * pszWrite = m_psz;
                size_t length = wcslen(pszWrite);
                StringCchCopyW(pszWrite, length +1, pszRead);
            }
        }
        return m_psz;
    }
    WCHAR * RTrim()
    {
        if (m_psz)
        {
            WCHAR * pszTail = m_psz + wcslen(m_psz);
            WCHAR * pszZeroTerm = pszTail;
            while (pszZeroTerm > m_psz && iswspace(pszZeroTerm[-1]))
            {
                pszZeroTerm--;
            }
            if (pszZeroTerm != pszTail)
            {
                *pszZeroTerm = '\0';
            }
        }
        return m_psz;        
    }
    WCHAR * TrimBoth()
    {
        RTrim();
        return LTrim();
    }
};



//
//  Simple inline function converts a ulong to a hex string.
//
inline void SpHexFromUlong(__out_ecount (9) WCHAR * psz, ULONG ul)
{
    // If for some reason we cannot convert a number, set it to 0

#ifndef UNDER_CE
    if (_ultow_s(ul, psz, 9, 16))
    {
        psz[0] = L'0';
        psz[1] = 0;
    }
#else
    if (psz != NULL)
    {
        psz[0] = L'0';
        psz[1] = 0;
        _ultow(ul, psz, 16);
    }
#endif
}


inline HRESULT SpULongFromHex(const WCHAR *psz, unsigned *pResult)
{
    HRESULT hr = S_OK;
    *pResult = 0;
    size_t cLen = wcslen (psz);

    if (cLen > 8)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // Convert the token to its numeral form in a WCHAR
        bool fFirst = true;

        for (size_t i = 0; i < cLen; i++)
        {
            int k = tolower (*psz);
            if (k >= L'a')
            {
                k = 10 + k - L'a';
            }
            else
            {
                if (k <= L'9')
                {
                    k -= L'0';
                }
                else
                {
                    // character in the range ':' .. '@'
                    k = -1;
                }
            }

            if (k < 0 || k > 15)
            {
                hr = E_FAIL;
                break;
            }
            if (fFirst)
                fFirst = false;
            else
                *pResult <<= 4;

            *pResult += (unsigned) k;
            psz++;
        }
    }

    return hr;
} 

//=== Token helpers

inline HRESULT SpGetTokenFromId(
    const WCHAR * pszTokenId, 
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = cpToken.CoCreateInstance(CLSID_SpObjectToken);
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetId(NULL, pszTokenId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppToken = cpToken.Detach();
    }
    
    return hr;
}

inline HRESULT SpGetCategoryFromId(
    const WCHAR * pszCategoryId,
    ISpObjectTokenCategory ** ppCategory,
    BOOL fCreateIfNotExist = FALSE)
{
    HRESULT hr;
    
    CComPtr<ISpObjectTokenCategory> cpTokenCategory;
    hr = cpTokenCategory.CoCreateInstance(CLSID_SpObjectTokenCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpTokenCategory->SetId(pszCategoryId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppCategory = cpTokenCategory.Detach();
    }
    
    return hr;
}

inline HRESULT SpGetDefaultTokenIdFromCategoryId(
    const WCHAR * pszCategoryId,
    __deref_out WCHAR ** ppszTokenId)
{
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->GetDefaultTokenId(ppszTokenId);
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenIdForCategoryId(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenId)
{
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->SetDefaultTokenId(pszTokenId);
    }

    return hr;
}

inline HRESULT SpGetDefaultTokenFromCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken ** ppToken,
    BOOL fCreateCategoryIfNotExist = TRUE)
{
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, fCreateCategoryIfNotExist);

    if (SUCCEEDED(hr))
    {
        WCHAR * pszTokenId;
        hr = cpCategory->GetDefaultTokenId(&pszTokenId);
        if (SUCCEEDED(hr))
        {
            hr = SpGetTokenFromId(pszTokenId, ppToken);
            ::CoTaskMemFree(pszTokenId);
        }
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenForCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken * pToken)
{
    HRESULT hr;

    WCHAR * pszTokenId;
    hr = pToken->GetId(&pszTokenId);

    if (SUCCEEDED(hr))
    {
        hr = SpSetDefaultTokenIdForCategoryId(pszCategoryId, pszTokenId);
        ::CoTaskMemFree(pszTokenId);
    }

    return hr;
}

inline HRESULT SpSetCommonTokenData(
    ISpObjectToken * pToken,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpDataKey ** ppDataKeyAttribs)
{
    HRESULT hr = S_OK;
    
    // Set the new token's CLSID (if specified)
    if (SUCCEEDED(hr) && pclsid)
    {
        CSpDynamicString dstrClsid;
        hr = StringFromCLSID(*pclsid, &dstrClsid);
    
        if (SUCCEEDED(hr))
        {
            hr = pToken->SetStringValue(SPTOKENVALUE_CLSID, dstrClsid);
        }
    }

    // Set the token's lang independent name
    if (SUCCEEDED(hr) && pszLangIndependentName)
    {
        hr = pToken->SetStringValue(NULL, pszLangIndependentName);
    }

    // Set the token's lang dependent name
    if (SUCCEEDED(hr) && pszLangDependentName)
    {
        WCHAR szLangId[10];
        StringCbPrintfW (szLangId, sizeof (szLangId), L"%x", langid);

        hr = pToken->SetStringValue(szLangId, pszLangDependentName);
    }

    // Open the attributes key if requested
    if (SUCCEEDED(hr) && ppDataKeyAttribs)
    {
        hr = pToken->CreateKey(L"Attributes", ppDataKeyAttribs);
    }

    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszTokenId,
    ISpObjectToken ** ppToken)
{
    HRESULT hr;

    // Forcefully create the token
    hr = SpGetTokenFromId(pszTokenId, ppToken, TRUE);
    
    return hr;
}

inline HRESULT SPCoCreateGuid(GUID *pGuid)
{
    HRESULT hr = S_OK;

    hr = CoCreateGuid(pGuid);
    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    ISpObjectToken ** ppToken)
{
    HRESULT hr;

    // Forcefully create the category
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, TRUE);

    // Come up with a token key name if one wasn't specified
    CSpDynamicString dstrTokenKeyName;
    if (SUCCEEDED(hr))
    {
        if (pszTokenKeyName == NULL)
        {
            GUID guidTokenKeyName;
            hr = SPCoCreateGuid(&guidTokenKeyName);

            if (SUCCEEDED(hr))
            {
                hr = StringFromCLSID(guidTokenKeyName, &dstrTokenKeyName);
            }

            if (SUCCEEDED(hr))
            {
                pszTokenKeyName = dstrTokenKeyName;
            }
        }
    }

    // Build the token id
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = pszCategoryId;
        dstrTokenId.Append2(L"\\Tokens\\", pszTokenKeyName);
    }

    // Forcefully create the token
    if (SUCCEEDED(hr))
    {
        hr = SpGetTokenFromId(dstrTokenId, ppToken, TRUE);
    }
    
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszCategoryId, pszTokenKeyName, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszTokenId,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszTokenId, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    return hr;
}

inline HRESULT SpEnumTokens(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    HRESULT hr = S_OK;
    
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->EnumTokens(
                    pszReqAttribs,
                    pszOptAttribs,
                    ppEnum);
    }
    
    return hr;
}

inline HRESULT SpFindBestToken(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    ISpObjectToken **ppObjectToken)
{
    HRESULT hr = S_OK;
    
    const WCHAR *pszVendorPreferred = L"VendorPreferred";
    const ULONG ulLenVendorPreferred = (ULONG) wcslen(pszVendorPreferred);

    // append VendorPreferred to the end of pszOptAttribs to force this preference
    ULONG ulLen;
    if (pszOptAttribs)
    {
        hr = ULongAdd((ULONG)wcslen(pszOptAttribs), ulLenVendorPreferred, &ulLen);
        if (SUCCEEDED(hr))
        {
            hr = ULongAdd(ulLen, 1 + 1, &ulLen); // including 1 char here for null terminator
        }
    }
    else
    {
        hr = ULongAdd(ulLenVendorPreferred, 1, &ulLen); // including 1 char here for null terminator
    }
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR *pszOptAttribsVendorPref = new WCHAR[ulLen];
        if (pszOptAttribsVendorPref)
        {
            if (pszOptAttribs)
            {
                StringCchCopyW (pszOptAttribsVendorPref, ulLen, pszOptAttribs);
                StringCchCatW (pszOptAttribsVendorPref, ulLen, L";");
                StringCchCatW (pszOptAttribsVendorPref, ulLen, pszVendorPreferred);
            }
            else
            {
                StringCchCopyW (pszOptAttribsVendorPref, ulLen, pszVendorPreferred);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CComPtr<IEnumSpObjectTokens> cpEnum;
        if (SUCCEEDED(hr))
        {
            hr = SpEnumTokens(pszCategoryId, pszReqAttribs, pszOptAttribsVendorPref, &cpEnum);
        }

        delete[] pszOptAttribsVendorPref;

        if (SUCCEEDED(hr))
        {
            hr = cpEnum->Next(1, ppObjectToken, NULL);
            if (hr == S_FALSE)
            {
                *ppObjectToken = NULL;
                hr = SPERR_NOT_FOUND;
            }
        }
    }

    return hr;
}

template<class T>
HRESULT SpCreateObjectFromToken(ISpObjectToken * pToken, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    HRESULT hr;

    hr = pToken->CreateInstance(pUnkOuter, dwClsCtxt, __uuidof(T), (void **)ppObject);
    
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromTokenId(const WCHAR * pszTokenId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    
    ISpObjectToken * pToken;
    HRESULT hr = SpGetTokenFromId(pszTokenId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    return hr;
}

template<class T>
HRESULT SpCreateDefaultObjectFromCategoryId(const WCHAR * pszCategoryId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
   
    ISpObjectToken * pToken;
    HRESULT hr = SpGetDefaultTokenFromCategoryId(pszCategoryId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    return hr;
}

template<class T>
HRESULT SpCreateBestObject(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    T ** ppObject,
    IUnknown * pUnkOuter = NULL, 
    DWORD dwClsCtxt = CLSCTX_ALL)
{
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = SpFindBestToken(pszCategoryId, pszReqAttribs, pszOptAttribs, &cpToken);

    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    return hr;
}

inline HRESULT SpCreatePhoneConverter(
    LANGID LangID,
    const WCHAR * pszReqAttribs,
    const WCHAR * pszOptAttribs,
    ISpPhoneConverter ** ppPhoneConverter)
{
    HRESULT hr = SPERR_NOT_FOUND;

    // If not IPA or UPS
    if (LangID != 0)
    {
        CSpDynamicString dstrReqAttribs;
        if (pszReqAttribs)
        {
            dstrReqAttribs = pszReqAttribs;
            dstrReqAttribs.Append(L";");
        }

        WCHAR szLang[MAX_PATH];

        SpHexFromUlong(szLang, LangID);

        WCHAR szLangCondition[MAX_PATH];
        StringCchCopyW(szLangCondition, MAX_PATH, L"Language=");
        StringCchCatW(szLangCondition, MAX_PATH, szLang);

        dstrReqAttribs.Append(szLangCondition);

        hr = SpCreateBestObject(SPCAT_PHONECONVERTERS, dstrReqAttribs, pszOptAttribs, ppPhoneConverter);
    }

#if _SAPI_VER >= 0x053
    // If we cannot find a phone converter, use the Universal Phone Converter as default
    if (hr == SPERR_NOT_FOUND)
    {
        hr =  CoCreateInstance(CLSID_SpPhoneConverter, NULL, CLSCTX_ALL, IID_ISpPhoneConverter, (LPVOID*)ppPhoneConverter);

        if (SUCCEEDED(hr))
        {
            ISpPhoneticAlphabetSelection * pAlphabetSelection = NULL;
            hr = (*ppPhoneConverter)->QueryInterface(IID_ISpPhoneticAlphabetSelection, (LPVOID*) &pAlphabetSelection);
            if (SUCCEEDED(hr))
            {
                hr = pAlphabetSelection->SetAlphabetToUPS(TRUE);
                pAlphabetSelection->Release();
            }
            else
            {
                // We cannot query for the new interface, reset the error code
                hr = SPERR_NOT_FOUND;
            }

            if (FAILED(hr))
            {
                (*ppPhoneConverter)->Release();
                *ppPhoneConverter = NULL;
            }
        }
    }
#endif
    return hr;
}

inline HRESULT SpGetLanguageFromToken(ISpObjectToken * pToken, LANGID * plangid)
{
    HRESULT hr = S_OK;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = pToken->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpDataKeyAttribs);

    CSpDynamicString dstrLanguage;
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->GetStringValue(L"Language", &dstrLanguage);
    }

    if (SUCCEEDED(hr))
    {
        const WCHAR *pszLangId = dstrLanguage;
        WCHAR achHexNumber [5]; // LangIds cannot be more than 4 characters longs

        // check if the langid is in the format "409;9" - extract the "409" in this case
        const WCHAR *pSemiColon = wcschr (pszLangId, L';');
        if (pSemiColon)
        {
            size_t cLen = pSemiColon - dstrLanguage;
            if (cLen <= 4)
            {
                StringCbCopyNW (achHexNumber, sizeof (achHexNumber), dstrLanguage, cLen * sizeof (achHexNumber [0]));
                pszLangId = achHexNumber;
            }
        }
        unsigned langid;
        if (FAILED (SpULongFromHex(pszLangId, &langid)))
        {
            hr = SPERR_INVALID_TOKEN_ID;
        }
        else
        {
            *plangid = (LANGID) langid;
        }
    }

    return hr;
}

inline HRESULT SpGetLanguageFromVoiceToken(ISpObjectToken * pToken, LANGID * plangid)
{
    return SpGetLanguageFromToken(pToken, plangid);
}


/****************************************************************************
* SpHrFromWin32 *
*---------------*
*   Description:
*       This inline function works around a basic problem with the macro
*   HRESULT_FROM_WIN32.  The macro forces the expresion in ( ) to be evaluated
*   two times.  By using this inline function, the expression will only be
*   evaluated once.
*
*   Returns:
*       HRESULT of converted Win32 error code
*
*****************************************************************************/

inline HRESULT SpHrFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}


/****************************************************************************
* SpHrFromLastWin32Error *
*------------------------*
*   Description:
*       This simple inline function is used to return a converted HRESULT
*   from the Win32 function ::GetLastError.  Note that using HRESULT_FROM_WIN32
*   will evaluate the error code twice so we don't want to use:
*
*       HRESULT_FROM_WIN32(::GetLastError()) 
*
*   since that will call GetLastError twice.
*
*   Returns:
*       HRESULT for ::GetLastError(). If the HRESULT is a success code, this 
*       function will return E_FAIL to guarantee an error return code.
*
*****************************************************************************/

inline HRESULT SpHrFromLastWin32Error()
{
    HRESULT hr = SpHrFromWin32(::GetLastError());
    return FAILED(hr) ? hr : E_FAIL;
}


/****************************************************************************
* SpGetUserDefaultUILanguage *
*----------------------------*
*   Description:
*       Now that we only support XP & Above, this is a straight call to
*       GetUserDefaultUILanguage
*
*   Returns:
*       Default UI language
*
*****************************************************************************/

inline LANGID SpGetUserDefaultUILanguage(void) 
{
    return GetUserDefaultUILanguage() ;
}

inline HRESULT SpGetDescription(ISpObjectToken * pObjToken, __deref_out WCHAR ** ppszDescription, LANGID Language = SpGetUserDefaultUILanguage())
{
    WCHAR szLangId[10];
    HRESULT hr = S_OK;

#if _SAPI_VER >= 0x053
    WCHAR* pRegKeyPath = 0;
    WCHAR* pszTemp = 0;
    HKEY   Handle = NULL;

    // Windows Vista does not encourage localized strings in the registry
    // When running on Windows Vista query the localized engine name from a resource dll
    OSVERSIONINFO ver;
    ver.dwOSVersionInfoSize = sizeof( ver );

    if (ppszDescription == NULL)
    {
        return E_POINTER;
    }
    *ppszDescription = NULL;

    if( ( ::GetVersionEx( &ver ) == TRUE ) && ( ver.dwMajorVersion >= 6 ) )
    {
        // If we reach this code we are running under Windows Vista
        HMODULE hmodAdvapi32Dll = NULL;
        typedef HRESULT (WINAPI* LPFN_RegLoadMUIStringW)(HKEY, LPCWSTR, LPWSTR, DWORD, LPDWORD, DWORD, LPCWSTR);
        LPFN_RegLoadMUIStringW pfnRegLoadMUIStringW = NULL;
                
        // Delay bind with RegLoadMUIStringW since this function is not supported on previous versions of advapi32.dll
        // RegLoadMUIStringW is supported only on advapi32.dll that ships with Windows Vista  and above
        // Calling RegLoadMUIStringW directly makes the loader try to resolve the function reference at load time which breaks,
        // hence we manually load advapi32.dll, query for the function pointer and invoke it.
        hmodAdvapi32Dll = ::LoadLibrary(TEXT("advapi32.dll"));
        if(hmodAdvapi32Dll)
        {
#ifdef UNDER_CE
            pfnRegLoadMUIStringW = (LPFN_RegLoadMUIStringW) ::GetProcAddress(hmodAdvapi32Dll, L"RegLoadMUIStringW");
#else
            pfnRegLoadMUIStringW = (LPFN_RegLoadMUIStringW) ::GetProcAddress(hmodAdvapi32Dll, "RegLoadMUIStringW");
#endif
            if (!pfnRegLoadMUIStringW)
            {
                // This should not happen in Vista
                _ASSERT (pfnRegLoadMUIStringW);
                hr = TYPE_E_DLLFUNCTIONNOTFOUND;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pObjToken->GetId(&pszTemp);
        }

        if (SUCCEEDED(hr))
        {
            LONG   lErrorCode = ERROR_SUCCESS;

            pRegKeyPath = wcschr(pszTemp, L'\\');   // Find the first occurance of '\\' in the absolute registry key path
            if(pRegKeyPath)
            {
                *pRegKeyPath = L'\0';
                pRegKeyPath++;                         // pRegKeyPath now points to the path to the recognizer token under the HKLM or HKCR hive
                *ppszDescription = 0;

                // Open the registry key for read and get the handle
                if (wcsncmp(pszTemp, L"HKEY_LOCAL_MACHINE", MAX_PATH) == 0)
                {
                    lErrorCode = RegOpenKeyExW(HKEY_LOCAL_MACHINE, pRegKeyPath, 0, KEY_QUERY_VALUE, &Handle);
                }
                else if (wcsncmp(pszTemp, L"HKEY_CURRENT_USER", MAX_PATH) == 0)
                {
                    lErrorCode = RegOpenKeyExW(HKEY_CURRENT_USER, pRegKeyPath, 0, KEY_QUERY_VALUE, &Handle);
                }
                else
                {
                    lErrorCode = ERROR_BAD_ARGUMENTS;
                }
                
                // Use MUI RegLoadMUIStringW API to load the localized string
                if(ERROR_SUCCESS == lErrorCode)
                {
                    *ppszDescription = (WCHAR*) CoTaskMemAlloc(MAX_PATH * sizeof(WCHAR)); // This should be enough memory to allocate the localized Engine Name
                    lErrorCode = (*pfnRegLoadMUIStringW) (Handle, SR_LOCALIZED_DESCRIPTION, *ppszDescription, MAX_PATH * sizeof(WCHAR), NULL, REG_MUI_STRING_TRUNCATE, NULL);
                }
            }
            else
            {
                // pRegKeyPath should never be 0 if we are querying for relative hkey path
                lErrorCode = ERROR_BAD_ARGUMENTS;
            }

            hr = HRESULT_FROM_WIN32(lErrorCode);
        }

        // Close registry key handle
        if(Handle)
        {
            RegCloseKey(Handle);
        }
        // Free memory allocated to locals
        if(pszTemp)
        {
            CoTaskMemFree(pszTemp);
        }
        if (hmodAdvapi32Dll)
        {
            ::FreeLibrary(hmodAdvapi32Dll);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }

    _ASSERT(FAILED(hr) || *ppszDescription != NULL);

    // If running on OSes released before Windows Vista query the localized string from the registry
    // If RegLoadMUIStringW failed to retrieved the localized Engine name retrieve the localized string from the fallback (Default) attribute
#else
    hr = E_FAIL;
#endif // _SAPI_VER >= 0x053
    if (FAILED(hr))
    {
        // Free memory allocated above if necessary
        if (*ppszDescription != NULL)
        {
            CoTaskMemFree(*ppszDescription);
            *ppszDescription = NULL;
        }

        SpHexFromUlong(szLangId, Language);
        hr = pObjToken->GetStringValue(szLangId, ppszDescription);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = pObjToken->GetStringValue(NULL, ppszDescription);
        }
    }

    return hr;
}


inline HRESULT SpSetDescription(ISpObjectToken * pObjToken, const WCHAR * pszDescription, LANGID Language = SpGetUserDefaultUILanguage(), BOOL fSetLangIndependentId = TRUE)
{
    WCHAR szLangId[10];
    SpHexFromUlong(szLangId, Language);
    HRESULT hr = pObjToken->SetStringValue(szLangId, pszDescription);
    if (SUCCEEDED(hr) && fSetLangIndependentId)
    {
        hr = pObjToken->SetStringValue(NULL, pszDescription);
    }
    return hr;
}

/****************************************************************************
* SpConvertStreamFormatEnum *
*---------------------------*
*   Description:
*       This method converts the specified stream format into a wave format
*   structure.
*
*****************************************************************************/
inline HRESULT SpConvertStreamFormatEnum(SPSTREAMFORMAT eFormat, GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    HRESULT hr = S_OK;

    if(pFormatId==NULL || ppCoMemWaveFormatEx==NULL)
    {
        return E_INVALIDARG;
    }

    const GUID * pFmtGuid = &GUID_NULL;     // Assume failure case
    if( eFormat >= SPSF_8kHz8BitMono && eFormat <= SPSF_48kHz16BitStereo )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        *ppCoMemWaveFormatEx = pwfex;
        if (pwfex)
        {
            DWORD dwIndex = eFormat - SPSF_8kHz8BitMono;
            BOOL bIsStereo = dwIndex & 0x1;
            BOOL bIs16 = dwIndex & 0x2;
            DWORD dwKHZ = (dwIndex & 0x3c) >> 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 };
            pwfex->wFormatTag = WAVE_FORMAT_PCM;
            pwfex->nChannels = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->wBitsPerSample = 8;
            if (bIs16)
            {
                pwfex->wBitsPerSample *= 2;
                pwfex->nBlockAlign *= 2;
            }
                pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( eFormat == SPSF_TrueSpeech_8kHz1BitMono )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 32;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, NumBytes );
            pwfex->wFormatTag      = WAVE_FORMAT_DSPGROUP_TRUESPEECH;
            pwfex->nChannels       = 1;
            pwfex->nSamplesPerSec  = 8000;
            pwfex->nAvgBytesPerSec = 1067;
            pwfex->nBlockAlign     = 32;
            pwfex->wBitsPerSample  = 1;
            pwfex->cbSize          = 32;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            pExtra[0] = 1;
            pExtra[2] = 0xF0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_CCITT_ALaw_8kHzMono    ) &&
             (eFormat <= SPSF_CCITT_ALaw_44kHzStereo ) )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, sizeof(WAVEFORMATEX) );
            DWORD dwIndex = eFormat - SPSF_CCITT_ALaw_8kHzMono;
            DWORD dwKHZ = dwIndex / 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            BOOL bIsStereo    = dwIndex & 0x1;
            pwfex->wFormatTag = WAVE_FORMAT_ALAW;
            pwfex->nChannels  = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->wBitsPerSample  = 8;
            pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize          = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_CCITT_uLaw_8kHzMono    ) &&
             (eFormat <= SPSF_CCITT_uLaw_44kHzStereo ) )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, sizeof(WAVEFORMATEX) );
            DWORD dwIndex = eFormat - SPSF_CCITT_uLaw_8kHzMono;
            DWORD dwKHZ = dwIndex / 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            BOOL bIsStereo    = dwIndex & 0x1;
            pwfex->wFormatTag = WAVE_FORMAT_MULAW;
            pwfex->nChannels  = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->wBitsPerSample  = 8;
            pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize          = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_ADPCM_8kHzMono    ) &&
             (eFormat <= SPSF_ADPCM_44kHzStereo ) )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 32;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            //--- Some of these values seem odd. We used what the codec told us.
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            static const DWORD BytesPerSec[] = { 4096, 8192, 5644, 11289, 11155, 22311, 22179, 44359 };
            static const DWORD BlockAlign[]  = { 256, 256, 512, 1024 };
            static const BYTE Extra811[32] =
            {
                0xF4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE Extra22[32] =
            {
                0xF4, 0x03, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE Extra44[32] =
            {
                0xF4, 0x07, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE* Extra[4] = { Extra811, Extra811, Extra22, Extra44 };
            memset( pwfex, 0, NumBytes );
            DWORD dwIndex  = eFormat - SPSF_ADPCM_8kHzMono;
            DWORD dwKHZ    = dwIndex / 2;
            BOOL bIsStereo = dwIndex & 0x1;
            pwfex->wFormatTag      = WAVE_FORMAT_ADPCM;
            pwfex->nChannels       = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec =  (dwKHZ < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwKHZ] : adwKHZ[0];
            pwfex->nAvgBytesPerSec = (dwIndex < sizeof(BytesPerSec)/sizeof(BytesPerSec[0])) ? BytesPerSec[dwIndex] : BytesPerSec[0];
            pwfex->nBlockAlign     = (WORD)(((dwKHZ < sizeof(BlockAlign)/sizeof(BlockAlign[0])) ? BlockAlign[dwKHZ] : BlockAlign[0]) * pwfex->nChannels);
            pwfex->wBitsPerSample  = 4;
            pwfex->cbSize          = 32;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            memcpy( pExtra, (dwKHZ < sizeof(Extra)/sizeof(Extra[0])) ? Extra[dwKHZ] : Extra[0], 32 );
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_GSM610_8kHzMono    ) &&
             (eFormat <= SPSF_GSM610_44kHzMono ) )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 2;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            //--- Some of these values seem odd. We used what the codec told us.
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            static const DWORD BytesPerSec[] = { 1625, 2239, 4478, 8957 };
            memset( pwfex, 0, NumBytes );
            DWORD dwIndex          = eFormat - SPSF_GSM610_8kHzMono;
            pwfex->wFormatTag      = WAVE_FORMAT_GSM610;
            pwfex->nChannels       = 1;
            pwfex->nSamplesPerSec = (dwIndex < sizeof(adwKHZ)/sizeof(adwKHZ[0])) ? adwKHZ[dwIndex] : adwKHZ[0];
            pwfex->nAvgBytesPerSec = BytesPerSec[dwIndex];
            pwfex->nBlockAlign     = 65;
            pwfex->wBitsPerSample  = 0;
            pwfex->cbSize          = 2;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            pExtra[0] = 0x40;
            pExtra[1] = 0x01;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppCoMemWaveFormatEx = NULL;
        switch (eFormat)
        {
        case SPSF_NoAssignedFormat:
            break;
        case SPSF_Text:
            pFmtGuid = &SPDFID_Text;
            break;
        default:
            hr = E_INVALIDARG;
            break;
        }
    }
    *pFormatId = *pFmtGuid;
    return hr;
}

class CSpStreamFormat
{
public:
    GUID            m_guidFormatId;
    WAVEFORMATEX  * m_pCoMemWaveFormatEx; 


    static HRESULT CoMemCopyWFEX(const WAVEFORMATEX * pSrc, WAVEFORMATEX ** ppCoMemWFEX)
    {
        if (pSrc == NULL ||
            pSrc->nAvgBytesPerSec == 0 ||
            pSrc->nBlockAlign == 0 ||
            pSrc->nChannels == 0) // There are other fields like wBitsPerSample but these can be zero in some formats.
        {
            return E_INVALIDARG;
        }

        ULONG cb = sizeof(WAVEFORMATEX);
        if (pSrc->wFormatTag != WAVE_FORMAT_PCM)
        {
            // Add the extra data size in but ignore for WAVE_FORMAT_PCM {accoring to MSDN this should be ignored}.
            cb += pSrc->cbSize;
            if (cb < pSrc->cbSize)
            {
                return E_INVALIDARG;
            }
        }

        *ppCoMemWFEX = (WAVEFORMATEX *)::CoTaskMemAlloc(cb);
        if (*ppCoMemWFEX)
        {
            memcpy(*ppCoMemWFEX, pSrc, cb);
            if ((*ppCoMemWFEX)->wFormatTag == WAVE_FORMAT_PCM)
            {
                (*ppCoMemWFEX)->cbSize = 0; // Always set cbSize to zero for WAVE_FORMAT_PCM.
            }
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }


    CSpStreamFormat()
    {
        m_guidFormatId = GUID_NULL;
        m_pCoMemWaveFormatEx = NULL;
    }

    CSpStreamFormat(SPSTREAMFORMAT eFormat, HRESULT * phr)
    {
        *phr = SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    CSpStreamFormat(const WAVEFORMATEX * pWaveFormatEx, HRESULT * phr)
    {
        _ASSERT(pWaveFormatEx);
        *phr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(*phr) ? SPDFID_WaveFormatEx : GUID_NULL;
    }

    ~CSpStreamFormat()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
    }

    void Clear()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    const GUID & FormatId() const 
    {
        return m_guidFormatId;
    }

    const WAVEFORMATEX * WaveFormatExPtr() const
    {
        return m_pCoMemWaveFormatEx;
    }


    HRESULT AssignFormat(SPSTREAMFORMAT eFormat)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);    
        return SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    HRESULT AssignFormat(ISpStreamFormat * pStream)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        HRESULT hr = pStream->GetFormat(&m_guidFormatId, &m_pCoMemWaveFormatEx);
        if (SUCCEEDED(hr) && m_pCoMemWaveFormatEx)
        {
            if (m_pCoMemWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM)
            {
                m_pCoMemWaveFormatEx->cbSize = 0; // Always set cbSize to zero for WAVE_FORMAT_PCM.
            }
            if (m_pCoMemWaveFormatEx->nAvgBytesPerSec == 0 ||
                m_pCoMemWaveFormatEx->nBlockAlign == 0 ||
                m_pCoMemWaveFormatEx->nChannels == 0)
            {
                Clear();
                hr = E_INVALIDARG;
            }
        }
        return hr;
    }

    HRESULT AssignFormat(const WAVEFORMATEX * pWaveFormatEx)
    {
        if (pWaveFormatEx->nBlockAlign == 0)
        {
            return E_INVALIDARG;
        }
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        HRESULT hr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(hr) ? SPDFID_WaveFormatEx : GUID_NULL;
        return hr;
    }

    HRESULT AssignFormat(REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx)
    {
        HRESULT hr = S_OK;

        m_guidFormatId = rguidFormatId;
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;

        if (rguidFormatId == SPDFID_WaveFormatEx)
        {
            if (pWaveFormatEx == NULL)
            {
                hr = E_INVALIDARG;
            }
            else 
            {
                hr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
            }

            if (FAILED(hr))
            {
                m_guidFormatId = GUID_NULL;
            }
        }

        return hr;
    }


    BOOL IsEqual(REFGUID rguidFormatId, const WAVEFORMATEX * pwfex) const
    {
        if (rguidFormatId == m_guidFormatId)
        {
            if (m_pCoMemWaveFormatEx)
            {
                if (pwfex &&
                    pwfex->cbSize == m_pCoMemWaveFormatEx->cbSize &&
                    memcmp(m_pCoMemWaveFormatEx, pwfex, sizeof(WAVEFORMATEX) + pwfex->cbSize) == 0)
                {
                    return TRUE;
                }
            }
            else
            {
                return (pwfex == NULL);
            }
        }
        return FALSE;
    }



    HRESULT ParamValidateAssignFormat(REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx, BOOL fRequireWaveFormat = FALSE)
    {
        if ((pWaveFormatEx && (rguidFormatId != SPDFID_WaveFormatEx)) ||
            (fRequireWaveFormat && pWaveFormatEx == NULL))
        {
            return E_INVALIDARG;
        }
        return AssignFormat(rguidFormatId, pWaveFormatEx);
    }

    SPSTREAMFORMAT ComputeFormatEnum()
    {
        if (m_guidFormatId == GUID_NULL)
        {
            return SPSF_NoAssignedFormat;
        }
        if (m_guidFormatId == SPDFID_Text)
        {
            return SPSF_Text;
        }
        if ((m_guidFormatId != SPDFID_WaveFormatEx) || (m_pCoMemWaveFormatEx == NULL))
        {
            return SPSF_NonStandardFormat;
        }
        //
        //  It is a WAVEFORMATEX.  Now determine which type it is and convert.
        //
        DWORD dwIndex = 0;
        switch (m_pCoMemWaveFormatEx->wFormatTag)
        {
          case WAVE_FORMAT_PCM:
          {
            switch (m_pCoMemWaveFormatEx->nChannels)
            {
              case 1:
                break;
              case 2:
                dwIndex |= 1;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->wBitsPerSample)
            {
              case 8:
                break;
              case 16:
                dwIndex |= 2;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
            {
              case 48000:
                dwIndex += 4;   // Fall through
              case 44100:
                dwIndex += 4;   // Fall through
              case 32000:
                dwIndex += 4;   // Fall through
              case 24000:
                dwIndex += 4;   // Fall through
              case 22050:
                dwIndex += 4;   // Fall through
              case 16000:
                dwIndex += 4;   // Fall through
              case 12000:
                dwIndex += 4;   // Fall through
              case 11025:
                dwIndex += 4;   // Fall through
              case 8000:
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            return static_cast<SPSTREAMFORMAT>(SPSF_8kHz8BitMono + dwIndex);
          }

          case WAVE_FORMAT_DSPGROUP_TRUESPEECH:
          {
            return SPSF_TrueSpeech_8kHz1BitMono;
          }

          case WAVE_FORMAT_ALAW: // fall through
          case WAVE_FORMAT_MULAW:
          case WAVE_FORMAT_ADPCM:
          {
            switch (m_pCoMemWaveFormatEx->nChannels)
            {
              case 1:
                break;
              case 2:
                dwIndex |= 1;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            if(m_pCoMemWaveFormatEx->wFormatTag == WAVE_FORMAT_ADPCM)
            {
                if(m_pCoMemWaveFormatEx->wBitsPerSample != 4)
                {
                    return SPSF_ExtendedAudioFormat;
                }
            }
            else if(m_pCoMemWaveFormatEx->wBitsPerSample != 8)
            {
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
            {
              case 44100:
                dwIndex += 2;   // Fall through
              case 22050:
                dwIndex += 2;   // Fall through
              case 11025:
                dwIndex += 2;   // Fall through
              case 8000:
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            switch( m_pCoMemWaveFormatEx->wFormatTag )
            {
              case WAVE_FORMAT_ALAW:
                return static_cast<SPSTREAMFORMAT>(SPSF_CCITT_ALaw_8kHzMono + dwIndex);
              case WAVE_FORMAT_MULAW:
                return static_cast<SPSTREAMFORMAT>(SPSF_CCITT_uLaw_8kHzMono + dwIndex);
              case WAVE_FORMAT_ADPCM:
                return static_cast<SPSTREAMFORMAT>(SPSF_ADPCM_8kHzMono + dwIndex);
            }
          }

          case WAVE_FORMAT_GSM610:
          {
            if( m_pCoMemWaveFormatEx->nChannels != 1 )
            {
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
            {
              case 44100:
                dwIndex = 3;
                break;
              case 22050:
                dwIndex = 2;
                break;
              case 11025:
                dwIndex = 1;
                break;
              case 8000:
                dwIndex = 0;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            return static_cast<SPSTREAMFORMAT>(SPSF_GSM610_8kHzMono + dwIndex);
          }

          default:
            return SPSF_ExtendedAudioFormat;
            break;
        }
    }

    void DetachTo(CSpStreamFormat & Other)
    {
        ::CoTaskMemFree(Other.m_pCoMemWaveFormatEx);
        Other.m_guidFormatId = m_guidFormatId;
        Other.m_pCoMemWaveFormatEx = m_pCoMemWaveFormatEx;
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    void DetachTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
    {
        *pFormatId = m_guidFormatId;
        *ppCoMemWaveFormatEx = m_pCoMemWaveFormatEx;
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    HRESULT CopyTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX) const
    {
        HRESULT hr = S_OK;
        *pFormatId = m_guidFormatId;
        if (m_pCoMemWaveFormatEx)
        {
            hr = CoMemCopyWFEX(m_pCoMemWaveFormatEx, ppCoMemWFEX);
            if (FAILED(hr))
            {
                memset(pFormatId, 0, sizeof(*pFormatId));
            }
        }
        else
        {
            *ppCoMemWFEX = NULL;
        }
        return hr;
    }

    HRESULT CopyTo(CSpStreamFormat & Other) const
    {
        ::CoTaskMemFree(Other.m_pCoMemWaveFormatEx);
        return CopyTo(&Other.m_guidFormatId, &Other.m_pCoMemWaveFormatEx);
    }
    
    HRESULT AssignFormat(const CSpStreamFormat & Src)
    {
        return Src.CopyTo(*this);
    }


    HRESULT ParamValidateCopyTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX) const
    {
        if ((pFormatId == NULL) || (ppCoMemWFEX == NULL))
        {
            return E_POINTER;
        }
        return CopyTo(pFormatId, ppCoMemWFEX);
    }

    BOOL operator==(const CSpStreamFormat & Other) const
    {
        return IsEqual(Other.m_guidFormatId, Other.m_pCoMemWaveFormatEx);
    }
    BOOL operator!=(const CSpStreamFormat & Other) const
    {
        return !IsEqual(Other.m_guidFormatId, Other.m_pCoMemWaveFormatEx);
    }

    ULONG SerializeSize() const
    {
        ULONG cb = sizeof(ULONG) + sizeof(m_guidFormatId);
        if (m_pCoMemWaveFormatEx)
        {
            if (m_pCoMemWaveFormatEx->cbSize != 0 && m_pCoMemWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM)
            {
                _ASSERT(!"PCM wave format");
                SetLastError(ERROR_INVALID_STATE);
                return 0;
            }
            cb += sizeof(WAVEFORMATEX) + m_pCoMemWaveFormatEx->cbSize + 3;  // Add 3 to round up
            cb -= cb % 4;                                                   // Round to DWORD
        }
        return cb;
    }

    ULONG Serialize(BYTE * pBuffer) const
    {
        ULONG cb = SerializeSize();
        *((UNALIGNED ULONG *)pBuffer) = cb;
        pBuffer += sizeof(ULONG);
        *((UNALIGNED GUID *)pBuffer) = m_guidFormatId;
        if (m_pCoMemWaveFormatEx)
        {
            pBuffer += sizeof(m_guidFormatId);
            memcpy(pBuffer, m_pCoMemWaveFormatEx, sizeof(WAVEFORMATEX) + m_pCoMemWaveFormatEx->cbSize);
        }
        return cb;
    }

    HRESULT Deserialize(const BYTE * pBuffer, ULONG * pcbUsed)
    {
        HRESULT hr = S_OK;

        // check pointer to pBuffer for size value
        if(pBuffer == NULL || pcbUsed == NULL)
        {
            return E_INVALIDARG;
        }

        *pcbUsed = *((UNALIGNED ULONG *)pBuffer);
 
        // check complete pBuffer from start
        if(*pcbUsed < sizeof(GUID) + sizeof(ULONG))
        {
            return E_INVALIDARG;
        }

        pBuffer += sizeof(ULONG);

        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;

        memcpy(&m_guidFormatId, pBuffer, sizeof(GUID));
        if (*pcbUsed > sizeof(GUID) + sizeof(ULONG))
        {
            pBuffer += sizeof(m_guidFormatId);
            hr = CoMemCopyWFEX((const WAVEFORMATEX *)pBuffer, &m_pCoMemWaveFormatEx);
            if (FAILED(hr))
            {
                m_guidFormatId = GUID_NULL;
            }
        }
        return hr;
    }

};



// Return the default codepage given a LCID.
// Note some of the newer locales do not have associated Windows codepages.  For these, we return UTF-8.

inline UINT SpCodePageFromLcid(LCID lcid)
{
    WCHAR achCodePage[6];

    return (0 != GetLocaleInfoW(lcid, LOCALE_IDEFAULTANSICODEPAGE, achCodePage, sizeof(achCodePage) / sizeof(*achCodePage))) ? _wtoi(achCodePage) : 65001;
}


inline HRESULT SPBindToFile( LPCWSTR pFileName, SPFILEMODE eMode, ISpStream ** ppStream,
                            const GUID * pFormatId = NULL, const WAVEFORMATEX * pWaveFormatEx = NULL,
                            ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    HRESULT hr = ::CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
    if (SUCCEEDED(hr))
    {
        hr = (*ppStream)->BindToFile(pFileName, eMode, pFormatId, pWaveFormatEx, ullEventInterest);
        if (FAILED(hr))
        {
            (*ppStream)->Release();
            *ppStream = NULL;
        }
    }
    return hr;
} /* SPBindToFile */

inline HRESULT SPBindToFile( const CHAR * pFileName, SPFILEMODE eMode, ISpStream** ppStream, 
                             const GUID * pFormatId = NULL, const WAVEFORMATEX * pWaveFormatEx = NULL,
                             ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    WCHAR szWcharFileName[MAX_PATH];
    ::MultiByteToWideChar(CP_ACP, 0, pFileName, -1, szWcharFileName, sp_countof(szWcharFileName));
    return SPBindToFile(szWcharFileName, eMode, ppStream, pFormatId, pWaveFormatEx, ullEventInterest);
}

/****************************************************************************
* CheckStringSizeBytes *
*--------------*
*   Description:
*       Checks a string is not longer that the supplied size {IN BYTES}, including
*       the terminating char. If pcb is non-null then it is set to the size of 
*       the string {IN BYTES}, including the terminating char.
*
*****************************************************************************/
inline HRESULT CheckStringSizeBytes(WCHAR const * psz, size_t cbMax, size_t* pcb)
{
    HRESULT hr = S_OK;
    size_t cchMax = cbMax / sizeof(WCHAR);

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr) && pcb)
    {
        *pcb = cbMax - (cchMax - 1) * sizeof(WCHAR);
    }

    return hr;
}

/****************************************************************************
* SpClearEvent *
*--------------*
*   Description:
*       Helper function that can be used by clients that do not use the CSpEvent
*   class.
*
*   Returns:
*
*****************************************************************************/

inline void SpClearEvent(SPEVENT * pe)
{
    if( pe->elParamType != SPEI_UNDEFINED)
    {
        if( pe->elParamType == SPET_LPARAM_IS_POINTER ||
            pe->elParamType == SPET_LPARAM_IS_STRING)
        {
            ::CoTaskMemFree((void *)pe->lParam);
        }
        else if (pe->elParamType == SPET_LPARAM_IS_TOKEN ||
               pe->elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)pe->lParam)->Release();
        }
    }
    memset(pe, 0, sizeof(*pe));
}

/****************************************************************************
* SpInitEvent *
*-------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline void SpInitEvent(SPEVENT * pe)
{
    memset(pe, 0, sizeof(*pe));
}

/****************************************************************************
* SpEventSerializeSize *
*----------------------*
*   Description:
*       Computes the required size of a buffer to serialize an event.  The caller
*   must specify which type of serialized event is desired -- either SPSERIALIZEDEVENT
*   or SPSERIALIZEDEVENT64.    
*
*   Returns:
*       Size in bytes required to seriailze the event.
*
****************************************************************************/

template <class T>
inline ULONG SpEventSerializeSize(const SPEVENT * pEvent)
{
    ULONG ulSize = sizeof(T);

    if( ( pEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pEvent->lParam )
    {
        ulSize += ULONG(pEvent->wParam);
    }
    else if ((pEvent->elParamType == SPET_LPARAM_IS_STRING) && pEvent->lParam != NULL)
    {
        // Would be better to check for overflow of string length.
        ulSize += ((ULONG) wcslen((WCHAR*)pEvent->lParam) + 1) * sizeof( WCHAR );
    }
    else if( pEvent->elParamType == SPET_LPARAM_IS_TOKEN )
    {
        CSpDynamicString dstrObjectId;
        if( ((ISpObjectToken*)(pEvent->lParam))->GetId( &dstrObjectId ) == S_OK )
        {
            ulSize += (dstrObjectId.Length() + 1) * sizeof( WCHAR );
        }
        else
        {
            return 0;
        }
    }
    // Round up to nearest DWORD
    ulSize += 3;
    ulSize -= ulSize % 4;
    return ulSize;
}

/****************************************************************************
* SpSerializedEventSize *
*-----------------------*
*   Description:
*       Returns the size, in bytes, used by a serialized event.  The caller can
*   pass a pointer to either a SPSERIAILZEDEVENT or SPSERIALIZEDEVENT64 structure.
*
*   Returns:
*       Number of bytes used by serizlied event
*
*****************************************************************************/

template <class T>
inline ULONG SpSerializedEventSize(const T * pSerEvent)
{
    ULONG ulSize = sizeof(T);

    if( ( pSerEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pSerEvent->SerializedlParam )
    {
        ulSize += ULONG(pSerEvent->SerializedwParam);
    }
    else if ((pSerEvent->elParamType == SPET_LPARAM_IS_STRING || pSerEvent->elParamType == SPET_LPARAM_IS_TOKEN) &&
             pSerEvent->SerializedlParam != NULL)
    {
        ulSize += ((ULONG)wcslen((WCHAR*)(pSerEvent + 1)) + 1) * sizeof( WCHAR );
    }
    // Round up to nearest DWORD
    ulSize += 3;
    ulSize -= ulSize % 4;
    return ulSize;
}


/*** CSpEvent helper class
*
*/
class CSpEvent : public SPEVENT
{
public:
    CSpEvent()
    {
        SpInitEvent(this);
    }
    ~CSpEvent()
    {
        SpClearEvent(this);
    }
    // If you need to take the address of a CSpEvent that is not const, use the AddrOf() method
    // which will do debug checking of parameters.  If you encounter this problem when calling
    // GetEvents from an event source, you may want to use the GetFrom() method of this class.
    const SPEVENT * operator&()
        {
                return this;
        }
    CSpEvent * AddrOf()
    {
        // Note:  This method does not ASSERT since we assume the caller knows what they are doing.
        return this;
    }
    void Clear()
    {
        SpClearEvent(this);
    }
    HRESULT CopyTo(SPEVENT * pDestEvent) const
    {
        memcpy(pDestEvent, this, sizeof(*pDestEvent));
        if ((elParamType == SPET_LPARAM_IS_POINTER) && lParam)
        {
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(wParam);
            if (pDestEvent->lParam)
            {
                memcpy((void *)pDestEvent->lParam, (void *)lParam, wParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_STRING && lParam != NULL)
        {
            size_t cLen = wcslen((WCHAR*)lParam) + 1;
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(cLen * sizeof(WCHAR));
            if (pDestEvent->lParam)
            {
                StringCchCopyW ((WCHAR*)pDestEvent->lParam, cLen, (WCHAR*)lParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_TOKEN ||
               elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)lParam)->AddRef();
        }
        return S_OK;
    }

    HRESULT GetFrom(ISpEventSource * pEventSrc)
    {
        SpClearEvent(this);
        return pEventSrc->GetEvents(1, this, NULL);
    }
    HRESULT CopyFrom(const SPEVENT * pSrcEvent)
    {
        SpClearEvent(this);
        return static_cast<const CSpEvent *>(pSrcEvent)->CopyTo(this);
    }
    void Detach(SPEVENT * pDestEvent = NULL)
    {
        if (pDestEvent)
        {
            memcpy(pDestEvent, this, sizeof(*pDestEvent));
        }
        memset(this, 0, sizeof(*this));
    }

    template <class T>
    ULONG SerializeSize() const
    {
        return SpEventSerializeSize<T>(this);
    }

    // Call this method with either SPSERIALIZEDEVENT or SPSERIALIZEDEVENT64
    template <class T>
    HRESULT Serialize(T * pSerEvent) const
    {
        if (elParamType == SPET_LPARAM_IS_OBJECT)
        {
            _ASSERT(elParamType != SPET_LPARAM_IS_OBJECT);
            return E_UNEXPECTED;
        }

        HRESULT hr = S_OK;

        pSerEvent->eEventId = this->eEventId;
        pSerEvent->elParamType = this->elParamType;
        pSerEvent->ulStreamNum = this->ulStreamNum;
        pSerEvent->ullAudioStreamOffset = this->ullAudioStreamOffset;
        pSerEvent->SerializedwParam = static_cast<ULONG>(this->wParam);
        pSerEvent->SerializedlParam = static_cast<LONG>(this->lParam);
        if (lParam)
        {
            switch(elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                memcpy(pSerEvent + 1, (void *)lParam, wParam);
                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_STRING:
                StringCchCopyW ((WCHAR *)(pSerEvent + 1), wcslen ((WCHAR*) lParam) + 1, (WCHAR*)lParam);
                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    CSpDynamicString dstrObjectId;
                    hr = ((ISpObjectToken*)lParam)->GetId( &dstrObjectId );
                    if( SUCCEEDED( hr ) )
                    {
                        pSerEvent->SerializedwParam = (dstrObjectId.Length() + 1) * sizeof( WCHAR );;
                        memcpy( pSerEvent + 1, (void *)dstrObjectId.m_psz, static_cast<ULONG>(pSerEvent->SerializedwParam) );
                    }
                    pSerEvent->SerializedlParam = sizeof(T);
                }
                break;

            default:
                break;
            }
        }
        return hr;
    }

    template <class T>
    HRESULT Serialize(T ** ppCoMemSerEvent, ULONG * pcbSerEvent) const 
    {
        *pcbSerEvent = SpEventSerializeSize<T>(this);
        if (*pcbSerEvent == 0)
        {
            return E_FAIL;
        }
        *ppCoMemSerEvent = (T *)::CoTaskMemAlloc(*pcbSerEvent);
        if (*ppCoMemSerEvent)
        {
            return Serialize(*ppCoMemSerEvent);
        }
        else
        {
            *pcbSerEvent = 0;
            return E_OUTOFMEMORY;
        }
    }


    // Call this method with either SPSERIALIZEDEVENT or SPSERIALIZEDEVENT64
    template <class T>
    HRESULT Deserialize(const T * pSerEvent, ULONG * pcbUsed = NULL, ULONG cbMaxLength = 0xFFFF)
    {
        Clear();
        HRESULT hr = S_OK;
        const UNALIGNED T * pTemp = pSerEvent;
        if (cbMaxLength < sizeof(*pTemp))
        {
            return E_INVALIDARG;
        }
        size_t cbExtraSize = cbMaxLength - sizeof(*pTemp);

        this->eEventId = pTemp->eEventId;
        this->elParamType = pTemp->elParamType;
        this->ulStreamNum = pTemp->ulStreamNum;
        this->ullAudioStreamOffset = pTemp->ullAudioStreamOffset;
        this->wParam = static_cast<WPARAM>(pTemp->SerializedwParam);
        this->lParam = static_cast<LPARAM>(pTemp->SerializedlParam);


        if (pTemp->SerializedlParam)
        {
            size_t cbAlloc = 0;
            switch (pTemp->elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                cbAlloc = static_cast<ULONG>(wParam);
                if (cbAlloc > cbExtraSize)
                {
                    hr = E_INVALIDARG;
                }
                break;

            case SPET_LPARAM_IS_STRING:
                hr = CheckStringSizeBytes((WCHAR *)(pTemp + 1), cbExtraSize, &cbAlloc);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    hr = CheckStringSizeBytes((WCHAR *)(pTemp + 1), cbExtraSize, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = SpGetTokenFromId( (const WCHAR*)(pTemp + 1), (ISpObjectToken **)&lParam );
                        wParam = 0;
                    }
                }
                break;
            case SPET_LPARAM_IS_UNDEFINED:
                break;
            case SPET_LPARAM_IS_OBJECT:
                hr = E_INVALIDARG;
                break;
            default:
                hr = E_INVALIDARG;
                break;
            }

            if (SUCCEEDED(hr) && cbAlloc)
            {
                void * pvBuff = ::CoTaskMemAlloc(cbAlloc);
                this->lParam = (LPARAM)pvBuff;
                if (pvBuff)
                {
                    memcpy(pvBuff, pTemp + 1, cbAlloc);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if( SUCCEEDED( hr ) && pcbUsed )
        {
            *pcbUsed = SpEventSerializeSize<T>(this);
            if(*pcbUsed == 0)
            {
                hr = E_FAIL;
            }
        }

        // Reset the data structure on failure.  Otherwise, the destructor may AV.
        if (FAILED(hr))
        {
            memset(this, 0, sizeof(*this));
        }

        return hr;
    }

    //
    //  Helpers for access to events.  Performs run-time checks in debug and casts
    //  data to the appropriate types
    //
    SPPHONEID Phoneme() const 
    {
        _ASSERT(eEventId == SPEI_PHONEME);
        return (SPPHONEID)LOWORD(lParam);
    }
    SPVISEMES Viseme() const 
    {
        _ASSERT(eEventId == SPEI_VISEME);
        return (SPVISEMES)LOWORD(lParam);
    }
    ULONG InputWordPos() const
    {
        _ASSERT(eEventId == SPEI_WORD_BOUNDARY);
        return ULONG(lParam);
    }
    ULONG InputWordLen() const 
    {
        _ASSERT(eEventId == SPEI_WORD_BOUNDARY);
        return ULONG(wParam);
    }
    ULONG InputSentPos() const
    {
        _ASSERT(eEventId == SPEI_SENTENCE_BOUNDARY);
        return ULONG(lParam);
    }
    ULONG InputSentLen() const 
    {
        _ASSERT(eEventId == SPEI_SENTENCE_BOUNDARY);
        return ULONG(wParam);
    }
    ISpObjectToken * ObjectToken() const
    {
        _ASSERT(elParamType == SPET_LPARAM_IS_TOKEN);
        return (ISpObjectToken *)lParam;
    }
    ISpObjectToken * VoiceToken() const     // More explicit check than ObjectToken()
    {
        _ASSERT(eEventId == SPEI_VOICE_CHANGE);
        return ObjectToken();
    }
    BOOL PersistVoiceChange() const
    {
        _ASSERT(eEventId == SPEI_VOICE_CHANGE);
        return (BOOL)wParam;
    }
    IUnknown * Object() const
    {
        _ASSERT(elParamType == SPET_LPARAM_IS_OBJECT);
        return (IUnknown*)lParam;
    }
    ISpRecoResult * RecoResult() const
    {
        return (ISpRecoResult *)Object();
    }

#if _SAPI_VER >= 0x053
    ULONG RetainedAudioSize() const
    {
        _ASSERT(eEventId == SPEI_SR_RETAINEDAUDIO);
        return ULONG(wParam);
    }

    ISpStreamFormat * RetainedAudioStream() const
    {
        _ASSERT(eEventId == SPEI_SR_RETAINEDAUDIO);
        return (ISpStreamFormat *)Object();
    }
#endif

    BOOL IsPaused()
    {
        return (BOOL)(wParam & SPREF_AutoPause);
    }
    BOOL IsEmulated()
    {
        return (BOOL)(wParam & SPREF_Emulated);
    }

#if _SAPI_VER >= 0x053
    BOOL IsSMLTimeout()
    {
        return (BOOL)(wParam & SPREF_SMLTimeout);
    }
#endif

    const WCHAR * String() const
    {
        _ASSERT(elParamType == SPET_LPARAM_IS_STRING);
        return (const WCHAR*)lParam;
    }
    const WCHAR * BookmarkName() const
    {
        _ASSERT(eEventId == SPEI_TTS_BOOKMARK);
        return String();
    }
    const WCHAR * RequestTypeOfUI() const
    {
        _ASSERT(eEventId == SPEI_REQUEST_UI);
        return String();
    }
    SPRECOSTATE RecoState() const
    {
        _ASSERT(eEventId == SPEI_RECO_STATE_CHANGE);
        return static_cast<SPRECOSTATE>(wParam);
    }
    const WCHAR * PropertyName() const
    {
        _ASSERT((eEventId == SPEI_PROPERTY_NUM_CHANGE && elParamType == SPET_LPARAM_IS_STRING) ||
                     (eEventId == SPEI_PROPERTY_STRING_CHANGE && elParamType == SPET_LPARAM_IS_POINTER));
        // Note: Don't use String() method here since in the case of string attributes, the elParamType
        // field specifies LPARAM_IS_POINTER, but the attribute name IS the first string in this buffer
        return (const WCHAR*)lParam;
    }
    const LONG PropertyNumValue() const 
    {
        _ASSERT(eEventId == SPEI_PROPERTY_NUM_CHANGE);
        return static_cast<LONG>(wParam);
    }
    const WCHAR * PropertyStringValue() const
    {
        // Search for the first NULL and return pointer to the char past it.
        _ASSERT(eEventId == SPEI_PROPERTY_STRING_CHANGE);
        const WCHAR * psz = (const WCHAR *)lParam;
        for (; *psz; psz++) {}
        return psz + 1;
    }
    SPINTERFERENCE Interference() const
    {
        _ASSERT(eEventId == SPEI_INTERFERENCE);
        return static_cast<SPINTERFERENCE>(lParam);
    }
    HRESULT EndStreamResult() const
    {
        _ASSERT(eEventId == SPEI_END_SR_STREAM);
        return static_cast<HRESULT>(lParam);
    }
    BOOL InputStreamReleased() const
    {
        _ASSERT(eEventId == SPEI_END_SR_STREAM);
        return (wParam & SPESF_STREAM_RELEASED) ? TRUE : FALSE;
    }
};

class CSpPhrasePtr
{
public:
    SPPHRASE    *   m_pPhrase;
    CSpPhrasePtr() : m_pPhrase(NULL) {}
    CSpPhrasePtr(ISpPhrase * pPhraseObj, HRESULT * phr)
    {
        *phr = pPhraseObj->GetPhrase(&m_pPhrase);
    }
    ~CSpPhrasePtr()
    {
        ::CoTaskMemFree(m_pPhrase);
    }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the m_pPhrase member explicitly.
        SPPHRASE ** operator&()
        {
            _ASSERT(m_pPhrase == NULL);
            return &m_pPhrase;
        }
    operator SPPHRASE *() const
    {
        return m_pPhrase;
    }
        SPPHRASE & operator*() const
        {
                _ASSERT(m_pPhrase);
                return *m_pPhrase;
        }
    SPPHRASE * operator->() const
    {
        return m_pPhrase;
    }
        bool operator!() const
        {
                return (m_pPhrase == NULL);
        }
    void Clear()
    {
        if (m_pPhrase)
        {
            ::CoTaskMemFree(m_pPhrase);
            m_pPhrase = NULL;
        }
    }
    HRESULT GetFrom(ISpPhrase * pPhraseObj)
    {
        Clear();
        return pPhraseObj->GetPhrase(&m_pPhrase);
    }
};


template <class T>
class CSpCoTaskMemPtr
{
public:
    T       * m_pT;
    CSpCoTaskMemPtr() : m_pT(NULL) {}
    CSpCoTaskMemPtr(void * pv) : m_pT((T *)pv) {}
    CSpCoTaskMemPtr(ULONG cElements, HRESULT * phr)
    {
        m_pT = (T *)::CoTaskMemAlloc(cElements * sizeof(T));
        *phr = m_pT ? S_OK : E_OUTOFMEMORY;
    }
    ~CSpCoTaskMemPtr()
    {
        ::CoTaskMemFree(m_pT);
    }
    void Clear()
    {
        if (m_pT)
        {
            ::CoTaskMemFree(m_pT);
            m_pT = NULL;
        }
    }
    HRESULT Alloc(ULONG cArrayElements = 1)
    {
        T * pNewT = (T *)::CoTaskMemRealloc(m_pT, sizeof(T) * cArrayElements);
        if (pNewT == NULL)
        {
            // Keep the old behavior, the pointer becomes NULL if we fail above
            Clear();
            return E_OUTOFMEMORY;
        }
        else
        {
            m_pT = pNewT;
            return S_OK;
        }
    }
    void Attach(void * pv)
    {
        Clear();
        m_pT = (T *)pv;
    }
    T * Detatch()
    {
        T * pT = m_pT;
        m_pT = NULL;
        return pT;
    }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the m_pT member explicitly.
        T ** operator&()
        {
            _ASSERT(m_pT == NULL);
            return &m_pT;
        }
    T * operator->()
    {
        _ASSERT(m_pT != NULL);
        return m_pT;
    }
    operator T *()
    {
        return m_pT;
    }
        bool operator!() const
        {
                return (m_pT == NULL);
        }
};

/**** Helper function used to create a new phrase object from an array of
    test words. Each word in the string is converted to a phrase element.
    This is useful to create a phrase to pass to the EmulateRecognition method.
    The method can convert standard words as well as words with the
    "/display_text/lexical_form/pronounciation;" word format.
    You can also specify the DisplayAttributes for each element if desired. 
    If prgDispAttribs is NULL then the DisplayAttribs for each element default to 
    SPAF_ONE_TRAILING_SPACE. ****/
inline HRESULT CreatePhraseFromWordArray(const WCHAR ** ppWords, ULONG cWords,
                             SPDISPLYATTRIBUTES * prgDispAttribs,
                             ISpPhraseBuilder **ppResultPhrase,
                             LANGID LangId = 0,
                             CComPtr<ISpPhoneConverter> cpPhoneConv = NULL,
                             BOOL fNoSpecialCharacters = FALSE)
{
    HRESULT hr = S_OK;

    if ( cWords == 0 || ppWords == NULL )
    {
        return E_INVALIDARG;
    }

    size_t   cTotalChars = 0;
    ULONG    i;
    WCHAR** pStringPtrArray = (WCHAR**)::CoTaskMemAlloc( cWords * sizeof(WCHAR *));
    if ( !pStringPtrArray )
    {
        return E_OUTOFMEMORY;
    }
    for (i = 0; i < cWords; i++)
    {
        cTotalChars += wcslen(ppWords[i])+1;
    }

    if ((ULONG) cTotalChars != cTotalChars)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }

    CSpDynamicString dsText((ULONG) cTotalChars);
    if(dsText.m_psz == NULL)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }
    CSpDynamicString dsPhoneId((ULONG) cTotalChars);
    if(dsPhoneId.m_psz == NULL)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }
    SPPHONEID* pphoneId = dsPhoneId;

    SPPHRASE Phrase;
    memset(&Phrase, 0, sizeof(Phrase));
#ifdef SP_SPPHRASESIZE_500
        Phrase.cbSize = SP_SPPHRASESIZE_500;
#else
        Phrase.cbSize = sizeof(Phrase);
#endif

    if(LangId == 0)
    {
        LangId = SpGetUserDefaultUILanguage();
    }

    SPPHRASEELEMENT *pPhraseElement = new SPPHRASEELEMENT[cWords];
    if(pPhraseElement == NULL)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }
    memset(pPhraseElement, 0, sizeof(SPPHRASEELEMENT) * cWords);
    
    WCHAR * pText = dsText;
    for (i = 0; SUCCEEDED(hr) && i < cWords; i++)
    {
        WCHAR *p = pText;
        pStringPtrArray[i] = pText;

        if (ppWords[i][0] == L'/' && !fNoSpecialCharacters)
        {
            const WCHAR *pszOriginalText = ppWords[i] + 1;
            
            //This is a compound word
            WCHAR* pszFirstPart = p;
            WCHAR* pszSecondPart = NULL;
            WCHAR* pszThirdPart = NULL;

            // Find the second separator slash.
            while (*pszOriginalText)
            {
                if (*pszOriginalText == L'\\')
                {
                    pszOriginalText++;
                }
                else if (*pszOriginalText == L';' || *pszOriginalText == L'/')
                {
                    break;
                }
                *p++ = *pszOriginalText++;
            }

            if (*pszOriginalText == L'/')
            {
                // We stopped at the second '/'
                *p = L'\0';
                pszSecondPart = ++p;
                pszOriginalText++;
                while (*pszOriginalText)
                {
                    if (*pszOriginalText == L'\\')
                    {
                        pszOriginalText++;
                    }
                    else if (*pszOriginalText == L';' || *pszOriginalText == L'/')
                    {
                        break;
                    }
                    *p++ = *pszOriginalText++;
                }
                if (*pszOriginalText == L'/')
                {
                    // We stopped at the third '/'
                    *p = L'\0';
                    pszThirdPart = ++p;
                    pszOriginalText++;
                }
                
            }

            WCHAR *pBound = (WCHAR*) pszOriginalText + wcslen(pszOriginalText);
            while (pszOriginalText < pBound && *pszOriginalText != L';')
            {
                *p++ = *pszOriginalText++;
            }

            *p = L'\0';
            pText = p + 1;


            pPhraseElement[i].pszDisplayText = pszFirstPart;
            pPhraseElement[i].pszLexicalForm = pszSecondPart ? pszSecondPart : pszFirstPart;

            if (pszThirdPart && *pszThirdPart != L'\0')
            {
                if(cpPhoneConv == NULL)
                {
                    hr = SpCreatePhoneConverter(LangId, NULL, NULL, &cpPhoneConv);
                    if(FAILED(hr))
                    {
                        break;
                    }
                }

                hr = cpPhoneConv->PhoneToId(pszThirdPart, pphoneId);
                if (SUCCEEDED(hr))
                {
                    pPhraseElement[i].pszPronunciation = pphoneId;
                    pphoneId += wcslen(pphoneId) + 1;
                }
            }
        }
        else
        {
            //It is the simple format, only have one form, use it for everything.
            StringCchCopyW ( pText, cTotalChars - (pText - dsText), ppWords[i] );
            pText += wcslen( p ) + 1;

            pPhraseElement[i].pszDisplayText = NULL;
            pPhraseElement[i].pszLexicalForm = p;
            pPhraseElement[i].pszPronunciation = NULL;
        }

        pPhraseElement[i].bDisplayAttributes = (BYTE)(prgDispAttribs ? prgDispAttribs[i] : SPAF_ONE_TRAILING_SPACE);
        pPhraseElement[i].RequiredConfidence = SP_NORMAL_CONFIDENCE;
        pPhraseElement[i].ActualConfidence =  SP_NORMAL_CONFIDENCE;
        pPhraseElement[i].SREngineConfidence = 1.0f; // Emulated results give confidence of 1.0
    }

    Phrase.Rule.ulCountOfElements = cWords;
    Phrase.Rule.SREngineConfidence = 1.0f;
    Phrase.pElements = pPhraseElement;
    Phrase.LangID = LangId;

    CComPtr<ISpPhraseBuilder> cpPhrase;
    if (SUCCEEDED(hr))
    {
        hr = cpPhrase.CoCreateInstance(CLSID_SpPhraseBuilder);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpPhrase->InitFromPhrase(&Phrase);
    }
    if (SUCCEEDED(hr))
    {
        *ppResultPhrase = cpPhrase.Detach();
    }

    delete[] pPhraseElement;
    ::CoTaskMemFree(pStringPtrArray);

    return hr;
}

/**** Helper function used to create a new phrase object from a 
    test string. Each word in the string is converted to a phrase element.
    This is useful to create a phrase to pass to the EmulateRecognition method.
    The method can convert standard words as well as words with the
    "/display_text/lexical_form/pronounciation;" word format.
    If the emulation needs to match word sequence data (textbuffer) then
    the corresponding words need to be bracketed with '[' and ']' so they
    can be put into a single phrase element
    ****/
inline HRESULT CreatePhraseFromText(const WCHAR *pszOriginalText,
                             ISpPhraseBuilder **ppResultPhrase,
                             LANGID LangId = 0,
                             CComPtr<ISpPhoneConverter> cpPhoneConv = NULL,
                             BOOL fNoSpecialCharacters = FALSE)
{
    HRESULT hr = S_OK;

    //We first trim the input text
    CSpDynamicString dsText((ULONG)wcslen(pszOriginalText) + 1);
    if(dsText.m_psz == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ULONG cWords = 0;

    // Set first array pointer (if *p).
    WCHAR *p = dsText;
    while (*pszOriginalText != L'\0')
    {
        // Skip leading white spaces
        while (iswspace(*pszOriginalText))
        {
            *p++ = L'\0';
            pszOriginalText++;
        }

        // Skip over word
        if (*pszOriginalText != L'\0')
        {
            cWords++;
            if ((*pszOriginalText == L'/') && !fNoSpecialCharacters)
            {
                // Skip all non-semicolon characters and unescape escaped characters
                while (*pszOriginalText != L'\0')
                {
                    if (*pszOriginalText == L'\\')
                    {
                        *p++ = *pszOriginalText++;
                    }
                    else if (*pszOriginalText == L';')
                    {
                        break;
                    }
                    *p++ = *pszOriginalText++;
                }
                if (*pszOriginalText == L';')
                {
                    *p++ = *pszOriginalText++;
                }
            }
            else
            {
                // Skip all non-whitespace characters
                while ((*pszOriginalText != L'\0') && !iswspace(*pszOriginalText))
                {
                    *p++ = *pszOriginalText++;
                }
            }
        }
    }
    *p = L'\0';

    WCHAR** pStringPtrArray = (WCHAR**)::CoTaskMemAlloc( cWords * sizeof(WCHAR *));
    if ( !pStringPtrArray )
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        p = dsText;
        for (ULONG i=0; i<cWords; i++)
        {
            while (*p == L'\0') p++;
            pStringPtrArray[i] = p;
            p += wcslen(p);
        }

        hr = CreatePhraseFromWordArray((const WCHAR **)pStringPtrArray, cWords, NULL, ppResultPhrase, LangId, cpPhoneConv, fNoSpecialCharacters);

        ::CoTaskMemFree(pStringPtrArray);
    }
    return hr;
}

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sperror.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPError.h *
*-----------*
*   Description:
*       This header file contains the custom error codes specific to SAPI5
*-------------------------------------------------------------------------------
*******************************************************************************/
#ifndef SPError_h
#define SPError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

#define FACILITY_SAPI      FACILITY_ITF
#define SAPI_ERROR_BASE    0x5000

#define MAKE_SAPI_HRESULT(sev, err)    MAKE_HRESULT(sev, FACILITY_SAPI, err)
#define MAKE_SAPI_ERROR(err)           MAKE_SAPI_HRESULT(SEVERITY_ERROR, err + SAPI_ERROR_BASE)
#define MAKE_SAPI_SCODE(scode)         MAKE_SAPI_HRESULT(SEVERITY_SUCCESS, scode + SAPI_ERROR_BASE)

/*** SPERR_UNINITIALIZED                                   0x80045001    -2147201023
*   The object has not been properly initialized.
*/
#define SPERR_UNINITIALIZED                                MAKE_SAPI_ERROR(0x001)

/*** SPERR_ALREADY_INITIALIZED                             0x80045002    -2147201022
*   The object has already been initialized.
*/
#define SPERR_ALREADY_INITIALIZED                          MAKE_SAPI_ERROR(0x002)

/*** SPERR_UNSUPPORTED_FORMAT                              0x80045003    -2147201021
*   The caller has specified an unsupported format.
*/
#define SPERR_UNSUPPORTED_FORMAT                           MAKE_SAPI_ERROR(0x003)

/*** SPERR_INVALID_FLAGS                                   0x80045004    -2147201020
*   The caller has specified invalid flags for this operation.
*/
#define SPERR_INVALID_FLAGS                                MAKE_SAPI_ERROR(0x004)

/*** SP_END_OF_STREAM                                      0x00045005    282629
*   The operation has reached the end of stream.
*/
#define SP_END_OF_STREAM                                   MAKE_SAPI_SCODE(0x005)

/*** SPERR_DEVICE_BUSY                                     0x80045006    -2147201018
*   The wave device is busy.
*/
#define SPERR_DEVICE_BUSY                                  MAKE_SAPI_ERROR(0x006)

/*** SPERR_DEVICE_NOT_SUPPORTED                            0x80045007    -2147201017
*   The wave device is not supported.
*/
#define SPERR_DEVICE_NOT_SUPPORTED                         MAKE_SAPI_ERROR(0x007)

/*** SPERR_DEVICE_NOT_ENABLED                              0x80045008    -2147201016
*   The wave device is not enabled.
*/
#define SPERR_DEVICE_NOT_ENABLED                           MAKE_SAPI_ERROR(0x008)

/*** SPERR_NO_DRIVER                                       0x80045009    -2147201015
*   There is no wave driver installed.
*/
#define SPERR_NO_DRIVER                                    MAKE_SAPI_ERROR(0x009)

/*** SPERR_FILEMUSTBEUNICODE                               0x8004500a    -2147201014
*   The file must be Unicode.
*/
#define SPERR_FILE_MUST_BE_UNICODE                         MAKE_SAPI_ERROR(0x00a)

/*** SP_INSUFFICIENTDATA                                   0x0004500b    282635
*
*/
#define SP_INSUFFICIENT_DATA                               MAKE_SAPI_SCODE(0x00b)

/*** SPERR_INVALID_PHRASE_ID                               0x8004500c    -2147201012
*   The phrase ID specified does not exist or is out of range.
*/
#define SPERR_INVALID_PHRASE_ID                            MAKE_SAPI_ERROR(0x00c)

/*** SPERR_BUFFER_TOO_SMALL                                0x8004500d    -2147201011
*   The caller provided a buffer too small to return a result.
*/
#define SPERR_BUFFER_TOO_SMALL                             MAKE_SAPI_ERROR(0x00d)

/*** SPERR_FORMAT_NOT_SPECIFIED                            0x8004500e    -2147201010
*   Caller did not specify a format prior to opening a stream.
*/
#define SPERR_FORMAT_NOT_SPECIFIED                         MAKE_SAPI_ERROR(0x00e)

/*** SPERR_AUDIO_STOPPED                                   0x8004500f    -2147201009
*   This method is deprecated. Use SP_AUDIO_STOPPED instead.
*/
#define SPERR_AUDIO_STOPPED                                MAKE_SAPI_ERROR(0x00f)

/*** SP_AUDIO_PAUSED                                       0x00045010    282640
*   This will be returned only on input (read) streams when the stream is paused.  Reads on
*   paused streams will not block, and this return code indicates that all of the data has been
*   removed from the stream.
*/
#define SP_AUDIO_PAUSED                                    MAKE_SAPI_SCODE(0x010)

/*** SPERR_RULE_NOT_FOUND                                  0x80045011    -2147201007
*   Invalid rule name passed to ActivateGrammar.
*/
#define SPERR_RULE_NOT_FOUND                               MAKE_SAPI_ERROR(0x011)

/*** SPERR_TTS_ENGINE_EXCEPTION                            0x80045012    -2147201006
*   An exception was raised during a call to the current TTS driver.
*/
#define SPERR_TTS_ENGINE_EXCEPTION                         MAKE_SAPI_ERROR(0x012)

/*** SPERR_TTS_NLP_EXCEPTION                               0x80045013    -2147201005
*   An exception was raised during a call to an application sentence filter.
*/
#define SPERR_TTS_NLP_EXCEPTION                            MAKE_SAPI_ERROR(0x013)

/*** SPERR_ENGINE_BUSY                                     0x80045014    -2147201004
*   In speech recognition, the current method can not be performed while
*   a grammar rule is active.
*/
#define SPERR_ENGINE_BUSY                                  MAKE_SAPI_ERROR(0x014)

/*** SP_AUDIO_CONVERSION_ENABLED                           0x00045015    282645
*   The operation was successful, but only with automatic stream format conversion.
*/
#define SP_AUDIO_CONVERSION_ENABLED                        MAKE_SAPI_SCODE(0x015)

/*** SP_NO_HYPOTHESIS_AVAILABLE                            0x00045016    282646
*   There is currently no hypothesis recognition available.
*/
#define SP_NO_HYPOTHESIS_AVAILABLE                         MAKE_SAPI_SCODE(0x016)

/*** SPERR_CANT_CREATE                                     0x80045017    -2147201001
*   Can not create a new object instance for the specified object category.
*/
#define SPERR_CANT_CREATE                                  MAKE_SAPI_ERROR(0x017)

/*** SP_ALREADY_IN_LEX                                     0x00045018    282648
*   The word, pronunciation, or POS pair being added is already in lexicon.
*/
#define SP_ALREADY_IN_LEX                                  MAKE_SAPI_SCODE(0x018)

/*** SPERR_NOT_IN_LEX                                      0x80045019    -2147200999
*   The word does not exist in the lexicon.
*/
#define SPERR_NOT_IN_LEX                                   MAKE_SAPI_ERROR(0x019)

/*** SP_LEX_NOTHING_TO_SYNC                                0x0004501a    282650
*   The client is currently synced with the lexicon.
*/
#define SP_LEX_NOTHING_TO_SYNC                             MAKE_SAPI_SCODE(0x01a)

/*** SPERR_LEX_VERY_OUT_OF_SYNC                            0x8004501b    -2147200997
*   The client is excessively out of sync with the lexicon. Mismatches may not be incrementally sync'd.
*/
#define SPERR_LEX_VERY_OUT_OF_SYNC                         MAKE_SAPI_ERROR(0x01b)

/*** SPERR_UNDEFINED_FORWARD_RULE_REF                      0x8004501c    -2147200996
*   A rule reference in a grammar was made to a named rule that was never defined.
*/
#define SPERR_UNDEFINED_FORWARD_RULE_REF                   MAKE_SAPI_ERROR(0x01c)

/*** SPERR_EMPTY_RULE                                      0x8004501d    -2147200995
*   A non-dynamic grammar rule that has no body.
*/
#define SPERR_EMPTY_RULE                                   MAKE_SAPI_ERROR(0x01d)

/*** SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR                 0x8004501e    -2147200994
*   The grammar compiler failed due to an internal state error.
*/
#define SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR              MAKE_SAPI_ERROR(0x01e)

/*** SPERR_RULE_NOT_DYNAMIC                                0x8004501f    -2147200993
*   An attempt was made to modify a non-dynamic rule.
*/
#define SPERR_RULE_NOT_DYNAMIC                             MAKE_SAPI_ERROR(0x01f)

/*** SPERR_DUPLICATE_RULE_NAME                             0x80045020    -2147200992
*   A rule name was duplicated.
*/
#define SPERR_DUPLICATE_RULE_NAME                          MAKE_SAPI_ERROR(0x020)

/*** SPERR_DUPLICATE_RESOURCE_NAME                         0x80045021    -2147200991
*   A resource name was duplicated for a given rule.
*/
#define SPERR_DUPLICATE_RESOURCE_NAME                      MAKE_SAPI_ERROR(0x021)

/*** SPERR_TOO_MANY_GRAMMARS                               0x80045022    -2147200990
*   Too many grammars have been loaded.
*/
#define SPERR_TOO_MANY_GRAMMARS                            MAKE_SAPI_ERROR(0x022)

/*** SPERR_CIRCULAR_REFERENCE                              0x80045023    -2147200989
*   Circular reference in import rules of grammars.
*/
#define SPERR_CIRCULAR_REFERENCE                           MAKE_SAPI_ERROR(0x023)

/*** SPERR_INVALID_IMPORT                                  0x80045024    -2147200988
*   A rule reference to an imported grammar that could not be resolved.
*/
#define SPERR_INVALID_IMPORT                               MAKE_SAPI_ERROR(0x024)

/*** SPERR_INVALID_WAV_FILE                                0x80045025    -2147200987
*   The format of the WAV file is not supported.
*/
#define SPERR_INVALID_WAV_FILE                             MAKE_SAPI_ERROR(0x025)

/*** SP_REQUEST_PENDING                                    0x00045026    282662
*   This success code indicates that an SR method called with the SPRIF_ASYNC flag is
*   being processed.  When it has finished processing, an SPFEI_ASYNC_COMPLETED event will be generated.
*/
#define SP_REQUEST_PENDING                                 MAKE_SAPI_SCODE(0x026)

/*** SPERR_ALL_WORDS_OPTIONAL                              0x80045027    -2147200985
*   A grammar rule was defined with a null path through the rule.  That is, it is possible
*   to satisfy the rule conditions with no words.
*/
#define SPERR_ALL_WORDS_OPTIONAL                           MAKE_SAPI_ERROR(0x027)

/*** SPERR_INSTANCE_CHANGE_INVALID                         0x80045028    -2147200984
*   It is not possible to change the current engine or input.  This occurs in the
*   following cases:
*
*       1) SelectEngine called while a recognition context exists, or
*       2) SetInput called in the shared instance case.
*/
#define SPERR_INSTANCE_CHANGE_INVALID                      MAKE_SAPI_ERROR(0x028)

/*** SPERR_RULE_NAME_ID_CONFLICT                          0x80045029    -2147200983
*   A rule exists with matching IDs (names) but different names (IDs).  
*/
#define SPERR_RULE_NAME_ID_CONFLICT                        MAKE_SAPI_ERROR(0x029)

/*** SPERR_NO_RULES                                       0x8004502a    -2147200982
*   A grammar contains no top-level, dynamic, or exported rules.  There is no possible
*   way to activate or otherwise use any rule in this grammar.
*/
#define SPERR_NO_RULES                                     MAKE_SAPI_ERROR(0x02a)

/*** SPERR_CIRCULAR_RULE_REF                              0x8004502b    -2147200981
*   Rule 'A' refers to a second rule 'B' which, in turn, refers to rule 'A'. 
*/
#define SPERR_CIRCULAR_RULE_REF                            MAKE_SAPI_ERROR(0x02b)

/*** SP_NO_PARSE_FOUND                                    0x0004502c    282668
*   Parse path cannot be parsed given the currently active rules.
*/
#define SP_NO_PARSE_FOUND                                  MAKE_SAPI_SCODE(0x02c)

/*** SPERR_NO_PARSE_FOUND                                 0x8004502d    -2147200979
*   Parse path cannot be parsed given the currently active rules.
*/
#define SPERR_INVALID_HANDLE                               MAKE_SAPI_ERROR(0x02d)

/*** SPERR_REMOTE_CALL_TIMED_OUT                          0x8004502e    -2147200978
*   A marshaled remote call failed to respond.
*/
#define SPERR_REMOTE_CALL_TIMED_OUT                        MAKE_SAPI_ERROR(0x02e)

/*** SPERR_AUDIO_BUFFER_OVERFLOW                           0x8004502f    -2147200977
*   This will only be returned on input (read) streams when the stream is paused because
*   the SR driver has not retrieved data recently.
*/
#define SPERR_AUDIO_BUFFER_OVERFLOW                        MAKE_SAPI_ERROR(0x02f)

/*** SPERR_NO_AUDIO_DATA                                   0x80045030    -2147200976
*   The result does not contain any audio, nor does the portion of the element chain of the result
*   contain any audio.
*/
#define SPERR_NO_AUDIO_DATA                                MAKE_SAPI_ERROR(0x030)

/*** SPERR_DEAD_ALTERNATE                                  0x80045031    -2147200975
*   This alternate is no longer a valid alternate to the result it was obtained from.
*   Returned from ISpPhraseAlt methods.
*/
#define SPERR_DEAD_ALTERNATE                               MAKE_SAPI_ERROR(0x031)

/*** SPERR_HIGH_LOW_CONFIDENCE                             0x80045032    -2147200974
*   The result does not contain any audio, nor does the portion of the element chain of the result
*   contain any audio.  Returned from ISpResult::GetAudio and ISpResult::SpeakAudio.
*/
#define SPERR_HIGH_LOW_CONFIDENCE                          MAKE_SAPI_ERROR(0x032)

/*** SPERR_INVALID_FORMAT_STRING                           0x80045033    -2147200973
*   The XML format string for this RULEREF is invalid, e.g. not a GUID or REFCLSID.
*/
#define SPERR_INVALID_FORMAT_STRING                        MAKE_SAPI_ERROR(0x033)

/*** SP_UNSUPPORTED_ON_STREAM_INPUT                        0x00045034    282676
*   The operation is not supported for stream input.
*/
#define SP_UNSUPPORTED_ON_STREAM_INPUT                     MAKE_SAPI_SCODE(0x034)

/*** SPERR_APPLEX_READ_ONLY                                0x80045035    -2147200971
*   The operation is invalid for all but newly created application lexicons.
*/
#define SPERR_APPLEX_READ_ONLY                             MAKE_SAPI_ERROR(0x035)

/*** SPERR_NO_TERMINATING_RULE_PATH                        0x80045036    -2147200970
*
*/

#define SPERR_NO_TERMINATING_RULE_PATH                     MAKE_SAPI_ERROR(0x036)

/*** SP_WORD_EXISTS_WITHOUT_PRONUNCIATION                  0x00045037    282679
*   The word exists but without pronunciation.
*/
#define SP_WORD_EXISTS_WITHOUT_PRONUNCIATION               MAKE_SAPI_SCODE(0x037)

/*** SPERR_STREAM_CLOSED                                   0x80045038    -2147200968
*   An operation was attempted on a stream object that has been closed.
*/
#define SPERR_STREAM_CLOSED                                MAKE_SAPI_ERROR(0x038)

// --- The following error codes are taken directly from WIN32  ---

/*** SPERR_NO_MORE_ITEMS                                   0x80045039    -2147200967
*   When enumerating items, the requested index is greater than the count of items.
*/
#define SPERR_NO_MORE_ITEMS                                MAKE_SAPI_ERROR(0x039)

/*** SPERR_NOT_FOUND                                       0x8004503a    -2147200966
*   The requested data item (data key, value, etc.) was not found.
*/
#define SPERR_NOT_FOUND                                    MAKE_SAPI_ERROR(0x03a)

/*** SPERR_INVALID_AUDIO_STATE                             0x8004503b    -2147200965
*   Audio state passed to SetState() is invalid.
*/
#define SPERR_INVALID_AUDIO_STATE                          MAKE_SAPI_ERROR(0x03b)

/*** SPERR_GENERIC_MMSYS_ERROR                             0x8004503c    -2147200964
*   A generic MMSYS error not caught by _MMRESULT_TO_HRESULT.
*/
#define SPERR_GENERIC_MMSYS_ERROR                          MAKE_SAPI_ERROR(0x03c)

/*** SPERR_MARSHALER_EXCEPTION                             0x8004503d    -2147200963
*   An exception was raised during a call to the marshaling code.
*/
#define SPERR_MARSHALER_EXCEPTION                          MAKE_SAPI_ERROR(0x03d)

/*** SPERR_NOT_DYNAMIC_GRAMMAR                             0x8004503e    -2147200962
*   Attempt was made to manipulate a non-dynamic grammar.
*/
#define SPERR_NOT_DYNAMIC_GRAMMAR                          MAKE_SAPI_ERROR(0x03e)

/*** SPERR_AMBIGUOUS_PROPERTY                              0x8004503f    -2147200961
*   Cannot add ambiguous property.
*/
#define SPERR_AMBIGUOUS_PROPERTY                           MAKE_SAPI_ERROR(0x03f)

/*** SPERR_INVALID_REGISTRY_KEY                            0x80045040    -2147200960
*   The key specified is invalid.
*/
#define SPERR_INVALID_REGISTRY_KEY                         MAKE_SAPI_ERROR(0x040)

/*** SPERR_INVALID_TOKEN_ID                                0x80045041    -2147200959
*   The token specified is invalid.
*/
#define SPERR_INVALID_TOKEN_ID                             MAKE_SAPI_ERROR(0x041)

/*** SPERR_XML_BAD_SYNTAX                                  0x80045042    -2147200958
*   The xml parser failed due to bad syntax.
*/
#define SPERR_XML_BAD_SYNTAX                               MAKE_SAPI_ERROR(0x042)

/*** SPERR_XML_RESOURCE_NOT_FOUND                          0x80045043    -2147200957
*   The xml parser failed to load a required resource (e.g., voice, phoneconverter, etc.).
*/
#define SPERR_XML_RESOURCE_NOT_FOUND                       MAKE_SAPI_ERROR(0x043)

/*** SPERR_TOKEN_IN_USE                                    0x80045044    -2147200956
*   Attempted to remove registry data from a token that is already in use elsewhere.
*/
#define SPERR_TOKEN_IN_USE                                 MAKE_SAPI_ERROR(0x044)

/*** SPERR_TOKEN_DELETED                                   0x80045045    -2147200955
*   Attempted to perform an action on an object token that has had associated registry key deleted.
*/
#define SPERR_TOKEN_DELETED                                MAKE_SAPI_ERROR(0x045)

/*** SPERR_MULTI_LINGUAL_NOT_SUPPORTED                     0x80045046    -2147200954
*   The selected voice was registered as multi-lingual. SAPI does not support multi-lingual registration. 
*/
#define SPERR_MULTI_LINGUAL_NOT_SUPPORTED                  MAKE_SAPI_ERROR(0x046)

/*** SPERR_EXPORT_DYNAMIC_RULE                             0x80045047    -2147200953
*   Exported rules cannot refer directly or indirectly to a dynamic rule.
*/
#define SPERR_EXPORT_DYNAMIC_RULE                          MAKE_SAPI_ERROR(0x047)

/*** SPERR_STGF_ERROR                                      0x80045048    -2147200952
*   Error parsing the SAPI Text Grammar Format (XML grammar).
*/
#define SPERR_STGF_ERROR                                   MAKE_SAPI_ERROR(0x048)

/*** SPERR_WORDFORMAT_ERROR                                0x80045049    -2147200951
*   Incorrect word format, probably due to incorrect pronunciation string.
*/
#define SPERR_WORDFORMAT_ERROR                             MAKE_SAPI_ERROR(0x049)

/*** SPERR_STREAM_NOT_ACTIVE                               0x8004504a    -2147200950
*   Methods associated with active audio stream cannot be called unless stream is active.
*/
#define SPERR_STREAM_NOT_ACTIVE                            MAKE_SAPI_ERROR(0x04a)

/*** SPERR_ENGINE_RESPONSE_INVALID                         0x8004504b    -2147200949
*   Arguments or data supplied by the engine are in an invalid format or are inconsistent.
*/
#define SPERR_ENGINE_RESPONSE_INVALID                      MAKE_SAPI_ERROR(0x04b)

/*** SPERR_SR_ENGINE_EXCEPTION                             0x8004504c    -2147200948
*   An exception was raised during a call to the current SR engine.
*/
#define SPERR_SR_ENGINE_EXCEPTION                          MAKE_SAPI_ERROR(0x04c)

/*** SPERR_STREAM_POS_INVALID                              0x8004504d    -2147200947
*   Stream position information supplied from engine is inconsistent.
*/
#define SPERR_STREAM_POS_INVALID                           MAKE_SAPI_ERROR(0x04d)

/*** SP_RECOGNIZER_INACTIVE                                0x0004504e    282702
*   Operation could not be completed because the recognizer is inactive. It is inactive either
*   because the recognition state is currently inactive or because no rules are active .
*/
#define SP_RECOGNIZER_INACTIVE                             MAKE_SAPI_SCODE(0x04e)

/*** SPERR_REMOTE_CALL_ON_WRONG_THREAD                     0x8004504f    -2147200945
*   When making a remote call to the server, the call was made on the wrong thread.
*/
#define SPERR_REMOTE_CALL_ON_WRONG_THREAD                  MAKE_SAPI_ERROR(0x04f)

/*** SPERR_REMOTE_PROCESS_TERMINATED                       0x80045050    -2147200944
*   The remote process terminated unexpectedly.
*/
#define SPERR_REMOTE_PROCESS_TERMINATED                    MAKE_SAPI_ERROR(0x050)

/*** SPERR_REMOTE_PROCESS_ALREADY_RUNNING                  0x80045051    -2147200943
*   The remote process is already running; it cannot be started a second time.
*/
#define SPERR_REMOTE_PROCESS_ALREADY_RUNNING               MAKE_SAPI_ERROR(0x051)

/*** SPERR_LANGID_MISMATCH                                 0x80045052    -2147200942
*   An attempt to load a CFG grammar with a LANGID different than other loaded grammars.
*/
#define SPERR_LANGID_MISMATCH                              MAKE_SAPI_ERROR(0x052)

/*** SP_PARTIAL_PARSE_FOUND                               0x00045053    282707
*   A grammar-ending parse has been found that does not use all available words.
*/
#define SP_PARTIAL_PARSE_FOUND                             MAKE_SAPI_SCODE(0x053)

/*** SPERR_NOT_TOPLEVEL_RULE                              0x80045054    -2147200940
*   An attempt to deactivate or activate a non-toplevel rule.
*/
#define SPERR_NOT_TOPLEVEL_RULE                            MAKE_SAPI_ERROR(0x054)

/*** SP_NO_RULE_ACTIVE                                    0x00045055    282709
*   An attempt to parse when no rule was active.
*/
#define SP_NO_RULE_ACTIVE                                  MAKE_SAPI_SCODE(0x055)

/*** SPERR_LEX_REQUIRES_COOKIE                            0x80045056    -2147200938
*   An attempt to ask a container lexicon for all words at once.
*/
#define SPERR_LEX_REQUIRES_COOKIE                          MAKE_SAPI_ERROR(0x056)

/*** SP_STREAM_UNINITIALIZED                              0x00045057    282711
*   An attempt to activate a rule/dictation/etc without calling SetInput 
*   first in the inproc case.
*/
#define SP_STREAM_UNINITIALIZED                            MAKE_SAPI_SCODE(0x057)


// Error x058 is not used in SAPI 5.0


/*** SPERR_UNSUPPORTED_LANG                               0x80045059    -2147200935
*   The requested language is not supported.
*/
#define SPERR_UNSUPPORTED_LANG                             MAKE_SAPI_ERROR(0x059)

/*** SPERR_VOICE_PAUSED                                   0x8004505a    -2147200934
*   The operation cannot be performed because the voice is currently paused.
*/
#define SPERR_VOICE_PAUSED                                 MAKE_SAPI_ERROR(0x05a)

/*** SPERR_AUDIO_BUFFER_UNDERFLOW                          0x8004505b    -2147200933
*   This will only be returned on input (read) streams when the real time audio device
*   stops returning data for a long period of time.
*/
#define SPERR_AUDIO_BUFFER_UNDERFLOW                       MAKE_SAPI_ERROR(0x05b)

/*** SPERR_AUDIO_STOPPED_UNEXPECTEDLY                     0x8004505c    -2147200932
*   An audio device stopped returning data from the Read() method even though it was in
*   the run state.  This error is only returned in the END_SR_STREAM event.
*/
#define SPERR_AUDIO_STOPPED_UNEXPECTEDLY                   MAKE_SAPI_ERROR(0x05c)

/*** SPERR_NO_WORD_PRONUNCIATION                           0x8004505d    -2147200931
*   The SR engine is unable to add this word to a grammar. The application may need to supply 
*   an explicit pronunciation for this word.
*/
#define SPERR_NO_WORD_PRONUNCIATION                        MAKE_SAPI_ERROR(0x05d)

/*** SPERR_ALTERNATES_WOULD_BE_INCONSISTENT                0x8004505e    -2147200930
*   An attempt to call ScaleAudio on a recognition result having previously
*   called GetAlternates. Allowing the call to succeed would result in
*   the previously created alternates located in incorrect audio stream positions.
*/
#define SPERR_ALTERNATES_WOULD_BE_INCONSISTENT             MAKE_SAPI_ERROR(0x05e)

/*** SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER             0x8004505f    -2147200929
*   The method called is not supported for the shared recognizer.
*   For example, ISpRecognizer::GetInputStream().
*/
#define SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER          MAKE_SAPI_ERROR(0x05f)

/*** SPERR_TIMEOUT                                         0x80045060    -2147200928
*   A task could not complete because the SR engine had timed out.
*/
#define SPERR_TIMEOUT                                      MAKE_SAPI_ERROR(0x060)

/*** SPERR_REENTER_SYNCHRONIZE                             0x80045061    -2147200927
*   A SR engine called synchronize while inside of a synchronize call.
*/
#define SPERR_REENTER_SYNCHRONIZE                          MAKE_SAPI_ERROR(0x061)

/*** SPERR_STATE_WITH_NO_ARCS                              0x80045062    -2147200926
*   The grammar contains a node no arcs.
*/
#define SPERR_STATE_WITH_NO_ARCS                           MAKE_SAPI_ERROR(0x062)

/*** SPERR_NOT_ACTIVE_SESSION                              0x80045063    -2147200925
*   Neither audio output and input is supported for non-active console sessions.
*/
#define SPERR_NOT_ACTIVE_SESSION                           MAKE_SAPI_ERROR(0x063)

/*** SPERR_ALREADY_DELETED                                 0x80045064    -2147200924
*   The object is a stale reference and is invalid to use.
*   For example having a ISpeechGrammarRule object reference and then calling 
*   ISpeechRecoGrammar::Reset() will cause the rule object to be invalidated.
*   Calling any methods after this will result in this error.
*/
#define SPERR_ALREADY_DELETED                              MAKE_SAPI_ERROR(0x064)

/*** SP_AUDIO_STOPPED                                      0x00045065    282725
*   This can be returned from Read or Write calls audio streams when the stream is stopped.
*/
#define SP_AUDIO_STOPPED                                   MAKE_SAPI_SCODE(0x065)

/*** SPERR_RECOXML_GENERATION_FAIL                             0x80045066    -2147200922
*   The Recognition Parse Tree couldn't be genrated.
*   For example, that the rule name begins with a digit.
*   XML parser doesn't allow element name beginning with a digit.
*/
#define SPERR_RECOXML_GENERATION_FAIL                      MAKE_SAPI_ERROR(0x066)

/*** SPERR_SML_GENERATION_FAIL                             0x80045067    -2147200921
*   The SML couldn't be genrated.
*   For example, the transformation xslt template is not well formed.
*/
#define SPERR_SML_GENERATION_FAIL                          MAKE_SAPI_ERROR(0x067)

/*** SPERR_NOT_PROMPT_VOICE                                0x80045068   -2147200920
*   The current voice is not a prompt voice, so the ISpPromptVoice
*   functions don't work.
*/
#define SPERR_NOT_PROMPT_VOICE                             MAKE_SAPI_ERROR(0x068)

/*** SPERR_ROOTRULE_ALREADY_DEFINED                        0x80045069   -2147200919
*   There is already a root rule for this grammar
*   Defining another root rule will fail.
*/
#define SPERR_ROOTRULE_ALREADY_DEFINED                     MAKE_SAPI_ERROR(0x069)

/*** SPERR_SCRIPT_DISALLOWED                               0x80045070   -2147200912
*   Support for embedded script not supported because browser security settings have disabled it
*/
#define SPERR_SCRIPT_DISALLOWED                            MAKE_SAPI_ERROR(0x070)

/*** SPERR_REMOTE_CALL_TIMED_OUT_START                     0x80045071    -2147200911
*   A time out occurred starting the sapi server
*/
#define SPERR_REMOTE_CALL_TIMED_OUT_START                  MAKE_SAPI_ERROR(0x071)

/*** SPERR_REMOTE_CALL_TIMED_OUT_CONNECT                   0x80045072    -2147200910
*   A timeout occurred obtaining the lock for starting or connecting to sapi server 
*/
#define SPERR_REMOTE_CALL_TIMED_OUT_CONNECT                MAKE_SAPI_ERROR(0x072)

/*** SPERR_SECMGR_CHANGE_NOT_ALLOWED                       0x80045073    -2147200909
*   When there is a cfg grammar loaded, we don't allow changing the security manager
*/
#define SPERR_SECMGR_CHANGE_NOT_ALLOWED                    MAKE_SAPI_ERROR(0x073)

/*** SP_COMPLETE_BUT_EXTENDABLE                            0x00045074    282740
*   Parse is valid but could be extendable (internal use only)
*/
#define SP_COMPLETE_BUT_EXTENDABLE                         MAKE_SAPI_SCODE(0x074)

/*** SPERR_FAILED_TO_DELETE_FILE                           0x80045075    -2147200907
*   Tried and failed to delete an existing file.
*/
#define SPERR_FAILED_TO_DELETE_FILE                        MAKE_SAPI_ERROR(0x075)

/*** SPERR_SHARED_ENGINE_DISABLED                          0x80045076    -2147200906
*   The user has chosen to disable speech from running on the machine, or the 
*   system is not set up to run speech {e.g. initial setup and tutorial has not been run}.    
*/
#define SPERR_SHARED_ENGINE_DISABLED                       MAKE_SAPI_ERROR(0x076)

/*** SPERR_RECOGNIZER_NOT_FOUND                            0x80045077    -2147200905
*   No recognizer is installed.    
*/
#define SPERR_RECOGNIZER_NOT_FOUND                         MAKE_SAPI_ERROR(0x077)

/*** SPERR_AUDIO_NOT_FOUND                                 0x80045078    -2147200904
*   No audio device is installed.    
*/
#define SPERR_AUDIO_NOT_FOUND                              MAKE_SAPI_ERROR(0x078)

/*** SPERR_NO_VOWEL                                        0x80045079    -2147200903
*   No Vowel in a word 
*/
#define SPERR_NO_VOWEL                                     MAKE_SAPI_ERROR(0x079)

/*** SPERR_UNSUPPORTED_PHONEME                             0x8004507A    -2147200902
*   Unknown phoneme
*/
#define SPERR_UNSUPPORTED_PHONEME                          MAKE_SAPI_ERROR(0x07A)

/*** SP_NO_RULES_TO_ACTIVATE                               0x0004507B    282747
*   The grammar does not have any root or top-level active rules to activate.
*/
#define SP_NO_RULES_TO_ACTIVATE                            MAKE_SAPI_SCODE(0x07B)

/*** SP_NO_WORDENTRY_NOTIFICATION                          0x0004507C    282748
*   The engine does not need SAPI word entry handles for this grammar
*/
#define SP_NO_WORDENTRY_NOTIFICATION                       MAKE_SAPI_SCODE(0x07C)


/*** SPERR_WORD_NEEDS_NORMALIZATION                        0x8004507D    -2147200899
*   The word passed to the GetPronunciations interface needs normalizing first
*/
#define SPERR_WORD_NEEDS_NORMALIZATION                     MAKE_SAPI_ERROR(0x07D)

/*** SPERR_CANNOT_NORMALIZE                                0x8004507E    -2147200898
*   The word passed to the normalize interface cannot be normalized
*/
#define SPERR_CANNOT_NORMALIZE                             MAKE_SAPI_ERROR(0x07E)

/*** S_LIMIT_REACHED                     0x8004507F    -2147200897
*   The word being normalized has generated more than the maximum number of allowed normalized results
*   Indicates that returned list is not exhaustive, but contains as many alternatives as the engine is willing to provide.
*/
#define S_LIMIT_REACHED                                    MAKE_SAPI_SCODE(0x07F)

/*** S_NOTSUPPORTED                     0x80045080    -2147200896
*   We currently don't support this combination of function call + input
*/
#define S_NOTSUPPORTED                                    MAKE_SAPI_SCODE(0x080)

/*** SPERR_TOPIC_NOT_ADAPTABLE                            0x80045081    -2147200895
*   This topic is not adaptable
*/
#define SPERR_TOPIC_NOT_ADAPTABLE                         MAKE_SAPI_ERROR(0x081)

/*** SPERR_PHONEME_CONVERSION                            0x80045082    -2147200894
*   Cannot convert the phonemes to the specified phonetic alphabet.
*/
#define SPERR_PHONEME_CONVERSION                          MAKE_SAPI_ERROR(0x082)

/*** SPERR_NOT_SUPPORTED_FOR_INPROC_RECOGNIZER           0x80045083    -2147200893
*   The method called is not supported for the in-process recognizer.
*   For example: SetTextFeedback
*/
#define SPERR_NOT_SUPPORTED_FOR_INPROC_RECOGNIZER         MAKE_SAPI_ERROR(0x083)

/*** SPERR_OVERLOAD                 0x80045084         -2147200892
*   The operation cannot be carried out due to overload and should be attempted again.
*/
#define SPERR_OVERLOAD                                  MAKE_SAPI_ERROR(0x084)

/*** SPERR_LEX_INVALID_DATA         0x80045085         -2147200891
*   The lexicon data is invalid or corrupted.
*/
#define SPERR_LEX_INVALID_DATA                          MAKE_SAPI_ERROR(0x085)

/*** SPERR_CFG_INVALID_DATA         0x80045086         -2147200890
*   The data in the CFG grammar is invalid or corrupted
*/
#define SPERR_CFG_INVALID_DATA                          MAKE_SAPI_ERROR(0x086)

/*** SPERR_LEX_UNEXPECTED_FORMAT      0x80045087       -2147200889
*   The lexicon is not in the expected format.
*/
#define SPERR_LEX_UNEXPECTED_FORMAT                     MAKE_SAPI_ERROR(0x087)

/*** SPERR_STRING_TOO_LONG          0x80045088         -2147200888
*   The string is too long.
*/
#define SPERR_STRING_TOO_LONG                           MAKE_SAPI_ERROR(0x088)

/*** SPERR_STRING_EMPTY             0x80045089         -2147200887
*   The string cannot be empty.
*/
#define SPERR_STRING_EMPTY                              MAKE_SAPI_ERROR(0x089)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sql.h ===
//-----------------------------------------------------------------------------
// File:            sql.h
//
// Copyright:       Copyright (c) Microsoft Corporation
//
// Contents:        This is the the main include for ODBC Core functions.
//
// Comments:        preconditions: #include "windows.h"
//
//-----------------------------------------------------------------------------

#ifndef __SQL
#define __SQL

/*
* ODBCVER  Default to ODBC version number (0x0380).   To exclude
*          definitions introduced in version 3.8 (or above)
*          #define ODBCVER 0x0351 before #including <sql.h>
*/
#ifndef ODBCVER
#define ODBCVER 0x0380
#endif

#ifndef __SQLTYPES
#include "sqltypes.h"
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++   */
#endif  /* __cplusplus */

/* special length/indicator values */
#define SQL_NULL_DATA             (-1)
#define SQL_DATA_AT_EXEC          (-2)


/* return values from functions */
#define SQL_SUCCESS                 0
#define SQL_SUCCESS_WITH_INFO       1
#if (ODBCVER >= 0x0300)
#define SQL_NO_DATA                 100
#endif

#if (ODBCVER >= 0x0380)
#define SQL_PARAM_DATA_AVAILABLE    101  
#endif

#define SQL_ERROR                   (-1)
#define SQL_INVALID_HANDLE          (-2)

#define SQL_STILL_EXECUTING         2
#define SQL_NEED_DATA               99

/* test for SQL_SUCCESS or SQL_SUCCESS_WITH_INFO */
#define SQL_SUCCEEDED(rc) (((rc)&(~1))==0)

/* flags for null-terminated string */
#define SQL_NTS                   (-3)
#define SQL_NTSL                  (-3L)

/* maximum message length */
#define SQL_MAX_MESSAGE_LENGTH   512

/* date/time length constants */
#if (ODBCVER >= 0x0300)
#define SQL_DATE_LEN           10
#define SQL_TIME_LEN            8  /* add P+1 if precision is nonzero */
#define SQL_TIMESTAMP_LEN      19  /* add P+1 if precision is nonzero */
#endif

/* handle type identifiers */
#if (ODBCVER >= 0x0300)
#define SQL_HANDLE_ENV             1
#define SQL_HANDLE_DBC             2
#define SQL_HANDLE_STMT            3
#define SQL_HANDLE_DESC            4
#endif

/* environment attribute */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_OUTPUT_NTS    10001
#endif

/* connection attributes */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_AUTO_IPD      10001
#define SQL_ATTR_METADATA_ID   10014
#endif  /* ODBCVER >= 0x0300 */

/* statement attributes */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_APP_ROW_DESC       10010
#define SQL_ATTR_APP_PARAM_DESC     10011
#define SQL_ATTR_IMP_ROW_DESC       10012
#define SQL_ATTR_IMP_PARAM_DESC     10013
#define SQL_ATTR_CURSOR_SCROLLABLE  (-1)
#define SQL_ATTR_CURSOR_SENSITIVITY (-2)
#endif

/* SQL_ATTR_CURSOR_SCROLLABLE values */
#if (ODBCVER >= 0x0300)
#define SQL_NONSCROLLABLE           0
#define SQL_SCROLLABLE              1
#endif  /* ODBCVER >= 0x0300 */

/* identifiers of fields in the SQL descriptor */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_COUNT                  1001
#define SQL_DESC_TYPE                   1002
#define SQL_DESC_LENGTH                 1003
#define SQL_DESC_OCTET_LENGTH_PTR       1004
#define SQL_DESC_PRECISION              1005
#define SQL_DESC_SCALE                  1006
#define SQL_DESC_DATETIME_INTERVAL_CODE 1007
#define SQL_DESC_NULLABLE               1008
#define SQL_DESC_INDICATOR_PTR          1009
#define SQL_DESC_DATA_PTR               1010
#define SQL_DESC_NAME                   1011
#define SQL_DESC_UNNAMED                1012
#define SQL_DESC_OCTET_LENGTH           1013
#define SQL_DESC_ALLOC_TYPE             1099
#endif

/* identifiers of fields in the diagnostics area */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_RETURNCODE        1
#define SQL_DIAG_NUMBER            2
#define SQL_DIAG_ROW_COUNT         3
#define SQL_DIAG_SQLSTATE          4
#define SQL_DIAG_NATIVE            5
#define SQL_DIAG_MESSAGE_TEXT      6
#define SQL_DIAG_DYNAMIC_FUNCTION  7
#define SQL_DIAG_CLASS_ORIGIN      8
#define SQL_DIAG_SUBCLASS_ORIGIN   9
#define SQL_DIAG_CONNECTION_NAME  10
#define SQL_DIAG_SERVER_NAME      11
#define SQL_DIAG_DYNAMIC_FUNCTION_CODE 12
#endif

/* dynamic function codes */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_ALTER_DOMAIN           3
#define SQL_DIAG_ALTER_TABLE            4
#define SQL_DIAG_CALL                   7
#define SQL_DIAG_CREATE_ASSERTION       6
#define SQL_DIAG_CREATE_CHARACTER_SET   8
#define SQL_DIAG_CREATE_COLLATION       10
#define SQL_DIAG_CREATE_DOMAIN          23
#define SQL_DIAG_CREATE_INDEX          (-1)
#define SQL_DIAG_CREATE_SCHEMA          64
#define SQL_DIAG_CREATE_TABLE          77
#define SQL_DIAG_CREATE_TRANSLATION     79
#define SQL_DIAG_CREATE_VIEW           84
#define SQL_DIAG_DELETE_WHERE          19
#define SQL_DIAG_DROP_ASSERTION         24
#define SQL_DIAG_DROP_CHARACTER_SET     25
#define SQL_DIAG_DROP_COLLATION         26
#define SQL_DIAG_DROP_DOMAIN            27
#define SQL_DIAG_DROP_INDEX            (-2)
#define SQL_DIAG_DROP_SCHEMA            31
#define SQL_DIAG_DROP_TABLE            32
#define SQL_DIAG_DROP_TRANSLATION      33
#define SQL_DIAG_DROP_VIEW             36
#define SQL_DIAG_DYNAMIC_DELETE_CURSOR 38
#define SQL_DIAG_DYNAMIC_UPDATE_CURSOR 81
#define SQL_DIAG_GRANT                 48
#define SQL_DIAG_INSERT                50
#define SQL_DIAG_REVOKE                59
#define SQL_DIAG_SELECT_CURSOR         85
#define SQL_DIAG_UNKNOWN_STATEMENT      0
#define SQL_DIAG_UPDATE_WHERE          82
#endif  /* ODBCVER >= 0x0300 */

/* SQL data type codes */
#define SQL_UNKNOWN_TYPE    0
#define SQL_CHAR            1
#define SQL_NUMERIC         2
#define SQL_DECIMAL         3
#define SQL_INTEGER         4
#define SQL_SMALLINT        5
#define SQL_FLOAT           6
#define SQL_REAL            7
#define SQL_DOUBLE          8
#if (ODBCVER >= 0x0300)
#define SQL_DATETIME        9
#endif
#define SQL_VARCHAR        12

/* One-parameter shortcuts for date/time data types */
#if (ODBCVER >= 0x0300)
#define SQL_TYPE_DATE      91
#define SQL_TYPE_TIME      92
#define SQL_TYPE_TIMESTAMP 93
#endif

/* Statement attribute values for cursor sensitivity */
#if (ODBCVER >= 0x0300)
#define SQL_UNSPECIFIED     0
#define SQL_INSENSITIVE     1
#define SQL_SENSITIVE       2
#endif

/* GetTypeInfo() request for all data types */
#define SQL_ALL_TYPES       0

/* Default conversion code for SQLBindCol(), SQLBindParam() and SQLGetData() */
#if (ODBCVER >= 0x0300)
#define SQL_DEFAULT        99
#endif

/* SQLSQLLEN GetData() code indicating that the application row descriptor
 * specifies the data type
 */
#if (ODBCVER >= 0x0300)
#define SQL_ARD_TYPE      (-99)
#endif

#if (ODBCVER >= 0x0380)
#define SQL_APD_TYPE      (-100)
#endif

/* SQL date/time type subcodes */
#if (ODBCVER >= 0x0300)
#define SQL_CODE_DATE       1
#define SQL_CODE_TIME       2
#define SQL_CODE_TIMESTAMP  3
#endif

/* CLI option values */
#if (ODBCVER >= 0x0300)
#define SQL_FALSE           0
#define SQL_TRUE            1
#endif

/* values of NULLABLE field in descriptor */
#define SQL_NO_NULLS        0
#define SQL_NULLABLE        1

/* Value returned by SQLGetTypeInfo() to denote that it is
 * not known whether or not a data type supports null values.
 */
#define SQL_NULLABLE_UNKNOWN  2

/* Values returned by SQLGetTypeInfo() to show WHERE clause
 * supported
 */
#if (ODBCVER >= 0x0300)
#define SQL_PRED_NONE     0
#define SQL_PRED_CHAR     1
#define SQL_PRED_BASIC    2
#endif

/* values of UNNAMED field in descriptor */
#if (ODBCVER >= 0x0300)
#define SQL_NAMED           0
#define SQL_UNNAMED         1
#endif

/* values of ALLOC_TYPE field in descriptor */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_ALLOC_AUTO 1
#define SQL_DESC_ALLOC_USER 2
#endif

/* FreeStmt() options */
#define SQL_CLOSE           0
#define SQL_DROP            1
#define SQL_UNBIND          2
#define SQL_RESET_PARAMS    3

/* Codes used for FetchOrientation in SQLFetchScroll(),
   and in SQLDataSources()
*/
#define SQL_FETCH_NEXT      1
#define SQL_FETCH_FIRST     2

/* Other codes used for FetchOrientation in SQLFetchScroll() */
#define SQL_FETCH_LAST      3
#define SQL_FETCH_PRIOR     4
#define SQL_FETCH_ABSOLUTE  5
#define SQL_FETCH_RELATIVE  6

/* SQLEndTran() options */
#define SQL_COMMIT          0
#define SQL_ROLLBACK        1

/* null handles returned by SQLAllocHandle() */
#define SQL_NULL_HENV       0
#define SQL_NULL_HDBC       0
#define SQL_NULL_HSTMT      0
#if (ODBCVER >= 0x0300)
#define SQL_NULL_HDESC      0
#endif

/* null handle used in place of parent handle when allocating HENV */
#if (ODBCVER >= 0x0300)
#define SQL_NULL_HANDLE     0L
#endif

/* Values that may appear in the result set of SQLSpecialColumns() */
#define SQL_SCOPE_CURROW    0
#define SQL_SCOPE_TRANSACTION 1
#define SQL_SCOPE_SESSION   2

#define SQL_PC_UNKNOWN      0
#if (ODBCVER >= 0x0300)
#define SQL_PC_NON_PSEUDO   1
#endif
#define SQL_PC_PSEUDO       2

/* Reserved value for the IdentifierType argument of SQLSpecialColumns() */
#if (ODBCVER >= 0x0300)
#define SQL_ROW_IDENTIFIER  1
#endif

/* Reserved values for UNIQUE argument of SQLStatistics() */
#define SQL_INDEX_UNIQUE    0
#define SQL_INDEX_ALL       1

/* Values that may appear in the result set of SQLStatistics() */
#define SQL_INDEX_CLUSTERED 1
#define SQL_INDEX_HASHED    2
#define SQL_INDEX_OTHER     3

/* SQLGetFunctions() values to identify ODBC APIs */
#define SQL_API_SQLALLOCCONNECT         1
#define SQL_API_SQLALLOCENV             2
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLALLOCHANDLE       1001
#endif
#define SQL_API_SQLALLOCSTMT            3
#define SQL_API_SQLBINDCOL              4
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLBINDPARAM         1002
#endif
#define SQL_API_SQLCANCEL               5
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLCLOSECURSOR       1003
#define SQL_API_SQLCOLATTRIBUTE         6
#endif
#define SQL_API_SQLCOLUMNS             40
#define SQL_API_SQLCONNECT              7
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLCOPYDESC          1004
#endif
#define SQL_API_SQLDATASOURCES         57
#define SQL_API_SQLDESCRIBECOL          8
#define SQL_API_SQLDISCONNECT           9
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLENDTRAN           1005
#endif
#define SQL_API_SQLERROR               10
#define SQL_API_SQLEXECDIRECT          11
#define SQL_API_SQLEXECUTE             12
#define SQL_API_SQLFETCH               13
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLFETCHSCROLL       1021
#endif
#define SQL_API_SQLFREECONNECT         14
#define SQL_API_SQLFREEENV             15
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLFREEHANDLE        1006
#endif
#define SQL_API_SQLFREESTMT            16
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLGETCONNECTATTR    1007
#endif
#define SQL_API_SQLGETCONNECTOPTION    42
#define SQL_API_SQLGETCURSORNAME       17
#define SQL_API_SQLGETDATA             43
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLGETDESCFIELD      1008
#define SQL_API_SQLGETDESCREC        1009
#define SQL_API_SQLGETDIAGFIELD      1010
#define SQL_API_SQLGETDIAGREC        1011
#define SQL_API_SQLGETENVATTR        1012
#endif
#define SQL_API_SQLGETFUNCTIONS        44
#define SQL_API_SQLGETINFO             45
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLGETSTMTATTR       1014
#endif
#define SQL_API_SQLGETSTMTOPTION       46
#define SQL_API_SQLGETTYPEINFO         47
#define SQL_API_SQLNUMRESULTCOLS       18
#define SQL_API_SQLPARAMDATA           48
#define SQL_API_SQLPREPARE             19
#define SQL_API_SQLPUTDATA             49
#define SQL_API_SQLROWCOUNT            20
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLSETCONNECTATTR    1016
#endif
#define SQL_API_SQLSETCONNECTOPTION    50
#define SQL_API_SQLSETCURSORNAME       21
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLSETDESCFIELD      1017
#define SQL_API_SQLSETDESCREC        1018
#define SQL_API_SQLSETENVATTR        1019
#endif
#define SQL_API_SQLSETPARAM            22
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLSETSTMTATTR       1020
#endif
#define SQL_API_SQLSETSTMTOPTION       51
#define SQL_API_SQLSPECIALCOLUMNS      52
#define SQL_API_SQLSTATISTICS          53
#define SQL_API_SQLTABLES              54
#define SQL_API_SQLTRANSACT            23

#if (ODBCVER >= 0x0380)
#define SQL_API_SQLCANCELHANDLE      1022
#endif

/* Information requested by SQLGetInfo() */
#if (ODBCVER >= 0x0300)
#define SQL_MAX_DRIVER_CONNECTIONS           0
#define SQL_MAXIMUM_DRIVER_CONNECTIONS      SQL_MAX_DRIVER_CONNECTIONS
#define SQL_MAX_CONCURRENT_ACTIVITIES        1
#define SQL_MAXIMUM_CONCURRENT_ACTIVITIES   SQL_MAX_CONCURRENT_ACTIVITIES
#endif
#define SQL_DATA_SOURCE_NAME                 2
#define SQL_FETCH_DIRECTION                  8
#define SQL_SERVER_NAME                     13
#define SQL_SEARCH_PATTERN_ESCAPE           14
#define SQL_DBMS_NAME                       17
#define SQL_DBMS_VER                        18
#define SQL_ACCESSIBLE_TABLES               19
#define SQL_ACCESSIBLE_PROCEDURES           20
#define SQL_CURSOR_COMMIT_BEHAVIOR          23
#define SQL_DATA_SOURCE_READ_ONLY           25
#define SQL_DEFAULT_TXN_ISOLATION           26
#define SQL_IDENTIFIER_CASE                 28
#define SQL_IDENTIFIER_QUOTE_CHAR           29
#define SQL_MAX_COLUMN_NAME_LEN             30
#define SQL_MAXIMUM_COLUMN_NAME_LENGTH      SQL_MAX_COLUMN_NAME_LEN
#define SQL_MAX_CURSOR_NAME_LEN             31
#define SQL_MAXIMUM_CURSOR_NAME_LENGTH      SQL_MAX_CURSOR_NAME_LEN
#define SQL_MAX_SCHEMA_NAME_LEN             32
#define SQL_MAXIMUM_SCHEMA_NAME_LENGTH      SQL_MAX_SCHEMA_NAME_LEN
#define SQL_MAX_CATALOG_NAME_LEN            34
#define SQL_MAXIMUM_CATALOG_NAME_LENGTH     SQL_MAX_CATALOG_NAME_LEN
#define SQL_MAX_TABLE_NAME_LEN              35
#define SQL_SCROLL_CONCURRENCY              43
#define SQL_TXN_CAPABLE                     46
#define SQL_TRANSACTION_CAPABLE             SQL_TXN_CAPABLE
#define SQL_USER_NAME                       47
#define SQL_TXN_ISOLATION_OPTION            72
#define SQL_TRANSACTION_ISOLATION_OPTION    SQL_TXN_ISOLATION_OPTION
#define SQL_INTEGRITY                       73
#define SQL_GETDATA_EXTENSIONS              81
#define SQL_NULL_COLLATION                  85
#define SQL_ALTER_TABLE                     86
#define SQL_ORDER_BY_COLUMNS_IN_SELECT      90
#define SQL_SPECIAL_CHARACTERS              94
#define SQL_MAX_COLUMNS_IN_GROUP_BY         97
#define SQL_MAXIMUM_COLUMNS_IN_GROUP_BY     SQL_MAX_COLUMNS_IN_GROUP_BY
#define SQL_MAX_COLUMNS_IN_INDEX            98
#define SQL_MAXIMUM_COLUMNS_IN_INDEX        SQL_MAX_COLUMNS_IN_INDEX
#define SQL_MAX_COLUMNS_IN_ORDER_BY         99
#define SQL_MAXIMUM_COLUMNS_IN_ORDER_BY     SQL_MAX_COLUMNS_IN_ORDER_BY
#define SQL_MAX_COLUMNS_IN_SELECT          100
#define SQL_MAXIMUM_COLUMNS_IN_SELECT      SQL_MAX_COLUMNS_IN_SELECT
#define SQL_MAX_COLUMNS_IN_TABLE           101
#define SQL_MAX_INDEX_SIZE                 102
#define SQL_MAXIMUM_INDEX_SIZE             SQL_MAX_INDEX_SIZE
#define SQL_MAX_ROW_SIZE                   104
#define SQL_MAXIMUM_ROW_SIZE               SQL_MAX_ROW_SIZE
#define SQL_MAX_STATEMENT_LEN              105
#define SQL_MAXIMUM_STATEMENT_LENGTH       SQL_MAX_STATEMENT_LEN
#define SQL_MAX_TABLES_IN_SELECT           106
#define SQL_MAXIMUM_TABLES_IN_SELECT       SQL_MAX_TABLES_IN_SELECT
#define SQL_MAX_USER_NAME_LEN              107
#define SQL_MAXIMUM_USER_NAME_LENGTH       SQL_MAX_USER_NAME_LEN
#if (ODBCVER >= 0x0300)
#define SQL_OJ_CAPABILITIES                115
#define SQL_OUTER_JOIN_CAPABILITIES        SQL_OJ_CAPABILITIES
#endif /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0300)
#define SQL_XOPEN_CLI_YEAR               10000
#define SQL_CURSOR_SENSITIVITY           10001
#define SQL_DESCRIBE_PARAMETER           10002
#define SQL_CATALOG_NAME                 10003
#define SQL_COLLATION_SEQ                10004
#define SQL_MAX_IDENTIFIER_LEN           10005
#define SQL_MAXIMUM_IDENTIFIER_LENGTH    SQL_MAX_IDENTIFIER_LEN
#endif /* ODBCVER >= 0x0300 */

/* SQL_ALTER_TABLE bitmasks */
#if (ODBCVER >= 0x0200)
#define SQL_AT_ADD_COLUMN                       0x00000001L
#define SQL_AT_DROP_COLUMN                      0x00000002L
#endif /* ODBCVER >= 0x0200 */

#if (ODBCVER >= 0x0300)
#define SQL_AT_ADD_CONSTRAINT                   0x00000008L

/* The following bitmasks are ODBC extensions and defined in sqlext.h
*#define    SQL_AT_COLUMN_SINGLE                    0x00000020L
*#define    SQL_AT_ADD_COLUMN_DEFAULT               0x00000040L
*#define    SQL_AT_ADD_COLUMN_COLLATION             0x00000080L
*#define    SQL_AT_SET_COLUMN_DEFAULT               0x00000100L
*#define    SQL_AT_DROP_COLUMN_DEFAULT              0x00000200L
*#define    SQL_AT_DROP_COLUMN_CASCADE              0x00000400L
*#define    SQL_AT_DROP_COLUMN_RESTRICT             0x00000800L
*#define SQL_AT_ADD_TABLE_CONSTRAINT                0x00001000L
*#define SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE       0x00002000L
*#define SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT      0x00004000L
*#define SQL_AT_CONSTRAINT_NAME_DEFINITION          0x00008000L
*#define SQL_AT_CONSTRAINT_INITIALLY_DEFERRED       0x00010000L
*#define SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE      0x00020000L
*#define SQL_AT_CONSTRAINT_DEFERRABLE               0x00040000L
*#define SQL_AT_CONSTRAINT_NON_DEFERRABLE           0x00080000L
*/
#endif  /* ODBCVER >= 0x0300 */


/* SQL_ASYNC_MODE values */
#if (ODBCVER >= 0x0300)
#define SQL_AM_NONE                         0
#define SQL_AM_CONNECTION                   1
#define SQL_AM_STATEMENT                    2
#endif

/* SQL_CURSOR_COMMIT_BEHAVIOR values */
#define SQL_CB_DELETE                       0
#define SQL_CB_CLOSE                        1
#define SQL_CB_PRESERVE                     2

/* SQL_FETCH_DIRECTION bitmasks */
#define SQL_FD_FETCH_NEXT                   0x00000001L
#define SQL_FD_FETCH_FIRST                  0x00000002L
#define SQL_FD_FETCH_LAST                   0x00000004L
#define SQL_FD_FETCH_PRIOR                  0x00000008L
#define SQL_FD_FETCH_ABSOLUTE               0x00000010L
#define SQL_FD_FETCH_RELATIVE               0x00000020L

/* SQL_GETDATA_EXTENSIONS bitmasks */
#define SQL_GD_ANY_COLUMN                   0x00000001L
#define SQL_GD_ANY_ORDER                    0x00000002L

/* SQL_IDENTIFIER_CASE values */
#define SQL_IC_UPPER                        1
#define SQL_IC_LOWER                        2
#define SQL_IC_SENSITIVE                    3
#define SQL_IC_MIXED                        4

/* SQL_OJ_CAPABILITIES bitmasks */
/* NB: this means 'outer join', not what  you may be thinking */


#if (ODBCVER >= 0x0201)
#define SQL_OJ_LEFT                         0x00000001L
#define SQL_OJ_RIGHT                        0x00000002L
#define SQL_OJ_FULL                         0x00000004L
#define SQL_OJ_NESTED                       0x00000008L
#define SQL_OJ_NOT_ORDERED                  0x00000010L
#define SQL_OJ_INNER                        0x00000020L
#define SQL_OJ_ALL_COMPARISON_OPS           0x00000040L
#endif

/* SQL_SCROLL_CONCURRENCY bitmasks */
#define SQL_SCCO_READ_ONLY                  0x00000001L
#define SQL_SCCO_LOCK                       0x00000002L
#define SQL_SCCO_OPT_ROWVER                 0x00000004L
#define SQL_SCCO_OPT_VALUES                 0x00000008L

/* SQL_TXN_CAPABLE values */
#define SQL_TC_NONE                         0
#define SQL_TC_DML                          1
#define SQL_TC_ALL                          2
#define SQL_TC_DDL_COMMIT                   3
#define SQL_TC_DDL_IGNORE                   4

/* SQL_TXN_ISOLATION_OPTION bitmasks */
#define SQL_TXN_READ_UNCOMMITTED            0x00000001L
#define SQL_TRANSACTION_READ_UNCOMMITTED    SQL_TXN_READ_UNCOMMITTED
#define SQL_TXN_READ_COMMITTED              0x00000002L
#define SQL_TRANSACTION_READ_COMMITTED      SQL_TXN_READ_COMMITTED
#define SQL_TXN_REPEATABLE_READ             0x00000004L
#define SQL_TRANSACTION_REPEATABLE_READ     SQL_TXN_REPEATABLE_READ
#define SQL_TXN_SERIALIZABLE                0x00000008L
#define SQL_TRANSACTION_SERIALIZABLE        SQL_TXN_SERIALIZABLE

/* SQL_NULL_COLLATION values */
#define SQL_NC_HIGH                         0
#define SQL_NC_LOW                          1

#ifndef RC_INVOKED

SQLRETURN  SQL_API SQLAllocConnect(SQLHENV EnvironmentHandle,
           __out SQLHDBC *ConnectionHandle);

SQLRETURN  SQL_API SQLAllocEnv(__out SQLHENV *EnvironmentHandle);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLAllocHandle(SQLSMALLINT HandleType,
           SQLHANDLE InputHandle, __out SQLHANDLE *OutputHandle);
#endif

SQLRETURN  SQL_API SQLAllocStmt(SQLHDBC ConnectionHandle,
           __out SQLHSTMT *StatementHandle);

SQLRETURN  SQL_API SQLBindCol(SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType,
           __inout_xcount_opt(BufferLength) SQLPOINTER TargetValue, 
           SQLLEN BufferLength, __inout_opt SQLLEN *StrLen_or_Ind);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLBindParam(SQLHSTMT StatementHandle,
           SQLUSMALLINT ParameterNumber, SQLSMALLINT ValueType,
           SQLSMALLINT ParameterType, SQLULEN LengthPrecision,
           SQLSMALLINT ParameterScale, SQLPOINTER ParameterValue,
           SQLLEN *StrLen_or_Ind);
#endif

SQLRETURN  SQL_API SQLCancel(SQLHSTMT StatementHandle);

#if (ODBCVER >= 0x0380)
SQLRETURN  SQL_API SQLCancelHandle(SQLSMALLINT HandleType, SQLHANDLE InputHandle);
#endif // ODBCVER >= 0x0380

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLCloseCursor(SQLHSTMT StatementHandle);

#ifdef _WIN64
SQLRETURN  SQL_API SQLColAttribute (SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLUSMALLINT FieldIdentifier,
           __out_bcount_opt(BufferLength) SQLPOINTER CharacterAttribute, SQLSMALLINT BufferLength,
           __out_opt SQLSMALLINT *StringLength, __out_opt SQLLEN *NumericAttribute);
#else
SQLRETURN  SQL_API SQLColAttribute (SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLUSMALLINT FieldIdentifier,
           __out_bcount_opt(BufferLength) SQLPOINTER CharacterAttribute, SQLSMALLINT BufferLength,
           __out_opt SQLSMALLINT *StringLength, __out_opt SQLPOINTER NumericAttribute);
#endif
#endif


SQLRETURN  SQL_API SQLColumns(SQLHSTMT StatementHandle,
           __in_ecount_opt(NameLength1) SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           __in_ecount_opt(NameLength2) SQLCHAR *SchemaName, SQLSMALLINT NameLength2,
           __in_ecount_opt(NameLength3) SQLCHAR *TableName, SQLSMALLINT NameLength3,
           __in_ecount_opt(NameLength4) SQLCHAR *ColumnName, SQLSMALLINT NameLength4);


SQLRETURN  SQL_API SQLConnect(SQLHDBC ConnectionHandle,
           __in_ecount(NameLength1) SQLCHAR *ServerName, SQLSMALLINT NameLength1,
           __in_ecount(NameLength2) SQLCHAR *UserName, SQLSMALLINT NameLength2,
           __in_ecount(NameLength3) SQLCHAR *Authentication, SQLSMALLINT NameLength3);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLCopyDesc(SQLHDESC SourceDescHandle,
           SQLHDESC TargetDescHandle);
#endif

SQLRETURN  SQL_API SQLDataSources(SQLHENV EnvironmentHandle,
           SQLUSMALLINT Direction, __out_ecount_opt(BufferLength1) SQLCHAR *ServerName,
           SQLSMALLINT BufferLength1, __out_opt SQLSMALLINT *NameLength1Ptr,
           __out_ecount_opt(BufferLength2) SQLCHAR *Description, SQLSMALLINT BufferLength2,
           __out_opt SQLSMALLINT *NameLength2Ptr);

SQLRETURN  SQL_API SQLDescribeCol(SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, __out_ecount_opt(BufferLength) SQLCHAR *ColumnName,
           SQLSMALLINT BufferLength, __out_opt SQLSMALLINT *NameLength,
           __out_opt SQLSMALLINT *DataType, __out_opt SQLULEN *ColumnSize,
           __out_opt SQLSMALLINT *DecimalDigits, __out_opt SQLSMALLINT *Nullable);

SQLRETURN  SQL_API SQLDisconnect(SQLHDBC ConnectionHandle);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLEndTran(SQLSMALLINT HandleType, SQLHANDLE Handle,
           SQLSMALLINT CompletionType);
#endif

SQLRETURN  SQL_API SQLError(SQLHENV EnvironmentHandle,
           SQLHDBC ConnectionHandle, SQLHSTMT StatementHandle,
           __out_ecount(6) SQLCHAR *Sqlstate, __out_opt SQLINTEGER *NativeError,
           __out_ecount_opt(BufferLength) SQLCHAR *MessageText, SQLSMALLINT BufferLength,
           __out_opt SQLSMALLINT *TextLength);

SQLRETURN  SQL_API SQLExecDirect
(
    SQLHSTMT StatementHandle,
    __in_ecount_opt(TextLength) SQLCHAR* StatementText,
    SQLINTEGER TextLength
);

SQLRETURN  SQL_API SQLExecute(SQLHSTMT StatementHandle);

SQLRETURN  SQL_API SQLFetch(SQLHSTMT StatementHandle);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLFetchScroll(SQLHSTMT StatementHandle,
           SQLSMALLINT FetchOrientation, SQLLEN FetchOffset);
#endif

SQLRETURN  SQL_API SQLFreeConnect(SQLHDBC ConnectionHandle);

SQLRETURN  SQL_API SQLFreeEnv(SQLHENV EnvironmentHandle);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle);
#endif

SQLRETURN  SQL_API SQLFreeStmt(SQLHSTMT StatementHandle,
           SQLUSMALLINT Option);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLGetConnectAttr(SQLHDBC ConnectionHandle,
           SQLINTEGER Attribute, __out_xcount_opt(BufferLength) SQLPOINTER Value,
           SQLINTEGER BufferLength, __out_opt SQLINTEGER *StringLengthPtr);
#endif

SQLRETURN  SQL_API SQLGetConnectOption(SQLHDBC ConnectionHandle,
           SQLUSMALLINT Option, SQLPOINTER Value);

SQLRETURN  SQL_API SQLGetCursorName
(
    SQLHSTMT StatementHandle,
    __out_ecount_opt(BufferLength) SQLCHAR *CursorName,
    SQLSMALLINT BufferLength,
    __out_opt
    SQLSMALLINT *NameLengthPtr
);

SQLRETURN  SQL_API SQLGetData(SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType,
           __out_xcount_opt(BufferLength) SQLPOINTER TargetValue, SQLLEN BufferLength,
           __out_opt SQLLEN *StrLen_or_IndPtr);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLGetDescField(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
           __out_xcount_opt(BufferLength) SQLPOINTER Value, SQLINTEGER BufferLength,
           __out_opt SQLINTEGER *StringLength);

SQLRETURN  SQL_API SQLGetDescRec(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, __out_ecount_opt(BufferLength) SQLCHAR *Name,
           SQLSMALLINT BufferLength, __out_opt SQLSMALLINT *StringLengthPtr,
           __out_opt SQLSMALLINT *TypePtr, __out_opt SQLSMALLINT *SubTypePtr,
           __out_opt SQLLEN     *LengthPtr, __out_opt SQLSMALLINT *PrecisionPtr,
           __out_opt SQLSMALLINT *ScalePtr, __out_opt SQLSMALLINT *NullablePtr);

SQLRETURN  SQL_API SQLGetDiagField(SQLSMALLINT HandleType, SQLHANDLE Handle,
           SQLSMALLINT RecNumber, SQLSMALLINT DiagIdentifier,
           __out_xcount_opt(BufferLength) SQLPOINTER DiagInfo, SQLSMALLINT BufferLength,
           __out_opt SQLSMALLINT *StringLength);

SQLRETURN  SQL_API SQLGetDiagRec
(
    SQLSMALLINT HandleType,
    SQLHANDLE Handle,
    SQLSMALLINT RecNumber,
    __out_ecount_opt(6) SQLCHAR *Sqlstate,
    SQLINTEGER *NativeError,
    __out_ecount_opt(BufferLength) SQLCHAR* MessageText,
    SQLSMALLINT BufferLength,
    __out_opt
    SQLSMALLINT *TextLength
);

SQLRETURN  SQL_API SQLGetEnvAttr(SQLHENV EnvironmentHandle,
           SQLINTEGER Attribute, __out_xcount(BufferLength) SQLPOINTER Value,
           SQLINTEGER BufferLength, __out_opt SQLINTEGER *StringLength);
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLGetFunctions(SQLHDBC ConnectionHandle,
           SQLUSMALLINT FunctionId, 
           __out_xcount_opt("Buffer length pfExists points to depends on fFunction value.") 
           SQLUSMALLINT *Supported);

__success(return == SQL_SUCCESS)
SQLRETURN  SQL_API SQLGetInfo(SQLHDBC ConnectionHandle,
           SQLUSMALLINT InfoType, __out_bcount_opt(BufferLength) SQLPOINTER InfoValue,
           SQLSMALLINT BufferLength, __out_opt SQLSMALLINT *StringLengthPtr);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLGetStmtAttr(SQLHSTMT StatementHandle,
           SQLINTEGER Attribute, __out_xcount_opt(BufferLength) SQLPOINTER Value,
           SQLINTEGER BufferLength, __out_opt SQLINTEGER *StringLength);
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLGetStmtOption(SQLHSTMT StatementHandle,
           SQLUSMALLINT Option, SQLPOINTER Value);

SQLRETURN  SQL_API SQLGetTypeInfo(SQLHSTMT StatementHandle,
           SQLSMALLINT DataType);

SQLRETURN  SQL_API SQLNumResultCols(SQLHSTMT StatementHandle,
           __out SQLSMALLINT *ColumnCount);

SQLRETURN  SQL_API SQLParamData(SQLHSTMT StatementHandle,
           __out_opt SQLPOINTER *Value);

SQLRETURN  SQL_API SQLPrepare
(
    SQLHSTMT StatementHandle,
    __in_ecount(TextLength) SQLCHAR* StatementText,
    SQLINTEGER TextLength
);

SQLRETURN  SQL_API SQLPutData(SQLHSTMT StatementHandle,
           __in_xcount(StrLen_or_Ind) SQLPOINTER Data, SQLLEN StrLen_or_Ind);

SQLRETURN  SQL_API SQLRowCount(__in SQLHSTMT StatementHandle,
                               __out SQLLEN* RowCount);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetConnectAttr(SQLHDBC ConnectionHandle,
           SQLINTEGER Attribute, __in_bcount_opt(StringLength) SQLPOINTER Value,
           SQLINTEGER StringLength);
#endif /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLSetConnectOption(SQLHDBC ConnectionHandle,
           SQLUSMALLINT Option, SQLULEN Value);

SQLRETURN  SQL_API SQLSetCursorName
(
    SQLHSTMT StatementHandle,
    __in_ecount(NameLength) SQLCHAR* CursorName,
    SQLSMALLINT NameLength
);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetDescField(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
           __in_xcount(BufferLength) SQLPOINTER Value, SQLINTEGER BufferLength);

SQLRETURN  SQL_API SQLSetDescRec(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLSMALLINT Type,
           SQLSMALLINT SubType, SQLLEN Length,
           SQLSMALLINT Precision, SQLSMALLINT Scale,
           __inout_bcount_opt(Length) SQLPOINTER Data, __inout_opt SQLLEN *StringLength,
           __inout_opt SQLLEN *Indicator);

SQLRETURN  SQL_API SQLSetEnvAttr(SQLHENV EnvironmentHandle,
           SQLINTEGER Attribute, __in_bcount(StringLength) SQLPOINTER Value,
           SQLINTEGER StringLength);
#endif /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLSetParam(SQLHSTMT StatementHandle,
           SQLUSMALLINT ParameterNumber, SQLSMALLINT ValueType,
           SQLSMALLINT ParameterType, SQLULEN LengthPrecision,
           SQLSMALLINT ParameterScale, __in_xcount(*StrLen_or_Ind) SQLPOINTER ParameterValue,
           __inout SQLLEN *StrLen_or_Ind);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetStmtAttr(SQLHSTMT StatementHandle,
           SQLINTEGER Attribute, __in_xcount(StringLength) SQLPOINTER Value,
           SQLINTEGER StringLength);
#endif

SQLRETURN  SQL_API SQLSetStmtOption(SQLHSTMT StatementHandle,
           SQLUSMALLINT Option, SQLULEN Value);

SQLRETURN  SQL_API SQLSpecialColumns(SQLHSTMT StatementHandle,
           SQLUSMALLINT IdentifierType, 
           __in_ecount_opt(NameLength1) SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           __in_ecount_opt(NameLength2) SQLCHAR *SchemaName, SQLSMALLINT NameLength2, 
           __in_ecount_opt(NameLength3) SQLCHAR *TableName, SQLSMALLINT NameLength3, 
           SQLUSMALLINT Scope, SQLUSMALLINT Nullable);

SQLRETURN  SQL_API SQLStatistics(SQLHSTMT StatementHandle,
           __in_ecount_opt(NameLength1) SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           __in_ecount_opt(NameLength2) SQLCHAR *SchemaName, SQLSMALLINT NameLength2,
           __in_ecount_opt(NameLength3) SQLCHAR *TableName, SQLSMALLINT NameLength3,
           SQLUSMALLINT Unique, SQLUSMALLINT Reserved);

SQLRETURN  SQL_API SQLTables(SQLHSTMT StatementHandle,
           __in_ecount_opt(NameLength1) SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           __in_ecount_opt(NameLength2) SQLCHAR *SchemaName, SQLSMALLINT NameLength2,
           __in_ecount_opt(NameLength3) SQLCHAR *TableName, SQLSMALLINT NameLength3,
           __in_ecount_opt(NameLength4) SQLCHAR *TableType, SQLSMALLINT NameLength4);

SQLRETURN  SQL_API SQLTransact(SQLHENV EnvironmentHandle,
           SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType);

#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */
#endif  /* #ifndef __SQL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\speventq.h ===
/*******************************************************************************
// Copyright Microsoft Corporation. All Rights Reserved. 
* SPEventQ.h *
*------------*
*   Description:
*       This is the header file for the SAPI5 event queue implementation.
*-------------------------------------------------------------------------------
*******************************************************************************/
#ifndef SPEventQ_h
#define SPEventQ_h

#ifndef SPHelper_h
#include <SPHelper.h>
#endif

#ifdef ETW_TRACE_HEADER
#ifdef SOFTWARE_TRACING
#include <speventq.tmh>
#endif
#endif


//=== Inline helpers for copying and deleting events ============================


//=== Class definition ==========================================================




// This class wraps the SPEVENTEX structure providing a next pointer to allow it to be used in queues;
// and helper methods to serialize and deserialize.
// This has some similar code to CSpEvent in sphelper.h, but that method is public and not based on
// SPEVENTEX.
class CSpEventExNode : public SPEVENTEX
{
public:
    CSpEventExNode()
    {
        memset(this, 0, sizeof(SPEVENTEX));
    }
    ~CSpEventExNode()
    {
        Clear();
    }

    CSpEventExNode    * m_pNext;

    static LONG Compare(const CSpEventExNode * p1, const CSpEventExNode *p2)
    {
        // Assumes offsets DO or DO NOT reset when stream number changes
        if (p1->ulStreamNum < p2->ulStreamNum)
        {
            return -1;
        }
        else if (p1->ulStreamNum > p2->ulStreamNum)
        {
            return 1;
        }
        else if (p1->ullAudioStreamOffset < p2->ullAudioStreamOffset)
        {
            return -1;
        }
        else if (p1->ullAudioStreamOffset > p2->ullAudioStreamOffset)
        {
            return 1;
        }
        return 0;
    }

    // Clears the event and releases associated memory
    void Clear()
    {
        if (elParamType != SPEI_UNDEFINED)
        {
            if (elParamType == SPET_LPARAM_IS_POINTER ||
                elParamType == SPET_LPARAM_IS_STRING)
            {
                ::CoTaskMemFree((void *)lParam);
            }
            else if (elParamType == SPET_LPARAM_IS_TOKEN ||
                elParamType == SPET_LPARAM_IS_OBJECT)
            {
                ((IUnknown*)lParam)->Release();
            }
        }
        memset(this, 0, sizeof(SPEVENTEX));
    }

    // Copy data from this class to an SPEVENTEX, making new copies of associated memory
    HRESULT CopyTo(SPEVENTEX * pDestEvent) const
    {
        memcpy(pDestEvent, this, sizeof(*pDestEvent));
        if ((elParamType == SPET_LPARAM_IS_POINTER) && lParam)
        {
            _ASSERT(wParam && (wParam < 0x100000));    // this is too big!
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(wParam);
            if (pDestEvent->lParam)
            {
                memcpy((void *)pDestEvent->lParam, (void *)lParam, wParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_STRING && lParam != NULL)
        {
			size_t cbLen = (wcslen((WCHAR*)lParam) + 1) * sizeof(WCHAR);
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(cbLen);
            if (pDestEvent->lParam)
            {
                StringCbCopyW ((WCHAR*)pDestEvent->lParam, cbLen, (WCHAR*)lParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_TOKEN ||
               elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)lParam)->AddRef();
        }
        return S_OK;
    }

    // Initialize this object from an existing SPEVENTEX, copying associated memory
    HRESULT CopyFrom(const SPEVENTEX * pSrcEvent)
    {
        Clear();
        return static_cast<const CSpEventExNode *>(pSrcEvent)->CopyTo(this);
    }

    // Finds the additional size of data needed to be appended to the end of the event when serializing
    ULONG ExtraDataSize() const
    {
        ULONG ulSize = 0;

        if( ( elParamType == SPET_LPARAM_IS_POINTER ) && lParam )
        {
            ulSize += ULONG(wParam);
        }
        else if ((elParamType == SPET_LPARAM_IS_STRING) && lParam != NULL)
        {
            // Would be better to check for overflow of string length.
            ulSize += ((ULONG) wcslen((WCHAR*)lParam) + 1) * sizeof( WCHAR );
        }
        else if( elParamType == SPET_LPARAM_IS_TOKEN )
        {
            CSpDynamicString dstrObjectId;
            if( ((ISpObjectToken*)(lParam))->GetId( &dstrObjectId ) == S_OK )
            {
                ulSize += (dstrObjectId.Length() + 1) * sizeof( WCHAR );
            }
            else
            {
                return (ULONG)-1;
            }
        }
        // Round up to nearest DWORD
        ulSize += 3;
        ulSize -= ulSize % 4;
        return ulSize;
    }

    // Size of SPSERIALIZEDEVENT64 with ullAudioTimeOffset appended
    ULONG SerializeSizeEx() const
    {
        ULONG ulSize = ExtraDataSize();
        return (ulSize == (ULONG)-1) ? 0 : sizeof(SPSERIALIZEDEVENT64) + ulSize + sizeof(ULONGLONG);
    }

    // Size of regular 32 bit SPSERIALIZEDEVENT
    ULONG SerializeSize() const
    {
        ULONG ulSize = ExtraDataSize();
        return (ulSize == (ULONG)-1) ? 0 : sizeof(SPSERIALIZEDEVENT) + ulSize;
    }

    // Call this method with either SPSERIALIZEDEVENT or SPSERIALIZEDEVENT64
    template <class T>
    HRESULT Serialize(T * pSerEvent) const
    {
        HRESULT hr = S_OK;

        _ASSERT(elParamType != SPET_LPARAM_IS_OBJECT);
        pSerEvent->eEventId = this->eEventId;
        pSerEvent->elParamType = this->elParamType;
        pSerEvent->ulStreamNum = this->ulStreamNum;
        pSerEvent->ullAudioStreamOffset = this->ullAudioStreamOffset;
        SerializeParams(pSerEvent);
        if (lParam)
        {
            switch(elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                memcpy(pSerEvent + 1, (void *)lParam, wParam);
                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_STRING:
                StringCchCopyW ((WCHAR *)(pSerEvent + 1), wcslen ((WCHAR*) lParam) + 1, (WCHAR*)lParam);

                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    CSpDynamicString dstrObjectId;
                    hr = ((ISpObjectToken*)lParam)->GetId( &dstrObjectId );
                    if( SUCCEEDED( hr ) )
                    {
                        pSerEvent->SerializedwParam = (dstrObjectId.Length() + 1) * sizeof( WCHAR );;
                        memcpy( pSerEvent + 1, (void *)dstrObjectId.m_psz, static_cast<ULONG>(pSerEvent->SerializedwParam) );
                    }
                    pSerEvent->SerializedlParam = sizeof(T);
                }
                break;

            default:
                break;
            }
        }
        return hr;
    }

    void SerializeParams(__unaligned SPSERIALIZEDEVENT * pSerEvent) const
    {
        pSerEvent->SerializedwParam = (ULONG)this->wParam;
        pSerEvent->SerializedlParam = (LONG)this->lParam;
    }

    void SerializeParams(__unaligned SPSERIALIZEDEVENT64 * pSerEvent) const
    {
        pSerEvent->SerializedwParam = (ULONGLONG)this->wParam;
        pSerEvent->SerializedlParam = (LONGLONG)this->lParam;
    }

    // Serialize into an SPSERIALIZEDEVENT64 structure. The ullAudioTimeOffset field is appended at 
    // the end of the other serialized data. This is to make this structure binary compatible with SAPI 5.1
    // code trying to deserialize it.
    HRESULT SerializeEx(SPSERIALIZEDEVENT64* pSerEvent) const
    {
        ULONG ulSize = SerializeSizeEx();
        if (ulSize == 0) 
        {
            return E_FAIL;
        }
        *(UNALIGNED ULONGLONG*)((BYTE*)pSerEvent + ulSize - sizeof(ULONGLONG)) = ullAudioTimeOffset;
        return Serialize(pSerEvent);
    }

    // Deserialize into this class, assuming ullAudioTimeOffset included
    HRESULT DeserializeEx(const SPSERIALIZEDEVENT64 *pSerEvent, ULONG cbSize)
    {
        Clear();
        HRESULT hr = S_OK;
        const UNALIGNED SPSERIALIZEDEVENT64 * pTemp = pSerEvent;
        if (cbSize < sizeof(*pTemp) + sizeof(ULONGLONG))
        {
            return E_INVALIDARG;
        }
        size_t cbExtraSize = cbSize - sizeof(*pTemp) - sizeof(ULONGLONG);

        this->eEventId = pTemp->eEventId;
        this->elParamType = pTemp->elParamType;
        this->ulStreamNum = pTemp->ulStreamNum;
        this->ullAudioStreamOffset = pTemp->ullAudioStreamOffset;
        this->wParam = static_cast<WPARAM>(pTemp->SerializedwParam);
        this->lParam = static_cast<LPARAM>(pTemp->SerializedlParam);
        size_t cbAlloc = 0;

        if (pTemp->SerializedlParam)
        {
            switch (pTemp->elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                cbAlloc = static_cast<ULONG>(wParam);
                if (cbAlloc > cbExtraSize)
                {
                    hr = E_INVALIDARG;
                }
                break;

            case SPET_LPARAM_IS_STRING:
                hr = CheckStringSizeBytes((WCHAR *)(pTemp + 1), cbExtraSize, &cbAlloc);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    hr = CheckStringSizeBytes((WCHAR *)(pTemp + 1), cbExtraSize, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = SpGetTokenFromId( (const WCHAR*)(pTemp + 1), (ISpObjectToken **)&lParam );
                        wParam = 0;
                    }
                }
                break;
            case SPET_LPARAM_IS_UNDEFINED:
                break;
            case SPET_LPARAM_IS_OBJECT:
                hr = E_INVALIDARG;
                break;
            default:
                hr = E_INVALIDARG;
                break;
            }

            if (SUCCEEDED(hr) && cbAlloc)
            {
                void * pvBuff = ::CoTaskMemAlloc(cbAlloc);
                this->lParam = (LPARAM)pvBuff;
                if (pvBuff)
                {
                    memcpy(pvBuff, pTemp + 1, cbAlloc);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            ullAudioTimeOffset = *(UNALIGNED ULONGLONG*)((BYTE*)pTemp + cbSize - sizeof(ULONGLONG));
            _ASSERT(cbSize == SerializeSizeEx());
        }
        else
        {
            memset(this, 0, sizeof(*this));
        }

        return hr;
    }
};



typedef CSpBasicQueue<CSpEventExNode, TRUE, TRUE> CSpEventList;

#define DECLARE_SPNOTIFYSOURCE_METHODS(T) \
STDMETHODIMP SetNotifySink(ISpNotifySink * pNotifySink) \
{ return T._SetNotifySink(pNotifySink); } \
STDMETHODIMP SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyWindowMessage(hWnd, Msg, wParam, lParam); } \
STDMETHODIMP SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyCallbackFunction(pfnCallback, wParam, lParam); } \
STDMETHODIMP SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyCallbackInterface(pSpCallback, wParam, lParam); } \
STDMETHODIMP SetNotifyWin32Event() \
{ return T._SetNotifyWin32Event(); } \
STDMETHODIMP WaitForNotifyEvent(DWORD dwMilliseconds) \
{ return T._WaitForNotifyEvent(dwMilliseconds); } \
STDMETHODIMP_(HANDLE) GetNotifyEventHandle() \
{ return T._GetNotifyEventHandle(); } 

#define DECLARE_SPEVENTSOURCE_METHODS(T) \
DECLARE_SPNOTIFYSOURCE_METHODS(T) \
STDMETHODIMP SetInterest(ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest) \
{ return T._SetInterest(ullEventInterest, ullQueuedInterest); } \
STDMETHODIMP GetEvents(ULONG ulCount, SPEVENT* pEventArray, ULONG * pulFetched) \
{ return T._GetEvents(ulCount, pEventArray, pulFetched); } \
STDMETHODIMP GetInfo(SPEVENTSOURCEINFO *pInfo) \
{ return T._GetInfo(pInfo); }



class CSpEventSource 
{
  public:
    CSpEventSource(CComObjectRootEx<CComMultiThreadModel> * pParent, bool fSortEvents = true) :
        m_pParent(pParent),
        m_fSortEvents(fSortEvents)
    {
        m_ullEventInterest = 0; m_ullQueuedInterest = 0;
        m_ulStreamNum = 0;
    }
    HRESULT _SetNotifySink(ISpNotifySink * pNotifySink);
    HRESULT _SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyWin32Event();
    HRESULT _WaitForNotifyEvent(DWORD dwMilliseconds);
    HANDLE  _GetNotifyEventHandle();

    HRESULT _SetInterest(ULONGLONG ullEventInterest , ULONGLONG ullQueuedInterest);

    template <class T>
    inline HRESULT _GetEvents( ULONG ulCount, T* pEventArray, ULONG *pulFetched )
    {
        HRESULT hr = S_OK;
        m_pParent->Lock();
        if( SPIsBadWritePtr( pEventArray, sizeof(T) * ulCount ) ||
            SP_IS_BAD_OPTIONAL_WRITE_PTR(pulFetched) )
        {
            hr = E_INVALIDARG;
        }
        else 
        {
            ULONG ulCopied = 0;
            ULONG ulRemaining = ulCount;
            CSpEventExNode * pCur = m_CompletedList.m_pHead;
            CSpEventExNode * pLastCopied = NULL;
            while (ulRemaining && pCur)
            {
#ifdef ETW_TRACE_HEADER
#ifdef SOFTWARE_TRACING
                if(pCur->eEventId == SPEI_RECOGNITION || pCur->eEventId == SPEI_FALSE_RECOGNITION || pCur->eEventId == SPEI_RECOGNITION_ALL)
                {
                    DoTraceMessage(Trace_Verbose, "CpEventSource::Removed event with offset %I64u and Id %u from queue",pCur->ullAudioStreamOffset,pCur->eEventId);
                }
#endif
#endif
                // Detach the event into the passed in array and clear our copy
                memcpy(pEventArray + ulCopied, pCur, sizeof(T));
                memset((SPEVENTEX*)pCur, 0, sizeof(SPEVENTEX));

                pLastCopied = pCur;
                ulCopied++;
                pCur = pCur->m_pNext;
                ulRemaining--;
            }
            if (ulCopied)
            {
                if (m_FreeList.m_pHead == NULL)
                {
                    m_FreeList.m_pTail = pLastCopied;
                }
                pLastCopied->m_pNext = m_FreeList.m_pHead;
                m_FreeList.m_pHead = m_CompletedList.m_pHead;
                m_CompletedList.m_pHead = pCur;
                m_CompletedList.m_cElements -= ulCopied;
                m_FreeList.m_cElements += ulCopied;
            }
            if (ulCopied < ulCount)
            {
                hr = S_FALSE;
            }
            if (pulFetched) 
            {
                *pulFetched = ulCopied;
            }
        }
        m_pParent->Unlock();
        return hr;
    }


    HRESULT _GetInfo(SPEVENTSOURCEINFO *pInfo );

    /*--- Non interface methods ---*/
    HRESULT _CompleteEvents( ULONGLONG ullPos = 0xFFFFFFFFFFFFFFFF );
    inline void _MoveAllToFreeList(CSpEventList * pList);
    inline void _RemoveAllEvents();
    inline HRESULT _AddEvent(const SPEVENTEX & Event);
    inline HRESULT _AddEvents(const SPEVENT* pEventArray, ULONG ulCount);
    inline HRESULT _AddEvents(const SPEVENTEX* pEventArray, ULONG ulCount);
    inline HRESULT _GetStreamNumber(const ULONGLONG ullAudioOffset, ULONG *pulStreamNum);
    //=== Data members ==============================
  public:
    ULONGLONG                   m_ullEventInterest;
    ULONGLONG                   m_ullQueuedInterest;
    ULONG                       m_ulStreamNum;
    CSpEventList                m_PendingList;
    CSpEventList                m_CompletedList;
    CSpEventList                m_FreeList;
    CComPtr<ISpNotifySink>      m_cpNotifySink;
    CComPtr<ISpNotifyTranslator> m_cpEventTranslator;   // If non-NULL then Win32 events being used
    CComObjectRootEx<CComMultiThreadModel> * m_pParent;
    CComAutoCriticalSection     m_NotifyObjChangeCrit;  // Critical section used to make sure that
                                                        // the notify object (m_cpNotifySink) not changed
                                                        // while waiting on it.
  private:
    bool                        m_fSortEvents;

};


//
//=== Inlines =========================================================
//

//
//  WARNING:  If this logic changes, you will need to change the logic in SetNotifyWin32Event also.
//
inline HRESULT CSpEventSource::_SetNotifySink(ISpNotifySink * pNotifySink)
{
    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pNotifySink))
    {
        return E_INVALIDARG;
    }
    else
    {
        m_pParent->Lock();
        m_NotifyObjChangeCrit.Lock();
        m_cpEventTranslator.Release();
        m_cpNotifySink = pNotifySink;
        if (m_cpNotifySink && m_CompletedList.GetHead())
        {
            m_cpNotifySink->Notify();
        }
        m_NotifyObjChangeCrit.Unlock();
        m_pParent->Unlock();
        return S_OK;
    }
}

/****************************************************************************
* CSpEventSource::_SetNotifyWindowMessage *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitWindowMessage(hWnd, Msg, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyCallbackFunction *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitCallback(pfnCallback, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyCallbackInterface *
*---------------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitSpNotifyCallback(pSpCallback, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyWin32Event *
*--------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_SetNotifyWin32Event(void)
{

    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitWin32Event(NULL, TRUE);
    }
    if (SUCCEEDED(hr))
    {
        //
        //  In this case we do NOT call _SetNotify sink since we want to set the cpEventTranslator
        //
        m_pParent->Lock();
        m_NotifyObjChangeCrit.Lock();
        m_cpEventTranslator = cpTranslator;
        m_cpNotifySink = cpTranslator;
        if (m_cpNotifySink && m_CompletedList.GetHead())
        {
            m_cpNotifySink->Notify();
        }
        m_NotifyObjChangeCrit.Unlock();
        m_pParent->Unlock();
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_WaitForNotifyEvent *
*-------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HRESULT CSpEventSource::_WaitForNotifyEvent(DWORD dwMilliseconds)
{

    HRESULT hr = S_OK;
    m_NotifyObjChangeCrit.Lock();
    if (m_cpEventTranslator)
    {
        hr = m_cpEventTranslator->Wait(dwMilliseconds);
    }
    else
    {
        if (m_cpNotifySink)
        {
            hr = SPERR_ALREADY_INITIALIZED;
        }
        else
        {
            hr = _SetNotifyWin32Event();
            if (SUCCEEDED(hr))
            {
                hr = m_cpEventTranslator->Wait(dwMilliseconds);
            }
        }
    }
    m_NotifyObjChangeCrit.Unlock();
    return hr;
}
/****************************************************************************
* CSpEventSource::_GetNotifyEventHandle *
*---------------------------------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline HANDLE CSpEventSource::_GetNotifyEventHandle()
{
    HANDLE h = NULL;

    m_NotifyObjChangeCrit.Lock();
    if (!m_cpNotifySink)
    {
        _SetNotifyWin32Event();
    }
    if (m_cpEventTranslator)
    {
        h = m_cpEventTranslator->GetEventHandle();
    }
    m_NotifyObjChangeCrit.Unlock();
    return h;
}


inline HRESULT CSpEventSource::_SetInterest( ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();

    if(ullEventInterest && SPFEI_FLAGCHECK != (ullEventInterest & SPFEI_FLAGCHECK))
    {
        hr = E_INVALIDARG;
    }
    else if(ullQueuedInterest && SPFEI_FLAGCHECK != (ullQueuedInterest & SPFEI_FLAGCHECK))
    {
        hr = E_INVALIDARG;
    }
    else if ((ullQueuedInterest | ullEventInterest) != ullEventInterest)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_ullEventInterest = ullEventInterest;
        m_ullQueuedInterest = ullQueuedInterest;
    }
    m_pParent->Unlock();
    return hr;
}


//
//  Same as AddEvents except:  No param validation, and caller must take the critical section
//  prior to calling.
//
inline HRESULT CSpEventSource::_AddEvents( const SPEVENT* pEventArray, ULONG ulCount )
{
    HRESULT hr = S_OK;
    for( ULONG i = 0; i < ulCount && SUCCEEDED(hr); ++i )
    {
        SPEVENTEX EventEx;
        memcpy(&EventEx, pEventArray + i, sizeof(SPEVENT));
        EventEx.ullAudioTimeOffset = 0; // We set the audio time to zero if no information available
        hr = _AddEvent(EventEx);
    }
    return hr;
}

inline HRESULT CSpEventSource::_AddEvents( const SPEVENTEX* pEventArray, ULONG ulCount )
{
    HRESULT hr = S_OK;
    for( ULONG i = 0; i < ulCount && SUCCEEDED(hr = _AddEvent(pEventArray[i])); ++i ) {}
    return hr;
}

inline HRESULT CSpEventSource::_AddEvent(const SPEVENTEX & Event)
{
    _ASSERT(Event.eEventId < 64);
    _ASSERT(Event.elParamType == SPET_LPARAM_IS_UNDEFINED ||
                 Event.elParamType == SPET_LPARAM_IS_TOKEN ||
                 Event.elParamType == SPET_LPARAM_IS_OBJECT ||
                 Event.elParamType == SPET_LPARAM_IS_POINTER ||
                 Event.elParamType == SPET_LPARAM_IS_STRING);
#ifdef _DEBUG
    if (Event.eEventId == SPEI_VOICE_CHANGE)
    {
        _ASSERT(Event.elParamType == SPET_LPARAM_IS_TOKEN);
    }
    else if (Event.eEventId == SPEI_RECOGNITION || Event.eEventId == SPEI_FALSE_RECOGNITION || Event.eEventId == SPEI_HYPOTHESIS)
    {
        _ASSERT(Event.elParamType == SPET_LPARAM_IS_OBJECT);
    }
    else if (Event.eEventId ==SPEI_REQUEST_UI || Event.eEventId == SPEI_TTS_BOOKMARK)
    {
        _ASSERT(Event.elParamType == SPET_LPARAM_IS_STRING);
    }
#endif

    if ( (1i64 << Event.eEventId) & m_ullEventInterest )
    {
        CSpEventExNode *pNode = m_FreeList.RemoveHead();
        if (pNode == NULL)
        {
            pNode = new CSpEventExNode();
            if (pNode == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        pNode->CopyFrom(&Event);
        if (m_fSortEvents)
        {
            m_PendingList.InsertSorted(pNode);
        }
        else
        {
            m_PendingList.InsertTail(pNode);
        }
    }
    return S_OK;
}


inline HRESULT CSpEventSource::_GetInfo( SPEVENTSOURCEINFO * pInfo )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();    
    if( SP_IS_BAD_WRITE_PTR( pInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        pInfo->ulCount = m_CompletedList.GetCount();
        pInfo->ullEventInterest = m_ullEventInterest;
        pInfo->ullQueuedInterest= m_ullQueuedInterest;
    }
    m_pParent->Unlock();
    return hr;
}



//
//  The caller must call this function with the critical section owned
//
inline HRESULT CSpEventSource::_CompleteEvents( ULONGLONG ullPos )
{
    HRESULT hr = S_OK;

    if (m_PendingList.m_pHead && m_PendingList.m_pHead->ullAudioStreamOffset <= ullPos)
    {
        BOOL bNotify = FALSE;
        while (m_PendingList.m_pHead &&
               m_PendingList.m_pHead->ullAudioStreamOffset <= ullPos)
        {
            CSpEventExNode *pNode = m_PendingList.RemoveHead();
            if(pNode->ulStreamNum != m_ulStreamNum)
            {
                m_ulStreamNum = pNode->ulStreamNum;
            }
            if ( (1i64 << pNode->eEventId) & m_ullEventInterest )
            {
                bNotify = TRUE;
                //
                //  NOTE:  If we're forwarding events to an event sink then we'll only
                //  pay attention to the Interest flags.  If we're going to notify, then
                //  we'll only queue completed events that the user has explicitly asked
                //  us to store as completed events.
                //
                if ( (1i64 << pNode->eEventId) & m_ullQueuedInterest )
                {
                    if (m_fSortEvents)
                    {
                        m_CompletedList.InsertSorted(pNode);
                    }
                    else
                    {
                        m_CompletedList.InsertTail(pNode);
                    }
#ifdef ETW_TRACE_HEADER
#ifdef SOFTWARE_TRACING
                    if(pNode->eEventId == SPEI_RECOGNITION || pNode->eEventId == SPEI_FALSE_RECOGNITION || pNode->eEventId == SPEI_RECOGNITION_ALL)
                    {
                        DoTraceMessage(Trace_Verbose, "CpEventSource::Added reco event with offset %I64u and event id %u to queue",pNode->ullAudioStreamOffset,pNode->eEventId);
                    }
#endif
#endif
                }
                else
                {
                    pNode->Clear();
                    m_FreeList.InsertHead(pNode);
                }
            }
            else
            {
                pNode->Clear();
                m_FreeList.InsertHead(pNode);
            }
        }    
        if (bNotify && m_cpNotifySink)
        {
            hr = m_cpNotifySink->Notify();
        }
    }
    return hr;
};


inline void CSpEventSource::_MoveAllToFreeList(CSpEventList * pList)
{
    CSpEventExNode * pNode;
    while ((pNode = pList->RemoveHead()) != NULL)
    {
        pNode->Clear();
        m_FreeList.InsertHead(pNode);
    }
}
inline void CSpEventSource::_RemoveAllEvents( )
{
    m_pParent->Lock();

    _MoveAllToFreeList(&m_CompletedList);
    _MoveAllToFreeList(&m_PendingList);
    m_pParent->Unlock();
}

inline HRESULT CSpEventSource::_GetStreamNumber(const ULONGLONG ullAudioOffset, ULONG *pulStreamNum)
{
    CSpEventExNode *pNode = m_PendingList.m_pHead;
    *pulStreamNum = m_ulStreamNum;
    for(;pNode && pNode->ullAudioStreamOffset <= ullAudioOffset; pNode = pNode->m_pNext)
    {
        *pulStreamNum = pNode->ulStreamNum;
    }
    return S_OK;
}



#endif //--- This must be the last line in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Sql_1.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    SQL_1.H

Abstract:

    Level 1 Syntax SQL Parser

History:

--*/

#ifndef _SQL_1_H_
#define _SQL_1_H_

struct SQL_LEVEL_1_TOKEN
{
    enum { OP_EXPRESSION = 1, TOKEN_AND, TOKEN_OR, TOKEN_NOT };
    enum { IFUNC_NONE = 0, IFUNC_UPPER = 1, IFUNC_LOWER = 2 };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum { OP_EQUAL = 1, OP_NOT_EQUAL, OP_EQUALorGREATERTHAN,
		       OP_EQUALorLESSTHAN, OP_LESSTHAN, OP_GREATERTHAN, OP_LIKE };
    
    BSTR    pPropertyName;		// Name of the property on which the operator is applied
    int     nOperator;			// Operator that is applied on property
    BOOL	bConstIsStrNumeric;	// True if the vConstValue is a BSTR and is a UINT32 or any 64bit number
	VARIANT vConstValue;		// Value applied by operator
    BSTR    pPropName2;         // Property compared to.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "
    
    SQL_LEVEL_1_TOKEN();
    SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN&);
   ~SQL_LEVEL_1_TOKEN(); 
    SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src);
    
    void Dump(FILE *);
};


// Contains RPN version of expression.
// ===================================

struct SQL_LEVEL_1_RPN_EXPRESSION
{
    int nNumTokens;
    int nCurSize;
    SQL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
	__field_ecount_part(nCurPropSize, nNumberOfProperties) BSTR *pbsRequestedPropertyNames;  // Array of property names which values are to be returned if
    
    SQL_LEVEL_1_RPN_EXPRESSION();
   ~SQL_LEVEL_1_RPN_EXPRESSION();
   
   //Note: this method deletes the token it is passed as an argument
    void AddToken(SQL_LEVEL_1_TOKEN *pTok);
    void AddToken(SQL_LEVEL_1_TOKEN &pTok);
    void AddProperty(__in LPWSTR pProp);
    void Dump(const char *pszTextFile);
};


class SQL1_Parser
{
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;
    SQL_LEVEL_1_RPN_EXPRESSION* m_pExpression;

	//Cleanup used by d'tor and SetSource
	void Cleanup();

	//Init used by c'tor and SetSource
	void Init(__in CGenLexSource *pSrc);

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    LPWSTR     m_pIdent;
    LPWSTR     m_pPropComp;
	BOOL       m_bConstIsStrNumeric;
        
    // Parsing functions.
    // ==================
    BOOL Next();
    
    int parse();

    int prop_list();
    int class_name();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int unknown_func_expr();
    int typed_constant();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    SQL1_Parser(__in CGenLexSource *pSrc);
   ~SQL1_Parser();

    int GetQueryClass(__out_ecount_opt(nBufLen) LPWSTR pDestBuf, int nBufLen);
       
    int Parse(__deref_out SQL_LEVEL_1_RPN_EXPRESSION **pOutput);
        // use operator delete on pOutput
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
	void SetSource(CGenLexSource *pSrc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sqlext.h ===
//-----------------------------------------------------------------------------
// File:            sqlext.h
//
// Copyright:       Copyright (c) Microsoft Corporation
//
// Contents:        This is the include for applications using the Microsoft SQL Extensions
//
// Comments:
//
//-----------------------------------------------------------------------------

#ifndef __SQLEXT
#define __SQLEXT

#ifndef __SQL
#include "sql.h"
#endif

#ifdef __cplusplus
extern "C" {                         /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* generally useful constants */
#define SQL_SPEC_MAJOR     3        /* Major version of specification  */
#define SQL_SPEC_MINOR     80       /* Minor version of specification  */
#define SQL_SPEC_STRING   "03.80"   /* String constant for version */

#define SQL_SQLSTATE_SIZE   5   /* size of SQLSTATE */

typedef SQLTCHAR SQLSTATE[SQL_SQLSTATE_SIZE+1];

#define SQL_MAX_DSN_LENGTH  32  /* maximum data source name size */

#define SQL_MAX_OPTION_STRING_LENGTH    256

/* return code SQL_NO_DATA_FOUND is the same as SQL_NO_DATA */
#if (ODBCVER < 0x0300)
#define SQL_NO_DATA_FOUND   100
#else
#define SQL_NO_DATA_FOUND   SQL_NO_DATA
#endif

/* an end handle type */
#if (ODBCVER >= 0x0300)
#define SQL_HANDLE_SENV     5
#endif  /* ODBCVER >= 0x0300 */

/* env attribute */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ODBC_VERSION               200
#define SQL_ATTR_CONNECTION_POOLING         201
#define SQL_ATTR_CP_MATCH                   202
#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0300)
/* values for SQL_ATTR_CONNECTION_POOLING */
#define SQL_CP_OFF                          0UL
#define SQL_CP_ONE_PER_DRIVER               1UL
#define SQL_CP_ONE_PER_HENV                 2UL
#define SQL_CP_DEFAULT                      SQL_CP_OFF

/* values for SQL_ATTR_CP_MATCH */
#define SQL_CP_STRICT_MATCH                 0UL
#define SQL_CP_RELAXED_MATCH                1UL
#define SQL_CP_MATCH_DEFAULT                SQL_CP_STRICT_MATCH

/* values for SQL_ATTR_ODBC_VERSION */
#define SQL_OV_ODBC2                        2UL
#define SQL_OV_ODBC3                        3UL
#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0380)
// new values for SQL_ATTR_ODBC_VERSION 
// From ODBC 3.8 onwards, we should use <major version> * 100 + <minor version>
#define SQL_OV_ODBC3_80                     380UL
#endif  /* ODBCVER >= 0x0380

/* connection attributes */
#define SQL_ACCESS_MODE                 101
#define SQL_AUTOCOMMIT                  102
#define SQL_LOGIN_TIMEOUT               103
#define SQL_OPT_TRACE                   104
#define SQL_OPT_TRACEFILE               105
#define SQL_TRANSLATE_DLL               106
#define SQL_TRANSLATE_OPTION            107
#define SQL_TXN_ISOLATION               108
#define SQL_CURRENT_QUALIFIER           109
#define SQL_ODBC_CURSORS                110
#define SQL_QUIET_MODE                  111
#define SQL_PACKET_SIZE                 112

/* connection attributes with new names */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ACCESS_MODE        SQL_ACCESS_MODE
#define SQL_ATTR_AUTOCOMMIT         SQL_AUTOCOMMIT
#define SQL_ATTR_CONNECTION_TIMEOUT 113
#define SQL_ATTR_CURRENT_CATALOG    SQL_CURRENT_QUALIFIER
#define SQL_ATTR_DISCONNECT_BEHAVIOR    114
#define SQL_ATTR_ENLIST_IN_DTC      1207
#define SQL_ATTR_ENLIST_IN_XA       1208
#define SQL_ATTR_LOGIN_TIMEOUT      SQL_LOGIN_TIMEOUT
#define SQL_ATTR_ODBC_CURSORS       SQL_ODBC_CURSORS
#define SQL_ATTR_PACKET_SIZE        SQL_PACKET_SIZE
#define SQL_ATTR_QUIET_MODE         SQL_QUIET_MODE
#define SQL_ATTR_TRACE              SQL_OPT_TRACE
#define SQL_ATTR_TRACEFILE          SQL_OPT_TRACEFILE
#define SQL_ATTR_TRANSLATE_LIB      SQL_TRANSLATE_DLL
#define SQL_ATTR_TRANSLATE_OPTION   SQL_TRANSLATE_OPTION
#define SQL_ATTR_TXN_ISOLATION      SQL_TXN_ISOLATION
#endif  /* ODBCVER >= 0x0300 */

#define SQL_ATTR_CONNECTION_DEAD    1209    /* GetConnectAttr only */

#if (ODBCVER >= 0x0351)
/*  ODBC Driver Manager sets this connection attribute to a unicode driver
    (which supports SQLConnectW) when the application is an ANSI application
    (which calls SQLConnect, SQLDriverConnect, or SQLBrowseConnect).
    This is SetConnectAttr only and application does not set this attribute
    This attribute was introduced because some unicode driver's some APIs may
    need to behave differently on ANSI or Unicode applications. A unicode
    driver, which  has same behavior for both ANSI or Unicode applications,
    should return SQL_ERROR when the driver manager sets this connection
    attribute. When a unicode driver returns SQL_SUCCESS on this attribute,
    the driver manager treates ANSI and Unicode connections differently in
    connection pooling.
*/
#define SQL_ATTR_ANSI_APP           115
#endif

#if (ODBCVER >= 0x0380)
#define SQL_ATTR_RESET_CONNECTION   116
#define SQL_ATTR_ASYNC_DBC_FUNCTIONS_ENABLE    117
#endif


/* SQL_CONNECT_OPT_DRVR_START is not meaningful for 3.0 driver */
#if (ODBCVER < 0x0300)
#define SQL_CONNECT_OPT_DRVR_START      1000
#endif  /* ODBCVER < 0x0300 */

#if (ODBCVER < 0x0300)
#define SQL_CONN_OPT_MAX                SQL_PACKET_SIZE
#define SQL_CONN_OPT_MIN                SQL_ACCESS_MODE
#endif /* ODBCVER < 0x0300 */

/* SQL_ACCESS_MODE options */
#define SQL_MODE_READ_WRITE             0UL
#define SQL_MODE_READ_ONLY              1UL
#define SQL_MODE_DEFAULT                SQL_MODE_READ_WRITE

/* SQL_AUTOCOMMIT options */
#define SQL_AUTOCOMMIT_OFF              0UL
#define SQL_AUTOCOMMIT_ON               1UL
#define SQL_AUTOCOMMIT_DEFAULT          SQL_AUTOCOMMIT_ON

/* SQL_LOGIN_TIMEOUT options */
#define SQL_LOGIN_TIMEOUT_DEFAULT       15UL

/* SQL_OPT_TRACE options */
#define SQL_OPT_TRACE_OFF               0UL
#define SQL_OPT_TRACE_ON                1UL
#define SQL_OPT_TRACE_DEFAULT           SQL_OPT_TRACE_OFF
#define SQL_OPT_TRACE_FILE_DEFAULT      "\\SQL.LOG"

/* SQL_ODBC_CURSORS options */
#define SQL_CUR_USE_IF_NEEDED           0UL
#define SQL_CUR_USE_ODBC                1UL
#define SQL_CUR_USE_DRIVER              2UL
#define SQL_CUR_DEFAULT                 SQL_CUR_USE_DRIVER

#if (ODBCVER >= 0x0300)
/* values for SQL_ATTR_DISCONNECT_BEHAVIOR */
#define SQL_DB_RETURN_TO_POOL           0UL
#define SQL_DB_DISCONNECT               1UL
#define SQL_DB_DEFAULT                  SQL_DB_RETURN_TO_POOL

/* values for SQL_ATTR_ENLIST_IN_DTC */
#define SQL_DTC_DONE                    0L
#endif  /* ODBCVER >= 0x0300 */

/* values for SQL_ATTR_CONNECTION_DEAD */
#define SQL_CD_TRUE                     1L      /* Connection is closed/dead */
#define SQL_CD_FALSE                    0L      /* Connection is open/available */

/* values for SQL_ATTR_ANSI_APP */
#if (ODBCVER >= 0x0351)
#define SQL_AA_TRUE                     1L  /* the application is an ANSI app */
#define SQL_AA_FALSE                    0L  /* the application is a Unicode app */
#endif

/* values for SQL_ATTR_RESET_CONNECTION */
#if (ODBCVER >= 0x0380)
#define SQL_RESET_CONNECTION_YES        1UL
#endif

/* values for SQL_ATTR_ASYNC_DBC_FUNCTIONS_ENABLE */
#if (ODBCVER >= 0x0380)
#define SQL_ASYNC_DBC_ENABLE_ON         1UL
#define SQL_ASYNC_DBC_ENABLE_OFF        0UL
#define SQL_ASYNC_DBC_ENABLE_DEFAULT	SQL_ASYNC_DBC_ENABLE_OFF
#endif // ODBCVER >= 0x0380

/* statement attributes */
#define SQL_QUERY_TIMEOUT       0
#define SQL_MAX_ROWS            1
#define SQL_NOSCAN              2
#define SQL_MAX_LENGTH          3
#define SQL_ASYNC_ENABLE        4   /* same as SQL_ATTR_ASYNC_ENABLE */
#define SQL_BIND_TYPE           5
#define SQL_CURSOR_TYPE         6
#define SQL_CONCURRENCY         7
#define SQL_KEYSET_SIZE         8
#define SQL_ROWSET_SIZE         9
#define SQL_SIMULATE_CURSOR     10
#define SQL_RETRIEVE_DATA       11
#define SQL_USE_BOOKMARKS       12
#define SQL_GET_BOOKMARK        13      /*      GetStmtOption Only */
#define SQL_ROW_NUMBER          14      /*      GetStmtOption Only */

/* statement attributes for ODBC 3.0 */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ASYNC_ENABLE               4
#define SQL_ATTR_CONCURRENCY                SQL_CONCURRENCY
#define SQL_ATTR_CURSOR_TYPE                SQL_CURSOR_TYPE
#define SQL_ATTR_ENABLE_AUTO_IPD            15
#define SQL_ATTR_FETCH_BOOKMARK_PTR         16
#define SQL_ATTR_KEYSET_SIZE                SQL_KEYSET_SIZE
#define SQL_ATTR_MAX_LENGTH                 SQL_MAX_LENGTH
#define SQL_ATTR_MAX_ROWS                   SQL_MAX_ROWS
#define SQL_ATTR_NOSCAN                     SQL_NOSCAN
#define SQL_ATTR_PARAM_BIND_OFFSET_PTR      17
#define SQL_ATTR_PARAM_BIND_TYPE            18
#define SQL_ATTR_PARAM_OPERATION_PTR        19
#define SQL_ATTR_PARAM_STATUS_PTR           20
#define SQL_ATTR_PARAMS_PROCESSED_PTR       21
#define SQL_ATTR_PARAMSET_SIZE              22
#define SQL_ATTR_QUERY_TIMEOUT              SQL_QUERY_TIMEOUT
#define SQL_ATTR_RETRIEVE_DATA              SQL_RETRIEVE_DATA
#define SQL_ATTR_ROW_BIND_OFFSET_PTR        23
#define SQL_ATTR_ROW_BIND_TYPE              SQL_BIND_TYPE
#define SQL_ATTR_ROW_NUMBER                 SQL_ROW_NUMBER      /*GetStmtAttr*/
#define SQL_ATTR_ROW_OPERATION_PTR          24
#define SQL_ATTR_ROW_STATUS_PTR             25
#define SQL_ATTR_ROWS_FETCHED_PTR           26
#define SQL_ATTR_ROW_ARRAY_SIZE             27
#define SQL_ATTR_SIMULATE_CURSOR            SQL_SIMULATE_CURSOR
#define SQL_ATTR_USE_BOOKMARKS              SQL_USE_BOOKMARKS

#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER < 0x0300)
#define SQL_STMT_OPT_MAX                SQL_ROW_NUMBER
#define SQL_STMT_OPT_MIN    SQL_QUERY_TIMEOUT
#endif      /* ODBCVER < 0x0300 */

/* New defines for SEARCHABLE column in SQLGetTypeInfo */

#if (ODBCVER >= 0x0300)
#define SQL_COL_PRED_CHAR       SQL_LIKE_ONLY
#define SQL_COL_PRED_BASIC      SQL_ALL_EXCEPT_LIKE
#endif /* ODBCVER >= 0x0300 */



/* whether an attribute is a pointer or not */
#if (ODBCVER >= 0x0300)
#define SQL_IS_POINTER                          (-4)
#define SQL_IS_UINTEGER                         (-5)
#define SQL_IS_INTEGER                          (-6)
#define SQL_IS_USMALLINT                        (-7)
#define SQL_IS_SMALLINT                         (-8)
#endif  /* ODBCVER >= 0x0300 */

/* the value of SQL_ATTR_PARAM_BIND_TYPE */
#if (ODBCVER >= 0x0300)
#define SQL_PARAM_BIND_BY_COLUMN            0UL
#define SQL_PARAM_BIND_TYPE_DEFAULT         SQL_PARAM_BIND_BY_COLUMN
#endif  /* ODBCVER >= 0x0300 */

/* SQL_QUERY_TIMEOUT options */
#define SQL_QUERY_TIMEOUT_DEFAULT       0UL

/* SQL_MAX_ROWS options */
#define SQL_MAX_ROWS_DEFAULT            0UL

/* SQL_NOSCAN options */
#define SQL_NOSCAN_OFF                  0UL     /*      1.0 FALSE */
#define SQL_NOSCAN_ON                   1UL     /*      1.0 TRUE */
#define SQL_NOSCAN_DEFAULT              SQL_NOSCAN_OFF

/* SQL_MAX_LENGTH options */
#define SQL_MAX_LENGTH_DEFAULT          0UL

/* values for SQL_ATTR_ASYNC_ENABLE */
#define SQL_ASYNC_ENABLE_OFF            0UL
#define SQL_ASYNC_ENABLE_ON             1UL
#define SQL_ASYNC_ENABLE_DEFAULT        SQL_ASYNC_ENABLE_OFF

/* SQL_BIND_TYPE options */
#define SQL_BIND_BY_COLUMN              0UL
#define SQL_BIND_TYPE_DEFAULT           SQL_BIND_BY_COLUMN  /* Default value */

/* SQL_CONCURRENCY options */
#define SQL_CONCUR_READ_ONLY            1
#define SQL_CONCUR_LOCK                 2
#define SQL_CONCUR_ROWVER               3
#define SQL_CONCUR_VALUES               4
#define SQL_CONCUR_DEFAULT              SQL_CONCUR_READ_ONLY /* Default value */

/* SQL_CURSOR_TYPE options */
#define SQL_CURSOR_FORWARD_ONLY         0UL
#define SQL_CURSOR_KEYSET_DRIVEN        1UL
#define SQL_CURSOR_DYNAMIC              2UL
#define SQL_CURSOR_STATIC               3UL
#define SQL_CURSOR_TYPE_DEFAULT         SQL_CURSOR_FORWARD_ONLY /* Default value */

/* SQL_ROWSET_SIZE options */
#define SQL_ROWSET_SIZE_DEFAULT         1UL

/* SQL_KEYSET_SIZE options */
#define SQL_KEYSET_SIZE_DEFAULT         0UL

/* SQL_SIMULATE_CURSOR options */
#define SQL_SC_NON_UNIQUE               0UL
#define SQL_SC_TRY_UNIQUE               1UL
#define SQL_SC_UNIQUE                   2UL

/* SQL_RETRIEVE_DATA options */
#define SQL_RD_OFF                      0UL
#define SQL_RD_ON                       1UL
#define SQL_RD_DEFAULT                  SQL_RD_ON

/* SQL_USE_BOOKMARKS options */
#define SQL_UB_OFF                      0UL
#define SQL_UB_ON                       01UL
#define SQL_UB_DEFAULT                  SQL_UB_OFF

/* New values for SQL_USE_BOOKMARKS attribute */
#if (ODBCVER >= 0x0300)
#define SQL_UB_FIXED                    SQL_UB_ON
#define SQL_UB_VARIABLE                 2UL
#endif  /* ODBCVER >= 0x0300 */

/* extended descriptor field */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_ARRAY_SIZE                     20
#define SQL_DESC_ARRAY_STATUS_PTR               21
#define SQL_DESC_AUTO_UNIQUE_VALUE              SQL_COLUMN_AUTO_INCREMENT
#define SQL_DESC_BASE_COLUMN_NAME               22
#define SQL_DESC_BASE_TABLE_NAME                23
#define SQL_DESC_BIND_OFFSET_PTR                24
#define SQL_DESC_BIND_TYPE                      25
#define SQL_DESC_CASE_SENSITIVE                 SQL_COLUMN_CASE_SENSITIVE
#define SQL_DESC_CATALOG_NAME                   SQL_COLUMN_QUALIFIER_NAME
#define SQL_DESC_CONCISE_TYPE                   SQL_COLUMN_TYPE
#define SQL_DESC_DATETIME_INTERVAL_PRECISION    26
#define SQL_DESC_DISPLAY_SIZE                   SQL_COLUMN_DISPLAY_SIZE
#define SQL_DESC_FIXED_PREC_SCALE               SQL_COLUMN_MONEY
#define SQL_DESC_LABEL                          SQL_COLUMN_LABEL
#define SQL_DESC_LITERAL_PREFIX                 27
#define SQL_DESC_LITERAL_SUFFIX                 28
#define SQL_DESC_LOCAL_TYPE_NAME                29
#define SQL_DESC_MAXIMUM_SCALE                  30
#define SQL_DESC_MINIMUM_SCALE                  31
#define SQL_DESC_NUM_PREC_RADIX                 32
#define SQL_DESC_PARAMETER_TYPE                 33
#define SQL_DESC_ROWS_PROCESSED_PTR             34
#if (ODBCVER >= 0x0350)
#define SQL_DESC_ROWVER                         35
#endif /* ODBCVER >= 0x0350 */
#define SQL_DESC_SCHEMA_NAME                    SQL_COLUMN_OWNER_NAME
#define SQL_DESC_SEARCHABLE                     SQL_COLUMN_SEARCHABLE
#define SQL_DESC_TYPE_NAME                      SQL_COLUMN_TYPE_NAME
#define SQL_DESC_TABLE_NAME                     SQL_COLUMN_TABLE_NAME
#define SQL_DESC_UNSIGNED                       SQL_COLUMN_UNSIGNED
#define SQL_DESC_UPDATABLE                      SQL_COLUMN_UPDATABLE
#endif /* ODBCVER >= 0x0300 */


/* defines for diagnostics fields */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_CURSOR_ROW_COUNT           (-1249)
#define SQL_DIAG_ROW_NUMBER                 (-1248)
#define SQL_DIAG_COLUMN_NUMBER              (-1247)
#endif /* ODBCVER >= 0x0300 */

/* SQL extended datatypes */
#define SQL_DATE                                9
#if (ODBCVER >= 0x0300)
#define SQL_INTERVAL                            10
#endif  /* ODBCVER >= 0x0300 */
#define SQL_TIME                                10
#define SQL_TIMESTAMP                           11
#define SQL_LONGVARCHAR                         (-1)
#define SQL_BINARY                              (-2)
#define SQL_VARBINARY                           (-3)
#define SQL_LONGVARBINARY                       (-4)
#define SQL_BIGINT                              (-5)
#define SQL_TINYINT                             (-6)
#define SQL_BIT                                 (-7)
#if (ODBCVER >= 0x0350)
#define SQL_GUID                (-11)
#endif  /* ODBCVER >= 0x0350 */

#if (ODBCVER >= 0x0300)
/* interval code */
#define SQL_CODE_YEAR               1
#define SQL_CODE_MONTH              2
#define SQL_CODE_DAY                3
#define SQL_CODE_HOUR               4
#define SQL_CODE_MINUTE             5
#define SQL_CODE_SECOND             6
#define SQL_CODE_YEAR_TO_MONTH          7
#define SQL_CODE_DAY_TO_HOUR            8
#define SQL_CODE_DAY_TO_MINUTE          9
#define SQL_CODE_DAY_TO_SECOND          10
#define SQL_CODE_HOUR_TO_MINUTE         11
#define SQL_CODE_HOUR_TO_SECOND         12
#define SQL_CODE_MINUTE_TO_SECOND       13

#define SQL_INTERVAL_YEAR                   (100 + SQL_CODE_YEAR)
#define SQL_INTERVAL_MONTH                  (100 + SQL_CODE_MONTH)
#define SQL_INTERVAL_DAY                    (100 + SQL_CODE_DAY)
#define SQL_INTERVAL_HOUR                   (100 + SQL_CODE_HOUR)
#define SQL_INTERVAL_MINUTE                 (100 + SQL_CODE_MINUTE)
#define SQL_INTERVAL_SECOND                 (100 + SQL_CODE_SECOND)
#define SQL_INTERVAL_YEAR_TO_MONTH          (100 + SQL_CODE_YEAR_TO_MONTH)
#define SQL_INTERVAL_DAY_TO_HOUR            (100 + SQL_CODE_DAY_TO_HOUR)
#define SQL_INTERVAL_DAY_TO_MINUTE          (100 + SQL_CODE_DAY_TO_MINUTE)
#define SQL_INTERVAL_DAY_TO_SECOND          (100 + SQL_CODE_DAY_TO_SECOND)
#define SQL_INTERVAL_HOUR_TO_MINUTE         (100 + SQL_CODE_HOUR_TO_MINUTE)
#define SQL_INTERVAL_HOUR_TO_SECOND         (100 + SQL_CODE_HOUR_TO_SECOND)
#define SQL_INTERVAL_MINUTE_TO_SECOND       (100 + SQL_CODE_MINUTE_TO_SECOND)

#else
#define SQL_INTERVAL_YEAR                       (-80)
#define SQL_INTERVAL_MONTH                      (-81)
#define SQL_INTERVAL_YEAR_TO_MONTH              (-82)
#define SQL_INTERVAL_DAY                        (-83)
#define SQL_INTERVAL_HOUR                       (-84)
#define SQL_INTERVAL_MINUTE                     (-85)
#define SQL_INTERVAL_SECOND                     (-86)
#define SQL_INTERVAL_DAY_TO_HOUR                (-87)
#define SQL_INTERVAL_DAY_TO_MINUTE              (-88)
#define SQL_INTERVAL_DAY_TO_SECOND              (-89)
#define SQL_INTERVAL_HOUR_TO_MINUTE             (-90)
#define SQL_INTERVAL_HOUR_TO_SECOND             (-91)
#define SQL_INTERVAL_MINUTE_TO_SECOND           (-92)
#endif  /* ODBCVER >= 0x0300 */


#if (ODBCVER <= 0x0300)
#define SQL_UNICODE                             (-95)
#define SQL_UNICODE_VARCHAR                     (-96)
#define SQL_UNICODE_LONGVARCHAR                 (-97)
#define SQL_UNICODE_CHAR                        SQL_UNICODE
#else
/* The previous definitions for SQL_UNICODE_ are historical and obsolete */

#define SQL_UNICODE             SQL_WCHAR

#define SQL_UNICODE_VARCHAR     SQL_WVARCHAR
#define SQL_UNICODE_LONGVARCHAR SQL_WLONGVARCHAR
#define SQL_UNICODE_CHAR        SQL_WCHAR
#endif

#if (ODBCVER < 0x0300)
#define SQL_TYPE_DRIVER_START                   SQL_INTERVAL_YEAR
#define SQL_TYPE_DRIVER_END                     SQL_UNICODE_LONGVARCHAR
#endif  /* ODBCVER < 0x0300 */

/* C datatype to SQL datatype mapping      SQL types
                                           ------------------- */
#define SQL_C_CHAR    SQL_CHAR             /* CHAR, VARCHAR, DECIMAL, NUMERIC */
#define SQL_C_LONG    SQL_INTEGER          /* INTEGER                      */
#define SQL_C_SHORT   SQL_SMALLINT         /* SMALLINT                     */
#define SQL_C_FLOAT   SQL_REAL             /* REAL                         */
#define SQL_C_DOUBLE  SQL_DOUBLE           /* FLOAT, DOUBLE                */
#if (ODBCVER >= 0x0300)
#define SQL_C_NUMERIC       SQL_NUMERIC
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_DEFAULT 99

#define SQL_SIGNED_OFFSET       (-20)
#define SQL_UNSIGNED_OFFSET     (-22)

/* C datatype to SQL datatype mapping */
#define SQL_C_DATE       SQL_DATE
#define SQL_C_TIME       SQL_TIME
#define SQL_C_TIMESTAMP  SQL_TIMESTAMP
#if (ODBCVER >= 0x0300)
#define SQL_C_TYPE_DATE                 SQL_TYPE_DATE
#define SQL_C_TYPE_TIME                 SQL_TYPE_TIME
#define SQL_C_TYPE_TIMESTAMP            SQL_TYPE_TIMESTAMP
#define SQL_C_INTERVAL_YEAR             SQL_INTERVAL_YEAR
#define SQL_C_INTERVAL_MONTH            SQL_INTERVAL_MONTH
#define SQL_C_INTERVAL_DAY              SQL_INTERVAL_DAY
#define SQL_C_INTERVAL_HOUR             SQL_INTERVAL_HOUR
#define SQL_C_INTERVAL_MINUTE           SQL_INTERVAL_MINUTE
#define SQL_C_INTERVAL_SECOND           SQL_INTERVAL_SECOND
#define SQL_C_INTERVAL_YEAR_TO_MONTH    SQL_INTERVAL_YEAR_TO_MONTH
#define SQL_C_INTERVAL_DAY_TO_HOUR      SQL_INTERVAL_DAY_TO_HOUR
#define SQL_C_INTERVAL_DAY_TO_MINUTE    SQL_INTERVAL_DAY_TO_MINUTE
#define SQL_C_INTERVAL_DAY_TO_SECOND    SQL_INTERVAL_DAY_TO_SECOND
#define SQL_C_INTERVAL_HOUR_TO_MINUTE   SQL_INTERVAL_HOUR_TO_MINUTE
#define SQL_C_INTERVAL_HOUR_TO_SECOND   SQL_INTERVAL_HOUR_TO_SECOND
#define SQL_C_INTERVAL_MINUTE_TO_SECOND SQL_INTERVAL_MINUTE_TO_SECOND
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_BINARY     SQL_BINARY
#define SQL_C_BIT        SQL_BIT
#if (ODBCVER >= 0x0300)
#define SQL_C_SBIGINT   (SQL_BIGINT+SQL_SIGNED_OFFSET)     /* SIGNED BIGINT */
#define SQL_C_UBIGINT   (SQL_BIGINT+SQL_UNSIGNED_OFFSET)   /* UNSIGNED BIGINT */
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_TINYINT    SQL_TINYINT
#define SQL_C_SLONG      (SQL_C_LONG+SQL_SIGNED_OFFSET)    /* SIGNED INTEGER  */
#define SQL_C_SSHORT     (SQL_C_SHORT+SQL_SIGNED_OFFSET)   /* SIGNED SMALLINT */
#define SQL_C_STINYINT   (SQL_TINYINT+SQL_SIGNED_OFFSET)   /* SIGNED TINYINT  */
#define SQL_C_ULONG      (SQL_C_LONG+SQL_UNSIGNED_OFFSET)  /* UNSIGNED INTEGER*/
#define SQL_C_USHORT     (SQL_C_SHORT+SQL_UNSIGNED_OFFSET) /* UNSIGNED SMALLINT*/
#define SQL_C_UTINYINT   (SQL_TINYINT+SQL_UNSIGNED_OFFSET) /* UNSIGNED TINYINT*/

#ifdef _WIN64
#define SQL_C_BOOKMARK   SQL_C_UBIGINT                     /* BOOKMARK        */
#else
#define SQL_C_BOOKMARK   SQL_C_ULONG                       /* BOOKMARK        */
#endif

#if (ODBCVER >= 0x0350)
#define SQL_C_GUID  SQL_GUID
#endif  /* ODBCVER >= 0x0350 */

#define SQL_TYPE_NULL                   0
#if (ODBCVER < 0x0300)
#define SQL_TYPE_MIN                    SQL_BIT
#define SQL_TYPE_MAX                    SQL_VARCHAR
#endif

// base value of driver-specific C-Type (max is 0x7fff)
// define driver-specific C-Type, named as SQL_DRIVER_C_TYPE_BASE, 
// SQL_DRIVER_C_TYPE_BASE+1, SQL_DRIVER_C_TYPE_BASE+2, etc.
#if (ODBCVER >= 0x380)
#define SQL_DRIVER_C_TYPE_BASE      0x4000
#endif

// base value of driver-specific fields/attributes (max are 0x7fff [16-bit] or 0x00007fff [32-bit])
// define driver-specific SQL-Type, named as SQL_DRIVER_SQL_TYPE_BASE, 
// SQL_DRIVER_SQL_TYPE_BASE+1, SQL_DRIVER_SQL_TYPE_BASE+2, etc.
// 
// Please note that there is no runtime change in this version of DM. 
// However, we suggest that driver manufacturers adhere to this range
// as future versions of the DM may enforce these constraints
#if (ODBCVER >= 0x380)
#define SQL_DRIVER_SQL_TYPE_BASE    0x4000
#define SQL_DRIVER_DESC_FIELD_BASE  0x4000
#define SQL_DRIVER_DIAG_FIELD_BASE  0x4000
#define SQL_DRIVER_INFO_TYPE_BASE   0x4000
#define SQL_DRIVER_CONN_ATTR_BASE   0x00004000  // 32-bit
#define SQL_DRIVER_STMT_ATTR_BASE   0x00004000  // 32-bit
#endif

#if (ODBCVER >= 0x0300)
#define SQL_C_VARBOOKMARK       SQL_C_BINARY
#endif  /* ODBCVER >= 0x0300 */

/* define for SQL_DIAG_ROW_NUMBER and SQL_DIAG_COLUMN_NUMBER */
#if (ODBCVER >= 0x0300)
#define SQL_NO_ROW_NUMBER                       (-1)
#define SQL_NO_COLUMN_NUMBER                    (-1)
#define SQL_ROW_NUMBER_UNKNOWN                  (-2)
#define SQL_COLUMN_NUMBER_UNKNOWN               (-2)
#endif

/* SQLBindParameter extensions */
#define SQL_DEFAULT_PARAM            (-5)
#define SQL_IGNORE                   (-6)
#if (ODBCVER >= 0x0300)
#define SQL_COLUMN_IGNORE           SQL_IGNORE
#endif  /* ODBCVER >= 0x0300 */
#define SQL_LEN_DATA_AT_EXEC_OFFSET  (-100)
#define SQL_LEN_DATA_AT_EXEC(length) (-(length)+SQL_LEN_DATA_AT_EXEC_OFFSET)

/* binary length for driver specific attributes */
#define SQL_LEN_BINARY_ATTR_OFFSET   (-100)
#define SQL_LEN_BINARY_ATTR(length)  (-(length)+SQL_LEN_BINARY_ATTR_OFFSET)

/* Defines used by Driver Manager when mapping SQLSetParam to SQLBindParameter
*/
#define SQL_PARAM_TYPE_DEFAULT           SQL_PARAM_INPUT_OUTPUT
#define SQL_SETPARAM_VALUE_MAX           (-1L)

/* SQLColAttributes defines */
#define SQL_COLUMN_COUNT                0
#define SQL_COLUMN_NAME                 1
#define SQL_COLUMN_TYPE                 2
#define SQL_COLUMN_LENGTH               3
#define SQL_COLUMN_PRECISION            4
#define SQL_COLUMN_SCALE                5
#define SQL_COLUMN_DISPLAY_SIZE         6
#define SQL_COLUMN_NULLABLE             7
#define SQL_COLUMN_UNSIGNED             8
#define SQL_COLUMN_MONEY                9
#define SQL_COLUMN_UPDATABLE            10
#define SQL_COLUMN_AUTO_INCREMENT       11
#define SQL_COLUMN_CASE_SENSITIVE       12
#define SQL_COLUMN_SEARCHABLE           13
#define SQL_COLUMN_TYPE_NAME            14
#define SQL_COLUMN_TABLE_NAME           15
#define SQL_COLUMN_OWNER_NAME           16
#define SQL_COLUMN_QUALIFIER_NAME       17
#define SQL_COLUMN_LABEL                18
#define SQL_COLATT_OPT_MAX              SQL_COLUMN_LABEL
#if (ODBCVER < 0x0300)
#define SQL_COLUMN_DRIVER_START         1000
#endif  /* ODBCVER < 0x0300 */

#define SQL_COLATT_OPT_MIN              SQL_COLUMN_COUNT

/* SQLColAttributes subdefines for SQL_COLUMN_UPDATABLE */
#define SQL_ATTR_READONLY               0
#define SQL_ATTR_WRITE                  1
#define SQL_ATTR_READWRITE_UNKNOWN      2

/* SQLColAttributes subdefines for SQL_COLUMN_SEARCHABLE */
/* These are also used by SQLGetInfo                     */
#define SQL_UNSEARCHABLE                0
#define SQL_LIKE_ONLY                   1
#define SQL_ALL_EXCEPT_LIKE             2
#define SQL_SEARCHABLE                  3
#define SQL_PRED_SEARCHABLE             SQL_SEARCHABLE


/* Special return values for SQLGetData */
#define SQL_NO_TOTAL                    (-4)

/********************************************/
/* SQLGetFunctions: additional values for   */
/* fFunction to represent functions that    */
/* are not in the X/Open spec.              */
/********************************************/

#if (ODBCVER >= 0x0300)
#define SQL_API_SQLALLOCHANDLESTD   73
#define SQL_API_SQLBULKOPERATIONS   24
#endif /* ODBCVER >= 0x0300 */
#define SQL_API_SQLBINDPARAMETER    72
#define SQL_API_SQLBROWSECONNECT    55
#define SQL_API_SQLCOLATTRIBUTES    6
#define SQL_API_SQLCOLUMNPRIVILEGES 56
#define SQL_API_SQLDESCRIBEPARAM    58
#define SQL_API_SQLDRIVERCONNECT    41
#define SQL_API_SQLDRIVERS          71
#define SQL_API_SQLEXTENDEDFETCH    59
#define SQL_API_SQLFOREIGNKEYS      60
#define SQL_API_SQLMORERESULTS      61
#define SQL_API_SQLNATIVESQL        62
#define SQL_API_SQLNUMPARAMS        63
#define SQL_API_SQLPARAMOPTIONS     64
#define SQL_API_SQLPRIMARYKEYS      65
#define SQL_API_SQLPROCEDURECOLUMNS 66
#define SQL_API_SQLPROCEDURES       67
#define SQL_API_SQLSETPOS           68
#define SQL_API_SQLSETSCROLLOPTIONS 69
#define SQL_API_SQLTABLEPRIVILEGES  70

/*-------------------------------------------*/
/* SQL_EXT_API_LAST is not useful with ODBC  */
/* version 3.0 because some of the values    */
/* from X/Open are in the 10000 range.       */
/*-------------------------------------------*/

#if (ODBCVER < 0x0300)
#define SQL_EXT_API_LAST            SQL_API_SQLBINDPARAMETER
#define SQL_NUM_FUNCTIONS           23
#define SQL_EXT_API_START           40
#define SQL_NUM_EXTENSIONS (SQL_EXT_API_LAST-SQL_EXT_API_START+1)
#endif

/*--------------------------------------------*/
/* SQL_API_ALL_FUNCTIONS returns an array     */
/* of 'booleans' representing whether a       */
/* function is implemented by the driver.     */
/*                                            */
/* CAUTION: Only functions defined in ODBC    */
/* version 2.0 and earlier are returned, the  */
/* new high-range function numbers defined by */
/* X/Open break this scheme.   See the new    */
/* method -- SQL_API_ODBC3_ALL_FUNCTIONS      */
/*--------------------------------------------*/

#define SQL_API_ALL_FUNCTIONS       0       /* See CAUTION above */

/*----------------------------------------------*/
/* 2.X drivers export a dummy function with     */
/* ordinal number SQL_API_LOADBYORDINAL to speed*/
/* loading under the windows operating system.  */
/*                      */
/* CAUTION: Loading by ordinal is not supported */
/* for 3.0 and above drivers.           */
/*----------------------------------------------*/

#define SQL_API_LOADBYORDINAL       199     /* See CAUTION above */

/*----------------------------------------------*/
/* SQL_API_ODBC3_ALL_FUNCTIONS                  */
/* This returns a bitmap, which allows us to    */
/* handle the higher-valued function numbers.   */
/* Use  SQL_FUNC_EXISTS(bitmap,function_number) */
/* to determine if the function exists.         */
/*----------------------------------------------*/


#if (ODBCVER >= 0x0300)
#define SQL_API_ODBC3_ALL_FUNCTIONS 999
#define SQL_API_ODBC3_ALL_FUNCTIONS_SIZE    250     /* array of 250 words */

#define SQL_FUNC_EXISTS(pfExists, uwAPI) \
                ((*(((UWORD*) (pfExists)) + ((uwAPI) >> 4)) \
                    & (1 << ((uwAPI) & 0x000F)) \
                 ) ? SQL_TRUE : SQL_FALSE \
                )
#endif  /* ODBCVER >= 0x0300 */


/************************************************/
/* Extended definitions for SQLGetInfo          */
/************************************************/

/*---------------------------------*/
/* Values in ODBC 2.0 that are not */
/* in the X/Open spec              */
/*---------------------------------*/

#define SQL_INFO_FIRST                       0
#define SQL_ACTIVE_CONNECTIONS               0  /* MAX_DRIVER_CONNECTIONS */
#define SQL_ACTIVE_STATEMENTS                1  /* MAX_CONCURRENT_ACTIVITIES */
#define SQL_DRIVER_HDBC                      3
#define SQL_DRIVER_HENV                      4
#define SQL_DRIVER_HSTMT                     5
#define SQL_DRIVER_NAME                      6
#define SQL_DRIVER_VER                       7
#define SQL_ODBC_API_CONFORMANCE             9
#define SQL_ODBC_VER                        10
#define SQL_ROW_UPDATES                     11
#define SQL_ODBC_SAG_CLI_CONFORMANCE        12
#define SQL_ODBC_SQL_CONFORMANCE            15
#define SQL_PROCEDURES                      21
#define SQL_CONCAT_NULL_BEHAVIOR            22
#define SQL_CURSOR_ROLLBACK_BEHAVIOR        24
#define SQL_EXPRESSIONS_IN_ORDERBY          27
#define SQL_MAX_OWNER_NAME_LEN              32  /* MAX_SCHEMA_NAME_LEN */
#define SQL_MAX_PROCEDURE_NAME_LEN          33
#define SQL_MAX_QUALIFIER_NAME_LEN          34  /* MAX_CATALOG_NAME_LEN */
#define SQL_MULT_RESULT_SETS                36
#define SQL_MULTIPLE_ACTIVE_TXN             37
#define SQL_OUTER_JOINS                     38
#define SQL_OWNER_TERM                      39
#define SQL_PROCEDURE_TERM                  40
#define SQL_QUALIFIER_NAME_SEPARATOR        41
#define SQL_QUALIFIER_TERM                  42
#define SQL_SCROLL_OPTIONS                  44
#define SQL_TABLE_TERM                      45
#define SQL_CONVERT_FUNCTIONS               48
#define SQL_NUMERIC_FUNCTIONS               49
#define SQL_STRING_FUNCTIONS                50
#define SQL_SYSTEM_FUNCTIONS                51
#define SQL_TIMEDATE_FUNCTIONS              52
#define SQL_CONVERT_BIGINT                  53
#define SQL_CONVERT_BINARY                  54
#define SQL_CONVERT_BIT                     55
#define SQL_CONVERT_CHAR                    56
#define SQL_CONVERT_DATE                    57
#define SQL_CONVERT_DECIMAL                 58
#define SQL_CONVERT_DOUBLE                  59
#define SQL_CONVERT_FLOAT                   60
#define SQL_CONVERT_INTEGER                 61
#define SQL_CONVERT_LONGVARCHAR             62
#define SQL_CONVERT_NUMERIC                 63
#define SQL_CONVERT_REAL                    64
#define SQL_CONVERT_SMALLINT                65
#define SQL_CONVERT_TIME                    66
#define SQL_CONVERT_TIMESTAMP               67
#define SQL_CONVERT_TINYINT                 68
#define SQL_CONVERT_VARBINARY               69
#define SQL_CONVERT_VARCHAR                 70
#define SQL_CONVERT_LONGVARBINARY           71
#define SQL_ODBC_SQL_OPT_IEF                73      /* SQL_INTEGRITY */
#define SQL_CORRELATION_NAME                74
#define SQL_NON_NULLABLE_COLUMNS            75
#define SQL_DRIVER_HLIB                     76
#define SQL_DRIVER_ODBC_VER                 77
#define SQL_LOCK_TYPES                      78
#define SQL_POS_OPERATIONS                  79
#define SQL_POSITIONED_STATEMENTS           80
#define SQL_BOOKMARK_PERSISTENCE            82
#define SQL_STATIC_SENSITIVITY              83
#define SQL_FILE_USAGE                      84
#define SQL_COLUMN_ALIAS                    87
#define SQL_GROUP_BY                        88
#define SQL_KEYWORDS                        89
#define SQL_OWNER_USAGE                     91
#define SQL_QUALIFIER_USAGE                 92
#define SQL_QUOTED_IDENTIFIER_CASE          93
#define SQL_SUBQUERIES                      95
#define SQL_UNION                           96
#define SQL_MAX_ROW_SIZE_INCLUDES_LONG      103
#define SQL_MAX_CHAR_LITERAL_LEN            108
#define SQL_TIMEDATE_ADD_INTERVALS          109
#define SQL_TIMEDATE_DIFF_INTERVALS         110
#define SQL_NEED_LONG_DATA_LEN              111
#define SQL_MAX_BINARY_LITERAL_LEN          112
#define SQL_LIKE_ESCAPE_CLAUSE              113
#define SQL_QUALIFIER_LOCATION              114

#if (ODBCVER >= 0x0201 && ODBCVER < 0x0300)
#define SQL_OJ_CAPABILITIES         65003  /* Temp value until ODBC 3.0 */
#endif  /* ODBCVER >= 0x0201 && ODBCVER < 0x0300 */

/*----------------------------------------------*/
/* SQL_INFO_LAST and SQL_INFO_DRIVER_START are  */
/* not useful anymore, because  X/Open has      */
/* values in the 10000 range.   You             */
/* must contact X/Open directly to get a range  */
/* of numbers for driver-specific values.       */
/*----------------------------------------------*/

#if (ODBCVER < 0x0300)
#define SQL_INFO_LAST                       SQL_QUALIFIER_LOCATION
#define SQL_INFO_DRIVER_START               1000
#endif /* ODBCVER < 0x0300 */

/*-----------------------------------------------*/
/* ODBC 3.0 SQLGetInfo values that are not part  */
/* of the X/Open standard at this time.   X/Open */
/* standard values are in sql.h.                 */
/*-----------------------------------------------*/

#if (ODBCVER >= 0x0300)
#define SQL_ACTIVE_ENVIRONMENTS                 116
#define SQL_ALTER_DOMAIN                        117

#define SQL_SQL_CONFORMANCE                     118
#define SQL_DATETIME_LITERALS                   119

#define SQL_ASYNC_MODE                          10021   /* new X/Open spec */
#define SQL_BATCH_ROW_COUNT                     120
#define SQL_BATCH_SUPPORT                       121
#define SQL_CATALOG_LOCATION                    SQL_QUALIFIER_LOCATION
#define SQL_CATALOG_NAME_SEPARATOR              SQL_QUALIFIER_NAME_SEPARATOR
#define SQL_CATALOG_TERM                        SQL_QUALIFIER_TERM
#define SQL_CATALOG_USAGE                       SQL_QUALIFIER_USAGE
#define SQL_CONVERT_WCHAR                       122
#define SQL_CONVERT_INTERVAL_DAY_TIME           123
#define SQL_CONVERT_INTERVAL_YEAR_MONTH         124
#define SQL_CONVERT_WLONGVARCHAR                125
#define SQL_CONVERT_WVARCHAR                    126
#define SQL_CREATE_ASSERTION                    127
#define SQL_CREATE_CHARACTER_SET                128
#define SQL_CREATE_COLLATION                    129
#define SQL_CREATE_DOMAIN                       130
#define SQL_CREATE_SCHEMA                       131
#define SQL_CREATE_TABLE                        132
#define SQL_CREATE_TRANSLATION                  133
#define SQL_CREATE_VIEW                         134
#define SQL_DRIVER_HDESC                        135
#define SQL_DROP_ASSERTION                      136
#define SQL_DROP_CHARACTER_SET                  137
#define SQL_DROP_COLLATION                      138
#define SQL_DROP_DOMAIN                         139
#define SQL_DROP_SCHEMA                         140
#define SQL_DROP_TABLE                          141
#define SQL_DROP_TRANSLATION                    142
#define SQL_DROP_VIEW                           143
#define SQL_DYNAMIC_CURSOR_ATTRIBUTES1          144
#define SQL_DYNAMIC_CURSOR_ATTRIBUTES2          145
#define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1     146
#define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2     147
#define SQL_INDEX_KEYWORDS                      148
#define SQL_INFO_SCHEMA_VIEWS                   149
#define SQL_KEYSET_CURSOR_ATTRIBUTES1           150
#define SQL_KEYSET_CURSOR_ATTRIBUTES2           151
#define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS     10022   /* new X/Open spec */
#define SQL_ODBC_INTERFACE_CONFORMANCE          152
#define SQL_PARAM_ARRAY_ROW_COUNTS              153
#define SQL_PARAM_ARRAY_SELECTS                 154
#define SQL_SCHEMA_TERM                         SQL_OWNER_TERM
#define SQL_SCHEMA_USAGE                        SQL_OWNER_USAGE
#define SQL_SQL92_DATETIME_FUNCTIONS            155
#define SQL_SQL92_FOREIGN_KEY_DELETE_RULE       156
#define SQL_SQL92_FOREIGN_KEY_UPDATE_RULE       157
#define SQL_SQL92_GRANT                         158
#define SQL_SQL92_NUMERIC_VALUE_FUNCTIONS       159
#define SQL_SQL92_PREDICATES                    160
#define SQL_SQL92_RELATIONAL_JOIN_OPERATORS     161
#define SQL_SQL92_REVOKE                        162
#define SQL_SQL92_ROW_VALUE_CONSTRUCTOR         163
#define SQL_SQL92_STRING_FUNCTIONS              164
#define SQL_SQL92_VALUE_EXPRESSIONS             165
#define SQL_STANDARD_CLI_CONFORMANCE            166
#define SQL_STATIC_CURSOR_ATTRIBUTES1           167
#define SQL_STATIC_CURSOR_ATTRIBUTES2           168

#define SQL_AGGREGATE_FUNCTIONS                 169
#define SQL_DDL_INDEX                           170
#define SQL_DM_VER                              171
#define SQL_INSERT_STATEMENT                    172
#define SQL_CONVERT_GUID                        173
#define SQL_UNION_STATEMENT                     SQL_UNION

#if (ODBCVER >= 0x0380)
// Info Types
#define SQL_ASYNC_DBC_FUNCTIONS                 10023
#endif // ODBCVER >= 0x0380

#endif  /* ODBCVER >= 0x0300 */

#define SQL_DTC_TRANSITION_COST                 1750

/* SQL_ALTER_TABLE bitmasks */
#if (ODBCVER >= 0x0300)
/* the following 5 bitmasks are defined in sql.h
*#define SQL_AT_ADD_COLUMN                      0x00000001L
*#define SQL_AT_DROP_COLUMN                     0x00000002L
*#define SQL_AT_ADD_CONSTRAINT                  0x00000008L
*/
#define SQL_AT_ADD_COLUMN_SINGLE                0x00000020L
#define SQL_AT_ADD_COLUMN_DEFAULT               0x00000040L
#define SQL_AT_ADD_COLUMN_COLLATION             0x00000080L
#define SQL_AT_SET_COLUMN_DEFAULT               0x00000100L
#define SQL_AT_DROP_COLUMN_DEFAULT              0x00000200L
#define SQL_AT_DROP_COLUMN_CASCADE              0x00000400L
#define SQL_AT_DROP_COLUMN_RESTRICT             0x00000800L
#define SQL_AT_ADD_TABLE_CONSTRAINT             0x00001000L
#define SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE    0x00002000L
#define SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT   0x00004000L
#define SQL_AT_CONSTRAINT_NAME_DEFINITION       0x00008000L
#define SQL_AT_CONSTRAINT_INITIALLY_DEFERRED    0x00010000L
#define SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE   0x00020000L
#define SQL_AT_CONSTRAINT_DEFERRABLE            0x00040000L
#define SQL_AT_CONSTRAINT_NON_DEFERRABLE        0x00080000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_CONVERT_*  return value bitmasks */

#define SQL_CVT_CHAR                        0x00000001L
#define SQL_CVT_NUMERIC                     0x00000002L
#define SQL_CVT_DECIMAL                     0x00000004L
#define SQL_CVT_INTEGER                     0x00000008L
#define SQL_CVT_SMALLINT                    0x00000010L
#define SQL_CVT_FLOAT                       0x00000020L
#define SQL_CVT_REAL                        0x00000040L
#define SQL_CVT_DOUBLE                      0x00000080L
#define SQL_CVT_VARCHAR                     0x00000100L
#define SQL_CVT_LONGVARCHAR                 0x00000200L
#define SQL_CVT_BINARY                      0x00000400L
#define SQL_CVT_VARBINARY                   0x00000800L
#define SQL_CVT_BIT                         0x00001000L
#define SQL_CVT_TINYINT                     0x00002000L
#define SQL_CVT_BIGINT                      0x00004000L
#define SQL_CVT_DATE                        0x00008000L
#define SQL_CVT_TIME                        0x00010000L
#define SQL_CVT_TIMESTAMP                   0x00020000L
#define SQL_CVT_LONGVARBINARY               0x00040000L
#if (ODBCVER >= 0x0300)
#define SQL_CVT_INTERVAL_YEAR_MONTH         0x00080000L
#define SQL_CVT_INTERVAL_DAY_TIME           0x00100000L
#define SQL_CVT_WCHAR                       0x00200000L
#define SQL_CVT_WLONGVARCHAR                0x00400000L
#define SQL_CVT_WVARCHAR                    0x00800000L
#define SQL_CVT_GUID                        0x01000000L

#endif  /* ODBCVER >= 0x0300 */


/* SQL_CONVERT_FUNCTIONS functions */
#define SQL_FN_CVT_CONVERT                  0x00000001L
#if (ODBCVER >= 0x0300)
#define SQL_FN_CVT_CAST                     0x00000002L
#endif  /* ODBCVER >= 0x0300 */


/* SQL_STRING_FUNCTIONS functions */

#define SQL_FN_STR_CONCAT                   0x00000001L
#define SQL_FN_STR_INSERT                   0x00000002L
#define SQL_FN_STR_LEFT                     0x00000004L
#define SQL_FN_STR_LTRIM                    0x00000008L
#define SQL_FN_STR_LENGTH                   0x00000010L
#define SQL_FN_STR_LOCATE                   0x00000020L
#define SQL_FN_STR_LCASE                    0x00000040L
#define SQL_FN_STR_REPEAT                   0x00000080L
#define SQL_FN_STR_REPLACE                  0x00000100L
#define SQL_FN_STR_RIGHT                    0x00000200L
#define SQL_FN_STR_RTRIM                    0x00000400L
#define SQL_FN_STR_SUBSTRING                0x00000800L
#define SQL_FN_STR_UCASE                    0x00001000L
#define SQL_FN_STR_ASCII                    0x00002000L
#define SQL_FN_STR_CHAR                     0x00004000L
#define SQL_FN_STR_DIFFERENCE               0x00008000L
#define SQL_FN_STR_LOCATE_2                 0x00010000L
#define SQL_FN_STR_SOUNDEX                  0x00020000L
#define SQL_FN_STR_SPACE                    0x00040000L
#if (ODBCVER >= 0x0300)
#define SQL_FN_STR_BIT_LENGTH               0x00080000L
#define SQL_FN_STR_CHAR_LENGTH              0x00100000L
#define SQL_FN_STR_CHARACTER_LENGTH         0x00200000L
#define SQL_FN_STR_OCTET_LENGTH             0x00400000L
#define SQL_FN_STR_POSITION                 0x00800000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SQL92_STRING_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SSF_CONVERT                     0x00000001L
#define SQL_SSF_LOWER                       0x00000002L
#define SQL_SSF_UPPER                       0x00000004L
#define SQL_SSF_SUBSTRING                   0x00000008L
#define SQL_SSF_TRANSLATE                   0x00000010L
#define SQL_SSF_TRIM_BOTH                   0x00000020L
#define SQL_SSF_TRIM_LEADING                0x00000040L
#define SQL_SSF_TRIM_TRAILING               0x00000080L
#endif /* ODBCVER >= 0x0300 */

/* SQL_NUMERIC_FUNCTIONS functions */

#define SQL_FN_NUM_ABS                      0x00000001L
#define SQL_FN_NUM_ACOS                     0x00000002L
#define SQL_FN_NUM_ASIN                     0x00000004L
#define SQL_FN_NUM_ATAN                     0x00000008L
#define SQL_FN_NUM_ATAN2                    0x00000010L
#define SQL_FN_NUM_CEILING                  0x00000020L
#define SQL_FN_NUM_COS                      0x00000040L
#define SQL_FN_NUM_COT                      0x00000080L
#define SQL_FN_NUM_EXP                      0x00000100L
#define SQL_FN_NUM_FLOOR                    0x00000200L
#define SQL_FN_NUM_LOG                      0x00000400L
#define SQL_FN_NUM_MOD                      0x00000800L
#define SQL_FN_NUM_SIGN                     0x00001000L
#define SQL_FN_NUM_SIN                      0x00002000L
#define SQL_FN_NUM_SQRT                     0x00004000L
#define SQL_FN_NUM_TAN                      0x00008000L
#define SQL_FN_NUM_PI                       0x00010000L
#define SQL_FN_NUM_RAND                     0x00020000L
#define SQL_FN_NUM_DEGREES                  0x00040000L
#define SQL_FN_NUM_LOG10                    0x00080000L
#define SQL_FN_NUM_POWER                    0x00100000L
#define SQL_FN_NUM_RADIANS                  0x00200000L
#define SQL_FN_NUM_ROUND                    0x00400000L
#define SQL_FN_NUM_TRUNCATE                 0x00800000L

/* SQL_SQL92_NUMERIC_VALUE_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SNVF_BIT_LENGTH                 0x00000001L
#define SQL_SNVF_CHAR_LENGTH                0x00000002L
#define SQL_SNVF_CHARACTER_LENGTH           0x00000004L
#define SQL_SNVF_EXTRACT                    0x00000008L
#define SQL_SNVF_OCTET_LENGTH               0x00000010L
#define SQL_SNVF_POSITION                   0x00000020L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_TIMEDATE_FUNCTIONS functions */

#define SQL_FN_TD_NOW                       0x00000001L
#define SQL_FN_TD_CURDATE                   0x00000002L
#define SQL_FN_TD_DAYOFMONTH                0x00000004L
#define SQL_FN_TD_DAYOFWEEK                 0x00000008L
#define SQL_FN_TD_DAYOFYEAR                 0x00000010L
#define SQL_FN_TD_MONTH                     0x00000020L
#define SQL_FN_TD_QUARTER                   0x00000040L
#define SQL_FN_TD_WEEK                      0x00000080L
#define SQL_FN_TD_YEAR                      0x00000100L
#define SQL_FN_TD_CURTIME                   0x00000200L
#define SQL_FN_TD_HOUR                      0x00000400L
#define SQL_FN_TD_MINUTE                    0x00000800L
#define SQL_FN_TD_SECOND                    0x00001000L
#define SQL_FN_TD_TIMESTAMPADD              0x00002000L
#define SQL_FN_TD_TIMESTAMPDIFF             0x00004000L
#define SQL_FN_TD_DAYNAME                   0x00008000L
#define SQL_FN_TD_MONTHNAME                 0x00010000L
#if (ODBCVER >= 0x0300)
#define SQL_FN_TD_CURRENT_DATE              0x00020000L
#define SQL_FN_TD_CURRENT_TIME              0x00040000L
#define SQL_FN_TD_CURRENT_TIMESTAMP         0x00080000L
#define SQL_FN_TD_EXTRACT                   0x00100000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SQL92_DATETIME_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SDF_CURRENT_DATE                0x00000001L
#define SQL_SDF_CURRENT_TIME                0x00000002L
#define SQL_SDF_CURRENT_TIMESTAMP           0x00000004L
#endif /* ODBCVER >= 0x0300 */

/* SQL_SYSTEM_FUNCTIONS functions */

#define SQL_FN_SYS_USERNAME                 0x00000001L
#define SQL_FN_SYS_DBNAME                   0x00000002L
#define SQL_FN_SYS_IFNULL                   0x00000004L

/* SQL_TIMEDATE_ADD_INTERVALS and SQL_TIMEDATE_DIFF_INTERVALS functions */

#define SQL_FN_TSI_FRAC_SECOND              0x00000001L
#define SQL_FN_TSI_SECOND                   0x00000002L
#define SQL_FN_TSI_MINUTE                   0x00000004L
#define SQL_FN_TSI_HOUR                     0x00000008L
#define SQL_FN_TSI_DAY                      0x00000010L
#define SQL_FN_TSI_WEEK                     0x00000020L
#define SQL_FN_TSI_MONTH                    0x00000040L
#define SQL_FN_TSI_QUARTER                  0x00000080L
#define SQL_FN_TSI_YEAR                     0x00000100L

/* bitmasks for SQL_DYNAMIC_CURSOR_ATTRIBUTES1,
 * SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1,
 * SQL_KEYSET_CURSOR_ATTRIBUTES1, and SQL_STATIC_CURSOR_ATTRIBUTES1
 */
#if (ODBCVER >= 0x0300)
/* supported SQLFetchScroll FetchOrientation's */
#define SQL_CA1_NEXT                        0x00000001L
#define SQL_CA1_ABSOLUTE                    0x00000002L
#define SQL_CA1_RELATIVE                    0x00000004L
#define SQL_CA1_BOOKMARK                    0x00000008L

/* supported SQLSetPos LockType's */
#define SQL_CA1_LOCK_NO_CHANGE              0x00000040L
#define SQL_CA1_LOCK_EXCLUSIVE              0x00000080L
#define SQL_CA1_LOCK_UNLOCK                 0x00000100L

/* supported SQLSetPos Operations */
#define SQL_CA1_POS_POSITION                0x00000200L
#define SQL_CA1_POS_UPDATE                  0x00000400L
#define SQL_CA1_POS_DELETE                  0x00000800L
#define SQL_CA1_POS_REFRESH                 0x00001000L

/* positioned updates and deletes */
#define SQL_CA1_POSITIONED_UPDATE           0x00002000L
#define SQL_CA1_POSITIONED_DELETE           0x00004000L
#define SQL_CA1_SELECT_FOR_UPDATE           0x00008000L

/* supported SQLBulkOperations operations */
#define SQL_CA1_BULK_ADD                    0x00010000L
#define SQL_CA1_BULK_UPDATE_BY_BOOKMARK     0x00020000L
#define SQL_CA1_BULK_DELETE_BY_BOOKMARK     0x00040000L
#define SQL_CA1_BULK_FETCH_BY_BOOKMARK      0x00080000L
#endif  /* ODBCVER >= 0x0300 */

/* bitmasks for SQL_DYNAMIC_CURSOR_ATTRIBUTES2,
 * SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2,
 * SQL_KEYSET_CURSOR_ATTRIBUTES2, and SQL_STATIC_CURSOR_ATTRIBUTES2
 */
#if (ODBCVER >= 0x0300)
/* supported values for SQL_ATTR_SCROLL_CONCURRENCY */
#define SQL_CA2_READ_ONLY_CONCURRENCY       0x00000001L
#define SQL_CA2_LOCK_CONCURRENCY            0x00000002L
#define SQL_CA2_OPT_ROWVER_CONCURRENCY      0x00000004L
#define SQL_CA2_OPT_VALUES_CONCURRENCY      0x00000008L

/* sensitivity of the cursor to its own inserts, deletes, and updates */
#define SQL_CA2_SENSITIVITY_ADDITIONS       0x00000010L
#define SQL_CA2_SENSITIVITY_DELETIONS       0x00000020L
#define SQL_CA2_SENSITIVITY_UPDATES         0x00000040L

/* semantics of SQL_ATTR_MAX_ROWS */
#define SQL_CA2_MAX_ROWS_SELECT             0x00000080L
#define SQL_CA2_MAX_ROWS_INSERT             0x00000100L
#define SQL_CA2_MAX_ROWS_DELETE             0x00000200L
#define SQL_CA2_MAX_ROWS_UPDATE             0x00000400L
#define SQL_CA2_MAX_ROWS_CATALOG            0x00000800L
#define SQL_CA2_MAX_ROWS_AFFECTS_ALL        (SQL_CA2_MAX_ROWS_SELECT | \
                    SQL_CA2_MAX_ROWS_INSERT | SQL_CA2_MAX_ROWS_DELETE | \
                    SQL_CA2_MAX_ROWS_UPDATE | SQL_CA2_MAX_ROWS_CATALOG)

/* semantics of SQL_DIAG_CURSOR_ROW_COUNT */
#define SQL_CA2_CRC_EXACT                   0x00001000L
#define SQL_CA2_CRC_APPROXIMATE             0x00002000L

/* the kinds of positioned statements that can be simulated */
#define SQL_CA2_SIMULATE_NON_UNIQUE         0x00004000L
#define SQL_CA2_SIMULATE_TRY_UNIQUE         0x00008000L
#define SQL_CA2_SIMULATE_UNIQUE             0x00010000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_ODBC_API_CONFORMANCE values */

#define SQL_OAC_NONE                        0x0000
#define SQL_OAC_LEVEL1                      0x0001
#define SQL_OAC_LEVEL2                      0x0002

/* SQL_ODBC_SAG_CLI_CONFORMANCE values */

#define SQL_OSCC_NOT_COMPLIANT              0x0000
#define SQL_OSCC_COMPLIANT                  0x0001

/* SQL_ODBC_SQL_CONFORMANCE values */

#define SQL_OSC_MINIMUM                     0x0000
#define SQL_OSC_CORE                        0x0001
#define SQL_OSC_EXTENDED                    0x0002


/* SQL_CONCAT_NULL_BEHAVIOR values */

#define SQL_CB_NULL                         0x0000
#define SQL_CB_NON_NULL                     0x0001

/* SQL_SCROLL_OPTIONS masks */

#define SQL_SO_FORWARD_ONLY                 0x00000001L
#define SQL_SO_KEYSET_DRIVEN                0x00000002L
#define SQL_SO_DYNAMIC                      0x00000004L
#define SQL_SO_MIXED                        0x00000008L
#define SQL_SO_STATIC                       0x00000010L

/* SQL_FETCH_DIRECTION masks */

/* SQL_FETCH_RESUME is no longer supported
#define SQL_FD_FETCH_RESUME                 0x00000040L
*/
#define SQL_FD_FETCH_BOOKMARK               0x00000080L

/* SQL_TXN_ISOLATION_OPTION masks */
/* SQL_TXN_VERSIONING is no longer supported
#define SQL_TXN_VERSIONING                  0x00000010L
*/

/* SQL_CORRELATION_NAME values */

#define SQL_CN_NONE                         0x0000
#define SQL_CN_DIFFERENT                    0x0001
#define SQL_CN_ANY                          0x0002

/* SQL_NON_NULLABLE_COLUMNS values */

#define SQL_NNC_NULL                        0x0000
#define SQL_NNC_NON_NULL                    0x0001

/* SQL_NULL_COLLATION values */

#define SQL_NC_START                        0x0002
#define SQL_NC_END                          0x0004

/* SQL_FILE_USAGE values */

#define SQL_FILE_NOT_SUPPORTED              0x0000
#define SQL_FILE_TABLE                      0x0001
#define SQL_FILE_QUALIFIER                  0x0002
#define SQL_FILE_CATALOG                    SQL_FILE_QUALIFIER  // ODBC 3.0


/* SQL_GETDATA_EXTENSIONS values */

#define SQL_GD_BLOCK                        0x00000004L
#define SQL_GD_BOUND                        0x00000008L
#if (ODBCVER >= 0x0380)
    #define SQL_GD_OUTPUT_PARAMS            0x00000010L
#endif

/* SQL_POSITIONED_STATEMENTS masks */

#define SQL_PS_POSITIONED_DELETE            0x00000001L
#define SQL_PS_POSITIONED_UPDATE            0x00000002L
#define SQL_PS_SELECT_FOR_UPDATE            0x00000004L

/* SQL_GROUP_BY values */

#define SQL_GB_NOT_SUPPORTED                0x0000
#define SQL_GB_GROUP_BY_EQUALS_SELECT       0x0001
#define SQL_GB_GROUP_BY_CONTAINS_SELECT     0x0002
#define SQL_GB_NO_RELATION                  0x0003
#if (ODBCVER >= 0x0300)
#define SQL_GB_COLLATE                      0x0004

#endif  /* ODBCVER >= 0x0300 */

/* SQL_OWNER_USAGE masks */

#define SQL_OU_DML_STATEMENTS               0x00000001L
#define SQL_OU_PROCEDURE_INVOCATION         0x00000002L
#define SQL_OU_TABLE_DEFINITION             0x00000004L
#define SQL_OU_INDEX_DEFINITION             0x00000008L
#define SQL_OU_PRIVILEGE_DEFINITION         0x00000010L

/* SQL_SCHEMA_USAGE masks */
#if (ODBCVER >= 0x0300)
#define SQL_SU_DML_STATEMENTS           SQL_OU_DML_STATEMENTS
#define SQL_SU_PROCEDURE_INVOCATION     SQL_OU_PROCEDURE_INVOCATION
#define SQL_SU_TABLE_DEFINITION         SQL_OU_TABLE_DEFINITION
#define SQL_SU_INDEX_DEFINITION         SQL_OU_INDEX_DEFINITION
#define SQL_SU_PRIVILEGE_DEFINITION     SQL_OU_PRIVILEGE_DEFINITION
#endif  /* ODBCVER >= 0x0300 */

/* SQL_QUALIFIER_USAGE masks */

#define SQL_QU_DML_STATEMENTS               0x00000001L
#define SQL_QU_PROCEDURE_INVOCATION         0x00000002L
#define SQL_QU_TABLE_DEFINITION             0x00000004L
#define SQL_QU_INDEX_DEFINITION             0x00000008L
#define SQL_QU_PRIVILEGE_DEFINITION         0x00000010L

#if (ODBCVER >= 0x0300)
/* SQL_CATALOG_USAGE masks */
#define SQL_CU_DML_STATEMENTS           SQL_QU_DML_STATEMENTS
#define SQL_CU_PROCEDURE_INVOCATION     SQL_QU_PROCEDURE_INVOCATION
#define SQL_CU_TABLE_DEFINITION         SQL_QU_TABLE_DEFINITION
#define SQL_CU_INDEX_DEFINITION         SQL_QU_INDEX_DEFINITION
#define SQL_CU_PRIVILEGE_DEFINITION     SQL_QU_PRIVILEGE_DEFINITION
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SUBQUERIES masks */

#define SQL_SQ_COMPARISON                   0x00000001L
#define SQL_SQ_EXISTS                       0x00000002L
#define SQL_SQ_IN                           0x00000004L
#define SQL_SQ_QUANTIFIED                   0x00000008L
#define SQL_SQ_CORRELATED_SUBQUERIES        0x00000010L

/* SQL_UNION masks */

#define SQL_U_UNION                         0x00000001L
#define SQL_U_UNION_ALL                     0x00000002L

/* SQL_BOOKMARK_PERSISTENCE values */

#define SQL_BP_CLOSE                        0x00000001L
#define SQL_BP_DELETE                       0x00000002L
#define SQL_BP_DROP                         0x00000004L
#define SQL_BP_TRANSACTION                  0x00000008L
#define SQL_BP_UPDATE                       0x00000010L
#define SQL_BP_OTHER_HSTMT                  0x00000020L
#define SQL_BP_SCROLL                       0x00000040L

/* SQL_STATIC_SENSITIVITY values */

#define SQL_SS_ADDITIONS                    0x00000001L
#define SQL_SS_DELETIONS                    0x00000002L
#define SQL_SS_UPDATES                      0x00000004L

/* SQL_VIEW values */
#define SQL_CV_CREATE_VIEW                  0x00000001L
#define SQL_CV_CHECK_OPTION                 0x00000002L
#define SQL_CV_CASCADED                     0x00000004L
#define SQL_CV_LOCAL                        0x00000008L

/* SQL_LOCK_TYPES masks */

#define SQL_LCK_NO_CHANGE                   0x00000001L
#define SQL_LCK_EXCLUSIVE                   0x00000002L
#define SQL_LCK_UNLOCK                      0x00000004L

/* SQL_POS_OPERATIONS masks */

#define SQL_POS_POSITION                    0x00000001L
#define SQL_POS_REFRESH                     0x00000002L
#define SQL_POS_UPDATE                      0x00000004L
#define SQL_POS_DELETE                      0x00000008L
#define SQL_POS_ADD                         0x00000010L

/* SQL_QUALIFIER_LOCATION values */

#define SQL_QL_START                        0x0001
#define SQL_QL_END                          0x0002

/* Here start return values for ODBC 3.0 SQLGetInfo */

#if (ODBCVER >= 0x0300)
/* SQL_AGGREGATE_FUNCTIONS bitmasks */
#define SQL_AF_AVG                      0x00000001L
#define SQL_AF_COUNT                    0x00000002L
#define SQL_AF_MAX                      0x00000004L
#define SQL_AF_MIN                      0x00000008L
#define SQL_AF_SUM                      0x00000010L
#define SQL_AF_DISTINCT                 0x00000020L
#define SQL_AF_ALL                      0x00000040L

/* SQL_SQL_CONFORMANCE bit masks */
#define SQL_SC_SQL92_ENTRY              0x00000001L
#define SQL_SC_FIPS127_2_TRANSITIONAL   0x00000002L
#define SQL_SC_SQL92_INTERMEDIATE       0x00000004L
#define SQL_SC_SQL92_FULL               0x00000008L

/* SQL_DATETIME_LITERALS masks */
#define SQL_DL_SQL92_DATE                       0x00000001L
#define SQL_DL_SQL92_TIME                       0x00000002L
#define SQL_DL_SQL92_TIMESTAMP                  0x00000004L
#define SQL_DL_SQL92_INTERVAL_YEAR              0x00000008L
#define SQL_DL_SQL92_INTERVAL_MONTH             0x00000010L
#define SQL_DL_SQL92_INTERVAL_DAY               0x00000020L
#define SQL_DL_SQL92_INTERVAL_HOUR              0x00000040L
#define SQL_DL_SQL92_INTERVAL_MINUTE            0x00000080L
#define SQL_DL_SQL92_INTERVAL_SECOND            0x00000100L
#define SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH     0x00000200L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR       0x00000400L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE     0x00000800L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND     0x00001000L
#define SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE    0x00002000L
#define SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND    0x00004000L
#define SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND  0x00008000L

/* SQL_CATALOG_LOCATION values */
#define SQL_CL_START                        SQL_QL_START
#define SQL_CL_END                          SQL_QL_END

/* values for SQL_BATCH_ROW_COUNT */
#define SQL_BRC_PROCEDURES          0x0000001
#define SQL_BRC_EXPLICIT            0x0000002
#define SQL_BRC_ROLLED_UP           0x0000004

/* bitmasks for SQL_BATCH_SUPPORT */
#define SQL_BS_SELECT_EXPLICIT              0x00000001L
#define SQL_BS_ROW_COUNT_EXPLICIT           0x00000002L
#define SQL_BS_SELECT_PROC                  0x00000004L
#define SQL_BS_ROW_COUNT_PROC               0x00000008L

/* Values for SQL_PARAM_ARRAY_ROW_COUNTS getinfo */
#define SQL_PARC_BATCH      1
#define SQL_PARC_NO_BATCH   2

/* values for SQL_PARAM_ARRAY_SELECTS */
#define SQL_PAS_BATCH               1
#define SQL_PAS_NO_BATCH            2
#define SQL_PAS_NO_SELECT           3

/* Bitmasks for SQL_INDEX_KEYWORDS */
#define SQL_IK_NONE                         0x00000000L
#define SQL_IK_ASC                          0x00000001L
#define SQL_IK_DESC                         0x00000002L
#define SQL_IK_ALL                          (SQL_IK_ASC | SQL_IK_DESC)

/* Bitmasks for SQL_INFO_SCHEMA_VIEWS */

#define SQL_ISV_ASSERTIONS                  0x00000001L
#define SQL_ISV_CHARACTER_SETS              0x00000002L
#define SQL_ISV_CHECK_CONSTRAINTS           0x00000004L
#define SQL_ISV_COLLATIONS                  0x00000008L
#define SQL_ISV_COLUMN_DOMAIN_USAGE         0x00000010L
#define SQL_ISV_COLUMN_PRIVILEGES           0x00000020L
#define SQL_ISV_COLUMNS                     0x00000040L
#define SQL_ISV_CONSTRAINT_COLUMN_USAGE     0x00000080L
#define SQL_ISV_CONSTRAINT_TABLE_USAGE      0x00000100L
#define SQL_ISV_DOMAIN_CONSTRAINTS          0x00000200L
#define SQL_ISV_DOMAINS                     0x00000400L
#define SQL_ISV_KEY_COLUMN_USAGE            0x00000800L
#define SQL_ISV_REFERENTIAL_CONSTRAINTS     0x00001000L
#define SQL_ISV_SCHEMATA                    0x00002000L
#define SQL_ISV_SQL_LANGUAGES               0x00004000L
#define SQL_ISV_TABLE_CONSTRAINTS           0x00008000L
#define SQL_ISV_TABLE_PRIVILEGES            0x00010000L
#define SQL_ISV_TABLES                      0x00020000L
#define SQL_ISV_TRANSLATIONS                0x00040000L
#define SQL_ISV_USAGE_PRIVILEGES            0x00080000L
#define SQL_ISV_VIEW_COLUMN_USAGE           0x00100000L
#define SQL_ISV_VIEW_TABLE_USAGE            0x00200000L
#define SQL_ISV_VIEWS                       0x00400000L

/* Bitmasks for SQL_ASYNC_MODE */

#define SQL_AM_NONE         0
#define SQL_AM_CONNECTION   1
#define SQL_AM_STATEMENT    2

/* Bitmasks for SQL_ALTER_DOMAIN */
#define SQL_AD_CONSTRAINT_NAME_DEFINITION           0x00000001L
#define SQL_AD_ADD_DOMAIN_CONSTRAINT                0x00000002L
#define SQL_AD_DROP_DOMAIN_CONSTRAINT               0x00000004L
#define SQL_AD_ADD_DOMAIN_DEFAULT                   0x00000008L
#define SQL_AD_DROP_DOMAIN_DEFAULT                  0x00000010L
#define SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED    0x00000020L
#define SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE   0x00000040L
#define SQL_AD_ADD_CONSTRAINT_DEFERRABLE            0x00000080L
#define SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE        0x00000100L


/* SQL_CREATE_SCHEMA bitmasks */
#define SQL_CS_CREATE_SCHEMA                0x00000001L
#define SQL_CS_AUTHORIZATION                0x00000002L
#define SQL_CS_DEFAULT_CHARACTER_SET        0x00000004L

/* SQL_CREATE_TRANSLATION bitmasks */
#define SQL_CTR_CREATE_TRANSLATION          0x00000001L

/* SQL_CREATE_ASSERTION bitmasks */
#define SQL_CA_CREATE_ASSERTION                 0x00000001L
#define SQL_CA_CONSTRAINT_INITIALLY_DEFERRED    0x00000010L
#define SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE   0x00000020L
#define SQL_CA_CONSTRAINT_DEFERRABLE            0x00000040L
#define SQL_CA_CONSTRAINT_NON_DEFERRABLE        0x00000080L

/* SQL_CREATE_CHARACTER_SET bitmasks */
#define SQL_CCS_CREATE_CHARACTER_SET        0x00000001L
#define SQL_CCS_COLLATE_CLAUSE              0x00000002L
#define SQL_CCS_LIMITED_COLLATION           0x00000004L

/* SQL_CREATE_COLLATION bitmasks */
#define SQL_CCOL_CREATE_COLLATION           0x00000001L

/* SQL_CREATE_DOMAIN bitmasks */
#define SQL_CDO_CREATE_DOMAIN                   0x00000001L
#define SQL_CDO_DEFAULT                         0x00000002L
#define SQL_CDO_CONSTRAINT                      0x00000004L
#define SQL_CDO_COLLATION                       0x00000008L
#define SQL_CDO_CONSTRAINT_NAME_DEFINITION      0x00000010L
#define SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED   0x00000020L
#define SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE  0x00000040L
#define SQL_CDO_CONSTRAINT_DEFERRABLE           0x00000080L
#define SQL_CDO_CONSTRAINT_NON_DEFERRABLE       0x00000100L

/* SQL_CREATE_TABLE bitmasks */
#define SQL_CT_CREATE_TABLE                     0x00000001L
#define SQL_CT_COMMIT_PRESERVE                  0x00000002L
#define SQL_CT_COMMIT_DELETE                    0x00000004L
#define SQL_CT_GLOBAL_TEMPORARY                 0x00000008L
#define SQL_CT_LOCAL_TEMPORARY                  0x00000010L
#define SQL_CT_CONSTRAINT_INITIALLY_DEFERRED    0x00000020L
#define SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE   0x00000040L
#define SQL_CT_CONSTRAINT_DEFERRABLE            0x00000080L
#define SQL_CT_CONSTRAINT_NON_DEFERRABLE        0x00000100L
#define SQL_CT_COLUMN_CONSTRAINT                0x00000200L
#define SQL_CT_COLUMN_DEFAULT                   0x00000400L
#define SQL_CT_COLUMN_COLLATION                 0x00000800L
#define SQL_CT_TABLE_CONSTRAINT                 0x00001000L
#define SQL_CT_CONSTRAINT_NAME_DEFINITION       0x00002000L

/* SQL_DDL_INDEX bitmasks */
#define SQL_DI_CREATE_INDEX                     0x00000001L
#define SQL_DI_DROP_INDEX                       0x00000002L

/* SQL_DROP_COLLATION bitmasks */
#define SQL_DC_DROP_COLLATION                   0x00000001L

/* SQL_DROP_DOMAIN bitmasks */
#define SQL_DD_DROP_DOMAIN                      0x00000001L
#define SQL_DD_RESTRICT                         0x00000002L
#define SQL_DD_CASCADE                          0x00000004L

/* SQL_DROP_SCHEMA bitmasks */
#define SQL_DS_DROP_SCHEMA                      0x00000001L
#define SQL_DS_RESTRICT                         0x00000002L
#define SQL_DS_CASCADE                          0x00000004L

/* SQL_DROP_CHARACTER_SET bitmasks */
#define SQL_DCS_DROP_CHARACTER_SET              0x00000001L

/* SQL_DROP_ASSERTION bitmasks */
#define SQL_DA_DROP_ASSERTION                   0x00000001L

/* SQL_DROP_TABLE bitmasks */
#define SQL_DT_DROP_TABLE                       0x00000001L
#define SQL_DT_RESTRICT                         0x00000002L
#define SQL_DT_CASCADE                          0x00000004L

/* SQL_DROP_TRANSLATION bitmasks */
#define SQL_DTR_DROP_TRANSLATION                0x00000001L

/* SQL_DROP_VIEW bitmasks */
#define SQL_DV_DROP_VIEW                        0x00000001L
#define SQL_DV_RESTRICT                         0x00000002L
#define SQL_DV_CASCADE                          0x00000004L

/* SQL_INSERT_STATEMENT bitmasks */
#define SQL_IS_INSERT_LITERALS                  0x00000001L
#define SQL_IS_INSERT_SEARCHED                  0x00000002L
#define SQL_IS_SELECT_INTO                      0x00000004L

/* SQL_ODBC_INTERFACE_CONFORMANCE values */
#define SQL_OIC_CORE                            1UL
#define SQL_OIC_LEVEL1                          2UL
#define SQL_OIC_LEVEL2                          3UL

/* SQL_SQL92_FOREIGN_KEY_DELETE_RULE bitmasks */
#define SQL_SFKD_CASCADE                        0x00000001L
#define SQL_SFKD_NO_ACTION                      0x00000002L
#define SQL_SFKD_SET_DEFAULT                    0x00000004L
#define SQL_SFKD_SET_NULL                       0x00000008L

/* SQL_SQL92_FOREIGN_KEY_UPDATE_RULE bitmasks */
#define SQL_SFKU_CASCADE                        0x00000001L
#define SQL_SFKU_NO_ACTION                      0x00000002L
#define SQL_SFKU_SET_DEFAULT                    0x00000004L
#define SQL_SFKU_SET_NULL                       0x00000008L

/* SQL_SQL92_GRANT  bitmasks */
#define SQL_SG_USAGE_ON_DOMAIN                  0x00000001L
#define SQL_SG_USAGE_ON_CHARACTER_SET           0x00000002L
#define SQL_SG_USAGE_ON_COLLATION               0x00000004L
#define SQL_SG_USAGE_ON_TRANSLATION             0x00000008L
#define SQL_SG_WITH_GRANT_OPTION                0x00000010L
#define SQL_SG_DELETE_TABLE                     0x00000020L
#define SQL_SG_INSERT_TABLE                     0x00000040L
#define SQL_SG_INSERT_COLUMN                    0x00000080L
#define SQL_SG_REFERENCES_TABLE                 0x00000100L
#define SQL_SG_REFERENCES_COLUMN                0x00000200L
#define SQL_SG_SELECT_TABLE                     0x00000400L
#define SQL_SG_UPDATE_TABLE                     0x00000800L
#define SQL_SG_UPDATE_COLUMN                    0x00001000L

/* SQL_SQL92_PREDICATES bitmasks */
#define SQL_SP_EXISTS                           0x00000001L
#define SQL_SP_ISNOTNULL                        0x00000002L
#define SQL_SP_ISNULL                           0x00000004L
#define SQL_SP_MATCH_FULL                       0x00000008L
#define SQL_SP_MATCH_PARTIAL                    0x00000010L
#define SQL_SP_MATCH_UNIQUE_FULL                0x00000020L
#define SQL_SP_MATCH_UNIQUE_PARTIAL             0x00000040L
#define SQL_SP_OVERLAPS                         0x00000080L
#define SQL_SP_UNIQUE                           0x00000100L
#define SQL_SP_LIKE                             0x00000200L
#define SQL_SP_IN                               0x00000400L
#define SQL_SP_BETWEEN                          0x00000800L
#define SQL_SP_COMPARISON                       0x00001000L
#define SQL_SP_QUANTIFIED_COMPARISON            0x00002000L

/* SQL_SQL92_RELATIONAL_JOIN_OPERATORS bitmasks */
#define SQL_SRJO_CORRESPONDING_CLAUSE           0x00000001L
#define SQL_SRJO_CROSS_JOIN                     0x00000002L
#define SQL_SRJO_EXCEPT_JOIN                    0x00000004L
#define SQL_SRJO_FULL_OUTER_JOIN                0x00000008L
#define SQL_SRJO_INNER_JOIN                     0x00000010L
#define SQL_SRJO_INTERSECT_JOIN                 0x00000020L
#define SQL_SRJO_LEFT_OUTER_JOIN                0x00000040L
#define SQL_SRJO_NATURAL_JOIN                   0x00000080L
#define SQL_SRJO_RIGHT_OUTER_JOIN               0x00000100L
#define SQL_SRJO_UNION_JOIN                     0x00000200L

/* SQL_SQL92_REVOKE bitmasks */
#define SQL_SR_USAGE_ON_DOMAIN                  0x00000001L
#define SQL_SR_USAGE_ON_CHARACTER_SET           0x00000002L
#define SQL_SR_USAGE_ON_COLLATION               0x00000004L
#define SQL_SR_USAGE_ON_TRANSLATION             0x00000008L
#define SQL_SR_GRANT_OPTION_FOR                 0x00000010L
#define SQL_SR_CASCADE                          0x00000020L
#define SQL_SR_RESTRICT                         0x00000040L
#define SQL_SR_DELETE_TABLE                     0x00000080L
#define SQL_SR_INSERT_TABLE                     0x00000100L
#define SQL_SR_INSERT_COLUMN                    0x00000200L
#define SQL_SR_REFERENCES_TABLE                 0x00000400L
#define SQL_SR_REFERENCES_COLUMN                0x00000800L
#define SQL_SR_SELECT_TABLE                     0x00001000L
#define SQL_SR_UPDATE_TABLE                     0x00002000L
#define SQL_SR_UPDATE_COLUMN                    0x00004000L

/* SQL_SQL92_ROW_VALUE_CONSTRUCTOR bitmasks */
#define SQL_SRVC_VALUE_EXPRESSION               0x00000001L
#define SQL_SRVC_NULL                           0x00000002L
#define SQL_SRVC_DEFAULT                        0x00000004L
#define SQL_SRVC_ROW_SUBQUERY                   0x00000008L

/* SQL_SQL92_VALUE_EXPRESSIONS bitmasks */
#define SQL_SVE_CASE                            0x00000001L
#define SQL_SVE_CAST                            0x00000002L
#define SQL_SVE_COALESCE                        0x00000004L
#define SQL_SVE_NULLIF                          0x00000008L

/* SQL_STANDARD_CLI_CONFORMANCE bitmasks */
#define SQL_SCC_XOPEN_CLI_VERSION1              0x00000001L
#define SQL_SCC_ISO92_CLI                       0x00000002L

/* SQL_UNION_STATEMENT bitmasks */
#define SQL_US_UNION                            SQL_U_UNION
#define SQL_US_UNION_ALL                        SQL_U_UNION_ALL
#endif  /* ODBCVER >= 0x0300 */

/* SQL_DTC_TRANSITION_COST bitmasks */
#define SQL_DTC_ENLIST_EXPENSIVE                0x00000001L
#define SQL_DTC_UNENLIST_EXPENSIVE              0x00000002L

#if (ODBCVER >= 0x0380)
// possible values for SQL_ASYNC_DBC_FUNCTIONS 
#define SQL_ASYNC_DBC_NOT_CAPABLE               0x00000000L
#define SQL_ASYNC_DBC_CAPABLE                   0x00000001L
#endif // ODBCVER >= 0x0380

/* additional SQLDataSources fetch directions */
#if (ODBCVER >= 0x0300)
#define SQL_FETCH_FIRST_USER                31
#define SQL_FETCH_FIRST_SYSTEM              32
#endif  /* ODBCVER >= 0x0300 */


/* Defines for SQLSetPos */
#define SQL_ENTIRE_ROWSET            0

/* Operations in SQLSetPos */
#define SQL_POSITION                 0               /*      1.0 FALSE */
#define SQL_REFRESH                  1               /*      1.0 TRUE */
#define SQL_UPDATE                   2
#define SQL_DELETE                   3

/* Operations in SQLBulkOperations */
#define SQL_ADD                      4
#define SQL_SETPOS_MAX_OPTION_VALUE         SQL_ADD
#if (ODBCVER >= 0x0300)
#define SQL_UPDATE_BY_BOOKMARK       5
#define SQL_DELETE_BY_BOOKMARK       6
#define SQL_FETCH_BY_BOOKMARK        7

#endif /*  ODBCVER >= 0x0300 */

/* Lock options in SQLSetPos */
#define SQL_LOCK_NO_CHANGE           0               /*      1.0 FALSE */
#define SQL_LOCK_EXCLUSIVE           1               /*      1.0 TRUE */
#define SQL_LOCK_UNLOCK              2

#define SQL_SETPOS_MAX_LOCK_VALUE       SQL_LOCK_UNLOCK

/* Macros for SQLSetPos */
#define SQL_POSITION_TO(hstmt,irow) SQLSetPos(hstmt,irow,SQL_POSITION,SQL_LOCK_NO_CHANGE)
#define SQL_LOCK_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_POSITION,fLock)
#define SQL_REFRESH_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_REFRESH,fLock)
#define SQL_UPDATE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_UPDATE,SQL_LOCK_NO_CHANGE)
#define SQL_DELETE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_DELETE,SQL_LOCK_NO_CHANGE)
#define SQL_ADD_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_ADD,SQL_LOCK_NO_CHANGE)

/* Column types and scopes in SQLSpecialColumns.  */
#define SQL_BEST_ROWID                  1
#define SQL_ROWVER                      2

/* Defines for SQLSpecialColumns (returned in the result set)
   SQL_PC_UNKNOWN and SQL_PC_PSEUDO are defined in sql.h */
#define SQL_PC_NOT_PSEUDO               1

/* Defines for SQLStatistics */
#define SQL_QUICK                       0
#define SQL_ENSURE                      1

/* Defines for SQLStatistics (returned in the result set)
   SQL_INDEX_CLUSTERED, SQL_INDEX_HASHED, and SQL_INDEX_OTHER are
   defined in sql.h */
#define SQL_TABLE_STAT                  0


/* Defines for SQLTables */
#if (ODBCVER >= 0x0300)
#define SQL_ALL_CATALOGS                "%"
#define SQL_ALL_SCHEMAS                 "%"
#define SQL_ALL_TABLE_TYPES             "%"
#endif  /* ODBCVER >= 0x0300 */

/* Options for SQLDriverConnect */
#define SQL_DRIVER_NOPROMPT             0
#define SQL_DRIVER_COMPLETE             1
#define SQL_DRIVER_PROMPT               2
#define SQL_DRIVER_COMPLETE_REQUIRED    3

#ifndef RC_INVOKED

SQLRETURN SQL_API SQLDriverConnect(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    __in_ecount(cchConnStrIn)
    SQLCHAR           *szConnStrIn,
    SQLSMALLINT        cchConnStrIn,
    __out_ecount_opt(cchConnStrOutMax)
    SQLCHAR           *szConnStrOut,
    SQLSMALLINT        cchConnStrOutMax,
    __out_opt
    SQLSMALLINT       *pcchConnStrOut,
    SQLUSMALLINT       fDriverCompletion);

#endif /* RC_INVOKED */

/* Level 2 Functions                             */

/* SQLExtendedFetch "fFetchType" values */
#define SQL_FETCH_BOOKMARK               8

/* SQLExtendedFetch "rgfRowStatus" element values */
#define SQL_ROW_SUCCESS                  0
#define SQL_ROW_DELETED                  1
#define SQL_ROW_UPDATED                  2
#define SQL_ROW_NOROW                    3
#define SQL_ROW_ADDED                    4
#define SQL_ROW_ERROR                    5
#if (ODBCVER >= 0x0300)
#define SQL_ROW_SUCCESS_WITH_INFO        6
#define SQL_ROW_PROCEED                  0
#define SQL_ROW_IGNORE                   1
#endif

/* value for SQL_DESC_ARRAY_STATUS_PTR */
#if (ODBCVER >= 0x0300)
#define SQL_PARAM_SUCCESS               0
#define SQL_PARAM_SUCCESS_WITH_INFO     6
#define SQL_PARAM_ERROR                 5
#define SQL_PARAM_UNUSED                7
#define SQL_PARAM_DIAG_UNAVAILABLE      1

#define SQL_PARAM_PROCEED               0
#define SQL_PARAM_IGNORE                1
#endif  /* ODBCVER >= 0x0300 */

/* Defines for SQLForeignKeys (UPDATE_RULE and DELETE_RULE) */
#define SQL_CASCADE                      0
#define SQL_RESTRICT                     1
#define SQL_SET_NULL                     2
#if (ODBCVER >= 0x0250)
#define SQL_NO_ACTION            3
#define SQL_SET_DEFAULT          4
#endif  /* ODBCVER >= 0x0250 */

#if (ODBCVER >= 0x0300)
/* Note that the following are in a different column of SQLForeignKeys than */
/* the previous #defines.   These are for DEFERRABILITY.                    */

#define SQL_INITIALLY_DEFERRED          5
#define SQL_INITIALLY_IMMEDIATE         6
#define SQL_NOT_DEFERRABLE          7

#endif  /* ODBCVER >= 0x0300 */

/* Defines for SQLBindParameter and
                           SQLProcedureColumns (returned in the result set) */
#define SQL_PARAM_TYPE_UNKNOWN              0
#define SQL_PARAM_INPUT                     1
#define SQL_PARAM_INPUT_OUTPUT              2
#define SQL_RESULT_COL                      3
#define SQL_PARAM_OUTPUT                    4
#define SQL_RETURN_VALUE                    5
#if (ODBCVER >= 0x0380)
    #define SQL_PARAM_INPUT_OUTPUT_STREAM   8
    #define SQL_PARAM_OUTPUT_STREAM         16
#endif

/* Defines for SQLProcedures (returned in the result set) */
#define SQL_PT_UNKNOWN                   0
#define SQL_PT_PROCEDURE                 1
#define SQL_PT_FUNCTION                  2

#ifndef RC_INVOKED

/*      This define is too large for RC */
#define SQL_ODBC_KEYWORDS \
"ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,"\
"ASC,ASSERTION,AT,AUTHORIZATION,AVG,"\
"BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,"\
"CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,"\
"COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,"\
"CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,"\
"CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,"\
"DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,"\
"DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,"\
"DISTINCT,DOMAIN,DOUBLE,DROP,"\
"ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,"\
"EXISTS,EXTERNAL,EXTRACT,"\
"FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,"\
"GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,"\
"IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,"\
"INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,"\
"JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,"\
"MATCH,MAX,MIN,MINUTE,MODULE,MONTH,"\
"NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,"\
"OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,"\
"PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,"\
"PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,"\
"READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWS"\
"SCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,"\
"SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,"\
"SUBSTRING,SUM,SYSTEM_USER,"\
"TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,"\
"TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,"\
"UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,"\
"VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,"\
"YEAR,ZONE"

SQLRETURN SQL_API SQLBrowseConnect(
    SQLHDBC            hdbc,
    __in_ecount(cchConnStrIn)
    SQLCHAR           *szConnStrIn,
    SQLSMALLINT        cchConnStrIn,
    __out_ecount_opt(cchConnStrOutMax)
    SQLCHAR           *szConnStrOut,
    SQLSMALLINT        cchConnStrOutMax,
    __out_opt
    SQLSMALLINT       *pcchConnStrOut);

#if (ODBCVER >= 0x0300)
SQLRETURN   SQL_API SQLBulkOperations(
    SQLHSTMT            StatementHandle,
    SQLSMALLINT         Operation);
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN SQL_API SQLColAttributes(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLUSMALLINT       fDescType,
    SQLPOINTER         rgbDesc,
    SQLSMALLINT        cbDescMax,
    SQLSMALLINT       *pcbDesc,
    SQLLEN            * pfDesc);

SQLRETURN SQL_API SQLColumnPrivileges(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName)
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName)
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName)
    SQLCHAR           *szTableName,
    SQLSMALLINT        cchTableName,
    __in_ecount_opt(cchColumnName)
    SQLCHAR           *szColumnName,
    SQLSMALLINT        cchColumnName);

SQLRETURN SQL_API SQLDescribeParam(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    __out_opt
    SQLSMALLINT       *pfSqlType,
    __out_opt
    SQLULEN           *pcbParamDef,
    __out_opt
    SQLSMALLINT       *pibScale,
    __out_opt
    SQLSMALLINT       *pfNullable);

SQLRETURN SQL_API SQLExtendedFetch(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fFetchType,
    SQLLEN             irow,
    __out_opt
    SQLULEN           *pcrow,
    __out_opt
    SQLUSMALLINT      *rgfRowStatus);

SQLRETURN SQL_API SQLForeignKeys(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchPkCatalogName)
    SQLCHAR           *szPkCatalogName,
    SQLSMALLINT        cchPkCatalogName,
    __in_ecount_opt(cchPkSchemaName)
    SQLCHAR           *szPkSchemaName,
    SQLSMALLINT        cchPkSchemaName,
    __in_ecount_opt(cchPkTableName)
    SQLCHAR           *szPkTableName,
    SQLSMALLINT        cchPkTableName,
    __in_ecount_opt(cchFkCatalogName)
    SQLCHAR           *szFkCatalogName,
    SQLSMALLINT        cchFkCatalogName,
    __in_ecount_opt(cchFkSchemaName)
    SQLCHAR           *szFkSchemaName,
    SQLSMALLINT        cchFkSchemaName,
    __in_ecount_opt(cchFkTableName)
    SQLCHAR           *szFkTableName,
    SQLSMALLINT        cchFkTableName);

SQLRETURN SQL_API SQLMoreResults(
    SQLHSTMT           hstmt);

SQLRETURN SQL_API SQLNativeSql
(
    SQLHDBC            hdbc,
    __in_ecount(cchSqlStrIn) SQLCHAR* szSqlStrIn,
    SQLINTEGER  cchSqlStrIn,
    __out_ecount_opt(cchSqlStrMax) SQLCHAR* szSqlStr,
    SQLINTEGER         cchSqlStrMax,
    SQLINTEGER        *pcbSqlStr
);

SQLRETURN SQL_API SQLNumParams(
    SQLHSTMT           hstmt,
    __out_opt
    SQLSMALLINT       *pcpar);

SQLRETURN SQL_API SQLParamOptions(
    SQLHSTMT           hstmt,
    SQLULEN            crow,
    SQLULEN            *pirow);

SQLRETURN SQL_API SQLPrimaryKeys(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName)
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName)
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName)
    SQLCHAR           *szTableName,
    SQLSMALLINT        cchTableName);

SQLRETURN SQL_API SQLProcedureColumns(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName)
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName)
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchProcName)
    SQLCHAR           *szProcName,
    SQLSMALLINT        cchProcName,
    __in_ecount_opt(cchColumnName)
    SQLCHAR           *szColumnName,
    SQLSMALLINT        cchColumnName);

SQLRETURN SQL_API SQLProcedures(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName)
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName)
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchProcName)
    SQLCHAR           *szProcName,
    SQLSMALLINT        cchProcName);



SQLRETURN SQL_API SQLSetPos(
    SQLHSTMT           hstmt,
    SQLSETPOSIROW      irow,
    SQLUSMALLINT       fOption,
    SQLUSMALLINT       fLock);

SQLRETURN SQL_API SQLTablePrivileges(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName)
    SQLCHAR           *szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName)
    SQLCHAR           *szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName)
    SQLCHAR           *szTableName,
    SQLSMALLINT        cchTableName);

SQLRETURN SQL_API SQLDrivers(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    __out_ecount_opt(cchDriverDescMax)
    SQLCHAR           *szDriverDesc,
    SQLSMALLINT        cchDriverDescMax,
    __out_opt
    SQLSMALLINT       *pcchDriverDesc,
    __out_ecount_opt(cchDrvrAttrMax)
    SQLCHAR           *szDriverAttributes,
    SQLSMALLINT        cchDrvrAttrMax,
    __out_opt
    SQLSMALLINT       *pcchDrvrAttr);

SQLRETURN SQL_API SQLBindParameter(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT        fParamType,
    SQLSMALLINT        fCType,
    SQLSMALLINT        fSqlType,
    SQLULEN            cbColDef,
    SQLSMALLINT        ibScale,
    SQLPOINTER         rgbValue,
    SQLLEN             cbValueMax,
    SQLLEN             *pcbValue);


#endif /* RC_INVOKED */

/*---------------------------------------------------------*/
/* SQLAllocHandleStd is implemented to make SQLAllocHandle */
/* compatible with X/Open standard.  an application should */
/* not call SQLAllocHandleStd directly                     */
/*---------------------------------------------------------*/
#ifdef ODBC_STD
#define SQLAllocHandle  SQLAllocHandleStd
#define SQLAllocEnv(phenv)  SQLAllocHandleStd(SQL_HANDLE_ENV, SQL_NULL_HANDLE, phenv)

/* Internal type subcodes */
#define SQL_YEAR                        SQL_CODE_YEAR
#define SQL_MONTH                       SQL_CODE_MONTH
#define SQL_DAY                         SQL_CODE_DAY
#define SQL_HOUR                        SQL_CODE_HOUR
#define SQL_MINUTE                      SQL_CODE_MINUTE
#define SQL_SECOND                      SQL_CODE_SECOND
#define SQL_YEAR_TO_MONTH               SQL_CODE_YEAR_TO_MONTH
#define SQL_DAY_TO_HOUR                 SQL_CODE_DAY_TO_HOUR
#define SQL_DAY_TO_MINUTE               SQL_CODE_DAY_TO_MINUTE
#define SQL_DAY_TO_SECOND               SQL_CODE_DAY_TO_SECOND
#define SQL_HOUR_TO_MINUTE              SQL_CODE_HOUR_TO_MINUTE
#define SQL_HOUR_TO_SECOND              SQL_CODE_HOUR_TO_SECOND
#define SQL_MINUTE_TO_SECOND            SQL_CODE_MINUTE_TO_SECOND
#endif /* ODBC_STD */

#if (ODBCVER >= 0x0300)
#ifndef RC_INVOKED
SQLRETURN SQL_API SQLAllocHandleStd(
    SQLSMALLINT     fHandleType,
    SQLHANDLE       hInput,
    __out
    SQLHANDLE      *phOutput);
#endif /* RC_INVOKED */
#endif

/*      Deprecated defines from prior versions of ODBC */
#define SQL_DATABASE_NAME               16    /* Use SQLGetConnectOption/SQL_CURRENT_QUALIFIER */
#define SQL_FD_FETCH_PREV               SQL_FD_FETCH_PRIOR
#define SQL_FETCH_PREV                  SQL_FETCH_PRIOR
#define SQL_CONCUR_TIMESTAMP            SQL_CONCUR_ROWVER
#define SQL_SCCO_OPT_TIMESTAMP          SQL_SCCO_OPT_ROWVER
#define SQL_CC_DELETE                   SQL_CB_DELETE
#define SQL_CR_DELETE                   SQL_CB_DELETE
#define SQL_CC_CLOSE                    SQL_CB_CLOSE
#define SQL_CR_CLOSE                    SQL_CB_CLOSE
#define SQL_CC_PRESERVE                 SQL_CB_PRESERVE
#define SQL_CR_PRESERVE                 SQL_CB_PRESERVE
/* SQL_FETCH_RESUME is not supported by 2.0+ drivers
#define SQL_FETCH_RESUME                7
*/
#define SQL_SCROLL_FORWARD_ONLY         0L    /*-SQL_CURSOR_FORWARD_ONLY */
#define SQL_SCROLL_KEYSET_DRIVEN        (-1L) /*-SQL_CURSOR_KEYSET_DRIVEN */
#define SQL_SCROLL_DYNAMIC              (-2L) /*-SQL_CURSOR_DYNAMIC */
#define SQL_SCROLL_STATIC               (-3L) /*-SQL_CURSOR_STATIC */

/*      Deprecated functions from prior versions of ODBC */
#ifndef RC_INVOKED

SQLRETURN SQL_API SQLSetScrollOptions(    /*      Use SQLSetStmtOptions */
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fConcurrency,
    SQLLEN             crowKeyset,
    SQLUSMALLINT       crowRowset);

/* Tracing section */

#define     TRACE_VERSION   1000        /* Version of trace API */

// open a trace log file
RETCODE SQL_API TraceOpenLogFile
(
    __in_opt                        LPWSTR szFileName,
    __out_bcount_opt(cbOutputMsg)   LPWSTR lpwszOutputMsg,
    __in                            DWORD  cbOutputMsg
);

RETCODE SQL_API TraceCloseLogFile();            // Request to close a trace log
VOID    SQL_API TraceReturn(RETCODE,RETCODE);   // Processes trace after FN is called
DWORD   SQL_API TraceVersion();                 // Returns trace API version

/* Functions for Visual Studio Analyzer*/
/* to turn on/off tracing or VS events, call TraceVSControl by setting or clearing the following bits  */
#define TRACE_ON            0x00000001L
#define TRACE_VS_EVENT_ON   0x00000002L

RETCODE SQL_API TraceVSControl(DWORD);

/* Functions for setting the connection pooling failure detection code */
/* The "TryWait" value is the time (in seconds) that the DM will wait  */
/* between detecting that a connection is dead (using                  */
/* SQL_ATTR_CONNECTION_DEAD) and retrying the connection.  During that */
/* interval, connection requests will get "The server appears to be    */
/* dead" error returns.                                                */


BOOL SQL_API    ODBCSetTryWaitValue(DWORD dwValue); /* In seconds */
DWORD SQL_API   ODBCGetTryWaitValue();          /* In Milliseconds(!) */


/* the flags in ODBC_VS_ARGS */
#define ODBC_VS_FLAG_UNICODE_ARG    0x00000001L /* the argument is unicode */
#define ODBC_VS_FLAG_UNICODE_COR    0x00000002L /* the correlation is unicode */
#define ODBC_VS_FLAG_RETCODE        0x00000004L /* RetCode field is set */
#define ODBC_VS_FLAG_STOP       0x00000008L /* Stop firing visual studio analyzer events */

typedef struct tagODBC_VS_ARGS {
    const GUID  *pguidEvent;    /* the GUID for event */
    DWORD   dwFlags;        /* flags for the call */
    union {
        WCHAR   *wszArg;
        CHAR    *szArg;
    };
    union {
        WCHAR   *wszCorrelation;
        CHAR    *szCorrelation;
    };
    RETCODE RetCode;
} ODBC_VS_ARGS, *PODBC_VS_ARGS;
VOID    SQL_API FireVSDebugEvent(PODBC_VS_ARGS);

#endif /* RC_INVOKED */


#ifdef __cplusplus
}                                     /* End of extern "C" { */
#endif  /* __cplusplus */

#if defined(WIN32) || defined(_WIN64)
#include "sqlucode.h"
#endif

#endif /* __SQLEXT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SspGuid.h ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    sspguid

Abstract:

    CLSID definitions from the scardssp project.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _SSPGUID_H_
#define _SSPGUID_H_

#define IID_DEFINED

#include "scardssp_i.c"

#ifndef CLSCTX_LOCAL
#define CLSCTX_LOCAL            (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)
#endif

#endif // _SSPGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SspsErr.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SspsErr

Abstract:

    This header file describes the error codes that are generated by
    the Microsoft Smartcard Service Provider (SSP).

Author:

    Michael Gallagher (a-mgalla) 10/21/1996

Environment:

    Win32

Revision History:

    Mike Gallagher (a-mgalla) 12/19/1996

Notes:

--*/


#ifndef __SSPSERR_H__
#define __SSPSERR_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef SCARD_S_SUCCESS
#include "scarderr.h"
#endif
#ifdef _DEBUG
#pragma message("sspserr.h is obsolete.")
#endif


/////////////////////////////////////////////////////////////////////////////

#endif  // __SSPSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\stgprop.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:       stgprop.h
//
//  Contents:   Standard storage provider property definitions;
//
//  History:    Jul-9-93       robertfe
//
//----------------------------------------------------------------------------

#ifndef _STGPROP_H_
#define _STGPROP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define PSGUID_STORAGE  { 0xb725f130,           \
                          0x47ef, 0x101a,       \
                          { 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac } }

//#define PID_STG_DICTIONARY            ((PROPID) 0x00000000) //reserved
//#define PID_STG_CODEPAGE              ((PROPID) 0x00000001) //reserved

#define PID_STG_DIRECTORY               ((PROPID) 0x00000002)

#define PID_STG_CLASSID                 ((PROPID) 0x00000003)
#define PID_STG_STORAGETYPE             ((PROPID) 0x00000004)

#define PID_STG_VOLUME_ID               ((PROPID) 0x00000005)
#define PID_STG_PARENT_WORKID           ((PROPID) 0x00000006)
#define PID_STG_SECONDARYSTORE          ((PROPID) 0x00000007)

#define PID_STG_FILEINDEX               ((PROPID) 0x00000008)
#define PID_STG_LASTCHANGEUSN           ((PROPID) 0x00000009)
#define PID_STG_NAME                    ((PROPID) 0x0000000a)
#define PID_STG_PATH                    ((PROPID) 0x0000000b)

#define PID_STG_SIZE                    ((PROPID) 0x0000000c)
#define PID_STG_ATTRIBUTES              ((PROPID) 0x0000000d)
#define PID_STG_WRITETIME               ((PROPID) 0x0000000e)
#define PID_STG_CREATETIME              ((PROPID) 0x0000000f)
#define PID_STG_ACCESSTIME              ((PROPID) 0x00000010)
#define PID_STG_CHANGETIME              ((PROPID) 0x00000011)
#define PID_STG_ALLOCSIZE               ((PROPID) 0x00000012)

#define PID_STG_CONTENTS                ((PROPID) 0x00000013)
#define PID_STG_SHORTNAME               ((PROPID) 0x00000014)

#define PID_STG_FRN                     ((PROPID) 0x00000015)
#define PID_STG_SCOPE                   ((PROPID) 0x00000016)

#define PID_STG_MAX                     PID_STG_SCOPE

#define CSTORAGEPROPERTY                0x17

#endif _STGPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\SspsIdl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       sspsidl.h
//
//--------------------------------------------------------------------------

#include "scardssp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\statusdeviceservice.h ===
/*
 *  StatusDeviceService.h
 *
 *  Contains definitions of the Status Device Service
 *
 *  Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

#ifndef _STATUSDEVICESERVICE_H_
#define _STATUSDEVICESERVICE_H_

#include <DeviceServices.h>

/*****************************************************************************/
/*  Status Service Info                                                      */
/*****************************************************************************/

DEFINE_DEVSVCGUID(SERVICE_Status,
    0x0B9F1048, 0xB94B, 0xDC9A, 0x4e, 0xd7, 0xfe, 0x4f, 0xed, 0x3a, 0x0d, 0xeb);

#define NAME_StatusSvc                      L"Status"
#define TYPE_StatusSvc                      DEVSVCTYPE_DEFAULT

/*****************************************************************************/
/*  Status Service Property Keys                                             */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_StatusSvc,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13);


/*  PKEY_StatusSvc_SignalStrength
 *
 *  Signal strength in "bars" from 0 (no signal) to 4 (excellent signal)
 *
 *  Type: UInt8
 *  Form: Range
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_SignalStrength,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    2);

#define NAME_StatusSvc_SignalStrength       L"SignalStrength"

#define RANGEMIN_StatusSvc_SignalStrength   0
#define RANGEMAX_StatusSvc_SignalStrength   4
#define RANGESTEP_StatusSvc_SignalStrength  1

/*  PKEY_StatusSvc_TextMessages
 *
 *  Number of unread text messages (255 max)
 *
 *  Type: UInt8
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_TextMessages,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    3);

#define NAME_StatusSvc_TextMessages         L"TextMessages"
#define RANGEMAX_StatusSvc_TextMessages     255

/*  PKEY_StatusSvc_NewPictures
 *
 *  Number of "new" pictures on the device (65535 max)
 *
 *  Type: UInt16
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_NewPictures,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    4);

#define NAME_StatusSvc_NewPictures          L"NewPictures"
#define RANGEMAX_StatusSvc_NewPictures      65535

/*  PKEY_StatusSvc_MissedCalls
 *
 *  Number of missed calls on the device (255 max)
 *
 *  Type: UInt8
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_MissedCalls,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    5);

#define NAME_StatusSvc_MissedCalls          L"MissedCalls"
#define RANGEMAX_StatusSvc_MissedCalls      255


/*  PKEY_StatusSvc_VoiceMail
 *
 *  Number of "available" voice mail messages (255 max)
 *
 *  Type: UInt8
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_VoiceMail,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    6);

#define NAME_StatusSvc_VoiceMail            L"VoiceMail"
#define RANGEMAX_StatusSvc_VoiceMail        255


/*  PKEY_StatusSvc_NetworkName
 *
 *  Network provider network name
 *
 *  Type: String
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_NetworkName,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    7);

#define NAME_StatusSvc_NetworkName          L"NetworkName"


/*  PKEY_StatusSvc_NetworkType
 *
 *  Network "type" (e.g. GPRS, EDGE, UMTS, 1xRTT, EVDO, or operator branded)
 *
 *  Type: String
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_NetworkType,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    8);

#define NAME_StatusSvc_NetworkType          L"NetworkType"


/*  PKEY_StatusSvc_Roaming
 *
 *  Current network roaming state
 *
 *  Type: UInt8
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_Roaming,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    9);

#define NAME_StatusSvc_Roaming              L"Roaming"

#define ENUM_StatusSvc_RoamingInactive      0x00
#define ENUM_StatusSvc_RoamingActive        0x01
#define ENUM_StatusSvc_RoamingUnknown       0x02


/*  PKEY_StatusSvc_BatteryLife
 *
 *  Remaining battery life on the device as a percentage between 100 and 0.
 *
 *  Type: UInt8
 *  Form: Range
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_BatteryLife,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    10);

#define NAME_StatusSvc_BatteryLife          L"BatteryLife"

#define RANGEMIN_StatusSvc_BatteryLife      0
#define RANGEMAX_StatusSvc_BatteryLife      100
#define RANGESTEP_StatusSvc_BatteryLife     1


/*  PKEY_StatusSvc_ChargingState
 *
 *  Current charging state of the device
 *
 *  Type: UInt8
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_ChargingState,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    11);

#define NAME_StatusSvc_ChargingState        L"ChargingState"

#define ENUM_StatusSvc_ChargingInactive     0x00
#define ENUM_StatusSvc_ChargingActive       0x01
#define ENUM_StatusSvc_ChargingUnknown      0x02


/*  PKEY_StatusSvc_StorageCapacity
 *
 *  Total storage capacity on the device (across all storages)
 *
 *  Type: UInt64
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_StorageCapacity,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    12);

#define NAME_StatusSvc_StorageCapacity      L"StorageCapacity"


/*  PKEY_StatusSvc_StorageFreeSpace
 *
 *  Total free storage capacity on the device (across all storages)
 *
 *  Type: UInt64
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_StatusSvc_StorageFreeSpace,
    0x49cd1f76, 0x5626, 0x4b17, 0xa4, 0xe8, 0x18, 0xb4, 0xaa, 0x1a, 0x22, 0x13,
    13);

#define NAME_StatusSvc_StorageFreeSpace     L"StorageFreeSpace"

#endif  /* _STATUSDEVICESERVICE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sqloledb.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Provider for SQL Server
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module SQLOLEDB.H | Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _SQLOLEDB_H_
#define  _SQLOLEDB_H_

#ifndef	 __oledb_h__
#include "oledb.h"
#endif	/* __oledb_h__	*/

//----------------------------------------------------------------------------
// Provider-specific Class Ids
// Provider CLSID 		{0C7FF16C-38E3-11d0-97AB-00C04FC2AD98}
extern const GUID OLEDBDECLSPEC CLSID_SQLOLEDB          = {0xc7ff16cL,0x38e3,0x11d0,0x97,0xab,0x0,0xc0,0x4f,0xc2,0xad,0x98};
// Error Lookup CLSID 		{C0932C62-38E5-11d0-97AB-00C04FC2AD98}
extern const GUID OLEDBDECLSPEC CLSID_SQLOLEDB_ERROR    = {0xc0932c62L,0x38e5,0x11d0,0x97,0xab,0x0,0xc0,0x4f,0xc2,0xad,0x98};
// Enumerator CLSID 		{DFA22B8E-E68D-11d0-97E4-00C04FC2AD98}
extern const GUID OLEDBDECLSPEC CLSID_SQLOLEDB_ENUMERATOR = {0xdfa22b8eL,0xe68d,0x11d0,0x97,0xe4,0x0,0xc0,0x4f,0xc2,0xad,0x98};

//----------------------------------------------------------------------------
// Provider-specific Interface Ids
extern const GUID OLEDBDECLSPEC IID_ISQLServerErrorInfo = {0x5cf4ca12,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC IID_IRowsetFastLoad     = {0x5cf4ca13,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC IID_IUMSInitialize      = {0x5cf4ca14,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
// {4C2389FB-2511-11d4-B258-00C04F7971CE}
extern const GUID OLEDBDECLSPEC IID_ISchemaLock         = {0x4c2389fb,0x2511,0x11d4,0xb2,0x58,0x0,0xc0,0x4f,0x79,0x71,0xce};
extern const GUID OLEDBDECLSPEC DBGUID_MSSQLXML         = {0x5d531cb2L,0xe6ed,0x11d2,0xb2,0x52,0x00,0xc0,0x4f,0x68,0x1b,0x71};
extern const GUID OLEDBDECLSPEC DBGUID_XPATH            = {0xec2a4293L,0xe898,0x11d2,0xb1,0xb7,0x00,0xc0,0x4f,0x68,0x0c,0x56};
// This IID_ICommandStream definition is available in later versions of 
// UUID.LIB.  It is also already an extern defined in oledb.h.
//
#if _MSC_VER < 1300
extern const GUID OLEDBDECLSPEC IID_ICommandStream      = {0x0c733abfL,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d};
#endif // _MSC_VER
extern const GUID OLEDBDECLSPEC IID_ISQLXMLHelper       = {0xd22a7678L,0xf860,0x40cd,0xa5,0x67,0x15,0x63,0xde,0xb4,0x6d,0x49};

//----------------------------------------------------------------------------
// Provider-specific schema rowsets
extern const GUID OLEDBDECLSPEC DBSCHEMA_LINKEDSERVERS  = {0x9093caf4,0x2eac,0x11d1,0x98,0x9,0x0,0xc0,0x4f,0xc2,0xad,0x98};

//----------------------------------------------------------------------------
// Provider-specific property sets
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDATASOURCE = {0x28efaee4,0x2d2c,0x11d1,0x98,0x7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDATASOURCEINFO = {0xdf10cb94,0x35f6,0x11d2,0x9c,0x54,0x0,0xc0,0x4f,0x79,0x71,0xd3};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDBINIT   = {0x5cf4ca10,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERROWSET   = {0x5cf4ca11,0xef21,0x11d0,0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERSESSION  = {0x28efaee5,0x2d2c,0x11d1,0x98,0x7,0x0,0xc0,0x4f,0xc2,0xad,0x98};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERCOLUMN   = {0x3b63fb5e,0x3fbb,0x11d3,0x9f,0x29,0x0,0xc0,0x4f,0x8e,0xe9,0xdc};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERSTREAM   = {0x9f79c073,0x8a6d,0x4bca,0xa8,0xa8,0xc9,0xb7,0x9a,0x9b,0x96,0x2d};

//----------------------------------------------------------------------------
// Provider-specific columns for IColumnsRowset
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_COMPFLAGS       = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)100};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_SORTID          = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)101};
extern const DBID OLEDBDECLSPEC DBCOLUMN_BASETABLEINSTANCE  = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)102};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_TDSCOLLATION    = {0x627bd890,0xed54,0x11d2,0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c, DBKIND_GUID_PROPID, (LPOLESTR)103};

#define CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS	1

//----------------------------------------------------------------------------
// PropIds for DBPROP_INIT_GENERALTIMEOUT
#if ( OLEDBVER == 0x0210 )
#define DBPROP_INIT_GENERALTIMEOUT		0x11cL
#endif

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDATASOURCE
#define SSPROP_ENABLEFASTLOAD			2

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDATASOURCEINFO
#define SSPROP_UNICODELCID				2
#define SSPROP_UNICODECOMPARISONSTYLE	3
#define SSPROP_COLUMNLEVELCOLLATION     4
#define SSPROP_CHARACTERSET				5
#define	SSPROP_SORTORDER				6
#define SSPROP_CURRENTCOLLATION			7
//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDBINIT 
#define SSPROP_INIT_CURRENTLANGUAGE		4
#define SSPROP_INIT_NETWORKADDRESS		5
#define SSPROP_INIT_NETWORKLIBRARY		6
#define SSPROP_INIT_USEPROCFORPREP		7
#define SSPROP_INIT_AUTOTRANSLATE		8
#define SSPROP_INIT_PACKETSIZE			9
#define SSPROP_INIT_APPNAME			10
#define SSPROP_INIT_WSID			11
#define SSPROP_INIT_FILENAME			12
#define SSPROP_INIT_ENCRYPT             13 
#define SSPROP_AUTH_REPL_SERVER_NAME	14
#define SSPROP_INIT_TAGCOLUMNCOLLATION	15

//-----------------------------------------------------------------------------
// Values for SSPROP_USEPROCFORPREP
#define SSPROPVAL_USEPROCFORPREP_OFF		0
#define SSPROPVAL_USEPROCFORPREP_ON			1
#define SSPROPVAL_USEPROCFORPREP_ON_DROP	2

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERSESSION
#define SSPROP_QUOTEDCATALOGNAMES		2
#define SSPROP_ALLOWNATIVEVARIANT		3
#define SSPROP_SQLXMLXPROGID			4

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERROWSET 
#define SSPROP_MAXBLOBLENGTH			8
#define SSPROP_FASTLOADOPTIONS			9
#define SSPROP_FASTLOADKEEPNULLS		10
#define SSPROP_FASTLOADKEEPIDENTITY		11
#define SSPROP_CURSORAUTOFETCH			12
#define SSPROP_DEFERPREPARE				13
#define SSPROP_IRowsetFastLoad			14

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERCOLUMN
#define SSPROP_COL_COLLATIONNAME		14

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERSTREAM
#define SSPROP_STREAM_MAPPINGSCHEMA     15
#define SSPROP_STREAM_XSL               16
#define SSPROP_STREAM_BASEPATH          17
#define SSPROP_STREAM_COMMANDTYPE       18
#define SSPROP_STREAM_XMLROOT           19
#define SSPROP_STREAM_FLAGS             20
#define SSPROP_STREAM_CONTENTTYPE       23

//----------------------------------------------------------------------------
// Possible values for SSPROP_STREAM_FLAGS
#define STREAM_FLAGS_DISALLOW_URL           0x00000001
#define STREAM_FLAGS_DISALLOW_ABSOLUTE_PATH 0x00000002
#define STREAM_FLAGS_DISALLOW_QUERY         0x00000004
#define STREAM_FLAGS_DONTCACHEMAPPINGSCHEMA 0x00000008
#define STREAM_FLAGS_DONTCACHETEMPLATE      0x00000010
#define STREAM_FLAGS_DONTCACHEXSL           0x00000020
#define STREAM_FLAGS_DISALLOW_UPDATEGRAMS   0x00000040
#define STREAM_FLAGS_RESERVED               0xffff0000

// Values for SSPROPVAL_COMMANDTYPE

#define SSPROPVAL_COMMANDTYPE_REGULAR   21
#define SSPROPVAL_COMMANDTYPE_BULKLOAD  22

//-------------------------------------------------------------------
// Variant Access macros, similar to ole automation.
//-------------------------------------------------------------------

#define V_SS_VT(X)         ((X)->vt)
#define V_SS_UNION(X, Y)   ((X)->Y)

#define V_SS_UI1(X)				V_SS_UNION(X, bTinyIntVal)
#define V_SS_I2(X)				V_SS_UNION(X, sShortIntVal)
#define V_SS_I4(X)				V_SS_UNION(X, lIntVal)
#define V_SS_I8(X)				V_SS_UNION(X, llBigIntVal)

#define V_SS_R4(X)				V_SS_UNION(X, fltRealVal)
#define V_SS_R8(X)				V_SS_UNION(X, dblFloatVal)
#define V_SS_UI4(X)			    V_SS_UNION(X, ulVal)

#define V_SS_MONEY(X)			V_SS_UNION(X, cyMoneyVal)
#define V_SS_SMALLMONEY(X)		V_SS_UNION(X, cyMoneyVal)

#define V_SS_WSTRING(X)			V_SS_UNION(X, NCharVal)
#define V_SS_WVARSTRING(X)		V_SS_UNION(X, NCharVal)

#define V_SS_STRING(X)			V_SS_UNION(X, CharVal)
#define V_SS_VARSTRING(X)		V_SS_UNION(X, CharVal)

#define V_SS_BIT(X)				V_SS_UNION(X, fBitVal)
#define V_SS_GUID(X)			V_SS_UNION(X, rgbGuidVal)

#define V_SS_NUMERIC(X)			V_SS_UNION(X, numNumericVal)
#define V_SS_DECIMAL(X)			V_SS_UNION(X, numNumericVal)

#define V_SS_BINARY(X)			V_SS_UNION(X, BinaryVal)
#define V_SS_VARBINARY(X)		V_SS_UNION(X, BinaryVal)

#define V_SS_DATETIME(X)		V_SS_UNION(X, tsDateTimeVal)
#define V_SS_SMALLDATETIME(X)	V_SS_UNION(X, tsDateTimeVal)

#define V_SS_UNKNOWN(X)	V_SS_UNION(X, UnknownType)

//For next release.
#define V_SS_IMAGE(X)	V_SS_UNION(X, ImageVal)
#define V_SS_TEXT(X)	V_SS_UNION(X, TextVal)
#define V_SS_NTEXT(X)	V_SS_UNION(X, NTextVal)

//-------------------------------------------------------------------
// define SQL Server Spefific Variant Type
//-------------------------------------------------------------------
#define DBTYPE_SQLVARIANT   144

enum SQLVARENUM
    {	
	VT_SS_EMPTY = DBTYPE_EMPTY,
	VT_SS_NULL = DBTYPE_NULL,
	VT_SS_UI1 = DBTYPE_UI1,
	VT_SS_I2 = DBTYPE_I2,
	VT_SS_I4 = DBTYPE_I4,
	VT_SS_I8 = DBTYPE_I8,

	//Floats
	VT_SS_R4  = DBTYPE_R4,
	VT_SS_R8 = DBTYPE_R8,

	//Money
	VT_SS_MONEY = DBTYPE_CY,
	VT_SS_SMALLMONEY  = 200,
	
	//Strings
	VT_SS_WSTRING		= 201,
	VT_SS_WVARSTRING	= 202,
	
	VT_SS_STRING	=203,
	VT_SS_VARSTRING	=204,
	
	//Bit
	VT_SS_BIT		=DBTYPE_BOOL,
	
	//Guid
	VT_SS_GUID		=DBTYPE_GUID,

	//Exact precision
	VT_SS_NUMERIC	=DBTYPE_NUMERIC,
	VT_SS_DECIMAL	=205,

	//Datetime
	VT_SS_DATETIME		= DBTYPE_DBTIMESTAMP,
	VT_SS_SMALLDATETIME =206,

	//Binary
	VT_SS_BINARY =207,
	VT_SS_VARBINARY =208,
	//Future
	VT_SS_UNKNOWN	= 209,
    };

typedef unsigned short SSVARTYPE;


//Hungarian : ssv (Sql Server Variant)
struct SSVARIANT
	{
		SSVARTYPE vt;
		DWORD dwReserved1;
		DWORD dwReserved2;
        union 
            {
			BYTE bTinyIntVal;
			SHORT sShortIntVal;
            LONG lIntVal;
            LONGLONG llBigIntVal;
            
            FLOAT fltRealVal;
            DOUBLE dblFloatVal;
			
			CY cyMoneyVal;

			struct _NCharVal
				{
				SHORT sActualLength;
				SHORT sMaxLength;
				WCHAR * pwchNCharVal;
				BYTE rgbReserved[5];
				DWORD dwReserved;
				WCHAR * pwchReserved;
				} NCharVal;


			struct _CharVal
				{
				SHORT sActualLength;
				SHORT sMaxLength;
				CHAR  * pchCharVal;
				BYTE rgbReserved[5];
				DWORD dwReserved;
				WCHAR * pwchReserved;
				} CharVal;
			
			VARIANT_BOOL  fBitVal;
			BYTE  rgbGuidVal [16];
			
			DB_NUMERIC numNumericVal;		

			struct _BinaryVal
				{
				SHORT sActualLength;
				SHORT sMaxLength;
				BYTE  * prgbBinaryVal;
				DWORD dwReserved;
				} BinaryVal;

			DBTIMESTAMP  tsDateTimeVal;

			struct _UnknownType
				{
				DWORD dwActualLength;
				BYTE rgMetadata [16];
				BYTE * pUnknownData;					
				} UnknownType;
				            
			struct _BLOBType
				{
				DBOBJECT dbobj;
				IUnknown * pUnk; 
				} BLOBType;
			};

    };


#if defined(__cplusplus) && !defined(CINTERFACE)

//-----------------------------------------------------------------
// Class Factory Interface used to initialize pointer to UMS. 
//
interface IUMSInitialize : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Initialize (VOID * pUMS) = 0;
};


//-----------------------------------------------------------------
// Interface used to communicate with UMS.
//
interface IUMS
{
public:
    virtual VOID STDMETHODCALLTYPE SqlUmsSuspend (ULONG ticks) = 0;
	virtual VOID STDMETHODCALLTYPE SqlUmsYield (ULONG ticks) = 0;
	virtual VOID STDMETHODCALLTYPE SqlUmsSwitchPremptive () = 0;
	virtual VOID STDMETHODCALLTYPE SqlUmsSwitchNonPremptive() = 0;
	virtual BOOL STDMETHODCALLTYPE SqlUmsFIsPremptive() = 0;
};

#endif

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue May 09 16:41:59 2000
 */
/* Compiler settings for sqloledb.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sqloledb_h__
#define __sqloledb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISQLServerErrorInfo_FWD_DEFINED__
#define __ISQLServerErrorInfo_FWD_DEFINED__
typedef interface ISQLServerErrorInfo ISQLServerErrorInfo;
#endif 	/* __ISQLServerErrorInfo_FWD_DEFINED__ */


#ifndef __IRowsetFastLoad_FWD_DEFINED__
#define __IRowsetFastLoad_FWD_DEFINED__
typedef interface IRowsetFastLoad IRowsetFastLoad;
#endif 	/* __IRowsetFastLoad_FWD_DEFINED__ */


#ifndef __ISchemaLock_FWD_DEFINED__
#define __ISchemaLock_FWD_DEFINED__
typedef interface ISchemaLock ISchemaLock;
#endif 	/* __ISchemaLock_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"


__bcount_opt(size)
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t size);
void __RPC_USER MIDL_user_free(__inout void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_sqloledb_0000
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


// the structure returned by  ISQLServerErrorInfo::GetSQLServerInfo
typedef struct  tagSSErrorInfo
    {
    LPOLESTR pwszMessage;
    LPOLESTR pwszServer;
    LPOLESTR pwszProcedure;
    LONG lNative;
    BYTE bState;
    BYTE bClass;
    WORD wLineNumber;
    }	SSERRORINFO;



extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0000_v0_0_s_ifspec;

#ifndef __ISQLServerErrorInfo_INTERFACE_DEFINED__
#define __ISQLServerErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLServerErrorInfo
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_ISQLServerErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA12-EF21-11d0-97E7-00C04FC2AD98")
    ISQLServerErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ SSERRORINFO __RPC_FAR *__RPC_FAR *ppErrorInfo,
            __deref_out
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLServerErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISQLServerErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISQLServerErrorInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISQLServerErrorInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            ISQLServerErrorInfo __RPC_FAR * This,
            /* [out] */ SSERRORINFO __RPC_FAR *__RPC_FAR *ppErrorInfo,
            __deref_out
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer);
        
        END_INTERFACE
    } ISQLServerErrorInfoVtbl;

    interface ISQLServerErrorInfo
    {
        CONST_VTBL struct ISQLServerErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLServerErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLServerErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLServerErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLServerErrorInfo_GetErrorInfo(This,ppErrorInfo,ppStringsBuffer)	\
    (This)->lpVtbl -> GetErrorInfo(This,ppErrorInfo,ppStringsBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISQLServerErrorInfo_GetErrorInfo_Proxy( 
    ISQLServerErrorInfo __RPC_FAR * This,
    /* [out] */ SSERRORINFO __RPC_FAR *__RPC_FAR *ppErrorInfo,
    __deref_out
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer);


void __RPC_STUB ISQLServerErrorInfo_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLServerErrorInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_sqloledb_0006
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 

#ifdef _WIN64
typedef ULONG_PTR HACCESSOR;
#else
typedef ULONG HACCESSOR;
#endif


extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0006_v0_0_s_ifspec;

#ifndef __IRowsetFastLoad_INTERFACE_DEFINED__
#define __IRowsetFastLoad_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetFastLoad
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_IRowsetFastLoad;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA13-EF21-11d0-97E7-00C04FC2AD98")
    IRowsetFastLoad : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertRow( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fDone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetFastLoadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowsetFastLoad __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowsetFastLoad __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowsetFastLoad __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertRow )( 
            IRowsetFastLoad __RPC_FAR * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IRowsetFastLoad __RPC_FAR * This,
            /* [in] */ BOOL fDone);
        
        END_INTERFACE
    } IRowsetFastLoadVtbl;

    interface IRowsetFastLoad
    {
        CONST_VTBL struct IRowsetFastLoadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetFastLoad_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetFastLoad_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetFastLoad_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetFastLoad_InsertRow(This,hAccessor,pData)	\
    (This)->lpVtbl -> InsertRow(This,hAccessor,pData)

#define IRowsetFastLoad_Commit(This,fDone)	\
    (This)->lpVtbl -> Commit(This,fDone)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetFastLoad_InsertRow_Proxy( 
    IRowsetFastLoad __RPC_FAR * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ void __RPC_FAR *pData);


void __RPC_STUB IRowsetFastLoad_InsertRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetFastLoad_Commit_Proxy( 
    IRowsetFastLoad __RPC_FAR * This,
    /* [in] */ BOOL fDone);


void __RPC_STUB IRowsetFastLoad_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetFastLoad_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_sqloledb_0007
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 

typedef DWORD LOCKMODE;

enum LOCKMODEENUM
    {	LOCKMODE_INVALID	= 0,
	LOCKMODE_EXCLUSIVE	= LOCKMODE_INVALID + 1,
	LOCKMODE_SHARED	= LOCKMODE_EXCLUSIVE + 1
    };

extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqloledb_0007_v0_0_s_ifspec;

#ifndef __ISchemaLock_INTERFACE_DEFINED__
#define __ISchemaLock_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISchemaLock
 * at Tue May 09 16:41:59 2000
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_ISchemaLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C2389FB-2511-11d4-B258-00C04F7971CE")
    ISchemaLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSchemaLock( 
            /* [in] */ DBID __RPC_FAR *pTableID,
            /* [in] */ LOCKMODE lmMode,
            /* [out] */ HANDLE __RPC_FAR *phLockHandle,
            /* [out] */ ULONGLONG __RPC_FAR *pTableVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSchemaLock( 
            /* [in] */ HANDLE hLockHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchemaLock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchemaLock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchemaLock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSchemaLock )( 
            ISchemaLock __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pTableID,
            /* [in] */ LOCKMODE lmMode,
            /* [out] */ HANDLE __RPC_FAR *phLockHandle,
            /* [out] */ ULONGLONG __RPC_FAR *pTableVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseSchemaLock )( 
            ISchemaLock __RPC_FAR * This,
            /* [in] */ HANDLE hLockHandle);
        
        END_INTERFACE
    } ISchemaLockVtbl;

    interface ISchemaLock
    {
        CONST_VTBL struct ISchemaLockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchemaLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchemaLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchemaLock_GetSchemaLock(This,pTableID,lmMode,phLockHandle,pTableVersion)	\
    (This)->lpVtbl -> GetSchemaLock(This,pTableID,lmMode,phLockHandle,pTableVersion)

#define ISchemaLock_ReleaseSchemaLock(This,hLockHandle)	\
    (This)->lpVtbl -> ReleaseSchemaLock(This,hLockHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISchemaLock_GetSchemaLock_Proxy( 
    ISchemaLock __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pTableID,
    /* [in] */ LOCKMODE lmMode,
    /* [out] */ HANDLE __RPC_FAR *phLockHandle,
    /* [out] */ ULONGLONG __RPC_FAR *pTableVersion);


void __RPC_STUB ISchemaLock_GetSchemaLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaLock_ReleaseSchemaLock_Proxy( 
    ISchemaLock __RPC_FAR * This,
    /* [in] */ HANDLE hLockHandle);


void __RPC_STUB ISchemaLock_ReleaseSchemaLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaLock_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

#endif //_SQLOLEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\sqlucode.h ===
//-----------------------------------------------------------------------------
// File:            sqlucode.h
//
// Copyright:       Copyright (c) Microsoft Corporation
//
// Contents:        This is the the unicode include for ODBC Core functions
//
// Comments:
//
//-----------------------------------------------------------------------------

#ifndef __SQLUCODE
#define __SQLUCODE


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++   */
#endif  /* __cplusplus */

#include <sqlext.h>

#define SQL_WCHAR           (-8)
#define SQL_WVARCHAR        (-9)
#define SQL_WLONGVARCHAR    (-10)
#define SQL_C_WCHAR         SQL_WCHAR

#ifdef UNICODE
#define SQL_C_TCHAR         SQL_C_WCHAR
#else
#define SQL_C_TCHAR         SQL_C_CHAR
#endif

#define SQL_SQLSTATE_SIZEW  10  /* size of SQLSTATE for unicode */

#ifndef RC_INVOKED

// UNICODE versions
#ifdef _WIN64
SQLRETURN SQL_API SQLColAttributeW
(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    iCol,
    SQLUSMALLINT    iField,
    __out_bcount_opt(cbDescMax)
    SQLPOINTER      pCharAttr,
    SQLSMALLINT     cbDescMax,
    __out_opt
    SQLSMALLINT     *pcbCharAttr,
    __out_opt
    SQLLEN          *pNumAttr
);
#else
SQLRETURN SQL_API SQLColAttributeW(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    iCol,
    SQLUSMALLINT    iField,
    __out_bcount_opt(cbDescMax)
    SQLPOINTER      pCharAttr,
    SQLSMALLINT     cbDescMax,
    __out_opt
    SQLSMALLINT     *pcbCharAttr,
    __out_opt
    SQLPOINTER      pNumAttr);
#endif

SQLRETURN SQL_API SQLColAttributesW
(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    icol,
    SQLUSMALLINT    fDescType,
    __out_bcount_opt(cbDescMax)
    SQLPOINTER      rgbDesc,
    SQLSMALLINT     cbDescMax,
    __out_opt
    SQLSMALLINT     *pcbDesc,
    __out_opt
    SQLLEN          *pfDesc
);

SQLRETURN SQL_API SQLConnectW
(
    SQLHDBC             hdbc,
    __in_ecount(cchDSN) SQLWCHAR* szDSN,
    SQLSMALLINT         cchDSN,
    __in_ecount(cchUID) SQLWCHAR* szUID,
    SQLSMALLINT         cchUID,
    __in_ecount(cchAuthStr) SQLWCHAR* szAuthStr,
    SQLSMALLINT         cchAuthStr
);

SQLRETURN SQL_API SQLDescribeColW
(
    SQLHSTMT            hstmt,
    SQLUSMALLINT        icol,
    __out_ecount_opt(cchColNameMax) SQLWCHAR* szColName,
    SQLSMALLINT         cchColNameMax,
    __out_opt
    SQLSMALLINT*        pcchColName,
    __out_opt
    SQLSMALLINT*        pfSqlType,
    __out_opt
    SQLULEN*            pcbColDef,
    __out_opt
    SQLSMALLINT*        pibScale,
    __out_opt
    SQLSMALLINT*        pfNullable
);

SQLRETURN SQL_API SQLErrorW
(
    SQLHENV             henv,
    SQLHDBC             hdbc,
    SQLHSTMT            hstmt,
    __out_ecount(6) SQLWCHAR* wszSqlState,
    __out_opt SQLINTEGER*         pfNativeError,
    __out_ecount_opt(cchErrorMsgMax) SQLWCHAR* wszErrorMsg,
    SQLSMALLINT         cchErrorMsgMax,
    __out_opt SQLSMALLINT*        pcchErrorMsg
);

SQLRETURN SQL_API SQLExecDirectW
(
    SQLHSTMT    hstmt,
    __in_ecount_opt(TextLength) SQLWCHAR* szSqlStr,
    SQLINTEGER  TextLength
);

SQLRETURN SQL_API SQLGetConnectAttrW
(
    SQLHDBC     hdbc,
    SQLINTEGER  fAttribute,
    __out_xcount_opt(cbValueMax)
    SQLPOINTER  rgbValue,
    SQLINTEGER  cbValueMax,
    __out_opt
    SQLINTEGER* pcbValue
);

SQLRETURN SQL_API SQLGetCursorNameW
(
    SQLHSTMT        hstmt,
    __out_ecount_opt(cchCursorMax) SQLWCHAR* szCursor,
    SQLSMALLINT     cchCursorMax,
    __out_opt
    SQLSMALLINT*    pcchCursor
);

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetDescFieldW
(
    SQLHDESC        DescriptorHandle,
    SQLSMALLINT     RecNumber,
    SQLSMALLINT     FieldIdentifier,
    SQLPOINTER      Value,
    SQLINTEGER      BufferLength
);

SQLRETURN SQL_API SQLGetDescFieldW
(
    SQLHDESC        hdesc,
    SQLSMALLINT     iRecord,
    SQLSMALLINT     iField,
    __out_xcount_opt(cbBufferLength)
    SQLPOINTER      rgbValue,
    SQLINTEGER      cbBufferLength,
    __out_opt
    SQLINTEGER      *StringLength
);

SQLRETURN SQL_API SQLGetDescRecW
(
    SQLHDESC        hdesc,
    SQLSMALLINT     iRecord,
    __out_ecount_opt(cchNameMax) SQLWCHAR* szName,
    SQLSMALLINT     cchNameMax,
    __out_opt
    SQLSMALLINT     *pcchName,
    __out_opt
    SQLSMALLINT     *pfType,
    __out_opt
    SQLSMALLINT     *pfSubType,
    __out_opt
    SQLLEN          *pLength,
    __out_opt
    SQLSMALLINT     *pPrecision,
    __out_opt
    SQLSMALLINT     *pScale,
    __out_opt
    SQLSMALLINT     *pNullable
);

SQLRETURN SQL_API SQLGetDiagFieldW
(
    SQLSMALLINT     fHandleType,
    SQLHANDLE       handle,
    SQLSMALLINT     iRecord,
    SQLSMALLINT     fDiagField,
    __out_xcount_opt(cbBufferLength)
    SQLPOINTER      rgbDiagInfo,
    SQLSMALLINT     cbBufferLength,
    __out_opt
    SQLSMALLINT     *pcbStringLength
);

SQLRETURN SQL_API SQLGetDiagRecW
(
    SQLSMALLINT     fHandleType,
    SQLHANDLE       handle,
    SQLSMALLINT     iRecord,
    __out_ecount_opt(6) SQLWCHAR* szSqlState,
    SQLINTEGER*     pfNativeError,
    __out_ecount_opt(cchErrorMsgMax) SQLWCHAR* szErrorMsg,
    SQLSMALLINT     cchErrorMsgMax,
    SQLSMALLINT*    pcchErrorMsg
);
#endif

SQLRETURN SQL_API SQLPrepareW
(
    SQLHSTMT    hstmt,
    __in_ecount(cchSqlStr) SQLWCHAR* szSqlStr,
    SQLINTEGER  cchSqlStr
);

SQLRETURN SQL_API SQLSetConnectAttrW(
    SQLHDBC            hdbc,
    SQLINTEGER         fAttribute,
    __in_bcount_opt(cbValue)
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValue);

SQLRETURN SQL_API SQLSetCursorNameW
(
    SQLHSTMT            hstmt,
    __in_ecount(cchCursor) SQLWCHAR* szCursor,
    SQLSMALLINT         cchCursor
);

SQLRETURN SQL_API SQLColumnsW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName,
    __in_ecount_opt(cchColumnName) SQLWCHAR*     szColumnName,
    SQLSMALLINT        cchColumnName
);

SQLRETURN SQL_API SQLGetConnectOptionW(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fOption,
    SQLPOINTER         pvParam);

SQLRETURN SQL_API SQLGetInfoW(
    SQLHDBC                     hdbc,
    SQLUSMALLINT                fInfoType,
    __out_bcount_opt(cbInfoValueMax) SQLPOINTER rgbInfoValue,
    SQLSMALLINT        cbInfoValueMax,
    __out_opt
    SQLSMALLINT*                pcbInfoValue);

SQLRETURN SQL_API   SQLGetTypeInfoW(
    SQLHSTMT            StatementHandle,
    SQLSMALLINT         DataType);

SQLRETURN SQL_API SQLSetConnectOptionW(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fOption,
    SQLULEN            vParam);

SQLRETURN SQL_API SQLSpecialColumnsW
(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fColType,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName,
    SQLUSMALLINT       fScope,
    SQLUSMALLINT       fNullable
);

SQLRETURN SQL_API SQLStatisticsW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName,
    SQLUSMALLINT       fUnique,
    SQLUSMALLINT       fAccuracy
);

SQLRETURN SQL_API SQLTablesW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName,
    __in_ecount_opt(cchTableType) SQLWCHAR*      szTableType,
    SQLSMALLINT        cchTableType
);

SQLRETURN SQL_API SQLDataSourcesW
(
    SQLHENV             henv,
    SQLUSMALLINT        fDirection,
    __out_ecount_opt(cchDSNMax) SQLWCHAR* szDSN,
    SQLSMALLINT         cchDSNMax,
    __out_opt
    SQLSMALLINT*        pcchDSN,
    __out_ecount_opt(cchDescriptionMax) SQLWCHAR* wszDescription,
    SQLSMALLINT         cchDescriptionMax,
    __out_opt
    SQLSMALLINT*        pcchDescription
);

SQLRETURN SQL_API SQLDriverConnectW
(
    SQLHDBC             hdbc,
    SQLHWND             hwnd,
    __in_ecount(cchConnStrIn) SQLWCHAR* szConnStrIn,
    SQLSMALLINT         cchConnStrIn,
    __out_ecount_opt(cchConnStrOutMax) SQLWCHAR* szConnStrOut,
    SQLSMALLINT         cchConnStrOutMax,
    __out_opt SQLSMALLINT*        pcchConnStrOut,
    SQLUSMALLINT        fDriverCompletion
);

SQLRETURN SQL_API SQLBrowseConnectW
(
    SQLHDBC             hdbc,
    __in_ecount(cchConnStrIn) SQLWCHAR* szConnStrIn,
    SQLSMALLINT         cchConnStrIn,
    __out_ecount_opt(cchConnStrOutMax) SQLWCHAR* szConnStrOut,
    SQLSMALLINT         cchConnStrOutMax,
    __out_opt
    SQLSMALLINT*        pcchConnStrOut
);

SQLRETURN SQL_API SQLColumnPrivilegesW(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName,
    __in_ecount_opt(cchColumnName) SQLWCHAR*     szColumnName,
    SQLSMALLINT        cchColumnName
);

SQLRETURN SQL_API SQLGetStmtAttrW(
    SQLHSTMT           hstmt,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax,
    SQLINTEGER     *pcbValue);

SQLRETURN SQL_API SQLSetStmtAttrW(
    SQLHSTMT           hstmt,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax);

SQLRETURN SQL_API SQLForeignKeysW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchPkCatalogName) SQLWCHAR*    szPkCatalogName,
    SQLSMALLINT        cchPkCatalogName,
    __in_ecount_opt(cchPkSchemaName) SQLWCHAR*     szPkSchemaName,
    SQLSMALLINT        cchPkSchemaName,
    __in_ecount_opt(cchPkTableName) SQLWCHAR*      szPkTableName,
    SQLSMALLINT        cchPkTableName,
    __in_ecount_opt(cchFkCatalogName) SQLWCHAR*    szFkCatalogName,
    SQLSMALLINT        cchFkCatalogName,
    __in_ecount_opt(cchFkSchemaName) SQLWCHAR*     szFkSchemaName,
    SQLSMALLINT        cchFkSchemaName,
    __in_ecount_opt(cchFkTableName) SQLWCHAR*      szFkTableName,
    SQLSMALLINT        cchFkTableName
);

SQLRETURN SQL_API SQLNativeSqlW
(
    SQLHDBC                                     hdbc,
    __in_ecount(cchSqlStrIn) SQLWCHAR*          szSqlStrIn,
    SQLINTEGER                                  cchSqlStrIn,
    __out_ecount_opt(cchSqlStrMax) SQLWCHAR*    szSqlStr,
    SQLINTEGER                                  cchSqlStrMax,
    SQLINTEGER*                                 pcchSqlStr
);

SQLRETURN SQL_API SQLPrimaryKeysW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName
);

SQLRETURN SQL_API SQLProcedureColumnsW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchProcName) SQLWCHAR*       szProcName,
    SQLSMALLINT        cchProcName,
    __in_ecount_opt(cchColumnName) SQLWCHAR*     szColumnName,
    SQLSMALLINT        cchColumnName
);

SQLRETURN SQL_API SQLProceduresW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchProcName) SQLWCHAR*      szProcName,
    SQLSMALLINT        cchProcName
);

SQLRETURN SQL_API SQLTablePrivilegesW
(
    SQLHSTMT           hstmt,
    __in_ecount_opt(cchCatalogName) SQLWCHAR*    szCatalogName,
    SQLSMALLINT        cchCatalogName,
    __in_ecount_opt(cchSchemaName) SQLWCHAR*     szSchemaName,
    SQLSMALLINT        cchSchemaName,
    __in_ecount_opt(cchTableName) SQLWCHAR*      szTableName,
    SQLSMALLINT        cchTableName
);

SQLRETURN SQL_API SQLDriversW
(
    SQLHENV         henv,
    SQLUSMALLINT    fDirection,
    __out_ecount_opt(cchDriverDescMax) SQLWCHAR* szDriverDesc,
    SQLSMALLINT     cchDriverDescMax,
    __out_opt
    SQLSMALLINT*    pcchDriverDesc,
    __out_ecount_opt(cchDrvrAttrMax) SQLWCHAR*     szDriverAttributes,
    SQLSMALLINT     cchDrvrAttrMax,
    __out_opt
    SQLSMALLINT*    pcchDrvrAttr
);

// ANSI versions
#ifdef _WIN64
SQLRETURN SQL_API SQLColAttributeA(
    SQLHSTMT        hstmt,
    SQLSMALLINT     iCol,
    SQLSMALLINT     iField,
    __out_bcount_opt(cbCharAttrMax)
    SQLPOINTER      pCharAttr,
    SQLSMALLINT     cbCharAttrMax,
    __out_opt
    SQLSMALLINT     *pcbCharAttr,
    __out_opt
    SQLLEN          *pNumAttr);
#else
SQLRETURN SQL_API SQLColAttributeA(
    SQLHSTMT        hstmt,
    SQLSMALLINT     iCol,
    SQLSMALLINT     iField,
    __out_bcount_opt(cbCharAttrMax)
    SQLPOINTER      pCharAttr,
    SQLSMALLINT     cbCharAttrMax,
    __out_opt
    SQLSMALLINT     *pcbCharAttr,
    __out_opt
    SQLPOINTER      pNumAttr);
#endif

SQLRETURN SQL_API SQLColAttributesA(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    icol,
    SQLUSMALLINT    fDescType,
    __out_bcount_opt(cbDescMax)
    SQLPOINTER      rgbDesc,
    SQLSMALLINT     cbDescMax,
    __out_opt
    SQLSMALLINT     *pcbDesc,
    __out_opt
    SQLLEN          *pfDesc);

SQLRETURN SQL_API SQLConnectA(
    SQLHDBC         hdbc,
    __in_ecount(cbDSN)
    SQLCHAR         *szDSN,
    SQLSMALLINT     cbDSN,
    __in_ecount(cbUID)
    SQLCHAR         *szUID,
    SQLSMALLINT     cbUID,
    __in_ecount(cbAuthStr)
    SQLCHAR         *szAuthStr,
    SQLSMALLINT     cbAuthStr);

SQLRETURN SQL_API SQLDescribeColA(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    icol,
    __out_ecount_opt(cbColNameMax) 
    SQLCHAR         *szColName,
    SQLSMALLINT     cbColNameMax,
    __out_opt
    SQLSMALLINT     *pcbColName,
    __out_opt
    SQLSMALLINT     *pfSqlType,
    __out_opt
    SQLULEN         *pcbColDef,
    __out_opt
    SQLSMALLINT     *pibScale,
    __out_opt
    SQLSMALLINT     *pfNullable);

SQLRETURN SQL_API SQLErrorA(
    SQLHENV         henv,
    SQLHDBC         hdbc,
    SQLHSTMT        hstmt,
    __out_ecount(SQL_SQLSTATE_SIZE + 1)
    SQLCHAR         *szSqlState,
    __out_opt
    SQLINTEGER      *pfNativeError,
    __out_ecount_opt(cbErrorMsgMax)
    SQLCHAR         *szErrorMsg,
    SQLSMALLINT     cbErrorMsgMax,
    __out_opt
    SQLSMALLINT     *pcbErrorMsg);

SQLRETURN SQL_API SQLExecDirectA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbSqlStr)
    SQLCHAR         *szSqlStr,
    SQLINTEGER      cbSqlStr);

SQLRETURN SQL_API SQLGetConnectAttrA(
    SQLHDBC         hdbc,
    SQLINTEGER      fAttribute,
    __out_xcount_opt(cbValueMax)
    SQLPOINTER      rgbValue,
    SQLINTEGER      cbValueMax,
    __out_opt
    SQLINTEGER      *pcbValue);

SQLRETURN SQL_API SQLGetCursorNameA(
    SQLHSTMT        hstmt,
    __out_ecount_opt(cbCursorMax) 
    SQLCHAR         *szCursor,
    SQLSMALLINT     cbCursorMax,
    __out_opt
    SQLSMALLINT     *pcbCursor);

#if (ODBCVER >= 0x0300)
SQLRETURN SQL_API SQLGetDescFieldA(
    SQLHDESC        hdesc,
    SQLSMALLINT     iRecord,
    SQLSMALLINT     iField,
    __out_xcount_opt(cbBufferLength)
    SQLPOINTER      rgbValue,
    SQLINTEGER      cbBufferLength,
    __out_opt
    SQLINTEGER      *StringLength);

SQLRETURN SQL_API SQLGetDescRecA(
    SQLHDESC        hdesc,
    SQLSMALLINT     iRecord,
    __out_ecount_opt(cbNameMax)
    SQLCHAR         *szName,
    SQLSMALLINT     cbNameMax,
    __out_opt
    SQLSMALLINT     *pcbName,
    __out_opt
    SQLSMALLINT     *pfType,
    __out_opt
    SQLSMALLINT     *pfSubType,
    __out_opt
    SQLLEN          *pLength,
    __out_opt
    SQLSMALLINT     *pPrecision,
    __out_opt
    SQLSMALLINT     *pScale,
    __out_opt
    SQLSMALLINT     *pNullable);

SQLRETURN SQL_API SQLGetDiagFieldA(
    SQLSMALLINT     fHandleType,
    SQLHANDLE       handle,
    SQLSMALLINT     iRecord,
    SQLSMALLINT     fDiagField,
    __out_xcount_opt(cbDiagInfoMax)
    SQLPOINTER      rgbDiagInfo,
    SQLSMALLINT     cbDiagInfoMax,
    __out_opt
    SQLSMALLINT     *pcbDiagInfo);

SQLRETURN SQL_API SQLGetDiagRecA(
    SQLSMALLINT     fHandleType,
    SQLHANDLE       handle,
    SQLSMALLINT     iRecord,
    __out_ecount_opt(6)
    SQLCHAR         *szSqlState,
    SQLINTEGER      *pfNativeError,
    __out_ecount_opt(cbErrorMsgMax)
    SQLCHAR         *szErrorMsg,
    SQLSMALLINT     cbErrorMsgMax,
    SQLSMALLINT     *pcbErrorMsg);

SQLRETURN SQL_API SQLGetStmtAttrA(
    SQLHSTMT        hstmt,
    SQLINTEGER      fAttribute,
    SQLPOINTER      rgbValue,
    SQLINTEGER      cbValueMax,
    SQLINTEGER      *pcbValue);
#endif

SQLRETURN SQL_API   SQLGetTypeInfoA(
    SQLHSTMT        StatementHandle,
    SQLSMALLINT     DataType);

SQLRETURN SQL_API SQLPrepareA(
    SQLHSTMT        hstmt,
    __in_ecount(cbSqlStr)
    SQLCHAR         *szSqlStr,
    SQLINTEGER      cbSqlStr);

SQLRETURN SQL_API SQLSetConnectAttrA(
    SQLHDBC         hdbc,
    SQLINTEGER      fAttribute,
    __in_bcount_opt(cbValue)
    SQLPOINTER      rgbValue,
    SQLINTEGER      cbValue);

SQLRETURN SQL_API SQLSetCursorNameA(
    SQLHSTMT        hstmt,
    __in_ecount(cbCursor)
    SQLCHAR         *szCursor,
    SQLSMALLINT     cbCursor);

SQLRETURN SQL_API SQLColumnsA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName,
    __in_ecount_opt(cbColumnName)
    SQLCHAR         *szColumnName,
    SQLSMALLINT     cbColumnName);

SQLRETURN SQL_API SQLGetConnectOptionA(
    SQLHDBC         hdbc,
    SQLUSMALLINT    fOption,
    SQLPOINTER      pvParam);

SQLRETURN SQL_API SQLGetInfoA(
    SQLHDBC         hdbc,
    SQLUSMALLINT    fInfoType,
    __out_bcount_opt(cbInfoValueMax)
    SQLPOINTER      rgbInfoValue,
    SQLSMALLINT     cbInfoValueMax,
    __out_opt
    SQLSMALLINT*    pcbInfoValue);

SQLRETURN SQL_API SQLGetStmtOptionA(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    fOption,
    SQLPOINTER      pvParam);

SQLRETURN SQL_API SQLSetConnectOptionA(
    SQLHDBC         hdbc,
    SQLUSMALLINT    fOption,
    SQLULEN         vParam);

SQLRETURN SQL_API SQLSetStmtOptionA(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    fOption,
    SQLULEN         vParam);

SQLRETURN SQL_API SQLSpecialColumnsA(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    fColType,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName,
    SQLUSMALLINT    fScope,
    SQLUSMALLINT    fNullable);

SQLRETURN SQL_API SQLStatisticsA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName,
    SQLUSMALLINT    fUnique,
    SQLUSMALLINT    fAccuracy);

SQLRETURN SQL_API SQLTablesA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName,
    __in_ecount_opt(cbTableType)
    SQLCHAR         *szTableType,
    SQLSMALLINT     cbTableType);

SQLRETURN SQL_API SQLDataSourcesA(
    SQLHENV         henv,
    SQLUSMALLINT    fDirection,
    __out_ecount_opt(cbDSNMax)
    SQLCHAR         *szDSN,
    SQLSMALLINT     cbDSNMax,
    SQLSMALLINT     *pcbDSN,
    __out_ecount_opt(cbDescriptionMax)
    SQLCHAR         *szDescription,
    SQLSMALLINT     cbDescriptionMax,
    SQLSMALLINT     *pcbDescription);

SQLRETURN SQL_API SQLDriverConnectA(
    SQLHDBC         hdbc,
    SQLHWND         hwnd,
    __in_ecount(cbConnStrIn)
    SQLCHAR         *szConnStrIn,
    SQLSMALLINT     cbConnStrIn,
    __out_ecount_opt(cbConnStrOutMax)
    SQLCHAR         *szConnStrOut,
    SQLSMALLINT     cbConnStrOutMax,
    __out_opt
    SQLSMALLINT     *pcbConnStrOut,
    SQLUSMALLINT    fDriverCompletion);

SQLRETURN SQL_API SQLBrowseConnectA(
    SQLHDBC         hdbc,
    __in_ecount(cbConnStrIn)
    SQLCHAR         *szConnStrIn,
    SQLSMALLINT     cbConnStrIn,
    __out_ecount_opt(cbConnStrOutMax)
    SQLCHAR         *szConnStrOut,
    SQLSMALLINT     cbConnStrOutMax,
    __out_opt
    SQLSMALLINT     *pcbConnStrOut);

SQLRETURN SQL_API SQLColumnPrivilegesA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName,
    __in_ecount_opt(cbColumnName)
    SQLCHAR         *szColumnName,
    SQLSMALLINT     cbColumnName);

SQLRETURN SQL_API SQLDescribeParamA(
    SQLHSTMT        hstmt,
    SQLUSMALLINT    ipar,
    __out_opt
    SQLSMALLINT     *pfSqlType,
    __out_opt
    SQLUINTEGER     *pcbParamDef,
    __out_opt
    SQLSMALLINT     *pibScale,
    __out_opt
    SQLSMALLINT     *pfNullable);

SQLRETURN SQL_API SQLForeignKeysA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbPkCatalogName)
    SQLCHAR         *szPkCatalogName,
    SQLSMALLINT     cbPkCatalogName,
    __in_ecount_opt(cbPkSchemaName)
    SQLCHAR         *szPkSchemaName,
    SQLSMALLINT     cbPkSchemaName,
    __in_ecount_opt(cbPkTableName)
    SQLCHAR         *szPkTableName,
    SQLSMALLINT     cbPkTableName,
    __in_ecount_opt(cbFkCatalogName)
    SQLCHAR         *szFkCatalogName,
    SQLSMALLINT     cbFkCatalogName,
    __in_ecount_opt(cbFkSchemaName)
    SQLCHAR         *szFkSchemaName,
    SQLSMALLINT     cbFkSchemaName,
    __in_ecount_opt(cbFkTableName)
    SQLCHAR         *szFkTableName,
    SQLSMALLINT     cbFkTableName);

SQLRETURN SQL_API SQLNativeSqlA(
    SQLHDBC         hdbc,
    __in_ecount(cbSqlStrIn)
    SQLCHAR         *szSqlStrIn,
    SQLINTEGER      cbSqlStrIn,
    __out_ecount_opt(cbSqlStrMax)
    SQLCHAR         *szSqlStr,
    SQLINTEGER      cbSqlStrMax,
    SQLINTEGER      *pcbSqlStr);

SQLRETURN SQL_API SQLPrimaryKeysA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName);

SQLRETURN SQL_API SQLProcedureColumnsA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbProcName)
    SQLCHAR         *szProcName,
    SQLSMALLINT     cbProcName,
    __in_ecount_opt(cbColumnName)
    SQLCHAR         *szColumnName,
    SQLSMALLINT     cbColumnName);

SQLRETURN SQL_API SQLProceduresA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbProcName)
    SQLCHAR         *szProcName,
    SQLSMALLINT     cbProcName);

SQLRETURN SQL_API SQLTablePrivilegesA(
    SQLHSTMT        hstmt,
    __in_ecount_opt(cbCatalogName)
    SQLCHAR         *szCatalogName,
    SQLSMALLINT     cbCatalogName,
    __in_ecount_opt(cbSchemaName)
    SQLCHAR         *szSchemaName,
    SQLSMALLINT     cbSchemaName,
    __in_ecount_opt(cbTableName)
    SQLCHAR         *szTableName,
    SQLSMALLINT     cbTableName);

SQLRETURN SQL_API SQLDriversA(
    SQLHENV         henv,
    SQLUSMALLINT    fDirection,
    __out_ecount_opt(cbDriverDescMax)
    SQLCHAR         *szDriverDesc,
    SQLSMALLINT     cbDriverDescMax,
    __out_opt
    SQLSMALLINT     *pcbDriverDesc,
    __out_ecount_opt(cbDrvrAttrMax)
    SQLCHAR         *szDriverAttributes,
    SQLSMALLINT     cbDrvrAttrMax,
    __out_opt
    SQLSMALLINT     *pcbDrvrAttr);

//---------------------------------------------
// Mapping macros for Unicode
//---------------------------------------------
#ifndef SQL_NOUNICODEMAP    // define this to disable the mapping
#ifdef  UNICODE

#define SQLColAttribute     SQLColAttributeW
#define SQLColAttributes    SQLColAttributesW
#define SQLConnect          SQLConnectW
#define SQLDescribeCol      SQLDescribeColW
#define SQLError            SQLErrorW
#define SQLExecDirect       SQLExecDirectW
#define SQLGetConnectAttr   SQLGetConnectAttrW
#define SQLGetCursorName    SQLGetCursorNameW
#define SQLGetDescField     SQLGetDescFieldW
#define SQLGetDescRec       SQLGetDescRecW
#define SQLGetDiagField     SQLGetDiagFieldW
#define SQLGetDiagRec       SQLGetDiagRecW
#define SQLPrepare          SQ