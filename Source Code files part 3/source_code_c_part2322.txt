E phToken
    );
#ifdef UNICODE
#define LogonUser  LogonUserW
#else
#define LogonUser  LogonUserA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ImpersonateLoggedOnUser(
    HANDLE  hToken
    );

WINADVAPI
BOOL
WINAPI
CreateProcessAsUserA (
    HANDLE hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
WINADVAPI
BOOL
WINAPI
CreateProcessAsUserW (
    HANDLE hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
#ifdef UNICODE
#define CreateProcessAsUser  CreateProcessAsUserW
#else
#define CreateProcessAsUser  CreateProcessAsUserA
#endif // !UNICODE


//
// Performance counter API's
//

WINBASEAPI
BOOL
WINAPI
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    );

WINBASEAPI
BOOL
WINAPI
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    );

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];       // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];       // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2


WINBASEAPI
BOOL
WINAPI
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );
WINBASEAPI
BOOL
WINAPI
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );
#ifdef UNICODE
#define GetVersionEx  GetVersionExW
#else
#define GetVersionEx  GetVersionExA
#endif // !UNICODE


// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

#include <winerror.h>

/* Abnormal termination codes */

#define TC_NORMAL       0
#define TC_HARDERR      1
#define TC_GP_TRAP      2
#define TC_SIGNAL       3

#if(WINVER >= 0x0400)
//
// Power Management APIs
//

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_UNKNOWN        0xFFFFFFFF

typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

BOOL
WINAPI
GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

BOOL
WINAPI
SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    );
#endif /* WINVER >= 0x0400 */


#ifdef __cplusplus
}
#endif



#endif // _WINBASE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINCON.H ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    wincon.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT console subsystem.

Created:

    26-Oct-1990

Revision History:

--*/

#ifndef _WINCON_
#define _WINCON_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;

//
// ControlKeyState flags
//

#define RIGHT_ALT_PRESSED     0x0001 // the right alt key is pressed.
#define LEFT_ALT_PRESSED      0x0002 // the left alt key is pressed.
#define RIGHT_CTRL_PRESSED    0x0004 // the right ctrl key is pressed.
#define LEFT_CTRL_PRESSED     0x0008 // the left ctrl key is pressed.
#define SHIFT_PRESSED         0x0010 // the shift key is pressed.
#define NUMLOCK_ON            0x0020 // the numlock light is on.
#define SCROLLLOCK_ON         0x0040 // the scrolllock light is on.
#define CAPSLOCK_ON           0x0080 // the capslock light is on.
#define ENHANCED_KEY          0x0100 // the key is enhanced.

typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;

//
// ButtonState flags
//

#define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
#define RIGHTMOST_BUTTON_PRESSED        0x0002
#define FROM_LEFT_2ND_BUTTON_PRESSED    0x0004
#define FROM_LEFT_3RD_BUTTON_PRESSED    0x0008
#define FROM_LEFT_4TH_BUTTON_PRESSED    0x0010

//
// EventFlags
//

#define MOUSE_MOVED   0x0001
#define DOUBLE_CLICK  0x0002

typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

//
//  EventType flags:
//

#define KEY_EVENT         0x0001 // Event contains key event record
#define MOUSE_EVENT       0x0002 // Event contains mouse event record
#define WINDOW_BUFFER_SIZE_EVENT 0x0004 // Event contains window change event record
#define MENU_EVENT 0x0008 // Event contains menu event record
#define FOCUS_EVENT 0x0010 // event contains focus change

typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

//
// Attributes flags:
//

#define FOREGROUND_BLUE      0x0001 // text color contains blue.
#define FOREGROUND_GREEN     0x0002 // text color contains green.
#define FOREGROUND_RED       0x0004 // text color contains red.
#define FOREGROUND_INTENSITY 0x0008 // text color is intensified.
#define BACKGROUND_BLUE      0x0010 // background color contains blue.
#define BACKGROUND_GREEN     0x0020 // background color contains green.
#define BACKGROUND_RED       0x0040 // background color contains red.
#define BACKGROUND_INTENSITY 0x0080 // background color is intensified.


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

//
// typedef for ctrl-c handler routines
//

typedef
BOOL
(WINAPI *PHANDLER_ROUTINE)(
    DWORD CtrlType
    );

#define CTRL_C_EVENT        0
#define CTRL_BREAK_EVENT    1
#define CTRL_CLOSE_EVENT    2
// 3 is reserved!
// 4 is reserved!
#define CTRL_LOGOFF_EVENT   5
#define CTRL_SHUTDOWN_EVENT 6

//
//  Input Mode flags:
//

#define ENABLE_PROCESSED_INPUT 0x0001
#define ENABLE_LINE_INPUT      0x0002
#define ENABLE_ECHO_INPUT      0x0004
#define ENABLE_WINDOW_INPUT    0x0008
#define ENABLE_MOUSE_INPUT     0x0010

//
// Output Mode flags:
//

#define ENABLE_PROCESSED_OUTPUT    0x0001
#define ENABLE_WRAP_AT_EOL_OUTPUT  0x0002

//
// direct API definitions.
//

WINBASEAPI
BOOL
WINAPI
PeekConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
WINBASEAPI
BOOL
WINAPI
PeekConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
#ifdef UNICODE
#define PeekConsoleInput  PeekConsoleInputW
#else
#define PeekConsoleInput  PeekConsoleInputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
#ifdef UNICODE
#define ReadConsoleInput  ReadConsoleInputW
#else
#define ReadConsoleInput  ReadConsoleInputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleInputA(
    HANDLE hConsoleInput,
    CONST INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleInputW(
    HANDLE hConsoleInput,
    CONST INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
#ifdef UNICODE
#define WriteConsoleInput  WriteConsoleInputW
#else
#define WriteConsoleInput  WriteConsoleInputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputA(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputW(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );
#ifdef UNICODE
#define ReadConsoleOutput  ReadConsoleOutputW
#else
#define ReadConsoleOutput  ReadConsoleOutputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputA(
    HANDLE hConsoleOutput,
    CONST CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputW(
    HANDLE hConsoleOutput,
    CONST CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );
#ifdef UNICODE
#define WriteConsoleOutput  WriteConsoleOutputW
#else
#define WriteConsoleOutput  WriteConsoleOutputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPWSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );
#ifdef UNICODE
#define ReadConsoleOutputCharacter  ReadConsoleOutputCharacterW
#else
#define ReadConsoleOutputCharacter  ReadConsoleOutputCharacterA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    LPWORD lpAttribute,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfAttrsRead
    );

WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPCSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPCWSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
#ifdef UNICODE
#define WriteConsoleOutputCharacter  WriteConsoleOutputCharacterW
#else
#define WriteConsoleOutputCharacter  WriteConsoleOutputCharacterA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    CONST WORD *lpAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );

WINBASEAPI
BOOL
WINAPI
FillConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    CHAR  cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
WINBASEAPI
BOOL
WINAPI
FillConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    WCHAR  cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
#ifdef UNICODE
#define FillConsoleOutputCharacter  FillConsoleOutputCharacterW
#else
#define FillConsoleOutputCharacter  FillConsoleOutputCharacterA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FillConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    WORD   wAttribute,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleMode(
    HANDLE hConsoleHandle,
    LPDWORD lpMode
    );

WINBASEAPI
BOOL
WINAPI
GetNumberOfConsoleInputEvents(
    HANDLE hConsoleInput,
    LPDWORD lpNumberOfEvents
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleScreenBufferInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );

WINBASEAPI
COORD
WINAPI
GetLargestConsoleWindowSize(
    HANDLE hConsoleOutput
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );

WINBASEAPI
BOOL
WINAPI
GetNumberOfConsoleMouseButtons(
    LPDWORD lpNumberOfMouseButtons
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleMode(
    HANDLE hConsoleHandle,
    DWORD dwMode
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleActiveScreenBuffer(
    HANDLE hConsoleOutput
    );

WINBASEAPI
BOOL
WINAPI
FlushConsoleInputBuffer(
    HANDLE hConsoleInput
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleScreenBufferSize(
    HANDLE hConsoleOutput,
    COORD dwSize
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleCursorPosition(
    HANDLE hConsoleOutput,
    COORD dwCursorPosition
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    CONST CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );

WINBASEAPI
BOOL
WINAPI
ScrollConsoleScreenBufferA(
    HANDLE hConsoleOutput,
    CONST SMALL_RECT *lpScrollRectangle,
    CONST SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    CONST CHAR_INFO *lpFill
    );
WINBASEAPI
BOOL
WINAPI
ScrollConsoleScreenBufferW(
    HANDLE hConsoleOutput,
    CONST SMALL_RECT *lpScrollRectangle,
    CONST SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    CONST CHAR_INFO *lpFill
    );
#ifdef UNICODE
#define ScrollConsoleScreenBuffer  ScrollConsoleScreenBufferW
#else
#define ScrollConsoleScreenBuffer  ScrollConsoleScreenBufferA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetConsoleWindowInfo(
    HANDLE hConsoleOutput,
    BOOL bAbsolute,
    CONST SMALL_RECT *lpConsoleWindow
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleTextAttribute(
    HANDLE hConsoleOutput,
    WORD wAttributes
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleCtrlHandler(
    PHANDLER_ROUTINE HandlerRoutine,
    BOOL Add
    );

WINBASEAPI
BOOL
WINAPI
GenerateConsoleCtrlEvent(
    DWORD dwCtrlEvent,
    DWORD dwProcessGroupId
    );

WINBASEAPI
BOOL
WINAPI
AllocConsole( VOID );

WINBASEAPI
BOOL
WINAPI
FreeConsole( VOID );


WINBASEAPI
DWORD
WINAPI
GetConsoleTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetConsoleTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize
    );
#ifdef UNICODE
#define GetConsoleTitle  GetConsoleTitleW
#else
#define GetConsoleTitle  GetConsoleTitleA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetConsoleTitleA(
    LPCSTR lpConsoleTitle
    );
WINBASEAPI
BOOL
WINAPI
SetConsoleTitleW(
    LPCWSTR lpConsoleTitle
    );
#ifdef UNICODE
#define SetConsoleTitle  SetConsoleTitleW
#else
#define SetConsoleTitle  SetConsoleTitleA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleA(
    HANDLE hConsoleInput,
    LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    LPVOID lpReserved
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleW(
    HANDLE hConsoleInput,
    LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    LPVOID lpReserved
    );
#ifdef UNICODE
#define ReadConsole  ReadConsoleW
#else
#define ReadConsole  ReadConsoleA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleA(
    HANDLE hConsoleOutput,
    CONST VOID *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleW(
    HANDLE hConsoleOutput,
    CONST VOID *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved
    );
#ifdef UNICODE
#define WriteConsole  WriteConsoleW
#else
#define WriteConsole  WriteConsoleA
#endif // !UNICODE

#define CONSOLE_TEXTMODE_BUFFER  1

WINBASEAPI
HANDLE
WINAPI
CreateConsoleScreenBuffer(
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    CONST SECURITY_ATTRIBUTES *lpSecurityAttributes,
    DWORD dwFlags,
    LPVOID lpScreenBufferData
    );

WINBASEAPI
UINT
WINAPI
GetConsoleCP( VOID );

WINBASEAPI
BOOL
WINAPI
SetConsoleCP(
    UINT wCodePageID
    );

WINBASEAPI
UINT
WINAPI
GetConsoleOutputCP( VOID );

WINBASEAPI
BOOL
WINAPI
SetConsoleOutputCP(
    UINT wCodePageID
    );

#ifdef __cplusplus
}
#endif

#endif // _WINCON_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\UNKNWN.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:30 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unknwn_h__
#define __unknwn_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IUnknown_FWD_DEFINED__
#define __IUnknown_FWD_DEFINED__
typedef interface IUnknown IUnknown;
#endif 	/* __IUnknown_FWD_DEFINED__ */


#ifndef __IClassFactory_FWD_DEFINED__
#define __IClassFactory_FWD_DEFINED__
typedef interface IClassFactory IClassFactory;
#endif 	/* __IClassFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUnknown
 * at Fri Apr 28 07:02:30 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */ IUnknown __RPC_FAR *LPUNKNOWN;

//////////////////////////////////////////////////////////////////
// IID_IUnknown and all other system IIDs are provided in UUID.LIB
// Link that library in with your proxies, clients and servers
//////////////////////////////////////////////////////////////////

EXTERN_C const IID IID_IUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual ULONG __stdcall AddRef( void) = 0;
        
        virtual ULONG __stdcall Release( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnknownVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IUnknown __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IUnknown __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IUnknown __RPC_FAR * This);
        
    } IUnknownVtbl;

    interface IUnknown
    {
        CONST_VTBL struct IUnknownVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IUnknown_QueryInterface_Proxy( 
    IUnknown __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IUnknown_QueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IUnknown_AddRef_Proxy( 
    IUnknown __RPC_FAR * This);


void __RPC_STUB IUnknown_AddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IUnknown_Release_Proxy( 
    IUnknown __RPC_FAR * This);


void __RPC_STUB IUnknown_Release_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnknown_INTERFACE_DEFINED__ */


#ifndef __IClassFactory_INTERFACE_DEFINED__
#define __IClassFactory_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IClassFactory
 * at Fri Apr 28 07:02:30 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IClassFactory __RPC_FAR *LPCLASSFACTORY;


EXTERN_C const IID IID_IClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IClassFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT __stdcall LockServer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassFactoryVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IClassFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IClassFactory __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IClassFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *CreateInstance )( 
            IClassFactory __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( __stdcall __RPC_FAR *LockServer )( 
            IClassFactory __RPC_FAR * This,
            /* [in] */ BOOL fLock);
        
    } IClassFactoryVtbl;

    interface IClassFactory
    {
        CONST_VTBL struct IClassFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassFactory_CreateInstance(This,pUnkOuter,riid,ppvObject)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObject)

#define IClassFactory_LockServer(This,fLock)	\
    (This)->lpVtbl -> LockServer(This,fLock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IClassFactory_LockServer_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);


void __RPC_STUB IClassFactory_LockServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassFactory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT __stdcall IClassFactory_CreateInstance_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT __stdcall IClassFactory_CreateInstance_Stub( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINDEF.H ===
/****************************************************************************
*                                                                           *
* windef.h -- Basic Windows Type Definitions                                *
*                                                                           *
* Copyright (c) 1985-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/


#ifndef _WINDEF_        
#define _WINDEF_


#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINVER
#define WINVER 0x0400
#endif 


/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */

#ifndef BASETYPES
#define BASETYPES
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#endif  /* !BASETYPES */

#define MAX_PATH          260

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#undef far
#undef near
#undef pascal

#define far
#define near
#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define pascal __stdcall
#else
#define pascal
#endif

#ifdef DOSWIN32
#define cdecl _cdecl
#ifndef CDECL
#define CDECL _cdecl
#endif
#else
#define cdecl
#ifndef CDECL
#define CDECL
#endif
#endif

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define CALLBACK    __stdcall
#define WINAPI      __stdcall
#define WINAPIV     __cdecl
#define APIENTRY    WINAPI
#define APIPRIVATE  __stdcall
#define PASCAL      __stdcall
#else
#define CALLBACK
#define WINAPI
#define WINAPIV
#define APIENTRY    WINAPI
#define APIPRIVATE
#define PASCAL      pascal
#endif

#define FAR                 far
#define NEAR                near
#ifndef CONST
#define CONST               const
#endif

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL near           *PBOOL;
typedef BOOL far            *LPBOOL;
typedef BYTE near           *PBYTE;
typedef BYTE far            *LPBYTE;
typedef int near            *PINT;
typedef int far             *LPINT;
typedef WORD near           *PWORD;
typedef WORD far            *LPWORD;
typedef long far            *LPLONG;
typedef DWORD near          *PDWORD;
typedef DWORD far           *LPDWORD;
typedef void far            *LPVOID;
typedef CONST void far      *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;

#ifndef NT_INCLUDED
#include <winnt.h>
#endif /* NT_INCLUDED */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))


#ifndef WIN_INTERNAL
DECLARE_HANDLE            (HWND);
DECLARE_HANDLE            (HHOOK);
#endif

typedef WORD                ATOM;

typedef HANDLE NEAR         *SPHANDLE;
typedef HANDLE FAR          *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;
typedef int (FAR WINAPI *FARPROC)();
typedef int (NEAR WINAPI *NEARPROC)();
typedef int (WINAPI *PROC)();

#ifdef STRICT
typedef void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HBRUSH);
#if(WINVER >= 0x0400)
DECLARE_HANDLE(HCOLORSPACE);
#endif /* WINVER >= 0x0400 */
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HGLRC);          // OpenGL
DECLARE_HANDLE(HDESK);
DECLARE_HANDLE(HENHMETAFILE);
DECLARE_HANDLE(HFONT);
DECLARE_HANDLE(HICON);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HMETAFILE);
DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HRSRC);
DECLARE_HANDLE(HSTR);
DECLARE_HANDLE(HTASK);
DECLARE_HANDLE(HWINSTA);
DECLARE_HANDLE(HKL);

typedef int HFILE;      
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */

typedef DWORD   COLORREF;
typedef DWORD   *LPCOLORREF;

#define HFILE_ERROR ((HFILE)-1)

typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;

typedef const RECT FAR* LPCRECT;

typedef struct _RECTL       /* rcl */
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL FAR* LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;

typedef struct _POINTL      /* ptl  */
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{
    SHORT   x;
    SHORT   y;
} POINTS, *PPOINTS, *LPPOINTS;

/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8

#define DM_IN_BUFFER        DM_MODIFY
#define DM_IN_PROMPT        DM_PROMPT
#define DM_OUT_BUFFER       DM_COPY
#define DM_OUT_DEFAULT      DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS           1
#define DC_PAPERS           2
#define DC_PAPERSIZE        3
#define DC_MINEXTENT        4
#define DC_MAXEXTENT        5
#define DC_BINS             6
#define DC_DUPLEX           7
#define DC_SIZE             8
#define DC_EXTRA            9
#define DC_VERSION          10
#define DC_DRIVER           11
#define DC_BINNAMES         12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE         15
#define DC_PAPERNAMES       16
#define DC_ORIENTATION      17
#define DC_COPIES           18

#ifdef __cplusplus
}
#endif


#endif /* _WINDEF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\STRING.H ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#ifndef _INC_STRING
#define _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647	/* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* Function prototypes */

_CRTIMP void * __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void * __cdecl memchr(const void *, int, size_t);
	int __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP int __cdecl _memicmp(const void *, const void *, unsigned int);
	void * __cdecl memcpy(void *, const void *, size_t);
#ifdef	_M_ALPHA
	/* memmove is available as an intrinsic in the Alpha compiler */
	void * __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void * __cdecl memmove(void *, const void *, size_t);
#endif
	void * __cdecl memset(void *, int, size_t);
	char * __cdecl strcat(char *, const char *);
_CRTIMP char * __cdecl strchr(const char *, int);
	int __cdecl strcmp(const char *, const char *);
_CRTIMP int __cdecl _strcmpi(const char *, const char *);
_CRTIMP int __cdecl _stricmp(const char *, const char *);
_CRTIMP int __cdecl strcoll(const char *, const char *);
_CRTIMP int __cdecl _stricoll(const char *, const char *);
_CRTIMP int __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _strnicoll(const char *, const char *, size_t);
	char * __cdecl strcpy(char *, const char *);
_CRTIMP size_t __cdecl strcspn(const char *, const char *);
_CRTIMP char * __cdecl _strdup(const char *);
_CRTIMP char * __cdecl _strerror(const char *);
_CRTIMP char * __cdecl strerror(int);
	size_t __cdecl strlen(const char *);
_CRTIMP char * __cdecl _strlwr(char *);
_CRTIMP char * __cdecl strncat(char *, const char *, size_t);
_CRTIMP int __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _strnset(char *, int, size_t);
_CRTIMP char * __cdecl strpbrk(const char *, const char *);
_CRTIMP char * __cdecl strrchr(const char *, int);
_CRTIMP char * __cdecl _strrev(char *);
	char * __cdecl _strset(char *, int);
_CRTIMP size_t __cdecl strspn(const char *, const char *);
_CRTIMP char * __cdecl strstr(const char *, const char *);
_CRTIMP char * __cdecl strtok(char *, const char *);
_CRTIMP char * __cdecl _strupr(char *);
_CRTIMP size_t __cdecl strxfrm (char *, const char *, size_t);

#if	!__STDC__

#ifdef	_NTSDK

/* Non-ANSI names for compatibility */
#define memccpy  _memccpy
#define memicmp  _memicmp
#define strcmpi  _strcmpi
#define stricmp  _stricmp
#define strdup	 _strdup
#define strlwr	 _strlwr
#define strnicmp _strnicmp
#define strnset  _strnset
#define strrev	 _strrev
#define strset	 _strset
#define strupr	 _strupr
#define stricoll _stricoll

#else	/* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, unsigned int);
_CRTIMP int __cdecl memicmp(const void *, const void *, unsigned int);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
	char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif	/* ndef _NTSDK */

#endif	/* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if	!__STDC__

/* old names */
#define wcswcs wcsstr

#ifdef	_NTSDK

/* Non-ANSI names for compatibility */
#define wcsdup	_wcsdup
#define wcsicmp	_wcsicmp
#define wcsnicmp _wcsnicmp
#define wcsnset	_wcsnset
#define wcsrev	_wcsrev
#define wcsset	_wcsset
#define wcslwr	_wcslwr
#define wcsupr	_wcsupr
#define wcsicoll _wcsicoll

#else	/* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif	/* ndef _NTSDK */

#endif	/* !__STDC__ */

#define _WSTRING_DEFINED
#endif

#ifdef __cplusplus
}
#endif

#endif	/* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINDOWS.H ===
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

#ifndef _WINDOWS_
#define _WINDOWS_


#ifndef _INC_WINDOWS    
#define _INC_WINDOWS 

#ifndef WINVER
#define WINVER 0x0400
#endif

/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NONLS             - All NLS defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 *  NOMCX             - Modem Configuration Extensions
 */

#ifdef RC_INVOKED

/* Turn off a bunch of stuff to ensure that RC files compile OK. */
#define NOATOM
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI
#define NOMCX
#endif /* RC_INVOKED */

#if !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif

#if !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif

#if !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif

#ifndef RC_INVOKED
#if	( _MSC_VER >= 800 )
#pragma warning(disable:4001)
#endif
#include <excpt.h>
#include <stdarg.h>
#endif /* RC_INVOKED */

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winuser.h>
#include <winnls.h>
#include <wincon.h>
#include <winver.h>
#include <winreg.h>
#include <winnetwk.h>

#ifndef WIN32_LEAN_AND_MEAN
#include <cderr.h>
#include <dde.h>
#include <ddeml.h>
#include <dlgs.h>
#include <lzexpand.h>
#include <mmsystem.h>
#include <nb30.h>
#include <rpc.h>
#include <shellapi.h>
#include <winperf.h>
#include <winsock.h>
#ifndef NOGDI
#include <commdlg.h>
#include <winspool.h>
#ifdef INC_OLE1
#include <ole.h>
#else
#include <ole2.h>
#endif /* !INC_OLE1 */
#endif /* !NOGDI */
#endif /* WIN32_LEAN_AND_MEAN */

#ifdef INC_OLE2
#include <ole2.h>
#endif /* INC_OLE2 */

#ifndef NOSERVICE
#include <winsvc.h>
#endif

#if(WINVER >= 0x0400)
#ifndef NOMCX          
#include <mcx.h>      
#endif /* NOMCX */      
                        
#ifndef NOIME           
#include <imm.h>        
#endif                  
#endif /* WINVER >= 0x0400 */

#ifndef RC_INVOKED
#if	( _MSC_VER >= 800 )
#pragma warning(default:4001)
#endif
#endif /* RC_INVOKED */

#endif /* _INC_WINDOWS */
#endif /* _WINDOWS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINERROR.H ===
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *  
*                                                                       *
*   Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _WINERROR_
#define _WINERROR_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 8
#define FACILITY_STORAGE                 3
#define FACILITY_RPC                     1
#define FACILITY_WIN32                   7
#define FACILITY_CONTROL                 10
#define FACILITY_NULL                    0
#define FACILITY_ITF                     4
#define FACILITY_DISPATCH                2


//
// Define the severity codes
//


//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
//  The operation completed successfully.
//
#define ERROR_SUCCESS                    0L

#define NO_ERROR 0L                                                 // dderror

//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
//  Incorrect function.
//
#define ERROR_INVALID_FUNCTION           1L    // dderror

//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.
//
#define ERROR_FILE_NOT_FOUND             2L

//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND             3L

//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
//  The system cannot open the file.
//
#define ERROR_TOO_MANY_OPEN_FILES        4L

//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define ERROR_ACCESS_DENIED              5L

//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
//  The handle is invalid.
//
#define ERROR_INVALID_HANDLE             6L

//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
//  The storage control blocks were destroyed.
//
#define ERROR_ARENA_TRASHED              7L

//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
//  Not enough storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_MEMORY          8L    // dderror

//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
//  The storage control block address is invalid.
//
#define ERROR_INVALID_BLOCK              9L

//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
//  The environment is incorrect.
//
#define ERROR_BAD_ENVIRONMENT            10L

//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
//  An attempt was made to load a program with an
//  incorrect format.
//
#define ERROR_BAD_FORMAT                 11L

//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
//  The access code is invalid.
//
#define ERROR_INVALID_ACCESS             12L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//
#define ERROR_INVALID_DATA               13L

//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
//  Not enough storage is available to complete this operation.
//
#define ERROR_OUTOFMEMORY                14L

//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
//  The system cannot find the drive specified.
//
#define ERROR_INVALID_DRIVE              15L

//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
//  The directory cannot be removed.
//
#define ERROR_CURRENT_DIRECTORY          16L

//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
//  The system cannot move the file
//  to a different disk drive.
//
#define ERROR_NOT_SAME_DEVICE            17L

//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
//  There are no more files.
//
#define ERROR_NO_MORE_FILES              18L

//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
//  The media is write protected.
//
#define ERROR_WRITE_PROTECT              19L

//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
//  The system cannot find the device specified.
//
#define ERROR_BAD_UNIT                   20L

//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
//  The device is not ready.
//
#define ERROR_NOT_READY                  21L

//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
//  The device does not recognize the command.
//
#define ERROR_BAD_COMMAND                22L

//
// MessageId: ERROR_CRC
//
// MessageText:
//
//  Data error (cyclic redundancy check)
//
#define ERROR_CRC                        23L

//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
//  The program issued a command but the
//  command length is incorrect.
//
#define ERROR_BAD_LENGTH                 24L

//
// MessageId: ERROR_SEEK
//
// MessageText:
//
//  The drive cannot locate a specific
//  area or track on the disk.
//
#define ERROR_SEEK                       25L

//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
//  The specified disk or diskette cannot be accessed.
//
#define ERROR_NOT_DOS_DISK               26L

//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
//  The drive cannot find the sector requested.
//
#define ERROR_SECTOR_NOT_FOUND           27L

//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
//  The printer is out of paper.
//
#define ERROR_OUT_OF_PAPER               28L

//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
//  The system cannot write to the specified device.
//
#define ERROR_WRITE_FAULT                29L

//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
//  The system cannot read from the specified device.
//
#define ERROR_READ_FAULT                 30L

//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
//  A device attached to the system is not functioning.
//
#define ERROR_GEN_FAILURE                31L

//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  it is being used by another process.
//
#define ERROR_SHARING_VIOLATION          32L

//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  another process has locked a portion of the file.
//
#define ERROR_LOCK_VIOLATION             33L

//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
//  The wrong diskette is in the drive.
//  Insert %2 (Volume Serial Number: %3)
//  into drive %1.
//
#define ERROR_WRONG_DISK                 34L

//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
//  Too many files opened for sharing.
//
#define ERROR_SHARING_BUFFER_EXCEEDED    36L

//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
//  Reached end of file.
//
#define ERROR_HANDLE_EOF                 38L

//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
//  The disk is full.
//
#define ERROR_HANDLE_DISK_FULL           39L

//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//
#define ERROR_NOT_SUPPORTED              50L

//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
//  The remote computer is not available.
//
#define ERROR_REM_NOT_LIST               51L

//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define ERROR_DUP_NAME                   52L

//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
//  The network path was not found.
//
#define ERROR_BAD_NETPATH                53L

//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//
#define ERROR_NETWORK_BUSY               54L

//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
//  The specified network resource or device is no longer
//  available.
//
#define ERROR_DEV_NOT_EXIST              55L    // dderror

//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//
#define ERROR_TOO_MANY_CMDS              56L

//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
//  A network adapter hardware error occurred.
//
#define ERROR_ADAP_HDW_ERR               57L

//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested
//  operation.
//
#define ERROR_BAD_NET_RESP               58L

//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
//  An unexpected network error occurred.
//
#define ERROR_UNEXP_NET_ERR              59L

//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
//  The remote adapter is not compatible.
//
#define ERROR_BAD_REM_ADAP               60L

//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
//  The printer queue is full.
//
#define ERROR_PRINTQ_FULL                61L

//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is
//  not available on the server.
//
#define ERROR_NO_SPOOL_SPACE             62L

//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
//  Your file waiting to be printed was deleted.
//
#define ERROR_PRINT_CANCELLED            63L

//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
//  The specified network name is no longer available.
//
#define ERROR_NETNAME_DELETED            64L

//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//
#define ERROR_NETWORK_ACCESS_DENIED      65L

//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
//  The network resource type is not correct.
//
#define ERROR_BAD_DEV_TYPE               66L

//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
//  The network name cannot be found.
//
#define ERROR_BAD_NET_NAME               67L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES             68L

//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//
#define ERROR_TOO_MANY_SESS              69L

//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
//  The remote server has been paused or is in the
//  process of being started.
//
#define ERROR_SHARING_PAUSED             70L

//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
//  No more connections can be made to this remote computer at this time
//  because there are already as many connections as the computer can accept.
//
#define ERROR_REQ_NOT_ACCEP              71L

//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
//  The specified printer or disk device has been paused.
//
#define ERROR_REDIR_PAUSED               72L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//
#define ERROR_FILE_EXISTS                80L

//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
//  The directory or file cannot be created.
//
#define ERROR_CANNOT_MAKE                82L

//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
//  Fail on INT 24
//
#define ERROR_FAIL_I24                   83L

//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
//  Storage to process this request is not available.
//
#define ERROR_OUT_OF_STRUCTURES          84L

//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
//  The local device name is already in use.
//
#define ERROR_ALREADY_ASSIGNED           85L

//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
//  The specified network password is not correct.
//
#define ERROR_INVALID_PASSWORD           86L

//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  The parameter is incorrect.
//
#define ERROR_INVALID_PARAMETER          87L    // dderror

//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
//  A write fault occurred on the network.
//
#define ERROR_NET_WRITE_FAULT            88L

//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
//  The system cannot start another process at
//  this time.
//
#define ERROR_NO_PROC_SLOTS              89L

//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
//  Cannot create another system semaphore.
//
#define ERROR_TOO_MANY_SEMAPHORES        100L

//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
//  The exclusive semaphore is owned by another process.
//
#define ERROR_EXCL_SEM_ALREADY_OWNED     101L

//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
//  The semaphore is set and cannot be closed.
//
#define ERROR_SEM_IS_SET                 102L

//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
//  The semaphore cannot be set again.
//
#define ERROR_TOO_MANY_SEM_REQUESTS      103L

//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
//  Cannot request exclusive semaphores at interrupt time.
//
#define ERROR_INVALID_AT_INTERRUPT_TIME  104L

//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
//  The previous ownership of this semaphore has ended.
//
#define ERROR_SEM_OWNER_DIED             105L

//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
//  Insert the diskette for drive %1.
//
#define ERROR_SEM_USER_LIMIT             106L

//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
//  Program stopped because alternate diskette was not inserted.
//
#define ERROR_DISK_CHANGE                107L

//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
//  The disk is in use or locked by
//  another process.
//
#define ERROR_DRIVE_LOCKED               108L

//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
//  The pipe has been ended.
//
#define ERROR_BROKEN_PIPE                109L

//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
//  The system cannot open the
//  device or file specified.
//
#define ERROR_OPEN_FAILED                110L

//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
//  The file name is too long.
//
#define ERROR_BUFFER_OVERFLOW            111L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//
#define ERROR_DISK_FULL                  112L

//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
//  No more internal file identifiers available.
//
#define ERROR_NO_MORE_SEARCH_HANDLES     113L

//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
//  The target internal file identifier is incorrect.
//
#define ERROR_INVALID_TARGET_HANDLE      114L

//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
//  The IOCTL call made by the application program is
//  not correct.
//
#define ERROR_INVALID_CATEGORY           117L

//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
//  The verify-on-write switch parameter value is not
//  correct.
//
#define ERROR_INVALID_VERIFY_SWITCH      118L

//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
//  The system does not support the command requested.
//
#define ERROR_BAD_DRIVER_LEVEL           119L

//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
//  This function is only valid in Win32 mode.
//
#define ERROR_CALL_NOT_IMPLEMENTED       120L

//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
//  The semaphore timeout period has expired.
//
#define ERROR_SEM_TIMEOUT                121L

//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The data area passed to a system call is too
//  small.
//
#define ERROR_INSUFFICIENT_BUFFER        122L    // dderror

//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
//  The filename, directory name, or volume label syntax is incorrect.
//
#define ERROR_INVALID_NAME               123L

//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
//  The system call level is not correct.
//
#define ERROR_INVALID_LEVEL              124L

//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
//  The disk has no volume label.
//
#define ERROR_NO_VOLUME_LABEL            125L

//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
//  The specified module could not be found.
//
#define ERROR_MOD_NOT_FOUND              126L

//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
//  The specified procedure could not be found.
//
#define ERROR_PROC_NOT_FOUND             127L

//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
//  There are no child processes to wait for.
//
#define ERROR_WAIT_NO_CHILDREN           128L

//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
//  The %1 application cannot be run in Win32 mode.
//
#define ERROR_CHILD_NOT_COMPLETE         129L

//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
//  Attempt to use a file handle to an open disk partition for an
//  operation other than raw disk I/O.
//
#define ERROR_DIRECT_ACCESS_HANDLE       130L

//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
//  An attempt was made to move the file pointer before the beginning of the file.
//
#define ERROR_NEGATIVE_SEEK              131L

//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
//  The file pointer cannot be set on the specified device or file.
//
#define ERROR_SEEK_ON_DEVICE             132L

//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
//  A JOIN or SUBST command
//  cannot be used for a drive that
//  contains previously joined drives.
//
#define ERROR_IS_JOIN_TARGET             133L

//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been joined.
//
#define ERROR_IS_JOINED                  134L

//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been substituted.
//
#define ERROR_IS_SUBSTED                 135L

//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
//  The system tried to delete
//  the JOIN of a drive that is not joined.
//
#define ERROR_NOT_JOINED                 136L

//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
//  The system tried to delete the
//  substitution of a drive that is not substituted.
//
#define ERROR_NOT_SUBSTED                137L

//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
//  The system tried to join a drive
//  to a directory on a joined drive.
//
#define ERROR_JOIN_TO_JOIN               138L

//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
//  The system tried to substitute a
//  drive to a directory on a substituted drive.
//
#define ERROR_SUBST_TO_SUBST             139L

//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
//  The system tried to join a drive to
//  a directory on a substituted drive.
//
#define ERROR_JOIN_TO_SUBST              140L

//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
//  The system tried to SUBST a drive
//  to a directory on a joined drive.
//
#define ERROR_SUBST_TO_JOIN              141L

//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
//  The system cannot perform a JOIN or SUBST at this time.
//
#define ERROR_BUSY_DRIVE                 142L

//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
//  The system cannot join or substitute a
//  drive to or for a directory on the same drive.
//
#define ERROR_SAME_DRIVE                 143L

//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
//  The directory is not a subdirectory of the root directory.
//
#define ERROR_DIR_NOT_ROOT               144L

//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
//  The directory is not empty.
//
#define ERROR_DIR_NOT_EMPTY              145L

//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
//  The path specified is being used in
//  a substitute.
//
#define ERROR_IS_SUBST_PATH              146L

//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
//  Not enough resources are available to
//  process this command.
//
#define ERROR_IS_JOIN_PATH               147L

//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
//  The path specified cannot be used at this time.
//
#define ERROR_PATH_BUSY                  148L

//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
//  An attempt was made to join
//  or substitute a drive for which a directory
//  on the drive is the target of a previous
//  substitute.
//
#define ERROR_IS_SUBST_TARGET            149L

//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
//  System trace information was not specified in your
//  CONFIG.SYS file, or tracing is disallowed.
//
#define ERROR_SYSTEM_TRACE               150L

//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
//  The number of specified semaphore events for
//  DosMuxSemWait is not correct.
//
#define ERROR_INVALID_EVENT_COUNT        151L

//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
//  DosMuxSemWait did not execute; too many semaphores
//  are already set.
//
#define ERROR_TOO_MANY_MUXWAITERS        152L

//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
//  The DosMuxSemWait list is not correct.
//
#define ERROR_INVALID_LIST_FORMAT        153L

//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
//  The volume label you entered exceeds the label character
//  limit of the target file system.
//
#define ERROR_LABEL_TOO_LONG             154L

//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
//  Cannot create another thread.
//
#define ERROR_TOO_MANY_TCBS              155L

//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
//  The recipient process has refused the signal.
//
#define ERROR_SIGNAL_REFUSED             156L

//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
//  The segment is already discarded and cannot be locked.
//
#define ERROR_DISCARDED                  157L

//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
//  The segment is already unlocked.
//
#define ERROR_NOT_LOCKED                 158L

//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
//  The address for the thread ID is not correct.
//
#define ERROR_BAD_THREADID_ADDR          159L

//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
//  The argument string passed to DosExecPgm is not correct.
//
#define ERROR_BAD_ARGUMENTS              160L

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//
#define ERROR_BAD_PATHNAME               161L

//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
//  A signal is already pending.
//
#define ERROR_SIGNAL_PENDING             162L

//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
//  No more threads can be created in the system.
//
#define ERROR_MAX_THRDS_REACHED          164L

//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
//  Unable to lock a region of a file.
//
#define ERROR_LOCK_FAILED                167L

//
// MessageId: ERROR_BUSY
//
// MessageText:
//
//  The requested resource is in use.
//
#define ERROR_BUSY                       170L

//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
//  A lock request was not outstanding for the supplied cancel region.
//
#define ERROR_CANCEL_VIOLATION           173L

//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
//  The file system does not support atomic changes to the lock type.
//
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174L

//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
//  The system detected a segment number that was not correct.
//
#define ERROR_INVALID_SEGMENT_NUMBER     180L

//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_ORDINAL            182L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS             183L

//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
//  The flag passed is not correct.
//
#define ERROR_INVALID_FLAG_NUMBER        186L

//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
//  The specified system semaphore name was not found.
//
#define ERROR_SEM_NOT_FOUND              187L

//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STARTING_CODESEG   188L

//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STACKSEG           189L

//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MODULETYPE         190L

//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
//  Cannot run %1 in Win32 mode.
//
#define ERROR_INVALID_EXE_SIGNATURE      191L

//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_EXE_MARKED_INVALID         192L

//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
//  %1 is not a valid Win32 application.
//
#define ERROR_BAD_EXE_FORMAT             193L

//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_ITERATED_DATA_EXCEEDS_64k  194L

//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MINALLOCSIZE       195L

//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_DYNLINK_FROM_INVALID_RING  196L

//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
//  The operating system is not presently
//  configured to run this application.
//
#define ERROR_IOPL_NOT_ENABLED           197L

//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_SEGDPL             198L

//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_AUTODATASEG_EXCEEDS_64k    199L

//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
//  The code segment cannot be greater than or equal to 64KB.
//
#define ERROR_RING2SEG_MUST_BE_MOVABLE   200L

//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM   201L

//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INFLOOP_IN_RELOC_CHAIN     202L

//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
//  The system could not find the environment
//  option that was entered.
//
#define ERROR_ENVVAR_NOT_FOUND           203L

//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
//  No process in the command subtree has a
//  signal handler.
//
#define ERROR_NO_SIGNAL_SENT             205L

//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
//  The filename or extension is too long.
//
#define ERROR_FILENAME_EXCED_RANGE       206L

//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
//  The ring 2 stack is in use.
//
#define ERROR_RING2_STACK_IN_USE         207L

//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
//  The global filename characters, * or ?, are entered
//  incorrectly or too many global filename characters are specified.
//
#define ERROR_META_EXPANSION_TOO_LONG    208L

//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
//  The signal being posted is not correct.
//
#define ERROR_INVALID_SIGNAL_NUMBER      209L

//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
//  The signal handler cannot be set.
//
#define ERROR_THREAD_1_INACTIVE          210L

//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
//  The segment is locked and cannot be reallocated.
//
#define ERROR_LOCKED                     212L

//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
//  Too many dynamic link modules are attached to this
//  program or dynamic link module.
//
#define ERROR_TOO_MANY_MODULES           214L

//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
//  Can't nest calls to LoadModule.
//
#define ERROR_NESTING_NOT_ALLOWED        215L

//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
//  The pipe state is invalid.
//
#define ERROR_BAD_PIPE                   230L

//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
//  All pipe instances are busy.
//
#define ERROR_PIPE_BUSY                  231L

//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
//  The pipe is being closed.
//
#define ERROR_NO_DATA                    232L

//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
//  No process is on the other end of the pipe.
//
#define ERROR_PIPE_NOT_CONNECTED         233L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
#define ERROR_MORE_DATA                  234L    // dderror

//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
//  The session was cancelled.
//
#define ERROR_VC_DISCONNECTED            240L

//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
//  The specified extended attribute name was invalid.
//
#define ERROR_INVALID_EA_NAME            254L

//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  The extended attributes are inconsistent.
//
#define ERROR_EA_LIST_INCONSISTENT       255L

//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more data is available.
//
#define ERROR_NO_MORE_ITEMS              259L

//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
//  The Copy API cannot be used.
//
#define ERROR_CANNOT_COPY                266L

//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
//  The directory name is invalid.
//
#define ERROR_DIRECTORY                  267L

//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
//  The extended attributes did not fit in the buffer.
//
#define ERROR_EAS_DIDNT_FIT              275L

//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
//  The extended attribute file on the mounted file system is corrupt.
//
#define ERROR_EA_FILE_CORRUPT            276L

//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
//  The extended attribute table file is full.
//
#define ERROR_EA_TABLE_FULL              277L

//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
//  The specified extended attribute handle is invalid.
//
#define ERROR_INVALID_EA_HANDLE          278L

//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  The mounted file system does not support extended attributes.
//
#define ERROR_EAS_NOT_SUPPORTED          282L

//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
//  Attempt to release mutex not owned by caller.
//
#define ERROR_NOT_OWNER                  288L

//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
//  Too many posts were made to a semaphore.
//
#define ERROR_TOO_MANY_POSTS             298L

//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
//  Only part of a Read/WriteProcessMemory request was completed.
//
#define ERROR_PARTIAL_COPY               299L

//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
//  The system cannot find message for message number 0x%1
//  in message file for %2.
//
#define ERROR_MR_MID_NOT_FOUND           317L

//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
//  Attempt to access invalid address.
//
#define ERROR_INVALID_ADDRESS            487L

//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
//  Arithmetic result exceeded 32 bits.
//
#define ERROR_ARITHMETIC_OVERFLOW        534L

//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
//  There is a process on other end of the pipe.
//
#define ERROR_PIPE_CONNECTED             535L

//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
//  Waiting for a process to open the other end of the pipe.
//
#define ERROR_PIPE_LISTENING             536L

//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
//  Access to the extended attribute was denied.
//
#define ERROR_EA_ACCESS_DENIED           994L

//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
//  The I/O operation has been aborted because of either a thread exit
//  or an application request.
//
#define ERROR_OPERATION_ABORTED          995L

//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
//  Overlapped I/O event is not in a signalled state.
//
#define ERROR_IO_INCOMPLETE              996L

//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
//  Overlapped I/O operation is in progress.
//
#define ERROR_IO_PENDING                 997L    // dderror

//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
//  Invalid access to memory location.
//
#define ERROR_NOACCESS                   998L

//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
//  Error performing inpage operation.
//
#define ERROR_SWAPERROR                  999L

//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
//  Recursion too deep, stack overflowed.
//
#define ERROR_STACK_OVERFLOW             1001L

//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
//  The window cannot act on the sent message.
//
#define ERROR_INVALID_MESSAGE            1002L

//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
//  Cannot complete this function.
//
#define ERROR_CAN_NOT_COMPLETE           1003L

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//
#define ERROR_INVALID_FLAGS              1004L

//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupt.
//
#define ERROR_UNRECOGNIZED_VOLUME        1005L

//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define ERROR_FILE_INVALID               1006L

//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in full-screen mode.
//
#define ERROR_FULLSCREEN_MODE            1007L

//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that does not exist.
//
#define ERROR_NO_TOKEN                   1008L

//
// MessageId: ERROR_BADDB
//
// MessageText:
//
//  The configuration registry database is corrupt.
//
#define ERROR_BADDB                      1009L

//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
//  The configuration registry key is invalid.
//
#define ERROR_BADKEY                     1010L

//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
//  The configuration registry key could not be opened.
//
#define ERROR_CANTOPEN                   1011L

//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
//  The configuration registry key could not be read.
//
#define ERROR_CANTREAD                   1012L

//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
//  The configuration registry key could not be written.
//
#define ERROR_CANTWRITE                  1013L

//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
//  One of the files in the Registry database had to be recovered
//  by use of a log or alternate copy.  The recovery was successful.
//
#define ERROR_REGISTRY_RECOVERED         1014L

//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
//  The Registry is corrupt. The structure of one of the files that contains
//  Registry data is corrupt, or the system's image of the file in memory
//  is corrupt, or the file could not be recovered because the alternate
//  copy or log was absent or corrupt.
//
#define ERROR_REGISTRY_CORRUPT           1015L

//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the Registry failed unrecoverably.
//  The Registry could not read in, or write out, or flush, one of the files
//  that contain the system's image of the Registry.
//
#define ERROR_REGISTRY_IO_FAILED         1016L

//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the Registry, but the
//  specified file is not in a Registry file format.
//
#define ERROR_NOT_REGISTRY_FILE          1017L

//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a Registry key which has been marked for deletion.
//
#define ERROR_KEY_DELETED                1018L

//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate the required space in a Registry log.
//
#define ERROR_NO_LOG_SPACE               1019L

//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
//  Cannot create a symbolic link in a Registry key that already
//  has subkeys or values.
//
#define ERROR_KEY_HAS_CHILDREN           1020L

//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  Cannot create a stable subkey under a volatile parent key.
//
#define ERROR_CHILD_MUST_BE_VOLATILE     1021L

//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  A notify change request is being completed and the information
//  is not being returned in the caller's buffer. The caller now
//  needs to enumerate the files to find the changes.
//
#define ERROR_NOTIFY_ENUM_DIR            1022L

//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
//  A stop control has been sent to a service which other running services
//  are dependent on.
//
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L

//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
//  The requested control is not valid for this service
//
#define ERROR_INVALID_SERVICE_CONTROL    1052L

//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
//  The service did not respond to the start or control request in a timely
//  fashion.
//
#define ERROR_SERVICE_REQUEST_TIMEOUT    1053L

//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
//  A thread could not be created for the service.
//
#define ERROR_SERVICE_NO_THREAD          1054L

//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
//  The service database is locked.
//
#define ERROR_SERVICE_DATABASE_LOCKED    1055L

//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  An instance of the service is already running.
//
#define ERROR_SERVICE_ALREADY_RUNNING    1056L

//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account name is invalid or does not exist.
//
#define ERROR_INVALID_SERVICE_ACCOUNT    1057L

//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
//  The specified service is disabled and cannot be started.
//
#define ERROR_SERVICE_DISABLED           1058L

//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
//  Circular service dependency was specified.
//
#define ERROR_CIRCULAR_DEPENDENCY        1059L

//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified service does not exist as an installed service.
//
#define ERROR_SERVICE_DOES_NOT_EXIST     1060L

//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
//  The service cannot accept control messages at this time.
//
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L

//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
//  The service has not been started.
//
#define ERROR_SERVICE_NOT_ACTIVE         1062L

//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
//  The service process could not connect to the service controller.
//
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063L

//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
//  An exception occurred in the service when handling the control request.
//
#define ERROR_EXCEPTION_IN_SERVICE       1064L

//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
//  The database specified does not exist.
//
#define ERROR_DATABASE_DOES_NOT_EXIST    1065L

//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
//  The service has returned a service-specific error code.
//
#define ERROR_SERVICE_SPECIFIC_ERROR     1066L

//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
//  The process terminated unexpectedly.
//
#define ERROR_PROCESS_ABORTED            1067L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
//  The dependency service or group failed to start.
//
#define ERROR_SERVICE_DEPENDENCY_FAIL    1068L

//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
//  The service did not start due to a logon failure.
//
#define ERROR_SERVICE_LOGON_FAILED       1069L

//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
//  After starting, the service hung in a start-pending state.
//
#define ERROR_SERVICE_START_HANG         1070L

//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
//  The specified service database lock is invalid.
//
#define ERROR_INVALID_SERVICE_LOCK       1071L

//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
//  The specified service has been marked for deletion.
//
#define ERROR_SERVICE_MARKED_FOR_DELETE  1072L

//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
//  The specified service already exists.
//
#define ERROR_SERVICE_EXISTS             1073L

//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
//  The system is currently running with the last-known-good configuration.
//
#define ERROR_ALREADY_RUNNING_LKG        1074L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
//  The dependency service does not exist or has been marked for
//  deletion.
//
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L

//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
//  The current boot has already been accepted for use as the
//  last-known-good control set.
//
#define ERROR_BOOT_ALREADY_ACCEPTED      1076L

//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
//  No attempts to start the service have been made since the last boot.
//
#define ERROR_SERVICE_NEVER_STARTED      1077L

//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
//  The name is already in use as either a service name or a service display
//  name.
//
#define ERROR_DUPLICATE_SERVICE_NAME     1078L

//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
//  The physical end of the tape has been reached.
//
#define ERROR_END_OF_MEDIA               1100L

//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a filemark.
//
#define ERROR_FILEMARK_DETECTED          1101L

//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  Beginning of tape or partition was encountered.
//
#define ERROR_BEGINNING_OF_MEDIA         1102L

//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached the end of a set of files.
//
#define ERROR_SETMARK_DETECTED           1103L

//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
//  No more data is on the tape.
//
#define ERROR_NO_DATA_DETECTED           1104L

//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//
#define ERROR_PARTITION_FAILURE          1105L

//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current
//  blocksize is incorrect.
//
#define ERROR_INVALID_BLOCK_LENGTH       1106L

//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//
#define ERROR_DEVICE_NOT_PARTITIONED     1107L

//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Unable to lock the media eject mechanism.
//
#define ERROR_UNABLE_TO_LOCK_MEDIA       1108L

//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unable to unload the media.
//
#define ERROR_UNABLE_TO_UNLOAD_MEDIA     1109L

//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
//  Media in drive may have changed.
//
#define ERROR_MEDIA_CHANGED              1110L

//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
//  The I/O bus was reset.
//
#define ERROR_BUS_RESET                  1111L

//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
//  No media in drive.
//
#define ERROR_NO_MEDIA_IN_DRIVE          1112L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION     1113L

//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
//  A dynamic link library (DLL) initialization routine failed.
//
#define ERROR_DLL_INIT_FAILED            1114L

//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  A system shutdown is in progress.
//
#define ERROR_SHUTDOWN_IN_PROGRESS       1115L

//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  Unable to abort the system shutdown because no shutdown was in progress.
//
#define ERROR_NO_SHUTDOWN_IN_PROGRESS    1116L

//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
//  The request could not be performed because of an I/O device error.
//
#define ERROR_IO_DEVICE                  1117L

//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
//  No serial device was successfully initialized.  The serial driver will unload.
//
#define ERROR_SERIAL_NO_DEVICE           1118L

//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
//  Unable to open a device that was sharing an interrupt request (IRQ)
//  with other devices. At least one other device that uses that IRQ
//  was already opened.
//
#define ERROR_IRQ_BUSY                   1119L

//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
//  A serial I/O operation was completed by another write to the serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define ERROR_MORE_WRITES                1120L

//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
//  A serial I/O operation completed because the time-out period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//
#define ERROR_COUNTER_TIMEOUT            1121L

//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  No ID address mark was found on the floppy disk.
//
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND   1122L

//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  Mismatch between the floppy disk sector ID field and the floppy disk
//  controller track address.
//
#define ERROR_FLOPPY_WRONG_CYLINDER      1123L

//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  The floppy disk controller reported an error that is not recognized
//  by the floppy disk driver.
//
#define ERROR_FLOPPY_UNKNOWN_ERROR       1124L

//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  The floppy disk controller returned inconsistent results in its registers.
//
#define ERROR_FLOPPY_BAD_REGISTERS       1125L

//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define ERROR_DISK_RECALIBRATE_FAILED    1126L

//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk operation failed even after retries.
//
#define ERROR_DISK_OPERATION_FAILED      1127L

//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk controller reset was needed, but
//  even that failed.
//
#define ERROR_DISK_RESET_FAILED          1128L

//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape encountered.
//
#define ERROR_EOM_OVERFLOW               1129L

//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
//  Not enough server storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_SERVER_MEMORY   1130L

//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  A potential deadlock condition has been detected.
//
#define ERROR_POSSIBLE_DEADLOCK          1131L

//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
//  The base address or the file offset specified does not have the proper
//  alignment.
//
#define ERROR_MAPPED_ALIGNMENT           1132L

//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
//  An attempt to change the system power state was vetoed by another
//  application or driver.
//
#define ERROR_SET_POWER_STATE_VETOED     1140L

//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
//  The system BIOS failed an attempt to change the system power state.
//
#define ERROR_SET_POWER_STATE_FAILED     1141L

//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
//  The specified program requires a newer version of Windows.
//
#define ERROR_OLD_WIN_VERSION            1150L

//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
//  The specified program is not a Windows or MS-DOS program.
//
#define ERROR_APP_WRONG_OS               1151L

//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
//  Cannot start more than one instance of the specified program.
//
#define ERROR_SINGLE_INSTANCE_APP        1152L

//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
//  The specified program was written for an older version of Windows.
//
#define ERROR_RMODE_APP                  1153L

//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
//  One of the library files needed to run this application is damaged.
//
#define ERROR_INVALID_DLL                1154L

//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
//  No application is associated with the specified file for this operation.
//
#define ERROR_NO_ASSOCIATION             1155L

//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
//  An error occurred in sending the command to the application.
//
#define ERROR_DDE_FAIL                   1156L

//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
//  One of the library files needed to run this application cannot be found.
//
#define ERROR_DLL_NOT_FOUND              1157L




///////////////////////////
//                       //
// Winnet32 Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
//  The specified username is invalid.
//
#define ERROR_BAD_USERNAME               2202L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//
#define ERROR_NOT_CONNECTED              2250L

//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
//  This network connection has files open or requests pending.
//
#define ERROR_OPEN_FILES                 2401L

//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
//  Active connections still exist.
//
#define ERROR_ACTIVE_CONNECTIONS         2402L

//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
//  The device is in use by an active process and cannot be disconnected.
//
#define ERROR_DEVICE_IN_USE              2404L

//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
//  The specified device name is invalid.
//
#define ERROR_BAD_DEVICE                 1200L

//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
//  The device is not currently connected but it is a remembered connection.
//
#define ERROR_CONNECTION_UNAVAIL         1201L

//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
//  An attempt was made to remember a device that had previously been remembered.
//
#define ERROR_DEVICE_ALREADY_REMEMBERED  1202L

//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
//  No network provider accepted the given network path.
//
#define ERROR_NO_NET_OR_BAD_PATH         1203L

//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
//  The specified network provider name is invalid.
//
#define ERROR_BAD_PROVIDER               1204L

//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
//  Unable to open the network connection profile.
//
#define ERROR_CANNOT_OPEN_PROFILE        1205L

//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
//  The network connection profile is corrupt.
//
#define ERROR_BAD_PROFILE                1206L

//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
//  Cannot enumerate a non-container.
//
#define ERROR_NOT_CONTAINER              1207L

//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
//  An extended error has occurred.
//
#define ERROR_EXTENDED_ERROR             1208L

//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
//  The format of the specified group name is invalid.
//
#define ERROR_INVALID_GROUPNAME          1209L

//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
//  The format of the specified computer name is invalid.
//
#define ERROR_INVALID_COMPUTERNAME       1210L

//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
//  The format of the specified event name is invalid.
//
#define ERROR_INVALID_EVENTNAME          1211L

//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
//  The format of the specified domain name is invalid.
//
#define ERROR_INVALID_DOMAINNAME         1212L

//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
//  The format of the specified service name is invalid.
//
#define ERROR_INVALID_SERVICENAME        1213L

//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
//  The format of the specified network name is invalid.
//
#define ERROR_INVALID_NETNAME            1214L

//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
//  The format of the specified share name is invalid.
//
#define ERROR_INVALID_SHARENAME          1215L

//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
//  The format of the specified password is invalid.
//
#define ERROR_INVALID_PASSWORDNAME       1216L

//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
//  The format of the specified message name is invalid.
//
#define ERROR_INVALID_MESSAGENAME        1217L

//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
//  The format of the specified message destination is invalid.
//
#define ERROR_INVALID_MESSAGEDEST        1218L

//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219L

//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to establish a session to a network server, but there
//  are already too many sessions established to that server.
//
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220L

//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
//  The workgroup or domain name is already in use by another computer on the
//  network.
//
#define ERROR_DUP_DOMAINNAME             1221L

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//
#define ERROR_NO_NETWORK                 1222L

//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
//  The operation was cancelled by the user.
//
#define ERROR_CANCELLED                  1223L

//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
//  The requested operation cannot be performed on a file with a user mapped section open.
//
#define ERROR_USER_MAPPED_FILE           1224L

//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
//  The remote system refused the network connection.
//
#define ERROR_CONNECTION_REFUSED         1225L

//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
//  The network connection was gracefully closed.
//
#define ERROR_GRACEFUL_DISCONNECT        1226L

//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
//  The network transport endpoint already has an address associated with it.
//
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227L

//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
//  An address has not yet been associated with the network endpoint.
//
#define ERROR_ADDRESS_NOT_ASSOCIATED     1228L

//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
//  An operation was attempted on a non-existent network connection.
//
#define ERROR_CONNECTION_INVALID         1229L

//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
//  An invalid operation was attempted on an active network connection.
//
#define ERROR_CONNECTION_ACTIVE          1230L

//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
//  The remote network is not reachable by the transport.
//
#define ERROR_NETWORK_UNREACHABLE        1231L

//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
//  The remote system is not reachable by the transport.
//
#define ERROR_HOST_UNREACHABLE           1232L

//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
//  The remote system does not support the transport protocol.
//
#define ERROR_PROTOCOL_UNREACHABLE       1233L

//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
//  No service is operating at the destination network endpoint
//  on the remote system.
//
#define ERROR_PORT_UNREACHABLE           1234L

//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
//  The request was aborted.
//
#define ERROR_REQUEST_ABORTED            1235L

//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
//  The network connection was aborted by the local system.
//
#define ERROR_CONNECTION_ABORTED         1236L

//
// MessageId: ERROR_RETRY
//
// MessageText:
//
//  The operation could not be completed.  A retry should be performed.
//
#define ERROR_RETRY                      1237L

//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
//  A connection to the server could not be made because the limit on the number of
//  concurrent connections for this account has been reached.
//
#define ERROR_CONNECTION_COUNT_LIMIT     1238L

//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
//  Attempting to login during an unauthorized time of day for this account.
//
#define ERROR_LOGIN_TIME_RESTRICTION     1239L

//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
//  The account is not authorized to login from this station.
//
#define ERROR_LOGIN_WKSTA_RESTRICTION    1240L

//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
//  The network address could not be used for the operation requested.
//
#define ERROR_INCORRECT_ADDRESS          1241L

//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
//  The service is already registered.
//
#define ERROR_ALREADY_REGISTERED         1242L

//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
//  The specified service does not exist.
//
#define ERROR_SERVICE_NOT_FOUND          1243L

//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not been authenticated.
//
#define ERROR_NOT_AUTHENTICATED          1244L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not logged on to the network.
//  The specified service does not exist.
//
#define ERROR_NOT_LOGGED_ON              1245L

//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
//  Return that wants caller to continue with work in progress.
//
#define ERROR_CONTINUE                   1246L

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when
//  initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED        1247L

//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
//  No more local devices.
//
#define ERROR_NO_MORE_DEVICES            1248L




///////////////////////////
//                       //
// Security Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Not all privileges referenced are assigned to the caller.
//
#define ERROR_NOT_ALL_ASSIGNED           1300L

//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some mapping between account names and security IDs was not done.
//
#define ERROR_SOME_NOT_MAPPED            1301L

//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  No system quota limits are specifically set for this account.
//
#define ERROR_NO_QUOTAS_FOR_ACCOUNT      1302L

//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  No encryption key is available.  A well-known encryption key was returned.
//
#define ERROR_LOCAL_USER_SESSION_KEY     1303L

//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
//  The NT password is too complex to be converted to a LAN Manager
//  password.  The LAN Manager password returned is a NULL string.
//
#define ERROR_NULL_LM_PASSWORD           1304L

//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
//  The revision level is unknown.
//
#define ERROR_UNKNOWN_REVISION           1305L

//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//
#define ERROR_REVISION_MISMATCH          1306L

//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
//  This security ID may not be assigned as the owner of this object.
//
#define ERROR_INVALID_OWNER              1307L

//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  This security ID may not be assigned as the primary group of an object.
//
#define ERROR_INVALID_PRIMARY_GROUP      1308L

//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token
//  by a thread that is not currently impersonating a client.
//
#define ERROR_NO_IMPERSONATION_TOKEN     1309L

//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  The group may not be disabled.
//
#define ERROR_CANT_DISABLE_MANDATORY     1310L

//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon
//  request.
//
#define ERROR_NO_LOGON_SERVERS           1311L

//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//   A specified logon session does not exist.  It may already have
//   been terminated.
//
#define ERROR_NO_SUCH_LOGON_SESSION      1312L

//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//   A specified privilege does not exist.
//
#define ERROR_NO_SUCH_PRIVILEGE          1313L

//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//   A required privilege is not held by the client.
//
#define ERROR_PRIVILEGE_NOT_HELD         1314L

//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//
#define ERROR_INVALID_ACCOUNT_NAME       1315L

//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//
#define ERROR_USER_EXISTS                1316L

//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//
#define ERROR_NO_SUCH_USER               1317L

//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//
#define ERROR_GROUP_EXISTS               1318L

//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//
#define ERROR_NO_SUCH_GROUP              1319L

//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
//  Either the specified user account is already a member of the specified
//  group, or the specified group cannot be deleted because it contains
//  a member.
//
#define ERROR_MEMBER_IN_GROUP            1320L

//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//
#define ERROR_MEMBER_NOT_IN_GROUP        1321L

//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
//  The last remaining administration account cannot be disabled
//  or deleted.
//
#define ERROR_LAST_ADMIN                 1322L

//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided as the current
//  password is incorrect.
//
#define ERROR_WRONG_PASSWORD             1323L

//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided for the new password
//  contains values that are not allowed in passwords.
//
#define ERROR_ILL_FORMED_PASSWORD        1324L

//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
//  Unable to update the password because a password update rule has been
//  violated.
//
#define ERROR_PASSWORD_RESTRICTION       1325L

//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
//  Logon failure: unknown user name or bad password.
//
#define ERROR_LOGON_FAILURE              1326L

//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Logon failure: user account restriction.
//
#define ERROR_ACCOUNT_RESTRICTION        1327L

//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
//  Logon failure: account logon time restriction violation.
//
#define ERROR_INVALID_LOGON_HOURS        1328L

//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
//  Logon failure: user not allowed to log on to this computer.
//
#define ERROR_INVALID_WORKSTATION        1329L

//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
//  Logon failure: the specified account password has expired.
//
#define ERROR_PASSWORD_EXPIRED           1330L

//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
//  Logon failure: account currently disabled.
//
#define ERROR_ACCOUNT_DISABLED           1331L

//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
//  No mapping between account names and security IDs was done.
//
#define ERROR_NONE_MAPPED                1332L

//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  Too many local user identifiers (LUIDs) were requested at one time.
//
#define ERROR_TOO_MANY_LUIDS_REQUESTED   1333L

//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
//  No more local user identifiers (LUIDs) are available.
//
#define ERROR_LUIDS_EXHAUSTED            1334L

//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  The subauthority part of a security ID is invalid for this particular use.
//
#define ERROR_INVALID_SUB_AUTHORITY      1335L

//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
//  The access control list (ACL) structure is invalid.
//
#define ERROR_INVALID_ACL                1336L

//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
//  The security ID structure is invalid.
//
#define ERROR_INVALID_SID                1337L

//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  The security descriptor structure is invalid.
//
#define ERROR_INVALID_SECURITY_DESCR     1338L

//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  The inherited access control list (ACL) or access control entry (ACE)
//  could not be built.
//
#define ERROR_BAD_INHERITANCE_ACL        1340L

//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
//  The server is currently disabled.
//
#define ERROR_SERVER_DISABLED            1341L

//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The server is currently enabled.
//
#define ERROR_SERVER_NOT_DISABLED        1342L

//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//
#define ERROR_INVALID_ID_AUTHORITY       1343L

//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  No more memory is available for security information updates.
//
#define ERROR_ALLOTTED_SPACE_EXCEEDED    1344L

//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the
//  attributes for the group as a whole.
//
#define ERROR_INVALID_GROUP_ATTRIBUTES   1345L

//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  Either a required impersonation level was not provided, or the
//  provided impersonation level is invalid.
//
#define ERROR_BAD_IMPERSONATION_LEVEL    1346L

//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  Cannot open an anonymous level security token.
//
#define ERROR_CANT_OPEN_ANONYMOUS        1347L

//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//
#define ERROR_BAD_VALIDATION_CLASS       1348L

//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token is inappropriate for its attempted use.
//
#define ERROR_BAD_TOKEN_TYPE             1349L

//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Unable to perform a security operation on an object
//  which has no associated security.
//
#define ERROR_NO_SECURITY_ON_OBJECT      1350L

//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Indicates a Windows NT Server could not be contacted or that
//  objects within the domain are protected such that necessary
//  information could not be retrieved.
//
#define ERROR_CANT_ACCESS_DOMAIN_INFO    1351L

//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
//  The security account manager (SAM) or local security
//  authority (LSA) server was in the wrong state to perform
//  the security operation.
//
#define ERROR_INVALID_SERVER_STATE       1352L

//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  The domain was in the wrong state to perform the security operation.
//
#define ERROR_INVALID_DOMAIN_STATE       1353L

//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define ERROR_INVALID_DOMAIN_ROLE        1354L

//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified domain did not exist.
//
#define ERROR_NO_SUCH_DOMAIN             1355L

//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified domain already exists.
//
#define ERROR_DOMAIN_EXISTS              1356L

//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server.
//
#define ERROR_DOMAIN_LIMIT_EXCEEDED      1357L

//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  Unable to complete the requested operation because of either a
//  catastrophic media failure or a data structure corruption on the disk.
//
#define ERROR_INTERNAL_DB_CORRUPTION     1358L

//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
//  The security account database contains an internal inconsistency.
//
#define ERROR_INTERNAL_ERROR             1359L

//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Generic access types were contained in an access mask which should
//  already be mapped to non-generic types.
//
#define ERROR_GENERIC_NOT_MAPPED         1360L

//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  A security descriptor is not in the right format (absolute or self-relative).
//
#define ERROR_BAD_DESCRIPTOR_FORMAT      1361L

//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes
//  only.  The calling process has not registered as a logon process.
//
#define ERROR_NOT_LOGON_PROCESS          1362L

//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  Cannot start a new logon session with an ID that is already in use.
//
#define ERROR_LOGON_SESSION_EXISTS       1363L

//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//
#define ERROR_NO_SUCH_PACKAGE            1364L

//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the
//  requested operation.
//
#define ERROR_BAD_LOGON_SESSION_STATE    1365L

//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  The logon session ID is already in use.
//
#define ERROR_LOGON_SESSION_COLLISION    1366L

//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
//  A logon request contained an invalid logon type value.
//
#define ERROR_INVALID_LOGON_TYPE         1367L

//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Unable to impersonate via a named pipe until data has been read
//  from that pipe.
//
#define ERROR_CANNOT_IMPERSONATE         1368L

//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
//  The transaction state of a Registry subtree is incompatible with the
//  requested operation.
//
#define ERROR_RXACT_INVALID_STATE        1369L

//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
//  An internal security database corruption has been encountered.
//
#define ERROR_RXACT_COMMIT_FAILURE       1370L

//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Cannot perform this operation on built-in accounts.
//
#define ERROR_SPECIAL_ACCOUNT            1371L

//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
//  Cannot perform this operation on this built-in special group.
//
#define ERROR_SPECIAL_GROUP              1372L

//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
//  Cannot perform this operation on this built-in special user.
//
#define ERROR_SPECIAL_USER               1373L

//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  The user cannot be removed from a group because the group
//  is currently the user's primary group.
//
#define ERROR_MEMBERS_PRIMARY_GROUP      1374L

//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  The token is already in use as a primary token.
//
#define ERROR_TOKEN_ALREADY_IN_USE       1375L

//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//
#define ERROR_NO_SUCH_ALIAS              1376L

//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//
#define ERROR_MEMBER_NOT_IN_ALIAS        1377L

//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//
#define ERROR_MEMBER_IN_ALIAS            1378L

//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//
#define ERROR_ALIAS_EXISTS               1379L

//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested
//  logon type at this computer.
//
#define ERROR_LOGON_NOT_GRANTED          1380L

//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been
//  exceeded.
//
#define ERROR_TOO_MANY_SECRETS           1381L

//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed.
//
#define ERROR_SECRET_TOO_LONG            1382L

//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The local security authority database contains an internal inconsistency.
//
#define ERROR_INTERNAL_DB_ERROR          1383L

//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many
//  security IDs.
//
#define ERROR_TOO_MANY_CONTEXT_IDS       1384L

//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested logon type
//  at this computer.
//
#define ERROR_LOGON_TYPE_NOT_GRANTED     1385L

//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change a user password.
//
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386L

//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member does
//  not exist.
//
#define ERROR_NO_SUCH_MEMBER             1387L

//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member has the
//  wrong account type.
//
#define ERROR_INVALID_MEMBER             1388L

//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many security IDs have been specified.
//
#define ERROR_TOO_MANY_SIDS              1389L

//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change this user password.
//
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390L

//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
//  Indicates an ACL contains no inheritable components
//
#define ERROR_NO_INHERITANCE             1391L

//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
//  The file or directory is corrupt and non-readable.
//
#define ERROR_FILE_CORRUPT               1392L

//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
//  The disk structure is corrupt and non-readable.
//
#define ERROR_DISK_CORRUPT               1393L

//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//
#define ERROR_NO_USER_SESSION_KEY        1394L

//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The service being accessed is licensed for a particular number of
//  connections. No more connections can be made to the service at this time
//  because there are already as many connections as the service can accept.
//
#define ERROR_LICENSE_QUOTA_EXCEEDED     1395L

// End of security error codes



///////////////////////////
//                       //
// WinUser Error Codes   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
//  Invalid window handle.
//
#define ERROR_INVALID_WINDOW_HANDLE      1400L

//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
//  Invalid menu handle.
//
#define ERROR_INVALID_MENU_HANDLE        1401L

//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
//  Invalid cursor handle.
//
#define ERROR_INVALID_CURSOR_HANDLE      1402L

//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
//  Invalid accelerator table handle.
//
#define ERROR_INVALID_ACCEL_HANDLE       1403L

//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
//  Invalid hook handle.
//
#define ERROR_INVALID_HOOK_HANDLE        1404L

//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
//  Invalid handle to a multiple-window position structure.
//
#define ERROR_INVALID_DWP_HANDLE         1405L

//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
//  Cannot create a top-level child window.
//
#define ERROR_TLW_WITH_WSCHILD           1406L

//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
//  Cannot find window class.
//
#define ERROR_CANNOT_FIND_WND_CLASS      1407L

//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
//  Invalid window, belongs to other thread.
//
#define ERROR_WINDOW_OF_OTHER_THREAD     1408L

//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
//  Hot key is already registered.
//
#define ERROR_HOTKEY_ALREADY_REGISTERED  1409L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS       1410L

//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
//  Class does not exist.
//
#define ERROR_CLASS_DOES_NOT_EXIST       1411L

//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
//  Class still has open windows.
//
#define ERROR_CLASS_HAS_WINDOWS          1412L

//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
//  Invalid index.
//
#define ERROR_INVALID_INDEX              1413L

//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
//  Invalid icon handle.
//
#define ERROR_INVALID_ICON_HANDLE        1414L

//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
//  Using private DIALOG window words.
//
#define ERROR_PRIVATE_DIALOG_INDEX       1415L

//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
//  The listbox identifier was not found.
//
#define ERROR_LISTBOX_ID_NOT_FOUND       1416L

//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
//  No wildcards were found.
//
#define ERROR_NO_WILDCARD_CHARACTERS     1417L

//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
//  Thread does not have a clipboard open.
//
#define ERROR_CLIPBOARD_NOT_OPEN         1418L

//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
//  Hot key is not registered.
//
#define ERROR_HOTKEY_NOT_REGISTERED      1419L

//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
//  The window is not a valid dialog window.
//
#define ERROR_WINDOW_NOT_DIALOG          1420L

//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
//  Control ID not found.
//
#define ERROR_CONTROL_ID_NOT_FOUND       1421L

//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
//  Invalid message for a combo box because it does not have an edit control.
//
#define ERROR_INVALID_COMBOBOX_MESSAGE   1422L

//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
//  The window is not a combo box.
//
#define ERROR_WINDOW_NOT_COMBOBOX        1423L

//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
//  Height must be less than 256.
//
#define ERROR_INVALID_EDIT_HEIGHT        1424L

//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
//  Invalid device context (DC) handle.
//
#define ERROR_DC_NOT_FOUND               1425L

//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
//  Invalid hook procedure type.
//
#define ERROR_INVALID_HOOK_FILTER        1426L

//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
//  Invalid hook procedure.
//
#define ERROR_INVALID_FILTER_PROC        1427L

//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
//  Cannot set non-local hook without a module handle.
//
#define ERROR_HOOK_NEEDS_HMOD            1428L

//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
//  This hook procedure can only be set globally.
//
#define ERROR_GLOBAL_ONLY_HOOK           1429L

//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
//  The journal hook procedure is already installed.
//
#define ERROR_JOURNAL_HOOK_SET           1430L

//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
//  The hook procedure is not installed.
//
#define ERROR_HOOK_NOT_INSTALLED         1431L

//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
//  Invalid message for single-selection listbox.
//
#define ERROR_INVALID_LB_MESSAGE         1432L

//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
//  LB_SETCOUNT sent to non-lazy listbox.
//
#define ERROR_SETCOUNT_ON_BAD_LB         1433L

//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
//  This list box does not support tab stops.
//
#define ERROR_LB_WITHOUT_TABSTOPS        1434L

//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
//  Cannot destroy object created by another thread.
//
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435L

//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
//  Child windows cannot have menus.
//
#define ERROR_CHILD_WINDOW_MENU          1436L

//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
//  The window does not have a system menu.
//
#define ERROR_NO_SYSTEM_MENU             1437L

//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
//  Invalid message box style.
//
#define ERROR_INVALID_MSGBOX_STYLE       1438L

//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
//  Invalid system-wide (SPI_*) parameter.
//
#define ERROR_INVALID_SPI_VALUE          1439L

//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
//  Screen already locked.
//
#define ERROR_SCREEN_ALREADY_LOCKED      1440L

//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
//  All handles to windows in a multiple-window position structure must
//  have the same parent.
//
#define ERROR_HWNDS_HAVE_DIFF_PARENT     1441L

//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
//  The window is not a child window.
//
#define ERROR_NOT_CHILD_WINDOW           1442L

//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
//  Invalid GW_* command.
//
#define ERROR_INVALID_GW_COMMAND         1443L

//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
//  Invalid thread identifier.
//
#define ERROR_INVALID_THREAD_ID          1444L

//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
//  Cannot process a message from a window that is not a multiple document
//  interface (MDI) window.
//
#define ERROR_NON_MDICHILD_WINDOW        1445L

//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
//  Popup menu already active.
//
#define ERROR_POPUP_ALREADY_ACTIVE       1446L

//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
//  The window does not have scroll bars.
//
#define ERROR_NO_SCROLLBARS              1447L

//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
//  Scroll bar range cannot be greater than 0x7FFF.
//
#define ERROR_INVALID_SCROLLBAR_RANGE    1448L

//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
//  Cannot show or remove the window in the way specified.
//
#define ERROR_INVALID_SHOWWIN_COMMAND    1449L

//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_NO_SYSTEM_RESOURCES        1450L

//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_NONPAGED_SYSTEM_RESOURCES  1451L

//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_PAGED_SYSTEM_RESOURCES     1452L

//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//
#define ERROR_WORKING_SET_QUOTA          1453L

//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//
#define ERROR_PAGEFILE_QUOTA             1454L

//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
//  The paging file is too small for this operation to complete.
//
#define ERROR_COMMITMENT_LIMIT           1455L

//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
//  A menu item was not found.
//
#define ERROR_MENU_ITEM_NOT_FOUND        1456L

// End of WinUser error codes



///////////////////////////
//                       //
// Eventlog Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The event log file is corrupt.
//
#define ERROR_EVENTLOG_FILE_CORRUPT      1500L

//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
//  No event log file could be opened, so the event logging service did not start.
//
#define ERROR_EVENTLOG_CANT_START        1501L

//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
//  The event log file is full.
//
#define ERROR_LOG_FILE_FULL              1502L

//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The event log file has changed between reads.
//
#define ERROR_EVENTLOG_FILE_CHANGED      1503L

// End of eventlog error codes



///////////////////////////
//                       //
//   RPC Status Codes    //
//                       //
///////////////////////////


//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
//  The string binding is invalid.
//
#define RPC_S_INVALID_STRING_BINDING     1700L

//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
//  The binding handle is not the correct type.
//
#define RPC_S_WRONG_KIND_OF_BINDING      1701L

//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
//  The binding handle is invalid.
//
#define RPC_S_INVALID_BINDING            1702L

//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
//  The RPC protocol sequence is not supported.
//
#define RPC_S_PROTSEQ_NOT_SUPPORTED      1703L

//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
//  The RPC protocol sequence is invalid.
//
#define RPC_S_INVALID_RPC_PROTSEQ        1704L

//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
//  The string universal unique identifier (UUID) is invalid.
//
#define RPC_S_INVALID_STRING_UUID        1705L

//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
//  The endpoint format is invalid.
//
#define RPC_S_INVALID_ENDPOINT_FORMAT    1706L

//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
//  The network address is invalid.
//
#define RPC_S_INVALID_NET_ADDR           1707L

//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
//  No endpoint was found.
//
#define RPC_S_NO_ENDPOINT_FOUND          1708L

//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
//  The timeout value is invalid.
//
#define RPC_S_INVALID_TIMEOUT            1709L

//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object universal unique identifier (UUID) was not found.
//
#define RPC_S_OBJECT_NOT_FOUND           1710L

//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
//  The object universal unique identifier (UUID) has already been registered.
//
#define RPC_S_ALREADY_REGISTERED         1711L

//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
//  The type universal unique identifier (UUID) has already been registered.
//
#define RPC_S_TYPE_ALREADY_REGISTERED    1712L

//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
//  The RPC server is already listening.
//
#define RPC_S_ALREADY_LISTENING          1713L

//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
//  No protocol sequences have been registered.
//
#define RPC_S_NO_PROTSEQS_REGISTERED     1714L

//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening.
//
#define RPC_S_NOT_LISTENING              1715L

//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
//  The manager type is unknown.
//
#define RPC_S_UNKNOWN_MGR_TYPE           1716L

//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
//  The interface is unknown.
//
#define RPC_S_UNKNOWN_IF                 1717L

//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
//  There are no bindings.
//
#define RPC_S_NO_BINDINGS                1718L

//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
//  There are no protocol sequences.
//
#define RPC_S_NO_PROTSEQS                1719L

//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
//  The endpoint cannot be created.
//
#define RPC_S_CANT_CREATE_ENDPOINT       1720L

//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
//  Not enough resources are available to complete this operation.
//
#define RPC_S_OUT_OF_RESOURCES           1721L

//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The RPC server is unavailable.
//
#define RPC_S_SERVER_UNAVAILABLE         1722L

//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
//  The RPC server is too busy to complete this operation.
//
#define RPC_S_SERVER_TOO_BUSY            1723L

//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
//  The network options are invalid.
//
#define RPC_S_INVALID_NETWORK_OPTIONS    1724L

//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
//  There is not a remote procedure call active in this thread.
//
#define RPC_S_NO_CALL_ACTIVE             1725L

//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
//  The remote procedure call failed.
//
#define RPC_S_CALL_FAILED                1726L

//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
//  The remote procedure call failed and did not execute.
//
#define RPC_S_CALL_FAILED_DNE            1727L

//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
//  A remote procedure call (RPC) protocol error occurred.
//
#define RPC_S_PROTOCOL_ERROR             1728L

//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
//  The transfer syntax is not supported by the RPC server.
//
#define RPC_S_UNSUPPORTED_TRANS_SYN      1730L

//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
//  The universal unique identifier (UUID) type is not supported.
//
#define RPC_S_UNSUPPORTED_TYPE           1732L

//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
//  The tag is invalid.
//
#define RPC_S_INVALID_TAG                1733L

//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
//  The array bounds are invalid.
//
#define RPC_S_INVALID_BOUND              1734L

//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
//  The binding does not contain an entry name.
//
#define RPC_S_NO_ENTRY_NAME              1735L

//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is invalid.
//
#define RPC_S_INVALID_NAME_SYNTAX        1736L

//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is not supported.
//
#define RPC_S_UNSUPPORTED_NAME_SYNTAX    1737L

//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
//  No network address is available to use to construct a universal
//  unique identifier (UUID).
//
#define RPC_S_UUID_NO_ADDRESS            1739L

//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
//  The endpoint is a duplicate.
//
#define RPC_S_DUPLICATE_ENDPOINT         1740L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
//  The authentication type is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_TYPE         1741L

//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
//  The maximum number of calls is too small.
//
#define RPC_S_MAX_CALLS_TOO_SMALL        1742L

//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
//  The string is too long.
//
#define RPC_S_STRING_TOO_LONG            1743L

//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
//  The RPC protocol sequence was not found.
//
#define RPC_S_PROTSEQ_NOT_FOUND          1744L

//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
//  The procedure number is out of range.
//
#define RPC_S_PROCNUM_OUT_OF_RANGE       1745L

//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
//  The binding does not contain any authentication information.
//
#define RPC_S_BINDING_HAS_NO_AUTH        1746L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
//  The authentication service is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_SERVICE      1747L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
//  The authentication level is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_LEVEL        1748L

//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
//  The security context is invalid.
//
#define RPC_S_INVALID_AUTH_IDENTITY      1749L

//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
//  The authorization service is unknown.
//
#define RPC_S_UNKNOWN_AUTHZ_SERVICE      1750L

//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
//  The entry is invalid.
//
#define EPT_S_INVALID_ENTRY              1751L

//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
//  The server endpoint cannot perform the operation.
//
#define EPT_S_CANT_PERFORM_OP            1752L

//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
//  There are no more endpoints available from the endpoint mapper.
//
#define EPT_S_NOT_REGISTERED             1753L

//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
//  No interfaces have been exported.
//
#define RPC_S_NOTHING_TO_EXPORT          1754L

//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
//  The entry name is incomplete.
//
#define RPC_S_INCOMPLETE_NAME            1755L

//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
//  The version option is invalid.
//
#define RPC_S_INVALID_VERS_OPTION        1756L

//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
//  There are no more members.
//
#define RPC_S_NO_MORE_MEMBERS            1757L

//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
//  There is nothing to unexport.
//
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED    1758L

//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
//  The interface was not found.
//
#define RPC_S_INTERFACE_NOT_FOUND        1759L

//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
//  The entry already exists.
//
#define RPC_S_ENTRY_ALREADY_EXISTS       1760L

//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
//  The entry is not found.
//
#define RPC_S_ENTRY_NOT_FOUND            1761L

//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
//  The name service is unavailable.
//
#define RPC_S_NAME_SERVICE_UNAVAILABLE   1762L

//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
//  The network address family is invalid.
//
#define RPC_S_INVALID_NAF_ID             1763L

//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
//  The requested operation is not supported.
//
#define RPC_S_CANNOT_SUPPORT             1764L

//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
//  No security context is available to allow impersonation.
//
#define RPC_S_NO_CONTEXT_AVAILABLE       1765L

//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in a remote procedure call (RPC).
//
#define RPC_S_INTERNAL_ERROR             1766L

//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
//  The RPC server attempted an integer division by zero.
//
#define RPC_S_ZERO_DIVIDE                1767L

//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
//  An addressing error occurred in the RPC server.
//
#define RPC_S_ADDRESS_ERROR              1768L

//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
//  A floating-point operation at the RPC server caused a division by zero.
//
#define RPC_S_FP_DIV_ZERO                1769L

//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
//  A floating-point underflow occurred at the RPC server.
//
#define RPC_S_FP_UNDERFLOW               1770L

//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
//  A floating-point overflow occurred at the RPC server.
//
#define RPC_S_FP_OVERFLOW                1771L

//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
//  The list of RPC servers available for the binding of auto handles
//  has been exhausted.
//
#define RPC_X_NO_MORE_ENTRIES            1772L

//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
//  Unable to open the character translation table file.
//
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL    1773L

//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
//  The file containing the character translation table has fewer than
//  512 bytes.
//
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE   1774L

//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
//  A null context handle was passed from the client to the host during
//  a remote procedure call.
//
#define RPC_X_SS_IN_NULL_CONTEXT         1775L

//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
//  The context handle changed during a remote procedure call.
//
#define RPC_X_SS_CONTEXT_DAMAGED         1777L

//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
//  The binding handles passed to a remote procedure call do not match.
//
#define RPC_X_SS_HANDLES_MISMATCH        1778L

//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
//  The stub is unable to get the remote procedure call handle.
//
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE  1779L

//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
//  A null reference pointer was passed to the stub.
//
#define RPC_X_NULL_REF_POINTER           1780L

//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
//  The enumeration value is out of range.
//
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE    1781L

//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
//  The byte count is too small.
//
#define RPC_X_BYTE_COUNT_TOO_SMALL       1782L

//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
//  The stub received bad data.
//
#define RPC_X_BAD_STUB_DATA              1783L

//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
//  The supplied user buffer is not valid for the requested operation.
//
#define ERROR_INVALID_USER_BUFFER        1784L

//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  The disk media is not recognized.  It may not be formatted.
//
#define ERROR_UNRECOGNIZED_MEDIA         1785L

//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret.
//
#define ERROR_NO_TRUST_LSA_SECRET        1786L

//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The SAM database on the Windows NT Server does not have a computer
//  account for this workstation trust relationship.
//
#define ERROR_NO_TRUST_SAM_ACCOUNT       1787L

//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The trust relationship between the primary domain and the trusted
//  domain failed.
//
#define ERROR_TRUSTED_DOMAIN_FAILURE     1788L

//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The trust relationship between this workstation and the primary
//  domain failed.
//
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789L

//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed.
//
#define ERROR_TRUST_FAILURE              1790L

//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
//  A remote procedure call is already in progress for this thread.
//
#define RPC_S_CALL_IN_PROGRESS           1791L

//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to logon, but the network logon service was not started.
//
#define ERROR_NETLOGON_NOT_STARTED       1792L

//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//
#define ERROR_ACCOUNT_EXPIRED            1793L

//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794L

//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified printer driver is already installed.
//
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795L

//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
//  The specified port is unknown.
//
#define ERROR_UNKNOWN_PORT               1796L

//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  The printer driver is unknown.
//
#define ERROR_UNKNOWN_PRINTER_DRIVER     1797L

//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
//  The print processor is unknown.
//
#define ERROR_UNKNOWN_PRINTPROCESSOR     1798L

//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
//  The specified separator file is invalid.
//
#define ERROR_INVALID_SEPARATOR_FILE     1799L

//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
//  The specified priority is invalid.
//
#define ERROR_INVALID_PRIORITY           1800L

//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
//  The printer name is invalid.
//
#define ERROR_INVALID_PRINTER_NAME       1801L

//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
//  The printer already exists.
//
#define ERROR_PRINTER_ALREADY_EXISTS     1802L

//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
//  The printer command is invalid.
//
#define ERROR_INVALID_PRINTER_COMMAND    1803L

//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
//  The specified datatype is invalid.
//
#define ERROR_INVALID_DATATYPE           1804L

//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
//  The Environment specified is invalid.
//
#define ERROR_INVALID_ENVIRONMENT        1805L

//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
//  There are no more bindings.
//
#define RPC_S_NO_MORE_BINDINGS           1806L

//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an interdomain trust account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807L

//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a Computer Account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808L

//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an server trust account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809L

//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or security ID (SID) of the domain specified is inconsistent
//  with the trust information for that domain.
//
#define ERROR_DOMAIN_TRUST_INCONSISTENT  1810L

//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//
#define ERROR_SERVER_HAS_OPEN_HANDLES    1811L

//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  The specified image file did not contain a resource section.
//
#define ERROR_RESOURCE_DATA_NOT_FOUND    1812L

//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  The specified resource type can not be found in the image file.
//
#define ERROR_RESOURCE_TYPE_NOT_FOUND    1813L

//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  The specified resource name can not be found in the image file.
//
#define ERROR_RESOURCE_NAME_NOT_FOUND    1814L

//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  The specified resource language ID cannot be found in the image file.
//
#define ERROR_RESOURCE_LANG_NOT_FOUND    1815L

//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
//  Not enough quota is available to process this command.
//
#define ERROR_NOT_ENOUGH_QUOTA           1816L

//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
//  No interfaces have been registered.
//
#define RPC_S_NO_INTERFACES              1817L

//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
//  The server was altered while processing this call.
//
#define RPC_S_CALL_CANCELLED             1818L

//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
//  The binding handle does not contain all required information.
//
#define RPC_S_BINDING_INCOMPLETE         1819L

//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
//  Communications failure.
//
#define RPC_S_COMM_FAILURE               1820L

//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
//  The requested authentication level is not supported.
//
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL    1821L

//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
//  No principal name registered.
//
#define RPC_S_NO_PRINC_NAME              1822L

//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
//  The error specified is not a valid Windows RPC error code.
//
#define RPC_S_NOT_RPC_ERROR              1823L

//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
//  A UUID that is valid only on this computer has been allocated.
//
#define RPC_S_UUID_LOCAL_ONLY            1824L

//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
//  A security package specific error occurred.
//
#define RPC_S_SEC_PKG_ERROR              1825L

//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
//  Thread is not cancelled.
//
#define RPC_S_NOT_CANCELLED              1826L

//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
//  Invalid operation on the encoding/decoding handle.
//
#define RPC_X_INVALID_ES_ACTION          1827L

//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
//  Incompatible version of the serializing package.
//
#define RPC_X_WRONG_ES_VERSION           1828L

//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
//  Incompatible version of the RPC stub.
//
#define RPC_X_WRONG_STUB_VERSION         1829L

//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
//  The group member was not found.
//
#define RPC_S_GROUP_MEMBER_NOT_FOUND     1898L

//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
//  The endpoint mapper database could not be created.
//
#define EPT_S_CANT_CREATE                1899L

//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
//  The object universal unique identifier (UUID) is the nil UUID.
//
#define RPC_S_INVALID_OBJECT             1900L

//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
//  The specified time is invalid.
//
#define ERROR_INVALID_TIME               1901L

//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
//  The specified Form name is invalid.
//
#define ERROR_INVALID_FORM_NAME          1902L

//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
//  The specified Form size is invalid
//
#define ERROR_INVALID_FORM_SIZE          1903L

//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
//  The specified Printer handle is already being waited on
//
#define ERROR_ALREADY_WAITING            1904L

//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
//  The specified Printer has been deleted
//
#define ERROR_PRINTER_DELETED            1905L

//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
//  The state of the Printer is invalid
//
#define ERROR_INVALID_PRINTER_STATE      1906L

//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
//  The user must change his password before he logs on the first time.
//
#define ERROR_PASSWORD_MUST_CHANGE       1907L

//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
//  Could not find the domain controller for this domain.
//
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908L

//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
//  The referenced account is currently locked out and may not be logged on to.
//
#define ERROR_ACCOUNT_LOCKED_OUT         1909L

//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
//  The list of servers for this workgroup is not currently available
//
#define ERROR_NO_BROWSER_SERVERS_FOUND   6118L




///////////////////////////
//                       //
//   OpenGL Error Code   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
//  The pixel format is invalid.
//
#define ERROR_INVALID_PIXEL_FORMAT       2000L

//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
//  The specified driver is invalid.
//
#define ERROR_BAD_DRIVER                 2001L

//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
//  The window style or class attribute is invalid for this operation.
//
#define ERROR_INVALID_WINDOW_STYLE       2002L

//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
//  The requested metafile operation is not supported.
//
#define ERROR_METAFILE_NOT_SUPPORTED     2003L

//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
//  The requested transformation operation is not supported.
//
#define ERROR_TRANSFORM_NOT_SUPPORTED    2004L

//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
//  The requested clipping operation is not supported.
//
#define ERROR_CLIPPING_NOT_SUPPORTED     2005L

// End of OpenGL error codes



////////////////////////////////////
//                                //
//     Win32 Spooler Error Codes  //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
//  The specified print monitor is unknown.
//
#define ERROR_UNKNOWN_PRINT_MONITOR      3000L

//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
//  The specified printer driver is currently in use.
//
#define ERROR_PRINTER_DRIVER_IN_USE      3001L

//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
//  The spool file was not found.
//
#define ERROR_SPOOL_FILE_NOT_FOUND       3002L

//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
//  A StartDocPrinter call was not issued.
//
#define ERROR_SPL_NO_STARTDOC            3003L

//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
//  An AddJob call was not issued.
//
#define ERROR_SPL_NO_ADDJOB              3004L

//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print processor has already been installed.
//
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005L

//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print monitor has already been installed.
//
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006L

////////////////////////////////////
//                                //
//     Wins Error Codes           //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
//  WINS encountered an error while processing the command.
//
#define ERROR_WINS_INTERNAL              4000L

//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
//  The local WINS can not be deleted.
//
#define ERROR_CAN_NOT_DEL_LOCAL_WINS     4001L

//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
//  The importation from the file failed.
//
#define ERROR_STATIC_INIT                4002L

//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
//  The backup Failed.  Was a full backup done before ?
//
#define ERROR_INC_BACKUP                 4003L

//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
//  The backup Failed.  Check the directory that you are backing the database to.
//
#define ERROR_FULL_BACKUP                4004L

//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
//  The name does not exist in the WINS database.
//
#define ERROR_REC_NON_EXISTENT           4005L

//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
//  Replication with a non-configured partner is not allowed.
//
#define ERROR_RPL_NOT_ALLOWED            4006L

////////////////////////////////////
//                                //
//     OLE Error Codes            //
//                                //
////////////////////////////////////

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an 
// HRESULT are shown below.  
//
// Many of the macros and functions below were orginally defined to 
// operate on SCODEs.  SCODEs are no longer used.  The macros are 
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)

//
// and the inverse
//

#define FAILED(Status) ((HRESULT)(Status)<0)


//
// Generic test for error on any status value.
//

#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)

//
// Return the code
//

#define HRESULT_CODE(hr)    ((hr) & 0xFFFF)
#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define HRESULT_FACILITY(hr)  (((hr) >> 16) & 0x1fff)
#define SCODE_FACILITY(sc)    (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define HRESULT_SEVERITY(hr)  (((hr) >> 31) & 0x1)
#define SCODE_SEVERITY(sc)    (((sc) >> 31) & 0x1)

//
// Create an HRESULT value from component pieces
//

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )


//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work

#define FACILITY_NT_BIT                 0x10000000
#define HRESULT_FROM_WIN32(x)   (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )

//
// Map an NT status value into a HRESULT
//

#define HRESULT_FROM_NT(x)      ((HRESULT) ((x) | FACILITY_NT_BIT))


// ****** OBSOLETE functions

// HRESULT functions
// As noted above, these functions are obsolete and should not be used.


// Extract the SCODE from a HRESULT

#define GetScode(hr) ((SCODE) (hr))

// Convert an SCODE into an HRESULT.

#define ResultFromScode(sc) ((HRESULT) (sc))


// PropagateResult is a noop
#define PropagateResult(hrPrevious, scBase) ((HRESULT) scBase)


// ****** End of OBSOLETE functions.


// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//

#define NOERROR             S_OK

//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
//  Unexpected failure
//
#define E_UNEXPECTED                     0x8000FFFFL

#ifdef _WIN32
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        0x80004001L

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    0x8007000EL

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     0x80070057L

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    0x80004002L

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        0x80004003L

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         0x80070006L

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          0x80004004L

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           0x80004005L

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   0x80070005L

#else
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        0x80000001L

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    0x80000002L

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     0x80000003L

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    0x80000004L

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        0x80000005L

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         0x80000006L

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          0x80000007L

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           0x80000008L

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   0x80000009L

#endif //_WIN32
//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
//  Thread local storage failure
//
#define CO_E_INIT_TLS                    0x80004006L

//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
//  Get shared memory allocator failure
//
#define CO_E_INIT_SHARED_ALLOCATOR       0x80004007L

//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
//  Get memory allocator failure
//
#define CO_E_INIT_MEMORY_ALLOCATOR       0x80004008L

//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
//  Unable to initialize class cache
//
#define CO_E_INIT_CLASS_CACHE            0x80004009L

//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
//  Unable to initialize RPC services
//
#define CO_E_INIT_RPC_CHANNEL            0x8000400AL

//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
//  Cannot set thread local storage channel control
//
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL 0x8000400BL

//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
//  Could not allocate thread local storage channel control
//
#define CO_E_INIT_TLS_CHANNEL_CONTROL    0x8000400CL

//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
//  The user supplied memory allocator is unacceptable
//
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR 0x8000400DL

//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
//  The OLE service mutex already exists
//
#define CO_E_INIT_SCM_MUTEX_EXISTS       0x8000400EL

//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
//  The OLE service file mapping already exists
//
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS 0x8000400FL

//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
//  Unable to map view of file for OLE service
//
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE   0x80004010L

//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
//  Failure attempting to launch OLE service
//
#define CO_E_INIT_SCM_EXEC_FAILURE       0x80004011L

//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
//  There was an attempt to call CoInitialize a second time while single threaded
//
#define CO_E_INIT_ONLY_SINGLE_THREADED   0x80004012L


//
// Success codes
//
#define S_OK                                   (0x00000000L)
#define S_FALSE                                (0x00000001L)

// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many inerfaces
//

#define OLE_E_FIRST 0x80040000L
#define OLE_E_LAST  0x800400FFL
#define OLE_S_FIRST 0x00040000L
#define OLE_S_LAST  0x000400FFL

//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
//  Invalid OLEVERB structure
//
#define OLE_E_OLEVERB                    0x80040000L

//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
//  Invalid advise flags
//
#define OLE_E_ADVF                       0x80040001L

//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
//  Can't enumerate any more, because the associated data is missing
//
#define OLE_E_ENUM_NOMORE                0x80040002L

//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
//  This implementation doesn't take advises
//
#define OLE_E_ADVISENOTSUPPORTED         0x80040003L

//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection for this connection ID
//
#define OLE_E_NOCONNECTION               0x80040004L

//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
//  Need to run the object to perform this operation
//
#define OLE_E_NOTRUNNING                 0x80040005L

//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
//  There is no cache to operate on
//
#define OLE_E_NOCACHE                    0x80040006L

//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
//  Uninitialized object
//
#define OLE_E_BLANK                      0x80040007L

//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
//  Linked object's source class has changed
//
#define OLE_E_CLASSDIFF                  0x80040008L

//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
//  Not able to get the moniker of the object
//
#define OLE_E_CANT_GETMONIKER            0x80040009L

//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
//  Not able to bind to the source
//
#define OLE_E_CANT_BINDTOSOURCE          0x8004000AL

//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
//  Object is static; operation not allowed
//
#define OLE_E_STATIC                     0x8004000BL

//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
//  User cancelled out of save dialog
//
#define OLE_E_PROMPTSAVECANCELLED        0x8004000CL

//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
//  Invalid rectangle
//
#define OLE_E_INVALIDRECT                0x8004000DL

//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
//  compobj.dll is too old for the ole2.dll initialized
//
#define OLE_E_WRONGCOMPOBJ               0x8004000EL

//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define OLE_E_INVALIDHWND                0x8004000FL

//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
//  Object is not in any of the inplace active states
//
#define OLE_E_NOT_INPLACEACTIVE          0x80040010L

//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
//  Not able to convert object
//
#define OLE_E_CANTCONVERT                0x80040011L

//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
//  Not able to perform the operation because object is not given storage yet
//  
//
#define OLE_E_NOSTORAGE                  0x80040012L

//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
//  Invalid FORMATETC structure
//
#define DV_E_FORMATETC                   0x80040064L

//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
//  Invalid DVTARGETDEVICE structure
//
#define DV_E_DVTARGETDEVICE              0x80040065L

//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
//  Invalid STDGMEDIUM structure
//
#define DV_E_STGMEDIUM                   0x80040066L

//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
//  Invalid STATDATA structure
//
#define DV_E_STATDATA                    0x80040067L

//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
//  Invalid lindex
//
#define DV_E_LINDEX                      0x80040068L

//
// MessageId: DV_E_TYMED
//
// MessageText:
//
//  Invalid tymed
//
#define DV_E_TYMED                       0x80040069L

//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
//  Invalid clipboard format
//
#define DV_E_CLIPFORMAT                  0x8004006AL

//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
//  Invalid aspect(s)
//
#define DV_E_DVASPECT                    0x8004006BL

//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
//  tdSize parameter of the DVTARGETDEVICE structure is invalid
//
#define DV_E_DVTARGETDEVICE_SIZE         0x8004006CL

//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
//  Object doesn't support IViewObject interface
//
#define DV_E_NOIVIEWOBJECT               0x8004006DL

#define DRAGDROP_E_FIRST 0x80040100L
#define DRAGDROP_E_LAST  0x8004010FL
#define DRAGDROP_S_FIRST 0x00040100L
#define DRAGDROP_S_LAST  0x0004010FL
//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
//  Trying to revoke a drop target that has not been registered
//
#define DRAGDROP_E_NOTREGISTERED         0x80040100L

//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
//  This window has already been registered as a drop target
//
#define DRAGDROP_E_ALREADYREGISTERED     0x80040101L

//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define DRAGDROP_E_INVALIDHWND           0x80040102L

#define CLASSFACTORY_E_FIRST  0x80040110L
#define CLASSFACTORY_E_LAST   0x8004011FL
#define CLASSFACTORY_S_FIRST  0x00040110L
#define CLASSFACTORY_S_LAST   0x0004011FL
//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
//  Class does not support aggregation (or class object is remote)
//
#define CLASS_E_NOAGGREGATION            0x80040110L

//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
//  ClassFactory cannot supply requested class
//
#define CLASS_E_CLASSNOTAVAILABLE        0x80040111L

#define MARSHAL_E_FIRST  0x80040120L
#define MARSHAL_E_LAST   0x8004012FL
#define MARSHAL_S_FIRST  0x00040120L
#define MARSHAL_S_LAST   0x0004012FL
#define DATA_E_FIRST     0x80040130L
#define DATA_E_LAST      0x8004013FL
#define DATA_S_FIRST     0x00040130L
#define DATA_S_LAST      0x0004013FL
#define VIEW_E_FIRST     0x80040140L
#define VIEW_E_LAST      0x8004014FL
#define VIEW_S_FIRST     0x00040140L
#define VIEW_S_LAST      0x0004014FL
//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
//  Error drawing view
//
#define VIEW_E_DRAW                      0x80040140L

#define REGDB_E_FIRST     0x80040150L
#define REGDB_E_LAST      0x8004015FL
#define REGDB_S_FIRST     0x00040150L
#define REGDB_S_LAST      0x0004015FL
//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
//  Could not read key from registry
//
#define REGDB_E_READREGDB                0x80040150L

//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
//  Could not write key to registry
//
#define REGDB_E_WRITEREGDB               0x80040151L

//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
//  Could not find the key in the registry
//
#define REGDB_E_KEYMISSING               0x80040152L

//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
//  Invalid value for registry
//
#define REGDB_E_INVALIDVALUE             0x80040153L

//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
//  Class not registered
//
#define REGDB_E_CLASSNOTREG              0x80040154L

//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
//  Interface not registered
//
#define REGDB_E_IIDNOTREG                0x80040155L

#define CACHE_E_FIRST     0x80040170L
#define CACHE_E_LAST      0x8004017FL
#define CACHE_S_FIRST     0x00040170L
#define CACHE_S_LAST      0x0004017FL
//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
//  Cache not updated
//
#define CACHE_E_NOCACHE_UPDATED          0x80040170L

#define OLEOBJ_E_FIRST     0x80040180L
#define OLEOBJ_E_LAST      0x8004018FL
#define OLEOBJ_S_FIRST     0x00040180L
#define OLEOBJ_S_LAST      0x0004018FL
//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
//  No verbs for OLE object
//
#define OLEOBJ_E_NOVERBS                 0x80040180L

//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_E_INVALIDVERB             0x80040181L

#define CLIENTSITE_E_FIRST     0x80040190L
#define CLIENTSITE_E_LAST      0x8004019FL
#define CLIENTSITE_S_FIRST     0x00040190L
#define CLIENTSITE_S_LAST      0x0004019FL
//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
//  Undo is not available
//
#define INPLACE_E_NOTUNDOABLE            0x800401A0L

//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
//  Space for tools is not available
//
#define INPLACE_E_NOTOOLSPACE            0x800401A1L

#define INPLACE_E_FIRST     0x800401A0L
#define INPLACE_E_LAST      0x800401AFL
#define INPLACE_S_FIRST     0x000401A0L
#define INPLACE_S_LAST      0x000401AFL
#define ENUM_E_FIRST        0x800401B0L
#define ENUM_E_LAST         0x800401BFL
#define ENUM_S_FIRST        0x000401B0L
#define ENUM_S_LAST         0x000401BFL
#define CONVERT10_E_FIRST        0x800401C0L
#define CONVERT10_E_LAST         0x800401CFL
#define CONVERT10_S_FIRST        0x000401C0L
#define CONVERT10_S_LAST         0x000401CFL
//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
//  OLESTREAM Get method failed
//
#define CONVERT10_E_OLESTREAM_GET        0x800401C0L

//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
//  OLESTREAM Put method failed
//
#define CONVERT10_E_OLESTREAM_PUT        0x800401C1L

//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
//  Contents of the OLESTREAM not in correct format
//
#define CONVERT10_E_OLESTREAM_FMT        0x800401C2L

//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the bitmap to a DIB
//
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB 0x800401C3L

//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
//  Contents of the IStorage not in correct format
//
#define CONVERT10_E_STG_FMT              0x800401C4L

//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
//  Contents of IStorage is missing one of the standard streams
//
#define CONVERT10_E_STG_NO_STD_STREAM    0x800401C5L

//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the DIB to a bitmap.
//  
//
#define CONVERT10_E_STG_DIB_TO_BITMAP    0x800401C6L

#define CLIPBRD_E_FIRST        0x800401D0L
#define CLIPBRD_E_LAST         0x800401DFL
#define CLIPBRD_S_FIRST        0x000401D0L
#define CLIPBRD_S_LAST         0x000401DFL
//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
//  OpenClipboard Failed
//
#define CLIPBRD_E_CANT_OPEN              0x800401D0L

//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
//  EmptyClipboard Failed
//
#define CLIPBRD_E_CANT_EMPTY             0x800401D1L

//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
//  SetClipboard Failed
//
#define CLIPBRD_E_CANT_SET               0x800401D2L

//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
//  Data on clipboard is invalid
//
#define CLIPBRD_E_BAD_DATA               0x800401D3L

//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
//  CloseClipboard Failed
//
#define CLIPBRD_E_CANT_CLOSE             0x800401D4L

#define MK_E_FIRST        0x800401E0L
#define MK_E_LAST         0x800401EFL
#define MK_S_FIRST        0x000401E0L
#define MK_S_LAST         0x000401EFL
//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
//  Moniker needs to be connected manually
//
#define MK_E_CONNECTMANUALLY             0x800401E0L

//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
//  Operation exceeded deadline
//
#define MK_E_EXCEEDEDDEADLINE            0x800401E1L

//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
//  Moniker needs to be generic
//
#define MK_E_NEEDGENERIC                 0x800401E2L

//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
//  Operation unavailable
//
#define MK_E_UNAVAILABLE                 0x800401E3L

//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
//  Invalid syntax
//
#define MK_E_SYNTAX                      0x800401E4L

//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
//  No object for moniker
//
#define MK_E_NOOBJECT                    0x800401E5L

//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
//  Bad extension for file
//
#define MK_E_INVALIDEXTENSION            0x800401E6L

//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
//  Intermediate operation failed
//
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED 0x800401E7L

//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
//  Moniker is not bindable
//
#define MK_E_NOTBINDABLE                 0x800401E8L

//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
//  Moniker is not bound
//
#define MK_E_NOTBOUND                    0x800401E9L

//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
//  Moniker cannot open file
//
#define MK_E_CANTOPENFILE                0x800401EAL

//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
//  User input required for operation to succeed
//
#define MK_E_MUSTBOTHERUSER              0x800401EBL

//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
//  Moniker class has no inverse
//
#define MK_E_NOINVERSE                   0x800401ECL

//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
//  Moniker does not refer to storage
//
#define MK_E_NOSTORAGE                   0x800401EDL

//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
//  No common prefix
//
#define MK_E_NOPREFIX                    0x800401EEL

//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
//  Moniker could not be enumerated
//
#define MK_E_ENUMERATION_FAILED          0x800401EFL

#define CO_E_FIRST        0x800401F0L
#define CO_E_LAST         0x800401FFL
#define CO_S_FIRST        0x000401F0L
#define CO_S_LAST         0x000401FFL
//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
//  CoInitialize has not been called.
//
#define CO_E_NOTINITIALIZED              0x800401F0L

//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
//  CoInitialize has already been called.
//
#define CO_E_ALREADYINITIALIZED          0x800401F1L

//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
//  Class of object cannot be determined
//
#define CO_E_CANTDETERMINECLASS          0x800401F2L

//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
//  Invalid class string
//
#define CO_E_CLASSSTRING                 0x800401F3L

//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
//  Invalid interface string
//
#define CO_E_IIDSTRING                   0x800401F4L

//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
//  Application not found
//
#define CO_E_APPNOTFOUND                 0x800401F5L

//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
//  Application cannot be run more than once
//
#define CO_E_APPSINGLEUSE                0x800401F6L

//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
//  Some error in application program
//
#define CO_E_ERRORINAPP                  0x800401F7L

//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
//  DLL for class not found
//
#define CO_E_DLLNOTFOUND                 0x800401F8L

//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
//  Error in the DLL
//
#define CO_E_ERRORINDLL                  0x800401F9L

//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
//  Wrong OS or OS version for application
//
#define CO_E_WRONGOSFORAPP               0x800401FAL

//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
//  Object is not registered
//
#define CO_E_OBJNOTREG                   0x800401FBL

//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
//  Object is already registered
//
#define CO_E_OBJISREG                    0x800401FCL

//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
//  Object is not connected to server
//
#define CO_E_OBJNOTCONNECTED             0x800401FDL

//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
//  Application was launched but it didn't register a class factory
//
#define CO_E_APPDIDNTREG                 0x800401FEL

//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
//  Object has been released
//
#define CO_E_RELEASED                    0x800401FFL

//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
//  Use the registry database to provide the requested information
//
#define OLE_S_USEREG                     0x00040000L

//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
//  Success, but static
//
#define OLE_S_STATIC                     0x00040001L

//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
//  Macintosh clipboard format
//
#define OLE_S_MAC_CLIPFORMAT             0x00040002L

//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
//  Successful drop took place
//
#define DRAGDROP_S_DROP                  0x00040100L

//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
//  Drag-drop operation canceled
//
#define DRAGDROP_S_CANCEL                0x00040101L

//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
//  Use the default cursor
//
#define DRAGDROP_S_USEDEFAULTCURSORS     0x00040102L

//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
//  Data has same FORMATETC
//
#define DATA_S_SAMEFORMATETC             0x00040130L

//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
//  View is already frozen
//
#define VIEW_S_ALREADY_FROZEN            0x00040140L

//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
//  FORMATETC not supported
//
#define CACHE_S_FORMATETC_NOTSUPPORTED   0x00040170L

//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
//  Same cache
//
#define CACHE_S_SAMECACHE                0x00040171L

//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
//  Some cache(s) not updated
//
#define CACHE_S_SOMECACHES_NOTUPDATED    0x00040172L

//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_S_INVALIDVERB             0x00040180L

//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
//  Verb number is valid but verb cannot be done now
//
#define OLEOBJ_S_CANNOT_DOVERB_NOW       0x00040181L

//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle passed
//
#define OLEOBJ_S_INVALIDHWND             0x00040182L

//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
//  Message is too long; some of it had to be truncated before displaying
//
#define INPLACE_S_TRUNCATED              0x000401A0L

//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
//  Unable to convert OLESTREAM to IStorage
//
#define CONVERT10_S_NO_PRESENTATION      0x000401C0L

//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
//  Moniker reduced to itself
//
#define MK_S_REDUCED_TO_SELF             0x000401E2L

//
// MessageId: MK_S_ME
//
// MessageText:
//
//  Common prefix is this moniker
//
#define MK_S_ME                          0x000401E4L

//
// MessageId: MK_S_HIM
//
// MessageText:
//
//  Common prefix is input moniker
//
#define MK_S_HIM                         0x000401E5L

//
// MessageId: MK_S_US
//
// MessageText:
//
//  Common prefix is both monikers
//
#define MK_S_US                          0x000401E6L

//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
//  Moniker is already registered in running object table
//
#define MK_S_MONIKERALREADYREGISTERED    0x000401E7L

// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
//  Attempt to create a class object failed
//
#define CO_E_CLASS_CREATE_FAILED         0x80080001L

//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
//  OLE service could not bind object
//
#define CO_E_SCM_ERROR                   0x80080002L

//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
//  RPC communication failed with OLE service
//
#define CO_E_SCM_RPC_FAILURE             0x80080003L

//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
//  Bad path to object
//
#define CO_E_BAD_PATH                    0x80080004L

//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
//  Server execution failed
//
#define CO_E_SERVER_EXEC_FAILURE         0x80080005L

//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
//  OLE service could not communicate with the object server
//
#define CO_E_OBJSRV_RPC_FAILURE          0x80080006L

//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
//  Moniker path could not be normalized
//
#define MK_E_NO_NORMALIZED               0x80080007L

//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
//  Object server is stopping when OLE service contacts it
//
#define CO_E_SERVER_STOPPING             0x80080008L

//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
//  An invalid root block pointer was specified
//
#define MEM_E_INVALID_ROOT               0x80080009L

//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
//  An allocation chain contained an invalid link pointer
//
#define MEM_E_INVALID_LINK               0x80080010L

//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
//  The requested allocation size was too large
//
#define MEM_E_INVALID_SIZE               0x80080011L

// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
//  Unknown interface.
//
#define DISP_E_UNKNOWNINTERFACE          0x80020001L

//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
//  Member not found.
//
#define DISP_E_MEMBERNOTFOUND            0x80020003L

//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
//  Parameter not found.
//
#define DISP_E_PARAMNOTFOUND             0x80020004L

//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define DISP_E_TYPEMISMATCH              0x80020005L

//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
//  Unknown name.
//
#define DISP_E_UNKNOWNNAME               0x80020006L

//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
//  No named arguments.
//
#define DISP_E_NONAMEDARGS               0x80020007L

//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
//  Bad variable type.
//
#define DISP_E_BADVARTYPE                0x80020008L

//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
//  Exception occurred.
//
#define DISP_E_EXCEPTION                 0x80020009L

//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
//  Out of present range.
//
#define DISP_E_OVERFLOW                  0x8002000AL

//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
//  Invalid index.
//
#define DISP_E_BADINDEX                  0x8002000BL

//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown language.
//
#define DISP_E_UNKNOWNLCID               0x8002000CL

//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
//  Memory is locked.
//
#define DISP_E_ARRAYISLOCKED             0x8002000DL

//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
//  Invalid number of parameters.
//
#define DISP_E_BADPARAMCOUNT             0x8002000EL

//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
//  Parameter not optional.
//
#define DISP_E_PARAMNOTOPTIONAL          0x8002000FL

//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
//  Invalid callee.
//
#define DISP_E_BADCALLEE                 0x80020010L

//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
//  Does not support a collection.
//
#define DISP_E_NOTACOLLECTION            0x80020011L

//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer too small.
//
#define TYPE_E_BUFFERTOOSMALL            0x80028016L

//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_INVDATAREAD               0x80028018L

//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_UNSUPFORMAT               0x80028019L

//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
//  Error accessing the OLE registry.
//
#define TYPE_E_REGISTRYACCESS            0x8002801CL

//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
//  Library not registered.
//
#define TYPE_E_LIBNOTREGISTERED          0x8002801DL

//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
//  Bound to unknown type.
//
#define TYPE_E_UNDEFINEDTYPE             0x80028027L

//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
//  Qualified name disallowed.
//
#define TYPE_E_QUALIFIEDNAMEDISALLOWED   0x80028028L

//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
//  Invalid forward reference, or reference to uncompiled type.
//
#define TYPE_E_INVALIDSTATE              0x80028029L

//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_WRONGTYPEKIND             0x8002802AL

//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
//  Element not found.
//
#define TYPE_E_ELEMENTNOTFOUND           0x8002802BL

//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
//  Ambiguous name.
//
#define TYPE_E_AMBIGUOUSNAME             0x8002802CL

//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
//  Name already exists in the library.
//
#define TYPE_E_NAMECONFLICT              0x8002802DL

//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown LCID.
//
#define TYPE_E_UNKNOWNLCID               0x8002802EL

//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
//  Function not defined in specified DLL.
//
#define TYPE_E_DLLFUNCTIONNOTFOUND       0x8002802FL

//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
//  Wrong module kind for the operation.
//
#define TYPE_E_BADMODULEKIND             0x800288BDL

//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
//  Size may not exceed 64K.
//
#define TYPE_E_SIZETOOBIG                0x800288C5L

//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
//  Duplicate ID in inheritance hierarchy.
//
#define TYPE_E_DUPLICATEID               0x800288C6L

//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
//  Incorrect inheritance depth in standard OLE hmember.
//
#define TYPE_E_INVALIDID                 0x800288CFL

//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_TYPEMISMATCH              0x80028CA0L

//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
//  Invalid number of arguments.
//
#define TYPE_E_OUTOFBOUNDS               0x80028CA1L

//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
//  I/O Error.
//
#define TYPE_E_IOERROR                   0x80028CA2L

//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
//  Error creating unique tmp file.
//
#define TYPE_E_CANTCREATETMPFILE         0x80028CA3L

//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
//  Error loading type library/DLL.
//
#define TYPE_E_CANTLOADLIBRARY           0x80029C4AL

//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
//  Inconsistent property functions.
//
#define TYPE_E_INCONSISTENTPROPFUNCS     0x80029C83L

//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
//  Circular dependency between types/modules.
//
#define TYPE_E_CIRCULARTYPE              0x80029C84L

// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
//  Unable to perform requested operation.
//
#define STG_E_INVALIDFUNCTION            0x80030001L

//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
//  %1 could not be found.
//
#define STG_E_FILENOTFOUND               0x80030002L

//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
//  The path %1 could not be found.
//
#define STG_E_PATHNOTFOUND               0x80030003L

//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
//  There are insufficient resources to open another file.
//
#define STG_E_TOOMANYOPENFILES           0x80030004L

//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
//  Access Denied.
//
#define STG_E_ACCESSDENIED               0x80030005L

//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
//  Attempted an operation on an invalid object.
//
#define STG_E_INVALIDHANDLE              0x80030006L

//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
//  There is insufficient memory available to complete operation.
//
#define STG_E_INSUFFICIENTMEMORY         0x80030008L

//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
//  Invalid pointer error.
//
#define STG_E_INVALIDPOINTER             0x80030009L

//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
//  There are no more entries to return.
//
#define STG_E_NOMOREFILES                0x80030012L

//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
//  Disk is write-protected.
//
#define STG_E_DISKISWRITEPROTECTED       0x80030013L

//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
//  An error occurred during a seek operation.
//
#define STG_E_SEEKERROR                  0x80030019L

//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
//  A disk error occurred during a write operation.
//
#define STG_E_WRITEFAULT                 0x8003001DL

//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
//  A disk error occurred during a read operation.
//
#define STG_E_READFAULT                  0x8003001EL

//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
//  A share violation has occurred.
//
#define STG_E_SHAREVIOLATION             0x80030020L

//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
//  A lock violation has occurred.
//
#define STG_E_LOCKVIOLATION              0x80030021L

//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
//  %1 already exists.
//
#define STG_E_FILEALREADYEXISTS          0x80030050L

//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
//  Invalid parameter error.
//
#define STG_E_INVALIDPARAMETER           0x80030057L

//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
//  There is insufficient disk space to complete operation.
//
#define STG_E_MEDIUMFULL                 0x80030070L

//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
//  An API call exited abnormally.
//
#define STG_E_ABNORMALAPIEXIT            0x800300FAL

//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
//  The file %1 is not a valid compound file.
//
#define STG_E_INVALIDHEADER              0x800300FBL

//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
//  The name %1 is not valid.
//
#define STG_E_INVALIDNAME                0x800300FCL

//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
//  An unexpected error occurred.
//
#define STG_E_UNKNOWN                    0x800300FDL

//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
//  That function is not implemented.
//
#define STG_E_UNIMPLEMENTEDFUNCTION      0x800300FEL

//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
//  Invalid flag error.
//
#define STG_E_INVALIDFLAG                0x800300FFL

//
// MessageId: STG_E_INUSE
//
// MessageText:
//
//  Attempted to use an object that is busy.
//
#define STG_E_INUSE                      0x80030100L

//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
//  The storage has been changed since the last commit.
//
#define STG_E_NOTCURRENT                 0x80030101L

//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
//  Attempted to use an object that has ceased to exist.
//
#define STG_E_REVERTED                   0x80030102L

//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
//  Can't save.
//
#define STG_E_CANTSAVE                   0x80030103L

//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
//  The compound file %1 was produced with an incompatible version of storage.
//
#define STG_E_OLDFORMAT                  0x80030104L

//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
//  The compound file %1 was produced with a newer version of storage.
//
#define STG_E_OLDDLL                     0x80030105L

//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
//  Share.exe or equivalent is required for operation.
//
#define STG_E_SHAREREQUIRED              0x80030106L

//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
//  Illegal operation called on non-file based storage.
//
#define STG_E_NOTFILEBASEDSTORAGE        0x80030107L

//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
//  Illegal operation called on object with extant marshallings.
//
#define STG_E_EXTANTMARSHALLINGS         0x80030108L

//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
//  The underlying file was converted to compound file format.
//
#define STG_S_CONVERTED                  0x00030200L

// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propogated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED              0x80010001L

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceled by the message filter.
//
#define RPC_E_CALL_CANCELED              0x80010002L

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  cannot call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL        0x80010003L

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronous call and cannot
//  make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL    0x80010004L

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  It is illegal to call out while inside message filter.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL 0x80010005L

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and cannot be used any more. Other connections
//  are still valid.
//
#define RPC_E_CONNECTION_TERMINATED      0x80010006L

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//
#define RPC_E_SERVER_DIED                0x80010007L

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client) disappeared while the callee (server) was
//  processing a call.
//
#define RPC_E_CLIENT_DIED                0x80010008L

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The data packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET         0x80010009L

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL          0x8001000AL

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot marshall the parameter data - low memory, etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA    0x8001000BL

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot unmarshall the return data - low memory, etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA  0x8001000CL

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot marshall the return data - low memory, etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA    0x8001000DL

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot unmarshall the parameter data - low memory, etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA  0x8001000EL

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data is invalid; could be server or client data.
//
#define RPC_E_INVALID_DATA               0x8001000FL

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and cannot be (un)marshalled.
//
#define RPC_E_INVALID_PARAMETER          0x80010010L

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN          0x80010011L

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE            0x80010012L

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//
#define RPC_E_SYS_CALL_FAILED            0x80010100L

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES           0x80010101L

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more than one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD      0x80010102L

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED             0x80010103L

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT                      0x80010104L

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//
#define RPC_E_SERVERFAULT                0x80010105L

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE               0x80010106L

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD              0x80010107L

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED               0x80010108L

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked chose not to process the call now.  Try again later.
//
#define RPC_E_RETRY                      0x80010109L

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The message filter indicated that the application is busy.
//
#define RPC_E_SERVERCALL_RETRYLATER      0x8001010AL

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The message filter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED        0x8001010BL

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  A call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA           0x8001010CL

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL 0x8001010DL

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The application called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD               0x8001010EL

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT            0x8001010FL

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occurred.
//
#define RPC_E_UNEXPECTED                 0x8001FFFFL

#endif // _WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINGDI.H ===
/**************************************************************************
*                                                                         *
* wingdi.h -- GDI procedure declarations, constant definitions and macros *
*                                                                         *
* Copyright (c) 1985-1995, Microsoft Corp. All rights reserved.           *
*                                                                         *
**************************************************************************/

#ifndef _WINGDI_
#define _WINGDI_


//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_GDI32_)
#define WINGDIAPI DECLSPEC_IMPORT
#else
#define WINGDIAPI
#endif

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_SPOOL32_)
#define WINSPOOLAPI DECLSPEC_IMPORT
#else
#define WINSPOOLAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef NOGDI

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1   /*  0       */
#define R2_NOTMERGEPEN      2   /* DPon     */
#define R2_MASKNOTPEN       3   /* DPna     */
#define R2_NOTCOPYPEN       4   /* PN       */
#define R2_MASKPENNOT       5   /* PDna     */
#define R2_NOT              6   /* Dn       */
#define R2_XORPEN           7   /* DPx      */
#define R2_NOTMASKPEN       8   /* DPan     */
#define R2_MASKPEN          9   /* DPa      */
#define R2_NOTXORPEN        10  /* DPxn     */
#define R2_NOP              11  /* D        */
#define R2_MERGENOTPEN      12  /* DPno     */
#define R2_COPYPEN          13  /* P        */
#define R2_MERGEPENNOT      14  /* PDno     */
#define R2_MERGEPEN         15  /* DPo      */
#define R2_WHITE            16  /*  1       */
#define R2_LAST             16

/* Ternary raster operations */
#define SRCCOPY             (DWORD)0x00CC0020 /* dest = source                   */
#define SRCPAINT            (DWORD)0x00EE0086 /* dest = source OR dest           */
#define SRCAND              (DWORD)0x008800C6 /* dest = source AND dest          */
#define SRCINVERT           (DWORD)0x00660046 /* dest = source XOR dest          */
#define SRCERASE            (DWORD)0x00440328 /* dest = source AND (NOT dest )   */
#define NOTSRCCOPY          (DWORD)0x00330008 /* dest = (NOT source)             */
#define NOTSRCERASE         (DWORD)0x001100A6 /* dest = (NOT src) AND (NOT dest) */
#define MERGECOPY           (DWORD)0x00C000CA /* dest = (source AND pattern)     */
#define MERGEPAINT          (DWORD)0x00BB0226 /* dest = (NOT source) OR dest     */
#define PATCOPY             (DWORD)0x00F00021 /* dest = pattern                  */
#define PATPAINT            (DWORD)0x00FB0A09 /* dest = DPSnoo                   */
#define PATINVERT           (DWORD)0x005A0049 /* dest = pattern XOR dest         */
#define DSTINVERT           (DWORD)0x00550009 /* dest = (NOT dest)               */
#define BLACKNESS           (DWORD)0x00000042 /* dest = BLACK                    */
#define WHITENESS           (DWORD)0x00FF0062 /* dest = WHITE                    */

/* Quaternary raster codes */
#define MAKEROP4(fore,back) (DWORD)((((back) << 8) & 0xFF000000) | (fore))

#endif /* NORASTEROPS */

#define GDI_ERROR (0xFFFFFFFFL)
#define HGDI_ERROR ((HANDLE)(0xFFFFFFFFL))

/* Region Flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3
#define RGN_ERROR ERROR

/* CombineRgn() Styles */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5
#define RGN_MIN             RGN_AND
#define RGN_MAX             RGN_COPY

/* StretchBlt() Modes */
#define BLACKONWHITE                 1
#define WHITEONBLACK                 2
#define COLORONCOLOR                 3
#define HALFTONE                     4
#define MAXSTRETCHBLTMODE            4

#if(WINVER >= 0x0400)
/* New StretchBlt() Modes */
#define STRETCH_ANDSCANS    BLACKONWHITE
#define STRETCH_ORSCANS     WHITEONBLACK
#define STRETCH_DELETESCANS COLORONCOLOR
#define STRETCH_HALFTONE    HALFTONE
#endif /* WINVER >= 0x0400 */

/* PolyFill() Modes */
#define ALTERNATE                    1
#define WINDING                      2
#define POLYFILL_LAST                2

/* Text Alignment Options */
#define TA_NOUPDATECP                0
#define TA_UPDATECP                  1

#define TA_LEFT                      0
#define TA_RIGHT                     2
#define TA_CENTER                    6

#define TA_TOP                       0
#define TA_BOTTOM                    8
#define TA_BASELINE                  24
#if (WINVER >= 0x0400)
#define TA_RTLREADING                256
#define TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
#else
#define TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP)
#endif

#define VTA_BASELINE TA_BASELINE
#define VTA_LEFT     TA_BOTTOM
#define VTA_RIGHT    TA_TOP
#define VTA_CENTER   TA_CENTER
#define VTA_BOTTOM   TA_RIGHT
#define VTA_TOP      TA_LEFT

#define ETO_OPAQUE                   0x0002
#define ETO_CLIPPED                  0x0004
#if(WINVER >= 0x0400)
#define ETO_GLYPH_INDEX              0x0010
#define ETO_RTLREADING               0x0080
#endif /* WINVER >= 0x0400 */

#define ASPECT_FILTERING             0x0001

/* Bounds Accumulation APIs */

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008

#ifndef NOMETAFILE

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0410
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139
#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43
#define META_EXTFLOODFILL            0x0548
#define META_DELETEOBJECT            0x01f0
#define META_CREATEPALETTE           0x00f7
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEREGION            0x06FF

#endif /* NOMETAFILE */

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define MOUSETRAILS                  39
#define GETDEVICEUNITS               42

#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define DOWNLOADFACE                 514
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048
#define GETSETSCREENPARAMS           3072
#define QUERYDIBSUPPORT              3073
#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109
#define SET_MIRROR_MODE              4110
#define OPENCHANNEL                  4110
#define DOWNLOADHEADER               4111
#define CLOSECHANNEL                 4112
#define POSTSCRIPT_PASSTHROUGH       4115
#define ENCAPSULATED_POSTSCRIPT      4116

/* Flag returned from QUERYDIBSUPPORT */
#define QDI_SETDIBITS                1
#define QDI_GETDIBITS                2
#define QDI_DIBTOSCREEN              4
#define QDI_STRETCHDIB               8

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

/* Object Definitions for EnumObjects() */
#define OBJ_PEN             1
#define OBJ_BRUSH           2
#define OBJ_DC              3
#define OBJ_METADC          4
#define OBJ_PAL             5
#define OBJ_FONT            6
#define OBJ_BITMAP          7
#define OBJ_REGION          8
#define OBJ_METAFILE        9
#define OBJ_MEMDC           10
#define OBJ_EXTPEN          11
#define OBJ_ENHMETADC       12
#define OBJ_ENHMETAFILE     13

/* xform stuff */
#define MWT_IDENTITY        1
#define MWT_LEFTMULTIPLY    2
#define MWT_RIGHTMULTIPLY   3

#define MWT_MIN             MWT_IDENTITY
#define MWT_MAX             MWT_RIGHTMULTIPLY

#define _XFORM_
typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM, FAR *LPXFORM;

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP, NEAR *NPBITMAP, FAR *LPBITMAP;

#include <pshpack1.h>
typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;
#include <poppack.h>

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

#if(WINVER >= 0x0400)

/* Image Color Matching color definitions */

typedef LONG	LCSCSTYPE;
#define LCS_CALIBRATED_RGB		0x00000000L
#define LCS_DEVICE_RGB			0x00000001L
#define LCS_DEVICE_CMYK			0x00000002L

typedef	LONG	LCSGAMUTMATCH;
#define LCS_GM_BUSINESS			0x00000001L
#define LCS_GM_GRAPHICS			0x00000002L
#define LCS_GM_IMAGES			0x00000004L

/* ICM Defines for results from CheckColorInGamut() */
#define CM_OUT_OF_GAMUT		255
#define CM_IN_GAMUT			0

/* Macros to retrieve CMYK values from a COLORREF */
#define GetCValue(cmyk)      ((BYTE)(cmyk))
#define GetMValue(cmyk)      ((BYTE)((cmyk)>> 8))
#define GetYValue(cmyk)      ((BYTE)((cmyk)>>16))
#define GetKValue(cmyk)      ((BYTE)((cmyk)>>24))

#define CMYK(c,m,y,k)       ((COLORREF)((((BYTE)(c)|((WORD)((BYTE)(m))<<8))|(((DWORD)(BYTE)(y))<<16))|(((DWORD)(BYTE)(k))<<24)))

typedef long            FXPT16DOT16, FAR *LPFXPT16DOT16;
typedef long            FXPT2DOT30, FAR *LPFXPT2DOT30;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of
// CIEXYZ. The values are fixed point 16.16.

typedef struct tagCIEXYZ
{
	FXPT2DOT30 ciexyzX;
	FXPT2DOT30 ciexyzY;
	FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ  FAR *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
	CIEXYZ  ciexyzRed;
	CIEXYZ  ciexyzGreen;
	CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE    FAR *LPCIEXYZTRIPLE;

// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.

typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[MAX_PATH];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[MAX_PATH];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;
#ifdef UNICODE
typedef LOGCOLORSPACEW LOGCOLORSPACE;
typedef LPLOGCOLORSPACEW LPLOGCOLORSPACE;
#else
typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
#endif // UNICODE

#endif /* WINVER >= 0x0400 */


/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER, FAR *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;


#if(WINVER >= 0x0400)
typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER, FAR *LPBITMAPV4HEADER, *PBITMAPV4HEADER;
#endif /* WINVER >= 0x0400 */

/* constants for the biCompression field */
#define BI_RGB        0L
#define BI_RLE8       1L
#define BI_RLE4       2L
#define BI_BITFIELDS  3L

typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO, FAR *LPBITMAPINFO, *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO, FAR *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#include <pshpack2.h>
typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
#include <poppack.h>

#define MAKEPOINTS(l)       (*((POINTS FAR *)&(l)))

#if(WINVER >= 0x0400)
#ifndef NOFONTSIG
typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,FAR *LPFONTSIGNATURE;

typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, NEAR *NPCHARSETINFO, FAR *LPCHARSETINFO;

#define TCI_SRCCHARSET	1
#define TCI_SRCCODEPAGE	2
#define TCI_SRCFONTSIG	3

typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE,FAR *LPLOCALESIGNATURE;

#endif
#endif /* WINVER >= 0x0400 */
#ifndef NOMETAFILE

/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE, FAR *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;
typedef struct tagMETARECORD UNALIGNED *PMETARECORD;
typedef struct tagMETARECORD UNALIGNED FAR *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
  } METAFILEPICT, FAR *LPMETAFILEPICT;

#include <pshpack2.h>
typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER UNALIGNED *PMETAHEADER;
typedef struct tagMETAHEADER UNALIGNED FAR *LPMETAHEADER;

#include <poppack.h>

/* Enhanced Metafile structures */
typedef struct tagENHMETARECORD
{
    DWORD   iType;              // Record type EMR_XXX
    DWORD   nSize;              // Record size in bytes
    DWORD   dParm[1];           // Parameters
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

#endif /* NOMETAFILE */

#ifndef NOTEXTMETRIC

/* tmPitchAndFamily flags */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR             0x02
#define TMPF_DEVICE             0x08
#define TMPF_TRUETYPE       0x04

//
// BCHAR definition for APPs
//
#ifdef UNICODE
    typedef WCHAR BCHAR;
#else
    typedef BYTE BCHAR;
#endif


typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA, NEAR *NPTEXTMETRICA, FAR *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW, NEAR *NPTEXTMETRICW, FAR *LPTEXTMETRICW;
#ifdef UNICODE
typedef TEXTMETRICW TEXTMETRIC;
typedef PTEXTMETRICW PTEXTMETRIC;
typedef NPTEXTMETRICW NPTEXTMETRIC;
typedef LPTEXTMETRICW LPTEXTMETRIC;
#else
typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;
#endif // UNICODE

/* ntmFlags field flags */
#define NTM_REGULAR     0x00000040L
#define NTM_BOLD        0x00000020L
#define NTM_ITALIC      0x00000001L

#include <pshpack4.h>
typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, NEAR *NPNEWTEXTMETRICA, FAR *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW, NEAR *NPNEWTEXTMETRICW, FAR *LPNEWTEXTMETRICW;
#ifdef UNICODE
typedef NEWTEXTMETRICW NEWTEXTMETRIC;
typedef PNEWTEXTMETRICW PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICW NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICW LPNEWTEXTMETRIC;
#else
typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;
#endif // UNICODE
#include <poppack.h>

#if(WINVER >= 0x0400)
typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;
#ifdef UNICODE
typedef NEWTEXTMETRICEXW NEWTEXTMETRICEX;
#else
typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

#endif /* NOTEXTMETRIC */
/* GDI Logical Objects: */

/* Pel Array */
typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY, NEAR *NPPELARRAY, FAR *LPPELARRAY;

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    LONG        lbHatch;
  } LOGBRUSH, *PLOGBRUSH, NEAR *NPLOGBRUSH, FAR *LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN NEAR        *NPPATTERN;
typedef PATTERN FAR         *LPPATTERN;

/* Logical Pen */
typedef struct tagLOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN, NEAR *NPLOGPEN, FAR *LPLOGPEN;

typedef struct tagEXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    LONG        elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN, NEAR *NPEXTLOGPEN, FAR *LPEXTLOGPEN;

typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;

/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, NEAR *NPLOGPALETTE, FAR *LPLOGPALETTE;


/* Logical Font */
#define LF_FACESIZE         32

typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[LF_FACESIZE];
} LOGFONTA, *PLOGFONTA, NEAR *NPLOGFONTA, FAR *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[LF_FACESIZE];
} LOGFONTW, *PLOGFONTW, NEAR *NPLOGFONTW, FAR *LPLOGFONTW;
#ifdef UNICODE
typedef LOGFONTW LOGFONT;
typedef PLOGFONTW PLOGFONT;
typedef NPLOGFONTW NPLOGFONT;
typedef LPLOGFONTW LPLOGFONT;
#else
typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
#endif // UNICODE

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[LF_FULLFACESIZE];
    BYTE     elfStyle[LF_FACESIZE];
} ENUMLOGFONTA, FAR* LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[LF_FULLFACESIZE];
    WCHAR    elfStyle[LF_FACESIZE];
} ENUMLOGFONTW, FAR* LPENUMLOGFONTW;
#ifdef UNICODE
typedef ENUMLOGFONTW ENUMLOGFONT;
typedef LPENUMLOGFONTW LPENUMLOGFONT;
#else
typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;
#endif // UNICODE

#if(WINVER >= 0x0400)
typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    BYTE        elfScript[LF_FACESIZE];
} ENUMLOGFONTEXA, FAR *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    BYTE        elfScript[LF_FACESIZE];
} ENUMLOGFONTEXW, FAR *LPENUMLOGFONTEXW;
#ifdef UNICODE
typedef ENUMLOGFONTEXW ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXW LPENUMLOGFONTEX;
#else
typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#define OUT_OUTLINE_PRECIS      8

#define CLIP_DEFAULT_PRECIS     0
#define CLIP_CHARACTER_PRECIS   1
#define CLIP_STROKE_PRECIS      2
#define CLIP_MASK               0xf
#define CLIP_LH_ANGLES          (1<<4)
#define CLIP_TT_ALWAYS          (2<<4)
#define CLIP_EMBEDDED           (8<<4)

#define DEFAULT_QUALITY         0
#define DRAFT_QUALITY           1
#define PROOF_QUALITY           2
#if(WINVER >= 0x0400)
#define NONANTIALIASED_QUALITY  3
#define ANTIALIASED_QUALITY     4
#endif /* WINVER >= 0x0400 */

#define DEFAULT_PITCH           0
#define FIXED_PITCH             1
#define VARIABLE_PITCH          2
#if(WINVER >= 0x0400)
#define MONO_FONT               8
#endif /* WINVER >= 0x0400 */

#define ANSI_CHARSET            0
#define DEFAULT_CHARSET         1
#define SYMBOL_CHARSET          2
#define SHIFTJIS_CHARSET        128
#define HANGEUL_CHARSET         129
#define GB2312_CHARSET          134
#define CHINESEBIG5_CHARSET     136
#define OEM_CHARSET             255
#if(WINVER >= 0x0400)
#define JOHAB_CHARSET           130
#define HEBREW_CHARSET          177
#define ARABIC_CHARSET          178
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define THAI_CHARSET            222
#define EASTEUROPE_CHARSET      238
#define RUSSIAN_CHARSET         204

#define MAC_CHARSET             77
#define BALTIC_CHARSET          186

#define FS_LATIN1		0x00000001L
#define FS_LATIN2		0x00000002L
#define FS_CYRILLIC		0x00000004L
#define FS_GREEK		0x00000008L
#define FS_TURKISH		0x00000010L
#define FS_HEBREW		0x00000020L
#define FS_ARABIC		0x00000040L
#define FS_BALTIC		0x00000080L
#define FS_THAI			0x00010000L
#define FS_JISJAPAN		0x00020000L
#define FS_CHINESESIMP  0x00040000L
#define FS_WANSUNG		0x00080000L
#define FS_CHINESETRAD	0x00100000L
#define FS_JOHAB        0x00200000L
#define FS_SYMBOL	    0x80000000L
#endif /* WINVER >= 0x0400 */

/* Font Families */
#define FF_DONTCARE         (0<<4)  /* Don't care or don't know. */
#define FF_ROMAN            (1<<4)  /* Variable stroke width, serifed. */
                                    /* Times Roman, Century Schoolbook, etc. */
#define FF_SWISS            (2<<4)  /* Variable stroke width, sans-serifed. */
                                    /* Helvetica, Swiss, etc. */
#define FF_MODERN           (3<<4)  /* Constant stroke width, serifed or sans-serifed. */
                                    /* Pica, Elite, Courier, etc. */
#define FF_SCRIPT           (4<<4)  /* Cursive, etc. */
#define FF_DECORATIVE       (5<<4)  /* Old English, etc. */

/* Font Weights */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

#define PANOSE_COUNT               10
#define PAN_FAMILYTYPE_INDEX        0
#define PAN_SERIFSTYLE_INDEX        1
#define PAN_WEIGHT_INDEX            2
#define PAN_PROPORTION_INDEX        3
#define PAN_CONTRAST_INDEX          4
#define PAN_STROKEVARIATION_INDEX   5
#define PAN_ARMSTYLE_INDEX          6
#define PAN_LETTERFORM_INDEX        7
#define PAN_MIDLINE_INDEX           8
#define PAN_XHEIGHT_INDEX           9

#define PAN_CULTURE_LATIN           0

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, * LPPANOSE;

#define PAN_ANY                         0 /* Any                            */
#define PAN_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */

#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */

#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */

#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */

#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */

#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */

#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */

#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */

#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */

#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */


#define ELF_VENDOR_SIZE     4

/* The extended logical font       */
/* An extension of the ENUMLOGFONT */

typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[ELF_VENDOR_SIZE];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA, NEAR *NPEXTLOGFONTA, FAR *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[LF_FULLFACESIZE];
    WCHAR       elfStyle[LF_FACESIZE];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[ELF_VENDOR_SIZE];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW, NEAR *NPEXTLOGFONTW, FAR *LPEXTLOGFONTW;
#ifdef UNICODE
typedef EXTLOGFONTW EXTLOGFONT;
typedef PEXTLOGFONTW PEXTLOGFONT;
typedef NPEXTLOGFONTW NPEXTLOGFONT;
typedef LPEXTLOGFONTW LPEXTLOGFONT;
#else
typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
#endif // UNICODE


#define ELF_VERSION         0
#define ELF_CULTURE_LATIN   0

/* EnumFonts Masks */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0x002
#define TRUETYPE_FONTTYPE   0x004

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
#define PALETTERGB(r,g,b)   (0x02000000 | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))

/* palette entry flags */

#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

/* Background Modes */
#define TRANSPARENT         1
#define OPAQUE              2
#define BKMODE_LAST         2

/* Graphics Modes */

#define GM_COMPATIBLE       1
#define GM_ADVANCED         2
#define GM_LAST             2

/* PolyDraw and GetPath point types */
#define PT_CLOSEFIGURE      0x01
#define PT_LINETO           0x02
#define PT_BEZIERTO         0x04
#define PT_MOVETO           0x06

/* Mapping Modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

/* Min and Max Mapping Mode values */
#define MM_MIN              MM_TEXT
#define MM_MAX              MM_ANISOTROPIC
#define MM_MAX_FIXEDSCALE   MM_TWIPS

/* Coordinate Modes */
#define ABSOLUTE            1
#define RELATIVE            2

/* Stock Logical Objects */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16
#if(WINVER >= 0x0400)
#define DEFAULT_GUI_FONT    17
#endif /* WINVER >= 0x0400 */

#if (WINVER >= 0x0400)
#define STOCK_LAST          17
#else
#define STOCK_LAST          16
#endif

#define CLR_INVALID     0xFFFFFFFF

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5
#define BS_DIBPATTERNPT     6
#define BS_PATTERN8X8       7
#define BS_DIBPATTERN8X8    8

/* Hatch Styles */
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
#define PS_NULL             5
#define PS_INSIDEFRAME      6
#define PS_USERSTYLE        7
#define PS_ALTERNATE        8
#define PS_STYLE_MASK       0x0000000F

#define PS_ENDCAP_ROUND     0x00000000
#define PS_ENDCAP_SQUARE    0x00000100
#define PS_ENDCAP_FLAT      0x00000200
#define PS_ENDCAP_MASK      0x00000F00

#define PS_JOIN_ROUND       0x00000000
#define PS_JOIN_BEVEL       0x00001000
#define PS_JOIN_MITER       0x00002000
#define PS_JOIN_MASK        0x0000F000

#define PS_COSMETIC         0x00000000
#define PS_GEOMETRIC        0x00010000
#define PS_TYPE_MASK        0x000F0000

#define AD_COUNTERCLOCKWISE 1
#define AD_CLOCKWISE        2

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0     /* Device driver version                    */
#define TECHNOLOGY    2     /* Device classification                    */
#define HORZSIZE      4     /* Horizontal size in millimeters           */
#define VERTSIZE      6     /* Vertical size in millimeters             */
#define HORZRES       8     /* Horizontal width in pixels               */
#define VERTRES       10    /* Vertical height in pixels                */
#define BITSPIXEL     12    /* Number of bits per pixel                 */
#define PLANES        14    /* Number of planes                         */
#define NUMBRUSHES    16    /* Number of brushes the device has         */
#define NUMPENS       18    /* Number of pens the device has            */
#define NUMMARKERS    20    /* Number of markers the device has         */
#define NUMFONTS      22    /* Number of fonts the device has           */
#define NUMCOLORS     24    /* Number of colors the device supports     */
#define PDEVICESIZE   26    /* Size required for device descriptor      */
#define CURVECAPS     28    /* Curve capabilities                       */
#define LINECAPS      30    /* Line capabilities                        */
#define POLYGONALCAPS 32    /* Polygonal capabilities                   */
#define TEXTCAPS      34    /* Text capabilities                        */
#define CLIPCAPS      36    /* Clipping capabilities                    */
#define RASTERCAPS    38    /* Bitblt capabilities                      */
#define ASPECTX       40    /* Length of the X leg                      */
#define ASPECTY       42    /* Length of the Y leg                      */
#define ASPECTXY      44    /* Length of the hypotenuse                 */

#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */

#define SIZEPALETTE  104    /* Number of entries in physical palette    */
#define NUMRESERVED  106    /* Number of reserved entries in palette    */
#define COLORRES     108    /* Actual color resolution                  */


// Printing related DeviceCaps. These replace the appropriate Escapes

#define PHYSICALWIDTH   110 /* Physical Width in device units           */
#define PHYSICALHEIGHT  111 /* Physical Height in device units          */
#define PHYSICALOFFSETX 112 /* Physical Printable Area x margin         */
#define PHYSICALOFFSETY 113 /* Physical Printable Area y margin         */
#define SCALINGFACTORX  114 /* Scaling factor x                         */
#define SCALINGFACTORY  115 /* Scaling factor y                         */

// Display driver specific

#define VREFRESH        116  /* Current vertical refresh rate of the    */
                             /* display device (for displays only) in Hz*/
#define DESKTOPVERTRES  117  /* Horizontal width of entire desktop in   */
                             /* pixels                                  */
#define DESKTOPHORZRES  118  /* Vertical height of entire desktop in    */
                             /* pixels                                  */
#define BLTALIGNMENT    119  /* Preferred blt alignment                 */

#ifndef NOGDICAPMASKS

/* Device Capability Masks: */

/* Device Technologies */
#define DT_PLOTTER          0   /* Vector plotter                   */
#define DT_RASDISPLAY       1   /* Raster display                   */
#define DT_RASPRINTER       2   /* Raster printer                   */
#define DT_RASCAMERA        3   /* Raster camera                    */
#define DT_CHARSTREAM       4   /* Character-stream, PLP            */
#define DT_METAFILE         5   /* Metafile, VDM                    */
#define DT_DISPFILE         6   /* Display-file                     */

/* Curve Capabilities */
#define CC_NONE             0   /* Curves not supported             */
#define CC_CIRCLES          1   /* Can do circles                   */
#define CC_PIE              2   /* Can do pie wedges                */
#define CC_CHORD            4   /* Can do chord arcs                */
#define CC_ELLIPSES         8   /* Can do ellipese                  */
#define CC_WIDE             16  /* Can do wide lines                */
#define CC_STYLED           32  /* Can do styled lines              */
#define CC_WIDESTYLED       64  /* Can do wide styled lines         */
#define CC_INTERIORS        128 /* Can do interiors                 */
#define CC_ROUNDRECT        256 /*                                  */

/* Line Capabilities */
#define LC_NONE             0   /* Lines not supported              */
#define LC_POLYLINE         2   /* Can do polylines                 */
#define LC_MARKER           4   /* Can do markers                   */
#define LC_POLYMARKER       8   /* Can do polymarkers               */
#define LC_WIDE             16  /* Can do wide lines                */
#define LC_STYLED           32  /* Can do styled lines              */
#define LC_WIDESTYLED       64  /* Can do wide styled lines         */
#define LC_INTERIORS        128 /* Can do interiors                 */

/* Polygonal Capabilities */
#define PC_NONE             0   /* Polygonals not supported         */
#define PC_POLYGON          1   /* Can do polygons                  */
#define PC_RECTANGLE        2   /* Can do rectangles                */
#define PC_WINDPOLYGON      4   /* Can do winding polygons          */
#define PC_TRAPEZOID        4   /* Can do trapezoids                */
#define PC_SCANLINE         8   /* Can do scanlines                 */
#define PC_WIDE             16  /* Can do wide borders              */
#define PC_STYLED           32  /* Can do styled borders            */
#define PC_WIDESTYLED       64  /* Can do wide styled borders       */
#define PC_INTERIORS        128 /* Can do interiors                 */
#define PC_POLYPOLYGON      256 /* Can do polypolygons              */
#define PC_PATHS            512 /* Can do paths                     */

/* Clipping Capabilities */
#define CP_NONE             0   /* No clipping of output            */
#define CP_RECTANGLE        1   /* Output clipped to rects          */
#define CP_REGION           2   /* obsolete                         */

/* Text Capabilities */
#define TC_OP_CHARACTER     0x00000001  /* Can do OutputPrecision   CHARACTER      */
#define TC_OP_STROKE        0x00000002  /* Can do OutputPrecision   STROKE         */
#define TC_CP_STROKE        0x00000004  /* Can do ClipPrecision     STROKE         */
#define TC_CR_90            0x00000008  /* Can do CharRotAbility    90             */
#define TC_CR_ANY           0x00000010  /* Can do CharRotAbility    ANY            */
#define TC_SF_X_YINDEP      0x00000020  /* Can do ScaleFreedom      X_YINDEPENDENT */
#define TC_SA_DOUBLE        0x00000040  /* Can do ScaleAbility      DOUBLE         */
#define TC_SA_INTEGER       0x00000080  /* Can do ScaleAbility      INTEGER        */
#define TC_SA_CONTIN        0x00000100  /* Can do ScaleAbility      CONTINUOUS     */
#define TC_EA_DOUBLE        0x00000200  /* Can do EmboldenAbility   DOUBLE         */
#define TC_IA_ABLE          0x00000400  /* Can do ItalisizeAbility  ABLE           */
#define TC_UA_ABLE          0x00000800  /* Can do UnderlineAbility  ABLE           */
#define TC_SO_ABLE          0x00001000  /* Can do StrikeOutAbility  ABLE           */
#define TC_RA_ABLE          0x00002000  /* Can do RasterFontAble    ABLE           */
#define TC_VA_ABLE          0x00004000  /* Can do VectorFontAble    ABLE           */
#define TC_RESERVED         0x00008000
#define TC_SCROLLBLT        0x00010000  /* Don't do text scroll with blt           */

#endif /* NOGDICAPMASKS */

/* Raster Capabilities */
#define RC_NONE
#define RC_BITBLT           1       /* Can do standard BLT.             */
#define RC_BANDING          2       /* Device requires banding support  */
#define RC_SCALING          4       /* Device requires scaling support  */
#define RC_BITMAP64         8       /* Device can support >64K bitmap   */
#define RC_GDI20_OUTPUT     0x0010      /* has 2.0 output calls         */
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080      /* supports DIB to memory       */
#define RC_PALETTE          0x0100      /* supports a palette           */
#define RC_DIBTODEV         0x0200      /* supports DIBitsToDevice      */
#define RC_BIGFONT          0x0400      /* supports >64K fonts          */
#define RC_STRETCHBLT       0x0800      /* supports StretchBlt          */
#define RC_FLOODFILL        0x1000      /* supports FloodFill           */
#define RC_STRETCHDIB       0x2000      /* supports StretchDIBits       */
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000


/* DIB color table identifiers */

#define DIB_RGB_COLORS      0 /* color table in RGBs */
#define DIB_PAL_COLORS      1 /* color table in palette indices */

/* constants for Get/SetSystemPaletteUse() */

#define SYSPAL_ERROR    0
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* constants for CreateDIBitmap */
#define CBM_INIT        0x04L   /* initialize bitmap */

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

/* size of a device name string */
#define CCHDEVICENAME 32

/* size of a form name string */
#define CCHFORMNAME 32

typedef struct _devicemodeA {
    BYTE   dmDeviceName[CCHDEVICENAME];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[CCHFORMNAME];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
#if (WINVER >= 0x0400)
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
#endif /* WINVER */
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR  dmDeviceName[CCHDEVICENAME];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[CCHFORMNAME];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
#if (WINVER >= 0x0400)
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
#endif /* WINVER */
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;
#ifdef UNICODE
typedef DEVMODEW DEVMODE;
typedef PDEVMODEW PDEVMODE;
typedef NPDEVMODEW NPDEVMODE;
typedef LPDEVMODEW LPDEVMODE;
#else
typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
#endif // UNICODE

/* current version of specification */
#if (WINVER >= 0x0400)
#define DM_SPECVERSION 0x0400
#else
#define DM_SPECVERSION 0x0320
#endif /* WINVER */

/* field selection bits */
#define DM_ORIENTATION      0x00000001L
#define DM_PAPERSIZE        0x00000002L
#define DM_PAPERLENGTH      0x00000004L
#define DM_PAPERWIDTH       0x00000008L
#define DM_SCALE            0x00000010L
#define DM_COPIES           0x00000100L
#define DM_DEFAULTSOURCE    0x00000200L
#define DM_PRINTQUALITY     0x00000400L
#define DM_COLOR            0x00000800L
#define DM_DUPLEX           0x00001000L
#define DM_YRESOLUTION      0x00002000L
#define DM_TTOPTION         0x00004000L
#define DM_COLLATE          0x00008000L
#define DM_FORMNAME         0x00010000L
#define DM_LOGPIXELS        0x00020000L
#define DM_BITSPERPEL       0x00040000L
#define DM_PELSWIDTH        0x00080000L
#define DM_PELSHEIGHT       0x00100000L
#define DM_DISPLAYFLAGS     0x00200000L
#define DM_DISPLAYFREQUENCY 0x00400000L
#if(WINVER >= 0x0400)
#define DM_ICMMETHOD	    0x00800000L
#define DM_ICMINTENT	    0x01000000L
#define DM_MEDIATYPE	    0x02000000L
#define DM_DITHERTYPE	    0x04000000L
#endif /* WINVER >= 0x0400 */

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
#define DMPAPER_FIRST                DMPAPER_LETTER
#define DMPAPER_LETTER               1  /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL          2  /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID              3  /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER               4  /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL                5  /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT            6  /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE            7  /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3                   8  /* A3 297 x 420 mm                    */
#define DMPAPER_A4                   9  /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL             10  /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5                  11  /* A5 148 x 210 mm                    */
#define DMPAPER_B4                  12  /* B4 (JIS) 250 x 354                 */
#define DMPAPER_B5                  13  /* B5 (JIS) 182 x 257 mm              */
#define DMPAPER_FOLIO               14  /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO              15  /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14               16  /* 10x14 in                           */
#define DMPAPER_11X17               17  /* 11x17 in                           */
#define DMPAPER_NOTE                18  /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9               19  /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10              20  /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11              21  /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12              22  /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14              23  /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET              24  /* C size sheet                       */
#define DMPAPER_DSHEET              25  /* D size sheet                       */
#define DMPAPER_ESHEET              26  /* E size sheet                       */
#define DMPAPER_ENV_DL              27  /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5              28  /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3              29  /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4              30  /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6              31  /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65             32  /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4              33  /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5              34  /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6              35  /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY           36  /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH         37  /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL        38  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US          39  /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
#if(WINVER >= 0x0400)
#define DMPAPER_ISO_B4              42  /* B4 (ISO) 250 x 353 mm              */
#define DMPAPER_JAPANESE_POSTCARD   43  /* Japanese Postcard 100 x 148 mm     */
#define DMPAPER_9X11                44  /* 9 x 11 in                          */
#define DMPAPER_10X11               45  /* 10 x 11 in                         */
#define DMPAPER_15X11               46  /* 15 x 11 in                         */
#define DMPAPER_ENV_INVITE          47  /* Envelope Invite 220 x 220 mm       */
#define DMPAPER_RESERVED_48         48  /* RESERVED--DO NOT USE               */
#define DMPAPER_RESERVED_49         49  /* RESERVED--DO NOT USE               */
#define DMPAPER_LETTER_EXTRA	    50  /* Letter Extra 9 \275 x 12 in        */
#define DMPAPER_LEGAL_EXTRA 	    51  /* Legal Extra 9 \275 x 15 in         */
#define DMPAPER_TABLOID_EXTRA	    52  /* Tabloid Extra 11.69 x 18 in        */
#define DMPAPER_A4_EXTRA     	    53  /* A4 Extra 9.27 x 12.69 in           */
#define DMPAPER_LETTER_TRANSVERSE   54  /* Letter Transverse 8 \275 x 11 in   */
#define DMPAPER_A4_TRANSVERSE       55  /* A4 Transverse 210 x 297 mm         */
#define DMPAPER_LETTER_EXTRA_TRANSVERSE 56 /* Letter Extra Transverse 9\275 x 12 in */
#define DMPAPER_A_PLUS              57  /* SuperA/SuperA/A4 227 x 356 mm      */
#define DMPAPER_B_PLUS              58  /* SuperB/SuperB/A3 305 x 487 mm      */
#define DMPAPER_LETTER_PLUS         59  /* Letter Plus 8.5 x 12.69 in         */
#define DMPAPER_A4_PLUS             60  /* A4 Plus 210 x 330 mm               */
#define DMPAPER_A5_TRANSVERSE       61  /* A5 Transverse 148 x 210 mm         */
#define DMPAPER_B5_TRANSVERSE       62  /* B5 (JIS) Transverse 182 x 257 mm   */
#define DMPAPER_A3_EXTRA            63  /* A3 Extra 322 x 445 mm              */
#define DMPAPER_A5_EXTRA            64  /* A5 Extra 174 x 235 mm              */
#define DMPAPER_B5_EXTRA            65  /* B5 (ISO) Extra 201 x 276 mm        */
#define DMPAPER_A2                  66  /* A2 420 x 594 mm                    */
#define DMPAPER_A3_TRANSVERSE       67  /* A3 Transverse 297 x 420 mm         */
#define DMPAPER_A3_EXTRA_TRANSVERSE 68  /* A3 Extra Transverse 322 x 445 mm   */
#endif /* WINVER >= 0x0400 */

#if (WINVER >= 0x0400)
#define DMPAPER_LAST                DMPAPER_A3_EXTRA_TRANSVERSE
#else
#define DMPAPER_LAST                DMPAPER_FANFOLD_LGL_GERMAN
#endif

#define DMPAPER_USER                256

/* bin selections */
#define DMBIN_FIRST         DMBIN_UPPER
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_FORMSOURCE    15
#define DMBIN_LAST          DMBIN_FORMSOURCE

#define DMBIN_USER          256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT         (-1)
#define DMRES_LOW           (-2)
#define DMRES_MEDIUM        (-3)
#define DMRES_HIGH          (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR       2

/* duplex enable */
#define DMDUP_SIMPLEX    1
#define DMDUP_VERTICAL   2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */
#if(WINVER >= 0x0400)
#define DMTT_DOWNLOAD_OUTLINE 4 /* download TT fonts as outline soft fonts */
#endif /* WINVER >= 0x0400 */

/* Collation selections */
#define DMCOLLATE_FALSE  0
#define DMCOLLATE_TRUE   1

/* DEVMODE dmDisplayFlags flags */

#define DM_GRAYSCALE  0x00000001
#define DM_INTERLACED 0x00000002

#if(WINVER >= 0x0400)
/* ICM methods */
#define DMICMMETHOD_NONE    1   /* ICM disabled */
#define DMICMMETHOD_SYSTEM  2   /* ICM handled by system */
#define DMICMMETHOD_DRIVER  3   /* ICM handled by driver */
#define DMICMMETHOD_DEVICE  4   /* ICM handled by device */

#define DMICMMETHOD_USER  256   /* Device-specific methods start here */

/* ICM Intents */
#define DMICM_SATURATE      1   /* Maximize color saturation */
#define DMICM_CONTRAST      2   /* Maximize color contrast */
#define DMICM_COLORMETRIC   3   /* Use specific color metric */

#define DMICM_USER        256   /* Device-specific intents start here */

/* Media types */

#define DMMEDIA_STANDARD      1   /* Standard paper */
#define DMMEDIA_TRANSPARENCY  2   /* Transparency */
#define DMMEDIA_GLOSSY        3   /* Glossy paper */

#define DMMEDIA_USER        256   /* Device-specific media start here */

/* Dither types */
#define DMDITHER_NONE		1   /* No dithering */
#define DMDITHER_COARSE 	2   /* Dither with a coarse brush */
#define DMDITHER_FINE		3   /* Dither with a fine brush */
#define DMDITHER_LINEART	4   /* LineArt dithering */

#define DMDITHER_ERRORDIFFUSION 5 /* LineArt dithering */
#define DMDITHER_RESERVED6	6   /* LineArt dithering */
#define DMDITHER_RESERVED7	7   /* LineArt dithering */
#define DMDITHER_RESERVED8	8   /* LineArt dithering */
#define DMDITHER_RESERVED9	9   /* LineArt dithering */

#define DMDITHER_GRAYSCALE     10   /* Device does grayscaling */

#define DMDITHER_USER     256   /* Device-specific dithers start here */
#endif /* WINVER >= 0x0400 */

/* GetRegionData/ExtCreateRegion */

#define RDH_RECTANGLES  1

typedef struct _RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA, NEAR *NPRGNDATA, FAR *LPRGNDATA;


typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC, NEAR *NPABC, FAR *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT, NEAR *NPABCFLOAT, FAR *LPABCFLOAT;

#ifndef NOTEXTMETRIC

typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, NEAR *NPOUTLINETEXTMETRICA, FAR *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, NEAR *NPOUTLINETEXTMETRICW, FAR *LPOUTLINETEXTMETRICW;
#ifdef UNICODE
typedef OUTLINETEXTMETRICW OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICW POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICW NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICW LPOUTLINETEXTMETRIC;
#else
typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
#endif // UNICODE

#endif /* NOTEXTMETRIC */


typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA, NEAR *NPPOLYTEXTA, FAR *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW, NEAR *NPPOLYTEXTW, FAR *LPPOLYTEXTW;
#ifdef UNICODE
typedef POLYTEXTW POLYTEXT;
typedef PPOLYTEXTW PPOLYTEXT;
typedef NPPOLYTEXTW NPPOLYTEXT;
typedef LPPOLYTEXTW LPPOLYTEXT;
#else
typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
#endif // UNICODE

typedef struct _FIXED {
    WORD    fract;
    short   value;
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2, FAR *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS, FAR *LPGLYPHMETRICS;

//  GetGlyphOutline constants

#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#if(WINVER >= 0x0400)
#define  GGO_GRAY2_BITMAP   4
#define  GGO_GRAY4_BITMAP   5
#define  GGO_GRAY8_BITMAP   6
#define  GGO_GLYPH_INDEX    0x0080
#endif /* WINVER >= 0x0400 */

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;


#if(WINVER >= 0x0400)
#define GCP_DBCS           0x0001
#define GCP_REORDER        0x0002
#define GCP_USEKERNING     0x0008
#define GCP_GLYPHSHAPE     0x0010
#define GCP_LIGATE         0x0020
////#define GCP_GLYPHINDEXING  0x0080
#define GCP_DIACRITIC      0x0100
#define GCP_KASHIDA	   0x0400
#define GCP_ERROR          0x8000
#define FLI_MASK	   0x103B

#define GCP_JUSTIFY        0x00010000L
////#define GCP_NODIACRITICS   0x00020000L
#define FLI_GLYPHS	   0x00040000L
#define GCP_CLASSIN        0x00080000L	
#define GCP_MAXEXTENT      0x00100000L
#define GCP_JUSTIFYIN	   0x00200000L
#define GCP_DISPLAYZWG      0x00400000L
#define GCP_SYMSWAPOFF      0x00800000L
#define GCP_NUMERICOVERRIDE 0x01000000L
#define GCP_NEUTRALOVERRIDE 0x02000000L
#define GCP_NUMERICSLATIN   0x04000000L
#define GCP_NUMERICSLOCAL   0x08000000L

#define GCPCLASS_LATIN                  1
#define GCPCLASS_HEBREW                 2
#define GCPCLASS_ARABIC                 2
#define GCPCLASS_NEUTRAL                3
#define GCPCLASS_LOCALNUMBER            4
#define GCPCLASS_LATINNUMBER            5
#define GCPCLASS_LATINNUMERICTERMINATOR 6
#define GCPCLASS_LATINNUMERICSEPARATOR  7
#define GCPCLASS_NUMERICSEPARATOR       8
#define GCPCLASS_PREBOUNDLTR         0x80
#define GCPCLASS_PREBOUNDRTL         0x40
#define GCPCLASS_POSTBOUNDLTR        0x20
#define GCPCLASS_POSTBOUNDRTL        0x10

#define GCPGLYPH_LINKBEFORE          0x8000
#define GCPGLYPH_LINKAFTER           0x4000


typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT FAR *lpOrder;
    int FAR  *lpDx;
    int FAR  *lpCaretPos;
    LPSTR     lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA, FAR* LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT FAR *lpOrder;
    int FAR  *lpDx;
    int FAR  *lpCaretPos;
    LPWSTR    lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW, FAR* LPGCP_RESULTSW;
#ifdef UNICODE
typedef GCP_RESULTSW GCP_RESULTS;
typedef LPGCP_RESULTSW LPGCP_RESULTS;
#else
typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

typedef struct _RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS, FAR *LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE    0x0001
#define TT_ENABLED      0x0002

/* Pixel format descriptor */
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, FAR *LPPIXELFORMATDESCRIPTOR;

/* pixel types */
#define PFD_TYPE_RGBA        0
#define PFD_TYPE_COLORINDEX  1

/* layer types */
#define PFD_MAIN_PLANE       0
#define PFD_OVERLAY_PLANE    1
#define PFD_UNDERLAY_PLANE   (-1)

/* PIXELFORMATDESCRIPTOR flags */
#define PFD_DOUBLEBUFFER            0x00000001
#define PFD_STEREO                  0x00000002
#define PFD_DRAW_TO_WINDOW          0x00000004
#define PFD_DRAW_TO_BITMAP          0x00000008
#define PFD_SUPPORT_GDI             0x00000010
#define PFD_SUPPORT_OPENGL          0x00000020
#define PFD_GENERIC_FORMAT          0x00000040
#define PFD_NEED_PALETTE            0x00000080
#define PFD_NEED_SYSTEM_PALETTE     0x00000100
#define PFD_SWAP_EXCHANGE           0x00000200
#define PFD_SWAP_COPY               0x00000400

/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */
#define PFD_DOUBLEBUFFER_DONTCARE   0x40000000
#define PFD_STEREO_DONTCARE         0x80000000

#ifdef STRICT
#if !defined(NOTEXTMETRIC)
typedef int (CALLBACK* OLDFONTENUMPROCA)(CONST LOGFONTA *, CONST TEXTMETRICA *, DWORD, LPARAM);
typedef int (CALLBACK* OLDFONTENUMPROCW)(CONST LOGFONTW *, CONST TEXTMETRICW *, DWORD, LPARAM);
#ifdef UNICODE
#define OLDFONTENUMPROC  OLDFONTENUMPROCW
#else
#define OLDFONTENUMPROC  OLDFONTENUMPROCA
#endif // !UNICODE
#else
typedef int (CALLBACK* OLDFONTENUMPROCA)(CONST LOGFONTA * ,CONST VOID *, DWORD, LPARAM);
typedef int (CALLBACK* OLDFONTENUMPROCW)(CONST LOGFONTW * ,CONST VOID *, DWORD, LPARAM);
#ifdef UNICODE
#define OLDFONTENUMPROC  OLDFONTENUMPROCW
#else
#define OLDFONTENUMPROC  OLDFONTENUMPROCA
#endif // !UNICODE
#endif

typedef OLDFONTENUMPROCA    FONTENUMPROCA;
typedef OLDFONTENUMPROCW    FONTENUMPROCW;
#ifdef UNICODE
typedef FONTENUMPROCW FONTENUMPROC;
#else
typedef FONTENUMPROCA FONTENUMPROC;
#endif // UNICODE

typedef int (CALLBACK* GOBJENUMPROC)(LPVOID, LPARAM);
typedef VOID (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROCA;
typedef FARPROC FONTENUMPROCW;
#ifdef UNICODE
typedef FONTENUMPROCW FONTENUMPROC;
#else
typedef FONTENUMPROCA FONTENUMPROC;
#endif // UNICODE
typedef FARPROC GOBJENUMPROC;
typedef FARPROC LINEDDAPROC;
#endif

WINGDIAPI int WINAPI AddFontResourceA(LPCSTR);
WINGDIAPI int WINAPI AddFontResourceW(LPCWSTR);
#ifdef UNICODE
#define AddFontResource  AddFontResourceW
#else
#define AddFontResource  AddFontResourceA
#endif // !UNICODE

WINGDIAPI BOOL  WINAPI AnimatePalette(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
WINGDIAPI BOOL  WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
WINGDIAPI BOOL  WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
WINGDIAPI BOOL  WINAPI CancelDC(HDC);
WINGDIAPI BOOL  WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
WINGDIAPI int   WINAPI ChoosePixelFormat(HDC, CONST PIXELFORMATDESCRIPTOR *);
WINGDIAPI HMETAFILE  WINAPI CloseMetaFile(HDC);
WINGDIAPI int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);
WINGDIAPI HMETAFILE WINAPI CopyMetaFileA(HMETAFILE, LPCSTR);
WINGDIAPI HMETAFILE WINAPI CopyMetaFileW(HMETAFILE, LPCWSTR);
#ifdef UNICODE
#define CopyMetaFile  CopyMetaFileW
#else
#define CopyMetaFile  CopyMetaFileA
#endif // !UNICODE
WINGDIAPI HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, CONST VOID *);
WINGDIAPI HBITMAP WINAPI CreateBitmapIndirect(CONST BITMAP *);
WINGDIAPI HBRUSH  WINAPI CreateBrushIndirect(CONST LOGBRUSH *);
WINGDIAPI HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
WINGDIAPI HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
WINGDIAPI HDC     WINAPI CreateCompatibleDC(HDC);
WINGDIAPI HDC     WINAPI CreateDCA(LPCSTR, LPCSTR , LPCSTR , CONST DEVMODEA *);
WINGDIAPI HDC     WINAPI CreateDCW(LPCWSTR, LPCWSTR , LPCWSTR , CONST DEVMODEW *);
#ifdef UNICODE
#define CreateDC  CreateDCW
#else
#define CreateDC  CreateDCA
#endif // !UNICODE
WINGDIAPI HBITMAP WINAPI CreateDIBitmap(HDC, CONST BITMAPINFOHEADER *, DWORD, CONST VOID *, CONST BITMAPINFO *, UINT);
WINGDIAPI HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
WINGDIAPI HBRUSH  WINAPI CreateDIBPatternBrushPt(CONST VOID *, UINT);
WINGDIAPI HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
WINGDIAPI HRGN    WINAPI CreateEllipticRgnIndirect(CONST RECT *);
WINGDIAPI HFONT   WINAPI CreateFontIndirectA(CONST LOGFONTA *);
WINGDIAPI HFONT   WINAPI CreateFontIndirectW(CONST LOGFONTW *);
#ifdef UNICODE
#define CreateFontIndirect  CreateFontIndirectW
#else
#define CreateFontIndirect  CreateFontIndirectA
#endif // !UNICODE
WINGDIAPI HFONT   WINAPI CreateFontA(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCSTR);
WINGDIAPI HFONT   WINAPI CreateFontW(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);
#ifdef UNICODE
#define CreateFont  CreateFontW
#else
#define CreateFont  CreateFontA
#endif // !UNICODE

WINGDIAPI HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
WINGDIAPI HDC     WINAPI CreateICA(LPCSTR, LPCSTR , LPCSTR , CONST DEVMODEA *);
WINGDIAPI HDC     WINAPI CreateICW(LPCWSTR, LPCWSTR , LPCWSTR , CONST DEVMODEW *);
#ifdef UNICODE
#define CreateIC  CreateICW
#else
#define CreateIC  CreateICA
#endif // !UNICODE
WINGDIAPI HDC     WINAPI CreateMetaFileA(LPCSTR);
WINGDIAPI HDC     WINAPI CreateMetaFileW(LPCWSTR);
#ifdef UNICODE
#define CreateMetaFile  CreateMetaFileW
#else
#define CreateMetaFile  CreateMetaFileA
#endif // !UNICODE
WINGDIAPI HPALETTE WINAPI CreatePalette(CONST LOGPALETTE *);
WINGDIAPI HPEN    WINAPI CreatePen(int, int, COLORREF);
WINGDIAPI HPEN    WINAPI CreatePenIndirect(CONST LOGPEN *);
WINGDIAPI HRGN    WINAPI CreatePolyPolygonRgn(CONST POINT *, CONST INT *, int, int);
WINGDIAPI HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
WINGDIAPI HRGN    WINAPI CreateRectRgn(int, int, int, int);
WINGDIAPI HRGN    WINAPI CreateRectRgnIndirect(CONST RECT *);
WINGDIAPI HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);
WINGDIAPI BOOL    WINAPI CreateScalableFontResourceA(DWORD, LPCSTR, LPCSTR, LPCSTR);
WINGDIAPI BOOL    WINAPI CreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR);
#ifdef UNICODE
#define CreateScalableFontResource  CreateScalableFontResourceW
#else
#define CreateScalableFontResource  CreateScalableFontResourceA
#endif // !UNICODE
WINGDIAPI HBRUSH  WINAPI CreateSolidBrush(COLORREF);

WINGDIAPI BOOL WINAPI DeleteDC(HDC);
WINGDIAPI BOOL WINAPI DeleteMetaFile(HMETAFILE);
WINGDIAPI BOOL WINAPI DeleteObject(HGDIOBJ);
WINGDIAPI int  WINAPI DescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 */

typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8

#define DM_IN_BUFFER        DM_MODIFY
#define DM_IN_PROMPT        DM_PROMPT
#define DM_OUT_BUFFER       DM_COPY
#define DM_OUT_DEFAULT      DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS           1
#define DC_PAPERS           2
#define DC_PAPERSIZE        3
#define DC_MINEXTENT        4
#define DC_MAXEXTENT        5
#define DC_BINS             6
#define DC_DUPLEX           7
#define DC_SIZE             8
#define DC_EXTRA            9
#define DC_VERSION          10
#define DC_DRIVER           11
#define DC_BINNAMES         12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE         15
#define DC_PAPERNAMES       16
#define DC_ORIENTATION      17
#define DC_COPIES           18
#if(WINVER >= 0x0400)
#define DC_BINADJUST            19
#define DC_EMF_COMPLIANT        20
#define DC_DATATYPE_PRODUCED    21
#define DC_MANUFACTURER 	23
#define DC_MODEL		24
#endif /* WINVER >= 0x0400 */

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP             0x0000001L
#define DCTT_DOWNLOAD           0x0000002L
#define DCTT_SUBDEV             0x0000004L
#if(WINVER >= 0x0400)
#define DCTT_DOWNLOAD_OUTLINE   0x0000008L

/* return values for DC_BINADJUST */
#define DCBA_FACEUPNONE       0x0000
#define DCBA_FACEUPCENTER     0x0001
#define DCBA_FACEUPLEFT       0x0002
#define DCBA_FACEUPRIGHT      0x0003
#define DCBA_FACEDOWNNONE     0x0100
#define DCBA_FACEDOWNCENTER   0x0101
#define DCBA_FACEDOWNLEFT     0x0102
#define DCBA_FACEDOWNRIGHT    0x0103
#endif /* WINVER >= 0x0400 */

WINSPOOLAPI int  WINAPI DeviceCapabilitiesA(LPCSTR, LPCSTR, WORD,
                                LPSTR, CONST DEVMODEA *);
WINSPOOLAPI int  WINAPI DeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
                                LPWSTR, CONST DEVMODEW *);
#ifdef UNICODE
#define DeviceCapabilities  DeviceCapabilitiesW
#else
#define DeviceCapabilities  DeviceCapabilitiesA
#endif // !UNICODE

WINGDIAPI int  WINAPI DrawEscape(HDC, int, int, LPCSTR);
WINGDIAPI BOOL WINAPI Ellipse(HDC, int, int, int, int);

#if(WINVER >= 0x0400)
WINGDIAPI int  WINAPI EnumFontFamiliesExA(HDC, LPLOGFONTA,FONTENUMPROCA, LPARAM,DWORD);
WINGDIAPI int  WINAPI EnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD);
#ifdef UNICODE
#define EnumFontFamiliesEx  EnumFontFamiliesExW
#else
#define EnumFontFamiliesEx  EnumFontFamiliesExA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINGDIAPI int  WINAPI EnumFontFamiliesA(HDC, LPCSTR, FONTENUMPROCA, LPARAM);
WINGDIAPI int  WINAPI EnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM);
#ifdef UNICODE
#define EnumFontFamilies  EnumFontFamiliesW
#else
#define EnumFontFamilies  EnumFontFamiliesA
#endif // !UNICODE
WINGDIAPI int  WINAPI EnumFontsA(HDC, LPCSTR,  FONTENUMPROCA, LPARAM);
WINGDIAPI int  WINAPI EnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM);
#ifdef UNICODE
#define EnumFonts  EnumFontsW
#else
#define EnumFonts  EnumFontsA
#endif // !UNICODE

#ifdef STRICT
WINGDIAPI int  WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
WINGDIAPI int  WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPVOID);
#endif


WINGDIAPI BOOL WINAPI EqualRgn(HRGN, HRGN);
WINGDIAPI int  WINAPI Escape(HDC, int, int, LPCSTR, LPVOID);
WINGDIAPI int  WINAPI ExtEscape(HDC, int, int, LPCSTR, int, LPSTR);
WINGDIAPI int  WINAPI ExcludeClipRect(HDC, int, int, int, int);
WINGDIAPI HRGN WINAPI ExtCreateRegion(CONST XFORM *, DWORD, CONST RGNDATA *);
WINGDIAPI BOOL  WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);
WINGDIAPI BOOL   WINAPI FillRgn(HDC, HRGN, HBRUSH);
WINGDIAPI BOOL   WINAPI FloodFill(HDC, int, int, COLORREF);
WINGDIAPI BOOL   WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
WINGDIAPI int   WINAPI GetROP2(HDC);
WINGDIAPI BOOL  WINAPI GetAspectRatioFilterEx(HDC, LPSIZE);
WINGDIAPI COLORREF WINAPI GetBkColor(HDC);
WINGDIAPI int   WINAPI GetBkMode(HDC);
WINGDIAPI LONG  WINAPI GetBitmapBits(HBITMAP, LONG, LPVOID);
WINGDIAPI BOOL  WINAPI GetBitmapDimensionEx(HBITMAP, LPSIZE);
WINGDIAPI UINT  WINAPI GetBoundsRect(HDC, LPRECT, UINT);

WINGDIAPI BOOL  WINAPI GetBrushOrgEx(HDC, LPPOINT);

WINGDIAPI BOOL  WINAPI GetCharWidthA(HDC, UINT, UINT, LPINT);
WINGDIAPI BOOL  WINAPI GetCharWidthW(HDC, UINT, UINT, LPINT);
#ifdef UNICODE
#define GetCharWidth  GetCharWidthW
#else
#define GetCharWidth  GetCharWidthA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI GetCharWidth32A(HDC, UINT, UINT, LPINT);
WINGDIAPI BOOL  WINAPI GetCharWidth32W(HDC, UINT, UINT, LPINT);
#ifdef UNICODE
#define GetCharWidth32  GetCharWidth32W
#else
#define GetCharWidth32  GetCharWidth32A
#endif // !UNICODE
WINGDIAPI BOOL  APIENTRY GetCharWidthFloatA(HDC, UINT, UINT, PFLOAT);
WINGDIAPI BOOL  APIENTRY GetCharWidthFloatW(HDC, UINT, UINT, PFLOAT);
#ifdef UNICODE
#define GetCharWidthFloat  GetCharWidthFloatW
#else
#define GetCharWidthFloat  GetCharWidthFloatA
#endif // !UNICODE

WINGDIAPI BOOL  APIENTRY GetCharABCWidthsA(HDC, UINT, UINT, LPABC);
WINGDIAPI BOOL  APIENTRY GetCharABCWidthsW(HDC, UINT, UINT, LPABC);
#ifdef UNICODE
#define GetCharABCWidths  GetCharABCWidthsW
#else
#define GetCharABCWidths  GetCharABCWidthsA
#endif // !UNICODE
WINGDIAPI BOOL  APIENTRY GetCharABCWidthsFloatA(HDC, UINT, UINT, LPABCFLOAT);
WINGDIAPI BOOL  APIENTRY GetCharABCWidthsFloatW(HDC, UINT, UINT, LPABCFLOAT);
#ifdef UNICODE
#define GetCharABCWidthsFloat  GetCharABCWidthsFloatW
#else
#define GetCharABCWidthsFloat  GetCharABCWidthsFloatA
#endif // !UNICODE

WINGDIAPI int   WINAPI GetClipBox(HDC, LPRECT);
WINGDIAPI int   WINAPI GetClipRgn(HDC, HRGN);
WINGDIAPI int   WINAPI GetMetaRgn(HDC, HRGN);
WINGDIAPI HGDIOBJ WINAPI GetCurrentObject(HDC, UINT);
WINGDIAPI BOOL  WINAPI GetCurrentPositionEx(HDC, LPPOINT);
WINGDIAPI int   WINAPI GetDeviceCaps(HDC, int);
WINGDIAPI int   WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, LPVOID, LPBITMAPINFO, UINT);
WINGDIAPI DWORD WINAPI GetFontData(HDC, DWORD, DWORD, LPVOID, DWORD);
WINGDIAPI DWORD WINAPI GetGlyphOutlineA(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, CONST MAT2 *);
WINGDIAPI DWORD WINAPI GetGlyphOutlineW(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, CONST MAT2 *);
#ifdef UNICODE
#define GetGlyphOutline  GetGlyphOutlineW
#else
#define GetGlyphOutline  GetGlyphOutlineA
#endif // !UNICODE
WINGDIAPI int   WINAPI GetGraphicsMode(HDC);
WINGDIAPI int   WINAPI GetMapMode(HDC);
WINGDIAPI UINT  WINAPI GetMetaFileBitsEx(HMETAFILE, UINT, LPVOID);
WINGDIAPI HMETAFILE   WINAPI GetMetaFileA(LPCSTR);
WINGDIAPI HMETAFILE   WINAPI GetMetaFileW(LPCWSTR);
#ifdef UNICODE
#define GetMetaFile  GetMetaFileW
#else
#define GetMetaFile  GetMetaFileA
#endif // !UNICODE
WINGDIAPI COLORREF WINAPI GetNearestColor(HDC, COLORREF);
WINGDIAPI UINT  WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);
WINGDIAPI DWORD WINAPI GetObjectType(HGDIOBJ h);

#ifndef NOTEXTMETRIC

WINGDIAPI UINT APIENTRY GetOutlineTextMetricsA(HDC, UINT, LPOUTLINETEXTMETRICA);
WINGDIAPI UINT APIENTRY GetOutlineTextMetricsW(HDC, UINT, LPOUTLINETEXTMETRICW);
#ifdef UNICODE
#define GetOutlineTextMetrics  GetOutlineTextMetricsW
#else
#define GetOutlineTextMetrics  GetOutlineTextMetricsA
#endif // !UNICODE

#endif /* NOTEXTMETRIC */

WINGDIAPI UINT  WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, LPPALETTEENTRY);
WINGDIAPI COLORREF WINAPI GetPixel(HDC, int, int);
WINGDIAPI int   WINAPI GetPixelFormat(HDC);
WINGDIAPI int   WINAPI GetPolyFillMode(HDC);
WINGDIAPI BOOL  WINAPI GetRasterizerCaps(LPRASTERIZER_STATUS, UINT);
WINGDIAPI DWORD WINAPI GetRegionData(HRGN, DWORD, LPRGNDATA);
WINGDIAPI int   WINAPI GetRgnBox(HRGN, LPRECT);
WINGDIAPI HGDIOBJ WINAPI GetStockObject(int);
WINGDIAPI int   WINAPI GetStretchBltMode(HDC);
WINGDIAPI UINT  WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, LPPALETTEENTRY);
WINGDIAPI UINT  WINAPI GetSystemPaletteUse(HDC);
WINGDIAPI int   WINAPI GetTextCharacterExtra(HDC);
WINGDIAPI UINT  WINAPI GetTextAlign(HDC);
WINGDIAPI COLORREF WINAPI GetTextColor(HDC);

WINGDIAPI BOOL  APIENTRY GetTextExtentPointA(
                    HDC,
                    LPCSTR,
                    int,
                    LPSIZE
                    );
WINGDIAPI BOOL  APIENTRY GetTextExtentPointW(
                    HDC,
                    LPCWSTR,
                    int,
                    LPSIZE
                    );
#ifdef UNICODE
#define GetTextExtentPoint  GetTextExtentPointW
#else
#define GetTextExtentPoint  GetTextExtentPointA
#endif // !UNICODE

WINGDIAPI BOOL  APIENTRY GetTextExtentPoint32A(
                    HDC,
                    LPCSTR,
                    int,
                    LPSIZE
                    );
WINGDIAPI BOOL  APIENTRY GetTextExtentPoint32W(
                    HDC,
                    LPCWSTR,
                    int,
                    LPSIZE
                    );
#ifdef UNICODE
#define GetTextExtentPoint32  GetTextExtentPoint32W
#else
#define GetTextExtentPoint32  GetTextExtentPoint32A
#endif // !UNICODE

WINGDIAPI BOOL  APIENTRY GetTextExtentExPointA(
                    HDC,
                    LPCSTR,
                    int,
                    int,
                    LPINT,
                    LPINT,
                    LPSIZE
                    );
WINGDIAPI BOOL  APIENTRY GetTextExtentExPointW(
                    HDC,
                    LPCWSTR,
                    int,
                    int,
                    LPINT,
                    LPINT,
                    LPSIZE
                    );
#ifdef UNICODE
#define GetTextExtentExPoint  GetTextExtentExPointW
#else
#define GetTextExtentExPoint  GetTextExtentExPointA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINGDIAPI int WINAPI GetTextCharset(HDC hdc);
WINGDIAPI int WINAPI GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
WINGDIAPI BOOL WINAPI TranslateCharsetInfo( DWORD FAR *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
WINGDIAPI DWORD WINAPI GetFontLanguageInfo( HDC );
WINGDIAPI DWORD WINAPI GetCharacterPlacementA(HDC, LPCSTR, int, int, LPGCP_RESULTSA, DWORD);
WINGDIAPI DWORD WINAPI GetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD);
#ifdef UNICODE
#define GetCharacterPlacement  GetCharacterPlacementW
#else
#define GetCharacterPlacement  GetCharacterPlacementA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINGDIAPI BOOL  WINAPI GetViewportExtEx(HDC, LPSIZE);
WINGDIAPI BOOL  WINAPI GetViewportOrgEx(HDC, LPPOINT);
WINGDIAPI BOOL  WINAPI GetWindowExtEx(HDC, LPSIZE);
WINGDIAPI BOOL  WINAPI GetWindowOrgEx(HDC, LPPOINT);

WINGDIAPI int  WINAPI IntersectClipRect(HDC, int, int, int, int);
WINGDIAPI BOOL WINAPI InvertRgn(HDC, HRGN);
WINGDIAPI BOOL WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);
WINGDIAPI BOOL WINAPI LineTo(HDC, int, int);
WINGDIAPI BOOL WINAPI MaskBlt(HDC, int, int, int, int,
              HDC, int, int, HBITMAP, int, int, DWORD);
WINGDIAPI BOOL WINAPI PlgBlt(HDC, CONST POINT *, HDC, int, int, int,
                     int, HBITMAP, int, int);

WINGDIAPI int  WINAPI OffsetClipRgn(HDC, int, int);
WINGDIAPI int  WINAPI OffsetRgn(HRGN, int, int);
WINGDIAPI BOOL WINAPI PatBlt(HDC, int, int, int, int, DWORD);
WINGDIAPI BOOL WINAPI Pie(HDC, int, int, int, int, int, int, int, int);
WINGDIAPI BOOL WINAPI PlayMetaFile(HDC, HMETAFILE);
WINGDIAPI BOOL WINAPI PaintRgn(HDC, HRGN);
WINGDIAPI BOOL WINAPI PolyPolygon(HDC, CONST POINT *, CONST INT *, int);
WINGDIAPI BOOL WINAPI PtInRegion(HRGN, int, int);
WINGDIAPI BOOL WINAPI PtVisible(HDC, int, int);
WINGDIAPI BOOL WINAPI RectInRegion(HRGN, CONST RECT *);
WINGDIAPI BOOL WINAPI RectVisible(HDC, CONST RECT *);
WINGDIAPI BOOL WINAPI Rectangle(HDC, int, int, int, int);
WINGDIAPI BOOL WINAPI RestoreDC(HDC, int);
WINGDIAPI HDC  WINAPI ResetDCA(HDC, CONST DEVMODEA *);
WINGDIAPI HDC  WINAPI ResetDCW(HDC, CONST DEVMODEW *);
#ifdef UNICODE
#define ResetDC  ResetDCW
#else
#define ResetDC  ResetDCA
#endif // !UNICODE
WINGDIAPI UINT WINAPI RealizePalette(HDC);
WINGDIAPI BOOL WINAPI RemoveFontResourceA(LPCSTR);
WINGDIAPI BOOL WINAPI RemoveFontResourceW(LPCWSTR);
#ifdef UNICODE
#define RemoveFontResource  RemoveFontResourceW
#else
#define RemoveFontResource  RemoveFontResourceA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI RoundRect(HDC, int, int, int, int, int, int);
WINGDIAPI BOOL WINAPI ResizePalette(HPALETTE, UINT);

WINGDIAPI int  WINAPI SaveDC(HDC);
WINGDIAPI int  WINAPI SelectClipRgn(HDC, HRGN);
WINGDIAPI int  WINAPI ExtSelectClipRgn(HDC, HRGN, int);
WINGDIAPI int  WINAPI SetMetaRgn(HDC);
WINGDIAPI HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
WINGDIAPI HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);
WINGDIAPI COLORREF WINAPI SetBkColor(HDC, COLORREF);
WINGDIAPI int   WINAPI SetBkMode(HDC, int);
WINGDIAPI LONG  WINAPI SetBitmapBits(HBITMAP, DWORD, CONST VOID *);

WINGDIAPI UINT  WINAPI SetBoundsRect(HDC, CONST RECT *, UINT);
WINGDIAPI int   WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, CONST VOID *, CONST BITMAPINFO *, UINT);
WINGDIAPI int   WINAPI SetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int,
        int, UINT, UINT, CONST VOID *, CONST BITMAPINFO *, UINT);
WINGDIAPI DWORD WINAPI SetMapperFlags(HDC, DWORD);
WINGDIAPI int   WINAPI SetGraphicsMode(HDC hdc, int iMode);
WINGDIAPI int   WINAPI SetMapMode(HDC, int);
WINGDIAPI HMETAFILE   WINAPI SetMetaFileBitsEx(UINT, CONST BYTE *);
WINGDIAPI UINT  WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
WINGDIAPI COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
WINGDIAPI BOOL   WINAPI SetPixelV(HDC, int, int, COLORREF);
WINGDIAPI BOOL  WINAPI SetPixelFormat(HDC, int, CONST PIXELFORMATDESCRIPTOR *);
WINGDIAPI int   WINAPI SetPolyFillMode(HDC, int);
WINGDIAPI BOOL   WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
WINGDIAPI BOOL   WINAPI SetRectRgn(HRGN, int, int, int, int);
WINGDIAPI int   WINAPI StretchDIBits(HDC, int, int, int, int, int, int, int, int, CONST
        VOID *, CONST BITMAPINFO *, UINT, DWORD);
WINGDIAPI int   WINAPI SetROP2(HDC, int);
WINGDIAPI int   WINAPI SetStretchBltMode(HDC, int);
WINGDIAPI UINT  WINAPI SetSystemPaletteUse(HDC, UINT);
WINGDIAPI int   WINAPI SetTextCharacterExtra(HDC, int);
WINGDIAPI COLORREF WINAPI SetTextColor(HDC, COLORREF);
WINGDIAPI UINT  WINAPI SetTextAlign(HDC, UINT);
WINGDIAPI BOOL  WINAPI SetTextJustification(HDC, int, int);
WINGDIAPI BOOL  WINAPI UpdateColors(HDC);

#ifndef NOMETAFILE

WINGDIAPI BOOL  WINAPI PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, UINT);
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
WINGDIAPI BOOL  WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

typedef int (CALLBACK* ENHMFENUMPROC)(HDC, HANDLETABLE FAR*, CONST ENHMETARECORD *, int, LPARAM);

// Enhanced Metafile Function Declarations

WINGDIAPI HENHMETAFILE WINAPI CloseEnhMetaFile(HDC);
WINGDIAPI HENHMETAFILE WINAPI CopyEnhMetaFileA(HENHMETAFILE, LPCSTR);
WINGDIAPI HENHMETAFILE WINAPI CopyEnhMetaFileW(HENHMETAFILE, LPCWSTR);
#ifdef UNICODE
#define CopyEnhMetaFile  CopyEnhMetaFileW
#else
#define CopyEnhMetaFile  CopyEnhMetaFileA
#endif // !UNICODE
WINGDIAPI HDC   WINAPI CreateEnhMetaFileA(HDC, LPCSTR, CONST RECT *, LPCSTR);
WINGDIAPI HDC   WINAPI CreateEnhMetaFileW(HDC, LPCWSTR, CONST RECT *, LPCWSTR);
#ifdef UNICODE
#define CreateEnhMetaFile  CreateEnhMetaFileW
#else
#define CreateEnhMetaFile  CreateEnhMetaFileA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI DeleteEnhMetaFile(HENHMETAFILE);
WINGDIAPI BOOL  WINAPI EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC,
        LPVOID, CONST RECT *);
WINGDIAPI HENHMETAFILE  WINAPI GetEnhMetaFileA(LPCSTR);
WINGDIAPI HENHMETAFILE  WINAPI GetEnhMetaFileW(LPCWSTR);
#ifdef UNICODE
#define GetEnhMetaFile  GetEnhMetaFileW
#else
#define GetEnhMetaFile  GetEnhMetaFileA
#endif // !UNICODE
WINGDIAPI UINT  WINAPI GetEnhMetaFileBits(HENHMETAFILE, UINT, LPBYTE);
WINGDIAPI UINT  WINAPI GetEnhMetaFileDescriptionA(HENHMETAFILE, UINT, LPSTR );
WINGDIAPI UINT  WINAPI GetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR );
#ifdef UNICODE
#define GetEnhMetaFileDescription  GetEnhMetaFileDescriptionW
#else
#define GetEnhMetaFileDescription  GetEnhMetaFileDescriptionA
#endif // !UNICODE
WINGDIAPI UINT  WINAPI GetEnhMetaFileHeader(HENHMETAFILE, UINT, LPENHMETAHEADER );
WINGDIAPI UINT  WINAPI GetEnhMetaFilePaletteEntries(HENHMETAFILE, UINT, LPPALETTEENTRY );
WINGDIAPI UINT  WINAPI GetWinMetaFileBits(HENHMETAFILE, UINT, LPBYTE, INT, HDC);
WINGDIAPI BOOL  WINAPI PlayEnhMetaFile(HDC, HENHMETAFILE, CONST RECT *);
WINGDIAPI BOOL  WINAPI PlayEnhMetaFileRecord(HDC, LPHANDLETABLE, CONST ENHMETARECORD *, UINT);
WINGDIAPI HENHMETAFILE  WINAPI SetEnhMetaFileBits(UINT, CONST BYTE *);
WINGDIAPI HENHMETAFILE  WINAPI SetWinMetaFileBits(UINT, CONST BYTE *, HDC, CONST METAFILEPICT *);
WINGDIAPI BOOL  WINAPI GdiComment(HDC, UINT, CONST BYTE *);

#endif  /* NOMETAFILE */

#ifndef NOTEXTMETRIC

WINGDIAPI BOOL WINAPI GetTextMetricsA(HDC, LPTEXTMETRICA);
WINGDIAPI BOOL WINAPI GetTextMetricsW(HDC, LPTEXTMETRICW);
#ifdef UNICODE
#define GetTextMetrics  GetTextMetricsW
#else
#define GetTextMetrics  GetTextMetricsA
#endif // !UNICODE

#endif

/* new GDI */

typedef struct tagDIBSECTION {
    BITMAP              dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION, FAR *LPDIBSECTION, *PDIBSECTION;

WINGDIAPI BOOL WINAPI AngleArc(HDC, int, int, DWORD, FLOAT, FLOAT);
WINGDIAPI BOOL WINAPI PolyPolyline(HDC, CONST POINT *, CONST DWORD *, DWORD);
WINGDIAPI BOOL WINAPI GetWorldTransform(HDC, LPXFORM);
WINGDIAPI BOOL WINAPI SetWorldTransform(HDC, CONST XFORM *);
WINGDIAPI BOOL WINAPI ModifyWorldTransform(HDC, CONST XFORM *, DWORD);
WINGDIAPI BOOL WINAPI CombineTransform(LPXFORM, CONST XFORM *, CONST XFORM *);
WINGDIAPI HBITMAP WINAPI CreateDIBSection(HDC, CONST BITMAPINFO *, UINT, VOID **, HANDLE, DWORD);
WINGDIAPI UINT WINAPI GetDIBColorTable(HDC, UINT, UINT, RGBQUAD *);
WINGDIAPI UINT WINAPI SetDIBColorTable(HDC, UINT, UINT, CONST RGBQUAD *);

/* Flags value for COLORADJUSTMENT */
#define CA_NEGATIVE                 0x0001
#define CA_LOG_FILTER               0x0002

/* IlluminantIndex values */
#define ILLUMINANT_DEVICE_DEFAULT   0
#define ILLUMINANT_A                1
#define ILLUMINANT_B                2
#define ILLUMINANT_C                3
#define ILLUMINANT_D50              4
#define ILLUMINANT_D55              5
#define ILLUMINANT_D65              6
#define ILLUMINANT_D75              7
#define ILLUMINANT_F2               8
#define ILLUMINANT_MAX_INDEX        ILLUMINANT_F2

#define ILLUMINANT_TUNGSTEN         ILLUMINANT_A
#define ILLUMINANT_DAYLIGHT         ILLUMINANT_C
#define ILLUMINANT_FLUORESCENT      ILLUMINANT_F2
#define ILLUMINANT_NTSC             ILLUMINANT_C

/* Min and max for RedGamma, GreenGamma, BlueGamma */
#define RGB_GAMMA_MIN               (WORD)02500
#define RGB_GAMMA_MAX               (WORD)65000

/* Min and max for ReferenceBlack and ReferenceWhite */
#define REFERENCE_WHITE_MIN         (WORD)6000
#define REFERENCE_WHITE_MAX         (WORD)10000
#define REFERENCE_BLACK_MIN         (WORD)0
#define REFERENCE_BLACK_MAX         (WORD)4000

/* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint */
#define COLOR_ADJ_MIN               (SHORT)-100
#define COLOR_ADJ_MAX               (SHORT)100

typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, FAR *LPCOLORADJUSTMENT;

WINGDIAPI BOOL WINAPI SetColorAdjustment(HDC, CONST COLORADJUSTMENT *);
WINGDIAPI BOOL WINAPI GetColorAdjustment(HDC, LPCOLORADJUSTMENT);
WINGDIAPI HPALETTE WINAPI CreateHalftonePalette(HDC);

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

typedef struct _DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;
#if (WINVER >= 0x0400)
    LPCSTR   lpszDatatype;
    DWORD    fwType;
#endif /* WINVER */
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;
#if (WINVER >= 0x0400)
    LPCWSTR  lpszDatatype;
    DWORD    fwType;
#endif /* WINVER */
} DOCINFOW, *LPDOCINFOW;
#ifdef UNICODE
typedef DOCINFOW DOCINFO;
typedef LPDOCINFOW LPDOCINFO;
#else
typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;
#endif // UNICODE

#if(WINVER >= 0x0400)
#define DI_APPBANDING   0x0001
#endif /* WINVER >= 0x0400 */

WINGDIAPI int WINAPI StartDocA(HDC, CONST DOCINFOA *);
WINGDIAPI int WINAPI StartDocW(HDC, CONST DOCINFOW *);
#ifdef UNICODE
#define StartDoc  StartDocW
#else
#define StartDoc  StartDocA
#endif // !UNICODE
WINGDIAPI int WINAPI EndDoc(HDC);
WINGDIAPI int WINAPI StartPage(HDC);
WINGDIAPI int WINAPI EndPage(HDC);
WINGDIAPI int WINAPI AbortDoc(HDC);
WINGDIAPI int WINAPI SetAbortProc(HDC, ABORTPROC);

WINGDIAPI BOOL WINAPI AbortPath(HDC);
WINGDIAPI BOOL WINAPI ArcTo(HDC, int, int, int, int, int, int,int, int);
WINGDIAPI BOOL WINAPI BeginPath(HDC);
WINGDIAPI BOOL WINAPI CloseFigure(HDC);
WINGDIAPI BOOL WINAPI EndPath(HDC);
WINGDIAPI BOOL WINAPI FillPath(HDC);
WINGDIAPI BOOL WINAPI FlattenPath(HDC);
WINGDIAPI int  WINAPI GetPath(HDC, LPPOINT, LPBYTE, int);
WINGDIAPI HRGN WINAPI PathToRegion(HDC);
WINGDIAPI BOOL WINAPI PolyDraw(HDC, CONST POINT *, CONST BYTE *, int);
WINGDIAPI BOOL WINAPI SelectClipPath(HDC, int);
WINGDIAPI int  WINAPI SetArcDirection(HDC, int);
WINGDIAPI BOOL WINAPI SetMiterLimit(HDC, FLOAT, PFLOAT);
WINGDIAPI BOOL WINAPI StrokeAndFillPath(HDC);
WINGDIAPI BOOL WINAPI StrokePath(HDC);
WINGDIAPI BOOL WINAPI WidenPath(HDC);
WINGDIAPI HPEN WINAPI ExtCreatePen(DWORD, DWORD, CONST LOGBRUSH *, DWORD, CONST DWORD *);
WINGDIAPI BOOL WINAPI GetMiterLimit(HDC, PFLOAT);
WINGDIAPI int  WINAPI GetArcDirection(HDC);

WINGDIAPI int   WINAPI GetObjectA(HGDIOBJ, int, LPVOID);
WINGDIAPI int   WINAPI GetObjectW(HGDIOBJ, int, LPVOID);
#ifdef UNICODE
#define GetObject  GetObjectW
#else
#define GetObject  GetObjectA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI MoveToEx(HDC, int, int, LPPOINT);
WINGDIAPI BOOL  WINAPI TextOutA(HDC, int, int, LPCSTR, int);
WINGDIAPI BOOL  WINAPI TextOutW(HDC, int, int, LPCWSTR, int);
#ifdef UNICODE
#define TextOut  TextOutW
#else
#define TextOut  TextOutA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI ExtTextOutA(HDC, int, int, UINT, CONST RECT *,LPCSTR, UINT, CONST INT *);
WINGDIAPI BOOL  WINAPI ExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);
#ifdef UNICODE
#define ExtTextOut  ExtTextOutW
#else
#define ExtTextOut  ExtTextOutA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI PolyTextOutA(HDC, CONST POLYTEXTA *, int);
WINGDIAPI BOOL  WINAPI PolyTextOutW(HDC, CONST POLYTEXTW *, int);
#ifdef UNICODE
#define PolyTextOut  PolyTextOutW
#else
#define PolyTextOut  PolyTextOutA
#endif // !UNICODE

WINGDIAPI HRGN  WINAPI CreatePolygonRgn(CONST POINT *, int, int);
WINGDIAPI BOOL  WINAPI DPtoLP(HDC, LPPOINT, int);
WINGDIAPI BOOL  WINAPI LPtoDP(HDC, LPPOINT, int);
WINGDIAPI BOOL  WINAPI Polygon(HDC, CONST POINT *, int);
WINGDIAPI BOOL  WINAPI Polyline(HDC, CONST POINT *, int);

WINGDIAPI BOOL  WINAPI PolyBezier(HDC, CONST POINT *, DWORD);
WINGDIAPI BOOL  WINAPI PolyBezierTo(HDC, CONST POINT *, DWORD);
WINGDIAPI BOOL  WINAPI PolylineTo(HDC, CONST POINT *, DWORD);

WINGDIAPI BOOL  WINAPI SetViewportExtEx(HDC, int, int, LPSIZE);
WINGDIAPI BOOL  WINAPI SetViewportOrgEx(HDC, int, int, LPPOINT);
WINGDIAPI BOOL  WINAPI SetWindowExtEx(HDC, int, int, LPSIZE);
WINGDIAPI BOOL  WINAPI SetWindowOrgEx(HDC, int, int, LPPOINT);

WINGDIAPI BOOL  WINAPI OffsetViewportOrgEx(HDC, int, int, LPPOINT);
WINGDIAPI BOOL  WINAPI OffsetWindowOrgEx(HDC, int, int, LPPOINT);
WINGDIAPI BOOL  WINAPI ScaleViewportExtEx(HDC, int, int, int, int, LPSIZE);
WINGDIAPI BOOL  WINAPI ScaleWindowExtEx(HDC, int, int, int, int, LPSIZE);
WINGDIAPI BOOL  WINAPI SetBitmapDimensionEx(HBITMAP, int, int, LPSIZE);
WINGDIAPI BOOL  WINAPI SetBrushOrgEx(HDC, int, int, LPPOINT);

WINGDIAPI int   WINAPI GetTextFaceA(HDC, int, LPSTR);
WINGDIAPI int   WINAPI GetTextFaceW(HDC, int, LPWSTR);
#ifdef UNICODE
#define GetTextFace  GetTextFaceW
#else
#define GetTextFace  GetTextFaceA
#endif // !UNICODE

#define FONTMAPPER_MAX 10

typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

WINGDIAPI DWORD WINAPI GetKerningPairsA(HDC, DWORD, LPKERNINGPAIR);
WINGDIAPI DWORD WINAPI GetKerningPairsW(HDC, DWORD, LPKERNINGPAIR);
#ifdef UNICODE
#define GetKerningPairs  GetKerningPairsW
#else
#define GetKerningPairs  GetKerningPairsA
#endif // !UNICODE

WINGDIAPI BOOL  WINAPI GetDCOrgEx(HDC,LPPOINT);
WINGDIAPI BOOL  WINAPI FixBrushOrgEx(HDC,int,int,LPPOINT);
WINGDIAPI BOOL  WINAPI UnrealizeObject(HGDIOBJ);

WINGDIAPI BOOL  WINAPI GdiFlush();
WINGDIAPI DWORD WINAPI GdiSetBatchLimit(DWORD);
WINGDIAPI DWORD WINAPI GdiGetBatchLimit();

#if(WINVER >= 0x0400)

#define ICM_OFF   1
#define ICM_ON	  2
#define ICM_QUERY 3

int WINAPI SetICMMode(HDC, int);
BOOL WINAPI CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE WINAPI GetColorSpace(HDC);
BOOL WINAPI GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
BOOL WINAPI GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
#ifdef UNICODE
#define GetLogColorSpace  GetLogColorSpaceW
#else
#define GetLogColorSpace  GetLogColorSpaceA
#endif // !UNICODE
HCOLORSPACE WINAPI CreateColorSpaceA(LPLOGCOLORSPACEA);
HCOLORSPACE WINAPI CreateColorSpaceW(LPLOGCOLORSPACEW);
#ifdef UNICODE
#define CreateColorSpace  CreateColorSpaceW
#else
#define CreateColorSpace  CreateColorSpaceA
#endif // !UNICODE
BOOL WINAPI SetColorSpace(HDC,HCOLORSPACE);
BOOL WINAPI DeleteColorSpace(HCOLORSPACE);
BOOL WINAPI GetICMProfileA(HDC,DWORD,LPSTR);
BOOL WINAPI GetICMProfileW(HDC,DWORD,LPWSTR);
#ifdef UNICODE
#define GetICMProfile  GetICMProfileW
#else
#define GetICMProfile  GetICMProfileA
#endif // !UNICODE
BOOL WINAPI SetICMProfileA(HDC,LPSTR);
BOOL WINAPI SetICMProfileW(HDC,LPWSTR);
#ifdef UNICODE
#define SetICMProfile  SetICMProfileW
#else
#define SetICMProfile  SetICMProfileA
#endif // !UNICODE
BOOL WINAPI GetDeviceGammaRamp(HDC,LPVOID);
BOOL WINAPI SetDeviceGammaRamp(HDC,LPVOID);
BOOL WINAPI ColorMatchToTarget(HDC,HDC,DWORD);
BOOL WINAPI UpdateICMRegKeyA(DWORD, DWORD, LPSTR, UINT);
BOOL WINAPI UpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT);
#ifdef UNICODE
#define UpdateICMRegKey  UpdateICMRegKeyW
#else
#define UpdateICMRegKey  UpdateICMRegKeyA
#endif // !UNICODE
typedef int (CALLBACK* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (CALLBACK* ICMENUMPROCW)(LPWSTR, LPARAM);
#ifdef UNICODE
#define ICMENUMPROC  ICMENUMPROCW
#else
#define ICMENUMPROC  ICMENUMPROCA
#endif // !UNICODE
int WINAPI EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
int WINAPI EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);
#ifdef UNICODE
#define EnumICMProfiles  EnumICMProfilesW
#else
#define EnumICMProfiles  EnumICMProfilesA
#endif // !UNICODE

#endif /* WINVER >= 0x0400 */
#ifndef NOMETAFILE

// Enhanced metafile constants.

#define ENHMETA_SIGNATURE       0x464D4520

// Stock object flag used in the object handle index in the enhanced
// metafile records.
// E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH)
// represents the stock object BLACK_BRUSH.

#define ENHMETA_STOCK_OBJECT    0x80000000

// Enhanced metafile record types.

#define EMR_HEADER                      1
#define EMR_POLYBEZIER                  2
#define EMR_POLYGON                     3
#define EMR_POLYLINE                    4
#define EMR_POLYBEZIERTO                5
#define EMR_POLYLINETO                  6
#define EMR_POLYPOLYLINE                7
#define EMR_POLYPOLYGON                 8
#define EMR_SETWINDOWEXTEX              9
#define EMR_SETWINDOWORGEX              10
#define EMR_SETVIEWPORTEXTEX            11
#define EMR_SETVIEWPORTORGEX            12
#define EMR_SETBRUSHORGEX               13
#define EMR_EOF                         14
#define EMR_SETPIXELV                   15
#define EMR_SETMAPPERFLAGS              16
#define EMR_SETMAPMODE                  17
#define EMR_SETBKMODE                   18
#define EMR_SETPOLYFILLMODE             19
#define EMR_SETROP2                     20
#define EMR_SETSTRETCHBLTMODE           21
#define EMR_SETTEXTALIGN                22
#define EMR_SETCOLORADJUSTMENT          23
#define EMR_SETTEXTCOLOR                24
#define EMR_SETBKCOLOR                  25
#define EMR_OFFSETCLIPRGN               26
#define EMR_MOVETOEX                    27
#define EMR_SETMETARGN                  28
#define EMR_EXCLUDECLIPRECT             29
#define EMR_INTERSECTCLIPRECT           30
#define EMR_SCALEVIEWPORTEXTEX          31
#define EMR_SCALEWINDOWEXTEX            32
#define EMR_SAVEDC                      33
#define EMR_RESTOREDC                   34
#define EMR_SETWORLDTRANSFORM           35
#define EMR_MODIFYWORLDTRANSFORM        36
#define EMR_SELECTOBJECT                37
#define EMR_CREATEPEN                   38
#define EMR_CREATEBRUSHINDIRECT         39
#define EMR_DELETEOBJECT                40
#define EMR_ANGLEARC                    41
#define EMR_ELLIPSE                     42
#define EMR_RECTANGLE                   43
#define EMR_ROUNDRECT                   44
#define EMR_ARC                         45
#define EMR_CHORD                       46
#define EMR_PIE                         47
#define EMR_SELECTPALETTE               48
#define EMR_CREATEPALETTE               49
#define EMR_SETPALETTEENTRIES           50
#define EMR_RESIZEPALETTE               51
#define EMR_REALIZEPALETTE              52
#define EMR_EXTFLOODFILL                53
#define EMR_LINETO                      54
#define EMR_ARCTO                       55
#define EMR_POLYDRAW                    56
#define EMR_SETARCDIRECTION             57
#define EMR_SETMITERLIMIT               58
#define EMR_BEGINPATH                   59
#define EMR_ENDPATH                     60
#define EMR_CLOSEFIGURE                 61
#define EMR_FILLPATH                    62
#define EMR_STROKEANDFILLPATH           63
#define EMR_STROKEPATH                  64
#define EMR_FLATTENPATH                 65
#define EMR_WIDENPATH                   66
#define EMR_SELECTCLIPPATH              67
#define EMR_ABORTPATH                   68

#define EMR_GDICOMMENT                  70
#define EMR_FILLRGN                     71
#define EMR_FRAMERGN                    72
#define EMR_INVERTRGN                   73
#define EMR_PAINTRGN                    74
#define EMR_EXTSELECTCLIPRGN            75
#define EMR_BITBLT                      76
#define EMR_STRETCHBLT                  77
#define EMR_MASKBLT                     78
#define EMR_PLGBLT                      79
#define EMR_SETDIBITSTODEVICE           80
#define EMR_STRETCHDIBITS               81
#define EMR_EXTCREATEFONTINDIRECTW      82
#define EMR_EXTTEXTOUTA                 83
#define EMR_EXTTEXTOUTW                 84
#define EMR_POLYBEZIER16                85
#define EMR_POLYGON16                   86
#define EMR_POLYLINE16                  87
#define EMR_POLYBEZIERTO16              88
#define EMR_POLYLINETO16                89
#define EMR_POLYPOLYLINE16              90
#define EMR_POLYPOLYGON16               91
#define EMR_POLYDRAW16                  92
#define EMR_CREATEMONOBRUSH             93
#define EMR_CREATEDIBPATTERNBRUSHPT     94
#define EMR_EXTCREATEPEN                95
#define EMR_POLYTEXTOUTA                96
#define EMR_POLYTEXTOUTW                97
#if(WINVER >= 0x0400)
#define EMR_SETICMMODE			98
#define EMR_CREATECOLORSPACE            99
#define EMR_SETCOLORSPACE              100
#define EMR_DELETECOLORSPACE           101
#endif /* WINVER >= 0x0400 */

#define EMR_MIN                         1

#if (WINVER >= 0x0400)
#define EMR_MAX                        101
#else
#define EMR_MAX                         97
#endif

// Base record type for the enhanced metafile.

typedef struct tagEMR
{
    DWORD   iType;              // Enhanced metafile record type
    DWORD   nSize;              // Length of the record in bytes.
                                // This must be a multiple of 4.
} EMR, *PEMR;

// Base text record type for the enhanced metafile.

typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          // Offset to the string
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              // Offset to the inter-character spacing array.
                                // This is always given.
} EMRTEXT, *PEMRTEXT;

// Record structures for the enhanced metafile.

typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,	*PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          // Specifies a relative instance
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      // Specifies the arc direction in the
                                // advanced graphics mode.
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           // Object handle index
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

#if(WINVER >= 0x0400)
typedef struct tagEMRSELECTCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               // ColorSpace handle index
} EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;
#endif /* WINVER >= 0x0400 */

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index, background mode only
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        // Number of palette entries
    DWORD   offPalEntries;      // Offset to the palette entries
    DWORD   nSizeLast;          // Same as nSize and must be the last DWORD
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;

typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;               // Number of points
    POINTL  aptl[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;               // Number of points
    POINTS  apts[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cptl;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTL  aptl[1];            // Array of points
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cpts;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTS  apts[1];            // Array of points
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    EMRTEXT emrtext;            // This is followed by the string and spacing
                                // array
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    LONG    cStrings;
    EMRTEXT aemrtext[1];        // Array of EMRTEXT structures.  This is
                                // followed by the strings and spacing arrays.
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             // Font handle index
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    LOGPALETTE lgpl;            // The peFlags fields in the palette entries
                                // do not contain any flags
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

#if(WINVER >= 0x0400)

typedef struct tagEMRCREATECOLORSPACE
{
    EMR 	    emr;
    DWORD	    ihCS;	// ColorSpace handle index
    LOGCOLORSPACEW  lcs;
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

#endif /* WINVER >= 0x0400 */

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any
    DWORD   cbBits;             // Size of the brush bitmap bits if any
    EXTLOGPEN elp;              // The extended pen with the style array.
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    LOGBRUSH lb;                // The style must be BS_SOLID, BS_HOLLOW,
                                // BS_NULL or BS_HATCHED.
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD   dSignature;         // Format signature, e.g. ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Format version number.
    DWORD   cbData;             // Size of data in bytes.
    DWORD   offData;            // Offset to data from GDICOMMENT_IDENTIFIER.
                                // It must begin at a DWORD offset.
} EMRFORMAT, *PEMRFORMAT;


#define GDICOMMENT_IDENTIFIER           0x43494447
#define GDICOMMENT_WINDOWS_METAFILE     0x80000001
#define GDICOMMENT_BEGINGROUP           0x00000002
#define GDICOMMENT_ENDGROUP             0x00000003
#define GDICOMMENT_MULTIFORMATS         0x40000004
#define EPS_SIGNATURE                   0x46535045

#endif  /* NOMETAFILE */


// OpenGL wgl prototypes

WINGDIAPI HGLRC WINAPI wglCreateContext(HDC);
WINGDIAPI BOOL  WINAPI wglDeleteContext(HGLRC);
WINGDIAPI HGLRC WINAPI wglGetCurrentContext(VOID);
WINGDIAPI HDC   WINAPI wglGetCurrentDC(VOID);
WINGDIAPI PROC  WINAPI wglGetProcAddress(LPCSTR);
WINGDIAPI BOOL  WINAPI wglMakeCurrent(HDC, HGLRC);
WINGDIAPI BOOL  WINAPI wglShareLists(HGLRC, HGLRC);
WINGDIAPI BOOL  WINAPI wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
WINGDIAPI BOOL  WINAPI wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
#ifdef UNICODE
#define wglUseFontBitmaps  wglUseFontBitmapsW
#else
#define wglUseFontBitmaps  wglUseFontBitmapsA
#endif // !UNICODE
WINGDIAPI BOOL  WINAPI SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, FAR *LPGLYPHMETRICSFLOAT;

#define WGL_FONT_LINES      0
#define WGL_FONT_POLYGONS   1
WINGDIAPI BOOL  WINAPI wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
WINGDIAPI BOOL  WINAPI wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
#ifdef UNICODE
#define wglUseFontOutlines  wglUseFontOutlinesW
#else
#define wglUseFontOutlines  wglUseFontOutlinesA
#endif // !UNICODE


#endif /* NOGDI */

#ifdef __cplusplus
}
#endif




#endif /* _WINGDI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINNLS.H ===
/**************************************************************************
*                                                                         *
* winnls.h -- NLS procedure declarations, constant definitions and macros *
*                                                                         *
* Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.           *
*                                                                         *
**************************************************************************/


#ifndef _WINNLS_
#define _WINNLS_


#ifdef __cplusplus
extern "C" {
#endif

#ifndef NONLS


/***************************************************************************\
* Constants
*
* Define all constants for the NLS component here.
\***************************************************************************/


/*
 *  String Length Maximums.
 */
#define MAX_LEADBYTES        12             /* 5 ranges, 2 bytes ea., 0 term. */
#define MAX_DEFAULTCHAR      2              /* single or double byte */


/*
 *  MBCS and Unicode Translation Flags.
 */
#define MB_PRECOMPOSED       0x00000001     /* use precomposed chars */
#define MB_COMPOSITE         0x00000002     /* use composite chars */
#define MB_USEGLYPHCHARS     0x00000004     /* use glyph chars, not ctrl chars */
#define MB_ERR_INVALID_CHARS 0x00000008     /* error for invalid chars */

#define WC_DEFAULTCHECK      0x00000100     /* check for default char */
#define WC_COMPOSITECHECK    0x00000200     /* convert composite to precomposed */
#define WC_DISCARDNS         0x00000010     /* discard non-spacing chars */
#define WC_SEPCHARS          0x00000020     /* generate separate chars */
#define WC_DEFAULTCHAR       0x00000040     /* replace w/ default char */



/*
 *  Character Type Flags.
 */
#define CT_CTYPE1            0x00000001     /* ctype 1 information */
#define CT_CTYPE2            0x00000002     /* ctype 2 information */
#define CT_CTYPE3            0x00000004     /* ctype 3 information */

/*
 *  CType 1 Flag Bits.
 */
#define C1_UPPER             0x0001         /* upper case */
#define C1_LOWER             0x0002         /* lower case */
#define C1_DIGIT             0x0004         /* decimal digits */
#define C1_SPACE             0x0008         /* spacing characters */
#define C1_PUNCT             0x0010         /* punctuation characters */
#define C1_CNTRL             0x0020         /* control characters */
#define C1_BLANK             0x0040         /* blank characters */
#define C1_XDIGIT            0x0080         /* other digits */
#define C1_ALPHA             0x0100         /* any linguistic character */

/*
 *  CType 2 Flag Bits.
 */
#define C2_LEFTTORIGHT       0x0001         /* left to right */
#define C2_RIGHTTOLEFT       0x0002         /* right to left */

#define C2_EUROPENUMBER      0x0003         /* European number, digit */
#define C2_EUROPESEPARATOR   0x0004         /* European numeric separator */
#define C2_EUROPETERMINATOR  0x0005         /* European numeric terminator */
#define C2_ARABICNUMBER      0x0006         /* Arabic number */
#define C2_COMMONSEPARATOR   0x0007         /* common numeric separator */

#define C2_BLOCKSEPARATOR    0x0008         /* block separator */
#define C2_SEGMENTSEPARATOR  0x0009         /* segment separator */
#define C2_WHITESPACE        0x000A         /* white space */
#define C2_OTHERNEUTRAL      0x000B         /* other neutrals */

#define C2_NOTAPPLICABLE     0x0000         /* no implicit directionality */

/*
 *  CType 3 Flag Bits.
 */
#define C3_NONSPACING        0x0001         /* nonspacing character */
#define C3_DIACRITIC         0x0002         /* diacritic mark */
#define C3_VOWELMARK         0x0004         /* vowel mark */
#define C3_SYMBOL            0x0008         /* symbols */

#define C3_KATAKANA          0x0010         /* katakana character */
#define C3_HIRAGANA          0x0020         /* hiragana character */
#define C3_HALFWIDTH         0x0040         /* half width character */
#define C3_FULLWIDTH         0x0080         /* full width character */
#define C3_IDEOGRAPH         0x0100         /* ideographic character */
#define C3_KASHIDA           0x0200         /* Arabic kashida character */
#define C3_LEXICAL           0x0400         /* lexical character */

#define C3_ALPHA             0x8000         /* any linguistic char (C1_ALPHA) */

#define C3_NOTAPPLICABLE     0x0000         /* ctype 3 is not applicable */


/*
 *  String Flags.
 */
#define NORM_IGNORECASE         0x00000001  /* ignore case */
#define NORM_IGNORENONSPACE     0x00000002  /* ignore nonspacing chars */
#define NORM_IGNORESYMBOLS      0x00000004  /* ignore symbols */

#define NORM_IGNOREKANATYPE     0x00010000  /* ignore kanatype */
#define NORM_IGNOREWIDTH        0x00020000  /* ignore width */


/*
 *  Locale Independent Mapping Flags.
 */
#define MAP_FOLDCZONE           0x00000010  /* fold compatibility zone chars */
#define MAP_PRECOMPOSED         0x00000020  /* convert to precomposed chars */
#define MAP_COMPOSITE           0x00000040  /* convert to composite chars */
#define MAP_FOLDDIGITS          0x00000080  /* all digits to ASCII 0-9 */


/*
 *  Locale Dependent Mapping Flags.
 */
#define LCMAP_LOWERCASE         0x00000100  /* lower case letters */
#define LCMAP_UPPERCASE         0x00000200  /* upper case letters */
#define LCMAP_SORTKEY           0x00000400  /* WC sort key (normalize) */
#define LCMAP_BYTEREV           0x00000800  /* byte reversal */

#define LCMAP_HIRAGANA          0x00100000  /* map katakana to hiragana */
#define LCMAP_KATAKANA          0x00200000  /* map hiragana to katakana */
#define LCMAP_HALFWIDTH         0x00400000  /* map double byte to single byte */
#define LCMAP_FULLWIDTH         0x00800000  /* map single byte to double byte */



/*
 *  Locale Enumeration Flags.
 */
#define LCID_INSTALLED          0x00000001  /* installed locale ids */
#define LCID_SUPPORTED          0x00000002  /* supported locale ids */

/*
 *  Code Page Enumeration Flags.
 */
#define CP_INSTALLED            0x00000001  /* installed code page ids */
#define CP_SUPPORTED            0x00000002  /* supported code page ids */


/*
 *  Sorting Flags.
 *
 *    WORD Sort:    culturally correct sort
 *                  hyphen and apostrophe are special cased
 *                  example: "coop" and "co-op" will sort together in a list
 *
 *                        co_op     <-------  underscore (symbol)
 *                        coat
 *                        comb
 *                        coop
 *                        co-op     <-------  hyphen (punctuation)
 *                        cork
 *                        went
 *                        were
 *                        we're     <-------  apostrophe (punctuation)
 *
 *
 *    STRING Sort:  hyphen and apostrophe will sort with all other symbols
 *
 *                        co-op     <-------  hyphen (punctuation)
 *                        co_op     <-------  underscore (symbol)
 *                        coat
 *                        comb
 *                        coop
 *                        cork
 *                        we're     <-------  apostrophe (punctuation)
 *                        went
 *                        were
 */
#define SORT_STRINGSORT         0x00001000  /* use string sort method */


/*
 *  Code Page Default Values.
 */
#define CP_ACP               0              /* default to ANSI code page */
#define CP_OEMCP             1              /* default to OEM  code page */
#define CP_MACCP             2              /* default to MAC  code page */


/*
 *  Country Codes.
 */
#define CTRY_DEFAULT                     0

#define CTRY_AUSTRALIA                   61      /* Australia */
#define CTRY_AUSTRIA                     43      /* Austria */
#define CTRY_BELGIUM                     32      /* Belgium */
#define CTRY_BRAZIL                      55      /* Brazil */
#define CTRY_BULGARIA                    359     /* Bulgaria */
#define CTRY_CANADA                      2       /* Canada */
#define CTRY_CROATIA                     385     /* Croatia */
#define CTRY_CZECH                       42      /* Czech Republic */
#define CTRY_DENMARK                     45      /* Denmark */
#define CTRY_FINLAND                     358     /* Finland */
#define CTRY_FRANCE                      33      /* France */
#define CTRY_GERMANY                     49      /* Germany */
#define CTRY_GREECE                      30      /* Greece */
#define CTRY_HONG_KONG                   852     /* Hong Kong */
#define CTRY_HUNGARY                     36      /* Hungary */
#define CTRY_ICELAND                     354     /* Iceland */
#define CTRY_IRELAND                     353     /* Ireland */
#define CTRY_ITALY                       39      /* Italy */
#define CTRY_JAPAN                       81      /* Japan */
#define CTRY_MEXICO                      52      /* Mexico */
#define CTRY_NETHERLANDS                 31      /* Netherlands */
#define CTRY_NEW_ZEALAND                 64      /* New Zealand */
#define CTRY_NORWAY                      47      /* Norway */
#define CTRY_POLAND                      48      /* Poland */
#define CTRY_PORTUGAL                    351     /* Portugal */
#define CTRY_PRCHINA                     86      /* Peoples' Republic of China */
#define CTRY_ROMANIA                     40      /* Romania */
#define CTRY_RUSSIA                      7       /* Russia */
#define CTRY_SINGAPORE                   65      /* Singapore */
#define CTRY_SLOVAK                      42      /* Slovak Republic */
#define CTRY_SLOVENIA                    386     /* Slovenia */
#define CTRY_SOUTH_KOREA                 82      /* South Korea */
#define CTRY_SPAIN                       34      /* Spain */
#define CTRY_SWEDEN                      46      /* Sweden */
#define CTRY_SWITZERLAND                 41      /* Switzerland */
#define CTRY_TAIWAN                      886     /* Taiwan */
#define CTRY_TURKEY                      90      /* Turkey */
#define CTRY_UNITED_KINGDOM              44      /* United Kingdom */
#define CTRY_UNITED_STATES               1       /* United States */


/*
 *  Locale Types.
 *
 *  These types are used for the GetLocaleInfoW NLS API routine.
 *
 *  LOCALE_NOUSEROVERRIDE is also used in GetTimeFormatW and GetDateFormatW.
 *
 *  LOCALE_USE_CP_ACP is used in many of the A (Ansi) apis that need to do 
 *  string translation.
 */
#define LOCALE_NOUSEROVERRIDE       0x80000000   /* do not use user overrides */
#define LOCALE_USE_CP_ACP           0x40000000   /* use the system ACP */

#define LOCALE_ILANGUAGE            0x00000001   /* language id */
#define LOCALE_SLANGUAGE            0x00000002   /* localized name of language */
#define LOCALE_SENGLANGUAGE         0x00001001   /* English name of language */
#define LOCALE_SABBREVLANGNAME      0x00000003   /* abbreviated language name */
#define LOCALE_SNATIVELANGNAME      0x00000004   /* native name of language */
#define LOCALE_ICOUNTRY             0x00000005   /* country code */
#define LOCALE_SCOUNTRY             0x00000006   /* localized name of country */
#define LOCALE_SENGCOUNTRY          0x00001002   /* English name of country */
#define LOCALE_SABBREVCTRYNAME      0x00000007   /* abbreviated country name */
#define LOCALE_SNATIVECTRYNAME      0x00000008   /* native name of country */
#define LOCALE_IDEFAULTLANGUAGE     0x00000009   /* default language id */
#define LOCALE_IDEFAULTCOUNTRY      0x0000000A   /* default country code */
#define LOCALE_IDEFAULTCODEPAGE     0x0000000B   /* default oem code page */
#define LOCALE_IDEFAULTANSICODEPAGE 0x00001004   /* default ansi code page */

#define LOCALE_SLIST                0x0000000C   /* list item separator */
#define LOCALE_IMEASURE             0x0000000D   /* 0 = metric, 1 = US */

#define LOCALE_SDECIMAL             0x0000000E   /* decimal separator */
#define LOCALE_STHOUSAND            0x0000000F   /* thousand separator */
#define LOCALE_SGROUPING            0x00000010   /* digit grouping */
#define LOCALE_IDIGITS              0x00000011   /* number of fractional digits */
#define LOCALE_ILZERO               0x00000012   /* leading zeros for decimal */
#define LOCALE_INEGNUMBER           0x00001010   /* negative number mode */
#define LOCALE_SNATIVEDIGITS        0x00000013   /* native ascii 0-9 */

#define LOCALE_SCURRENCY            0x00000014   /* local monetary symbol */
#define LOCALE_SINTLSYMBOL          0x00000015   /* intl monetary symbol */
#define LOCALE_SMONDECIMALSEP       0x00000016   /* monetary decimal separator */
#define LOCALE_SMONTHOUSANDSEP      0x00000017   /* monetary thousand separator */
#define LOCALE_SMONGROUPING         0x00000018   /* monetary grouping */
#define LOCALE_ICURRDIGITS          0x00000019   /* # local monetary digits */
#define LOCALE_IINTLCURRDIGITS      0x0000001A   /* # intl monetary digits */
#define LOCALE_ICURRENCY            0x0000001B   /* positive currency mode */
#define LOCALE_INEGCURR             0x0000001C   /* negative currency mode */

#define LOCALE_SDATE                0x0000001D   /* date separator */
#define LOCALE_STIME                0x0000001E   /* time separator */
#define LOCALE_SSHORTDATE           0x0000001F   /* short date format string */
#define LOCALE_SLONGDATE            0x00000020   /* long date format string */
#define LOCALE_STIMEFORMAT          0x00001003   /* time format string */
#define LOCALE_IDATE                0x00000021   /* short date format ordering */
#define LOCALE_ILDATE               0x00000022   /* long date format ordering */
#define LOCALE_ITIME                0x00000023   /* time format specifier */
#define LOCALE_ITIMEMARKPOSN        0x00001005   /* time marker position */
#define LOCALE_ICENTURY             0x00000024   /* century format specifier (short date) */
#define LOCALE_ITLZERO              0x00000025   /* leading zeros in time field */
#define LOCALE_IDAYLZERO            0x00000026   /* leading zeros in day field (short date) */
#define LOCALE_IMONLZERO            0x00000027   /* leading zeros in month field (short date) */
#define LOCALE_S1159                0x00000028   /* AM designator */
#define LOCALE_S2359                0x00000029   /* PM designator */

#define LOCALE_ICALENDARTYPE        0x00001009   /* type of calendar specifier */
#define LOCALE_IOPTIONALCALENDAR    0x0000100B   /* additional calendar types specifier */
#define LOCALE_IFIRSTDAYOFWEEK      0x0000100C   /* first day of week specifier */
#define LOCALE_IFIRSTWEEKOFYEAR     0x0000100D   /* first week of year specifier */

#define LOCALE_SDAYNAME1            0x0000002A   /* long name for Monday */
#define LOCALE_SDAYNAME2            0x0000002B   /* long name for Tuesday */
#define LOCALE_SDAYNAME3            0x0000002C   /* long name for Wednesday */
#define LOCALE_SDAYNAME4            0x0000002D   /* long name for Thursday */
#define LOCALE_SDAYNAME5            0x0000002E   /* long name for Friday */
#define LOCALE_SDAYNAME6            0x0000002F   /* long name for Saturday */
#define LOCALE_SDAYNAME7            0x00000030   /* long name for Sunday */
#define LOCALE_SABBREVDAYNAME1      0x00000031   /* abbreviated name for Monday */
#define LOCALE_SABBREVDAYNAME2      0x00000032   /* abbreviated name for Tuesday */
#define LOCALE_SABBREVDAYNAME3      0x00000033   /* abbreviated name for Wednesday */
#define LOCALE_SABBREVDAYNAME4      0x00000034   /* abbreviated name for Thursday */
#define LOCALE_SABBREVDAYNAME5      0x00000035   /* abbreviated name for Friday */
#define LOCALE_SABBREVDAYNAME6      0x00000036   /* abbreviated name for Saturday */
#define LOCALE_SABBREVDAYNAME7      0x00000037   /* abbreviated name for Sunday */
#define LOCALE_SMONTHNAME1          0x00000038   /* long name for January */
#define LOCALE_SMONTHNAME2          0x00000039   /* long name for February */
#define LOCALE_SMONTHNAME3          0x0000003A   /* long name for March */
#define LOCALE_SMONTHNAME4          0x0000003B   /* long name for April */
#define LOCALE_SMONTHNAME5          0x0000003C   /* long name for May */
#define LOCALE_SMONTHNAME6          0x0000003D   /* long name for June */
#define LOCALE_SMONTHNAME7          0x0000003E   /* long name for July */
#define LOCALE_SMONTHNAME8          0x0000003F   /* long name for August */
#define LOCALE_SMONTHNAME9          0x00000040   /* long name for September */
#define LOCALE_SMONTHNAME10         0x00000041   /* long name for October */
#define LOCALE_SMONTHNAME11         0x00000042   /* long name for November */
#define LOCALE_SMONTHNAME12         0x00000043   /* long name for December */
#define LOCALE_SMONTHNAME13         0x0000100E   /* long name for 13th month (if exists) */
#define LOCALE_SABBREVMONTHNAME1    0x00000044   /* abbreviated name for January */
#define LOCALE_SABBREVMONTHNAME2    0x00000045   /* abbreviated name for February */
#define LOCALE_SABBREVMONTHNAME3    0x00000046   /* abbreviated name for March */
#define LOCALE_SABBREVMONTHNAME4    0x00000047   /* abbreviated name for April */
#define LOCALE_SABBREVMONTHNAME5    0x00000048   /* abbreviated name for May */
#define LOCALE_SABBREVMONTHNAME6    0x00000049   /* abbreviated name for June */
#define LOCALE_SABBREVMONTHNAME7    0x0000004A   /* abbreviated name for July */
#define LOCALE_SABBREVMONTHNAME8    0x0000004B   /* abbreviated name for August */
#define LOCALE_SABBREVMONTHNAME9    0x0000004C   /* abbreviated name for September */
#define LOCALE_SABBREVMONTHNAME10   0x0000004D   /* abbreviated name for October */
#define LOCALE_SABBREVMONTHNAME11   0x0000004E   /* abbreviated name for November */
#define LOCALE_SABBREVMONTHNAME12   0x0000004F   /* abbreviated name for December */
#define LOCALE_SABBREVMONTHNAME13   0x0000100F   /* abbreviated name for 13th month (if exists) */

#define LOCALE_SPOSITIVESIGN        0x00000050   /* positive sign */
#define LOCALE_SNEGATIVESIGN        0x00000051   /* negative sign */
#define LOCALE_IPOSSIGNPOSN         0x00000052   /* positive sign position */
#define LOCALE_INEGSIGNPOSN         0x00000053   /* negative sign position */
#define LOCALE_IPOSSYMPRECEDES      0x00000054   /* mon sym precedes pos amt */
#define LOCALE_IPOSSEPBYSPACE       0x00000055   /* mon sym sep by space from pos amt */
#define LOCALE_INEGSYMPRECEDES      0x00000056   /* mon sym precedes neg amt */
#define LOCALE_INEGSEPBYSPACE       0x00000057   /* mon sym sep by space from neg amt */

#if(WINVER >= 0x0400)
#define LOCALE_FONTSIGNATURE       0x00000058   /* font signature */
#endif /* WINVER >= 0x0400 */

/*
 *  Time Flags for GetTimeFormatW.
 */
#define TIME_NOMINUTESORSECONDS    0x00000001  /* do not use minutes or seconds */
#define TIME_NOSECONDS             0x00000002  /* do not use seconds */
#define TIME_NOTIMEMARKER          0x00000004  /* do not use time marker */
#define TIME_FORCE24HOURFORMAT     0x00000008  /* always use 24 hour format */


/*
 *  Date Flags for GetDateFormatW.
 */
#define DATE_SHORTDATE             0x00000001  /* use short date picture */
#define DATE_LONGDATE              0x00000002  /* use long date picture */
#define DATE_USE_ALT_CALENDAR      0x00000004  /* use alternate calendar (if any) */


/*
 *  Calendar Types.
 *
 *  These types are used for the GetALTCalendarInfoW NLS API routine.
 */
#define CAL_ICALINTVALUE           0x00000001   /* calendar type */
#define CAL_SCALNAME               0x00000002   /* native name of calendar */
#define CAL_IYEAROFFSETRANGE       0x00000003   /* starting years of eras */
#define CAL_SERASTRING             0x00000004   /* era name for IYearOffsetRanges */
#define CAL_SSHORTDATE             0x00000005   /* short date format string */
#define CAL_SLONGDATE              0x00000006   /* long date format string */
#define CAL_SDAYNAME1              0x00000007   /* native name for Monday */
#define CAL_SDAYNAME2              0x00000008   /* native name for Tuesday */
#define CAL_SDAYNAME3              0x00000009   /* native name for Wednesday */
#define CAL_SDAYNAME4              0x0000000a   /* native name for Thursday */
#define CAL_SDAYNAME5              0x0000000b   /* native name for Friday */
#define CAL_SDAYNAME6              0x0000000c   /* native name for Saturday */
#define CAL_SDAYNAME7              0x0000000d   /* native name for Sunday */
#define CAL_SABBREVDAYNAME1        0x0000000e   /* abbreviated name for Monday */
#define CAL_SABBREVDAYNAME2        0x0000000f   /* abbreviated name for Tuesday */
#define CAL_SABBREVDAYNAME3        0x00000010   /* abbreviated name for Wednesday */
#define CAL_SABBREVDAYNAME4        0x00000011   /* abbreviated name for Thursday */
#define CAL_SABBREVDAYNAME5        0x00000012   /* abbreviated name for Friday */
#define CAL_SABBREVDAYNAME6        0x00000013   /* abbreviated name for Saturday */
#define CAL_SABBREVDAYNAME7        0x00000014   /* abbreviated name for Sunday */
#define CAL_SMONTHNAME1            0x00000015   /* native name for January */
#define CAL_SMONTHNAME2            0x00000016   /* native name for February */
#define CAL_SMONTHNAME3            0x00000017   /* native name for March */
#define CAL_SMONTHNAME4            0x00000018   /* native name for April */
#define CAL_SMONTHNAME5            0x00000019   /* native name for May */
#define CAL_SMONTHNAME6            0x0000001a   /* native name for June */
#define CAL_SMONTHNAME7            0x0000001b   /* native name for July */
#define CAL_SMONTHNAME8            0x0000001c   /* native name for August */
#define CAL_SMONTHNAME9            0x0000001d   /* native name for September */
#define CAL_SMONTHNAME10           0x0000001e   /* native name for October */
#define CAL_SMONTHNAME11           0x0000001f   /* native name for November */
#define CAL_SMONTHNAME12           0x00000020   /* native name for December */
#define CAL_SMONTHNAME13           0x00000021   /* native name for 13th month (if any) */
#define CAL_SABBREVMONTHNAME1      0x00000022   /* abbreviated name for January */
#define CAL_SABBREVMONTHNAME2      0x00000023   /* abbreviated name for February */
#define CAL_SABBREVMONTHNAME3      0x00000024   /* abbreviated name for March */
#define CAL_SABBREVMONTHNAME4      0x00000025   /* abbreviated name for April */
#define CAL_SABBREVMONTHNAME5      0x00000026   /* abbreviated name for May */
#define CAL_SABBREVMONTHNAME6      0x00000027   /* abbreviated name for June */
#define CAL_SABBREVMONTHNAME7      0x00000028   /* abbreviated name for July */
#define CAL_SABBREVMONTHNAME8      0x00000029   /* abbreviated name for August */
#define CAL_SABBREVMONTHNAME9      0x0000002a   /* abbreviated name for September */
#define CAL_SABBREVMONTHNAME10     0x0000002b   /* abbreviated name for October */
#define CAL_SABBREVMONTHNAME11     0x0000002c   /* abbreviated name for November */
#define CAL_SABBREVMONTHNAME12     0x0000002d   /* abbreviated name for December */
#define CAL_SABBREVMONTHNAME13     0x0000002e   /* abbreviated name for 13th month (if any) */


/*
 *  Calendar Enumeration Value.
 */
#define ENUM_ALL_CALENDARS         0xffffffff   /* enumerate all calendars */


/*
 *  Calendar ID Values.
 */
#define CAL_GREGORIAN        1         /* Gregorian (localized) calendar */
#define CAL_GREGORIAN_US     2         /* Gregorian (U.S.) calendar */
#define CAL_JAPAN            3         /* Japanese Emperor Era calendar */
#define CAL_TAIWAN           4         /* Republic of China Era calendar */
#define CAL_KOREA            5         /* Korean Tangun Era calendar */




/***************************************************************************\
* Typedefs
*
* Define all types for the NLS component here.
\***************************************************************************/

/*
 *  Locale type constant.
 */
typedef DWORD LCTYPE;

/*
 *  Calendar type constant.
 */
typedef DWORD CALTYPE;

/*
 *  Calendar ID.
 */
typedef DWORD CALID;


/*
 *  CP Info.
 */

typedef struct _cpinfo {
    UINT    MaxCharSize;                    /* max length (bytes) of a char */
    BYTE    DefaultChar[MAX_DEFAULTCHAR];   /* default character */
    BYTE    LeadByte[MAX_LEADBYTES];        /* lead byte ranges */
} CPINFO, *LPCPINFO;


/*
 *  Number format.
 */

typedef struct _numberfmtA {
    UINT    NumDigits;                 /* number of decimal digits */
    UINT    LeadingZero;               /* if leading zero in decimal fields */
    UINT    Grouping;                  /* group size left of decimal */
    LPSTR   lpDecimalSep;              /* ptr to decimal separator string */
    LPSTR   lpThousandSep;             /* ptr to thousand separator string */
    UINT    NegativeOrder;             /* negative number ordering */
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT    NumDigits;                 /* number of decimal digits */
    UINT    LeadingZero;               /* if leading zero in decimal fields */
    UINT    Grouping;                  /* group size left of decimal */
    LPWSTR  lpDecimalSep;              /* ptr to decimal separator string */
    LPWSTR  lpThousandSep;             /* ptr to thousand separator string */
    UINT    NegativeOrder;             /* negative number ordering */
} NUMBERFMTW, *LPNUMBERFMTW;
#ifdef UNICODE
typedef NUMBERFMTW NUMBERFMT;
typedef LPNUMBERFMTW LPNUMBERFMT;
#else
typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
#endif // UNICODE


/*
 *  Currency format.
 */

typedef struct _currencyfmtA {
    UINT    NumDigits;                 /* number of decimal digits */
    UINT    LeadingZero;               /* if leading zero in decimal fields */
    UINT    Grouping;                  /* group size left of decimal */
    LPSTR   lpDecimalSep;              /* ptr to decimal separator string */
    LPSTR   lpThousandSep;             /* ptr to thousand separator string */
    UINT    NegativeOrder;             /* negative currency ordering */
    UINT    PositiveOrder;             /* positive currency ordering */
    LPSTR   lpCurrencySymbol;          /* ptr to currency symbol string */
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT    NumDigits;                 /* number of decimal digits */
    UINT    LeadingZero;               /* if leading zero in decimal fields */
    UINT    Grouping;                  /* group size left of decimal */
    LPWSTR  lpDecimalSep;              /* ptr to decimal separator string */
    LPWSTR  lpThousandSep;             /* ptr to thousand separator string */
    UINT    NegativeOrder;             /* negative currency ordering */
    UINT    PositiveOrder;             /* positive currency ordering */
    LPWSTR  lpCurrencySymbol;          /* ptr to currency symbol string */
} CURRENCYFMTW, *LPCURRENCYFMTW;
#ifdef UNICODE
typedef CURRENCYFMTW CURRENCYFMT;
typedef LPCURRENCYFMTW LPCURRENCYFMT;
#else
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
#endif // UNICODE



/*
 *  Enumeration function constants.
 */

#ifdef STRICT

typedef BOOL (CALLBACK* LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (CALLBACK* CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (CALLBACK* DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (CALLBACK* TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (CALLBACK* CALINFO_ENUMPROCA)(LPSTR);

typedef BOOL (CALLBACK* LOCALE_ENUMPROCW)(LPWSTR);
typedef BOOL (CALLBACK* CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (CALLBACK* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (CALLBACK* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (CALLBACK* CALINFO_ENUMPROCW)(LPWSTR);

#else /* !STRICT */

typedef FARPROC LOCALE_ENUMPROCA;
typedef FARPROC CODEPAGE_ENUMPROCA;
typedef FARPROC DATEFMT_ENUMPROCA;
typedef FARPROC TIMEFMT_ENUMPROCA;
typedef FARPROC CALINFO_ENUMPROCA;

typedef FARPROC LOCALE_ENUMPROCW;
typedef FARPROC CODEPAGE_ENUMPROCW;
typedef FARPROC DATEFMT_ENUMPROCW;
typedef FARPROC TIMEFMT_ENUMPROCW;
typedef FARPROC CALINFO_ENUMPROCW;

#endif /* !STRICT */

#ifdef UNICODE

#define LOCALE_ENUMPROC    LOCALE_ENUMPROCW
#define CODEPAGE_ENUMPROC  CODEPAGE_ENUMPROCW
#define DATEFMT_ENUMPROC   DATEFMT_ENUMPROCW
#define TIMEFMT_ENUMPROC   TIMEFMT_ENUMPROCW
#define CALINFO_ENUMPROC   CALINFO_ENUMPROCW

#else

#define LOCALE_ENUMPROC    LOCALE_ENUMPROCA
#define CODEPAGE_ENUMPROC  CODEPAGE_ENUMPROCA
#define DATEFMT_ENUMPROC   DATEFMT_ENUMPROCA
#define TIMEFMT_ENUMPROC   TIMEFMT_ENUMPROCA
#define CALINFO_ENUMPROC   CALINFO_ENUMPROCA

#endif // !UNICODE



/***************************************************************************\
* Macros
*
* Define all macros for the NLS component here.
\***************************************************************************/



/***************************************************************************\
* Function Prototypes
*
* Only prototypes for the NLS APIs should go here.
\***************************************************************************/

/*
 *  Code Page Dependent APIs.
 */

WINBASEAPI
BOOL
WINAPI
IsValidCodePage(
    UINT  CodePage);

WINBASEAPI
UINT
WINAPI
GetACP(void);

WINBASEAPI
UINT
WINAPI
GetOEMCP(void);

WINBASEAPI
BOOL
WINAPI
GetCPInfo(
    UINT      CodePage,
    LPCPINFO  lpCPInfo);

WINBASEAPI
BOOL
WINAPI
IsDBCSLeadByte(
    BYTE  TestChar);

WINBASEAPI
BOOL
WINAPI
IsDBCSLeadByteEx(
    UINT  CodePage,
    BYTE  TestChar);

WINBASEAPI
int
WINAPI
MultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

WINBASEAPI
int
WINAPI
WideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);


/*
 *  Locale Dependent APIs.
 */

WINBASEAPI
int
WINAPI
CompareStringA(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCSTR lpString1,
    int      cchCount1,
    LPCSTR lpString2,
    int      cchCount2);
WINBASEAPI
int
WINAPI
CompareStringW(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR lpString1,
    int      cchCount1,
    LPCWSTR lpString2,
    int      cchCount2);
#ifdef UNICODE
#define CompareString  CompareStringW
#else
#define CompareString  CompareStringA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
LCMapStringA(
    LCID     Locale,
    DWORD    dwMapFlags,
    LPCSTR lpSrcStr,
    int      cchSrc,
    LPSTR  lpDestStr,
    int      cchDest);
WINBASEAPI
int
WINAPI
LCMapStringW(
    LCID     Locale,
    DWORD    dwMapFlags,
    LPCWSTR lpSrcStr,
    int      cchSrc,
    LPWSTR  lpDestStr,
    int      cchDest);
#ifdef UNICODE
#define LCMapString  LCMapStringW
#else
#define LCMapString  LCMapStringA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
GetLocaleInfoA(
    LCID     Locale,
    LCTYPE   LCType,
    LPSTR  lpLCData,
    int      cchData);
WINBASEAPI
int
WINAPI
GetLocaleInfoW(
    LCID     Locale,
    LCTYPE   LCType,
    LPWSTR  lpLCData,
    int      cchData);
#ifdef UNICODE
#define GetLocaleInfo  GetLocaleInfoW
#else
#define GetLocaleInfo  GetLocaleInfoA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetLocaleInfoA(
    LCID     Locale,
    LCTYPE   LCType,
    LPCSTR lpLCData);
WINBASEAPI
BOOL
WINAPI
SetLocaleInfoW(
    LCID     Locale,
    LCTYPE   LCType,
    LPCWSTR lpLCData);
#ifdef UNICODE
#define SetLocaleInfo  SetLocaleInfoW
#else
#define SetLocaleInfo  SetLocaleInfoA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
GetTimeFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCSTR lpFormat,
    LPSTR  lpTimeStr,
    int      cchTime);
WINBASEAPI
int
WINAPI
GetTimeFormatW(
    LCID     Locale,
    DWORD    dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR  lpTimeStr,
    int      cchTime);
#ifdef UNICODE
#define GetTimeFormat  GetTimeFormatW
#else
#define GetTimeFormat  GetTimeFormatA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
GetDateFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCSTR lpFormat,
    LPSTR  lpDateStr,
    int      cchDate);
WINBASEAPI
int
WINAPI
GetDateFormatW(
    LCID     Locale,
    DWORD    dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR  lpDateStr,
    int      cchDate);
#ifdef UNICODE
#define GetDateFormat  GetDateFormatW
#else
#define GetDateFormat  GetDateFormatA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
GetNumberFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    LPCSTR lpValue,
    CONST NUMBERFMTA *lpFormat,
    LPSTR  lpNumberStr,
    int      cchNumber);
WINBASEAPI
int
WINAPI
GetNumberFormatW(
    LCID     Locale,
    DWORD    dwFlags,
    LPCWSTR lpValue,
    CONST NUMBERFMTW *lpFormat,
    LPWSTR  lpNumberStr,
    int      cchNumber);
#ifdef UNICODE
#define GetNumberFormat  GetNumberFormatW
#else
#define GetNumberFormat  GetNumberFormatA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
GetCurrencyFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    LPCSTR lpValue,
    CONST CURRENCYFMTA *lpFormat,
    LPSTR  lpCurrencyStr,
    int      cchCurrency);
WINBASEAPI
int
WINAPI
GetCurrencyFormatW(
    LCID     Locale,
    DWORD    dwFlags,
    LPCWSTR lpValue,
    CONST CURRENCYFMTW *lpFormat,
    LPWSTR  lpCurrencyStr,
    int      cchCurrency);
#ifdef UNICODE
#define GetCurrencyFormat  GetCurrencyFormatW
#else
#define GetCurrencyFormat  GetCurrencyFormatA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumCalendarInfoA(
    CALINFO_ENUMPROCA lpCalInfoEnumProc,
    LCID              Locale,
    CALID             Calendar,
    CALTYPE           CalType);
WINBASEAPI
BOOL
WINAPI
EnumCalendarInfoW(
    CALINFO_ENUMPROCW lpCalInfoEnumProc,
    LCID              Locale,
    CALID             Calendar,
    CALTYPE           CalType);
#ifdef UNICODE
#define EnumCalendarInfo  EnumCalendarInfoW
#else
#define EnumCalendarInfo  EnumCalendarInfoA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumTimeFormatsA(
    TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
WINBASEAPI
BOOL
WINAPI
EnumTimeFormatsW(
    TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
#ifdef UNICODE
#define EnumTimeFormats  EnumTimeFormatsW
#else
#define EnumTimeFormats  EnumTimeFormatsA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumDateFormatsA(
    DATEFMT_ENUMPROCA lpDateFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
WINBASEAPI
BOOL
WINAPI
EnumDateFormatsW(
    DATEFMT_ENUMPROCW lpDateFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
#ifdef UNICODE
#define EnumDateFormats  EnumDateFormatsW
#else
#define EnumDateFormats  EnumDateFormatsA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
IsValidLocale(
    LCID   Locale,
    DWORD  dwFlags);

WINBASEAPI
LCID
WINAPI
ConvertDefaultLocale(
    LCID   Locale);

WINBASEAPI
LCID
WINAPI
GetThreadLocale(void);

WINBASEAPI
BOOL
WINAPI
SetThreadLocale(
    LCID  Locale
    );

WINBASEAPI
LANGID
WINAPI
GetSystemDefaultLangID(void);

WINBASEAPI
LANGID
WINAPI
GetUserDefaultLangID(void);

WINBASEAPI
LCID
WINAPI
GetSystemDefaultLCID(void);

WINBASEAPI
LCID
WINAPI
GetUserDefaultLCID(void);

/*
 *  Locale Independent APIs.
 */

WINBASEAPI
BOOL
WINAPI
GetStringTypeExA(
    LCID     Locale,
    DWORD    dwInfoType,
    LPCSTR lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);
WINBASEAPI
BOOL
WINAPI
GetStringTypeExW(
    LCID     Locale,
    DWORD    dwInfoType,
    LPCWSTR lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);
#ifdef UNICODE
#define GetStringTypeEx  GetStringTypeExW
#else
#define GetStringTypeEx  GetStringTypeExA
#endif // !UNICODE

/*
 *  NOTE: The parameters for GetStringTypeA and GetStringTypeW are
 *        NOT the same.  The W version was shipped in NT 3.1.  The
 *        A version was then shipped in 16-bit OLE with the wrong
 *        parameters (ported from Win95).  To be compatible, we
 *        must break the relationship between the A and W versions
 *        of GetStringType.  There will be NO function call for the
 *        generic GetStringType.
 *
 *        GetStringTypeEx (above) should be used instead.
 */
WINBASEAPI
BOOL
WINAPI
GetStringTypeA(
    LCID     Locale,
    DWORD    dwInfoType,
    LPCSTR   lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);

WINBASEAPI
BOOL
WINAPI
GetStringTypeW(
    DWORD    dwInfoType,
    LPCWSTR  lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);


WINBASEAPI
int
WINAPI
FoldStringA(
    DWORD    dwMapFlags,
    LPCSTR lpSrcStr,
    int      cchSrc,
    LPSTR  lpDestStr,
    int      cchDest);
WINBASEAPI
int
WINAPI
FoldStringW(
    DWORD    dwMapFlags,
    LPCWSTR lpSrcStr,
    int      cchSrc,
    LPWSTR  lpDestStr,
    int      cchDest);
#ifdef UNICODE
#define FoldString  FoldStringW
#else
#define FoldString  FoldStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumSystemLocalesA(
    LOCALE_ENUMPROCA lpLocaleEnumProc,
    DWORD            dwFlags);
WINBASEAPI
BOOL
WINAPI
EnumSystemLocalesW(
    LOCALE_ENUMPROCW lpLocaleEnumProc,
    DWORD            dwFlags);
#ifdef UNICODE
#define EnumSystemLocales  EnumSystemLocalesW
#else
#define EnumSystemLocales  EnumSystemLocalesA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumSystemCodePagesA(
    CODEPAGE_ENUMPROCA lpCodePageEnumProc,
    DWORD              dwFlags);
WINBASEAPI
BOOL
WINAPI
EnumSystemCodePagesW(
    CODEPAGE_ENUMPROCW lpCodePageEnumProc,
    DWORD              dwFlags);
#ifdef UNICODE
#define EnumSystemCodePages  EnumSystemCodePagesW
#else
#define EnumSystemCodePages  EnumSystemCodePagesA
#endif // !UNICODE



#endif   // NONLS

#ifdef __cplusplus
}
#endif

#endif   // _WINNLS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINNT.H ===
/*++ BUILD Version: 0093     Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/

#ifndef _WINNT_
#define _WINNT_

#ifdef __cplusplus
extern "C" {
#endif

#include <ctype.h>  
#define ANYSIZE_ARRAY 1       

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif


#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

typedef void *PVOID;    

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NTAPI __stdcall
#else
#define _cdecl
#define NTAPI
#endif

//
// Define API decoration for direct importing system DLL references.
//

#if !defined(_NTSYSTEM_)
#define NTSYSAPI DECLSPEC_IMPORT
#else
#define NTSYSAPI
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote

#else   /* UNICODE */

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define __TEXT(quote) quote

#endif /* UNICODE */
#define TEXT(quote) __TEXT(quote)


typedef SHORT *PSHORT;  
typedef LONG *PLONG;    

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      
/*lint -e624 */  
/*lint +e624 */  
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef __int64 LONGLONG;
typedef unsigned __int64 DWORDLONG;
#else
typedef double LONGLONG;
typedef double DWORDLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef DWORDLONG *PDWORDLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    };
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
#endif //MIDL_PASS
    DWORDLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;

// end_ntminiport end_ntndis

//
// Locally Unique Identifier
//

typedef LARGE_INTEGER LUID, *PLUID;


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//

#if defined(MIDL_PASS) || defined(RC_INVOKED)

//
// Midl does not understand inline assembler. Therefore, the Rtl functions
// are used for shifts by 0.31 and multiplies of 32-bits times 32-bits to
// form a 64-bit product.
//

#define Int32x32To64(a, b) ((LONGLONG)((LONG)(a)) * (LONGLONG)((LONG)(b)))
#define UInt32x32To64(a, b) ((DWORDLONG)((DWORD)(a)) * (DWORDLONG)((DWORD)(b)))

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))

#elif defined(_M_MRX000)

//
// MIPS uses intrinsic functions to perform shifts by 0..31 and multiplies of
// 32-bits times 32-bits to 64-bits.
//

#define Int32x32To64 __emul
#define UInt32x32To64 __emulu

#define Int64ShllMod32 __ll_lshift
#define Int64ShraMod32 __ll_rshift
#define Int64ShrlMod32 __ull_rshift

#if defined (__cplusplus)
extern "C" {
#endif

LONGLONG
NTAPI
Int32x32To64 (
    LONG Multiplier,
    LONG Multiplicand
    );

DWORDLONG
NTAPI
UInt32x32To64 (
    DWORD Multiplier,
    DWORD Multiplicand
    );

DWORDLONG
NTAPI
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    );

DWORDLONG
NTAPI
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

#if defined (__cplusplus)
};
#endif

#pragma intrinsic(__emul)
#pragma intrinsic(__emulu)

#pragma intrinsic(__ll_lshift)
#pragma intrinsic(__ll_rshift)
#pragma intrinsic(__ull_rshift)

#elif defined(_M_IX86)

//
// The x86 C compiler understands inline assembler. Therefore, inline functions
// that employ inline assembler are used for shifts of 0..31.  The multiplies
// rely on the compiler recognizing the cast of the multiplicand to int64 to
// generate the optimal code inline.
//

#define Int32x32To64( a, b ) (LONGLONG)((LONGLONG)(LONG)(a) * (LONG)(b))
#define UInt32x32To64( a, b ) (DWORDLONG)((DWORDLONG)(DWORD)(a) * (DWORD)(b))

DWORDLONG
NTAPI
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    );

DWORDLONG
NTAPI
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

#if !defined (__cplusplus)

#pragma warning(disable:4035)               // re-enable below

__inline DWORDLONG
NTAPI
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    )
{
    _asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    }
}

__inline LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    )
{
    _asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    }
}

__inline DWORDLONG
NTAPI
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    )
{
    _asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    }
}

#else

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))

#endif // !defined (__cplusplus)

#pragma warning(default:4035)

#elif defined(_M_ALPHA)

//
// Alpha has native 64-bit operations that are just as fast as their 32-bit
// counter parts. Therefore, the int64 data type is used directly to form
// shifts of 0..31 and multiplies of 32-bits times 32-bits to form a 64-bit
// product.
//

#define Int32x32To64(a, b) ((LONGLONG)((LONG)(a)) * (LONGLONG)((LONG)(b)))
#define UInt32x32To64(a, b) ((DWORDLONG)((DWORD)(a)) * (DWORDLONG)((DWORD)(b)))

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))


#elif defined(_M_PPC)

#define Int32x32To64(a, b) ((LONGLONG)((LONG)(a)) * (LONGLONG)((LONG)(b)))
#define UInt32x32To64(a, b) ((DWORDLONG)((DWORD)(a)) * (DWORDLONG)((DWORD)(b)))

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))

#else

#error Must define a target architecture.

#endif

#define UNICODE_NULL ((WCHAR)0) 
typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;

//
// Base data structures for OLE support
//

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD Data1;
    WORD   Data2;
    WORD   Data3;
    BYTE  Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED

typedef struct  _OBJECTID {     // size is 20
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#endif // !_OBJECTID_DEFINED

#define MINCHAR     0x80        
#define MAXCHAR     0x7f        
#define MINSHORT    0x8000      
#define MAXSHORT    0x7fff      
#define MINLONG     0x80000000  
#define MAXLONG     0x7fffffff  
#define MAXBYTE     0xff        
#define MAXWORD     0xffff      
#define MAXDWORD    0xffffffff  
//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))

/*
 *  Language IDs.
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics:
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
 *    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
 */

/*
 *  Primary language IDs.
 */
#define LANG_NEUTRAL                     0x00

#define LANG_ARABIC                      0x01
#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_BASQUE                      0x2d
#define LANG_BULGARIAN                   0x02
#define LANG_BYELORUSSIAN                0x23
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HEBREW                      0x0D
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_INDONESIAN                  0x21
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SORBIAN                     0x2e
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_UKRAINIAN                   0x22

/*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 */
#define SUBLANG_NEUTRAL                  0x00    /* language neutral */
#define SUBLANG_DEFAULT                  0x01    /* user default */
#define SUBLANG_SYS_DEFAULT              0x02    /* system default */

#define SUBLANG_ARABIC                   0x01    /* Arabic (Saudi Arabia) */
#define SUBLANG_ARABIC_IRAQ              0x02    /* Arabic (Iraq) */
#define SUBLANG_ARABIC_EGYPT             0x03    /* Arabic (Egypt) */
#define SUBLANG_ARABIC_LIBYA             0x04    /* Arabic (Libya) */
#define SUBLANG_ARABIC_ALGERIA           0x05    /* Arabic (Algeria) */
#define SUBLANG_ARABIC_MOROCCO           0x06    /* Arabic (Morocco) */
#define SUBLANG_ARABIC_TUNISIA           0x07    /* Arabic (Tunisia) */
#define SUBLANG_ARABIC_OMAN              0x08    /* Arabic (Oman) */
#define SUBLANG_ARABIC_YEMEN             0x09    /* Arabic (Yemen) */
#define SUBLANG_ARABIC_SYRIA             0x10    /* Arabic (Syria) */
#define SUBLANG_ARABIC_JORDAN            0x11    /* Arabic (Jordan) */
#define SUBLANG_ARABIC_LEBANON           0x12    /* Arabic (Lebanon) */
#define SUBLANG_ARABIC_KUWAIT            0x13    /* Arabic (Kuwait) */
#define SUBLANG_ARABIC_UAE               0x14    /* Arabic (United Arab Emirates) */
#define SUBLANG_ARABIC_BAHRAIN           0x15    /* Arabic (Bahrain) */
#define SUBLANG_ARABIC_QATAR             0x16    /* Arabic (Qatar) */
#define SUBLANG_CHINESE_TRADITIONAL      0x01    /* Chinese (Taiwan) */
#define SUBLANG_CHINESE_SIMPLIFIED       0x02    /* Chinese (PR China) */
#define SUBLANG_CHINESE_HONGKONG         0x03    /* Chinese (Hong Kong) */
#define SUBLANG_CHINESE_SINGAPORE        0x04    /* Chinese (Singapore) */
#define SUBLANG_DUTCH                    0x01    /* Dutch */
#define SUBLANG_DUTCH_BELGIAN            0x02    /* Dutch (Belgian) */
#define SUBLANG_ENGLISH_US               0x01    /* English (USA) */
#define SUBLANG_ENGLISH_UK               0x02    /* English (UK) */
#define SUBLANG_ENGLISH_AUS              0x03    /* English (Australian) */
#define SUBLANG_ENGLISH_CAN              0x04    /* English (Canadian) */
#define SUBLANG_ENGLISH_NZ               0x05    /* English (New Zealand) */
#define SUBLANG_ENGLISH_EIRE             0x06    /* English (Irish) */
#define SUBLANG_ENGLISH_SAFRICA          0x07    /* English (South Africa) */
#define SUBLANG_ENGLISH_JAMAICA          0x08    /* English (Jamaica) */
#define SUBLANG_ENGLISH_CARRIBEAN        0x09    /* English (Carribean) */
#define SUBLANG_FRENCH                   0x01    /* French */
#define SUBLANG_FRENCH_BELGIAN           0x02    /* French (Belgian) */
#define SUBLANG_FRENCH_CANADIAN          0x03    /* French (Canadian) */
#define SUBLANG_FRENCH_SWISS             0x04    /* French (Swiss) */
#define SUBLANG_FRENCH_LUXEMBOURG        0x05    /* French (Luxembourg) */
#define SUBLANG_GERMAN                   0x01    /* German */
#define SUBLANG_GERMAN_SWISS             0x02    /* German (Swiss) */
#define SUBLANG_GERMAN_AUSTRIAN          0x03    /* German (Austrian) */
#define SUBLANG_GERMAN_LUXEMBOURG        0x04    /* German (Luxembourg) */
#define SUBLANG_GERMAN_LIECHTENSTEIN     0x05    /* German (Liechtenstein) */
#define SUBLANG_ITALIAN                  0x01    /* Italian */
#define SUBLANG_ITALIAN_SWISS            0x02    /* Italian (Swiss) */
#define SUBLANG_KOREAN                   0x01    /* Korean */
#define SUBLANG_KOREAN_JOHAB             0x02    /* Korean (Johab) */
#define SUBLANG_NORWEGIAN_BOKMAL         0x01    /* Norwegian (Bokmal) */
#define SUBLANG_NORWEGIAN_NYNORSK        0x02    /* Norwegian (Nynorsk) */
#define SUBLANG_PORTUGUESE               0x02    /* Portuguese */
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01    /* Portuguese (Brazilian) */
#define SUBLANG_SPANISH                  0x01    /* Spanish (Castilian) */
#define SUBLANG_SPANISH_MEXICAN          0x02    /* Spanish (Mexican) */
#define SUBLANG_SPANISH_MODERN           0x03    /* Spanish (Modern) */
#define SUBLANG_SPANISH_GUATEMALA        0x04    /* Spanish (Guatemala) */
#define SUBLANG_SPANISH_COSTARICA        0x05    /* Spanish (Costa Rica) */
#define SUBLANG_SPANISH_PANAMA           0x06    /* Spanish (Panama) */
#define SUBLANG_SPANISH_DOMINICAN        0x07    /* Spanish (Dominican Republic) */
#define SUBLANG_SPANISH_VENEZUELA        0x08    /* Spanish (Venezuela) */
#define SUBLANG_SPANISH_COLOMBIA         0x09    /* Spanish (Colombia) */
#define SUBLANG_SPANISH_PERU             0x10    /* Spanish (Peru) */
#define SUBLANG_SPANISH_ARGENTINA        0x11    /* Spanish (Argentina) */
#define SUBLANG_SPANISH_ECUADOR          0x12    /* Spanish (Ecuador) */
#define SUBLANG_SPANISH_CHILE            0x13    /* Spanish (Chile) */
#define SUBLANG_SPANISH_URUGUAY          0x14    /* Spanish (Uruguay) */
#define SUBLANG_SPANISH_PARAGUAY         0x15    /* Spanish (Paraguay) */
#define SUBLANG_SPANISH_BOLIVIA          0x16    /* Spanish (Bolivia) */

/*
 *  Sorting IDs.
 *
 */
#define SORT_DEFAULT                     0x0     /* sorting default */

#define SORT_JAPANESE_XJIS               0x0     /* Japanese XJIS order */
#define SORT_JAPANESE_UNICODE            0x1     /* Japanese Unicode order */

#define SORT_CHINESE_BIG5                0x0     /* Chinese BIG5 order */
#define SORT_CHINESE_UNICODE             0x1     /* Chinese Unicode order */

#define SORT_KOREAN_KSC                  0x0     /* Korean KSC order */
#define SORT_KOREAN_UNICODE              0x1     /* Korean Unicode order */


/*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |     Sublanguage ID    |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from a primary language id and
 *                    a sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 */
#define MAKELANGID(p, s)       ((((WORD  )(s)) << 10) | (WORD  )(p))
#define PRIMARYLANGID(lgid)    ((WORD  )(lgid) & 0x3ff)
#define SUBLANGID(lgid)        ((WORD  )(lgid) >> 10)


/*
 *  A locale ID is a 32 bit value which is the combination of a
 *  language ID, a sort ID, and a reserved area.  The bits are
 *  allocated as follows:
 *
 *       +-------------+---------+-------------------------+
 *       |   Reserved  | Sort ID |      Language ID        |
 *       +-------------+---------+-------------------------+
 *        31         20 19     16 15                      0   bit
 *
 *
 *  Locale ID creation/extraction macros:
 *
 *    MAKELCID       - construct locale id from a language id and a sort id.
 *    LANGIDFROMLCID - extract language id from a locale id.
 *    SORTIDFROMLCID - extract sort id from a locale id.
 */
#define NLS_VALID_LOCALE_MASK  0x000fffff

#define MAKELCID(lgid, srtid)  ((DWORD)((((DWORD)((WORD  )(srtid))) << 16) |  \
                                         ((DWORD)((WORD  )(lgid)))))
#define LANGIDFROMLCID(lcid)   ((WORD  )(lcid))
#define SORTIDFROMLCID(lcid)   ((WORD  )((((DWORD)(lcid)) & NLS_VALID_LOCALE_MASK) >> 16))


/*
 *  Default System and User IDs for language and locale.
 */
#define LANG_SYSTEM_DEFAULT    (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT      (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT  (MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT))
#define LOCALE_USER_DEFAULT    (MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT))



// begin_ntminiport begin_ntndis

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! (defined(lint) || defined(_lint))
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint or _lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this.  line +e530 turns that checking back on.  Error 527 has to do with
// unreachable code.

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint +e527 +e530 */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint +e527 +e530 */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint +e527 +e530 */

#endif // lint or _lint


#ifndef WIN32_NO_STATUS 
/*lint -save -e767 */  
#define STATUS_WAIT_0                    ((DWORD   )0x00000000L)    
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
#define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
#define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
#define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
#define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
#define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
#define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
#define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
#define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
#define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
#define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
#define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
/*lint -restore */  
#endif 
#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended
typedef DWORD KSPIN_LOCK;  

#ifdef _ALPHA_

// begin_ntddk begin_nthal
//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_PORTABLE_32BIT     0x00100000
#define CONTEXT_ALPHA              0x00020000

#define CONTEXT_CONTROL         (CONTEXT_ALPHA | 0x00000001L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_ALPHA | 0x00000002L)
#define CONTEXT_INTEGER         (CONTEXT_ALPHA | 0x00000004L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)

#endif

#ifndef _PORTABLE_32BIT_CONTEXT

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to construct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, 4) it is used in the user level thread creation
//  routines, and 5) it is used to to pass thread state to debuggers.
//
//  N.B. Because this record is used as a call frame, it must be EXACTLY
//  a multiple of 16 bytes in length.
//
//  There are two variations of the context structure. This is the real one.
//

typedef struct _CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    DWORDLONG FltF0;
    DWORDLONG FltF1;
    DWORDLONG FltF2;
    DWORDLONG FltF3;
    DWORDLONG FltF4;
    DWORDLONG FltF5;
    DWORDLONG FltF6;
    DWORDLONG FltF7;
    DWORDLONG FltF8;
    DWORDLONG FltF9;
    DWORDLONG FltF10;
    DWORDLONG FltF11;
    DWORDLONG FltF12;
    DWORDLONG FltF13;
    DWORDLONG FltF14;
    DWORDLONG FltF15;
    DWORDLONG FltF16;
    DWORDLONG FltF17;
    DWORDLONG FltF18;
    DWORDLONG FltF19;
    DWORDLONG FltF20;
    DWORDLONG FltF21;
    DWORDLONG FltF22;
    DWORDLONG FltF23;
    DWORDLONG FltF24;
    DWORDLONG FltF25;
    DWORDLONG FltF26;
    DWORDLONG FltF27;
    DWORDLONG FltF28;
    DWORDLONG FltF29;
    DWORDLONG FltF30;
    DWORDLONG FltF31;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, and ra are defined in this section, but are
    //  considered part of the control context rather than part of the integer
    //  context.
    //

    DWORDLONG IntV0;    //  $0: return value register, v0
    DWORDLONG IntT0;    //  $1: temporary registers, t0 - t7
    DWORDLONG IntT1;    //  $2:
    DWORDLONG IntT2;    //  $3:
    DWORDLONG IntT3;    //  $4:
    DWORDLONG IntT4;    //  $5:
    DWORDLONG IntT5;    //  $6:
    DWORDLONG IntT6;    //  $7:
    DWORDLONG IntT7;    //  $8:
    DWORDLONG IntS0;    //  $9: nonvolatile registers, s0 - s5
    DWORDLONG IntS1;    // $10:
    DWORDLONG IntS2;    // $11:
    DWORDLONG IntS3;    // $12:
    DWORDLONG IntS4;    // $13:
    DWORDLONG IntS5;    // $14:
    DWORDLONG IntFp;    // $15: frame pointer register, fp/s6
    DWORDLONG IntA0;    // $16: argument registers, a0 - a5
    DWORDLONG IntA1;    // $17:
    DWORDLONG IntA2;    // $18:
    DWORDLONG IntA3;    // $19:
    DWORDLONG IntA4;    // $20:
    DWORDLONG IntA5;    // $21:
    DWORDLONG IntT8;    // $22: temporary registers, t8 - t11
    DWORDLONG IntT9;    // $23:
    DWORDLONG IntT10;   // $24:
    DWORDLONG IntT11;   // $25:
    DWORDLONG IntRa;    // $26: return address register, ra
    DWORDLONG IntT12;   // $27: temporary register, t12
    DWORDLONG IntAt;    // $28: assembler temp register, at
    DWORDLONG IntGp;    // $29: global pointer register, gp
    DWORDLONG IntSp;    // $30: stack pointer register, sp
    DWORDLONG IntZero;  // $31: zero register, zero

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    DWORDLONG Fpcr;     // floating point control register
    DWORDLONG SoftFpcr; // software extension to FPCR

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    // N.B. The registers gp, sp, and ra are defined in the integer section,
    //   but are considered part of the control context rather than part of
    //   the integer context.
    //

    DWORDLONG Fir;      // (fault instruction) continuation address
    DWORD Psr;          // processor status

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;
    DWORD Fill[4];      // padding for 16-byte stack frame alignment

} CONTEXT, *PCONTEXT;

#else

//
// 32-bit Context Frame
//
//  This alternate version of the Alpha context structure parallels that
//  of MIPS and IX86 in style for the first 64 entries: 32-bit machines
//  can operate on the fields, and a value declared as a pointer to an
//  array of int's can be used to index into the fields.  This makes life
//  with windbg and ntsd vastly easier.
//
//  There are two parts: the first contains the lower 32-bits of each
//  element in the 64-bit definition above.  The second part contains
//  the upper 32-bits of each 64-bit element above.
//
//  The names in the first part are identical to the 64-bit names.
//  The second part names are prefixed with "High".
//
//  1st half: at 32 bits each, (containing the low parts of 64-bit values)
//      32 floats, 32 ints, fpcrs, fir, psr, contextflags
//  2nd half: at 32 bits each
//      32 floats, 32 ints, fpcrs, fir, fill
//
//  There is no external support for the 32-bit version of the context
//  structure.  It is only used internally by windbg and ntsd.
//
//  This structure must be the same size as the 64-bit version above.
//

typedef struct _CONTEXT {

    DWORD FltF0;
    DWORD FltF1;
    DWORD FltF2;
    DWORD FltF3;
    DWORD FltF4;
    DWORD FltF5;
    DWORD FltF6;
    DWORD FltF7;
    DWORD FltF8;
    DWORD FltF9;
    DWORD FltF10;
    DWORD FltF11;
    DWORD FltF12;
    DWORD FltF13;
    DWORD FltF14;
    DWORD FltF15;
    DWORD FltF16;
    DWORD FltF17;
    DWORD FltF18;
    DWORD FltF19;
    DWORD FltF20;
    DWORD FltF21;
    DWORD FltF22;
    DWORD FltF23;
    DWORD FltF24;
    DWORD FltF25;
    DWORD FltF26;
    DWORD FltF27;
    DWORD FltF28;
    DWORD FltF29;
    DWORD FltF30;
    DWORD FltF31;

    DWORD IntV0;        //  $0: return value register, v0
    DWORD IntT0;        //  $1: temporary registers, t0 - t7
    DWORD IntT1;        //  $2:
    DWORD IntT2;        //  $3:
    DWORD IntT3;        //  $4:
    DWORD IntT4;        //  $5:
    DWORD IntT5;        //  $6:
    DWORD IntT6;        //  $7:
    DWORD IntT7;        //  $8:
    DWORD IntS0;        //  $9: nonvolatile registers, s0 - s5
    DWORD IntS1;        // $10:
    DWORD IntS2;        // $11:
    DWORD IntS3;        // $12:
    DWORD IntS4;        // $13:
    DWORD IntS5;        // $14:
    DWORD IntFp;        // $15: frame pointer register, fp/s6
    DWORD IntA0;        // $16: argument registers, a0 - a5
    DWORD IntA1;        // $17:
    DWORD IntA2;        // $18:
    DWORD IntA3;        // $19:
    DWORD IntA4;        // $20:
    DWORD IntA5;        // $21:
    DWORD IntT8;        // $22: temporary registers, t8 - t11
    DWORD IntT9;        // $23:
    DWORD IntT10;       // $24:
    DWORD IntT11;       // $25:
    DWORD IntRa;        // $26: return address register, ra
    DWORD IntT12;       // $27: temporary register, t12
    DWORD IntAt;        // $28: assembler temp register, at
    DWORD IntGp;        // $29: global pointer register, gp
    DWORD IntSp;        // $30: stack pointer register, sp
    DWORD IntZero;      // $31: zero register, zero

    DWORD Fpcr;         // floating point control register
    DWORD SoftFpcr;     // software extension to FPCR

    DWORD Fir;          // (fault instruction) continuation address

    DWORD Psr;          // processor status
    DWORD ContextFlags;

    //
    // Beginning of the "second half".
    // The name "High" parallels the HighPart of a LargeInteger.
    //

    DWORD HighFltF0;
    DWORD HighFltF1;
    DWORD HighFltF2;
    DWORD HighFltF3;
    DWORD HighFltF4;
    DWORD HighFltF5;
    DWORD HighFltF6;
    DWORD HighFltF7;
    DWORD HighFltF8;
    DWORD HighFltF9;
    DWORD HighFltF10;
    DWORD HighFltF11;
    DWORD HighFltF12;
    DWORD HighFltF13;
    DWORD HighFltF14;
    DWORD HighFltF15;
    DWORD HighFltF16;
    DWORD HighFltF17;
    DWORD HighFltF18;
    DWORD HighFltF19;
    DWORD HighFltF20;
    DWORD HighFltF21;
    DWORD HighFltF22;
    DWORD HighFltF23;
    DWORD HighFltF24;
    DWORD HighFltF25;
    DWORD HighFltF26;
    DWORD HighFltF27;
    DWORD HighFltF28;
    DWORD HighFltF29;
    DWORD HighFltF30;
    DWORD HighFltF31;

    DWORD HighIntV0;        //  $0: return value register, v0
    DWORD HighIntT0;        //  $1: temporary registers, t0 - t7
    DWORD HighIntT1;        //  $2:
    DWORD HighIntT2;        //  $3:
    DWORD HighIntT3;        //  $4:
    DWORD HighIntT4;        //  $5:
    DWORD HighIntT5;        //  $6:
    DWORD HighIntT6;        //  $7:
    DWORD HighIntT7;        //  $8:
    DWORD HighIntS0;        //  $9: nonvolatile registers, s0 - s5
    DWORD HighIntS1;        // $10:
    DWORD HighIntS2;        // $11:
    DWORD HighIntS3;        // $12:
    DWORD HighIntS4;        // $13:
    DWORD HighIntS5;        // $14:
    DWORD HighIntFp;        // $15: frame pointer register, fp/s6
    DWORD HighIntA0;        // $16: argument registers, a0 - a5
    DWORD HighIntA1;        // $17:
    DWORD HighIntA2;        // $18:
    DWORD HighIntA3;        // $19:
    DWORD HighIntA4;        // $20:
    DWORD HighIntA5;        // $21:
    DWORD HighIntT8;        // $22: temporary registers, t8 - t11
    DWORD HighIntT9;        // $23:
    DWORD HighIntT10;       // $24:
    DWORD HighIntT11;       // $25:
    DWORD HighIntRa;        // $26: return address register, ra
    DWORD HighIntT12;       // $27: temporary register, t12
    DWORD HighIntAt;        // $28: assembler temp register, at
    DWORD HighIntGp;        // $29: global pointer register, gp
    DWORD HighIntSp;        // $30: stack pointer register, sp
    DWORD HighIntZero;      // $31: zero register, zero

    DWORD HighFpcr;         // floating point control register
    DWORD HighSoftFpcr;     // software extension to FPCR
    DWORD HighFir;          // processor status

    double DoNotUseThisField; // to force quadword structure alignment
    DWORD HighFill[2];      // padding for 16-byte stack frame alignment

} CONTEXT, *PCONTEXT;

//
// These should name the fields in the _PORTABLE_32BIT structure
// that overlay the Psr and ContextFlags in the normal structure.
//

#define _QUAD_PSR_OFFSET   HighSoftFpcr
#define _QUAD_FLAGS_OFFSET HighFir

#endif // _PORTABLE_32BIT_CONTEXT

// end_ntddk end_nthal

#endif // _ALPHA_


#ifdef _ALPHA_

VOID
__jump_unwind (
    PVOID VirtualFramePointer,
    PVOID TargetPc
    );

#endif // _ALPHA_


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#pragma warning(default:4164)   // reenable C4164 warning

#endif
#endif


//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records

#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |\
                      CONTEXT_SEGMENTS)

#endif

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

} CONTEXT;



typedef CONTEXT *PCONTEXT;

// begin_ntminiport

#endif //_X86_


typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;


#if defined(_MIPS_)

// begin_ntddk begin_nthal
//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_R4000   0x00010000    // r4000 context

#define CONTEXT_CONTROL         (CONTEXT_R4000 | 0x00000001L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_R4000 | 0x00000002L)
#define CONTEXT_INTEGER         (CONTEXT_R4000 | 0x00000004L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)

#endif

//
// Context Frame
//
//  N.B. This frame must be exactly a multiple of 16 bytes in length.
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, and 4) it is used in the user level thread creation
//  routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // This section is always present and is used as an argument build
    // area.
    //

    DWORD Argument[4];

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    DWORD FltF0;
    DWORD FltF1;
    DWORD FltF2;
    DWORD FltF3;
    DWORD FltF4;
    DWORD FltF5;
    DWORD FltF6;
    DWORD FltF7;
    DWORD FltF8;
    DWORD FltF9;
    DWORD FltF10;
    DWORD FltF11;
    DWORD FltF12;
    DWORD FltF13;
    DWORD FltF14;
    DWORD FltF15;
    DWORD FltF16;
    DWORD FltF17;
    DWORD FltF18;
    DWORD FltF19;
    DWORD FltF20;
    DWORD FltF21;
    DWORD FltF22;
    DWORD FltF23;
    DWORD FltF24;
    DWORD FltF25;
    DWORD FltF26;
    DWORD FltF27;
    DWORD FltF28;
    DWORD FltF29;
    DWORD FltF30;
    DWORD FltF31;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, and ra are defined in this section, but are
    //  considered part of the control context rather than part of the integer
    //  context.
    //
    // N.B. Register zero is not stored in the frame.
    //

    DWORD IntZero;
    DWORD IntAt;
    DWORD IntV0;
    DWORD IntV1;
    DWORD IntA0;
    DWORD IntA1;
    DWORD IntA2;
    DWORD IntA3;
    DWORD IntT0;
    DWORD IntT1;
    DWORD IntT2;
    DWORD IntT3;
    DWORD IntT4;
    DWORD IntT5;
    DWORD IntT6;
    DWORD IntT7;
    DWORD IntS0;
    DWORD IntS1;
    DWORD IntS2;
    DWORD IntS3;
    DWORD IntS4;
    DWORD IntS5;
    DWORD IntS6;
    DWORD IntS7;
    DWORD IntT8;
    DWORD IntT9;
    DWORD IntK0;
    DWORD IntK1;
    DWORD IntGp;
    DWORD IntSp;
    DWORD IntS8;
    DWORD IntRa;
    DWORD IntLo;
    DWORD IntHi;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    DWORD Fsr;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    // N.B. The registers gp, sp, and ra are defined in the integer section,
    //   but are considered part of the control context rather than part of
    //   the integer context.
    //

    DWORD Fir;
    DWORD Psr;

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    DWORD Fill[2];
} CONTEXT, *PCONTEXT;

// end_ntddk end_nthal

#endif // MIPS


#if defined(_MIPS_)

VOID
__jump_unwind (
    PVOID Fp,
    PVOID TargetPc
    );

#endif // MIPS


#if defined(_PPC_)

// begin_ntddk begin_nthal
//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_CONTROL         0x00000001L
#define CONTEXT_FLOATING_POINT  0x00000002L
#define CONTEXT_INTEGER         0x00000004L
#define CONTEXT_DEBUG_REGISTERS 0x00000008L

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)

#endif

//
// Context Frame
//
//  N.B. This frame must be exactly a multiple of 16 bytes in length.
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, and 4) it is used in the user level thread creation
//  routines.
//
//  Requires at least 8-byte alignment (double)
//

typedef struct _CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    double Fpr0;                        // Floating registers 0..31
    double Fpr1;
    double Fpr2;
    double Fpr3;
    double Fpr4;
    double Fpr5;
    double Fpr6;
    double Fpr7;
    double Fpr8;
    double Fpr9;
    double Fpr10;
    double Fpr11;
    double Fpr12;
    double Fpr13;
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    double Fpscr;                       // Floating point status/control reg

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //

    DWORD Gpr0;                         // General registers 0..31
    DWORD Gpr1;
    DWORD Gpr2;
    DWORD Gpr3;
    DWORD Gpr4;
    DWORD Gpr5;
    DWORD Gpr6;
    DWORD Gpr7;
    DWORD Gpr8;
    DWORD Gpr9;
    DWORD Gpr10;
    DWORD Gpr11;
    DWORD Gpr12;
    DWORD Gpr13;
    DWORD Gpr14;
    DWORD Gpr15;
    DWORD Gpr16;
    DWORD Gpr17;
    DWORD Gpr18;
    DWORD Gpr19;
    DWORD Gpr20;
    DWORD Gpr21;
    DWORD Gpr22;
    DWORD Gpr23;
    DWORD Gpr24;
    DWORD Gpr25;
    DWORD Gpr26;
    DWORD Gpr27;
    DWORD Gpr28;
    DWORD Gpr29;
    DWORD Gpr30;
    DWORD Gpr31;

    DWORD Cr;                           // Condition register
    DWORD Xer;                          // Fixed point exception register

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    DWORD Msr;                          // Machine status register
    DWORD Iar;                          // Instruction address register
    DWORD Lr;                           // Link register
    DWORD Ctr;                          // Count register

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    DWORD Fill[3];                      // Pad out to multiple of 16 bytes

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //
    DWORD Dr0;                          // Breakpoint Register 1
    DWORD Dr1;                          // Breakpoint Register 2
    DWORD Dr2;                          // Breakpoint Register 3
    DWORD Dr3;                          // Breakpoint Register 4
    DWORD Dr4;                          // Breakpoint Register 5
    DWORD Dr5;                          // Breakpoint Register 6
    DWORD Dr6;                          // Debug Status Register
    DWORD Dr7;                          // Debug Control Register

} CONTEXT, *PCONTEXT;

// end_ntddk end_nthal


//
// Stack frame header
//
//   Order of appearance in stack frame:
//      Header (six words)
//      Parameters (at least eight words)
//      Local variables
//      Saved GPRs
//      Saved FPRs
//
//   Minimum alignment is 8 bytes

typedef struct _STACK_FRAME_HEADER {    // GPR 1 points here
    DWORD BackChain;                    // Addr of previous frame
    DWORD GlueSaved1;                   // Used by glue code
    DWORD GlueSaved2;
    DWORD Reserved1;                    // Reserved
    DWORD Spare1;                       // Used by tracing, profiling, ...
    DWORD Spare2;

    DWORD Parameter0;                   // First 8 parameter words are
    DWORD Parameter1;                   //   always present
    DWORD Parameter2;
    DWORD Parameter3;
    DWORD Parameter4;
    DWORD Parameter5;
    DWORD Parameter6;
    DWORD Parameter7;

} STACK_FRAME_HEADER,*PSTACK_FRAME_HEADER;

#endif // _PPC_


#if defined(_PPC_)

// **FINISH** This may need alteration for PowerPC

VOID
__jump_unwind (
    PVOID Fp,
    PVOID TargetPc
    );

#endif // _PPC_

#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    /*lint -e18 */  // Don't complain about different definitions
    DWORD    ExceptionCode;
    /*lint +e18 */  // Resume checking for different definitions
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
#define PROCESS_TERMINATE         (0x0001)  
#define PROCESS_CREATE_THREAD     (0x0002)  
#define PROCESS_VM_OPERATION      (0x0008)  
#define PROCESS_VM_READ           (0x0010)  
#define PROCESS_VM_WRITE          (0x0020)  
#define PROCESS_DUP_HANDLE        (0x0040)  
#define PROCESS_CREATE_PROCESS    (0x0080)  
#define PROCESS_SET_QUOTA         (0x0100)  
#define PROCESS_SET_INFORMATION   (0x0200)  
#define PROCESS_QUERY_INFORMATION (0x0400)  
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)

#define THREAD_TERMINATE               (0x0001)  
#define THREAD_SUSPEND_RESUME          (0x0002)  
#define THREAD_GET_CONTEXT             (0x0008)  
#define THREAD_SET_CONTEXT             (0x0010)  
#define THREAD_SET_INFORMATION         (0x0020)  
#define THREAD_QUERY_INFORMATION       (0x0040)  
#define THREAD_SET_THREAD_TOKEN        (0x0080)
#define THREAD_IMPERSONATE             (0x0100)
#define THREAD_DIRECT_IMPERSONATION    (0x0200)
// begin_ntddk

#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)

// end_ntddk
#define TLS_MINIMUM_AVAILABLE 64    
#define THREAD_BASE_PRIORITY_LOWRT  15  // value that gets a thread to LowRealtime-1
#define THREAD_BASE_PRIORITY_MAX    2   // maximum thread base priority boost
#define THREAD_BASE_PRIORITY_MIN    -2  // minimum thread base priority boost
#define THREAD_BASE_PRIORITY_IDLE   -15 // value that gets a thread to idle

typedef struct _QUOTA_LIMITS {
    DWORD PagedPoolLimit;
    DWORD NonPagedPoolLimit;
    DWORD MinimumWorkingSetSize;
    DWORD MaximumWorkingSetSize;
    DWORD PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS;
typedef QUOTA_LIMITS *PQUOTA_LIMITS;

#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 
#define MUTANT_QUERY_STATE      0x0001

#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
                          MUTANT_QUERY_STATE)
#define SEMAPHORE_MODIFY_STATE      0x0002  
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 
#define TIME_ZONE_ID_UNKNOWN  0
#define TIME_ZONE_ID_STANDARD 1
#define TIME_ZONE_ID_DAYLIGHT 2

#define PROCESSOR_INTEL_386     386
#define PROCESSOR_INTEL_486     486
#define PROCESSOR_INTEL_PENTIUM 586
#define PROCESSOR_MIPS_R4000    4000
#define PROCESSOR_ALPHA_21064   21064

#define PROCESSOR_ARCHITECTURE_INTEL 0
#define PROCESSOR_ARCHITECTURE_MIPS  1
#define PROCESSOR_ARCHITECTURE_ALPHA 2
#define PROCESSOR_ARCHITECTURE_PPC   3
#define PROCESSOR_ARCHITECTURE_UNKNOWN 0xFFFF

typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
#define SECTION_QUERY       0x0001
#define SECTION_MAP_WRITE   0x0002
#define SECTION_MAP_READ    0x0004
#define SECTION_MAP_EXECUTE 0x0008
#define SECTION_EXTEND_SIZE 0x0010

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
                            SECTION_MAP_WRITE |      \
                            SECTION_MAP_READ |       \
                            SECTION_MAP_EXECUTE |    \
                            SECTION_EXTEND_SIZE)
#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_TOP_DOWN       0x100000     
#define SEC_FILE           0x800000     
#define SEC_IMAGE         0x1000000     
#define SEC_RESERVE       0x4000000     
#define SEC_COMMIT        0x8000000     
#define SEC_NOCACHE      0x10000000     
#define MEM_IMAGE         SEC_IMAGE     

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe

#define FILE_READ_EA              ( 0x0008 )    // file & directory
#define FILE_READ_PROPERTIES      FILE_READ_EA

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory
#define FILE_WRITE_PROPERTIES     FILE_WRITE_EA

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)

#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_ATTRIBUTE_READONLY         0x00000001  
#define FILE_ATTRIBUTE_HIDDEN           0x00000002  
#define FILE_ATTRIBUTE_SYSTEM           0x00000004  
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010  
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020  
#define FILE_ATTRIBUTE_NORMAL           0x00000080  
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100  
#define FILE_ATTRIBUTE_COMPRESSED       0x00000800  
#define FILE_NOTIFY_CHANGE_FILE_NAME    0x00000001   
#define FILE_NOTIFY_CHANGE_DIR_NAME     0x00000002   
#define FILE_NOTIFY_CHANGE_ATTRIBUTES   0x00000004   
#define FILE_NOTIFY_CHANGE_SIZE         0x00000008   
#define FILE_NOTIFY_CHANGE_LAST_WRITE   0x00000010   
#define FILE_NOTIFY_CHANGE_SECURITY     0x00000100   
#define MAILSLOT_NO_MESSAGE             ((DWORD)-1) 
#define MAILSLOT_WAIT_FOREVER           ((DWORD)-1) 
#define FILE_CASE_SENSITIVE_SEARCH      0x00000001  
#define FILE_CASE_PRESERVED_NAMES       0x00000002  
#define FILE_UNICODE_ON_DISK            0x00000004  
#define FILE_PERSISTENT_ACLS            0x00000008  
#define FILE_FILE_COMPRESSION           0x00000010  
#define FILE_VOLUME_IS_COMPRESSED       0x00008000  
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 
#define DUPLICATE_CLOSE_SOURCE      0x00000001  
#define DUPLICATE_SAME_ACCESS       0x00000002  
typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_ntddk begin_nthal begin_ntifs
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_ntddk begin_nthal begin_ntifs
//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#include <pshpack4.h>

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#include <poppack.h>


////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs

typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;


typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
#ifdef MIDL_PASS
   [size_is(SubAuthorityCount)] DWORD SubAuthority[*];
#else // MIDL_PASS
   DWORD SubAuthority[ANYSIZE_ARRAY];
#endif // MIDL_PASS
} SID, *PISID;


#define SID_REVISION                     (1)    // Current revision level
#define SID_MAX_SUB_AUTHORITIES          (15)
#define SID_RECOMMENDED_SUB_AUTHORITIES  (1)    // Will change to around 6
                                                // in a future release.

typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown
} SID_NAME_USE, *PSID_NAME_USE;

// end_ntifs

typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID              S-1-0-0                                       //
//     World                 S-1-1-0                                       //
//     Local                 S-1-2-0                                       //
//     Creator Owner ID      S-1-3-0                                       //
//     Creator Group ID      S-1-3-1                                       //
//                                                                         //
//     (Non-unique IDs)      S-1-4                                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define SECURITY_NULL_SID_AUTHORITY     {0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY    {0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY    {0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY  {0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY   {0,0,0,0,0,4}

#define SECURITY_NULL_RID               (0x00000000L)
#define SECURITY_WORLD_RID              (0x00000000L)
#define SECURITY_LOCAL_RID              (0X00000000L)

#define SECURITY_CREATOR_OWNER_RID      (0x00000000L)
#define SECURITY_CREATOR_GROUP_RID      (0x00000001L)




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// NT well-known SIDs                                                      //
//                                                                         //
//     NT Authority          S-1-5                                         //
//     Dialup                S-1-5-1                                       //
//                                                                         //
//     Network               S-1-5-2                                       //
//     Batch                 S-1-5-3                                       //
//     Interactive           S-1-5-4                                       //
//     Service               S-1-5-6                                       //
//     AnonymousLogon        S-1-5-7       (aka null logon session)        //
//                                                                         //
//     (Logon IDs)           S-1-5-5-X-Y                                   //
//                                                                         //
//     (NT non-unique IDs)   S-1-5-0x15-...                                //
//                                                                         //
//     (Built-in domain)     s-1-5-0x20                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#define SECURITY_NT_AUTHORITY           {0,0,0,0,0,5}   // ntifs

#define SECURITY_DIALUP_RID             (0x00000001L)
#define SECURITY_NETWORK_RID            (0x00000002L)
#define SECURITY_BATCH_RID              (0x00000003L)
#define SECURITY_INTERACTIVE_RID        (0x00000004L)
#define SECURITY_SERVICE_RID            (0x00000006L)
#define SECURITY_ANONYMOUS_LOGON_RID    (0x00000007L)

#define SECURITY_LOGON_IDS_RID          (0x00000005L)
#define SECURITY_LOGON_IDS_RID_COUNT    (3L)

#define SECURITY_LOCAL_SYSTEM_RID       (0x00000012L)

#define SECURITY_NT_NON_UNIQUE          (0x00000015L)

#define SECURITY_BUILTIN_DOMAIN_RID     (0x00000020L)





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// Well-known users ...

#define DOMAIN_USER_RID_ADMIN          (0x000001F4L)
#define DOMAIN_USER_RID_GUEST          (0x000001F5L)



// well-known groups ...

#define DOMAIN_GROUP_RID_ADMINS        (0x00000200L)
#define DOMAIN_GROUP_RID_USERS         (0x00000201L)
#define DOMAIN_GROUP_RID_GUESTS        (0x00000202L)




// well-known aliases ...

#define DOMAIN_ALIAS_RID_ADMINS        (0x00000220L)
#define DOMAIN_ALIAS_RID_USERS         (0x00000221L)
#define DOMAIN_ALIAS_RID_GUESTS        (0x00000222L)
#define DOMAIN_ALIAS_RID_POWER_USERS   (0x00000223L)

#define DOMAIN_ALIAS_RID_ACCOUNT_OPS   (0x00000224L)
#define DOMAIN_ALIAS_RID_SYSTEM_OPS    (0x00000225L)
#define DOMAIN_ALIAS_RID_PRINT_OPS     (0x00000226L)
#define DOMAIN_ALIAS_RID_BACKUP_OPS    (0x00000227L)

#define DOMAIN_ALIAS_RID_REPLICATOR    (0x00000228L)






//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3E7 = 999)
//

#define SYSTEM_LUID                     { 0x3E7, 0x0 }

// end_ntifs

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Group attributes
//

#define SE_GROUP_MANDATORY              (0x00000001L)
#define SE_GROUP_ENABLED_BY_DEFAULT     (0x00000002L)
#define SE_GROUP_ENABLED                (0x00000004L)
#define SE_GROUP_OWNER                  (0x00000008L)
#define SE_GROUP_LOGON_ID               (0xC0000000L)



//
// User attributes
//

// (None yet defined.)




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_ntddk begin_ntifs
// This is the *current* ACL revision

#define ACL_REVISION     (2)

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

#define ACL_REVISION1   (1)
#define ACL_REVISION2   (2)

typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;

// end_ntddk

//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//

#define ACCESS_ALLOWED_ACE_TYPE          (0x0)
#define ACCESS_DENIED_ACE_TYPE           (0x1)
#define SYSTEM_AUDIT_ACE_TYPE            (0x2)
#define SYSTEM_ALARM_ACE_TYPE            (0x3)

//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//

#define OBJECT_INHERIT_ACE                (0x1)
#define CONTAINER_INHERIT_ACE             (0x2)
#define NO_PROPAGATE_INHERIT_ACE          (0x4)
#define INHERIT_ONLY_ACE                  (0x8)
#define VALID_INHERIT_FLAGS               (0xF)


//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//

#define SUCCESSFUL_ACCESS_ACE_FLAG       (0x40)
#define FAILED_ACCESS_ACE_FLAG           (0x80)


//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

// end_ntifs


//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;

//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//

typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;

//
//  This record is returned if the user is requesting AclSizeInformation
//

typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_ntddk begin_ntifs
//
// Current security descriptor revision value
//

#define SECURITY_DESCRIPTOR_REVISION     (1)
#define SECURITY_DESCRIPTOR_REVISION1    (1)

// end_ntddk

//
// Minimum length, in bytes, needed to build a security descriptor
// (NOTE: This must manually be kept consistent with the)
// (sizeof(SECURITY_DESCRIPTOR)                         )
//

#define SECURITY_DESCRIPTOR_MIN_LENGTH   (20)


typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

#define SE_OWNER_DEFAULTED               (0x0001)
#define SE_GROUP_DEFAULTED               (0x0002)
#define SE_DACL_PRESENT                  (0x0004)
#define SE_DACL_DEFAULTED                (0x0008)
#define SE_SACL_PRESENT                  (0x0010)
#define SE_SACL_DEFAULTED                (0x0020)
#define SE_SELF_RELATIVE                 (0x8000)

//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;
   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

// end_ntifs

// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//



////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_ntddk begin_nthal begin_ntifs
//
// Privilege attributes
//

#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED            (0x00000002L)
#define SE_PRIVILEGE_USED_FOR_ACCESS    (0x80000000L)

//
// Privilege Set Control flags
//

#define PRIVILEGE_SET_ALL_NECESSARY    (1)

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")


////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_ntddk begin_nthal begin_ntifs
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation

#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation

// end_nthal
//
// Security Tracking Mode
//

#define SECURITY_DYNAMIC_TRACKING      (TRUE)
#define SECURITY_STATIC_TRACKING       (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//

#define TOKEN_ASSIGN_PRIMARY    (0x0001)
#define TOKEN_DUPLICATE         (0x0002)
#define TOKEN_IMPERSONATE       (0x0004)
#define TOKEN_QUERY             (0x0008)
#define TOKEN_QUERY_SOURCE      (0x0010)
#define TOKEN_ADJUST_PRIVILEGES (0x0020)
#define TOKEN_ADJUST_GROUPS     (0x0040)
#define TOKEN_ADJUST_DEFAULT    (0x0080)

#define TOKEN_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED  |\
                          TOKEN_ASSIGN_PRIMARY      |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)


#define TOKEN_READ       (STANDARD_RIGHTS_READ      |\
                          TOKEN_QUERY)


#define TOKEN_WRITE      (STANDARD_RIGHTS_WRITE     |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)

#define TOKEN_EXECUTE    (STANDARD_RIGHTS_EXECUTE)


// begin_ntifs
//
// Token Types
//

typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;

// end_ntifs

//
// Token Information Classes.
//


typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//


typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;


typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;


// begin_ntifs

#define TOKEN_SOURCE_LENGTH 8

typedef struct _TOKEN_SOURCE {
    CHAR SourceName[TOKEN_SOURCE_LENGTH];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;

// end_ntifs

typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;


// begin_ntifs

typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
    } TOKEN_CONTROL, *PTOKEN_CONTROL;


typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION       (0X00000001L)
#define GROUP_SECURITY_INFORMATION       (0X00000002L)
#define DACL_SECURITY_INFORMATION        (0X00000004L)
#define SACL_SECURITY_INFORMATION        (0X00000008L)


//
// Image Format
//

#include "pshpack1.h"

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_VXD_SIGNATURE                 0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      // Windows VXD header
    WORD   e32_magic;                   // Magic number
    BYTE   e32_border;                  // The byte ordering for the VXD
    BYTE   e32_worder;                  // The word ordering for the VXD
    DWORD  e32_level;                   // The EXE format level for now = 0
    WORD   e32_cpu;                     // The CPU type
    WORD   e32_os;                      // The OS type
    DWORD  e32_ver;                     // Module version
    DWORD  e32_mflags;                  // Module flags
    DWORD  e32_mpages;                  // Module # pages
    DWORD  e32_startobj;                // Object # for instruction pointer
    DWORD  e32_eip;                     // Extended instruction pointer
    DWORD  e32_stackobj;                // Object # for stack pointer
    DWORD  e32_esp;                     // Extended stack pointer
    DWORD  e32_pagesize;                // VXD page size
    DWORD  e32_lastpagesize;            // Last page size in VXD
    DWORD  e32_fixupsize;               // Fixup section size
    DWORD  e32_fixupsum;                // Fixup section checksum
    DWORD  e32_ldrsize;                 // Loader section size
    DWORD  e32_ldrsum;                  // Loader section checksum
    DWORD  e32_objtab;                  // Object table offset
    DWORD  e32_objcnt;                  // Number of objects in module
    DWORD  e32_objmap;                  // Object page map offset
    DWORD  e32_itermap;                 // Object iterated data map offset
    DWORD  e32_rsrctab;                 // Offset of Resource Table
    DWORD  e32_rsrccnt;                 // Number of resource entries
    DWORD  e32_restab;                  // Offset of resident name table
    DWORD  e32_enttab;                  // Offset of Entry Table
    DWORD  e32_dirtab;                  // Offset of Module Directive Table
    DWORD  e32_dircnt;                  // Number of module directives
    DWORD  e32_fpagetab;                // Offset of Fixup Page Table
    DWORD  e32_frectab;                 // Offset of Fixup Record Table
    DWORD  e32_impmod;                  // Offset of Import Module Name Table
    DWORD  e32_impmodcnt;               // Number of entries in Import Module Name Table
    DWORD  e32_impproc;                 // Offset of Import Procedure Name Table
    DWORD  e32_pagesum;                 // Offset of Per-Page Checksum Table
    DWORD  e32_datapage;                // Offset of Enumerated Data Pages
    DWORD  e32_preload;                 // Number of preload pages
    DWORD  e32_nrestab;                 // Offset of Non-resident Names Table
    DWORD  e32_cbnrestab;               // Size of Non-resident Name Table
    DWORD  e32_nressum;                 // Non-resident Name Table Checksum
    DWORD  e32_autodata;                // Object # for automatic data object
    DWORD  e32_debuginfo;               // Offset of the debugging information
    DWORD  e32_debuglen;                // The length of the debugging info. in bytes
    DWORD  e32_instpreload;             // Number of instance pages in preload section of VXD file
    DWORD  e32_instdemand;              // Number of instance pages in demand load section of VXD file
    DWORD  e32_heapsize;                // Size of heap - for 16-bit apps
    BYTE   e32_res3[12];                // Reserved words
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   // Device ID for VxD
    WORD   e32_ddkver;                  // DDK version for VxD
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0x160 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
#define IMAGE_FILE_MACHINE_R10000            0x168   // MIPS little-endian
#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Reserved1;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((DWORD)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.


// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT           12   // Import Address Table

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

//
// Section characteristics.
//

//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
//                                           0x00002000  // Reserved.

//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
#define IMAGE_SCN_MEM_FARDATA                0x00008000
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_MEM_LOCKED                 0x00040000
#define IMAGE_SCN_MEM_PRELOAD                0x00080000

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
// Unused                                    0x00800000

#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     // if 0, use LongName
            DWORD   Long;      // offset into string table
        } Name;
        PBYTE   LongName[2];
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;

#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (SHORT)0          // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (SHORT)-1         // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (SHORT)-2         // Symbol is a special debug item.

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                 0x0000  // no type.
#define IMAGE_SYM_TYPE_VOID                 0x0001  //
#define IMAGE_SYM_TYPE_CHAR                 0x0002  // type character.
#define IMAGE_SYM_TYPE_SHORT                0x0003  // type short integer.
#define IMAGE_SYM_TYPE_INT                  0x0004  //
#define IMAGE_SYM_TYPE_LONG                 0x0005  //
#define IMAGE_SYM_TYPE_FLOAT                0x0006  //
#define IMAGE_SYM_TYPE_DOUBLE               0x0007  //
#define IMAGE_SYM_TYPE_STRUCT               0x0008  //
#define IMAGE_SYM_TYPE_UNION                0x0009  //
#define IMAGE_SYM_TYPE_ENUM                 0x000A  // enumeration.
#define IMAGE_SYM_TYPE_MOE                  0x000B  // member of enumeration.
#define IMAGE_SYM_TYPE_BYTE                 0x000C  //
#define IMAGE_SYM_TYPE_WORD                 0x000D  //
#define IMAGE_SYM_TYPE_UINT                 0x000E  //
#define IMAGE_SYM_TYPE_DWORD                0x000F  //
#define IMAGE_SYM_TYPE_PCODE                0x8000  //

//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                0       // no derived type.
#define IMAGE_SYM_DTYPE_POINTER             1       // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION            2       // function.
#define IMAGE_SYM_DTYPE_ARRAY               3       // array.

//
// Storage classes.
//

#define IMAGE_SYM_CLASS_END_OF_FUNCTION     (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                0x0000
#define IMAGE_SYM_CLASS_AUTOMATIC           0x0001
#define IMAGE_SYM_CLASS_EXTERNAL            0x0002
#define IMAGE_SYM_CLASS_STATIC              0x0003
#define IMAGE_SYM_CLASS_REGISTER            0x0004
#define IMAGE_SYM_CLASS_EXTERNAL_DEF        0x0005
#define IMAGE_SYM_CLASS_LABEL               0x0006
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL     0x0007
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    0x0008
#define IMAGE_SYM_CLASS_ARGUMENT            0x0009
#define IMAGE_SYM_CLASS_STRUCT_TAG          0x000A
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION     0x000B
#define IMAGE_SYM_CLASS_UNION_TAG           0x000C
#define IMAGE_SYM_CLASS_TYPE_DEFINITION     0x000D
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC    0x000E
#define IMAGE_SYM_CLASS_ENUM_TAG            0x000F
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM      0x0010
#define IMAGE_SYM_CLASS_REGISTER_PARAM      0x0011
#define IMAGE_SYM_CLASS_BIT_FIELD           0x0012

#define IMAGE_SYM_CLASS_FAR_EXTERNAL        0x0044  //

#define IMAGE_SYM_CLASS_BLOCK               0x0064
#define IMAGE_SYM_CLASS_FUNCTION            0x0065
#define IMAGE_SYM_CLASS_END_OF_STRUCT       0x0066
#define IMAGE_SYM_CLASS_FILE                0x0067
// new
#define IMAGE_SYM_CLASS_SECTION             0x0068
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL       0x0069

// type packing constants

#define N_BTMASK                            0x000F
#define N_TMASK                             0x0030
#define N_TMASK1                            0x00C0
#define N_TMASK2                            0x00F0
#define N_BTSHFT                            4
#define N_TSHIFT                            2

// MACROS

// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
#ifndef ISPTR
#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif

// Is x a function?
#ifndef ISFCN
#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif

// Is x an array?

#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif

// Is x a structure, union, or enumeration TAG?
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif

#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      // struct, union, or enum tag index
        union {
            struct {
                WORD    Linenumber;             // declaration line number
                WORD    Size;                   // size of struct, union, or enum
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen.
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        // tv index
    } Sym;
    struct {
        BYTE    Name[IMAGE_SIZEOF_SYMBOL];
    } File;
    struct {
        DWORD   Length;                         // section length
        WORD    NumberOfRelocations;            // number of relocation entries
        WORD    NumberOfLinenumbers;            // number of line numbers
        DWORD   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        BYTE    Selection;                      // communal selection type
    } Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;

#define IMAGE_SIZEOF_AUX_SYMBOL             18

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES    1
#define IMAGE_COMDAT_SELECT_ANY             2
#define IMAGE_COMDAT_SELECT_SAME_SIZE       3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH     4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE     5
#define IMAGE_COMDAT_SELECT_LARGEST         6
#define IMAGE_COMDAT_SELECT_NEWEST          7

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3

//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    };
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION         10

//
// I386 relocation types.
//

#define IMAGE_REL_I386_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16            0x0001  // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16            0x0002  // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32            0x0006  // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB          0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12            0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION          0x000A
#define IMAGE_REL_I386_SECREL           0x000B
#define IMAGE_REL_I386_REL32            0x0014  // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

#define IMAGE_REL_MIPS_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF          0x0001
#define IMAGE_REL_MIPS_REFWORD          0x0002
#define IMAGE_REL_MIPS_JMPADDR          0x0003
#define IMAGE_REL_MIPS_REFHI            0x0004
#define IMAGE_REL_MIPS_REFLO            0x0005
#define IMAGE_REL_MIPS_GPREL            0x0006
#define IMAGE_REL_MIPS_LITERAL          0x0007
#define IMAGE_REL_MIPS_SECTION          0x000A
#define IMAGE_REL_MIPS_SECREL           0x000B
#define IMAGE_REL_MIPS_SECRELLO         0x000C  // Low 16-bit section relative referemce (used for >32k TLS)
#define IMAGE_REL_MIPS_SECRELHI         0x000D  // High 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_MIPS_REFWORDNB        0x0022
#define IMAGE_REL_MIPS_PAIR             0x0025

//
// Alpha Relocation types.
//

#define IMAGE_REL_ALPHA_ABSOLUTE        0x0000
#define IMAGE_REL_ALPHA_REFLONG         0x0001
#define IMAGE_REL_ALPHA_REFQUAD         0x0002
#define IMAGE_REL_ALPHA_GPREL32         0x0003
#define IMAGE_REL_ALPHA_LITERAL         0x0004
#define IMAGE_REL_ALPHA_LITUSE          0x0005
#define IMAGE_REL_ALPHA_GPDISP          0x0006
#define IMAGE_REL_ALPHA_BRADDR          0x0007
#define IMAGE_REL_ALPHA_HINT            0x0008
#define IMAGE_REL_ALPHA_INLINE_REFLONG  0x0009
#define IMAGE_REL_ALPHA_REFHI           0x000A
#define IMAGE_REL_ALPHA_REFLO           0x000B
#define IMAGE_REL_ALPHA_PAIR            0x000C
#define IMAGE_REL_ALPHA_MATCH           0x000D
#define IMAGE_REL_ALPHA_SECTION         0x000E
#define IMAGE_REL_ALPHA_SECREL          0x000F
#define IMAGE_REL_ALPHA_REFLONGNB       0x0010
#define IMAGE_REL_ALPHA_SECRELLO        0x0011  // Low 16-bit section relative reference
#define IMAGE_REL_ALPHA_SECRELHI        0x0012  // High 16-bit section relative reference

//
// IBM PowerPC relocation types.
//

#define IMAGE_REL_PPC_ABSOLUTE          0x0000  // NOP
#define IMAGE_REL_PPC_ADDR64            0x0001  // 64-bit address
#define IMAGE_REL_PPC_ADDR32            0x0002  // 32-bit address
#define IMAGE_REL_PPC_ADDR24            0x0003  // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_PPC_ADDR16            0x0004  // 16-bit address
#define IMAGE_REL_PPC_ADDR14            0x0005  // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_PPC_REL24             0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_PPC_REL14             0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_PPC_TOCREL16          0x0008  // 16-bit offset from TOC base
#define IMAGE_REL_PPC_TOCREL14          0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

#define IMAGE_REL_PPC_ADDR32NB          0x000A  // 32-bit addr w/o image base
#define IMAGE_REL_PPC_SECREL            0x000B  // va of containing section (as in an image sectionhdr)
#define IMAGE_REL_PPC_SECTION           0x000C  // sectionheader number
#define IMAGE_REL_PPC_IFGLUE            0x000D  // substitute TOC restore instruction iff symbol is glue code
#define IMAGE_REL_PPC_IMGLUE            0x000E  // symbol is glue code; virtual address is TOC restore instruction
#define IMAGE_REL_PPC_SECREL16          0x000F  // va of containing section (limited to 16 bits)
#define IMAGE_REL_PPC_REFHI             0x0010
#define IMAGE_REL_PPC_REFLO             0x0011
#define IMAGE_REL_PPC_PAIR              0x0012

#define IMAGE_REL_PPC_TYPEMASK          0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG               0x0100  // subtract reloc value rather than adding it
#define IMAGE_REL_PPC_BRTAKEN           0x0200  // fix branch prediction bit to predict branch taken
#define IMAGE_REL_PPC_BRNTAKEN          0x0400  // fix branch prediction bit to predict branch not taken
#define IMAGE_REL_PPC_TOCDEFN           0x0800  // toc slot defined in file (or, data in toc)

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        DWORD   VirtualAddress;                 // Virtual address of line number.
    } Type;
    WORD    Linenumber;                         // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          // File member name - `/' terminated.
    BYTE     Date[12];                          // File member date - decimal.
    BYTE     UserID[6];                         // File member user id - decimal.
    BYTE     GroupID[6];                        // File member group id - decimal.
    BYTE     Mode[8];                           // File member mode - octal.
    BYTE     Size[10];                          // File member size - decimal.
    BYTE     EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    PDWORD  *AddressOfFunctions;
    PDWORD  *AddressOfNames;
    PWORD   *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        PBYTE  ForwarderString;
        PDWORD Function;
        DWORD Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;                // 0 for terminating null import descriptor
        PIMAGE_THUNK_DATA OriginalFirstThunk;   // RVA to original unbound IAT
    };
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    PIMAGE_THUNK_DATA FirstThunk;           // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;


//
// Thread Local Storage
//

typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    PDWORD  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} IMAGE_TLS_DIRECTORY, *PIMAGE_TLS_DIRECTORY;


//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000

//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        };
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    PVOID   LockPrefixTable;
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   Reserved[ 4 ];
} IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY;


//
// Function table entry format for MIPS/ALPHA images.  Function table is
// pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
// This definition duplicates ones in ntmips.h and ntalpha.h for use
// by portable image file mungers.
//

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    PVOID ExceptionHandler;
    PVOID HandlerData;
    DWORD PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_RUNTIME_FUNCTION_ENTRY;

//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

#define IMAGE_DEBUG_TYPE_UNKNOWN          0
#define IMAGE_DEBUG_TYPE_COFF             1
#define IMAGE_DEBUG_TYPE_CODEVIEW         2
#define IMAGE_DEBUG_TYPE_FPO              3
#define IMAGE_DEBUG_TYPE_MISC             4
#define IMAGE_DEBUG_TYPE_EXCEPTION        5
#define IMAGE_DEBUG_TYPE_FIXUP            6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8

typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

#define FRAME_FPO       0
#define FRAME_TRAP      1
#define FRAME_TSS       2
#define FRAME_NONFPO    3

typedef struct _FPO_DATA {
    DWORD       ulOffStart;             // offset 1st byte of function code
    DWORD       cbProcSize;             // # bytes in function
    DWORD       cdwLocals;              // # bytes in locals/4
    WORD        cdwParams;              // # bytes in params/4
    WORD        cbProlog : 8;           // # bytes in prolog
    WORD        cbRegs   : 3;           // # regs saved
    WORD        fHasSEH  : 1;           // TRUE if SEH in func
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated
    WORD        reserved : 1;           // reserved for future use
    WORD        cbFrame  : 2;           // frame type
} FPO_DATA, *PFPO_DATA;
#define SIZEOF_RFPO_DATA 16


#define IMAGE_DEBUG_MISC_EXENAME    1

typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               // type of misc data, see defines
    DWORD       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       Reserved[ 3 ];          // Note: reserved[0] is actually the section alignment
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944

#include "poppack.h"

//
// End Image Format
//

//
// for move macros
//
#include <string.h>
#define HEAP_NO_SERIALIZE               0x00000001      
#define HEAP_GROWABLE                   0x00000002      
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      
#define HEAP_ZERO_MEMORY                0x00000008      
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      
#define HEAP_CREATE_ALIGN_16            0x00010000      
#define HEAP_CREATE_ENABLE_TRACING      0x00020000      
#define HEAP_MAXIMUM_TAG                0x0FFF              
#define HEAP_PSEUDO_TAG_FLAG            0x8000              
#define HEAP_TAG_SHIFT                  16                  
#define HEAP_MAKE_TAG_FLAGS( b, o ) ((DWORD)((b) + ((o) << 16)))  

#define IS_TEXT_UNICODE_ASCII16               0x0001
#define IS_TEXT_UNICODE_REVERSE_ASCII16       0x0010

#define IS_TEXT_UNICODE_STATISTICS            0x0002
#define IS_TEXT_UNICODE_REVERSE_STATISTICS    0x0020

#define IS_TEXT_UNICODE_CONTROLS              0x0004
#define IS_TEXT_UNICODE_REVERSE_CONTROLS      0x0040

#define IS_TEXT_UNICODE_SIGNATURE             0x0008
#define IS_TEXT_UNICODE_REVERSE_SIGNATURE     0x0080

#define IS_TEXT_UNICODE_ILLEGAL_CHARS         0x0100
#define IS_TEXT_UNICODE_ODD_LENGTH            0x0200
#define IS_TEXT_UNICODE_DBCS_LEADBYTE         0x0400
#define IS_TEXT_UNICODE_NULL_BYTES            0x1000

#define IS_TEXT_UNICODE_UNICODE_MASK          0x000F
#define IS_TEXT_UNICODE_REVERSE_MASK          0x00F0
#define IS_TEXT_UNICODE_NOT_UNICODE_MASK      0x0F00
#define IS_TEXT_UNICODE_NOT_ASCII_MASK        0xF000

#define COMPRESSION_FORMAT_NONE          (0x0000)   
#define COMPRESSION_FORMAT_DEFAULT       (0x0001)   
#define COMPRESSION_FORMAT_LZNT1         (0x0002)   
#define COMPRESSION_ENGINE_STANDARD      (0x0000)   
#define COMPRESSION_ENGINE_MAXIMUM       (0x0100)   
#if defined(_M_IX86) || defined(_M_MRX000) || defined(_M_ALPHA)
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))
#else

NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   DWORD Length
   );

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   DWORD Length
   );

NTSYSAPI
VOID
NTAPI
RtlFillMemory (
   VOID UNALIGNED *Destination,
   DWORD Length,
   BYTE  Fill
   );

NTSYSAPI
VOID
NTAPI
RtlZeroMemory (
   VOID UNALIGNED *Destination,
   DWORD Length
   );
#endif

typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

#define MESSAGE_RESOURCE_UNICODE 0x0001

typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Spare[ 2 ];
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG;

#define RTL_CRITSECT_TYPE 0
#define RTL_RESOURCE_TYPE 1

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    DWORD Reserved;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
#define DLL_PROCESS_ATTACH 1    
#define DLL_THREAD_ATTACH  2    
#define DLL_THREAD_DETACH  3    
#define DLL_PROCESS_DETACH 0    

//
// Defines for the READ flags for Eventlogging
//
#define EVENTLOG_SEQUENTIAL_READ        0X0001
#define EVENTLOG_SEEK_READ              0X0002
#define EVENTLOG_FORWARDS_READ          0X0004
#define EVENTLOG_BACKWARDS_READ         0X0008

//
// The types of events that can be logged.
//
#define EVENTLOG_SUCCESS                0X0000
#define EVENTLOG_ERROR_TYPE             0x0001
#define EVENTLOG_WARNING_TYPE           0x0002
#define EVENTLOG_INFORMATION_TYPE       0x0004
#define EVENTLOG_AUDIT_SUCCESS          0x0008
#define EVENTLOG_AUDIT_FAILURE          0x0010

//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//

#define EVENTLOG_START_PAIRED_EVENT    0x0001
#define EVENTLOG_END_PAIRED_EVENT      0x0002
#define EVENTLOG_END_ALL_PAIRED_EVENTS 0x0004
#define EVENTLOG_PAIRED_EVENT_ACTIVE   0x0008
#define EVENTLOG_PAIRED_EVENT_INACTIVE 0x0010

//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//

typedef struct _EVENTLOGRECORD {
    DWORD  Length;        // Length of full record
    DWORD  Reserved;      // Used by the service
    DWORD  RecordNumber;  // Absolute record number
    DWORD  TimeGenerated; // Seconds since 1-1-1970
    DWORD  TimeWritten;   // Seconds since 1-1-1970
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; // For use with paired events (auditing)
    DWORD  ClosingRecordNumber; // For use with paired events (auditing)
    DWORD  StringOffset;  // Offset from beginning of record
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    // Offset from beginning of record
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} EVENTLOGRECORD, *PEVENTLOGRECORD;

#define DBG_CONTINUE                    ((DWORD   )0x00010002L) 
#define DBG_TERMINATE_THREAD            ((DWORD   )0x40010003L) 
#define DBG_TERMINATE_PROCESS           ((DWORD   )0x40010004L) 
#define DBG_CONTROL_C                   ((DWORD   )0x40010005L) 
#define DBG_CONTROL_BREAK               ((DWORD   )0x40010008L) 
#define DBG_EXCEPTION_NOT_HANDLED       ((DWORD   )0x80010001L) 
//

// begin_ntddk begin_nthal
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE)

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// Key restore flags
//

#define REG_WHOLE_HIVE_VOLATILE     (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE            (0x00000002L)   // Unwind changes to last flush

// end_ntddk end_nthal

//
// Notify filter values
//
#define REG_NOTIFY_CHANGE_NAME          (0x00000001L) // Create or delete (child)
#define REG_NOTIFY_CHANGE_ATTRIBUTES    (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET      (0x00000004L) // time stamp
#define REG_NOTIFY_CHANGE_SECURITY      (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER                 \
                (REG_NOTIFY_CHANGE_NAME          |\
                 REG_NOTIFY_CHANGE_ATTRIBUTES    |\
                 REG_NOTIFY_CHANGE_LAST_SET      |\
                 REG_NOTIFY_CHANGE_SECURITY)

//
//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )

// end_ntddk end_nthal

// begin_ntddk begin_nthal
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;


//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L

typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L

typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L

typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L

typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED            0x00000001
#define TAPE_DRIVE_SELECT           0x00000002
#define TAPE_DRIVE_INITIATOR        0x00000004

#define TAPE_DRIVE_ERASE_SHORT      0x00000010
#define TAPE_DRIVE_ERASE_LONG       0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY   0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE  0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY    0x00000100
#define TAPE_DRIVE_TAPE_REMAINING   0x00000200
#define TAPE_DRIVE_FIXED_BLOCK      0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK   0x00000800

#define TAPE_DRIVE_WRITE_PROTECT    0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE      0x00002000

#define TAPE_DRIVE_ECC              0x00010000
#define TAPE_DRIVE_COMPRESSION      0x00020000
#define TAPE_DRIVE_PADDING          0x00040000
#define TAPE_DRIVE_REPORT_SMKS      0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK  0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE  0x00400000

#define TAPE_DRIVE_RESERVED_BIT     0x80000000  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD      0x80000001
#define TAPE_DRIVE_TENSION          0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK      0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE   0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED  0x80000020
#define TAPE_DRIVE_TENSION_IMMED    0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED  0x80000080

#define TAPE_DRIVE_SET_ECC          0x80000100
#define TAPE_DRIVE_SET_COMPRESSION  0x80000200
#define TAPE_DRIVE_SET_PADDING      0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS  0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK     0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED    0x80002000
#define TAPE_DRIVE_LOGICAL_BLK      0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED    0x80008000

#define TAPE_DRIVE_END_OF_DATA      0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS    0x80020000
#define TAPE_DRIVE_FILEMARKS        0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS  0x80080000

#define TAPE_DRIVE_SETMARKS         0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS  0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE  0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS   0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS  0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS  0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT           0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES    0x80000000  //mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L

typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


#ifdef __cplusplus
}
#endif

#endif /* _WINNT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINNETWK.H ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    winnetwk.h

Abstract:

    Standard WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:

    optional-notes

--*/

#ifndef _WINNETWK_
#define _WINNETWK_


#ifdef __cplusplus
extern "C" {
#endif


//
// Network types
//

#define     WNNC_NET_MSNET      0x00010000
#define     WNNC_NET_LANMAN     0x00020000
#define     WNNC_NET_NETWARE    0x00030000
#define     WNNC_NET_VINES      0x00040000
#define     WNNC_NET_10NET      0x00050000
#define     WNNC_NET_LOCUS      0x00060000
#define     WNNC_NET_SUN_PC_NFS 0x00070000
#define     WNNC_NET_LANSTEP    0x00080000
#define     WNNC_NET_9TILES     0x00090000
#define     WNNC_NET_LANTASTIC  0x000A0000
#define     WNNC_NET_AS400      0x000B0000
#define     WNNC_NET_FTP_NFS    0x000C0000
#define     WNNC_NET_PATHWORKS  0x000D0000
#define     WNNC_NET_LIFENET    0x000E0000
#define     WNNC_NET_POWERLAN   0x000F0000
#define     WNNC_NET_BWNFS		0x00100000
#define     WNNC_NET_COGENT		0x00110000
#define     WNNC_NET_FARALLON	0x00120000
#define     WNNC_NET_APPLETALK	0x00130000


//
//  Network Resources.
//

#define RESOURCE_CONNECTED      0x00000001
#define RESOURCE_GLOBALNET      0x00000002
#define RESOURCE_REMEMBERED     0x00000003
#if(WINVER >= 0x0400)
#define RESOURCE_RECENT         0x00000004
#define RESOURCE_CONTEXT        0x00000005
#endif /* WINVER >= 0x0400 */

#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#if(WINVER >= 0x0400)
#define RESOURCETYPE_RESERVED   0x00000008
#endif /* WINVER >= 0x0400 */
#define RESOURCETYPE_UNKNOWN    0xFFFFFFFF

#define RESOURCEUSAGE_CONNECTABLE   0x00000001
#define RESOURCEUSAGE_CONTAINER     0x00000002
#if(WINVER >= 0x0400)
#define RESOURCEUSAGE_NOLOCALDEVICE 0x00000004
#define RESOURCEUSAGE_SIBLING       0x00000008
#define RESOURCEUSAGE_ALL           (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER)
#endif /* WINVER >= 0x0400 */
#define RESOURCEUSAGE_RESERVED      0x80000000

#define RESOURCEDISPLAYTYPE_GENERIC        0x00000000
#define RESOURCEDISPLAYTYPE_DOMAIN         0x00000001
#define RESOURCEDISPLAYTYPE_SERVER         0x00000002
#define RESOURCEDISPLAYTYPE_SHARE          0x00000003
#define RESOURCEDISPLAYTYPE_FILE           0x00000004
#define RESOURCEDISPLAYTYPE_GROUP          0x00000005
#if(WINVER >= 0x0400)
#define RESOURCEDISPLAYTYPE_NETWORK        0x00000006
#define RESOURCEDISPLAYTYPE_ROOT           0x00000007
#define RESOURCEDISPLAYTYPE_SHAREADMIN     0x00000008
#define RESOURCEDISPLAYTYPE_DIRECTORY      0x00000009
#endif /* WINVER >= 0x0400 */
#define RESOURCEDISPLAYTYPE_TREE           0x0000000A

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
#ifdef UNICODE
typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;
#else
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#endif // UNICODE


//
//  Network Connections.
// 

#define NETPROPERTY_PERSISTENT       1

#define CONNECT_UPDATE_PROFILE      0x00000001
#define CONNECT_UPDATE_RECENT       0x00000002
#define CONNECT_TEMPORARY           0x00000004
#define CONNECT_INTERACTIVE         0x00000008
#define CONNECT_PROMPT              0x00000010
#define CONNECT_NEED_DRIVE          0x00000020
#if(WINVER >= 0x0400)
#define CONNECT_REFCOUNT            0x00000040
#define CONNECT_REDIRECT            0x00000080
#define CONNECT_LOCALDRIVE          0x00000100
#define CONNECT_CURRENT_MEDIA       0x00000200
#endif /* WINVER >= 0x0400 */

DWORD APIENTRY
WNetAddConnectionA(
     LPCSTR   lpRemoteName,
     LPCSTR   lpPassword,
     LPCSTR   lpLocalName
    );
DWORD APIENTRY
WNetAddConnectionW(
     LPCWSTR   lpRemoteName,
     LPCWSTR   lpPassword,
     LPCWSTR   lpLocalName
    );
#ifdef UNICODE
#define WNetAddConnection  WNetAddConnectionW
#else
#define WNetAddConnection  WNetAddConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetAddConnection2A(
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection2W(
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection2  WNetAddConnection2W
#else
#define WNetAddConnection2  WNetAddConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetAddConnection3A(
     HWND           hwndOwner,
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection3W(
     HWND           hwndOwner,
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection3  WNetAddConnection3W
#else
#define WNetAddConnection3  WNetAddConnection3A
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection  WNetCancelConnectionW
#else
#define WNetCancelConnection  WNetCancelConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnection2A(
     LPCSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnection2W(
     LPCWSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection2  WNetCancelConnection2W
#else
#define WNetCancelConnection2  WNetCancelConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetGetConnectionA(
     LPCSTR lpLocalName,
     LPSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
DWORD APIENTRY
WNetGetConnectionW(
     LPCWSTR lpLocalName,
     LPWSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
#ifdef UNICODE
#define WNetGetConnection  WNetGetConnectionW
#else
#define WNetGetConnection  WNetGetConnectionA
#endif // !UNICODE


#if(WINVER >= 0x0400)
DWORD APIENTRY
WNetUseConnectionA(
    HWND            hwndOwner,
    LPNETRESOURCEA  lpNetResource,
    LPCSTR        lpUserID,
    LPCSTR        lpPassword,
    DWORD           dwFlags,
    LPSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
DWORD APIENTRY
WNetUseConnectionW(
    HWND            hwndOwner,
    LPNETRESOURCEW  lpNetResource,
    LPCWSTR        lpUserID,
    LPCWSTR        lpPassword,
    DWORD           dwFlags,
    LPWSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
#ifdef UNICODE
#define WNetUseConnection  WNetUseConnectionW
#else
#define WNetUseConnection  WNetUseConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetSetConnectionA(
    LPCSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
DWORD APIENTRY
WNetSetConnectionW(
    LPCWSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
#ifdef UNICODE
#define WNetSetConnection  WNetSetConnectionW
#else
#define WNetSetConnection  WNetSetConnectionA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */


//
//  Network Connection Dialogs.
// 

DWORD APIENTRY
WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD APIENTRY
WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    );

#if(WINVER >= 0x0400)
typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTA, FAR *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTW, FAR *LPCONNECTDLGSTRUCTW;
#ifdef UNICODE
typedef CONNECTDLGSTRUCTW CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTW LPCONNECTDLGSTRUCT;
#else
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
#endif // UNICODE

#define CONNDLG_RO_PATH     0x00000001 /* Resource path should be read-only    */
#define CONNDLG_CONN_POINT  0x00000002 /* Netware -style movable connection point enabled */
#define CONNDLG_USE_MRU     0x00000004 /* Use MRU combobox  */
#define CONNDLG_HIDE_BOX    0x00000008 /* Hide persistent connect checkbox  */

/*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 */
#define CONNDLG_PERSIST     0x00000010 /* Force persistent connection */
#define CONNDLG_NOT_PERSIST 0x00000020 /* Force connection NOT persistent */

DWORD APIENTRY
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
DWORD APIENTRY
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );
#ifdef UNICODE
#define WNetConnectionDialog1  WNetConnectionDialog1W
#else
#define WNetConnectionDialog1  WNetConnectionDialog1A
#endif // !UNICODE

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPSTR           lpLocalName;      /* local device name */
    LPSTR           lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTA, FAR *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPWSTR          lpLocalName;      /* local device name */
    LPWSTR          lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTW, FAR *LPDISCDLGSTRUCTW;
#ifdef UNICODE
typedef DISCDLGSTRUCTW DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTW LPDISCDLGSTRUCT;
#else
typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
#endif // UNICODE

#define DISC_UPDATE_PROFILE         0x00000001
#define DISC_NO_FORCE               0x00000040

DWORD APIENTRY
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct
    );
DWORD APIENTRY
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct
    );
#ifdef UNICODE
#define WNetDisconnectDialog1  WNetDisconnectDialog1W
#else
#define WNetDisconnectDialog1  WNetDisconnectDialog1A
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */


//
//  Network Browsing.
//

DWORD APIENTRY
WNetOpenEnumA(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEA lpNetResource,
     LPHANDLE       lphEnum
    );
DWORD APIENTRY
WNetOpenEnumW(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEW lpNetResource,
     LPHANDLE       lphEnum
    );
#ifdef UNICODE
#define WNetOpenEnum  WNetOpenEnumW
#else
#define WNetOpenEnum  WNetOpenEnumA
#endif // !UNICODE

DWORD APIENTRY
WNetEnumResourceA(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
DWORD APIENTRY
WNetEnumResourceW(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
#ifdef UNICODE
#define WNetEnumResource  WNetEnumResourceW
#else
#define WNetEnumResource  WNetEnumResourceA
#endif // !UNICODE

DWORD APIENTRY
WNetCloseEnum(
    HANDLE   hEnum
    );



//
//  Universal Naming.
//

#define UNIVERSAL_NAME_INFO_LEVEL   0x00000001
#define REMOTE_NAME_INFO_LEVEL      0x00000002

typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;
#ifdef UNICODE
typedef UNIVERSAL_NAME_INFOW UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOW LPUNIVERSAL_NAME_INFO;
#else
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
#endif // UNICODE

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;
#ifdef UNICODE
typedef REMOTE_NAME_INFOW REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOW LPREMOTE_NAME_INFO;
#else
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
#endif // UNICODE

DWORD APIENTRY
WNetGetUniversalNameA(
     LPCSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
DWORD APIENTRY
WNetGetUniversalNameW(
     LPCWSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
#ifdef UNICODE
#define WNetGetUniversalName  WNetGetUniversalNameW
#else
#define WNetGetUniversalName  WNetGetUniversalNameA
#endif // !UNICODE

//
//  Authentication and Logon/Logoff.
//

DWORD APIENTRY
WNetGetUserA(
     LPCSTR  lpName,
     LPSTR   lpUserName,
     LPDWORD   lpnLength
    );
DWORD APIENTRY
WNetGetUserW(
     LPCWSTR  lpName,
     LPWSTR   lpUserName,
     LPDWORD   lpnLength
    );
#ifdef UNICODE
#define WNetGetUser  WNetGetUserW
#else
#define WNetGetUser  WNetGetUserA
#endif // !UNICODE



//
// Other.
//

#if(WINVER >= 0x0400)
#define WNFMT_MULTILINE         0x01
#define WNFMT_ABBREVIATED       0x02
#define WNFMT_INENUM            0x10
#define WNFMT_CONNECTION        0x20
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)
DWORD APIENTRY
WNetGetProviderNameA(
    DWORD   dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize
    );
DWORD APIENTRY
WNetGetProviderNameW(
    DWORD   dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize
    );
#ifdef UNICODE
#define WNetGetProviderName  WNetGetProviderNameW
#else
#define WNetGetProviderName  WNetGetProviderNameA
#endif // !UNICODE

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    DWORD dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT, FAR *LPNETINFOSTRUCT;

#define NETINFO_DLL16       0x00000001  /* Provider running as 16 bit Winnet Driver */
#define NETINFO_DISKRED     0x00000004  /* Provider requires disk redirections to connect */
#define NETINFO_PRINTERRED  0x00000008  /* Provider requires printer redirections to connect */

DWORD APIENTRY
WNetGetNetworkInformationA(
    LPCSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
DWORD APIENTRY
WNetGetNetworkInformationW(
    LPCWSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
#ifdef UNICODE
#define WNetGetNetworkInformation  WNetGetNetworkInformationW
#else
#define WNetGetNetworkInformation  WNetGetNetworkInformationA
#endif // !UNICODE

//
//  User Profiles.
//

typedef UINT (FAR PASCAL *PFNGETPROFILEPATHA) (
    LPCSTR    pszUsername,
    LPSTR     pszBuffer,
    UINT        cbBuffer
    );
typedef UINT (FAR PASCAL *PFNGETPROFILEPATHW) (
    LPCWSTR    pszUsername,
    LPWSTR     pszBuffer,
    UINT        cbBuffer
    );
#ifdef UNICODE
#define PFNGETPROFILEPATH  PFNGETPROFILEPATHW
#else
#define PFNGETPROFILEPATH  PFNGETPROFILEPATHA
#endif // !UNICODE

typedef UINT (FAR PASCAL *PFNRECONCILEPROFILEA) (
    LPCSTR    pszCentralFile,
    LPCSTR    pszLocalFile,
    DWORD       dwFlags
    );
typedef UINT (FAR PASCAL *PFNRECONCILEPROFILEW) (
    LPCWSTR    pszCentralFile,
    LPCWSTR    pszLocalFile,
    DWORD       dwFlags
    );
#ifdef UNICODE
#define PFNRECONCILEPROFILE  PFNRECONCILEPROFILEW
#else
#define PFNRECONCILEPROFILE  PFNRECONCILEPROFILEA
#endif // !UNICODE

#define RP_LOGON    0x01        /* if set, do for logon, else for logoff */
#define RP_INIFILE  0x02        /* if set, reconcile .INI file, else reg. hive */


//
//  Policies.
//

typedef BOOL (FAR PASCAL *PFNPROCESSPOLICIESA) (
    HWND        hwnd,
    LPCSTR    pszPath,
    LPCSTR    pszUsername,
    LPCSTR    pszComputerName,
    DWORD       dwFlags
    );
typedef BOOL (FAR PASCAL *PFNPROCESSPOLICIESW) (
    HWND        hwnd,
    LPCWSTR    pszPath,
    LPCWSTR    pszUsername,
    LPCWSTR    pszComputerName,
    DWORD       dwFlags
    );
#ifdef UNICODE
#define PFNPROCESSPOLICIES  PFNPROCESSPOLICIESW
#else
#define PFNPROCESSPOLICIES  PFNPROCESSPOLICIESA
#endif // !UNICODE

#define PP_DISPLAYERRORS    0x01    /* if set, display error messages, else fail silently if error */
#endif /* WINVER >= 0x0400 */


//
//  Error handling.
// 

DWORD APIENTRY
WNetGetLastErrorA(
     LPDWORD    lpError,
     LPSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
DWORD APIENTRY
WNetGetLastErrorW(
     LPDWORD    lpError,
     LPWSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPWSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
#ifdef UNICODE
#define WNetGetLastError  WNetGetLastErrorW
#else
#define WNetGetLastError  WNetGetLastErrorA
#endif // !UNICODE

//
//  STATUS CODES
//

// General   

#define WN_SUCCESS                      NO_ERROR
#define WN_NO_ERROR                     NO_ERROR
#define WN_NOT_SUPPORTED                ERROR_NOT_SUPPORTED
#define WN_CANCEL                       ERROR_CANCELLED
#define WN_RETRY                        ERROR_RETRY
#define WN_NET_ERROR                    ERROR_UNEXP_NET_ERR
#define WN_MORE_DATA                    ERROR_MORE_DATA
#define WN_BAD_POINTER                  ERROR_INVALID_ADDRESS
#define WN_BAD_VALUE                    ERROR_INVALID_PARAMETER
#define WN_BAD_USER                     ERROR_BAD_USERNAME
#define WN_BAD_PASSWORD                 ERROR_INVALID_PASSWORD
#define WN_ACCESS_DENIED                ERROR_ACCESS_DENIED
#define WN_FUNCTION_BUSY                ERROR_BUSY
#define WN_WINDOWS_ERROR                ERROR_UNEXP_NET_ERR
#define WN_OUT_OF_MEMORY                ERROR_NOT_ENOUGH_MEMORY
#define WN_NO_NETWORK                   ERROR_NO_NETWORK
#define WN_EXTENDED_ERROR               ERROR_EXTENDED_ERROR
#define WN_BAD_LEVEL                    ERROR_INVALID_LEVEL
#define WN_BAD_HANDLE                   ERROR_INVALID_HANDLE
#if(WINVER >= 0x0400)
#define WN_NOT_INITIALIZING             ERROR_ALREADY_INITIALIZED
#define WN_NO_MORE_DEVICES              ERROR_NO_MORE_DEVICES
#endif /* WINVER >= 0x0400 */

// Connection

#define WN_NOT_CONNECTED                ERROR_NOT_CONNECTED
#define WN_OPEN_FILES                   ERROR_OPEN_FILES
#define WN_DEVICE_IN_USE                ERROR_DEVICE_IN_USE
#define WN_BAD_NETNAME                  ERROR_BAD_NET_NAME
#define WN_BAD_LOCALNAME                ERROR_BAD_DEVICE
#define WN_ALREADY_CONNECTED            ERROR_ALREADY_ASSIGNED
#define WN_DEVICE_ERROR                 ERROR_GEN_FAILURE
#define WN_CONNECTION_CLOSED            ERROR_CONNECTION_UNAVAIL
#define WN_NO_NET_OR_BAD_PATH           ERROR_NO_NET_OR_BAD_PATH
#define WN_BAD_PROVIDER                 ERROR_BAD_PROVIDER
#define WN_CANNOT_OPEN_PROFILE          ERROR_CANNOT_OPEN_PROFILE
#define WN_BAD_PROFILE                  ERROR_BAD_PROFILE
#define WN_BAD_DEV_TYPE                 ERROR_BAD_DEV_TYPE
#define WN_DEVICE_ALREADY_REMEMBERED    ERROR_DEVICE_ALREADY_REMEMBERED

// Enumeration

#define WN_NO_MORE_ENTRIES              ERROR_NO_MORE_ITEMS
#define WN_NOT_CONTAINER                ERROR_NOT_CONTAINER

#if(WINVER >= 0x0400)
// Authentication

#define WN_NOT_AUTHENTICATED            ERROR_NOT_AUTHENTICATED
#define WN_NOT_LOGGED_ON                ERROR_NOT_LOGGED_ON
#define WN_NOT_VALIDATED                ERROR_NO_LOGON_SERVERS
#endif /* WINVER >= 0x0400 */


//
//  For Shell
//

#if(WINVER >= 0x0400)
typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;

#define WNCON_FORNETCARD        0x00000001
#define WNCON_NOTROUTED         0x00000002
#define WNCON_SLOWLINK          0x00000004
#define WNCON_DYNAMIC           0x00000008

DWORD APIENTRY
MultinetGetConnectionPerformanceA(
        LPNETRESOURCEA lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
DWORD APIENTRY
MultinetGetConnectionPerformanceW(
        LPNETRESOURCEW lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
#ifdef UNICODE
#define MultinetGetConnectionPerformance  MultinetGetConnectionPerformanceW
#else
#define MultinetGetConnectionPerformance  MultinetGetConnectionPerformanceA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif

#endif  // _WINNETWK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINPERF.H ===
/*++

Copyright (C) 1993 - 1995 Microsoft Corporation

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/

#ifndef _WINPERF_
#define _WINPERF_

//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//

#define PERF_DATA_VERSION   1
#define PERF_DATA_REVISION  1


typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF"
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian
    DWORD           Version;            // Version of these data structures
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block
    DWORD           HeaderLength;       // Length of this structure
    DWORD           NumObjectTypes;     // Number of types of objects
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name
    DWORD           SystemNameOffset;   // Offset, from beginning of this
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//
#define PERF_SIZE_DWORD         0x00000000
#define PERF_SIZE_LARGE         0x00000100
#define PERF_SIZE_ZERO          0x00000200  // for Zero Length fields
#define PERF_SIZE_VARIABLE_LEN  0x00000300  // length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
#define PERF_TYPE_NUMBER        0x00000000  // a number (not a counter)
#define PERF_TYPE_COUNTER       0x00000400  // an increasing numeric value
#define PERF_TYPE_TEXT          0x00000800  // a text field
#define PERF_TYPE_ZERO          0x00000C00  // displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the
//  following to describe the Number
//
#define PERF_NUMBER_HEX         0x00000000  // display as HEX value
#define PERF_NUMBER_DECIMAL     0x00010000  // display as a decimal integer
#define PERF_NUMBER_DEC_1000    0x00020000  // display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
#define PERF_COUNTER_VALUE      0x00000000  // display counter value
#define PERF_COUNTER_RATE       0x00010000  // divide ctr / delta time
#define PERF_COUNTER_FRACTION   0x00020000  // divide ctr / base
#define PERF_COUNTER_BASE       0x00030000  // base value used in fractions
#define PERF_COUNTER_ELAPSED    0x00040000  // subtract counter from current time
#define PERF_COUNTER_QUEUELEN   0x00050000  // Use Queuelen processing func.
#define PERF_COUNTER_HISTOGRAM  0x00060000  // Counter begins or ends a histogram
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the
//  following to indicate the type of TEXT data.
//
#define PERF_TEXT_UNICODE       0x00000000  // type of text in text field
#define PERF_TEXT_ASCII         0x00010000  // ASCII using the CodePage field
//
//  Timer SubTypes
//
#define PERF_TIMER_TICK         0x00000000  // use system perf. freq for base
#define PERF_TIMER_100NS        0x00100000  // use 100 NS timer time base units
#define PERF_OBJECT_TIMER       0x00200000  // use the object timer freq
//
//  Any types that have calculations performed can use one or more of
//  the following calculation modification flags listed here
//
#define PERF_DELTA_COUNTER      0x00400000  // compute difference first
#define PERF_DELTA_BASE         0x00800000  // compute base diff as well
#define PERF_INVERSE_COUNTER    0x01000000  // show as 1.00-value (assumes:
#define PERF_MULTI_COUNTER      0x02000000  // sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
#define PERF_DISPLAY_NO_SUFFIX  0x00000000  // no suffix
#define PERF_DISPLAY_PER_SEC    0x10000000  // "/sec"
#define PERF_DISPLAY_PERCENT    0x20000000  // "%"
#define PERF_DISPLAY_SECONDS    0x30000000  // "secs"
#define PERF_DISPLAY_NOSHOW     0x40000000  // value is not displayed
//
//  Predefined counter types
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
#define PERF_COUNTER_COUNTER        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)


// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_QUEUELEN_TYPE  \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
#define PERF_COUNTER_BULK_COUNT     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)

// Indicates the counter is not a  counter but rather Unicode text Display as text.
#define PERF_COUNTER_TEXT           \
            (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |\
            PERF_DISPLAY_NO_SUFFIX)

// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT_HEX       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT_HEX       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)


// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"
#define PERF_SAMPLE_FRACTION        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT)

// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.
#define PERF_SAMPLE_COUNTER         \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// A label: no data is associated with this counter (it has 0 length)
// Do not display.
#define PERF_COUNTER_NODATA         \
            (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER | \
            PERF_DISPLAY_PERCENT)

// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.
#define PERF_SAMPLE_BASE            \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000001)  // for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"
#define PERF_AVERAGE_TIMER          \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_SECONDS)

// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.
#define PERF_AVERAGE_BASE           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000002)  // for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.
#define PERF_AVERAGE_BULK           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |\
            PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.
#define PERF_COUNTER_MULTI_TIMER    \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_COUNTER_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.
#define PERF_COUNTER_MULTI_BASE     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
#define PERF_100NSEC_MULTI_TIMER   \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_100NSEC_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Indicates the data is a fraction of the following counter  which
// should not be time averaged on display (such as free space over
// total space.) Display as is.  Display the quotient as "%".
#define PERF_RAW_FRACTION           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)
#define PERF_RAW_BASE               \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000003)  // for compatibility with pre-beta versions

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.
#define PERF_ELAPSED_TIME           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |\
            PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS)
//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//

#define PERF_COUNTER_HISTOGRAM_TYPE   0x80000000
                                        // Counter begins or ends a histogram

//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//

#define PERF_DETAIL_NOVICE          100 // The uninformed can understand it
#define PERF_DETAIL_ADVANCED        200 // For the advanced user
#define PERF_DETAIL_EXPERT          300 // For the expert user
#define PERF_DETAIL_WIZARD          400 // For the system designer


//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//

typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;

//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//

#define PERF_NO_UNIQUE_ID -1

typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none

} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD (APIENTRY PM_OPEN_PROC) (LPWSTR);
typedef DWORD (APIENTRY PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY PM_CLOSE_PROC) (void);

#endif // _WINPERF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINREG.H ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    Winreg.h

Abstract:

    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.

--*/

#ifndef _WINREG_
#define _WINREG_


#ifdef __cplusplus
extern "C" {
#endif


//
// Requested Key access mask type.
//

typedef ACCESS_MASK REGSAM;

//
// Type definitions.
//

DECLARE_HANDLE(HKEY);
typedef HKEY *PHKEY;

//
// Reserved Key Handles.
//

#define HKEY_CLASSES_ROOT           (( HKEY ) 0x80000000 )
#define HKEY_CURRENT_USER           (( HKEY ) 0x80000001 )
#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
#define HKEY_USERS                  (( HKEY ) 0x80000003 )
#define HKEY_PERFORMANCE_DATA       (( HKEY ) 0x80000004 )
#if(WINVER >= 0x0400)
#define HKEY_CURRENT_CONFIG         (( HKEY ) 0x80000005 )
#define HKEY_DYN_DATA               (( HKEY ) 0x80000006 )

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

#define PROVIDER_KEEPS_VALUE_LENGTH 0x1
struct val_context {
    int valuelen;       // the total length of this value
    LPVOID value_context;   // provider's context
    LPVOID val_buff_ptr;    // where in the ouput buffer the value is.
};

typedef struct val_context FAR *PVALCONTEXT;

typedef struct pvalueA {           // Provider supplied value/context.
    LPSTR   pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA, FAR *PPVALUEA;
typedef struct pvalueW {           // Provider supplied value/context.
    LPWSTR  pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW, FAR *PPVALUEW;
#ifdef UNICODE
typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;
#else
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
#endif // UNICODE

typedef
DWORD _cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD FAR *total_outlen, DWORD input_blen);

typedef QUERYHANDLER FAR *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    // capability flags (none defined yet).
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info FAR *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
}VALENTA, FAR *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
}VALENTW, FAR *PVALENTW;
#ifdef UNICODE
typedef VALENTW VALENT;
typedef PVALENTW PVALENT;
#else
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#endif // UNICODE

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#endif /* WINVER >= 0x0400 */

//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//

#define WIN31_CLASS                 NULL

//
// API Prototypes.
//


WINADVAPI
LONG
APIENTRY
RegCloseKey (
    HKEY hKey
    );

WINADVAPI
LONG
APIENTRY
RegConnectRegistryA (
    LPSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );
WINADVAPI
LONG
APIENTRY
RegConnectRegistryW (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );
#ifdef UNICODE
#define RegConnectRegistry  RegConnectRegistryW
#else
#define RegConnectRegistry  RegConnectRegistryA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegCreateKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );
WINADVAPI
LONG
APIENTRY
RegCreateKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );
#ifdef UNICODE
#define RegCreateKey  RegCreateKeyW
#else
#define RegCreateKey  RegCreateKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegCreateKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );
WINADVAPI
LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );
#ifdef UNICODE
#define RegCreateKeyEx  RegCreateKeyExW
#else
#define RegCreateKeyEx  RegCreateKeyExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegDeleteKeyA (
    HKEY hKey,
    LPCSTR lpSubKey
    );
WINADVAPI
LONG
APIENTRY
RegDeleteKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );
#ifdef UNICODE
#define RegDeleteKey  RegDeleteKeyW
#else
#define RegDeleteKey  RegDeleteKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegDeleteValueA (
    HKEY hKey,
    LPCSTR lpValueName
    );
WINADVAPI
LONG
APIENTRY
RegDeleteValueW (
    HKEY hKey,
    LPCWSTR lpValueName
    );
#ifdef UNICODE
#define RegDeleteValue  RegDeleteValueW
#else
#define RegDeleteValue  RegDeleteValueA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegEnumKeyA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    );
WINADVAPI
LONG
APIENTRY
RegEnumKeyW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );
#ifdef UNICODE
#define RegEnumKey  RegEnumKeyW
#else
#define RegEnumKey  RegEnumKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegEnumKeyExA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );
WINADVAPI
LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );
#ifdef UNICODE
#define RegEnumKeyEx  RegEnumKeyExW
#else
#define RegEnumKeyEx  RegEnumKeyExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
WINADVAPI
LONG
APIENTRY
RegEnumValueW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
#ifdef UNICODE
#define RegEnumValue  RegEnumValueW
#else
#define RegEnumValue  RegEnumValueA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegFlushKey (
    HKEY hKey
    );

WINADVAPI
LONG
APIENTRY
RegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    );

WINADVAPI
LONG
APIENTRY
RegLoadKeyA (
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpFile
    );
WINADVAPI
LONG
APIENTRY
RegLoadKeyW (
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpFile
    );
#ifdef UNICODE
#define RegLoadKey  RegLoadKeyW
#else
#define RegLoadKey  RegLoadKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegNotifyChangeKeyValue (
    HKEY hKey,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    HANDLE hEvent,
    BOOL fAsynchronus
    );

WINADVAPI
LONG
APIENTRY
RegOpenKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );
WINADVAPI
LONG
APIENTRY
RegOpenKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );
#ifdef UNICODE
#define RegOpenKey  RegOpenKeyW
#else
#define RegOpenKey  RegOpenKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegOpenKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
WINADVAPI
LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
#ifdef UNICODE
#define RegOpenKeyEx  RegOpenKeyExW
#else
#define RegOpenKeyEx  RegOpenKeyExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegQueryInfoKeyA (
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );
WINADVAPI
LONG
APIENTRY
RegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );
#ifdef UNICODE
#define RegQueryInfoKey  RegQueryInfoKeyW
#else
#define RegQueryInfoKey  RegQueryInfoKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegQueryValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpValue,
    PLONG   lpcbValue
    );
WINADVAPI
LONG
APIENTRY
RegQueryValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG   lpcbValue
    );
#ifdef UNICODE
#define RegQueryValue  RegQueryValueW
#else
#define RegQueryValue  RegQueryValueA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesA (
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );
WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesW (
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );
#ifdef UNICODE
#define RegQueryMultipleValues  RegQueryMultipleValuesW
#else
#define RegQueryMultipleValues  RegQueryMultipleValuesA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINADVAPI
LONG
APIENTRY
RegQueryValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
WINADVAPI
LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
#ifdef UNICODE
#define RegQueryValueEx  RegQueryValueExW
#else
#define RegQueryValueEx  RegQueryValueExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegReplaceKeyA (
    HKEY     hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpNewFile,
    LPCSTR  lpOldFile
    );
WINADVAPI
LONG
APIENTRY
RegReplaceKeyW (
    HKEY     hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpNewFile,
    LPCWSTR  lpOldFile
    );
#ifdef UNICODE
#define RegReplaceKey  RegReplaceKeyW
#else
#define RegReplaceKey  RegReplaceKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegRestoreKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    DWORD   dwFlags
    );
WINADVAPI
LONG
APIENTRY
RegRestoreKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    DWORD   dwFlags
    );
#ifdef UNICODE
#define RegRestoreKey  RegRestoreKeyW
#else
#define RegRestoreKey  RegRestoreKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegSaveKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINADVAPI
LONG
APIENTRY
RegSaveKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define RegSaveKey  RegSaveKeyW
#else
#define RegSaveKey  RegSaveKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegSetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

WINADVAPI
LONG
APIENTRY
RegSetValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );
WINADVAPI
LONG
APIENTRY
RegSetValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );
#ifdef UNICODE
#define RegSetValue  RegSetValueW
#else
#define RegSetValue  RegSetValueA
#endif // !UNICODE


WINADVAPI
LONG
APIENTRY
RegSetValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );
WINADVAPI
LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );
#ifdef UNICODE
#define RegSetValueEx  RegSetValueExW
#else
#define RegSetValueEx  RegSetValueExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegUnLoadKeyA (
    HKEY    hKey,
    LPCSTR lpSubKey
    );
WINADVAPI
LONG
APIENTRY
RegUnLoadKeyW (
    HKEY    hKey,
    LPCWSTR lpSubKey
    );
#ifdef UNICODE
#define RegUnLoadKey  RegUnLoadKeyW
#else
#define RegUnLoadKey  RegUnLoadKeyA
#endif // !UNICODE

//
// Remoteable System Shutdown APIs
//

WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );
#ifdef UNICODE
#define InitiateSystemShutdown  InitiateSystemShutdownW
#else
#define InitiateSystemShutdown  InitiateSystemShutdownA
#endif // !UNICODE


WINADVAPI
BOOL
APIENTRY
AbortSystemShutdownA(
    LPSTR lpMachineName
    );
WINADVAPI
BOOL
APIENTRY
AbortSystemShutdownW(
    LPWSTR lpMachineName
    );
#ifdef UNICODE
#define AbortSystemShutdown  AbortSystemShutdownW
#else
#define AbortSystemShutdown  AbortSystemShutdownA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif


#endif // _WINREG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINSOCK.H ===
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 * Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS          1           /* set/get IP per-packet options    */
#define IP_MULTICAST_IF     2           /* set/get IP multicast interface   */
#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */
#define IP_MULTICAST_LOOP   4           /* set/get IP multicast loopback    */
#define IP_ADD_MEMBERSHIP   5           /* add  an IP group membership      */
#define IP_DROP_MEMBERSHIP  6           /* drop an IP group membership      */

#define IP_DEFAULT_MULTICAST_TTL   1    /* normally limit m'casts to 1 hop  */
#define IP_DEFAULT_MULTICAST_LOOP  1    /* normally hear sends if a member  */
#define IP_MAX_MEMBERSHIPS         20   /* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * Option for opening sockets for synchronous access.
 */
#define SO_OPENTYPE     0x7008

#define SO_SYNCHRONOUS_ALERT    0x10
#define SO_SYNCHRONOUS_NONALERT 0x20

/*
 * Other NT-specific options.
 */
#define SO_MAXDG        0x7009
#define SO_MAXPATHDG    0x700A

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001
#define TCP_BSDURGENT   0x7000

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */
#define AF_VOICEVIEW    18              /* VoiceView */

#define AF_MAX          19

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK
#define PF_VOICEVIEW    AF_VOICEVIEW

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)
#define TRY_AGAIN               WSATRY_AGAIN

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)
#define NO_RECOVERY             WSANO_RECOVERY

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)
#define NO_DATA                 WSANO_DATA

/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name,
                                        const char FAR * proto,
                                        char FAR * buf, int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char FAR * proto, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char FAR * name, char FAR * buf,
                                         int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char FAR * buf,
                                           int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char FAR * addr, int len, int type,
                                        char FAR * buf, int buflen);

int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

int PASCAL FAR WSARecvEx (SOCKET s, char FAR * buf, int len, int FAR *flags);

typedef struct _TRANSMIT_FILE_BUFFERS {
    PVOID Head;
    DWORD HeadLength;
    PVOID Tail;
    DWORD TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

BOOL
PASCAL FAR
TransmitFile (
    IN SOCKET hSocket,
    IN HANDLE hFile,
    IN DWORD nNumberOfBytesToWrite,
    IN DWORD nNumberOfBytesPerSend,
    IN LPOVERLAPPED lpOverlapped,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD dwReserved
    );

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#endif  /* _WINSOCKAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\NVRMWIN.H ===
#ifndef _NVRMWIN_H_
#define _NVRMWIN_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVRMWIN.H                                                         *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  OS specific defines.
//
//---------------------------------------------------------------------------

//
// Max values for tables.
//
#define MAX_REGISTER                    16
//#define NUM_CLIENTS                     16
//
// Messages to Resource Manager Windows client.
//
#ifndef WM_USER
#define WM_USER                         0x0400
#endif
#define NVRM_WM_ERROR                   WM_USER
#define NVRM_WM_OPEN_HWND               (WM_USER+0x10)
#define NVRM_WM_CLOSE_HWND              (WM_USER+0x11)
#define NVRM_WM_REDRAW_HWND             (WM_USER+0x12)
#define NVRM_WM_REDRAW_SCREEN           (WM_USER+0x13)
//
// IOCTL Interface functions. 
//
#define NVRM_IOCTL_BASE 0x10
#define NVRM_IOCTL_CRTC_GET   (NVRM_IOCTL_BASE+0)
#define NVRM_IOCTL_CRTC_SET   (NVRM_IOCTL_BASE+1)
#define NVRM_IOCTL_DUMPNVDATA (NVRM_IOCTL_BASE+2)
#define NVRM_IOCTL_NV_READ    (NVRM_IOCTL_BASE+3)
#define NVRM_IOCTL_NV_WRITE   (NVRM_IOCTL_BASE+4)
#define NVRM_IOCTL_NV_ARCH    (NVRM_IOCTL_BASE+5)
#define NVRM_IOCTL_CRTC_TEST  (NVRM_IOCTL_BASE+6)
//
// API services to Resource Manager VxD.
//
#define NVRM_API_BASE                    1000
#define NVRM_API_GET_VERSION             (NVRM_API_BASE+0)
#define NVRM_API_SET_CANVAS              (NVRM_API_BASE+10)
#define NVRM_API_SET_CANVAS_RECT         (NVRM_API_BASE+11)
#define NVRM_API_SET_CANVAS_CLIP         (NVRM_API_BASE+12)
#define NVRM_API_SET_CANVAS_REGION       (NVRM_API_BASE+13)
#define NVRM_API_ALLOC_PAGES             (NVRM_API_BASE+20)
#define NVRM_API_FREE_PAGES              (NVRM_API_BASE+21)
#define NVRM_API_LOCK_PAGES              (NVRM_API_BASE+22)
#define NVRM_API_UNLOCK_PAGES            (NVRM_API_BASE+23)
#define NVRM_API_CLEAR_SCREEN            (NVRM_API_BASE+24)
#define NVRM_API_MAP_SELECTOR            (NVRM_API_BASE+25)
#define NVRM_API_HIDE_SW_CURSOR          (NVRM_API_BASE+26)
#define NVRM_API_IPC_CALLBACK            (NVRM_API_BASE+30)
#define NVRM_API_NOTIFY_CALLBACK         (NVRM_API_BASE+31)
#define NVRM_API_UNLOAD_DLL              (NVRM_API_BASE+32)
#define NVRM_API_GET_NV_ADDRESS          (NVRM_API_BASE+50)
#define NVRM_API_GET_FB_ADDRESS          (NVRM_API_BASE+51)
#define NVRM_API_GET_AGP_ADDRESS         (NVRM_API_BASE+52)
#define NVRM_API_GET_GAMMA_ADDRESS       (NVRM_API_BASE+53)
#define NVRM_API_GET_VDD_PRIV_ADDRESS    (NVRM_API_BASE+54)
#define NVRM_API_UPDATE_CONFIGURATION    (NVRM_API_BASE+60)
#define NVRM_API_UNLOAD_CONFIGURATION    (NVRM_API_BASE+61)
#define NVRM_API_LOAD_CONFIGURATION      (NVRM_API_BASE+62)
#define NVRM_API_CONFIG_VGA              (NVRM_API_BASE+63)
#define NVRM_API_MODE_HOOK               (NVRM_API_BASE+64)
#define NVRM_API_DMAPUSH_OPERATION       (NVRM_API_BASE+65)
#define NVRM_API_DMAPUSH_LOCK            (NVRM_API_BASE+69)
#define NVRM_API_SEMAPHORE               (NVRM_API_BASE+70)
#define NVRM_API_SIGNAL_MODE_SAVE        (NVRM_API_BASE+71)
#define NVRM_API_ARCHITECTURE_16         (NVRM_API_BASE+72)
#define NVRM_API_ARCHITECTURE_32         (NVRM_API_BASE+73)
#define NVRM_API_MULTIDEVICE_MAP_RM_INFO (NVRM_API_BASE+74)
#define NVRM_API_DISPLAY                 (NVRM_API_BASE+75)
#define NVRM_API_RM_TOKEN                (NVRM_API_BASE+76)
#define NVRM_API_GET_DEVICE_TYPE         (NVRM_API_BASE+77)
#define NVRM_API_TEST                    (NVRM_API_BASE+78)
#define NVRM_API_REGISTER_DISPLAY_DRIVER (NVRM_API_BASE+79)
#define NVRM_AGP_LOAD_DUMMY_PAGES        (NVRM_API_BASE+80)
#define NVRM_REGISTRY_SET_STRING         (NVRM_API_BASE+81)
#define NVRM_API_ACPI_ENABLED            (NVRM_API_BASE+82)

#define NVRM_API_INIT                    (NVRM_API_BASE+100)
#define NVRM_API_ENABLEVGA               (NVRM_API_BASE+101)
#define NVRM_API_ENABLEHIRES             (NVRM_API_BASE+102)
#define NVRM_API_DEV_HANDLE              (NVRM_API_BASE+103)
#define NVRM_API_POWER_UP                (NVRM_API_BASE+105)
#define NVRM_API_POWER_DOWN              (NVRM_API_BASE+106)
#define NVRM_API_EXIT                    (NVRM_API_BASE+107)
#define NVRM_API_POWER_D1                (NVRM_API_BASE+108)
#define NVRM_API_POWER_D2                (NVRM_API_BASE+109)
#define NVRM_API_DRIVER_CONNECT          (NVRM_API_BASE+110)
#define NVRM_API_DRIVER_DISCONNECT       (NVRM_API_BASE+111)
#define NVRM_API_READ_EDID               (NVRM_API_BASE+112)
#define NVRM_API_NUM_HEADS               (NVRM_API_BASE+113)
#define NVRM_API_GET_DDC_CAPS            (NVRM_API_BASE+114)
#define NVRM_API_HIBERNATE               (NVRM_API_BASE+115)
#define NVRM_API_SET_MONITOR_POWER       (NVRM_API_BASE+116)
#define NVRM_API_BLANK_SECONDARY         (NVRM_API_BASE+117)
#define NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP (NVRM_API_BASE+118)

#define NVRM_API_NV1ALLOCCHANNELPIO      (NVRM_API_BASE+700)
#define NVRM_API_VPE_MISC                (NVRM_API_BASE+600)
#define NVRM_API_OVERLAY_MISC            (NVRM_API_BASE+601)

#define NVRM_ARCH_NV01FREE              0
#define NVRM_ARCH_NV01ALLOCROOT         1
#define NVRM_ARCH_NV01ALLOCMEMORY       2
#define NVRM_ARCH_NV01ALLOCCONTEXTDMA   3
#define NVRM_ARCH_NV01ALLOCCHANNELPIO   4
#define NVRM_ARCH_NV01ALLOCOBJECT       5
#define NVRM_ARCH_NV01ALLOCDEVICE       6
#define NVRM_ARCH_NV03ALLOCCHANNELDMA   7
#define NVRM_ARCH_NV03DMAFLOWCONTROL    8
#define NVRM_ARCH_NV01INTERRUPT         9
#define NVRM_ARCH_NV01ALLOCEVENT        10
#define NVRM_ARCH_NV03HEAP              11
#define NVRM_ARCH_CONFIG_VERSION        12
#define NVRM_ARCH_CONFIG_GET            13
#define NVRM_ARCH_CONFIG_SET            14
#define NVRM_ARCH_CONFIG_UPDATE         15
#define NVRM_ARCH_RING0CALLBACK         16
#define NVRM_ARCH_CONFIG_GET_EX         17
#define NVRM_ARCH_CONFIG_SET_EX         18
#define NVRM_ARCH_I2C_ACCESS            19
#define NVRM_ARCH_NV01DEBUGCONTROL      20
#define NVRM_ARCH_NV04ALLOC             21
// audio stuff
#define NVRM_ARCH_UNIFIEDFREE           30

#define NVRM_ARCH_MAX_IOCTL             30

// ResourceManagerGlobalToken stuff.
#define AQUIRE_TOKEN 0
#define RETURN_TOKEN 1
#define QUERY_TOKEN  2

// *** Beginning of VPE_EXTRAS
// Videoport api subfunction list
#define SKIP_NEXT_FIELD                 1
#define SKIP_FIELD_PATTERN              2
#define MULTIPLE_SURFACE                3
#define STATUS_CURRENT                  4
#define STATUS_NEXT                     5
#define STATUS_ALL                      6
#define DMA_ATTACH_TO_SURFACE           7
#define DMA_DETTACH_FROM_SURFACE        8
#define DMA_STATUS                      9
#define DMA_QUERY_CAPS                  10

// 16 bit access only
#define VBI_INSTALL_16CALLBACK          11
#define VBI_UNINSTALL_16CALLBACK        12
#define IMAGE_INSTALL_16CALLBACK        13
#define IMAGE_UNINSTALL_16CALLBACK      14

// 32 bit access only
#define VBI_INSTALL_32CALLBACK          15
#define VBI_UNINSTALL_32CALLBACK        16
#define IMAGE_INSTALL_32CALLBACK        17
#define IMAGE_UNINSTALL_32CALLBACK      18

// special extras
#define CAPTURE_FIELD_IMAGE_LIMIT       19
#define CAPTURE_FIELD_VBI_LIMIT         20
#define EVENT_SET_INFO                  21
#define EVENT_START                     22
#define EVENT_STOP                      23
#define EVENT_DESTROY                   24

#define SET_VIDEOPORT_SIZE              25

#define VPE_API_MAX                     25

// vpe api error/warnings
#define VPE_MAX_API_LIST_EXCEEDED       1
#define VPE_API_FUNCTION_FAILED         2

#define SEMAPHORE_SIGNAL                0
#define SEMAPHORE_WAIT                  1

// Function equates for dll interfaces.
#define NV_FUNCTION_NVOPEN              1  
#define NV_FUNCTION_NVCLOSE             2  
#define NV_FUNCTION_NVSYSCLIENTEXIT     3  
#define NV_FUNCTION_NVNOTIFYEVENT       5  
#define NV_FUNCTION_NVNOTIFYMSG         6  
#define NV_FUNCTION_NVERRORMSG          7  
#define NV_FUNCTION_NVALLOCPAGES        8  
#define NV_FUNCTION_NVFREEPAGES         9  
#define NV_FUNCTION_GETSELECTORBASE     100  
#define NV_FUNCTION_GETCURRENTTASK      101  
#define NV_FUNCTION_NVCONFIGVERSION     200  
#define NV_FUNCTION_NVCONFIGGET         201  
#define NV_FUNCTION_NVCONFIGSET         202  
#define NV_FUNCTION_NVCONFIGUPDATE      203  
#define NV_FUNCTION_NVSYSGETHWPTRS      300  
#define NV_FUNCTION_NVDEVICEBASEGET     301  
#define NV_FUNCTION_NVDEVICELIMITGET    302 
#define NV_FUNCTION_NVDEVICESELECTORGET 303
#define NV_FUNCTION_NVSYSOPEN           500  
#define NV_FUNCTION_NVSYSCLOSE          501  
#define NV_FUNCTION_NVSYSSHOWHIDECRSR   502  
#define NV_FUNCTION_NVOPENDMA           503  
#define NV_FUNCTION_NVSYSOPENDMA        504

// structures ....
//
// Paramater structure used for communication between Resource Manager modules.
//
// Resource Manager RMUSRAPI parameters.
typedef struct def_rmusrapi_struct {
  U032  function;       
  U032  device; 
} RMUSRAPI_STRUCT,*PRMUSRAPI_STRUCT;

typedef struct def_diagstruct_struct {
  U032  nv_pfifo_intr_0;      
  U032  nv_pfifo_intr_en_0;   
  U032  nv_pfifo_caches;      
  U032  nv_pfifo_mode;        
  U032  nv_pfifo_cache1_push0;
  U032  nv_pfifo_cache1_push1;
  U032  nv_pfifo_cache1_pull0;
  U032  nv_pfifo_dma_put;     
  U032  nv_pfifo_dma_get;     
  U032  nv_pmc_intr_0;
  U032  nv_pmc_intr_en_0;
  U032  nv_pmc_intr_read_0;
  U032  nv_pmc_enable;
}NVWATCHDIAGSTRUCT,*PNVWATCHDIAGSTRUCT;


//
// IMPORTANT: The display driver uses this exact data structure alignment on the
// other side of the DLL thunks.  DO NOT CHANGE THIS STRUCTURE without also changing
// the display driver.  Otherwise everything will just stop working.
//
typedef struct _def_rmParams
{
    U032 RegEAX;
    U032 RegEBX;
    U032 RegECX;
    U032 RegEDX;
    U032 RegEDI;
    U032 RegESI;
    U032 RegES;
    U032 RegDS;
    U032 RegCS;
} RMPARAMS, *PRMPARAMS;

typedef struct _def_rmInterfaceParameters
{
    U032 Param0;
    U032 Param1;
    U032 Param2;
    U032 Param3;
    U032 Param4;
    U032 Param5;
    U032 Param6;
    U032 Param7;
} RMINTPARAMS, *PRMINTPARAMS;

// this structure is redfined in sdk\nvidia\inc\nvarmapi.h
// DO NOT CHANGE it!
typedef struct _def_NvIoctlArch
{
    V032 nvarchFunction;
    V032 nvarchParameters;
} NV_IOCTL_ARCH_STRUCT;

typedef struct
{
U032 dwOffset;
U032 dwLength;
U032 dwFormat;
U032 dwPitch;
} SURFACES, * PSURFACES;

typedef struct
{
U032 dwObjectIdent;
U032 dwNoOfSurfaces;
PSURFACES pSurfaceList;
U032 dwMasterFormat;
U032 dwRequiredXsize;
U032 dwRequiredYsize;
U032 dwSrcXsize;
U032 dwSrcYsize;
} MULTSURF, * PMULTSURF;

typedef struct 
{
U032 dwSkipPattern;
U032 dwSkipBits;
} SKIPPATTERN, * PSKIPPATTERN;

#define SYNC_CONTROL_NONE       0
#define SYNC_CONTROL_ODD        1
#define SYNC_CONTROL_EVEN       2
#define SYNC_CONTROL_BUFF_0     3
#define SYNC_CONTROL_BUFF_1     4

typedef struct
{
U032 dwFieldCount;
U032 dwSyncControl;
} CAPTURE_LIMIT, * PCAPTURE_LIMIT;

// mediaport temporary callback facility
typedef struct 
{
U032 Selector;
U032 Offset;
} CallBackDef;


// begining of overlay extras
// definitions...
#define OVERLAY_MULTIPLE_SURFACE        1
#define OVERLAY_API_MAX                 1

#define OVERLAY_MAX_API_LIST_EXCEEDED   1
#define OVERLAY_API_FUNCTION_FAILED     2

// structures....
typedef struct
{
U032 dwObjectIdent;
U032 dwNoOfSurfaces;
PSURFACES pSurfaceList;
U032 dwMasterFormat; // BOB or INTERLEAVED
} OVERLAY_MULTSURF, * POVERLAY_MULTSURF;

typedef struct
{
U032 hVideoEvent;
U032 hVBIEvent;
U032 dwVBISize;     // don't pay any attention to this
U032 dwFlags;       // which field caused the event
U032 pVBIBuffer;
// following are debug only
U032 fieldCounter;  // incremented every field interrupt
U032 vbiCounter;    // incremented every vbi interrupt
} EVENT_INFO, * PEVENT_INFO;

typedef struct
{
U032 dwMaxSizeX;
U032 dwMaxSizeY;
} VIDEOPORT_SIZE_INFO, * PVIDEOPORT_SIZE_INFO;

typedef struct
{
U032 chPtr;         // NvChannel *
U032 ctxDma;
U032 putAddress;
U032 getAddress;
U032 jumpAddress;
U032 pNotificationDmaToMemDmaPushStatus;
U032 fDmaPusherActive;
} DMAPUSH_ADDRESS_INFO, * PDMAPUSH_ADDRESS_INFO;

//
// DmaPush flag options.
//
#define SET_JUMP_ADDRESS                0x0001
#define WRITE_PUT_ADDRESS               0x0002
#define READ_GET_ADDRESS                0x0004
#define DMAPUSH_LOCK                    0x0008
#define DMAPUSH_FREE                    0x0010

//
// Display Device API functions
//
#define NVRM_API_DISPLAY_GET_MONITOR_TYPE           0x0000
#define NVRM_API_DISPLAY_GET_DISPLAY_TYPE           0x0001
#define NVRM_API_DISPLAY_SET_DISPLAY_TYPE           0x0002
#define NVRM_API_DISPLAY_GET_FP_CONNECT_STATUS      0x0003
#define NVRM_API_DISPLAY_GET_FP_CONFIG              0x0004
#define NVRM_API_DISPLAY_SET_FP_CONFIG              0x0005
#define NVRM_API_DISPLAY_CHANGE_START               0x0006
#define NVRM_API_DISPLAY_CHANGE_END                 0x0007
#define NVRM_API_DISPLAY_CHANGE_CONFIG              0x0008

//
// Mapping options.
//
#define MAP_LINEAR                      1
#define MAP_SELECTOR                    2
//
// Configuration options.
//
#define CONFIG_PERMANENT                1
#define CONFIG_TEMPORARY                2
//
// Resource String Definitions.
//
// NVSYS.DLL
//
#define NVSYS_STR_CLIENT_ERROR          1
#define NVSYS_STR_RM_ERROR              2
#define NVSYS_STR_EXE_NOT_FOUND         3
#define NVSYS_STR_TOO_MANY_CLIENTS      4
#define NVSYS_STR_VERSION_ERROR         5
//
// NVRM.EXE
//
#define NVEXE_STR_CLIENT_ERROR          1

//---------------------------------------------------------------------------
//
//  OS specific structures.
//
//---------------------------------------------------------------------------

#endif // _MVRMWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINVER.H ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) 1993-1995, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#ifdef __cplusplus
extern "C" {
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

DWORD
APIENTRY
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
APIENTRY
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

DWORD
APIENTRY
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
APIENTRY
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD
APIENTRY
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
APIENTRY
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE

#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif

#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINSVC.H ===
/*++ BUILD Version: 0010    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    winsvc.h

Abstract:

    Header file for the Service Control Manager

Environment:

    User Mode - Win32

--*/
#ifndef _WINSVC_
#define _WINSVC_

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(WINADVAPI)
#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

//
// Service database names
//

#define SERVICES_ACTIVE_DATABASEW      L"ServicesActive"
#define SERVICES_FAILED_DATABASEW      L"ServicesFailed"

#define SERVICES_ACTIVE_DATABASEA      "ServicesActive"
#define SERVICES_FAILED_DATABASEA      "ServicesFailed"

//
// Character to designate that a name is a group
//

#define SC_GROUP_IDENTIFIERW           L'+'
#define SC_GROUP_IDENTIFIERA           '+'

#ifdef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEW
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEW


#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERW

#else // ndef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEA

#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERA
#endif // ndef UNICODE


//
// Value to indicate no change to an optional parameter
//
#define SERVICE_NO_CHANGE              0xffffffff

//
// Service State -- for Enum Requests (Bit Mask)
//
#define SERVICE_ACTIVE                 0x00000001
#define SERVICE_INACTIVE               0x00000002
#define SERVICE_STATE_ALL              (SERVICE_ACTIVE   | \
                                        SERVICE_INACTIVE)

//
// Controls
//
#define SERVICE_CONTROL_STOP           0x00000001
#define SERVICE_CONTROL_PAUSE          0x00000002
#define SERVICE_CONTROL_CONTINUE       0x00000003
#define SERVICE_CONTROL_INTERROGATE    0x00000004
#define SERVICE_CONTROL_SHUTDOWN       0x00000005

//
// Service State -- for CurrentState
//
#define SERVICE_STOPPED                0x00000001
#define SERVICE_START_PENDING          0x00000002
#define SERVICE_STOP_PENDING           0x00000003
#define SERVICE_RUNNING                0x00000004
#define SERVICE_CONTINUE_PENDING       0x00000005
#define SERVICE_PAUSE_PENDING          0x00000006
#define SERVICE_PAUSED                 0x00000007

//
// Controls Accepted  (Bit Mask)
//
#define SERVICE_ACCEPT_STOP            0x00000001
#define SERVICE_ACCEPT_PAUSE_CONTINUE  0x00000002
#define SERVICE_ACCEPT_SHUTDOWN        0x00000004

//
// Service Control Manager object specific access types
//
#define SC_MANAGER_CONNECT             0x0001
#define SC_MANAGER_CREATE_SERVICE      0x0002
#define SC_MANAGER_ENUMERATE_SERVICE   0x0004
#define SC_MANAGER_LOCK                0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS   0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG  0x0020

#define SC_MANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED      | \
                                        SC_MANAGER_CONNECT            | \
                                        SC_MANAGER_CREATE_SERVICE     | \
                                        SC_MANAGER_ENUMERATE_SERVICE  | \
                                        SC_MANAGER_LOCK               | \
                                        SC_MANAGER_QUERY_LOCK_STATUS  | \
                                        SC_MANAGER_MODIFY_BOOT_CONFIG)



//
// Service object specific access type
//
#define SERVICE_QUERY_CONFIG           0x0001
#define SERVICE_CHANGE_CONFIG          0x0002
#define SERVICE_QUERY_STATUS           0x0004
#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
#define SERVICE_START                  0x0010
#define SERVICE_STOP                   0x0020
#define SERVICE_PAUSE_CONTINUE         0x0040
#define SERVICE_INTERROGATE            0x0080
#define SERVICE_USER_DEFINED_CONTROL   0x0100

#define SERVICE_ALL_ACCESS             (STANDARD_RIGHTS_REQUIRED     | \
                                        SERVICE_QUERY_CONFIG         | \
                                        SERVICE_CHANGE_CONFIG        | \
                                        SERVICE_QUERY_STATUS         | \
                                        SERVICE_ENUMERATE_DEPENDENTS | \
                                        SERVICE_START                | \
                                        SERVICE_STOP                 | \
                                        SERVICE_PAUSE_CONTINUE       | \
                                        SERVICE_INTERROGATE          | \
                                        SERVICE_USER_DEFINED_CONTROL)


//
// Handle Types
//

typedef HANDLE      SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

typedef DWORD       SERVICE_STATUS_HANDLE;

//
// Service Status Structure
//

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;



//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR          lpServiceName;
    LPSTR          lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR         lpServiceName;
    LPWSTR         lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
#ifdef UNICODE
typedef ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSW LPENUM_SERVICE_STATUS;
#else
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#endif // UNICODE


//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
#ifdef UNICODE
typedef QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSW LPQUERY_SERVICE_LOCK_STATUS;
#else
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#endif // UNICODE



//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
#ifdef UNICODE
typedef QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGW LPQUERY_SERVICE_CONFIG;
#else
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#endif // UNICODE



//
// Function Prototype for the Service Main Function
//

typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );

#ifdef UNICODE
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONW
#else
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONA
#endif //UNICODE


//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
#ifdef UNICODE
typedef SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYW LPSERVICE_TABLE_ENTRY;
#else
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#endif // UNICODE

//
// Prototype for the Service Control Handler Function
//

typedef VOID (WINAPI *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );



///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////

WINADVAPI
BOOL
WINAPI
ChangeServiceConfigA(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword,
    LPCSTR     lpDisplayName
    );
WINADVAPI
BOOL
WINAPI
ChangeServiceConfigW(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword,
    LPCWSTR     lpDisplayName
    );
#ifdef UNICODE
#define ChangeServiceConfig  ChangeServiceConfigW
#else
#define ChangeServiceConfig  ChangeServiceConfigA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CloseServiceHandle(
    SC_HANDLE   hSCObject
    );

WINADVAPI
BOOL
WINAPI
ControlService(
    SC_HANDLE           hService,
    DWORD               dwControl,
    LPSERVICE_STATUS    lpServiceStatus
    );

WINADVAPI
SC_HANDLE
WINAPI
CreateServiceA(
    SC_HANDLE    hSCManager,
    LPCSTR     lpServiceName,
    LPCSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword
    );
WINADVAPI
SC_HANDLE
WINAPI
CreateServiceW(
    SC_HANDLE    hSCManager,
    LPCWSTR     lpServiceName,
    LPCWSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword
    );
#ifdef UNICODE
#define CreateService  CreateServiceW
#else
#define CreateService  CreateServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
DeleteService(
    SC_HANDLE   hService
    );

WINADVAPI
BOOL
WINAPI
EnumDependentServicesA(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
WINADVAPI
BOOL
WINAPI
EnumDependentServicesW(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
#ifdef UNICODE
#define EnumDependentServices  EnumDependentServicesW
#else
#define EnumDependentServices  EnumDependentServicesA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
EnumServicesStatusA(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
WINADVAPI
BOOL
WINAPI
EnumServicesStatusW(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
#ifdef UNICODE
#define EnumServicesStatus  EnumServicesStatusW
#else
#define EnumServicesStatus  EnumServicesStatusA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
GetServiceKeyNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpDisplayName,
    LPSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
WINADVAPI
BOOL
WINAPI
GetServiceKeyNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpDisplayName,
    LPWSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
#ifdef UNICODE
#define GetServiceKeyName  GetServiceKeyNameW
#else
#define GetServiceKeyName  GetServiceKeyNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpServiceName,
    LPSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpServiceName,
    LPWSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
#ifdef UNICODE
#define GetServiceDisplayName  GetServiceDisplayNameW
#else
#define GetServiceDisplayName  GetServiceDisplayNameA
#endif // !UNICODE

WINADVAPI
SC_LOCK
WINAPI
LockServiceDatabase(
    SC_HANDLE   hSCManager
    );

WINADVAPI
BOOL
WINAPI
NotifyBootConfigStatus(
    BOOL     BootAcceptable
    );

WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
#ifdef UNICODE
#define OpenSCManager  OpenSCManagerW
#else
#define OpenSCManager  OpenSCManagerA
#endif // !UNICODE

WINADVAPI
SC_HANDLE
WINAPI
OpenServiceA(
    SC_HANDLE   hSCManager,
    LPCSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
WINADVAPI
SC_HANDLE
WINAPI
OpenServiceW(
    SC_HANDLE   hSCManager,
    LPCWSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
#ifdef UNICODE
#define OpenService  OpenServiceW
#else
#define OpenService  OpenServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceConfigA(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
WINADVAPI
BOOL
WINAPI
QueryServiceConfigW(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceConfig  QueryServiceConfigW
#else
#define QueryServiceConfig  QueryServiceConfigA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceLockStatus  QueryServiceLockStatusW
#else
#define QueryServiceLockStatus  QueryServiceLockStatusA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );

WINADVAPI
BOOL
WINAPI
QueryServiceStatus(
    SC_HANDLE           hService,
    LPSERVICE_STATUS    lpServiceStatus
    );

WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerA(
    LPCSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerW(
    LPCWSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
#ifdef UNICODE
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerW
#else
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
SetServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

WINADVAPI
BOOL
WINAPI
SetServiceStatus(
    SERVICE_STATUS_HANDLE   hServiceStatus,
    LPSERVICE_STATUS        lpServiceStatus
    );

WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherA(
    LPSERVICE_TABLE_ENTRYA    lpServiceStartTable
    );
WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherW(
    LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
    );
#ifdef UNICODE
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherW
#else
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
StartServiceA(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCSTR             *lpServiceArgVectors
    );
WINADVAPI
BOOL
WINAPI
StartServiceW(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCWSTR             *lpServiceArgVectors
    );
#ifdef UNICODE
#define StartService  StartServiceW
#else
#define StartService  StartServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
UnlockServiceDatabase(
    SC_LOCK     ScLock
    );


#ifdef __cplusplus
}
#endif

#endif // _WINSVC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\nvdef.inc ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;
;       NVIDIA.INC - Compile options for NVidia MiniVDD
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/10/96
;
;       $Revision: 2 $
;       $Date: 10/15/97 1:27p $
;       $Logfile: /resman.040/win96/vdd/nvdef.inc $
;       $Log: /resman.040/win96/vdd/nvdef.inc $
; 
; 2     10/15/97 1:27p Jhinman
; Don't define DOS_REFRESH!
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 10    4/01/97 8:43p Jhinman
; Turn off debug msgs.
; 
; 9     1/31/97 6:00p Markk
; Added DETECT_LATE define.
; 
; 8     1/23/97 11:02a Markk
; Removed tabs.
; Fixed copyright.
; Put refresh support back in.
; Added GET_RM_MAP define to get linear addresses from resource manager.
; 
; 7     1/22/97 12:10p Markk
; Don't do refresh rate right away, test on IKOS without it first.
; 
; 6     1/14/97 3:41p Markk
; Setup defines for NV3.
; Added OLD_VESA30_REFRESH define to ifdef out the old frequency list
; scan.
; 
; 5     11/19/96 2:04p Markk
; Added DOS refresh rates.
; Removed NVDEB stuff.
; 
; 4     11/15/96 6:07p Markk
; Added NVIDIA_COMMON, NVIDIA_SIMULATE for simulating.
; Added REFRESH_INCLUDE to include refresh rate control.
; 
; 3     11/13/96 12:29p Markk
; Added TEST_PCI_NV1 define for testing the PCI code on NV1.
; 
; 2     11/01/96 3:58p Markk
; Added DEBUG_LOG define.
; 
; 1     10/16/96 9:16a Markk
; Contains compile time option settings for the VDD.
;

;DEBUG_LOG                       equ             1       ; Output debug info to debug device
NVIDIA_SPECIFIC                 equ             1       ; Assemble items specific to NVidia
;NVIDIA_SIMULATE                 equ             1       ; Simulate real mode access registers
NVIDIA_COMMON                   equ             1       ; Define if NVIDIA_SPECIFIC or NVIDIA_SIMULATE are defined!!!
;WEITEK_PROTO                   equ             1       ; Assemble items specific to Weitek
ALLOW_32K_VIRTUALIZATION        equ             1       ; Allow returning of a 32KB block for VGA 4 plane virtualization
;FAST_HIRES_SAVE_RESTORE                equ             1       ; Allow linear frame buffer hires save and restore
VESA30                          equ             1       ; Include VESA VBE 3.0
VESA30_REFRESH                  equ             1       ; Include VESA VBE 3.0 refresh rate definitions
;TEST_PCI_NV1                    equ             1       ; Test PCI code by searching for NV1
INCLUDE_REFRESH                 equ             1       ; Include refresh rate control
;DOS_REFRESH                     equ             1       ; Include refresh rate control for DirectX and DOS
;OLD_VESA30_REFRESH              equ             1       ; Include support for old VBE 3.0 dot clock method
GET_RM_MAP                      equ             1       ; Get linear addresses from resource manager
DETECT_LATE                     equ             1       ; Detect the chip later on
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WTYPES.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:29 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __wtypes_h__
#define __wtypes_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IWinTypes_INTERFACE_DEFINED__
#define __IWinTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWinTypes
 * at Fri Apr 28 07:02:29 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 8 */
typedef struct  tagRemHGLOBAL
    {
    long fNullHGlobal;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHGLOBAL;

			/* size is 16 */
typedef struct  tagRemHMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHMETAFILEPICT;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HMETAFILEPICT;

			/* size is 4 */
typedef struct  tagRemHENHMETAFILE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHENHMETAFILE;

			/* size is 4 */
typedef struct  tagRemHBITMAP
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHBITMAP;

			/* size is 4 */
typedef struct  tagRemHPALETTE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHPALETTE;

			/* size is 4 */
typedef struct  tagRemBRUSH
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHBRUSH;

#ifndef _WIN32           // The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers... 
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
			/* size is 1 */
typedef unsigned char BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
			/* size is 2 */
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
			/* size is 4 */
typedef /* [transmit] */ unsigned int UINT;

			/* size is 4 */
typedef /* [transmit] */ int INT;

			/* size is 4 */
typedef long BOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
			/* size is 4 */
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
			/* size is 4 */
typedef UINT WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
			/* size is 4 */
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
			/* size is 4 */
typedef LONG LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
			/* size is 4 */
typedef LONG LRESULT;

#endif // !_LRESULT_DEFINED
			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HANDLE;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HMODULE;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HINSTANCE;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HICON;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HFONT;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HGLOBAL;

			/* size is 4 */
typedef HGLOBAL HLOCAL;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HBITMAP;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HPALETTE;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HBRUSH;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HENHMETAFILE;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HDC;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HRGN;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HWND;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HMENU;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HACCEL;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HTASK;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HKEY;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HDESK;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HMF;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HEMF;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HMETAFILE;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HPEN;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HRSRC;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HSTR;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HWINSTA;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HKL;

			/* size is 4 */
typedef /* [transmit] */ void __RPC_FAR *HGDIOBJ;

			/* size is 4 */
typedef HANDLE HDWP;

#ifndef _HFILE_DEFINED
#define _HFILE_DEFINED
			/* size is 4 */
typedef INT HFILE;

#endif // !_HFILE_DEFINED
#ifndef _HCURSOR_DEFINED
#define _HCURSOR_DEFINED
			/* size is 4 */
typedef HICON HCURSOR;

#endif // !_HCURSOR_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
			/* size is 4 */
typedef WORD __RPC_FAR *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
			/* size is 4 */
typedef DWORD __RPC_FAR *LPDWORD;

#endif // !_LPDWORD_DEFINED
			/* size is 4 */
typedef /* [string] */ char __RPC_FAR *LPSTR;

			/* size is 4 */
typedef /* [string] */ const char __RPC_FAR *LPCSTR;

#ifndef _WCHAR_DEFINED
#define _WCHAR_DEFINED
			/* size is 2 */
typedef wchar_t WCHAR;

			/* size is 2 */
typedef WCHAR TCHAR;

#endif // !_WCHAR_DEFINED
			/* size is 4 */
typedef /* [string] */ WCHAR __RPC_FAR *LPWSTR;

			/* size is 4 */
typedef /* [string] */ TCHAR __RPC_FAR *LPTSTR;

			/* size is 4 */
typedef /* [string] */ const WCHAR __RPC_FAR *LPCWSTR;

			/* size is 4 */
typedef /* [string] */ const TCHAR __RPC_FAR *LPCTSTR;

			/* size is 4 */
typedef struct  tagPALETTEENTRY
    {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
    }	PALETTEENTRY;

			/* size is 4 */
typedef struct tagPALETTEENTRY __RPC_FAR *PPALETTEENTRY;

			/* size is 4 */
typedef struct tagPALETTEENTRY __RPC_FAR *LPPALETTEENTRY;

#if 0
			/* size is 4 */
typedef struct  tagLOGPALETTE
    {
    WORD palVersion;
    WORD palNumEntries;
    /* [size_is] */ PALETTEENTRY palPalEntry[ 1 ];
    }	LOGPALETTE;

			/* size is 4 */
typedef struct tagLOGPALETTE __RPC_FAR *PLOGPALETTE;

			/* size is 4 */
typedef struct tagLOGPALETTE __RPC_FAR *LPLOGPALETTE;

#else
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, *LPLOGPALETTE;
#endif
#ifndef _COLORREF_DEFINED
#define _COLORREF_DEFINED
			/* size is 4 */
typedef DWORD COLORREF;

#endif // !_COLORREF_DEFINED
#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
			/* size is 4 */
typedef DWORD __RPC_FAR *LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED
			/* size is 4 */
typedef HANDLE __RPC_FAR *LPHANDLE;

			/* size is 16 */
typedef struct  _RECTL
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    }	RECTL;

			/* size is 4 */
typedef struct _RECTL __RPC_FAR *PRECTL;

			/* size is 4 */
typedef struct _RECTL __RPC_FAR *LPRECTL;

			/* size is 8 */
typedef struct  tagPOINT
    {
    LONG x;
    LONG y;
    }	POINT;

			/* size is 4 */
typedef struct tagPOINT __RPC_FAR *PPOINT;

			/* size is 4 */
typedef struct tagPOINT __RPC_FAR *LPPOINT;

			/* size is 8 */
typedef struct  _POINTL
    {
    LONG x;
    LONG y;
    }	POINTL;

			/* size is 4 */
typedef struct _POINTL __RPC_FAR *PPOINTL;

#ifndef WIN16
			/* size is 8 */
typedef struct  tagSIZE
    {
    LONG cx;
    LONG cy;
    }	SIZE;

			/* size is 4 */
typedef struct tagSIZE __RPC_FAR *PSIZE;

			/* size is 4 */
typedef struct tagSIZE __RPC_FAR *LPSIZE;

#else // WIN16
typedef struct tagSIZE
{
    INT cx;
    INT cy;
} SIZE, *PSIZE, *LPSIZE;
#endif // WIN16
			/* size is 28 */
typedef struct  tagMSG
    {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
    }	MSG;

			/* size is 4 */
typedef struct tagMSG __RPC_FAR *PMSG;

			/* size is 4 */
typedef struct tagMSG __RPC_FAR *NPMSG;

			/* size is 4 */
typedef struct tagMSG __RPC_FAR *LPMSG;

			/* size is 8 */
typedef struct  tagSIZEL
    {
    LONG cx;
    LONG cy;
    }	SIZEL;

			/* size is 4 */
typedef struct tagSIZEL __RPC_FAR *PSIZEL;

			/* size is 4 */
typedef struct tagSIZEL __RPC_FAR *LPSIZEL;

#endif  //WINAPI
#endif  //!WIN32
#if defined(_WIN32) && !defined(OLE2ANSI)
			/* size is 2 */
typedef WCHAR OLECHAR;

			/* size is 4 */
typedef /* [string] */ OLECHAR __RPC_FAR *LPOLESTR;

			/* size is 4 */
typedef /* [string] */ const OLECHAR __RPC_FAR *LPCOLESTR;

#define OLESTR(str) L##str
#else
typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str
#endif
#ifndef _WINDEF_
			/* size is 4 */
typedef const RECTL __RPC_FAR *LPCRECTL;

			/* size is 4 */
typedef void __RPC_FAR *PVOID;

			/* size is 4 */
typedef void __RPC_FAR *LPVOID;

			/* size is 16 */
typedef struct  tagRECT
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    }	RECT;

			/* size is 4 */
typedef struct tagRECT __RPC_FAR *PRECT;

			/* size is 4 */
typedef struct tagRECT __RPC_FAR *LPRECT;

			/* size is 4 */
typedef const RECT __RPC_FAR *LPCRECT;

#endif  //_WINDEF_
			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 2 */
typedef short SHORT;

			/* size is 2 */
typedef unsigned short USHORT;

			/* size is 4 */
typedef DWORD ULONG;

#if 0
			/* size is 8 */
typedef hyper LONGLONG;

			/* size is 8 */
typedef MIDL_uhyper ULONGLONG;

			/* size is 4 */
typedef LONGLONG __RPC_FAR *PLONGLONG;

			/* size is 4 */
typedef ULONGLONG __RPC_FAR *PULONGLONG;

			/* size is 8 */
typedef struct  _LARGE_INTEGER
    {
    LONGLONG QuadPart;
    }	LARGE_INTEGER;

			/* size is 4 */
typedef LARGE_INTEGER __RPC_FAR *PLARGE_INTEGER;

			/* size is 8 */
typedef struct  _ULARGE_INTEGER
    {
    ULONGLONG QuadPart;
    }	ULARGE_INTEGER;

#endif // 
#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_
			/* size is 8 */
typedef struct  _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    }	FILETIME;

			/* size is 4 */
typedef struct _FILETIME __RPC_FAR *PFILETIME;

			/* size is 4 */
typedef struct _FILETIME __RPC_FAR *LPFILETIME;

#endif // !_FILETIME
#ifndef _SYSTEMTIME_
#define _SYSTEMTIME_
			/* size is 16 */
typedef struct  _SYSTEMTIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    }	SYSTEMTIME;

			/* size is 4 */
typedef struct _SYSTEMTIME __RPC_FAR *PSYSTEMTIME;

			/* size is 4 */
typedef struct _SYSTEMTIME __RPC_FAR *LPSYSTEMTIME;

#endif // !_SYSTEMTIME
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
			/* size is 12 */
typedef struct  _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;

			/* size is 4 */
typedef struct _SECURITY_ATTRIBUTES __RPC_FAR *PSECURITY_ATTRIBUTES;

			/* size is 4 */
typedef struct _SECURITY_ATTRIBUTES __RPC_FAR *LPSECURITY_ATTRIBUTES;

#endif // !_SECURITY_ATTRIBUTES_
#ifndef SECURITY_DESCRIPTOR_REVISION
			/* size is 2 */
typedef USHORT SECURITY_DESCRIPTOR_CONTROL;

			/* size is 4 */
typedef USHORT __RPC_FAR *PSECURITY_DESCRIPTOR_CONTROL;

			/* size is 4 */
typedef PVOID PSID;

			/* size is 8 */
typedef struct  _ACL
    {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
    }	ACL;

			/* size is 4 */
typedef ACL __RPC_FAR *PACL;

			/* size is 20 */
typedef struct  _SECURITY_DESCRIPTOR
    {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
    }	SECURITY_DESCRIPTOR;

			/* size is 4 */
typedef struct _SECURITY_DESCRIPTOR __RPC_FAR *PISECURITY_DESCRIPTOR;

#endif // !SECURITY_DESCRIPTOR_REVISION
#endif //_WINBASE_
			/* size is 4 */
typedef LONG SCODE;

			/* size is 4 */
typedef LONG HRESULT;

			/* size is 4 */
typedef SCODE __RPC_FAR *PSCODE;

#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED
#if !defined( __LPGUID_DEFINED__ )
#define __LPGUID_DEFINED__
			/* size is 4 */
typedef GUID __RPC_FAR *LPGUID;

#endif // !__LPGUID_DEFINED__
#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
			/* size is 20 */
typedef struct  _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    }	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if !defined( __IID_DEFINED__ )
#define __IID_DEFINED__
			/* size is 16 */
typedef GUID IID;

			/* size is 4 */
typedef IID __RPC_FAR *LPIID;

#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
			/* size is 16 */
typedef GUID CLSID;

			/* size is 4 */
typedef CLSID __RPC_FAR *LPCLSID;

#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
#if 0
			/* size is 4 */
typedef GUID __RPC_FAR *REFGUID;

			/* size is 4 */
typedef IID __RPC_FAR *REFIID;

			/* size is 4 */
typedef CLSID __RPC_FAR *REFCLSID;

#endif // 0
#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID &
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID &
#endif // !_REFCLSID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID * const
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID * const
#endif // !_REFCLSID_DEFINED
#endif // !__cplusplus
#endif // !__IID_DEFINED__
			/* size is 2 */
typedef 
enum tagMEMCTX
    {	MEMCTX_TASK	= 1,
	MEMCTX_SHARED	= 2,
	MEMCTX_MACSYSTEM	= 3,
	MEMCTX_UNKNOWN	= -1,
	MEMCTX_SAME	= -2
    }	MEMCTX;

#ifndef _ROTFLAGS_DEFINED
#define _ROTFLAGS_DEFINED
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 1
#endif // !_ROTFLAGS_DEFINED
#ifndef _ROT_COMPARE_MAX_DEFINED
#define _ROT_COMPARE_MAX_DEFINED
#define ROT_COMPARE_MAX 2048
#endif // !_ROT_COMPARE_MAX_DEFINED
			/* size is 2 */
typedef 
enum tagCLSCTX
    {	CLSCTX_INPROC_SERVER	= 1,
	CLSCTX_INPROC_HANDLER	= 2,
	CLSCTX_LOCAL_SERVER	= 4,
	CLSCTX_INPROC_SERVER16	= 8
    }	CLSCTX;

			/* size is 2 */
typedef 
enum tagMSHLFLAGS
    {	MSHLFLAGS_NORMAL	= 0,
	MSHLFLAGS_TABLESTRONG	= 1,
	MSHLFLAGS_TABLEWEAK	= 2
    }	MSHLFLAGS;

			/* size is 2 */
typedef 
enum tagMSHCTX
    {	MSHCTX_LOCAL	= 0,
	MSHCTX_NOSHAREDMEM	= 1,
	MSHCTX_DIFFERENTMACHINE	= 2,
	MSHCTX_INPROC	= 3
    }	MSHCTX;

			/* size is 2 */
typedef 
enum tagDVASPECT
    {	DVASPECT_CONTENT	= 1,
	DVASPECT_THUMBNAIL	= 2,
	DVASPECT_ICON	= 4,
	DVASPECT_DOCPRINT	= 8
    }	DVASPECT;

			/* size is 2 */
typedef 
enum tagSTGC
    {	STGC_DEFAULT	= 0,
	STGC_OVERWRITE	= 1,
	STGC_ONLYIFCURRENT	= 2,
	STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE	= 4
    }	STGC;

			/* size is 2 */
typedef 
enum tagSTGMOVE
    {	STGMOVE_MOVE	= 0,
	STGMOVE_COPY	= 1
    }	STGMOVE;

			/* size is 2 */
typedef 
enum tagSTATFLAG
    {	STATFLAG_DEFAULT	= 0,
	STATFLAG_NONAME	= 1
    }	STATFLAG;

			/* size is 4 */
typedef /* [context_handle] */ void __RPC_FAR *HCONTEXT;

#ifndef _LCID_DEFINED
#define _LCID_DEFINED
			/* size is 4 */
typedef DWORD LCID;

#endif // !_LCID_DEFINED
void __RPC_API HGLOBAL_to_xmit (HGLOBAL __RPC_FAR *, RemHGLOBAL __RPC_FAR * __RPC_FAR *);
void __RPC_API HGLOBAL_from_xmit (RemHGLOBAL __RPC_FAR *, HGLOBAL __RPC_FAR *);
void __RPC_API HGLOBAL_free_inst (HGLOBAL __RPC_FAR *);
void __RPC_API HGLOBAL_free_xmit (RemHGLOBAL __RPC_FAR *);
void __RPC_API HBITMAP_to_xmit (HBITMAP __RPC_FAR *, RemHBITMAP __RPC_FAR * __RPC_FAR *);
void __RPC_API HBITMAP_from_xmit (RemHBITMAP __RPC_FAR *, HBITMAP __RPC_FAR *);
void __RPC_API HBITMAP_free_inst (HBITMAP __RPC_FAR *);
void __RPC_API HBITMAP_free_xmit (RemHBITMAP __RPC_FAR *);
void __RPC_API HPALETTE_to_xmit (HPALETTE __RPC_FAR *, RemHPALETTE __RPC_FAR * __RPC_FAR *);
void __RPC_API HPALETTE_from_xmit (RemHPALETTE __RPC_FAR *, HPALETTE __RPC_FAR *);
void __RPC_API HPALETTE_free_inst (HPALETTE __RPC_FAR *);
void __RPC_API HPALETTE_free_xmit (RemHPALETTE __RPC_FAR *);
void __RPC_API HBRUSH_to_xmit (HBRUSH __RPC_FAR *, RemHBRUSH __RPC_FAR * __RPC_FAR *);
void __RPC_API HBRUSH_from_xmit (RemHBRUSH __RPC_FAR *, HBRUSH __RPC_FAR *);
void __RPC_API HBRUSH_free_inst (HBRUSH __RPC_FAR *);
void __RPC_API HBRUSH_free_xmit (RemHBRUSH __RPC_FAR *);
void __RPC_API HMETAFILEPICT_to_xmit (HMETAFILEPICT __RPC_FAR *, RemHMETAFILEPICT __RPC_FAR * __RPC_FAR *);
void __RPC_API HMETAFILEPICT_from_xmit (RemHMETAFILEPICT __RPC_FAR *, HMETAFILEPICT __RPC_FAR *);
void __RPC_API HMETAFILEPICT_free_inst (HMETAFILEPICT __RPC_FAR *);
void __RPC_API HMETAFILEPICT_free_xmit (RemHMETAFILEPICT __RPC_FAR *);
void __RPC_API HENHMETAFILE_to_xmit (HENHMETAFILE __RPC_FAR *, RemHENHMETAFILE __RPC_FAR * __RPC_FAR *);
void __RPC_API HENHMETAFILE_from_xmit (RemHENHMETAFILE __RPC_FAR *, HENHMETAFILE __RPC_FAR *);
void __RPC_API HENHMETAFILE_free_inst (HENHMETAFILE __RPC_FAR *);
void __RPC_API HENHMETAFILE_free_xmit (RemHENHMETAFILE __RPC_FAR *);


extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
#endif /* __IWinTypes_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\NVHW.H ===
#ifndef _NVHW_H_
#define _NVHW_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NVHW.H                                                            *
*       Resource Manager hardware access macros (OS specific).              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/


//
// HW register access macros.
//

#define REG_WR08(a,d)   nvAddr->Reg008[(a)]  =(U008)(d)
#define REG_WR16(a,d)   nvAddr->Reg016[(a)/2]=(U016)(d)
#define REG_WR32(a,d)   nvAddr->Reg032[(a)/4]=(U032)(d)
#define REG_RD08(a)     nvAddr->Reg008[(a)]
#define REG_RD16(a)     nvAddr->Reg016[(a)/2]
#define REG_RD32(a)     nvAddr->Reg032[(a)/4]
#define WriteIndexed(addr, datum) REG_WR08(addr, datum & 0xFF); REG_WR08(addr+1, (datum >> 8) & 0xFF);
#define ReadIndexed(addr, reg) ReadIndexedpDev(pDev,addr,reg)

/*
	The REG_WR..DIRECT() and REG_RD..DIRECT() macros are used to access the NV 
    registers given as system addresses.  System addresses of the registers
    are passed in.  A read is made directly from that address, without manipulation. 
*/
#define REG_WR08_DIRECT(a,d)   (*a)=(U008)(d)
#define REG_WR16_DIRECT(a,d)   (*a)=(U016)(d)
#define REG_WR32_DIRECT(a,d)   (*a)=(U032)(d)
#define REG_RD08_DIRECT(a)     (*a)
#define REG_RD16_DIRECT(a)     (*a)
#define REG_RD32_DIRECT(a)     (*a)


#define CFG_WR08(a,d)
#define CFG_WR16(a,d)
#define CFG_WR32(a,d)
#define CFG_RD08(a)
#define CFG_RD16(a)
#define CFG_RD32(a)

#define IO_WR08(a,d)    outp((a),(d))
#define IO_WR16(a,d)    outpw((a),(d))
#define IO_WR32(a,d)    outpdw((a),(d))
#define IO_RD08(a)      inp(a)
#define IO_RD16(a)      inpw(a)
#define IO_RD32(a)      inpdw(a)

#define ROM_RD08(a)     (romAddr->Reg008[(a)])
#define ROM_RD16(a)     (romAddr->Reg008[(a)]          \
                        |(romAddr->Reg008[(a)+1]<<8))
#define ROM_RD32(a)     (romAddr->Reg008[(a)]          \
                        |(romAddr->Reg008[(a)+1]<<8)   \
                        |(romAddr->Reg008[(a)+2]<<16)  \
                        |(romAddr->Reg008[(a)+3]<<24))
                        
#define BIOS_RD08(a)     (biosAddr->Reg008[(a)])
#define BIOS_RD16(a)     (biosAddr->Reg008[(a)]          \
                        |(biosAddr->Reg008[(a)+1]<<8))
#define BIOS_RD32(a)     (biosAddr->Reg008[(a)]          \
                        |(biosAddr->Reg008[(a)+1]<<8)   \
                        |(biosAddr->Reg008[(a)+2]<<16)  \
                        |(biosAddr->Reg008[(a)+3]<<24))

#if 0                        
//
// HW register access macros, based on dumb frame buffer address.
//

#define MEM_BASE        (0?NV_PDFB)
#define MEM_WR08(a,d)   fbAddr->Reg008[(a-MEM_BASE)]  =(U008)(d)
#define MEM_WR16(a,d)   fbAddr->Reg016[(a-MEM_BASE)/2]=(U016)(d)
#define MEM_WR32(a,d)   fbAddr->Reg032[(a-MEM_BASE)/4]=(U032)(d)
#define MEM_RD08(a)     fbAddr->Reg008[(a-MEM_BASE)]
#define MEM_RD16(a)     fbAddr->Reg016[(a-MEM_BASE)/2]
#define MEM_RD32(a)     fbAddr->Reg032[(a-MEM_BASE)/4]
#else
#define FB_WR08(a,d)   fbAddr->Reg008[(a)  ] = (U008)(d)
#define FB_WR16(a,d)   fbAddr->Reg016[(a)/2] = (U016)(d)
#define FB_WR32(a,d)   fbAddr->Reg032[(a)/4] = (U032)(d)
#define FB_RD08(a)     fbAddr->Reg008[(a)  ]
#define FB_RD16(a)     fbAddr->Reg016[(a)/2]
#define FB_RD32(a)     fbAddr->Reg032[(a)/4]
#endif

#define INST_DIRECT_WR32(a,d)    nvAddr->Reg032[(pDev->Pram.HalInfo.PraminOffset+a)/4]=(U032)(d)
#define INST_DIRECT_RD32(a)      nvAddr->Reg032[(pDev->Pram.HalInfo.PraminOffset+a)/4]

#define channelInfo clientInfo[ClientInstance].CliDeviceList[DeviceInstance].DevFifoList

#endif // _NVHW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINSPOOL.H ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    WinSpool.h

Abstract:

    Header file for Print APIs

Revision History:

--*/

#ifndef _WINSPOOL_
#define _WINSPOOL_


#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0400)
#include <prsht.h>
#endif /* WINVER >= 0x0400 */

typedef struct _PRINTER_INFO_1A {
    DWORD   Flags;
    LPSTR   pDescription;
    LPSTR   pName;
    LPSTR   pComment;
} PRINTER_INFO_1A, *PPRINTER_INFO_1A, *LPPRINTER_INFO_1A;
typedef struct _PRINTER_INFO_1W {
    DWORD   Flags;
    LPWSTR  pDescription;
    LPWSTR  pName;
    LPWSTR  pComment;
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;
#ifdef UNICODE
typedef PRINTER_INFO_1W PRINTER_INFO_1;
typedef PPRINTER_INFO_1W PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1W LPPRINTER_INFO_1;
#else
typedef PRINTER_INFO_1A PRINTER_INFO_1;
typedef PPRINTER_INFO_1A PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1A LPPRINTER_INFO_1;
#endif // UNICODE

typedef struct _PRINTER_INFO_2A {
    LPSTR     pServerName;
    LPSTR     pPrinterName;
    LPSTR     pShareName;
    LPSTR     pPortName;
    LPSTR     pDriverName;
    LPSTR     pComment;
    LPSTR     pLocation;
    LPDEVMODEA pDevMode;
    LPSTR     pSepFile;
    LPSTR     pPrintProcessor;
    LPSTR     pDatatype;
    LPSTR     pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2A, *PPRINTER_INFO_2A, *LPPRINTER_INFO_2A;
typedef struct _PRINTER_INFO_2W {
    LPWSTR    pServerName;
    LPWSTR    pPrinterName;
    LPWSTR    pShareName;
    LPWSTR    pPortName;
    LPWSTR    pDriverName;
    LPWSTR    pComment;
    LPWSTR    pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR    pSepFile;
    LPWSTR    pPrintProcessor;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;
#ifdef UNICODE
typedef PRINTER_INFO_2W PRINTER_INFO_2;
typedef PPRINTER_INFO_2W PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2W LPPRINTER_INFO_2;
#else
typedef PRINTER_INFO_2A PRINTER_INFO_2;
typedef PPRINTER_INFO_2A PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2A LPPRINTER_INFO_2;
#endif // UNICODE

typedef struct _PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

typedef struct _PRINTER_INFO_4A {
    LPSTR   pPrinterName;
    LPSTR   pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;
typedef struct _PRINTER_INFO_4W {
    LPWSTR  pPrinterName;
    LPWSTR  pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;
#ifdef UNICODE
typedef PRINTER_INFO_4W PRINTER_INFO_4;
typedef PPRINTER_INFO_4W PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4W LPPRINTER_INFO_4;
#else
typedef PRINTER_INFO_4A PRINTER_INFO_4;
typedef PPRINTER_INFO_4A PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4A LPPRINTER_INFO_4;
#endif // UNICODE

#if(WINVER >= 0x0400)
typedef struct _PRINTER_INFO_5A {
    LPSTR   pPrinterName;
    LPSTR   pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5A, *PPRINTER_INFO_5A, *LPPRINTER_INFO_5A;
typedef struct _PRINTER_INFO_5W {
    LPWSTR  pPrinterName;
    LPWSTR  pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;
#ifdef UNICODE
typedef PRINTER_INFO_5W PRINTER_INFO_5;
typedef PPRINTER_INFO_5W PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5W LPPRINTER_INFO_5;
#else
typedef PRINTER_INFO_5A PRINTER_INFO_5;
typedef PPRINTER_INFO_5A PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5A LPPRINTER_INFO_5;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

#define PRINTER_CONTROL_PAUSE            1
#define PRINTER_CONTROL_RESUME           2
#define PRINTER_CONTROL_PURGE            3
#if(WINVER >= 0x0400)
#define PRINTER_CONTROL_SET_STATUS       4
#endif /* WINVER >= 0x0400 */

#define PRINTER_STATUS_PAUSED            0x00000001
#define PRINTER_STATUS_ERROR             0x00000002
#define PRINTER_STATUS_PENDING_DELETION  0x00000004
#define PRINTER_STATUS_PAPER_JAM         0x00000008
#define PRINTER_STATUS_PAPER_OUT         0x00000010
#define PRINTER_STATUS_MANUAL_FEED       0x00000020
#define PRINTER_STATUS_PAPER_PROBLEM     0x00000040
#define PRINTER_STATUS_OFFLINE           0x00000080
#define PRINTER_STATUS_IO_ACTIVE         0x00000100
#define PRINTER_STATUS_BUSY              0x00000200
#define PRINTER_STATUS_PRINTING          0x00000400
#define PRINTER_STATUS_OUTPUT_BIN_FULL   0x00000800
#define PRINTER_STATUS_NOT_AVAILABLE     0x00001000
#define PRINTER_STATUS_WAITING           0x00002000
#define PRINTER_STATUS_PROCESSING        0x00004000
#define PRINTER_STATUS_INITIALIZING      0x00008000
#define PRINTER_STATUS_WARMING_UP        0x00010000
#define PRINTER_STATUS_TONER_LOW         0x00020000
#define PRINTER_STATUS_NO_TONER          0x00040000
#define PRINTER_STATUS_PAGE_PUNT         0x00080000
#define PRINTER_STATUS_USER_INTERVENTION 0x00100000
#define PRINTER_STATUS_OUT_OF_MEMORY     0x00200000
#define PRINTER_STATUS_DOOR_OPEN         0x00400000
#define PRINTER_STATUS_SERVER_UNKNOWN    0x00800000
#if(WINVER >= 0x0400)
#define PRINTER_STATUS_POWER_SAVE        0x01000000
#endif /* WINVER >= 0x0400 */


#define PRINTER_ATTRIBUTE_QUEUED         0x00000001
#define PRINTER_ATTRIBUTE_DIRECT         0x00000002
#define PRINTER_ATTRIBUTE_DEFAULT        0x00000004
#define PRINTER_ATTRIBUTE_SHARED         0x00000008
#define PRINTER_ATTRIBUTE_NETWORK        0x00000010
#define PRINTER_ATTRIBUTE_HIDDEN         0x00000020
#define PRINTER_ATTRIBUTE_LOCAL          0x00000040

#define PRINTER_ATTRIBUTE_ENABLE_DEVQ       0x00000080
#define PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS   0x00000100
#define PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST 0x00000200

#if(WINVER >= 0x0400)
#define PRINTER_ATTRIBUTE_WORK_OFFLINE   0x00000400
#define PRINTER_ATTRIBUTE_ENABLE_BIDI    0x00000800
#endif /* WINVER >= 0x0400 */



#define NO_PRIORITY   0
#define MAX_PRIORITY 99
#define MIN_PRIORITY  1
#define DEF_PRIORITY  1

typedef struct _JOB_INFO_1A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pDatatype;
   LPSTR      pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1A, *PJOB_INFO_1A, *LPJOB_INFO_1A;
typedef struct _JOB_INFO_1W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pDatatype;
   LPWSTR     pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1W, *PJOB_INFO_1W, *LPJOB_INFO_1W;
#ifdef UNICODE
typedef JOB_INFO_1W JOB_INFO_1;
typedef PJOB_INFO_1W PJOB_INFO_1;
typedef LPJOB_INFO_1W LPJOB_INFO_1;
#else
typedef JOB_INFO_1A JOB_INFO_1;
typedef PJOB_INFO_1A PJOB_INFO_1;
typedef LPJOB_INFO_1A LPJOB_INFO_1;
#endif // UNICODE

typedef struct _JOB_INFO_2A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pNotifyName;
   LPSTR      pDatatype;
   LPSTR      pPrintProcessor;
   LPSTR      pParameters;
   LPSTR      pDriverName;
   LPDEVMODEA pDevMode;
   LPSTR      pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled
   DWORD    Time;           // How many seconds the job has been printing
   DWORD    PagesPrinted;
} JOB_INFO_2A, *PJOB_INFO_2A, *LPJOB_INFO_2A;
typedef struct _JOB_INFO_2W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pNotifyName;
   LPWSTR     pDatatype;
   LPWSTR     pPrintProcessor;
   LPWSTR     pParameters;
   LPWSTR     pDriverName;
   LPDEVMODEW pDevMode;
   LPWSTR     pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled
   DWORD    Time;           // How many seconds the job has been printing
   DWORD    PagesPrinted;
} JOB_INFO_2W, *PJOB_INFO_2W, *LPJOB_INFO_2W;
#ifdef UNICODE
typedef JOB_INFO_2W JOB_INFO_2;
typedef PJOB_INFO_2W PJOB_INFO_2;
typedef LPJOB_INFO_2W LPJOB_INFO_2;
#else
typedef JOB_INFO_2A JOB_INFO_2;
typedef PJOB_INFO_2A PJOB_INFO_2;
typedef LPJOB_INFO_2A LPJOB_INFO_2;
#endif // UNICODE

#define JOB_CONTROL_PAUSE              1
#define JOB_CONTROL_RESUME             2
#define JOB_CONTROL_CANCEL             3
#define JOB_CONTROL_RESTART            4
#if(WINVER >= 0x0400)
#define JOB_CONTROL_DELETE             5
#endif /* WINVER >= 0x0400 */

#define JOB_STATUS_PAUSED       0x00000001
#define JOB_STATUS_ERROR        0x00000002
#define JOB_STATUS_DELETING     0x00000004
#define JOB_STATUS_SPOOLING     0x00000008
#define JOB_STATUS_PRINTING     0x00000010
#define JOB_STATUS_OFFLINE      0x00000020
#define JOB_STATUS_PAPEROUT     0x00000040
#define JOB_STATUS_PRINTED      0x00000080
#define JOB_STATUS_DELETED      0x00000100
#define JOB_STATUS_BLOCKED_DEVQ 0x00000200
#if(WINVER >= 0x0400)
#define JOB_STATUS_USER_INTERVENTION   0x00000400
#endif /* WINVER >= 0x0400 */

#define JOB_POSITION_UNSPECIFIED       0

typedef struct _ADDJOB_INFO_1A {
    LPSTR     Path;
    DWORD   JobId;
} ADDJOB_INFO_1A, *PADDJOB_INFO_1A, *LPADDJOB_INFO_1A;
typedef struct _ADDJOB_INFO_1W {
    LPWSTR    Path;
    DWORD   JobId;
} ADDJOB_INFO_1W, *PADDJOB_INFO_1W, *LPADDJOB_INFO_1W;
#ifdef UNICODE
typedef ADDJOB_INFO_1W ADDJOB_INFO_1;
typedef PADDJOB_INFO_1W PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1W LPADDJOB_INFO_1;
#else
typedef ADDJOB_INFO_1A ADDJOB_INFO_1;
typedef PADDJOB_INFO_1A PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1A LPADDJOB_INFO_1;
#endif // UNICODE

typedef struct _DRIVER_INFO_1A {
    LPSTR     pName;              // QMS 810
} DRIVER_INFO_1A, *PDRIVER_INFO_1A, *LPDRIVER_INFO_1A;
typedef struct _DRIVER_INFO_1W {
    LPWSTR    pName;              // QMS 810
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;
#ifdef UNICODE
typedef DRIVER_INFO_1W DRIVER_INFO_1;
typedef PDRIVER_INFO_1W PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1W LPDRIVER_INFO_1;
#else
typedef DRIVER_INFO_1A DRIVER_INFO_1;
typedef PDRIVER_INFO_1A PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1A LPDRIVER_INFO_1;
#endif // UNICODE

typedef struct _DRIVER_INFO_2A {
    DWORD   cVersion;
    LPSTR     pName;              // QMS 810
    LPSTR     pEnvironment;       // Win32 x86
    LPSTR     pDriverPath;        // c:\drivers\pscript.dll
    LPSTR     pDataFile;          // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2A, *PDRIVER_INFO_2A, *LPDRIVER_INFO_2A;
typedef struct _DRIVER_INFO_2W {
    DWORD   cVersion;
    LPWSTR    pName;              // QMS 810
    LPWSTR    pEnvironment;       // Win32 x86
    LPWSTR    pDriverPath;        // c:\drivers\pscript.dll
    LPWSTR    pDataFile;          // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;
#ifdef UNICODE
typedef DRIVER_INFO_2W DRIVER_INFO_2;
typedef PDRIVER_INFO_2W PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2W LPDRIVER_INFO_2;
#else
typedef DRIVER_INFO_2A DRIVER_INFO_2;
typedef PDRIVER_INFO_2A PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2A LPDRIVER_INFO_2;
#endif // UNICODE

#if(WINVER >= 0x0400)
typedef struct _DRIVER_INFO_3A {
    DWORD   cVersion;
    LPSTR     pName;                    // QMS 810
    LPSTR     pEnvironment;             // Win32 x86
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPSTR     pMonitorName;             // "PJL monitor"
    LPSTR     pDefaultDataType;         // "EMF"
} DRIVER_INFO_3A, *PDRIVER_INFO_3A, *LPDRIVER_INFO_3A;
typedef struct _DRIVER_INFO_3W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;
#ifdef UNICODE
typedef DRIVER_INFO_3W DRIVER_INFO_3;
typedef PDRIVER_INFO_3W PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3W LPDRIVER_INFO_3;
#else
typedef DRIVER_INFO_3A DRIVER_INFO_3;
typedef PDRIVER_INFO_3A PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3A LPDRIVER_INFO_3;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

typedef struct _DOC_INFO_1A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
} DOC_INFO_1A, *PDOC_INFO_1A, *LPDOC_INFO_1A;
typedef struct _DOC_INFO_1W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;
#ifdef UNICODE
typedef DOC_INFO_1W DOC_INFO_1;
typedef PDOC_INFO_1W PDOC_INFO_1;
typedef LPDOC_INFO_1W LPDOC_INFO_1;
#else
typedef DOC_INFO_1A DOC_INFO_1;
typedef PDOC_INFO_1A PDOC_INFO_1;
typedef LPDOC_INFO_1A LPDOC_INFO_1;
#endif // UNICODE

typedef struct _FORM_INFO_1A {
    DWORD   Flags;
    LPSTR     pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1A, *PFORM_INFO_1A, *LPFORM_INFO_1A;
typedef struct _FORM_INFO_1W {
    DWORD   Flags;
    LPWSTR    pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;
#ifdef UNICODE
typedef FORM_INFO_1W FORM_INFO_1;
typedef PFORM_INFO_1W PFORM_INFO_1;
typedef LPFORM_INFO_1W LPFORM_INFO_1;
#else
typedef FORM_INFO_1A FORM_INFO_1;
typedef PFORM_INFO_1A PFORM_INFO_1;
typedef LPFORM_INFO_1A LPFORM_INFO_1;
#endif // UNICODE

#if(WINVER >= 0x0400)
typedef struct _DOC_INFO_2A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2A, *PDOC_INFO_2A, *LPDOC_INFO_2A;
typedef struct _DOC_INFO_2W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2W, *PDOC_INFO_2W, *LPDOC_INFO_2W;
#ifdef UNICODE
typedef DOC_INFO_2W DOC_INFO_2;
typedef PDOC_INFO_2W PDOC_INFO_2;
typedef LPDOC_INFO_2W LPDOC_INFO_2;
#else
typedef DOC_INFO_2A DOC_INFO_2;
typedef PDOC_INFO_2A PDOC_INFO_2;
typedef LPDOC_INFO_2A LPDOC_INFO_2;
#endif // UNICODE

#define DI_CHANNEL              1    // start direct read/write channel,
#define DI_CHANNEL_WRITE        2    // Direct write only - background read thread ok
#define DI_READ_SPOOL_JOB       3

#endif /* WINVER >= 0x0400 */

#define FORM_BUILTIN    0x00000001


typedef struct _PRINTPROCESSOR_INFO_1A {
    LPSTR     pName;
} PRINTPROCESSOR_INFO_1A, *PPRINTPROCESSOR_INFO_1A, *LPPRINTPROCESSOR_INFO_1A;
typedef struct _PRINTPROCESSOR_INFO_1W {
    LPWSTR    pName;
} PRINTPROCESSOR_INFO_1W, *PPRINTPROCESSOR_INFO_1W, *LPPRINTPROCESSOR_INFO_1W;
#ifdef UNICODE
typedef PRINTPROCESSOR_INFO_1W PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1W PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1W LPPRINTPROCESSOR_INFO_1;
#else
typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1A PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1A LPPRINTPROCESSOR_INFO_1;
#endif // UNICODE

typedef struct _PORT_INFO_1A {
    LPSTR     pName;
} PORT_INFO_1A, *PPORT_INFO_1A, *LPPORT_INFO_1A;
typedef struct _PORT_INFO_1W {
    LPWSTR    pName;
} PORT_INFO_1W, *PPORT_INFO_1W, *LPPORT_INFO_1W;
#ifdef UNICODE
typedef PORT_INFO_1W PORT_INFO_1;
typedef PPORT_INFO_1W PPORT_INFO_1;
typedef LPPORT_INFO_1W LPPORT_INFO_1;
#else
typedef PORT_INFO_1A PORT_INFO_1;
typedef PPORT_INFO_1A PPORT_INFO_1;
typedef LPPORT_INFO_1A LPPORT_INFO_1;
#endif // UNICODE

#if(WINVER >= 0x0400)
typedef struct _PORT_INFO_2A {
    LPSTR     pPortName;
    LPSTR     pMonitorName;
    LPSTR     pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2A, *PPORT_INFO_2A, *LPPORT_INFO_2A;
typedef struct _PORT_INFO_2W {
    LPWSTR    pPortName;
    LPWSTR    pMonitorName;
    LPWSTR    pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2W, *PPORT_INFO_2W, *LPPORT_INFO_2W;
#ifdef UNICODE
typedef PORT_INFO_2W PORT_INFO_2;
typedef PPORT_INFO_2W PPORT_INFO_2;
typedef LPPORT_INFO_2W LPPORT_INFO_2;
#else
typedef PORT_INFO_2A PORT_INFO_2;
typedef PPORT_INFO_2A PPORT_INFO_2;
typedef LPPORT_INFO_2A LPPORT_INFO_2;
#endif // UNICODE

#define PORT_TYPE_WRITE         0x0001
#define PORT_TYPE_READ          0x0002
#define PORT_TYPE_REDIRECTED    0x0004
#define PORT_TYPE_NET_ATTACHED  0x0008
#endif /* WINVER >= 0x0400 */

typedef struct _MONITOR_INFO_1A{
    LPSTR     pName;
} MONITOR_INFO_1A, *PMONITOR_INFO_1A, *LPMONITOR_INFO_1A;
typedef struct _MONITOR_INFO_1W{
    LPWSTR    pName;
} MONITOR_INFO_1W, *PMONITOR_INFO_1W, *LPMONITOR_INFO_1W;
#ifdef UNICODE
typedef MONITOR_INFO_1W MONITOR_INFO_1;
typedef PMONITOR_INFO_1W PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1W LPMONITOR_INFO_1;
#else
typedef MONITOR_INFO_1A MONITOR_INFO_1;
typedef PMONITOR_INFO_1A PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1A LPMONITOR_INFO_1;
#endif // UNICODE

typedef struct _MONITOR_INFO_2A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} MONITOR_INFO_2A, *PMONITOR_INFO_2A, *LPMONITOR_INFO_2A;
typedef struct _MONITOR_INFO_2W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} MONITOR_INFO_2W, *PMONITOR_INFO_2W, *LPMONITOR_INFO_2W;
#ifdef UNICODE
typedef MONITOR_INFO_2W MONITOR_INFO_2;
typedef PMONITOR_INFO_2W PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2W LPMONITOR_INFO_2;
#else
typedef MONITOR_INFO_2A MONITOR_INFO_2;
typedef PMONITOR_INFO_2A PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2A LPMONITOR_INFO_2;
#endif // UNICODE

typedef struct _DATATYPES_INFO_1A{
    LPSTR     pName;
} DATATYPES_INFO_1A, *PDATATYPES_INFO_1A, *LPDATATYPES_INFO_1A;
typedef struct _DATATYPES_INFO_1W{
    LPWSTR    pName;
} DATATYPES_INFO_1W, *PDATATYPES_INFO_1W, *LPDATATYPES_INFO_1W;
#ifdef UNICODE
typedef DATATYPES_INFO_1W DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1W PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1W LPDATATYPES_INFO_1;
#else
typedef DATATYPES_INFO_1A DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1A PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1A LPDATATYPES_INFO_1;
#endif // UNICODE

typedef struct _PRINTER_DEFAULTSA{
    LPSTR         pDatatype;
    LPDEVMODEA pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA;
typedef struct _PRINTER_DEFAULTSW{
    LPWSTR        pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;
#ifdef UNICODE
typedef PRINTER_DEFAULTSW PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSW PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSW LPPRINTER_DEFAULTS;
#else
typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSA PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSA LPPRINTER_DEFAULTS;
#endif // UNICODE

BOOL
WINAPI
EnumPrintersA(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumPrintersW(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPrinters  EnumPrintersW
#else
#define EnumPrinters  EnumPrintersA
#endif // !UNICODE

#define PRINTER_ENUM_DEFAULT     0x00000001
#define PRINTER_ENUM_LOCAL       0x00000002
#define PRINTER_ENUM_CONNECTIONS 0x00000004
#define PRINTER_ENUM_FAVORITE    0x00000004
#define PRINTER_ENUM_NAME        0x00000008
#define PRINTER_ENUM_REMOTE      0x00000010
#define PRINTER_ENUM_SHARED      0x00000020
#define PRINTER_ENUM_NETWORK     0x00000040

#define PRINTER_ENUM_EXPAND      0x00004000
#define PRINTER_ENUM_CONTAINER   0x00008000

#define PRINTER_ENUM_ICONMASK    0x00ff0000
#define PRINTER_ENUM_ICON1       0x00010000
#define PRINTER_ENUM_ICON2       0x00020000
#define PRINTER_ENUM_ICON3       0x00040000
#define PRINTER_ENUM_ICON4       0x00080000
#define PRINTER_ENUM_ICON5       0x00100000
#define PRINTER_ENUM_ICON6       0x00200000
#define PRINTER_ENUM_ICON7       0x00400000
#define PRINTER_ENUM_ICON8       0x00800000

BOOL
WINAPI
OpenPrinterA(
   LPSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSA pDefault
);
BOOL
WINAPI
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);
#ifdef UNICODE
#define OpenPrinter  OpenPrinterW
#else
#define OpenPrinter  OpenPrinterA
#endif // !UNICODE

BOOL
WINAPI
ResetPrinterA(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSA pDefault
);
BOOL
WINAPI
ResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
);
#ifdef UNICODE
#define ResetPrinter  ResetPrinterW
#else
#define ResetPrinter  ResetPrinterA
#endif // !UNICODE

BOOL
WINAPI
SetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);
BOOL
WINAPI
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);
#ifdef UNICODE
#define SetJob  SetJobW
#else
#define SetJob  SetJobA
#endif // !UNICODE

BOOL
WINAPI
GetJobA(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);
BOOL
WINAPI
GetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);
#ifdef UNICODE
#define GetJob  GetJobW
#else
#define GetJob  GetJobA
#endif // !UNICODE

BOOL
WINAPI
EnumJobsA(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumJobs  EnumJobsW
#else
#define EnumJobs  EnumJobsA
#endif // !UNICODE

HANDLE
WINAPI
AddPrinterA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);
HANDLE
WINAPI
AddPrinterW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);
#ifdef UNICODE
#define AddPrinter  AddPrinterW
#else
#define AddPrinter  AddPrinterA
#endif // !UNICODE

BOOL
WINAPI
DeletePrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
SetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);
BOOL
WINAPI
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);
#ifdef UNICODE
#define SetPrinter  SetPrinterW
#else
#define SetPrinter  SetPrinterA
#endif // !UNICODE

BOOL
WINAPI
GetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
WINAPI
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetPrinter  GetPrinterW
#else
#define GetPrinter  GetPrinterA
#endif // !UNICODE

BOOL
WINAPI
AddPrinterDriverA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);
BOOL
WINAPI
AddPrinterDriverW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);
#ifdef UNICODE
#define AddPrinterDriver  AddPrinterDriverW
#else
#define AddPrinterDriver  AddPrinterDriverA
#endif // !UNICODE

BOOL
WINAPI
EnumPrinterDriversA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumPrinterDriversW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPrinterDrivers  EnumPrinterDriversW
#else
#define EnumPrinterDrivers  EnumPrinterDriversA
#endif // !UNICODE

BOOL
WINAPI
GetPrinterDriverA(
    HANDLE  hPrinter,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
WINAPI
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetPrinterDriver  GetPrinterDriverW
#else
#define GetPrinterDriver  GetPrinterDriverA
#endif // !UNICODE

BOOL
WINAPI
GetPrinterDriverDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
WINAPI
GetPrinterDriverDirectoryW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetPrinterDriverDirectory  GetPrinterDriverDirectoryW
#else
#define GetPrinterDriverDirectory  GetPrinterDriverDirectoryA
#endif // !UNICODE

BOOL
WINAPI
DeletePrinterDriverA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName
);
BOOL
WINAPI
DeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
);
#ifdef UNICODE
#define DeletePrinterDriver  DeletePrinterDriverW
#else
#define DeletePrinterDriver  DeletePrinterDriverA
#endif // !UNICODE

BOOL
WINAPI
AddPrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPathName,
    LPSTR   pPrintProcessorName
);
BOOL
WINAPI
AddPrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
);
#ifdef UNICODE
#define AddPrintProcessor  AddPrintProcessorW
#else
#define AddPrintProcessor  AddPrintProcessorA
#endif // !UNICODE

BOOL
WINAPI
EnumPrintProcessorsA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumPrintProcessorsW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPrintProcessors  EnumPrintProcessorsW
#else
#define EnumPrintProcessors  EnumPrintProcessorsA
#endif // !UNICODE



BOOL
WINAPI
GetPrintProcessorDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
WINAPI
GetPrintProcessorDirectoryW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetPrintProcessorDirectory  GetPrintProcessorDirectoryW
#else
#define GetPrintProcessorDirectory  GetPrintProcessorDirectoryA
#endif // !UNICODE

BOOL
WINAPI
EnumPrintProcessorDatatypesA(
    LPSTR   pName,
    LPSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumPrintProcessorDatatypesW(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPrintProcessorDatatypes  EnumPrintProcessorDatatypesW
#else
#define EnumPrintProcessorDatatypes  EnumPrintProcessorDatatypesA
#endif // !UNICODE

BOOL
WINAPI
DeletePrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProcessorName
);
BOOL
WINAPI
DeletePrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPrintProcessorName
);
#ifdef UNICODE
#define DeletePrintProcessor  DeletePrintProcessorW
#else
#define DeletePrintProcessor  DeletePrintProcessorA
#endif // !UNICODE

DWORD
WINAPI
StartDocPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);
DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);
#ifdef UNICODE
#define StartDocPrinter  StartDocPrinterW
#else
#define StartDocPrinter  StartDocPrinterA
#endif // !UNICODE

BOOL
WINAPI
StartPagePrinter(
    HANDLE  hPrinter
);

BOOL
WINAPI
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
WINAPI
EndPagePrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
AbortPrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
);

BOOL
WINAPI
EndDocPrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
AddJobA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
WINAPI
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#ifdef UNICODE
#define AddJob  AddJobW
#else
#define AddJob  AddJobA
#endif // !UNICODE

BOOL
WINAPI
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

BOOL
WINAPI
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
);

LONG
WINAPI
DocumentPropertiesA(
    HWND      hWnd,
    HANDLE    hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput,
    DWORD     fMode
);
LONG
WINAPI
DocumentPropertiesW(
    HWND      hWnd,
    HANDLE    hPrinter,
    LPWSTR   pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput,
    DWORD     fMode
);
#ifdef UNICODE
#define DocumentProperties  DocumentPropertiesW
#else
#define DocumentProperties  DocumentPropertiesA
#endif // !UNICODE

LONG
WINAPI
AdvancedDocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput
);
LONG
WINAPI
AdvancedDocumentPropertiesW(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPWSTR   pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput
);
#ifdef UNICODE
#define AdvancedDocumentProperties  AdvancedDocumentPropertiesW
#else
#define AdvancedDocumentProperties  AdvancedDocumentPropertiesA
#endif // !UNICODE



DWORD
WINAPI
GetPrinterDataA(
    HANDLE   hPrinter,
    LPSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);
DWORD
WINAPI
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);
#ifdef UNICODE
#define GetPrinterData  GetPrinterDataW
#else
#define GetPrinterData  GetPrinterDataA
#endif // !UNICODE



DWORD
WINAPI
SetPrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);
DWORD
WINAPI
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);
#ifdef UNICODE
#define SetPrinterData  SetPrinterDataW
#else
#define SetPrinterData  SetPrinterDataA
#endif // !UNICODE

#define PRINTER_NOTIFY_TYPE 0x00
#define JOB_NOTIFY_TYPE     0x01

#define PRINTER_NOTIFY_FIELD_SERVER_NAME             0x00
#define PRINTER_NOTIFY_FIELD_PRINTER_NAME            0x01
#define PRINTER_NOTIFY_FIELD_SHARE_NAME              0x02
#define PRINTER_NOTIFY_FIELD_PORT_NAME               0x03
#define PRINTER_NOTIFY_FIELD_DRIVER_NAME             0x04
#define PRINTER_NOTIFY_FIELD_COMMENT                 0x05
#define PRINTER_NOTIFY_FIELD_LOCATION                0x06
#define PRINTER_NOTIFY_FIELD_DEVMODE                 0x07
#define PRINTER_NOTIFY_FIELD_SEPFILE                 0x08
#define PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR         0x09
#define PRINTER_NOTIFY_FIELD_PARAMETERS              0x0A
#define PRINTER_NOTIFY_FIELD_DATATYPE                0x0B
#define PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR     0x0C
#define PRINTER_NOTIFY_FIELD_ATTRIBUTES              0x0D
#define PRINTER_NOTIFY_FIELD_PRIORITY                0x0E
#define PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY        0x0F
#define PRINTER_NOTIFY_FIELD_START_TIME              0x10
#define PRINTER_NOTIFY_FIELD_UNTIL_TIME              0x11
#define PRINTER_NOTIFY_FIELD_STATUS                  0x12
#define PRINTER_NOTIFY_FIELD_STATUS_STRING           0x13
#define PRINTER_NOTIFY_FIELD_CJOBS                   0x14
#define PRINTER_NOTIFY_FIELD_AVERAGE_PPM             0x15
#define PRINTER_NOTIFY_FIELD_TOTAL_PAGES             0x16
#define PRINTER_NOTIFY_FIELD_PAGES_PRINTED           0x17
#define PRINTER_NOTIFY_FIELD_TOTAL_BYTES             0x18
#define PRINTER_NOTIFY_FIELD_BYTES_PRINTED           0x19

#define JOB_NOTIFY_FIELD_PRINTER_NAME                0x00
#define JOB_NOTIFY_FIELD_MACHINE_NAME                0x01
#define JOB_NOTIFY_FIELD_PORT_NAME                   0x02
#define JOB_NOTIFY_FIELD_USER_NAME                   0x03
#define JOB_NOTIFY_FIELD_NOTIFY_NAME                 0x04
#define JOB_NOTIFY_FIELD_DATATYPE                    0x05
#define JOB_NOTIFY_FIELD_PRINT_PROCESSOR             0x06
#define JOB_NOTIFY_FIELD_PARAMETERS                  0x07
#define JOB_NOTIFY_FIELD_DRIVER_NAME                 0x08
#define JOB_NOTIFY_FIELD_DEVMODE                     0x09
#define JOB_NOTIFY_FIELD_STATUS                      0x0A
#define JOB_NOTIFY_FIELD_STATUS_STRING               0x0B
#define JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR         0x0C
#define JOB_NOTIFY_FIELD_DOCUMENT                    0x0D
#define JOB_NOTIFY_FIELD_PRIORITY                    0x0E
#define JOB_NOTIFY_FIELD_POSITION                    0x0F
#define JOB_NOTIFY_FIELD_SUBMITTED                   0x10
#define JOB_NOTIFY_FIELD_START_TIME                  0x11
#define JOB_NOTIFY_FIELD_UNTIL_TIME                  0x12
#define JOB_NOTIFY_FIELD_TIME                        0x13
#define JOB_NOTIFY_FIELD_TOTAL_PAGES                 0x14
#define JOB_NOTIFY_FIELD_PAGES_PRINTED               0x15
#define JOB_NOTIFY_FIELD_TOTAL_BYTES                 0x16
#define JOB_NOTIFY_FIELD_BYTES_PRINTED               0x17


typedef struct _PRINTER_NOTIFY_OPTIONS_TYPE {
    WORD Type;
    WORD Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    PWORD pFields;
} PRINTER_NOTIFY_OPTIONS_TYPE, *PPRINTER_NOTIFY_OPTIONS_TYPE, *LPPRINTER_NOTIFY_OPTIONS_TYPE;


#define PRINTER_NOTIFY_OPTIONS_REFRESH  0x01

typedef struct _PRINTER_NOTIFY_OPTIONS {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PPRINTER_NOTIFY_OPTIONS_TYPE pTypes;
} PRINTER_NOTIFY_OPTIONS, *PPRINTER_NOTIFY_OPTIONS, *LPPRINTER_NOTIFY_OPTIONS;



#define PRINTER_NOTIFY_INFO_DISCARDED       0x01

typedef struct _PRINTER_NOTIFY_INFO_DATA {
    WORD Type;
    WORD Field;
    DWORD Reserved;
    DWORD Id;
    union {
        DWORD adwData[2];
        struct {
            DWORD  cbBuf;
            LPVOID pBuf;
        } Data;
    } NotifyData;
} PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA, *LPPRINTER_NOTIFY_INFO_DATA;

typedef struct _PRINTER_NOTIFY_INFO {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PRINTER_NOTIFY_INFO_DATA aData[1];
} PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO, *LPPRINTER_NOTIFY_INFO;

DWORD
WINAPI
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

HANDLE
WINAPI
FindFirstPrinterChangeNotification(
    HANDLE  hPrinter,
    DWORD   fdwFlags,
    DWORD   fdwOptions,
    LPVOID  pPrinterNotifyOptions
);


BOOL
WINAPI
FindNextPrinterChangeNotification(
    HANDLE hChange,
    PDWORD pdwChange,
    LPVOID pvReserved,
    LPVOID *ppPrinterNotifyInfo
);

BOOL
WINAPI
FreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
);

BOOL
WINAPI
FindClosePrinterChangeNotification(
    HANDLE hChange
);

#define PRINTER_CHANGE_ADD_PRINTER              0x00000001
#define PRINTER_CHANGE_SET_PRINTER              0x00000002
#define PRINTER_CHANGE_DELETE_PRINTER           0x00000004
#define PRINTER_CHANGE_FAILED_CONNECTION_PRINTER    0x00000008
#define PRINTER_CHANGE_PRINTER                  0x000000FF
#define PRINTER_CHANGE_ADD_JOB                  0x00000100
#define PRINTER_CHANGE_SET_JOB                  0x00000200
#define PRINTER_CHANGE_DELETE_JOB               0x00000400
#define PRINTER_CHANGE_WRITE_JOB                0x00000800
#define PRINTER_CHANGE_JOB                      0x0000FF00
#define PRINTER_CHANGE_ADD_FORM                 0x00010000
#define PRINTER_CHANGE_SET_FORM                 0x00020000
#define PRINTER_CHANGE_DELETE_FORM              0x00040000
#define PRINTER_CHANGE_FORM                     0x00070000
#define PRINTER_CHANGE_ADD_PORT                 0x00100000
#define PRINTER_CHANGE_CONFIGURE_PORT           0x00200000
#define PRINTER_CHANGE_DELETE_PORT              0x00400000
#define PRINTER_CHANGE_PORT                     0x00700000
#define PRINTER_CHANGE_ADD_PRINT_PROCESSOR      0x01000000
#define PRINTER_CHANGE_DELETE_PRINT_PROCESSOR   0x04000000
#define PRINTER_CHANGE_PRINT_PROCESSOR          0x07000000
#define PRINTER_CHANGE_ADD_PRINTER_DRIVER       0x10000000
#define PRINTER_CHANGE_SET_PRINTER_DRIVER       0x20000000
#define PRINTER_CHANGE_DELETE_PRINTER_DRIVER    0x40000000
#define PRINTER_CHANGE_PRINTER_DRIVER           0x70000000
#define PRINTER_CHANGE_TIMEOUT                  0x80000000
#define PRINTER_CHANGE_ALL                      0x7777FFFF

DWORD
WINAPI
PrinterMessageBoxA(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPSTR   pText,
    LPSTR   pCaption,
    DWORD   dwType
);
DWORD
WINAPI
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR   pText,
    LPWSTR   pCaption,
    DWORD   dwType
);
#ifdef UNICODE
#define PrinterMessageBox  PrinterMessageBoxW
#else
#define PrinterMessageBox  PrinterMessageBoxA
#endif // !UNICODE



#define PRINTER_ERROR_INFORMATION   0x80000000
#define PRINTER_ERROR_WARNING       0x40000000
#define PRINTER_ERROR_SEVERE        0x20000000

#define PRINTER_ERROR_OUTOFPAPER    0x00000001
#define PRINTER_ERROR_JAM           0x00000002
#define PRINTER_ERROR_OUTOFTONER    0x00000004

BOOL
WINAPI
ClosePrinter(
    HANDLE hPrinter
);

BOOL
WINAPI
AddFormA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);
BOOL
WINAPI
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);
#ifdef UNICODE
#define AddForm  AddFormW
#else
#define AddForm  AddFormA
#endif // !UNICODE



BOOL
WINAPI
DeleteFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName
);
BOOL
WINAPI
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName
);
#ifdef UNICODE
#define DeleteForm  DeleteFormW
#else
#define DeleteForm  DeleteFormA
#endif // !UNICODE



BOOL
WINAPI
GetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
WINAPI
GetFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetForm  GetFormW
#else
#define GetForm  GetFormA
#endif // !UNICODE



BOOL
WINAPI
SetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);
BOOL
WINAPI
SetFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);
#ifdef UNICODE
#define SetForm  SetFormW
#else
#define SetForm  SetFormA
#endif // !UNICODE



BOOL
WINAPI
EnumFormsA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumForms  EnumFormsW
#else
#define EnumForms  EnumFormsA
#endif // !UNICODE



BOOL
WINAPI
EnumMonitorsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumMonitorsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumMonitors  EnumMonitorsW
#else
#define EnumMonitors  EnumMonitorsA
#endif // !UNICODE



BOOL
WINAPI
AddMonitorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors
);
BOOL
WINAPI
AddMonitorW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors
);
#ifdef UNICODE
#define AddMonitor  AddMonitorW
#else
#define AddMonitor  AddMonitorA
#endif // !UNICODE



BOOL
WINAPI
DeleteMonitorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pMonitorName
);
BOOL
WINAPI
DeleteMonitorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName
);
#ifdef UNICODE
#define DeleteMonitor  DeleteMonitorW
#else
#define DeleteMonitor  DeleteMonitorA
#endif // !UNICODE



BOOL
WINAPI
EnumPortsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
WINAPI
EnumPortsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPorts  EnumPortsW
#else
#define EnumPorts  EnumPortsA
#endif // !UNICODE



BOOL
WINAPI
AddPortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pMonitorName
);
BOOL
WINAPI
AddPortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);
#ifdef UNICODE
#define AddPort  AddPortW
#else
#define AddPort  AddPortA
#endif // !UNICODE



BOOL
WINAPI
ConfigurePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
);
BOOL
WINAPI
ConfigurePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);
#ifdef UNICODE
#define ConfigurePort  ConfigurePortW
#else
#define ConfigurePort  ConfigurePortA
#endif // !UNICODE



BOOL
WINAPI
DeletePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
);
BOOL
WINAPI
DeletePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);
#ifdef UNICODE
#define DeletePort  DeletePortW
#else
#define DeletePort  DeletePortA
#endif // !UNICODE



BOOL
WINAPI
AddPrinterConnectionA(
    LPSTR   pName
);
BOOL
WINAPI
AddPrinterConnectionW(
    LPWSTR   pName
);
#ifdef UNICODE
#define AddPrinterConnection  AddPrinterConnectionW
#else
#define AddPrinterConnection  AddPrinterConnectionA
#endif // !UNICODE



BOOL
WINAPI
DeletePrinterConnectionA(
    LPSTR   pName
);
BOOL
WINAPI
DeletePrinterConnectionW(
    LPWSTR   pName
);
#ifdef UNICODE
#define DeletePrinterConnection  DeletePrinterConnectionW
#else
#define DeletePrinterConnection  DeletePrinterConnectionA
#endif // !UNICODE



HANDLE
WINAPI
ConnectToPrinterDlg(
    HWND    hwnd,
    DWORD   Flags
);

typedef struct _PROVIDOR_INFO_1A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} PROVIDOR_INFO_1A, *PPROVIDOR_INFO_1A, *LPPROVIDOR_INFO_1A;
typedef struct _PROVIDOR_INFO_1W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} PROVIDOR_INFO_1W, *PPROVIDOR_INFO_1W, *LPPROVIDOR_INFO_1W;
#ifdef UNICODE
typedef PROVIDOR_INFO_1W PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1W PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1W LPPROVIDOR_INFO_1;
#else
typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1A PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1A LPPROVIDOR_INFO_1;
#endif // UNICODE



BOOL
WINAPI
AddPrintProvidorA(
    LPSTR  pName,
    DWORD    level,
    LPBYTE   pProvidorInfo
);
BOOL
WINAPI
AddPrintProvidorW(
    LPWSTR  pName,
    DWORD    level,
    LPBYTE   pProvidorInfo
);
#ifdef UNICODE
#define AddPrintProvidor  AddPrintProvidorW
#else
#define AddPrintProvidor  AddPrintProvidorA
#endif // !UNICODE

BOOL
WINAPI
DeletePrintProvidorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProvidorName
);
BOOL
WINAPI
DeletePrintProvidorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPrintProvidorName
);
#ifdef UNICODE
#define DeletePrintProvidor  DeletePrintProvidorW
#else
#define DeletePrintProvidor  DeletePrintProvidorA
#endif // !UNICODE



#define SERVER_ACCESS_ADMINISTER    0x00000001
#define SERVER_ACCESS_ENUMERATE     0x00000002

#define PRINTER_ACCESS_ADMINISTER   0x00000004
#define PRINTER_ACCESS_USE          0x00000008

#define JOB_ACCESS_ADMINISTER       0x00000010


/*
 * Access rights for print servers
 */

#define SERVER_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED      |\
                              SERVER_ACCESS_ADMINISTER      |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_READ          (STANDARD_RIGHTS_READ          |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_WRITE         (STANDARD_RIGHTS_WRITE         |\
                              SERVER_ACCESS_ADMINISTER      |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_EXECUTE       (STANDARD_RIGHTS_EXECUTE       |\
                              SERVER_ACCESS_ENUMERATE)

/*
 * Access rights for printers
 */

#define PRINTER_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED     |\
                               PRINTER_ACCESS_ADMINISTER    |\
                               PRINTER_ACCESS_USE)

#define PRINTER_READ          (STANDARD_RIGHTS_READ         |\
                               PRINTER_ACCESS_USE)

#define PRINTER_WRITE         (STANDARD_RIGHTS_WRITE        |\
                               PRINTER_ACCESS_USE)

#define PRINTER_EXECUTE       (STANDARD_RIGHTS_EXECUTE      |\
                               PRINTER_ACCESS_USE)

/*
 * Access rights for jobs
 */

#define JOB_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED    |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_READ               (STANDARD_RIGHTS_READ        |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_WRITE              (STANDARD_RIGHTS_WRITE       |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_EXECUTE            (STANDARD_RIGHTS_EXECUTE     |\
                                JOB_ACCESS_ADMINISTER)


#ifdef __cplusplus
}
#endif

#endif // _WINSPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINUSER.H ===
/****************************************************************************
*                                                                           *
* winuser.h -- USER procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) 1985-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#ifndef _WINUSER_
#define _WINUSER_

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_USER32_)
#define WINUSERAPI DECLSPEC_IMPORT
#else
#define WINUSERAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef WINVER
#define WINVER  0x0400      /* version 4.0 */
#endif /* !WINVER */

#include <stdarg.h>

#ifndef NOUSER

typedef HANDLE HDWP;
typedef VOID MENUTEMPLATEA;
typedef VOID MENUTEMPLATEW;
#ifdef UNICODE
typedef MENUTEMPLATEW MENUTEMPLATE;
#else
typedef MENUTEMPLATEA MENUTEMPLATE;
#endif // UNICODE
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;
#ifdef UNICODE
typedef LPMENUTEMPLATEW LPMENUTEMPLATE;
#else
typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
#endif // UNICODE

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT

typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
typedef VOID (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef VOID (CALLBACK* SENDASYNCPROC)(HWND, UINT, DWORD, LRESULT);

typedef BOOL (CALLBACK* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (CALLBACK* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (CALLBACK* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, DWORD);
typedef BOOL (CALLBACK* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, DWORD);

typedef int (CALLBACK* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (CALLBACK* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);

#if(WINVER >= 0x0400)
typedef BOOL (CALLBACK* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#endif /* WINVER >= 0x0400 */
#else /* !STRICT */

typedef FARPROC DLGPROC;
typedef FARPROC TIMERPROC;
typedef FARPROC GRAYSTRINGPROC;
typedef FARPROC WNDENUMPROC;
typedef FARPROC HOOKPROC;
typedef FARPROC SENDASYNCPROC;

typedef FARPROC EDITWORDBREAKPROCA;
typedef FARPROC EDITWORDBREAKPROCW;

typedef FARPROC PROPENUMPROCA;
typedef FARPROC PROPENUMPROCW;

typedef FARPROC PROPENUMPROCEXA;
typedef FARPROC PROPENUMPROCEXW;

#if(WINVER >= 0x0400)
typedef FARPROC DRAWSTATEPROC;
#endif /* WINVER >= 0x0400 */
#endif /* !STRICT */

#ifdef UNICODE
typedef PROPENUMPROCW        PROPENUMPROC;
typedef PROPENUMPROCEXW      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCW   EDITWORDBREAKPROC;
#else  /* !UNICODE */
typedef PROPENUMPROCA        PROPENUMPROC;
typedef PROPENUMPROCEXA      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA   EDITWORDBREAKPROC;
#endif /* UNICODE */

#ifdef STRICT

typedef BOOL (CALLBACK* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (CALLBACK* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA   WINSTAENUMPROCA;
typedef NAMEENUMPROCA   DESKTOPENUMPROCA;
typedef NAMEENUMPROCW   WINSTAENUMPROCW;
typedef NAMEENUMPROCW   DESKTOPENUMPROCW;

#else /* !STRICT */

typedef FARPROC NAMEENUMPROCA;
typedef FARPROC NAMEENUMPROCW;
typedef FARPROC WINSTAENUMPROCA;
typedef FARPROC DESKTOPENUMPROCA;
typedef FARPROC WINSTAENUMPROCW;
typedef FARPROC DESKTOPENUMPROCW;

#endif /* !STRICT */

#ifdef UNICODE
typedef WINSTAENUMPROCW     WINSTAENUMPROC;
typedef DESKTOPENUMPROCW    DESKTOPENUMPROC;
#else  /* !UNICODE */
typedef WINSTAENUMPROCA     WINSTAENUMPROC;
typedef DESKTOPENUMPROCA    DESKTOPENUMPROC;
#endif /* UNICODE */

#define MAKEINTRESOURCEA(i) (LPSTR)((DWORD)((WORD)(i)))
#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))
#ifdef UNICODE
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#else
#define MAKEINTRESOURCE  MAKEINTRESOURCEA
#endif // !UNICODE

#ifndef NORESOURCE

/*
 * Predefined Resource Types
 */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)

#define DIFFERENCE          11
#define RT_GROUP_CURSOR MAKEINTRESOURCE((DWORD)RT_CURSOR + DIFFERENCE)
#define RT_GROUP_ICON   MAKEINTRESOURCE((DWORD)RT_ICON + DIFFERENCE)
#define RT_VERSION      MAKEINTRESOURCE(16)
#define RT_DLGINCLUDE   MAKEINTRESOURCE(17)
#if(WINVER >= 0x0400)
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)
#endif /* WINVER >= 0x0400 */

#endif /* !NORESOURCE */

WINUSERAPI
int
WINAPI
wvsprintfA(
    LPSTR,
    LPCSTR,
    va_list arglist);
WINUSERAPI
int
WINAPI
wvsprintfW(
    LPWSTR,
    LPCWSTR,
    va_list arglist);
#ifdef UNICODE
#define wvsprintf  wvsprintfW
#else
#define wvsprintf  wvsprintfA
#endif // !UNICODE

WINUSERAPI int WINAPIV wsprintfA(LPSTR, LPCSTR, ...);
WINUSERAPI int WINAPIV wsprintfW(LPWSTR, LPCWSTR, ...);
#ifdef UNICODE
#define wsprintf  wsprintfW
#else
#define wsprintf  wsprintfA
#endif // !UNICODE

#ifndef NOSCROLL

/*
 * Scroll Bar Constants
 */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

/*
 * Scroll Bar Commands
 */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8

#endif /* !NOSCROLL */

#ifndef NOSHOWWINDOW

/*
 * ShowWindow() Commands
 */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_MAX              10

/*
 * Old ShowWindow() Commands
 */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/*
 * Identifiers for the WM_SHOWWINDOW message
 */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4

#endif /* !NOSHOWWINDOW */

/*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
 */
#define KF_EXTENDED         0x0100
#define KF_DLGMODE          0x0800
#define KF_MENUMODE         0x1000
#define KF_ALTDOWN          0x2000
#define KF_REPEAT           0x4000
#define KF_UP               0x8000

#ifndef NOVIRTUALKEYCODES

/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VK_BACK           0x08
#define VK_TAB            0x09

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14

#define VK_ESCAPE         0x1B

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#if(WINVER >= 0x0400)
#define VK_PROCESSKEY     0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE

#endif /* !NOVIRTUALKEYCODES */

#ifndef NOWH

/*
 * SetWindowsHook() codes
 */
#define WH_MIN              (-1)
#define WH_MSGFILTER        (-1)
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1
#define WH_KEYBOARD         2
#define WH_GETMESSAGE       3
#define WH_CALLWNDPROC      4
#define WH_CBT              5
#define WH_SYSMSGFILTER     6
#define WH_MOUSE            7
#define WH_HARDWARE         8
#define WH_DEBUG            9
#define WH_SHELL           10
#define WH_FOREGROUNDIDLE  11
#if(WINVER >= 0x0400)
#define WH_CALLWNDPROCRET  12
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0400)
#define WH_MAX             12
#else
#define WH_MAX             11
#endif
#define WH_MINHOOK         WH_MIN
#define WH_MAXHOOK         WH_MAX

/*
 * Hook Codes
 */
#define HC_ACTION           0
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/*
 * CBT Hook Codes
 */
#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9

/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
#ifdef UNICODE
typedef CBT_CREATEWNDW CBT_CREATEWND;
typedef LPCBT_CREATEWNDW LPCBT_CREATEWND;
#else
typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#endif // UNICODE

/*
 * HCBT_ACTIVATE structure pointed to by lParam
 */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

/*
 * WH_MSGFILTER Filter Proc Codes
 */
#define MSGF_DIALOGBOX      0
#define MSGF_MESSAGEBOX     1
#define MSGF_MENU           2
#define MSGF_MOVE           3
#define MSGF_SIZE           4
#define MSGF_SCROLLBAR      5
#define MSGF_NEXTWINDOW     6
#define MSGF_MAINLOOP       8
#define MSGF_MAX            8
#define MSGF_USER           4096

/*
 * Shell support
 */
#define HSHELL_WINDOWCREATED        1
#define HSHELL_WINDOWDESTROYED      2
#define HSHELL_ACTIVATESHELLWINDOW  3

#if(WINVER >= 0x0400)
#define HSHELL_WINDOWACTIVATED      4
#define HSHELL_GETMINRECT           5
#define HSHELL_REDRAW               6
#define HSHELL_TASKMAN              7
#define HSHELL_LANGUAGE             8
#endif /* WINVER >= 0x0400 */

/*
 * Message Structure used in Journaling
 */
typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG, NEAR *NPEVENTMSGMSG, FAR *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG, NEAR *NPEVENTMSG, FAR *LPEVENTMSG;

/*
 * Message structure used by WH_CALLWNDPROC
 */
typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT, NEAR *NPCWPSTRUCT, FAR *LPCWPSTRUCT;

#if(WINVER >= 0x0400)
/*
 * Message structure used by WH_CALLWNDPROCRET
 */
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, NEAR *NPCWPRETSTRUCT, FAR *LPCWPRETSTRUCT;
#endif /* WINVER >= 0x0400 */

/*
 * Structure used by WH_DEBUG
 */
typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, NEAR *NPDEBUGHOOKINFO, FAR* LPDEBUGHOOKINFO;

/*
 * Structure used by WH_MOUSE
 */
typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT, FAR *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
#if(WINVER >= 0x0400)
/*
 * Structure used by WH_HARDWARE
 */
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT, FAR *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#endif /* WINVER >= 0x0400 */
#endif /* !NOWH */

/*
 * Keyboard Layout API
 */
#define HKL_PREV            0
#define HKL_NEXT            1

#define KLF_ACTIVATE        0x00000001
#define KLF_SUBSTITUTE_OK   0x00000002
#define KLF_UNLOADPREVIOUS  0x00000004
#define KLF_REORDER         0x00000008
#if(WINVER >= 0x0400)
#define KLF_REPLACELANG     0x00000010
#define KLF_NOTELLSHELL     0x00000080
#endif /* WINVER >= 0x0400 */

/*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 */
#define KL_NAMELENGTH       9

WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutA(
    LPCSTR pwszKLID,
    UINT Flags);
WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutW(
    LPCWSTR pwszKLID,
    UINT Flags);
#ifdef UNICODE
#define LoadKeyboardLayout  LoadKeyboardLayoutW
#else
#define LoadKeyboardLayout  LoadKeyboardLayoutA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
HKL
WINAPI
ActivateKeyboardLayout(
    HKL hkl,
    UINT Flags);
#else
WINUSERAPI
BOOL
WINAPI
ActivateKeyboardLayout(
    HKL hkl,
    UINT Flags);
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    PBYTE lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL dwhkl);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
UnloadKeyboardLayout(
    HKL hkl);

WINUSERAPI
BOOL
WINAPI
GetKeyboardLayoutNameA(
    LPSTR pwszKLID);
WINUSERAPI
BOOL
WINAPI
GetKeyboardLayoutNameW(
    LPWSTR pwszKLID);
#ifdef UNICODE
#define GetKeyboardLayoutName  GetKeyboardLayoutNameW
#else
#define GetKeyboardLayoutName  GetKeyboardLayoutNameA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
GetKeyboardLayoutList(
	int nBuff,
	HKL FAR *lpList);

WINUSERAPI
HKL
WINAPI
GetKeyboardLayout(
    DWORD dwLayout
);
#endif /* WINVER >= 0x0400 */

#ifndef NODESKTOP
/*
 * Desktop-specific access flags
 */
#define DESKTOP_READOBJECTS         0x0001L
#define DESKTOP_CREATEWINDOW        0x0002L
#define DESKTOP_CREATEMENU          0x0004L
#define DESKTOP_HOOKCONTROL         0x0008L
#define DESKTOP_JOURNALRECORD       0x0010L
#define DESKTOP_JOURNALPLAYBACK     0x0020L
#define DESKTOP_ENUMERATE           0x0040L
#define DESKTOP_WRITEOBJECTS        0x0080L
#define DESKTOP_SWITCHDESKTOP       0x0100L

/*
 * Desktop-specific control flags
 */
#define DF_ALLOWOTHERACCOUNTHOOK    0x0001L

#ifdef _WINGDI_
#ifndef NOGDI

WINUSERAPI
HDESK
WINAPI
CreateDesktopA(
    LPSTR lpszDesktop,
    LPSTR lpszDevice,
    LPDEVMODEA pDevmode,
    DWORD dwFlags,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
WINUSERAPI
HDESK
WINAPI
CreateDesktopW(
    LPWSTR lpszDesktop,
    LPWSTR lpszDevice,
    LPDEVMODEW pDevmode,
    DWORD dwFlags,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
#ifdef UNICODE
#define CreateDesktop  CreateDesktopW
#else
#define CreateDesktop  CreateDesktopA
#endif // !UNICODE

#endif /* NOGDI */
#endif /* _WINGDI_ */

WINUSERAPI
HDESK
WINAPI
OpenDesktopA(
    LPSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    DWORD dwDesiredAccess);
WINUSERAPI
HDESK
WINAPI
OpenDesktopW(
    LPWSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    DWORD dwDesiredAccess);
#ifdef UNICODE
#define OpenDesktop  OpenDesktopW
#else
#define OpenDesktop  OpenDesktopA
#endif // !UNICODE

WINUSERAPI
HDESK
WINAPI
OpenInputDesktop(
    DWORD dwFlags,
    BOOL fInherit,
    DWORD dwDesiredAccess);

WINUSERAPI
BOOL
WINAPI
EnumDesktopsA(
    HWINSTA hwinsta,
    DESKTOPENUMPROCA lpEnumFunc,
    LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
EnumDesktopsW(
    HWINSTA hwinsta,
    DESKTOPENUMPROCW lpEnumFunc,
    LPARAM lParam);
#ifdef UNICODE
#define EnumDesktops  EnumDesktopsW
#else
#define EnumDesktops  EnumDesktopsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EnumDesktopWindows(
    HDESK hDesktop,
    WNDENUMPROC lpfn,
    LPARAM lParam);

WINUSERAPI
BOOL
WINAPI
SwitchDesktop(
    HDESK hDesktop);

WINUSERAPI
BOOL
WINAPI
SetThreadDesktop(
    HDESK hDesktop);

WINUSERAPI
BOOL
WINAPI
CloseDesktop(
    HDESK hDesktop);

WINUSERAPI
HDESK
WINAPI
GetThreadDesktop(
    DWORD dwThreadId);

#endif  /* !NODESKTOP */

#ifndef NOWINDOWSTATION
/*
 * Windowstation-specific access flags
 */
#define WINSTA_ENUMDESKTOPS         0x0001L
#define WINSTA_READATTRIBUTES       0x0002L
#define WINSTA_ACCESSCLIPBOARD      0x0004L
#define WINSTA_CREATEDESKTOP        0x0008L
#define WINSTA_WRITEATTRIBUTES      0x0010L
#define WINSTA_ACCESSGLOBALATOMS    0x0020L
#define WINSTA_EXITWINDOWS          0x0040L
#define WINSTA_ENUMERATE            0x0100L
#define WINSTA_READSCREEN           0x0200L

/*
 * Windowstation-specific attribute flags
 */
#define WSF_VISIBLE                 0x0001L

WINUSERAPI
HWINSTA
WINAPI
CreateWindowStationA(
    LPSTR lpwinsta,
    DWORD dwReserved,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
WINUSERAPI
HWINSTA
WINAPI
CreateWindowStationW(
    LPWSTR lpwinsta,
    DWORD dwReserved,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
#ifdef UNICODE
#define CreateWindowStation  CreateWindowStationW
#else
#define CreateWindowStation  CreateWindowStationA
#endif // !UNICODE

WINUSERAPI
HWINSTA
WINAPI
OpenWindowStationA(
    LPSTR lpszWinSta,
    BOOL fInherit,
    DWORD dwDesiredAccess);
WINUSERAPI
HWINSTA
WINAPI
OpenWindowStationW(
    LPWSTR lpszWinSta,
    BOOL fInherit,
    DWORD dwDesiredAccess);
#ifdef UNICODE
#define OpenWindowStation  OpenWindowStationW
#else
#define OpenWindowStation  OpenWindowStationA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EnumWindowStationsA(
    WINSTAENUMPROCA lpEnumFunc,
    LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
EnumWindowStationsW(
    WINSTAENUMPROCW lpEnumFunc,
    LPARAM lParam);
#ifdef UNICODE
#define EnumWindowStations  EnumWindowStationsW
#else
#define EnumWindowStations  EnumWindowStationsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
CloseWindowStation(
    HWINSTA hWinSta);

WINUSERAPI
BOOL
WINAPI
SetProcessWindowStation(
    HWINSTA hWinSta);

WINUSERAPI
HWINSTA
WINAPI
GetProcessWindowStation(
    VOID);
#endif  /* !NOWINDOWSTATION */

#ifndef NOSECURITY

WINUSERAPI
BOOL
WINAPI
SetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID);

WINUSERAPI
BOOL
WINAPI
GetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);

#define UOI_FLAGS       1
#define UOI_NAME        2
#define UOI_TYPE        3

typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

WINUSERAPI
BOOL
WINAPI
GetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
WINUSERAPI
BOOL
WINAPI
GetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
#ifdef UNICODE
#define GetUserObjectInformation  GetUserObjectInformationW
#else
#define GetUserObjectInformation  GetUserObjectInformationA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);
WINUSERAPI
BOOL
WINAPI
SetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);
#ifdef UNICODE
#define SetUserObjectInformation  SetUserObjectInformationW
#else
#define SetUserObjectInformation  SetUserObjectInformationA
#endif // !UNICODE

#endif  /* !NOSECURITY */

#if(WINVER >= 0x0400)
typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, NEAR *NPWNDCLASSEXA, FAR *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;
#ifdef UNICODE
typedef WNDCLASSEXW WNDCLASSEX;
typedef PWNDCLASSEXW PWNDCLASSEX;
typedef NPWNDCLASSEXW NPWNDCLASSEX;
typedef LPWNDCLASSEXW LPWNDCLASSEX;
#else
typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA, NEAR *NPWNDCLASSA, FAR *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;
#ifdef UNICODE
typedef WNDCLASSW WNDCLASS;
typedef PWNDCLASSW PWNDCLASS;
typedef NPWNDCLASSW NPWNDCLASS;
typedef LPWNDCLASSW LPWNDCLASS;
#else
typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#endif // UNICODE

#ifndef NOMSG

/*
 * Message structure
 */
typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;

#define POINTSTOPOINT(pt, pts)                          \
        { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts);   \
          (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }

#define POINTTOPOINTS(pt)      (MAKELONG((short)((pt).x), (short)((pt).y)))
#define MAKEWPARAM(l, h)      (WPARAM)MAKELONG(l, h)
#define MAKELPARAM(l, h)      (LPARAM)MAKELONG(l, h)
#define MAKELRESULT(l, h)     (LRESULT)MAKELONG(l, h)

#endif /* !NOMSG */

#ifndef NOWINOFFSETS

/*
 * Window field offsets for GetWindowLong()
 */
#define GWL_WNDPROC         (-4)
#define GWL_HINSTANCE       (-6)
#define GWL_HWNDPARENT      (-8)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)
#define GWL_USERDATA        (-21)
#define GWL_ID              (-12)

/*
 * Class field offsets for GetClassLong()
 */
#define GCL_MENUNAME        (-8)
#define GCL_HBRBACKGROUND   (-10)
#define GCL_HCURSOR         (-12)
#define GCL_HICON           (-14)
#define GCL_HMODULE         (-16)
#define GCL_CBWNDEXTRA      (-18)
#define GCL_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCL_STYLE           (-26)
#define GCW_ATOM            (-32)

#if(WINVER >= 0x0400)
#define GCL_HICONSM         (-34)
#endif /* WINVER >= 0x0400 */

#endif /* !NOWINOFFSETS */

#ifndef NOWINMESSAGES

/*
 * Window Messages
 */

#define WM_NULL                         0x0000
#define WM_CREATE                       0x0001
#define WM_DESTROY                      0x0002
#define WM_MOVE                         0x0003
#define WM_SIZE                         0x0005

#define WM_ACTIVATE                     0x0006
/*
 * WM_ACTIVATE state values
 */
#define     WA_INACTIVE     0
#define     WA_ACTIVE       1
#define     WA_CLICKACTIVE  2

#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#define WM_QUERYENDSESSION              0x0011
#define WM_QUIT                         0x0012
#define WM_QUERYOPEN                    0x0013
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_ENDSESSION                   0x0016
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#if(WINVER >= 0x0400)
#define WM_SETTINGCHANGE                WM_WININICHANGE
#endif /* WINVER >= 0x0400 */

#define WM_DEVMODECHANGE                0x001B
#define WM_ACTIVATEAPP                  0x001C
#define WM_FONTCHANGE                   0x001D
#define WM_TIMECHANGE                   0x001E
#define WM_CANCELMODE                   0x001F
#define WM_SETCURSOR                    0x0020
#define WM_MOUSEACTIVATE                0x0021
#define WM_CHILDACTIVATE                0x0022
#define WM_QUEUESYNC                    0x0023

#define WM_GETMINMAXINFO                0x0024
/*
 * Struct pointed to by WM_GETMINMAXINFO lParam
 */
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#define WM_PAINTICON                    0x0026
#define WM_ICONERASEBKGND               0x0027
#define WM_NEXTDLGCTL                   0x0028
#define WM_SPOOLERSTATUS                0x002A
#define WM_DRAWITEM                     0x002B
#define WM_MEASUREITEM                  0x002C
#define WM_DELETEITEM                   0x002D
#define WM_VKEYTOITEM                   0x002E
#define WM_CHARTOITEM                   0x002F
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define WM_GETHOTKEY                    0x0033
#define WM_QUERYDRAGICON                0x0037
#define WM_COMPAREITEM                  0x0039

#define WM_COMPACTING                   0x0041
#define WM_COMMNOTIFY                   0x0044  /* no longer suported */
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_WINDOWPOSCHANGED             0x0047

#define WM_POWER                        0x0048
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3

#define WM_COPYDATA                     0x004A
#define WM_CANCELJOURNAL                0x004B
/*
 * lParam of WM_COPYDATA message points to...
 */
typedef struct tagCOPYDATASTRUCT {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;

#if(WINVER >= 0x0400)
#define WM_NOTIFY                       0x004E
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define WM_INPUTLANGCHANGE              0x0051
#define WM_TCARD                        0x0052
#define WM_HELP                         0x0053
#define WM_USERCHANGED                  0x0054
#define WM_NOTIFYFORMAT                 0x0055

#define NFR_ANSI                             1
#define NFR_UNICODE                          2
#define NF_QUERY                             3
#define NF_REQUERY                           4

#define WM_CONTEXTMENU                  0x007B
#define WM_STYLECHANGING                0x007C
#define WM_STYLECHANGED                 0x007D
#define WM_DISPLAYCHANGE                0x007E
#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#endif /* WINVER >= 0x0400 */

#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087

#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9

#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_KEYLAST                      0x0108

#if(WINVER >= 0x0400)
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#endif /* WINVER >= 0x0400 */

#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121

#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138

#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#define WM_MOUSELAST                    0x0209

#define WM_PARENTNOTIFY                 0x0210
#define MENULOOP_WINDOW                 0
#define MENULOOP_POPUP                  1
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212

#if(WINVER >= 0x0400)
#define WM_NEXTMENU                     0x0213

typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU, FAR * LPMDINEXTMENU;

#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#define WM_POWERBROADCAST               0x0218
#define WM_DEVICECHANGE                 0x0219

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#endif /* WINVER >= 0x0400 */

#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229

#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234

#define WM_CUT                          0x0300
#define WM_COPY                         0x0301
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312

#if(WINVER >= 0x0400)
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318

#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F

#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
#endif /* WINVER >= 0x0400 */

#define WM_PENWINFIRST                  0x0380
#define WM_PENWINLAST                   0x038F

#if(WINVER >= 0x0400)
#define WM_APP                          0x8000
#endif /* WINVER >= 0x0400 */

/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
#define WM_USER                         0x0400

#if(WINVER >= 0x0400)
/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#endif /* WINVER >= 0x0400 */

#ifndef NONCMESSAGES

/*
 * WM_SYNCTASK Commands
 */
#define ST_BEGINSWP         0
#define ST_ENDSWP           1

/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT
#if(WINVER >= 0x0400)
#define HTOBJECT            19
#define HTCLOSE             20
#define HTHELP              21
#endif /* WINVER >= 0x0400 */

/*
 * SendMessageTimeout values
 */
#define SMTO_NORMAL         0x0000
#define SMTO_BLOCK          0x0001
#define SMTO_ABORTIFHUNG    0x0002

#endif /* !NONCMESSAGES */

/*
 * WM_MOUSEACTIVATE Return Codes
 */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#define MA_NOACTIVATEANDEAT 4

WINUSERAPI
UINT
WINAPI
RegisterWindowMessageA(
    LPCSTR lpString);
WINUSERAPI
UINT
WINAPI
RegisterWindowMessageW(
    LPCWSTR lpString);
#ifdef UNICODE
#define RegisterWindowMessage  RegisterWindowMessageW
#else
#define RegisterWindowMessage  RegisterWindowMessageA
#endif // !UNICODE

/*
 * WM_SIZE message wParam values
 */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/*
 * Obsolete constant names
 */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/*
 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
 */
typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

/*
 * WM_NCCALCSIZE parameter structure
 */
typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW         (WVR_HREDRAW | \
                            WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400

#ifndef NOKEYSTATES

/*
 * Key State Masks for Mouse Messages
 */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010

#endif /* !NOKEYSTATES */

#endif /* !NOWINMESSAGES */

#ifndef NOWINSTYLES

/*
 * Window Styles
 */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

/*
 * Common Window Styles
 */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
                             WS_CAPTION        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)

#define WS_POPUPWINDOW      (WS_POPUP          | \
                             WS_BORDER         | \
                             WS_SYSMENU)

#define WS_CHILDWINDOW      (WS_CHILD)

/*
 * Extended Window Styles
 */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L
#define WS_EX_TOPMOST        0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#if(WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L

#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)

#endif /* WINVER >= 0x0400 */

/*
 * Class styles
 */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#if(WINVER >= 0x0400)
#define CS_IME              0x00010000
#endif /* WINVER >= 0x0400 */

#endif /* !NOWINSTYLES */
#if(WINVER >= 0x0400)
/* WM_PRINT flags */
#define PRF_CHECKVISIBLE    0x00000001L
#define PRF_NONCLIENT       0x00000002L
#define PRF_CLIENT          0x00000004L
#define PRF_ERASEBKGND      0x00000008L
#define PRF_CHILDREN        0x00000010L
#define PRF_OWNED           0x00000020L

/* 3D border styles */
#define BDR_RAISEDOUTER 0x0001
#define BDR_SUNKENOUTER 0x0002
#define BDR_RAISEDINNER 0x0004
#define BDR_SUNKENINNER 0x0008

#define BDR_OUTER       0x0003
#define BDR_INNER       0x000c
#define BDR_RAISED      0x0005
#define BDR_SUNKEN      0x000a

#define EDGE_RAISED     (BDR_RAISEDOUTER | BDR_RAISEDINNER)
#define EDGE_SUNKEN     (BDR_SUNKENOUTER | BDR_SUNKENINNER)
#define EDGE_ETCHED     (BDR_SUNKENOUTER | BDR_RAISEDINNER)
#define EDGE_BUMP       (BDR_RAISEDOUTER | BDR_SUNKENINNER)

/* Border flags */
#define BF_LEFT         0x0001
#define BF_TOP          0x0002
#define BF_RIGHT        0x0004
#define BF_BOTTOM       0x0008

#define BF_TOPLEFT      (BF_TOP | BF_LEFT)
#define BF_TOPRIGHT     (BF_TOP | BF_RIGHT)
#define BF_BOTTOMLEFT   (BF_BOTTOM | BF_LEFT)
#define BF_BOTTOMRIGHT  (BF_BOTTOM | BF_RIGHT)
#define BF_RECT         (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM)

#define BF_DIAGONAL     0x0010

// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.
#define BF_DIAGONAL_ENDTOPRIGHT     (BF_DIAGONAL | BF_TOP | BF_RIGHT)
#define BF_DIAGONAL_ENDTOPLEFT      (BF_DIAGONAL | BF_TOP | BF_LEFT)
#define BF_DIAGONAL_ENDBOTTOMLEFT   (BF_DIAGONAL | BF_BOTTOM | BF_LEFT)
#define BF_DIAGONAL_ENDBOTTOMRIGHT  (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT)

#define BF_MIDDLE       0x0800  /* Fill in the middle */
#define BF_SOFT         0x1000  /* For softer buttons */
#define BF_ADJUST       0x2000  /* Calculate the space left over */
#define BF_FLAT         0x4000  /* For flat rather than 3D borders */
#define BF_MONO         0x8000  /* For monochrome borders */

WINUSERAPI BOOL WINAPI DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);

/* flags for DrawFrameControl */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004

#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400
#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000

WINUSERAPI BOOL    WINAPI DrawFrameControl(HDC, LPRECT, UINT, UINT);

/* flags for DrawCaption */
#define DC_ACTIVE           0x0001
#define DC_SMALLCAP         0x0002
#define DC_ICON             0x0004
#define DC_TEXT             0x0008
#define DC_INBUTTON         0x0010
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)
#define DC_NC               (DC_CAPTION | DC_FRAME)

WINUSERAPI BOOL    WINAPI DrawCaption(HWND, HDC, CONST RECT *, UINT);

#define IDANI_OPEN          1
#define IDANI_CLOSE         2
#define IDANI_CAPTION       3
WINUSERAPI BOOL    WINAPI DrawAnimatedRects(HWND hwnd, int idAni, CONST RECT * lprcFrom, CONST RECT * lprcTo);

#endif /* WINVER >= 0x0400 */

#ifndef NOCLIPBOARD

/*
 * Predefined Clipboard Formats
 */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13
#define CF_ENHMETAFILE      14
#if(WINVER >= 0x0400)
#define CF_HDROP            15
#define CF_LOCALE           16
#define CF_MAX              17
#endif /* WINVER >= 0x0400 */

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E

/*
 * "Private" formats don't get GlobalFree()'d
 */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

#endif /* !NOCLIPBOARD */

/*
 * Defines for the fVirt field of the Accelerator table structure.
 */
#define FVIRTKEY  TRUE          /* Assumed to be == TRUE */
#define FNOINVERT 0x02
#define FSHIFT    0x04
#define FCONTROL  0x08
#define FALT      0x10

typedef struct tagACCEL {
    BYTE   fVirt;               /* Also called the flags field */
    WORD   key;
    WORD   cmd;
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;
#ifdef UNICODE
typedef CREATESTRUCTW CREATESTRUCT;
typedef LPCREATESTRUCTW LPCREATESTRUCT;
#else
typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
#endif // UNICODE

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#if(WINVER >= 0x0400)
typedef struct tagNMHDR
{
    HWND  hwndFrom;
    UINT  idFrom;
    UINT  code;         // NM_ code
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;
#endif /* WINVER >= 0x0400 */

/*
 * Owner draw control types
 */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4
#if(WINVER >= 0x0400)
#define ODT_STATIC      5
#endif /* WINVER >= 0x0400 */

/*
 * Owner draw actions
 */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/*
 * Owner draw state
 */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010
#if(WINVER >= 0x0400)
#define ODS_DEFAULT         0x0020
#define ODS_COMBOBOXEDIT    0x1000
#endif /* WINVER >= 0x0400 */

/*
 * MEASUREITEMSTRUCT for ownerdraw
 */
typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    DWORD      itemData;
} MEASUREITEMSTRUCT, NEAR *PMEASUREITEMSTRUCT, FAR *LPMEASUREITEMSTRUCT;

/*
 * DRAWITEMSTRUCT for ownerdraw
 */
typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT, NEAR *PDRAWITEMSTRUCT, FAR *LPDRAWITEMSTRUCT;

/*
 * DELETEITEMSTRUCT for ownerdraw
 */
typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    UINT       itemData;
} DELETEITEMSTRUCT, NEAR *PDELETEITEMSTRUCT, FAR *LPDELETEITEMSTRUCT;

/*
 * COMPAREITEMSTUCT for ownerdraw sorting
 */
typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT, NEAR *PCOMPAREITEMSTRUCT, FAR *LPCOMPAREITEMSTRUCT;

#ifndef NOMSG

/*
 * Message Function Templates
 */

WINUSERAPI
BOOL
WINAPI
GetMessageA(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);
WINUSERAPI
BOOL
WINAPI
GetMessageW(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);
#ifdef UNICODE
#define GetMessage  GetMessageW
#else
#define GetMessage  GetMessageA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
TranslateMessage(
    CONST MSG *lpMsg);

WINUSERAPI
LONG
WINAPI
DispatchMessageA(
    CONST MSG *lpMsg);
WINUSERAPI
LONG
WINAPI
DispatchMessageW(
    CONST MSG *lpMsg);
#ifdef UNICODE
#define DispatchMessage  DispatchMessageW
#else
#define DispatchMessage  DispatchMessageA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetMessageQueue(
    int cMessagesMax);

WINUSERAPI
BOOL
WINAPI
PeekMessageA(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);
WINUSERAPI
BOOL
WINAPI
PeekMessageW(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);
#ifdef UNICODE
#define PeekMessage  PeekMessageW
#else
#define PeekMessage  PeekMessageA
#endif // !UNICODE

/*
 * PeekMessage() Options
 */
#define PM_NOREMOVE         0x0000
#define PM_REMOVE           0x0001
#define PM_NOYIELD          0x0002

#endif /* !NOMSG */

WINUSERAPI
BOOL
WINAPI
RegisterHotKey(
    HWND hWnd ,
    int id,
    UINT fsModifiers,
    UINT vk);

WINUSERAPI
BOOL
WINAPI
UnregisterHotKey(
    HWND hWnd,
    int id);

#define MOD_ALT         0x0001
#define MOD_CONTROL     0x0002
#define MOD_SHIFT       0x0004
#define MOD_WIN         0x0008

#define IDHOT_SNAPWINDOW        (-1)    /* SHIFT-PRINTSCRN  */
#define IDHOT_SNAPDESKTOP       (-2)    /* PRINTSCRN        */

#ifdef WIN_INTERNAL
    #ifndef LSTRING
    #define NOLSTRING
    #endif /* LSTRING */
    #ifndef LFILEIO
    #define NOLFILEIO
    #endif /* LFILEIO */
#endif /* WIN_INTERNAL */

#if(WINVER >= 0x0400)
#define EW_RESTARTWINDOWS    0x0042L
#define EW_REBOOTSYSTEM      0x0043L
#define EW_EXITANDEXECAPP    0x0044L
#endif /* WINVER >= 0x0400 */

#define EWX_LOGOFF   0
#define EWX_SHUTDOWN 1
#define EWX_REBOOT   2
#define EWX_FORCE    4
#define EWX_POWEROFF 8

#define ExitWindows(dwReserved, Code) ExitWindowsEx(EWX_LOGOFF, 0xFFFFFFFF)

WINUSERAPI
BOOL
WINAPI
ExitWindowsEx(
    UINT uFlags,
    DWORD dwReserved);

WINUSERAPI
BOOL
WINAPI
SwapMouseButton(
    BOOL fSwap);

WINUSERAPI
DWORD
WINAPI
GetMessagePos(
    VOID);

WINUSERAPI
LONG
WINAPI
GetMessageTime(
    VOID);

WINUSERAPI
LONG
WINAPI
GetMessageExtraInfo(
    VOID);

#if(WINVER >= 0x0400)
WINUSERAPI
LPARAM
WINAPI
SetMessageExtraInfo(
    LPARAM lParam);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
LRESULT
WINAPI
SendMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
SendMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define SendMessage  SendMessageW
#else
#define SendMessage  SendMessageA
#endif // !UNICODE

WINUSERAPI
LRESULT
WINAPI
SendMessageTimeoutA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    LPDWORD lpdwResult);
WINUSERAPI
LRESULT
WINAPI
SendMessageTimeoutW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    LPDWORD lpdwResult);
#ifdef UNICODE
#define SendMessageTimeout  SendMessageTimeoutW
#else
#define SendMessageTimeout  SendMessageTimeoutA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SendNotifyMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
SendNotifyMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define SendNotifyMessage  SendNotifyMessageW
#else
#define SendNotifyMessage  SendNotifyMessageA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SendMessageCallbackA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    DWORD dwData);
WINUSERAPI
BOOL
WINAPI
SendMessageCallbackW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    DWORD dwData);
#ifdef UNICODE
#define SendMessageCallback  SendMessageCallbackW
#else
#define SendMessageCallback  SendMessageCallbackA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI long  WINAPI  BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM);
//Broadcast Special Message Recipient list
#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008

//Broadcast Special Message Flags
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002
#define BSF_FLUSHDISK           0x00000004
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040

typedef struct tagBROADCASTSYSMSG
{
    UINT    uiMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} BROADCASTSYSMSG;
typedef BROADCASTSYSMSG  FAR *LPBROADCASTSYSMSG;

#define DBWF_LPARAMPOINTER  0x8000

#define BROADCAST_QUERY_DENY         0x424D5144  // Return this value to deny a query.
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
PostMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
PostMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define PostMessage  PostMessageW
#else
#define PostMessage  PostMessageA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
PostThreadMessageW(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define PostThreadMessage  PostThreadMessageW
#else
#define PostThreadMessage  PostThreadMessageA
#endif // !UNICODE

#define PostAppMessageA(idThread, wMsg, wParam, lParam)\
        PostThreadMessageA((DWORD)idThread, wMsg, wParam, lParam)
#define PostAppMessageW(idThread, wMsg, wParam, lParam)\
        PostThreadMessageW((DWORD)idThread, wMsg, wParam, lParam)
#ifdef UNICODE
#define PostAppMessage  PostAppMessageW
#else
#define PostAppMessage  PostAppMessageA
#endif // !UNICODE

/*
 * Special HWND value for use with PostMessage() and SendMessage()
 */
#define HWND_BROADCAST  ((HWND)0xffff)

WINUSERAPI
BOOL
WINAPI
AttachThreadInput(
    DWORD idAttach,
    DWORD idAttachTo,
    BOOL fAttach);

WINUSERAPI
BOOL
WINAPI
ReplyMessage(
    LRESULT lResult);

WINUSERAPI
BOOL
WINAPI
WaitMessage(
    VOID);

WINUSERAPI
DWORD
WINAPI
WaitForInputIdle(
    HANDLE hProcess,
    DWORD dwMilliseconds);

WINUSERAPI
LRESULT
WINAPI
DefWindowProcA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
DefWindowProcW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define DefWindowProc  DefWindowProcW
#else
#define DefWindowProc  DefWindowProcA
#endif // !UNICODE

WINUSERAPI
VOID
WINAPI
PostQuitMessage(
    int nExitCode);

#ifdef STRICT

WINUSERAPI
LRESULT
WINAPI
CallWindowProcA(
    WNDPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
CallWindowProcW(
    WNDPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define CallWindowProc  CallWindowProcW
#else
#define CallWindowProc  CallWindowProcA
#endif // !UNICODE

#else /* !STRICT */

WINUSERAPI
LRESULT
WINAPI
CallWindowProcA(
    FARPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
CallWindowProcW(
    FARPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define CallWindowProc  CallWindowProcW
#else
#define CallWindowProc  CallWindowProcA
#endif // !UNICODE

#endif /* !STRICT */

WINUSERAPI
BOOL
WINAPI
InSendMessage(
    VOID);

WINUSERAPI
UINT
WINAPI
GetDoubleClickTime(
    VOID);

WINUSERAPI
BOOL
WINAPI
SetDoubleClickTime(
    UINT);

WINUSERAPI
ATOM
WINAPI
RegisterClassA(
    CONST WNDCLASSA *lpWndClass);
WINUSERAPI
ATOM
WINAPI
RegisterClassW(
    CONST WNDCLASSW *lpWndClass);
#ifdef UNICODE
#define RegisterClass  RegisterClassW
#else
#define RegisterClass  RegisterClassA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UnregisterClassA(
    LPCSTR lpClassName,
    HINSTANCE hInstance);
WINUSERAPI
BOOL
WINAPI
UnregisterClassW(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);
#ifdef UNICODE
#define UnregisterClass  UnregisterClassW
#else
#define UnregisterClass  UnregisterClassA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetClassInfoA(
    HINSTANCE hInstance ,
    LPCSTR lpClassName,
    LPWNDCLASSA lpWndClass);
WINUSERAPI
BOOL
WINAPI
GetClassInfoW(
    HINSTANCE hInstance ,
    LPCWSTR lpClassName,
    LPWNDCLASSW lpWndClass);
#ifdef UNICODE
#define GetClassInfo  GetClassInfoW
#else
#define GetClassInfo  GetClassInfoA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
ATOM
WINAPI
RegisterClassExA(CONST WNDCLASSEXA *);
WINUSERAPI
ATOM
WINAPI
RegisterClassExW(CONST WNDCLASSEXW *);
#ifdef UNICODE
#define RegisterClassEx  RegisterClassExW
#else
#define RegisterClassEx  RegisterClassExA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetClassInfoExA(HINSTANCE, LPCSTR, LPWNDCLASSEXA);
WINUSERAPI
BOOL
WINAPI
GetClassInfoExW(HINSTANCE, LPCWSTR, LPWNDCLASSEXW);
#ifdef UNICODE
#define GetClassInfoEx  GetClassInfoExW
#else
#define GetClassInfoEx  GetClassInfoExA
#endif // !UNICODE

#endif /* WINVER >= 0x0400 */

#define CW_USEDEFAULT       ((int)0x80000000)

/*
 * Special value for CreateWindow, et al.
 */
#define HWND_DESKTOP        ((HWND)0)

WINUSERAPI
HWND
WINAPI
CreateWindowExA(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);
WINUSERAPI
HWND
WINAPI
CreateWindowExW(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);
#ifdef UNICODE
#define CreateWindowEx  CreateWindowExW
#else
#define CreateWindowEx  CreateWindowExA
#endif // !UNICODE

#define CreateWindowA(lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\
CreateWindowExA(0L, lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)
#define CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\
CreateWindowExW(0L, lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)
#ifdef UNICODE
#define CreateWindow  CreateWindowW
#else
#define CreateWindow  CreateWindowA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsWindow(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
IsMenu(
    HMENU hMenu);

WINUSERAPI
BOOL
WINAPI
IsChild(
    HWND hWndParent,
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
DestroyWindow(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
ShowWindow(
    HWND hWnd,
    int nCmdShow);

#if(WINVER >= 0x0400)
WINUSERAPI
BOOL
WINAPI
ShowWindowAsync(
    HWND hWnd,
    int nCmdShow);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
FlashWindow(
    HWND hWnd,
    BOOL bInvert);

WINUSERAPI
BOOL
WINAPI
ShowOwnedPopups(
    HWND hWnd,
    BOOL fShow);

WINUSERAPI
BOOL
WINAPI
OpenIcon(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
CloseWindow(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
MoveWindow(
    HWND hWnd,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    BOOL bRepaint);

WINUSERAPI
BOOL
WINAPI
SetWindowPos(
    HWND hWnd,
    HWND hWndInsertAfter ,
    int X,
    int Y,
    int cx,
    int cy,
    UINT uFlags);

WINUSERAPI
BOOL
WINAPI
GetWindowPlacement(
    HWND hWnd,
    WINDOWPLACEMENT *lpwndpl);

WINUSERAPI
BOOL
WINAPI
SetWindowPlacement(
    HWND hWnd,
    CONST WINDOWPLACEMENT *lpwndpl);

#ifndef NODEFERWINDOWPOS

WINUSERAPI
HDWP
WINAPI
BeginDeferWindowPos(
    int nNumWindows);

WINUSERAPI
HDWP
WINAPI
DeferWindowPos(
    HDWP hWinPosInfo,
    HWND hWnd,
    HWND hWndInsertAfter ,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);

WINUSERAPI
BOOL
WINAPI
EndDeferWindowPos(
    HDWP hWinPosInfo);

#endif /* !NODEFERWINDOWPOS */

WINUSERAPI
BOOL
WINAPI
IsWindowVisible(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
IsIconic(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
AnyPopup(
    VOID);

WINUSERAPI
BOOL
WINAPI
BringWindowToTop(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
IsZoomed(
    HWND hWnd);

/*
 * SetWindowPos Flags
 */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */
#define SWP_NOSENDCHANGING  0x0400  /* Don't send WM_WINDOWPOSCHANGING */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#if(WINVER >= 0x0400)
#define SWP_DEFERERASE      0x2000
#define SWP_ASYNCWINDOWPOS  0x4000
#endif /* WINVER >= 0x0400 */

#define HWND_TOP        ((HWND)0)
#define HWND_BOTTOM     ((HWND)1)
#define HWND_TOPMOST    ((HWND)-1)
#define HWND_NOTOPMOST  ((HWND)-2)

#ifndef NOCTLMGR

/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#include <pshpack2.h>

/*
 * original NT 32 bit dialog template:
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;
#ifdef UNICODE
typedef LPDLGTEMPLATEW LPDLGTEMPLATE;
#else
typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
#endif // UNICODE
typedef CONST DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef CONST DLGTEMPLATE *LPCDLGTEMPLATEW;
#ifdef UNICODE
typedef LPCDLGTEMPLATEW LPCDLGTEMPLATE;
#else
typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
#endif // UNICODE

/*
 * 32 bit Dialog item template.
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;
#ifdef UNICODE
typedef PDLGITEMTEMPLATEW PDLGITEMTEMPLATE;
#else
typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
#endif // UNICODE
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;
#ifdef UNICODE
typedef LPDLGITEMTEMPLATEW LPDLGITEMTEMPLATE;
#else
typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
#endif // UNICODE

#include <poppack.h> /* Resume normal packing */

WINUSERAPI
HWND
WINAPI
CreateDialogParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
WINUSERAPI
HWND
WINAPI
CreateDialogParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#ifdef UNICODE
#define CreateDialogParam  CreateDialogParamW
#else
#define CreateDialogParam  CreateDialogParamA
#endif // !UNICODE

WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#ifdef UNICODE
#define CreateDialogIndirectParam  CreateDialogIndirectParamW
#else
#define CreateDialogIndirectParam  CreateDialogIndirectParamA
#endif // !UNICODE

#define CreateDialogA(hInstance, lpName, hWndParent, lpDialogFunc) \
CreateDialogParamA(hInstance, lpName, hWndParent, lpDialogFunc, 0L)
#define CreateDialogW(hInstance, lpName, hWndParent, lpDialogFunc) \
CreateDialogParamW(hInstance, lpName, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define CreateDialog  CreateDialogW
#else
#define CreateDialog  CreateDialogA
#endif // !UNICODE

#define CreateDialogIndirectA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
CreateDialogIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#define CreateDialogIndirectW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
CreateDialogIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define CreateDialogIndirect  CreateDialogIndirectW
#else
#define CreateDialogIndirect  CreateDialogIndirectA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
DialogBoxParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
WINUSERAPI
int
WINAPI
DialogBoxParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#ifdef UNICODE
#define DialogBoxParam  DialogBoxParamW
#else
#define DialogBoxParam  DialogBoxParamA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
DialogBoxIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA hDialogTemplate,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
WINUSERAPI
int
WINAPI
DialogBoxIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW hDialogTemplate,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#ifdef UNICODE
#define DialogBoxIndirectParam  DialogBoxIndirectParamW
#else
#define DialogBoxIndirectParam  DialogBoxIndirectParamA
#endif // !UNICODE

#define DialogBoxA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#define DialogBoxW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define DialogBox  DialogBoxW
#else
#define DialogBox  DialogBoxA
#endif // !UNICODE

#define DialogBoxIndirectA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#define DialogBoxIndirectW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define DialogBoxIndirect  DialogBoxIndirectW
#else
#define DialogBoxIndirect  DialogBoxIndirectA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EndDialog(
    HWND hDlg,
    int nResult);

WINUSERAPI
HWND
WINAPI
GetDlgItem(
    HWND hDlg,
    int nIDDlgItem);

WINUSERAPI
BOOL
WINAPI
SetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    UINT uValue,
    BOOL bSigned);

WINUSERAPI
UINT
WINAPI
GetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    BOOL *lpTranslated,
    BOOL bSigned);

WINUSERAPI
BOOL
WINAPI
SetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPCSTR lpString);
WINUSERAPI
BOOL
WINAPI
SetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString);
#ifdef UNICODE
#define SetDlgItemText  SetDlgItemTextW
#else
#define SetDlgItemText  SetDlgItemTextA
#endif // !UNICODE

WINUSERAPI
UINT
WINAPI
GetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPSTR lpString,
    int nMaxCount);
WINUSERAPI
UINT
WINAPI
GetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount);
#ifdef UNICODE
#define GetDlgItemText  GetDlgItemTextW
#else
#define GetDlgItemText  GetDlgItemTextA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
CheckDlgButton(
    HWND hDlg,
    int nIDButton,
    UINT uCheck);

WINUSERAPI
BOOL
WINAPI
CheckRadioButton(
    HWND hDlg,
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);

WINUSERAPI
UINT
WINAPI
IsDlgButtonChecked(
    HWND hDlg,
    int nIDButton);

WINUSERAPI
LONG
WINAPI
SendDlgItemMessageA(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LONG
WINAPI
SendDlgItemMessageW(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define SendDlgItemMessage  SendDlgItemMessageW
#else
#define SendDlgItemMessage  SendDlgItemMessageA
#endif // !UNICODE

WINUSERAPI
HWND
WINAPI
GetNextDlgGroupItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);

WINUSERAPI
HWND
WINAPI
GetNextDlgTabItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);

WINUSERAPI
int
WINAPI
GetDlgCtrlID(
    HWND hWnd);

WINUSERAPI
long
WINAPI
GetDialogBaseUnits(VOID);

WINUSERAPI
LRESULT
WINAPI
DefDlgProcA(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
DefDlgProcW(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define DefDlgProc  DefDlgProcW
#else
#define DefDlgProc  DefDlgProcA
#endif // !UNICODE

/*
 * Window extra byted needed for private dialog classes.
 */
#define DLGWINDOWEXTRA 30

#endif /* !NOCTLMGR */

#ifndef NOMSG

WINUSERAPI
BOOL
WINAPI
CallMsgFilterA(
    LPMSG lpMsg,
    int nCode);
WINUSERAPI
BOOL
WINAPI
CallMsgFilterW(
    LPMSG lpMsg,
    int nCode);
#ifdef UNICODE
#define CallMsgFilter  CallMsgFilterW
#else
#define CallMsgFilter  CallMsgFilterA
#endif // !UNICODE

#endif /* !NOMSG */

#ifndef NOCLIPBOARD

/*
 * Clipboard Manager Functions
 */

WINUSERAPI
BOOL
WINAPI
OpenClipboard(
    HWND hWndNewOwner);

WINUSERAPI
BOOL
WINAPI
CloseClipboard(
    VOID);

WINUSERAPI
HWND
WINAPI
GetClipboardOwner(
    VOID);

WINUSERAPI
HWND
WINAPI
SetClipboardViewer(
    HWND hWndNewViewer);

WINUSERAPI
HWND
WINAPI
GetClipboardViewer(
    VOID);

WINUSERAPI
BOOL
WINAPI
ChangeClipboardChain(
    HWND hWndRemove,
    HWND hWndNewNext);

WINUSERAPI
HANDLE
WINAPI
SetClipboardData(
    UINT uFormat,
    HANDLE hMem);

WINUSERAPI
HANDLE
WINAPI
    GetClipboardData(
    UINT uFormat);

WINUSERAPI
UINT
WINAPI
RegisterClipboardFormatA(
    LPCSTR lpszFormat);
WINUSERAPI
UINT
WINAPI
RegisterClipboardFormatW(
    LPCWSTR lpszFormat);
#ifdef UNICODE
#define RegisterClipboardFormat  RegisterClipboardFormatW
#else
#define RegisterClipboardFormat  RegisterClipboardFormatA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
CountClipboardFormats(
    VOID);

WINUSERAPI
UINT
WINAPI
EnumClipboardFormats(
    UINT format);

WINUSERAPI
int
WINAPI
GetClipboardFormatNameA(
    UINT format,
    LPSTR lpszFormatName,
    int cchMaxCount);
WINUSERAPI
int
WINAPI
GetClipboardFormatNameW(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);
#ifdef UNICODE
#define GetClipboardFormatName  GetClipboardFormatNameW
#else
#define GetClipboardFormatName  GetClipboardFormatNameA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EmptyClipboard(
    VOID);

WINUSERAPI
BOOL
WINAPI
IsClipboardFormatAvailable(
    UINT format);

WINUSERAPI
int
WINAPI
GetPriorityClipboardFormat(
    UINT *paFormatPriorityList,
    int cFormats);

WINUSERAPI
HWND
WINAPI
GetOpenClipboardWindow(
    VOID);

#endif /* !NOCLIPBOARD */

/*
 * Character Translation Routines
 */

WINUSERAPI
BOOL
WINAPI
CharToOemA(
    LPCSTR lpszSrc,
    LPSTR lpszDst);
WINUSERAPI
BOOL
WINAPI
CharToOemW(
    LPCWSTR lpszSrc,
    LPSTR lpszDst);
#ifdef UNICODE
#define CharToOem  CharToOemW
#else
#define CharToOem  CharToOemA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
OemToCharA(
    LPCSTR lpszSrc,
    LPSTR lpszDst);
WINUSERAPI
BOOL
WINAPI
OemToCharW(
    LPCSTR lpszSrc,
    LPWSTR lpszDst);
#ifdef UNICODE
#define OemToChar  OemToCharW
#else
#define OemToChar  OemToCharA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
CharToOemBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
WINUSERAPI
BOOL
WINAPI
CharToOemBuffW(
    LPCWSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
#ifdef UNICODE
#define CharToOemBuff  CharToOemBuffW
#else
#define CharToOemBuff  CharToOemBuffA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
OemToCharBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
WINUSERAPI
BOOL
WINAPI
OemToCharBuffW(
    LPCSTR lpszSrc,
    LPWSTR lpszDst,
    DWORD cchDstLength);
#ifdef UNICODE
#define OemToCharBuff  OemToCharBuffW
#else
#define OemToCharBuff  OemToCharBuffA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharUpperA(
    LPSTR lpsz);
WINUSERAPI
LPWSTR
WINAPI
CharUpperW(
    LPWSTR lpsz);
#ifdef UNICODE
#define CharUpper  CharUpperW
#else
#define CharUpper  CharUpperA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
CharUpperBuffA(
    LPSTR lpsz,
    DWORD cchLength);
WINUSERAPI
DWORD
WINAPI
CharUpperBuffW(
    LPWSTR lpsz,
    DWORD cchLength);
#ifdef UNICODE
#define CharUpperBuff  CharUpperBuffW
#else
#define CharUpperBuff  CharUpperBuffA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharLowerA(
    LPSTR lpsz);
WINUSERAPI
LPWSTR
WINAPI
CharLowerW(
    LPWSTR lpsz);
#ifdef UNICODE
#define CharLower  CharLowerW
#else
#define CharLower  CharLowerA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
CharLowerBuffA(
    LPSTR lpsz,
    DWORD cchLength);
WINUSERAPI
DWORD
WINAPI
CharLowerBuffW(
    LPWSTR lpsz,
    DWORD cchLength);
#ifdef UNICODE
#define CharLowerBuff  CharLowerBuffW
#else
#define CharLowerBuff  CharLowerBuffA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharNextA(
    LPCSTR lpsz);
WINUSERAPI
LPWSTR
WINAPI
CharNextW(
    LPCWSTR lpsz);
#ifdef UNICODE
#define CharNext  CharNextW
#else
#define CharNext  CharNextA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharPrevA(
    LPCSTR lpszStart,
    LPCSTR lpszCurrent);
WINUSERAPI
LPWSTR
WINAPI
CharPrevW(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);
#ifdef UNICODE
#define CharPrev  CharPrevW
#else
#define CharPrev  CharPrevA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
LPSTR
WINAPI
CharNextExA(
     WORD CodePage,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);

WINUSERAPI
LPSTR
WINAPI
CharPrevExA(
     WORD CodePage,
     LPCSTR lpStart,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);
#endif /* WINVER >= 0x0400 */

/*
 * Compatibility defines for character translation routines
 */
#define AnsiToOem CharToOemA
#define OemToAnsi OemToCharA
#define AnsiToOemBuff CharToOemBuffA
#define OemToAnsiBuff OemToCharBuffA
#define AnsiUpper CharUpperA
#define AnsiUpperBuff CharUpperBuffA
#define AnsiLower CharLowerA
#define AnsiLowerBuff CharLowerBuffA
#define AnsiNext CharNextA
#define AnsiPrev CharPrevA

#ifndef  NOLANGUAGE
/*
 * Language dependent Routines
 */

WINUSERAPI
BOOL
WINAPI
IsCharAlphaA(
    CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharAlphaW(
    WCHAR ch);
#ifdef UNICODE
#define IsCharAlpha  IsCharAlphaW
#else
#define IsCharAlpha  IsCharAlphaA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsCharAlphaNumericA(
    CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharAlphaNumericW(
    WCHAR ch);
#ifdef UNICODE
#define IsCharAlphaNumeric  IsCharAlphaNumericW
#else
#define IsCharAlphaNumeric  IsCharAlphaNumericA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsCharUpperA(
    CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharUpperW(
    WCHAR ch);
#ifdef UNICODE
#define IsCharUpper  IsCharUpperW
#else
#define IsCharUpper  IsCharUpperA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsCharLowerA(
    CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharLowerW(
    WCHAR ch);
#ifdef UNICODE
#define IsCharLower  IsCharLowerW
#else
#define IsCharLower  IsCharLowerA
#endif // !UNICODE

#endif  /* !NOLANGUAGE */

WINUSERAPI
HWND
WINAPI
SetFocus(
    HWND hWnd);

WINUSERAPI
HWND
WINAPI
GetActiveWindow(
    VOID);

WINUSERAPI
HWND
WINAPI
GetFocus(
    VOID);

WINUSERAPI
UINT
WINAPI
GetKBCodePage(
    VOID);

WINUSERAPI
SHORT
WINAPI
GetKeyState(
    int nVirtKey);

WINUSERAPI
SHORT
WINAPI
GetAsyncKeyState(
    int vKey);

WINUSERAPI
BOOL
WINAPI
GetKeyboardState(
    PBYTE lpKeyState);

WINUSERAPI
BOOL
WINAPI
SetKeyboardState(
    LPBYTE lpKeyState);

WINUSERAPI
int
WINAPI
GetKeyNameTextA(
    LONG lParam,
    LPSTR lpString,
    int nSize
    );
WINUSERAPI
int
WINAPI
GetKeyNameTextW(
    LONG lParam,
    LPWSTR lpString,
    int nSize
    );
#ifdef UNICODE
#define GetKeyNameText  GetKeyNameTextW
#else
#define GetKeyNameText  GetKeyNameTextA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
GetKeyboardType(
    int nTypeFlag);

WINUSERAPI
int
WINAPI
ToAscii(
    UINT uVirtKey,
    UINT uScanCode,
    PBYTE lpKeyState,
    LPWORD lpChar,
    UINT uFlags);

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
ToAsciiEx(
    UINT uVirtKey,
    UINT uScanCode,
    PBYTE lpKeyState,
    LPWORD lpChar,
    UINT uFlags,
    HKL dwhkl);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
int
WINAPI
ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    PBYTE lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags);

WINUSERAPI
DWORD
WINAPI
OemKeyScan(
    WORD wOemChar);

WINUSERAPI
SHORT
WINAPI
VkKeyScanA(
    CHAR ch);
WINUSERAPI
SHORT
WINAPI
VkKeyScanW(
    WCHAR ch);
#ifdef UNICODE
#define VkKeyScan  VkKeyScanW
#else
#define VkKeyScan  VkKeyScanA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
SHORT
WINAPI VkKeyScanExA(
    CHAR  ch,
    HKL   dwhkl);
WINUSERAPI
SHORT
WINAPI VkKeyScanExW(
    WCHAR  ch,
    HKL   dwhkl);
#ifdef UNICODE
#define VkKeyScanEx  VkKeyScanExW
#else
#define VkKeyScanEx  VkKeyScanExA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */
#define KEYEVENTF_EXTENDEDKEY 0x0001
#define KEYEVENTF_KEYUP       0x0002

WINUSERAPI
VOID
WINAPI
keybd_event(
    BYTE bVk,
    BYTE bScan,
    DWORD dwFlags,
    DWORD dwExtraInfo);

#define MOUSEEVENTF_MOVE        0x0001 /* mouse move */
#define MOUSEEVENTF_LEFTDOWN    0x0002 /* left button down */
#define MOUSEEVENTF_LEFTUP      0x0004 /* left button up */
#define MOUSEEVENTF_RIGHTDOWN   0x0008 /* right button down */
#define MOUSEEVENTF_RIGHTUP     0x0010 /* right button up */
#define MOUSEEVENTF_MIDDLEDOWN  0x0020 /* middle button down */
#define MOUSEEVENTF_MIDDLEUP    0x0040 /* middle button up */
#define MOUSEEVENTF_ABSOLUTE    0x8000 /* absolute move */

WINUSERAPI
VOID
WINAPI
mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD cButtons,
    DWORD dwExtraInfo);

WINUSERAPI
UINT
WINAPI
MapVirtualKeyA(
    UINT uCode,
    UINT uMapType);
WINUSERAPI
UINT
WINAPI
MapVirtualKeyW(
    UINT uCode,
    UINT uMapType);
#ifdef UNICODE
#define MapVirtualKey  MapVirtualKeyW
#else
#define MapVirtualKey  MapVirtualKeyA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
UINT
WINAPI
MapVirtualKeyExA(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);
WINUSERAPI
UINT
WINAPI
MapVirtualKeyExW(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);
#ifdef UNICODE
#define MapVirtualKeyEx  MapVirtualKeyExW
#else
#define MapVirtualKeyEx  MapVirtualKeyExA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
GetInputState(
    VOID);

WINUSERAPI
DWORD
WINAPI
GetQueueStatus(
    UINT flags);

WINUSERAPI
HWND
WINAPI
GetCapture(
    VOID);

WINUSERAPI
HWND
WINAPI
SetCapture(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
ReleaseCapture(
    VOID);

WINUSERAPI
DWORD
WINAPI
MsgWaitForMultipleObjects(
    DWORD nCount,
    LPHANDLE pHandles,
    BOOL fWaitAll,
    DWORD dwMilliseconds,
    DWORD dwWakeMask);

/*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 */
#define QS_KEY              0x0001
#define QS_MOUSEMOVE        0x0002
#define QS_MOUSEBUTTON      0x0004
#define QS_POSTMESSAGE      0x0008
#define QS_TIMER            0x0010
#define QS_PAINT            0x0020
#define QS_SENDMESSAGE      0x0040
#define QS_HOTKEY           0x0080

#define QS_MOUSE           (QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON)

#define QS_INPUT           (QS_MOUSE         | \
                            QS_KEY)

#define QS_ALLEVENTS       (QS_INPUT         | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_HOTKEY)

#define QS_ALLINPUT        (QS_INPUT         | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_HOTKEY        | \
                            QS_SENDMESSAGE)

/*
 * Windows Functions
 */

WINUSERAPI
UINT
WINAPI
SetTimer(
    HWND hWnd ,
    UINT nIDEvent,
    UINT uElapse,
    TIMERPROC lpTimerFunc);

WINUSERAPI
BOOL
WINAPI
KillTimer(
    HWND hWnd,
    UINT uIDEvent);

WINUSERAPI
BOOL
WINAPI
IsWindowUnicode(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
EnableWindow(
    HWND hWnd,
    BOOL bEnable);

WINUSERAPI
BOOL
WINAPI
IsWindowEnabled(
    HWND hWnd);

WINUSERAPI
HACCEL
WINAPI
LoadAcceleratorsA(
    HINSTANCE hInstance,
    LPCSTR lpTableName);
WINUSERAPI
HACCEL
WINAPI
LoadAcceleratorsW(
    HINSTANCE hInstance,
    LPCWSTR lpTableName);
#ifdef UNICODE
#define LoadAccelerators  LoadAcceleratorsW
#else
#define LoadAccelerators  LoadAcceleratorsA
#endif // !UNICODE

WINUSERAPI
HACCEL
WINAPI
CreateAcceleratorTableA(
    LPACCEL, int);
WINUSERAPI
HACCEL
WINAPI
CreateAcceleratorTableW(
    LPACCEL, int);
#ifdef UNICODE
#define CreateAcceleratorTable  CreateAcceleratorTableW
#else
#define CreateAcceleratorTable  CreateAcceleratorTableA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
DestroyAcceleratorTable(
    HACCEL hAccel);

WINUSERAPI
int
WINAPI
CopyAcceleratorTableA(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
WINUSERAPI
int
WINAPI
CopyAcceleratorTableW(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
#ifdef UNICODE
#define CopyAcceleratorTable  CopyAcceleratorTableW
#else
#define CopyAcceleratorTable  CopyAcceleratorTableA
#endif // !UNICODE

#ifndef NOMSG

WINUSERAPI
int
WINAPI
TranslateAcceleratorA(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
WINUSERAPI
int
WINAPI
TranslateAcceleratorW(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
#ifdef UNICODE
#define TranslateAccelerator  TranslateAcceleratorW
#else
#define TranslateAccelerator  TranslateAcceleratorA
#endif // !UNICODE

#endif /* !NOMSG */

#ifndef NOSYSMETRICS

/*
 * GetSystemMetrics() codes
 */
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43

#if(WINVER >= 0x0400)
#define SM_CXFIXEDFRAME           SM_CXDLGFRAME  /* ;win40 name change */
#define SM_CYFIXEDFRAME           SM_CYDLGFRAME  /* ;win40 name change */
#define SM_CXSIZEFRAME            SM_CXFRAME     /* ;win40 name change */
#define SM_CYSIZEFRAME            SM_CYFRAME     /* ;win40 name change */

#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#endif /* WINVER >= 0x0400 */
#define SM_SHOWSOUNDS           70
#if(WINVER >= 0x0400)
#define SM_CXMENUCHECK          71   /* Use instead of GetMenuCheckMarkDimensions()! */
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#endif /* WINVER >= 0x0400 */
#define SM_CMETRICS             75

WINUSERAPI
int
WINAPI
GetSystemMetrics(
    int nIndex);

#endif /* !NOSYSMETRICS */

#ifndef NOMENUS

WINUSERAPI
HMENU
WINAPI
LoadMenuA(
    HINSTANCE hInstance,
    LPCSTR lpMenuName);
WINUSERAPI
HMENU
WINAPI
LoadMenuW(
    HINSTANCE hInstance,
    LPCWSTR lpMenuName);
#ifdef UNICODE
#define LoadMenu  LoadMenuW
#else
#define LoadMenu  LoadMenuA
#endif // !UNICODE

WINUSERAPI
HMENU
WINAPI
LoadMenuIndirectA(
    CONST MENUTEMPLATEA *lpMenuTemplate);
WINUSERAPI
HMENU
WINAPI
LoadMenuIndirectW(
    CONST MENUTEMPLATEW *lpMenuTemplate);
#ifdef UNICODE
#define LoadMenuIndirect  LoadMenuIndirectW
#else
#define LoadMenuIndirect  LoadMenuIndirectA
#endif // !UNICODE

WINUSERAPI
HMENU
WINAPI
GetMenu(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
SetMenu(
    HWND hWnd,
    HMENU hMenu);

WINUSERAPI
BOOL
WINAPI
ChangeMenuA(
    HMENU hMenu,
    UINT cmd,
    LPCSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);
WINUSERAPI
BOOL
WINAPI
ChangeMenuW(
    HMENU hMenu,
    UINT cmd,
    LPCWSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);
#ifdef UNICODE
#define ChangeMenu  ChangeMenuW
#else
#define ChangeMenu  ChangeMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
HiliteMenuItem(
    HWND hWnd,
    HMENU hMenu,
    UINT uIDHiliteItem,
    UINT uHilite);

WINUSERAPI
int
WINAPI
GetMenuStringA(
    HMENU hMenu,
    UINT uIDItem,
    LPSTR lpString,
    int nMaxCount,
    UINT uFlag);
WINUSERAPI
int
WINAPI
GetMenuStringW(
    HMENU hMenu,
    UINT uIDItem,
    LPWSTR lpString,
    int nMaxCount,
    UINT uFlag);
#ifdef UNICODE
#define GetMenuString  GetMenuStringW
#else
#define GetMenuString  GetMenuStringA
#endif // !UNICODE

WINUSERAPI
UINT
WINAPI
GetMenuState(
    HMENU hMenu,
    UINT uId,
    UINT uFlags);

WINUSERAPI
BOOL
WINAPI
DrawMenuBar(
    HWND hWnd);

WINUSERAPI
HMENU
WINAPI
GetSystemMenu(
    HWND hWnd,
    BOOL bRevert);

WINUSERAPI
HMENU
WINAPI
CreateMenu(
    VOID);

WINUSERAPI
HMENU
WINAPI
CreatePopupMenu(
    VOID);

WINUSERAPI
BOOL
WINAPI
DestroyMenu(
    HMENU hMenu);

WINUSERAPI
DWORD
WINAPI
CheckMenuItem(
    HMENU hMenu,
    UINT uIDCheckItem,
    UINT uCheck);

WINUSERAPI
BOOL
WINAPI
EnableMenuItem(
    HMENU hMenu,
    UINT uIDEnableItem,
    UINT uEnable);

WINUSERAPI
HMENU
WINAPI
GetSubMenu(
    HMENU hMenu,
    int nPos);

WINUSERAPI
UINT
WINAPI
GetMenuItemID(
    HMENU hMenu,
    int nPos);

WINUSERAPI
int
WINAPI
GetMenuItemCount(
    HMENU hMenu);

WINUSERAPI
BOOL
WINAPI
InsertMenuA(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCSTR lpNewItem
    );
WINUSERAPI
BOOL
WINAPI
InsertMenuW(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );
#ifdef UNICODE
#define InsertMenu  InsertMenuW
#else
#define InsertMenu  InsertMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
AppendMenuA(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCSTR lpNewItem
    );
WINUSERAPI
BOOL
WINAPI
AppendMenuW(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );
#ifdef UNICODE
#define AppendMenu  AppendMenuW
#else
#define AppendMenu  AppendMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
ModifyMenuA(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCSTR lpNewItem
    );
WINUSERAPI
BOOL
WINAPI
ModifyMenuW(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );
#ifdef UNICODE
#define ModifyMenu  ModifyMenuW
#else
#define ModifyMenu  ModifyMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI RemoveMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);

WINUSERAPI
BOOL
WINAPI
DeleteMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);

WINUSERAPI
BOOL
WINAPI
SetMenuItemBitmaps(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    HBITMAP hBitmapUnchecked,
    HBITMAP hBitmapChecked);

WINUSERAPI
LONG
WINAPI
GetMenuCheckMarkDimensions(
    VOID);

WINUSERAPI
BOOL
WINAPI
TrackPopupMenu(
    HMENU hMenu,
    UINT uFlags,
    int x,
    int y,
    int nReserved,
    HWND hWnd,
    CONST RECT *prcRect);

#if(WINVER >= 0x0400)
/* return codes for WM_MENUCHAR */
#define MNC_IGNORE  0
#define MNC_CLOSE   1
#define MNC_EXECUTE 2
#define MNC_SELECT  3

typedef struct tagTPMPARAMS
{
    UINT    cbSize;     /* Size of structure */
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */
}   TPMPARAMS;
typedef TPMPARAMS FAR *LPTPMPARAMS;

WINUSERAPI BOOL    WINAPI TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);

#define MIIM_STATE       0x00000001
#define MIIM_ID          0x00000002
#define MIIM_SUBMENU     0x00000004
#define MIIM_CHECKMARKS  0x00000008
#define MIIM_TYPE        0x00000010
#define MIIM_DATA        0x00000020

typedef struct tagMENUITEMINFOA
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE
    UINT    fState;         // used if MIIM_STATE
    UINT    wID;            // used if MIIM_ID
    HMENU   hSubMenu;       // used if MIIM_SUBMENU
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS
    DWORD   dwItemData;     // used if MIIM_DATA
    LPSTR   dwTypeData;     // used if MIIM_TYPE
    UINT    cch;            // used if MIIM_TYPE
}   MENUITEMINFOA, FAR *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE
    UINT    fState;         // used if MIIM_STATE
    UINT    wID;            // used if MIIM_ID
    HMENU   hSubMenu;       // used if MIIM_SUBMENU
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS
    DWORD   dwItemData;     // used if MIIM_DATA
    LPWSTR  dwTypeData;     // used if MIIM_TYPE
    UINT    cch;            // used if MIIM_TYPE
}   MENUITEMINFOW, FAR *LPMENUITEMINFOW;
#ifdef UNICODE
typedef MENUITEMINFOW MENUITEMINFO;
typedef LPMENUITEMINFOW LPMENUITEMINFO;
#else
typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
#endif // UNICODE
typedef MENUITEMINFOA CONST FAR *LPCMENUITEMINFOA;
typedef MENUITEMINFOW CONST FAR *LPCMENUITEMINFOW;
#ifdef UNICODE
typedef LPCMENUITEMINFOW LPCMENUITEMINFO;
#else
typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
#endif // UNICODE

WINUSERAPI
BOOL
WINAPI
InsertMenuItemA(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOA
    );
WINUSERAPI
BOOL
WINAPI
InsertMenuItemW(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOW
    );
#ifdef UNICODE
#define InsertMenuItem  InsertMenuItemW
#else
#define InsertMenuItem  InsertMenuItemA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetMenuItemInfoA(
    HMENU,
    UINT,
    BOOL,
    LPMENUITEMINFOA
    );
WINUSERAPI
BOOL
WINAPI
GetMenuItemInfoW(
    HMENU,
    UINT,
    BOOL,
    LPMENUITEMINFOW
    );
#ifdef UNICODE
#define GetMenuItemInfo  GetMenuItemInfoW
#else
#define GetMenuItemInfo  GetMenuItemInfoA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetMenuItemInfoA(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOA
    );
WINUSERAPI
BOOL
WINAPI
SetMenuItemInfoW(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOW
    );
#ifdef UNICODE
#define SetMenuItemInfo  SetMenuItemInfoW
#else
#define SetMenuItemInfo  SetMenuItemInfoA
#endif // !UNICODE

#define GMDI_USEDISABLED    0x0001L
#define GMDI_GOINTOPOPUPS   0x0002L

WINUSERAPI UINT    WINAPI GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags);
WINUSERAPI BOOL    WINAPI SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos);

WINUSERAPI BOOL    WINAPI GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem);
WINUSERAPI int     WINAPI MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen);

#endif /* WINVER >= 0x0400 */
/*
 * Flags for TrackPopupMenu
 */
#define TPM_LEFTBUTTON  0x0000L
#define TPM_RIGHTBUTTON 0x0002L
#define TPM_LEFTALIGN   0x0000L
#define TPM_CENTERALIGN 0x0004L
#define TPM_RIGHTALIGN  0x0008L
#if(WINVER >= 0x0400)
#define TPM_TOPALIGN        0x0000L
#define TPM_VCENTERALIGN    0x0010L
#define TPM_BOTTOMALIGN     0x0020L

#define TPM_HORIZONTAL      0x0000L     /* Horz alignment matters more */
#define TPM_VERTICAL        0x0040L     /* Vert alignment matters more */
#define TPM_NONOTIFY        0x0080L     /* Don't send any notification msgs */
#define TPM_RETURNCMD       0x0100L
#endif /* WINVER >= 0x0400 */

#endif /* !NOMENUS */

#if(WINVER >= 0x0400)
//
// Drag-and-drop support
//

typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    DWORD   dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#define DOF_EXECUTABLE      0x8001
#define DOF_DOCUMENT        0x8002
#define DOF_DIRECTORY       0x8003
#define DOF_MULTIPLE        0x8004
#define DOF_PROGMAN         0x0001
#define DOF_SHELLDATA       0x0002

#define DO_DROPFILE         0x454C4946L
#define DO_PRINTFILE        0x544E5250L

WINUSERAPI
DWORD
WINAPI
DragObject(HWND, HWND, UINT, DWORD, HCURSOR);

WINUSERAPI
BOOL
WINAPI
DragDetect(HWND, POINT);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
DrawIcon(
    HDC hDC,
    int X,
    int Y,
    HICON hIcon);

#ifndef NODRAWTEXT

/*
 * DrawText() Format Flags
 */
#define DT_TOP              0x00000000
#define DT_LEFT             0x00000000
#define DT_CENTER           0x00000001
#define DT_RIGHT            0x00000002
#define DT_VCENTER          0x00000004
#define DT_BOTTOM           0x00000008
#define DT_WORDBREAK        0x00000010
#define DT_SINGLELINE       0x00000020
#define DT_EXPANDTABS       0x00000040
#define DT_TABSTOP          0x00000080
#define DT_NOCLIP           0x00000100
#define DT_EXTERNALLEADING  0x00000200
#define DT_CALCRECT         0x00000400
#define DT_NOPREFIX         0x00000800
#define DT_INTERNAL         0x00001000

#if(WINVER >= 0x0400)
#define DT_EDITCONTROL      0x00002000
#define DT_PATH_ELLIPSIS    0x00004000
#define DT_END_ELLIPSIS     0x00008000
#define DT_MODIFYSTRING     0x00010000
#define DT_RTLREADING       0x00020000
#define DT_WORD_ELLIPSIS    0x00040000

typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;
#endif /* WINVER >= 0x0400 */

WINUSERAPI
int
WINAPI
DrawTextA(
    HDC hDC,
    LPCSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat);
WINUSERAPI
int
WINAPI
DrawTextW(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat);
#ifdef UNICODE
#define DrawText  DrawTextW
#else
#define DrawText  DrawTextA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
DrawTextExA(HDC, LPSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
WINUSERAPI
int
WINAPI
DrawTextExW(HDC, LPWSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
#ifdef UNICODE
#define DrawTextEx  DrawTextExW
#else
#define DrawTextEx  DrawTextExA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

#endif /* !NODRAWTEXT */

WINUSERAPI
BOOL
WINAPI
GrayStringA(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);
WINUSERAPI
BOOL
WINAPI
GrayStringW(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);
#ifdef UNICODE
#define GrayString  GrayStringW
#else
#define GrayString  GrayStringA
#endif // !UNICODE

#if(WINVER >= 0x0400)
/* Monolithic state-drawing routine */
/* Image type */
#define DST_COMPLEX     0x0000
#define DST_TEXT        0x0001
#define DST_PREFIXTEXT  0x0002
#define DST_ICON        0x0003
#define DST_BITMAP      0x0004

/* State type */
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010  /* Gray string appearance */
#define DSS_DISABLED    0x0020
#define DSS_MONO        0x0080
#define DSS_RIGHT       0x8000

WINUSERAPI BOOL WINAPI DrawStateA(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
WINUSERAPI BOOL WINAPI DrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
#ifdef UNICODE
#define DrawState  DrawStateW
#else
#define DrawState  DrawStateA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINUSERAPI
LONG
WINAPI
TabbedTextOutA(
    HDC hDC,
    int X,
    int Y,
    LPCSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
WINUSERAPI
LONG
WINAPI
TabbedTextOutW(
    HDC hDC,
    int X,
    int Y,
    LPCWSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
#ifdef UNICODE
#define TabbedTextOut  TabbedTextOutW
#else
#define TabbedTextOut  TabbedTextOutA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
GetTabbedTextExtentA(
    HDC hDC,
    LPCSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions);
WINUSERAPI
DWORD
WINAPI
GetTabbedTextExtentW(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions);
#ifdef UNICODE
#define GetTabbedTextExtent  GetTabbedTextExtentW
#else
#define GetTabbedTextExtent  GetTabbedTextExtentA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UpdateWindow(
    HWND hWnd);

WINUSERAPI
HWND
WINAPI
SetActiveWindow(
    HWND hWnd);

WINUSERAPI
HWND
WINAPI
GetForegroundWindow(
    VOID);

#if(WINVER >= 0x0400)
WINUSERAPI BOOL WINAPI PaintDesktop(HDC hdc);

#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
SetForegroundWindow(
    HWND hWnd);

WINUSERAPI
HWND
WINAPI
WindowFromDC(
    HDC hDC);

WINUSERAPI
HDC
WINAPI
GetDC(
    HWND hWnd);

WINUSERAPI
HDC
WINAPI
GetDCEx(
    HWND hWnd ,
    HRGN hrgnClip,
    DWORD flags);

/*
 * GetDCEx() flags
 */
#define DCX_WINDOW           0x00000001L
#define DCX_CACHE            0x00000002L
#define DCX_NORESETATTRS     0x00000004L
#define DCX_CLIPCHILDREN     0x00000008L
#define DCX_CLIPSIBLINGS     0x00000010L
#define DCX_PARENTCLIP       0x00000020L

#define DCX_EXCLUDERGN       0x00000040L
#define DCX_INTERSECTRGN     0x00000080L

#define DCX_EXCLUDEUPDATE    0x00000100L
#define DCX_INTERSECTUPDATE  0x00000200L

#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_VALIDATE         0x00200000L

WINUSERAPI
HDC
WINAPI
GetWindowDC(
    HWND hWnd);

WINUSERAPI
int
WINAPI
ReleaseDC(
    HWND hWnd,
    HDC hDC);

WINUSERAPI
HDC
WINAPI
BeginPaint(
    HWND hWnd,
    LPPAINTSTRUCT lpPaint);

WINUSERAPI
BOOL
WINAPI
EndPaint(
    HWND hWnd,
    CONST PAINTSTRUCT *lpPaint);

WINUSERAPI
BOOL
WINAPI
GetUpdateRect(
    HWND hWnd,
    LPRECT lpRect,
    BOOL bErase);

WINUSERAPI
int
WINAPI
GetUpdateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);

WINUSERAPI
int
WINAPI
SetWindowRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bRedraw);

WINUSERAPI
int
WINAPI
GetWindowRgn(
    HWND hWnd,
    HRGN hRgn);

WINUSERAPI
int
WINAPI
ExcludeUpdateRgn(
    HDC hDC,
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
InvalidateRect(
    HWND hWnd ,
    CONST RECT *lpRect,
    BOOL bErase);

WINUSERAPI
BOOL
WINAPI
ValidateRect(
    HWND hWnd ,
    CONST RECT *lpRect);

WINUSERAPI
BOOL
WINAPI
InvalidateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);

WINUSERAPI
BOOL
WINAPI
ValidateRgn(
    HWND hWnd,
    HRGN hRgn);

WINUSERAPI
BOOL
WINAPI
RedrawWindow(
    HWND hWnd,
    CONST RECT *lprcUpdate,
    HRGN hrgnUpdate,
    UINT flags);

/*
 * RedrawWindow() flags
 */
#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

/*
 * LockWindowUpdate API
 */

WINUSERAPI
BOOL
WINAPI
LockWindowUpdate(
    HWND hWndLock);

WINUSERAPI
BOOL
WINAPI
ScrollWindow(
    HWND hWnd,
    int XAmount,
    int YAmount,
    CONST RECT *lpRect,
    CONST RECT *lpClipRect);

WINUSERAPI
BOOL
WINAPI
ScrollDC(
    HDC hDC,
    int dx,
    int dy,
    CONST RECT *lprcScroll,
    CONST RECT *lprcClip ,
    HRGN hrgnUpdate,
    LPRECT lprcUpdate);

WINUSERAPI
int
WINAPI
ScrollWindowEx(
    HWND hWnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);

#define SW_SCROLLCHILDREN   0x0001  /* Scroll children within *lprcScroll. */
#define SW_INVALIDATE       0x0002  /* Invalidate after scrolling */
#define SW_ERASE            0x0004  /* If SW_INVALIDATE, don't send WM_ERASEBACKGROUND */

#ifndef NOSCROLL

WINUSERAPI
int
WINAPI
SetScrollPos(
    HWND hWnd,
    int nBar,
    int nPos,
    BOOL bRedraw);

WINUSERAPI
int
WINAPI
GetScrollPos(
    HWND hWnd,
    int nBar);

WINUSERAPI
BOOL
WINAPI
SetScrollRange(
    HWND hWnd,
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw);

WINUSERAPI
BOOL
WINAPI
GetScrollRange(
    HWND hWnd,
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos);

WINUSERAPI
BOOL
WINAPI
ShowScrollBar(
    HWND hWnd,
    int wBar,
    BOOL bShow);

WINUSERAPI
BOOL
WINAPI
EnableScrollBar(
    HWND hWnd,
    UINT wSBflags,
    UINT wArrows);

/*
 * EnableScrollBar() flags
 */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* !NOSCROLL */

WINUSERAPI
BOOL
WINAPI
SetPropA(
    HWND hWnd,
    LPCSTR lpString,
    HANDLE hData);
WINUSERAPI
BOOL
WINAPI
SetPropW(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);
#ifdef UNICODE
#define SetProp  SetPropW
#else
#define SetProp  SetPropA
#endif // !UNICODE

WINUSERAPI
HANDLE
WINAPI
GetPropA(
    HWND hWnd,
    LPCSTR lpString);
WINUSERAPI
HANDLE
WINAPI
GetPropW(
    HWND hWnd,
    LPCWSTR lpString);
#ifdef UNICODE
#define GetProp  GetPropW
#else
#define GetProp  GetPropA
#endif // !UNICODE

WINUSERAPI
HANDLE
WINAPI
RemovePropA(
    HWND hWnd,
    LPCSTR lpString);
WINUSERAPI
HANDLE
WINAPI
RemovePropW(
    HWND hWnd,
    LPCWSTR lpString);
#ifdef UNICODE
#define RemoveProp  RemovePropW
#else
#define RemoveProp  RemovePropA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
EnumPropsExA(
    HWND hWnd,
    PROPENUMPROCEXA lpEnumFunc,
    LPARAM lParam);
WINUSERAPI
int
WINAPI
EnumPropsExW(
    HWND hWnd,
    PROPENUMPROCEXW lpEnumFunc,
    LPARAM lParam);
#ifdef UNICODE
#define EnumPropsEx  EnumPropsExW
#else
#define EnumPropsEx  EnumPropsExA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
EnumPropsA(
    HWND hWnd,
    PROPENUMPROCA lpEnumFunc);
WINUSERAPI
int
WINAPI
EnumPropsW(
    HWND hWnd,
    PROPENUMPROCW lpEnumFunc);
#ifdef UNICODE
#define EnumProps  EnumPropsW
#else
#define EnumProps  EnumPropsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetWindowTextA(
    HWND hWnd,
    LPCSTR lpString);
WINUSERAPI
BOOL
WINAPI
SetWindowTextW(
    HWND hWnd,
    LPCWSTR lpString);
#ifdef UNICODE
#define SetWindowText  SetWindowTextW
#else
#define SetWindowText  SetWindowTextA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
GetWindowTextA(
    HWND hWnd,
    LPSTR lpString,
    int nMaxCount);
WINUSERAPI
int
WINAPI
GetWindowTextW(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount);
#ifdef UNICODE
#define GetWindowText  GetWindowTextW
#else
#define GetWindowText  GetWindowTextA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
GetWindowTextLengthA(
    HWND hWnd);
WINUSERAPI
int
WINAPI
GetWindowTextLengthW(
    HWND hWnd);
#ifdef UNICODE
#define GetWindowTextLength  GetWindowTextLengthW
#else
#define GetWindowTextLength  GetWindowTextLengthA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetClientRect(
    HWND hWnd,
    LPRECT lpRect);

WINUSERAPI
BOOL
WINAPI
GetWindowRect(
    HWND hWnd,
    LPRECT lpRect);

WINUSERAPI
BOOL
WINAPI
AdjustWindowRect(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu);

WINUSERAPI
BOOL
WINAPI
AdjustWindowRectEx(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu,
    DWORD dwExStyle);

#if(WINVER >= 0x0400)
#define HELPINFO_WINDOW    0x0001
#define HELPINFO_MENUITEM  0x0002
typedef struct tagHELPINFO      /* Structure pointed to by lParam of WM_HELP */
{
    UINT    cbSize;             /* Size in bytes of this struct  */
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int     iCtrlId;            /* Control Id or a Menu item Id. */
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
    DWORD   dwContextId;        /* Context Id associated with this item */
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
}  HELPINFO, FAR *LPHELPINFO;

WINUSERAPI BOOL  WINAPI  SetWindowContextHelpId(HWND, DWORD);
WINUSERAPI DWORD WINAPI  GetWindowContextHelpId(HWND);
WINUSERAPI BOOL  WINAPI  SetMenuContextHelpId(HMENU, DWORD);
WINUSERAPI DWORD WINAPI  GetMenuContextHelpId(HMENU);

#endif /* WINVER >= 0x0400 */

#ifndef NOMB

/*
 * MessageBox() Flags
 */
#define MB_OK                       0x00000000L
#define MB_OKCANCEL                 0x00000001L
#define MB_ABORTRETRYIGNORE         0x00000002L
#define MB_YESNOCANCEL              0x00000003L
#define MB_YESNO                    0x00000004L
#define MB_RETRYCANCEL              0x00000005L

#define MB_ICONHAND                 0x00000010L
#define MB_ICONQUESTION             0x00000020L
#define MB_ICONEXCLAMATION          0x00000030L
#define MB_ICONASTERISK             0x00000040L

#if(WINVER >= 0x0400)
#define MB_ICONWARNING              MB_ICONEXCLAMATION
#define MB_ICONERROR                MB_ICONHAND
#endif /* WINVER >= 0x0400 */

#define MB_ICONINFORMATION          MB_ICONASTERISK
#define MB_ICONSTOP                 MB_ICONHAND

#define MB_DEFBUTTON1               0x00000000L
#define MB_DEFBUTTON2               0x00000100L
#define MB_DEFBUTTON3               0x00000200L
#if(WINVER >= 0x0400)
#define MB_DEFBUTTON4               0x00000300L
#endif /* WINVER >= 0x0400 */

#define MB_APPLMODAL                0x00000000L
#define MB_SYSTEMMODAL              0x00001000L
#define MB_TASKMODAL                0x00002000L
#if(WINVER >= 0x0400)
#define MB_HELP                     0x00004000L // Help Button
#define MB_RIGHT                    0x00080000L
#define MB_RTLREADING               0x00100000L
#endif /* WINVER >= 0x0400 */

#define MB_NOFOCUS                  0x00008000L
#define MB_SETFOREGROUND            0x00010000L
#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L
#define MB_SERVICE_NOTIFICATION     0x00040000L

#define MB_TYPEMASK                 0x0000000FL
#if(WINVER >= 0x0400)
#define MB_USERICON                 0x00000080L
#endif /* WINVER >= 0x0400 */
#define MB_ICONMASK                 0x000000F0L
#define MB_DEFMASK                  0x00000F00L
#define MB_MODEMASK                 0x00003000L
#define MB_MISCMASK                 0x0000C000L

WINUSERAPI
int
WINAPI
MessageBoxA(
    HWND hWnd ,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType);
WINUSERAPI
int
WINAPI
MessageBoxW(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);
#ifdef UNICODE
#define MessageBox  MessageBoxW
#else
#define MessageBox  MessageBoxA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
MessageBoxExA(
    HWND hWnd ,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
WINUSERAPI
int
WINAPI
MessageBoxExW(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
#ifdef UNICODE
#define MessageBoxEx  MessageBoxExW
#else
#define MessageBoxEx  MessageBoxExA
#endif // !UNICODE

#if(WINVER >= 0x0400)
#define MB_TOPMOST          0x00040000L

typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD       dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD   dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD       dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD   dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;
#ifdef UNICODE
typedef MSGBOXPARAMSW MSGBOXPARAMS;
typedef PMSGBOXPARAMSW PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSW LPMSGBOXPARAMS;
#else
typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
#endif // UNICODE

WINUSERAPI int     WINAPI MessageBoxIndirectA(LPMSGBOXPARAMSA);
WINUSERAPI int     WINAPI MessageBoxIndirectW(LPMSGBOXPARAMSW);
#ifdef UNICODE
#define MessageBoxIndirect  MessageBoxIndirectW
#else
#define MessageBoxIndirect  MessageBoxIndirectA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
MessageBeep(
    UINT uType);

#endif /* !NOMB */

WINUSERAPI
int
WINAPI
ShowCursor(
    BOOL bShow);

WINUSERAPI
BOOL
WINAPI
SetCursorPos(
    int X,
    int Y);

WINUSERAPI
HCURSOR
WINAPI
SetCursor(
    HCURSOR hCursor);

WINUSERAPI
BOOL
WINAPI
GetCursorPos(
    LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
ClipCursor(
    CONST RECT *lpRect);

WINUSERAPI
BOOL
WINAPI
GetClipCursor(
    LPRECT lpRect);

WINUSERAPI
HCURSOR
WINAPI
GetCursor(
    VOID);

WINUSERAPI
BOOL
WINAPI
CreateCaret(
    HWND hWnd,
    HBITMAP hBitmap ,
    int nWidth,
    int nHeight);

WINUSERAPI
UINT
WINAPI
GetCaretBlinkTime(
    VOID);

WINUSERAPI
BOOL
WINAPI
SetCaretBlinkTime(
    UINT uMSeconds);

WINUSERAPI
BOOL
WINAPI
DestroyCaret(
    VOID);

WINUSERAPI
BOOL
WINAPI
HideCaret(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
ShowCaret(
    HWND hWnd);

WINUSERAPI
BOOL
WINAPI
SetCaretPos(
    int X,
    int Y);

WINUSERAPI
BOOL
WINAPI
GetCaretPos(
    LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
ClientToScreen(
    HWND hWnd,
    LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
ScreenToClient(
    HWND hWnd,
    LPPOINT lpPoint);

WINUSERAPI
int
WINAPI
MapWindowPoints(
    HWND hWndFrom,
    HWND hWndTo,
    LPPOINT lpPoints,
    UINT cPoints);

WINUSERAPI
HWND
WINAPI
WindowFromPoint(
    POINT Point);

WINUSERAPI
HWND
WINAPI
ChildWindowFromPoint(
    HWND hWndParent,
    POINT Point);

#if(WINVER >= 0x0400)
#define CWP_ALL             0x0000
#define CWP_SKIPINVISIBLE   0x0001
#define CWP_SKIPDISABLED    0x0002
#define CWP_SKIPTRANSPARENT 0x0004

WINUSERAPI HWND    WINAPI ChildWindowFromPointEx(HWND, POINT, UINT);
#endif /* WINVER >= 0x0400 */

#ifndef NOCOLOR

/*
 * Color Types
 */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            7

#define COLOR_SCROLLBAR         0
#define COLOR_BACKGROUND        1
#define COLOR_ACTIVECAPTION     2
#define COLOR_INACTIVECAPTION   3
#define COLOR_MENU              4
#define COLOR_WINDOW            5
#define COLOR_WINDOWFRAME       6
#define COLOR_MENUTEXT          7
#define COLOR_WINDOWTEXT        8
#define COLOR_CAPTIONTEXT       9
#define COLOR_ACTIVEBORDER      10
#define COLOR_INACTIVEBORDER    11
#define COLOR_APPWORKSPACE      12
#define COLOR_HIGHLIGHT         13
#define COLOR_HIGHLIGHTTEXT     14
#define COLOR_BTNFACE           15
#define COLOR_BTNSHADOW         16
#define COLOR_GRAYTEXT          17
#define COLOR_BTNTEXT           18
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT      20

#if(WINVER >= 0x0400)
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24

#define COLOR_DESKTOP           COLOR_BACKGROUND
#define COLOR_3DFACE            COLOR_BTNFACE
#define COLOR_3DSHADOW          COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
#endif /* WINVER >= 0x0400 */

WINUSERAPI
DWORD
WINAPI
GetSysColor(
    int nIndex);

#if(WINVER >= 0x0400)
WINUSERAPI
HBRUSH
WINAPI
GetSysColorBrush(
    int nIndex);

#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
SetSysColors(
    int cElements,
    CONST INT * lpaElements,
    CONST COLORREF * lpaRgbValues);

#endif /* !NOCOLOR */

WINUSERAPI
BOOL
WINAPI
DrawFocusRect(
    HDC hDC,
    CONST RECT * lprc);

WINUSERAPI
int
WINAPI
FillRect(
    HDC hDC,
    CONST RECT *lprc,
    HBRUSH hbr);

WINUSERAPI
int
WINAPI
FrameRect(
    HDC hDC,
    CONST RECT *lprc,
    HBRUSH hbr);

WINUSERAPI
BOOL
WINAPI
InvertRect(
    HDC hDC,
    CONST RECT *lprc);

WINUSERAPI
BOOL
WINAPI
SetRect(
    LPRECT lprc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom);

WINUSERAPI
BOOL
WINAPI
    SetRectEmpty(
    LPRECT lprc);

WINUSERAPI
BOOL
WINAPI
CopyRect(
    LPRECT lprcDst,
    CONST RECT *lprcSrc);

WINUSERAPI
BOOL
WINAPI
InflateRect(
    LPRECT lprc,
    int dx,
    int dy);

WINUSERAPI
BOOL
WINAPI
IntersectRect(
    LPRECT lprcDst,
    CONST RECT *lprcSrc1,
    CONST RECT *lprcSrc2);

WINUSERAPI
BOOL
WINAPI
UnionRect(
    LPRECT lprcDst,
    CONST RECT *lprcSrc1,
    CONST RECT *lprcSrc2);

WINUSERAPI
BOOL
WINAPI
SubtractRect(
    LPRECT lprcDst,
    CONST RECT *lprcSrc1,
    CONST RECT *lprcSrc2);

WINUSERAPI
BOOL
WINAPI
OffsetRect(
    LPRECT lprc,
    int dx,
    int dy);

WINUSERAPI
BOOL
WINAPI
IsRectEmpty(
    CONST RECT *lprc);

WINUSERAPI
BOOL
WINAPI
EqualRect(
    CONST RECT *lprc1,
    CONST RECT *lprc2);

WINUSERAPI
BOOL
WINAPI
PtInRect(
    CONST RECT *lprc,
    POINT pt);

#ifndef NOWINOFFSETS

WINUSERAPI
WORD
WINAPI
GetWindowWord(
    HWND hWnd,
    int nIndex);

WINUSERAPI
WORD
WINAPI
SetWindowWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);

WINUSERAPI
LONG
WINAPI
GetWindowLongA(
    HWND hWnd,
    int nIndex);
WINUSERAPI
LONG
WINAPI
GetWindowLongW(
    HWND hWnd,
    int nIndex);
#ifdef UNICODE
#define GetWindowLong  GetWindowLongW
#else
#define GetWindowLong  GetWindowLongA
#endif // !UNICODE

WINUSERAPI
LONG
WINAPI
SetWindowLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
WINUSERAPI
LONG
WINAPI
SetWindowLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
#ifdef UNICODE
#define SetWindowLong  SetWindowLongW
#else
#define SetWindowLong  SetWindowLongA
#endif // !UNICODE

WINUSERAPI
WORD
WINAPI
GetClassWord(
    HWND hWnd,
    int nIndex);

WINUSERAPI
WORD
WINAPI
SetClassWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);

WINUSERAPI
DWORD
WINAPI
GetClassLongA(
    HWND hWnd,
    int nIndex);
WINUSERAPI
DWORD
WINAPI
GetClassLongW(
    HWND hWnd,
    int nIndex);
#ifdef UNICODE
#define GetClassLong  GetClassLongW
#else
#define GetClassLong  GetClassLongA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
SetClassLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
WINUSERAPI
DWORD
WINAPI
SetClassLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
#ifdef UNICODE
#define SetClassLong  SetClassLongW
#else
#define SetClassLong  SetClassLongA
#endif // !UNICODE

#endif /* !NOWINOFFSETS */

WINUSERAPI
HWND
WINAPI
GetDesktopWindow(
    VOID);

WINUSERAPI
HWND
WINAPI
GetParent(
    HWND hWnd);

WINUSERAPI
HWND
WINAPI
SetParent(
    HWND hWndChild,
    HWND hWndNewParent);

WINUSERAPI
BOOL
WINAPI
EnumChildWindows(
    HWND hWndParent,
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);

WINUSERAPI
HWND
WINAPI
FindWindowA(
    LPCSTR lpClassName ,
    LPCSTR lpWindowName);
WINUSERAPI
HWND
WINAPI
FindWindowW(
    LPCWSTR lpClassName ,
    LPCWSTR lpWindowName);
#ifdef UNICODE
#define FindWindow  FindWindowW
#else
#define FindWindow  FindWindowA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI HWND    WINAPI FindWindowExA(HWND, HWND, LPCSTR, LPCSTR);
WINUSERAPI HWND    WINAPI FindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR);
#ifdef UNICODE
#define FindWindowEx  FindWindowExW
#else
#define FindWindowEx  FindWindowExA
#endif // !UNICODE

#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
EnumWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);

WINUSERAPI
BOOL
WINAPI
EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam);

#define EnumTaskWindows(hTask, lpfn, lParam) EnumThreadWindows((DWORD)hTask, lpfn, lParam)

WINUSERAPI
int
WINAPI
GetClassNameA(
    HWND hWnd,
    LPSTR lpClassName,
    int nMaxCount);
WINUSERAPI
int
WINAPI
GetClassNameW(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);
#ifdef UNICODE
#define GetClassName  GetClassNameW
#else
#define GetClassName  GetClassNameA
#endif // !UNICODE

WINUSERAPI
HWND
WINAPI
GetTopWindow(
    HWND hWnd);

#define GetNextWindow(hWnd, wCmd) GetWindow(hWnd, wCmd)
#define GetSysModalWindow() (NULL)
#define SetSysModalWindow(hWnd) (NULL)

WINUSERAPI
DWORD
WINAPI
GetWindowThreadProcessId(
    HWND hWnd,
    LPDWORD lpdwProcessId);

#define GetWindowTask(hWnd) \
        ((HANDLE)GetWindowThreadProcessId(hWnd, NULL))

WINUSERAPI
HWND
WINAPI
GetLastActivePopup(
    HWND hWnd);

/*
 * GetWindow() Constants
 */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5
#define GW_MAX              5

WINUSERAPI
HWND
WINAPI
GetWindow(
    HWND hWnd,
    UINT uCmd);

#ifndef NOWH

#ifdef STRICT

WINUSERAPI
HHOOK
WINAPI
SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc);
WINUSERAPI
HHOOK
WINAPI
SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc);
#ifdef UNICODE
#define SetWindowsHook  SetWindowsHookW
#else
#define SetWindowsHook  SetWindowsHookA
#endif // !UNICODE

#else /* !STRICT */

WINUSERAPI
HOOKPROC
WINAPI
SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc);
WINUSERAPI
HOOKPROC
WINAPI
SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc);
#ifdef UNICODE
#define SetWindowsHook  SetWindowsHookW
#else
#define SetWindowsHook  SetWindowsHookA
#endif // !UNICODE

#endif /* !STRICT */

WINUSERAPI
BOOL
WINAPI
UnhookWindowsHook(
    int nCode,
    HOOKPROC pfnFilterProc);

WINUSERAPI
HHOOK
WINAPI
SetWindowsHookExA(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);
WINUSERAPI
HHOOK
WINAPI
SetWindowsHookExW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);
#ifdef UNICODE
#define SetWindowsHookEx  SetWindowsHookExW
#else
#define SetWindowsHookEx  SetWindowsHookExA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UnhookWindowsHookEx(
    HHOOK hhk);

WINUSERAPI
LRESULT
WINAPI
CallNextHookEx(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam);

/*
 * Macros for source-level compatibility with old functions.
 */
#ifdef STRICT
#define DefHookProc(nCode, wParam, lParam, phhk)\
        CallNextHookEx(*phhk, nCode, wParam, lParam)
#else
#define DefHookProc(nCode, wParam, lParam, phhk)\
        CallNextHookEx((HHOOK)*phhk, nCode, wParam, lParam)
#endif /* STRICT */

#endif /* !NOWH */

#ifndef NOMENUS

/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
#define MF_INSERT           0x00000000L
#define MF_CHANGE           0x00000080L
#define MF_APPEND           0x00000100L
#define MF_DELETE           0x00000200L
#define MF_REMOVE           0x00001000L

#define MF_BYCOMMAND        0x00000000L
#define MF_BYPOSITION       0x00000400L

#define MF_SEPARATOR        0x00000800L

#define MF_ENABLED          0x00000000L
#define MF_GRAYED           0x00000001L
#define MF_DISABLED         0x00000002L

#define MF_UNCHECKED        0x00000000L
#define MF_CHECKED          0x00000008L
#define MF_USECHECKBITMAPS  0x00000200L

#define MF_STRING           0x00000000L
#define MF_BITMAP           0x00000004L
#define MF_OWNERDRAW        0x00000100L

#define MF_POPUP            0x00000010L
#define MF_MENUBARBREAK     0x00000020L
#define MF_MENUBREAK        0x00000040L

#define MF_UNHILITE         0x00000000L
#define MF_HILITE           0x00000080L

#if(WINVER >= 0x0400)
#define MF_DEFAULT          0x00001000L
#endif /* WINVER >= 0x0400 */
#define MF_SYSMENU          0x00002000L
#define MF_HELP             0x00004000L
#if(WINVER >= 0x0400)
#define MF_RIGHTJUSTIFY     0x00004000L
#endif /* WINVER >= 0x0400 */

#define MF_MOUSESELECT      0x00008000L
#if(WINVER >= 0x0400)
#define MF_END              0x00000080L  /* Obsolete -- only used by old RES files */
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)
#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT

WINUSERAPI
BOOL
WINAPI
CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT);
#endif /* WINVER >= 0x0400 */

/*
 * Menu item resource format
 */
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        // version 0
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;
#define MF_END             0x00000080L

#endif /* !NOMENUS */

#ifndef NOSYSCOMMANDS

/*
 * System Menu Command Values
 */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#if(WINVER >= 0x0400)
#define SC_DEFAULT      0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP  0xF180
#define SC_SEPARATOR    0xF00F
#endif /* WINVER >= 0x0400 */
/*
 * Obsolete names
 */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif /* !NOSYSCOMMANDS */

/*
 * Resource Loading Routines
 */

WINUSERAPI
HBITMAP
WINAPI
LoadBitmapA(
    HINSTANCE hInstance,
    LPCSTR lpBitmapName);
WINUSERAPI
HBITMAP
WINAPI
LoadBitmapW(
    HINSTANCE hInstance,
    LPCWSTR lpBitmapName);
#ifdef UNICODE
#define LoadBitmap  LoadBitmapW
#else
#define LoadBitmap  LoadBitmapA
#endif // !UNICODE

WINUSERAPI
HCURSOR
WINAPI
LoadCursorA(
    HINSTANCE hInstance,
    LPCSTR lpCursorName);
WINUSERAPI
HCURSOR
WINAPI
LoadCursorW(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName);
#ifdef UNICODE
#define LoadCursor  LoadCursorW
#else
#define LoadCursor  LoadCursorA
#endif // !UNICODE

WINUSERAPI
HCURSOR
WINAPI
LoadCursorFromFileA(
    LPCSTR    lpFileName);
WINUSERAPI
HCURSOR
WINAPI
LoadCursorFromFileW(
    LPCWSTR    lpFileName);
#ifdef UNICODE
#define LoadCursorFromFile  LoadCursorFromFileW
#else
#define LoadCursorFromFile  LoadCursorFromFileA
#endif // !UNICODE

WINUSERAPI
HCURSOR
WINAPI
CreateCursor(
    HINSTANCE hInst,
    int xHotSpot,
    int yHotSpot,
    int nWidth,
    int nHeight,
    CONST VOID *pvANDPlane,
    CONST VOID *pvXORPlane);

WINUSERAPI
BOOL
WINAPI
DestroyCursor(
    HCURSOR hCursor);

#define CopyCursor(pcur) ((HCURSOR)CopyIcon((HICON)(pcur)))

/*
 * Standard Cursor IDs
 */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)  /* OBSOLETE: use IDC_SIZEALL */
#define IDC_ICON            MAKEINTRESOURCE(32641)  /* OBSOLETE: use IDC_ARROW */
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)
#define IDC_SIZEALL         MAKEINTRESOURCE(32646)
#define IDC_NO              MAKEINTRESOURCE(32648) /*not in win3.1 */
#define IDC_APPSTARTING     MAKEINTRESOURCE(32650) /*not in win3.1 */
#if(WINVER >= 0x0400)
#define IDC_HELP            MAKEINTRESOURCE(32651)
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
SetSystemCursor(
    HCURSOR hcur,
    DWORD   id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

WINUSERAPI
HICON
WINAPI
LoadIconA(
    HINSTANCE hInstance,
    LPCSTR lpIconName);
WINUSERAPI
HICON
WINAPI
LoadIconW(
    HINSTANCE hInstance,
    LPCWSTR lpIconName);
#ifdef UNICODE
#define LoadIcon  LoadIconW
#else
#define LoadIcon  LoadIconA
#endif // !UNICODE

WINUSERAPI
HICON
WINAPI
CreateIcon(
    HINSTANCE hInstance,
    int nWidth,
    int nHeight,
    BYTE cPlanes,
    BYTE cBitsPixel,
    CONST BYTE *lpbANDbits,
    CONST BYTE *lpbXORbits);

WINUSERAPI
BOOL
WINAPI
DestroyIcon(
    HICON hIcon);

WINUSERAPI
int
WINAPI
LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL fIcon);

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
LookupIconIdFromDirectoryEx(
    PBYTE presbits,
    BOOL  fIcon,
    int   cxDesired,
    int   cyDesired,
    UINT  Flags);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
HICON
WINAPI
CreateIconFromResource(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL fIcon,
    DWORD dwVer);

#if(WINVER >= 0x0400)
WINUSERAPI
HICON
WINAPI
CreateIconFromResourceEx(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL  fIcon,
    DWORD dwVer,
    int   cxDesired,
    int   cyDesired,
    UINT  Flags);

/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE, FAR *LPCURSORSHAPE;
#endif /* WINVER >= 0x0400 */

#define IMAGE_BITMAP        0
#define IMAGE_ICON          1
#define IMAGE_CURSOR        2
#if(WINVER >= 0x0400)
#define IMAGE_ENHMETAFILE   3

#define LR_DEFAULTCOLOR     0x0000
#define LR_MONOCHROME       0x0001
#define LR_COLOR            0x0002
#define LR_COPYRETURNORG    0x0004
#define LR_COPYDELETEORG    0x0008
#define LR_LOADFROMFILE     0x0010
#define LR_LOADTRANSPARENT  0x0020
#define LR_DEFAULTSIZE      0x0040
#define LR_LOADREALSIZE     0x0080
#define LR_LOADMAP3DCOLORS  0x1000
#define LR_CREATEDIBSECTION 0x2000

WINUSERAPI
HANDLE
WINAPI
LoadImageA(
    HINSTANCE,
    LPCSTR,
    UINT,
    int,
    int,
    UINT);
WINUSERAPI
HANDLE
WINAPI
LoadImageW(
    HINSTANCE,
    LPCWSTR,
    UINT,
    int,
    int,
    UINT);
#ifdef UNICODE
#define LoadImage  LoadImageW
#else
#define LoadImage  LoadImageA
#endif // !UNICODE

WINUSERAPI
HICON
WINAPI
CopyImage(
    HANDLE,
    UINT,
    int,
    int,
    UINT);

#define DI_MASK         0x0001
#define DI_IMAGE        0x0002
#define DI_NORMAL       0x0003
#define DI_COMPAT       0x0004
#define DI_DEFAULTSIZE  0x0008

WINUSERAPI BOOL WINAPI DrawIconEx(HDC hdc, int xLeft, int yTop,
              HICON hIcon, int cxWidth, int cyWidth,
              UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
HICON
WINAPI
CreateIconIndirect(
    PICONINFO piconinfo);

WINUSERAPI
HICON
WINAPI
CopyIcon(
    HICON hIcon);

WINUSERAPI
BOOL
WINAPI
GetIconInfo(
    HICON hIcon,
    PICONINFO piconinfo);

#if(WINVER >= 0x0400)
#define RES_ICON    1
#define RES_CURSOR  2
#endif /* WINVER >= 0x0400 */

#ifdef OEMRESOURCE

/*
 * OEM Resource Ordinal Numbers
 */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640   /* OBSOLETE: use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE: use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE: use OIC_WINLOGO */
#define OCR_NO              32648
#if(WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#endif /* WINVER >= 0x0400 */

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516
#if(WINVER >= 0x0400)
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif /* WINVER >= 0x0400 */

#endif /* OEMRESOURCE */

#define ORD_LANGDRIVER    1     /* The ordinal number for the entry point of
                                ** language drivers.
                                */

#ifndef NOICONS

/*
 * Standard Icon IDs
 */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         32517
#endif /* WINVER >= 0x0400 */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)
#endif /* WINVER >= 0x0400 */
#endif /* RC_INVOKED */

#if(WINVER >= 0x0400)
#define IDI_WARNING     IDI_EXCLAMATION
#define IDI_ERROR       IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#endif /* WINVER >= 0x0400 */

#endif /* !NOICONS */

WINUSERAPI
int
WINAPI
LoadStringA(
    HINSTANCE hInstance,
    UINT uID,
    LPSTR lpBuffer,
    int nBufferMax);
WINUSERAPI
int
WINAPI
LoadStringW(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax);
#ifdef UNICODE
#define LoadString  LoadStringW
#else
#define LoadString  LoadStringA
#endif // !UNICODE

/*
 * Dialog Box Command IDs
 */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7
#if(WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif /* WINVER >= 0x0400 */

#ifndef NOCTLMGR

/*
 * Control Manager Structures and Definitions
 */

#ifndef NOWINSTYLES

/*
 * Edit Control Styles
 */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L
#define ES_READONLY         0x0800L
#define ES_WANTRETURN       0x1000L
#if(WINVER >= 0x0400)
#define ES_NUMBER           0x2000L
#endif /* WINVER >= 0x0400 */

#endif /* !NOWINSTYLES */

/*
 * Edit Control Notification Codes
 */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#if(WINVER >= 0x0400)
/* Edit control EM_SETMARGIN parameters */
#define EC_LEFTMARGIN       0x0001
#define EC_RIGHTMARGIN      0x0002
#define EC_USEFONTINFO      0xffff
#endif /* WINVER >= 0x0400 */

#ifndef NOWINMESSAGES

/*
 * Edit Control Messages
 */
#define EM_GETSEL               0x00B0
#define EM_SETSEL               0x00B1
#define EM_GETRECT              0x00B2
#define EM_SETRECT              0x00B3
#define EM_SETRECTNP            0x00B4
#define EM_SCROLL               0x00B5
#define EM_LINESCROLL           0x00B6
#define EM_SCROLLCARET          0x00B7
#define EM_GETMODIFY            0x00B8
#define EM_SETMODIFY            0x00B9
#define EM_GETLINECOUNT         0x00BA
#define EM_LINEINDEX            0x00BB
#define EM_SETHANDLE            0x00BC
#define EM_GETHANDLE            0x00BD
#define EM_GETTHUMB             0x00BE
#define EM_LINELENGTH           0x00C1
#define EM_REPLACESEL           0x00C2
#define EM_GETLINE              0x00C4
#define EM_LIMITTEXT            0x00C5
#define EM_CANUNDO              0x00C6
#define EM_UNDO                 0x00C7
#define EM_FMTLINES             0x00C8
#define EM_LINEFROMCHAR         0x00C9
#define EM_SETTABSTOPS          0x00CB
#define EM_SETPASSWORDCHAR      0x00CC
#define EM_EMPTYUNDOBUFFER      0x00CD
#define EM_GETFIRSTVISIBLELINE  0x00CE
#define EM_SETREADONLY          0x00CF
#define EM_SETWORDBREAKPROC     0x00D0
#define EM_GETWORDBREAKPROC     0x00D1
#define EM_GETPASSWORDCHAR      0x00D2
#if(WINVER >= 0x0400)
#define EM_SETMARGINS           0x00D3
#define EM_GETMARGINS           0x00D4
#define EM_SETLIMITTEXT         EM_LIMITTEXT   /* ;win40 Name change */
#define EM_GETLIMITTEXT         0x00D5
#define EM_POSFROMCHAR          0x00D6
#define EM_CHARFROMPOS          0x00D7
#endif /* WINVER >= 0x0400 */

#endif /* !NOWINMESSAGES */

/*
 * EDITWORDBREAKPROC code values
 */
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2

/*
 * Button Control Styles
 */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L
#if(WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif /* WINVER >= 0x0400 */

/*
 * User Button Notification Codes
 */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5
#if(WINVER >= 0x0400)
#define BN_PUSHED           BN_HILITE
#define BN_UNPUSHED         BN_UNHILITE
#define BN_DBLCLK           BN_DOUBLECLICKED
#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7
#endif /* WINVER >= 0x0400 */

/*
 * Button Control Messages
 */
#define BM_GETCHECK        0x00F0
#define BM_SETCHECK        0x00F1
#define BM_GETSTATE        0x00F2
#define BM_SETSTATE        0x00F3
#define BM_SETSTYLE        0x00F4
#if(WINVER >= 0x0400)
#define BM_CLICK           0x00F5
#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7

#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008
#endif /* WINVER >= 0x0400 */

/*
 * Static Control Constants
 */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_BITMAP           0x0000000EL
#if(WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#define SS_TYPEMASK         0x0000001FL
#endif /* WINVER >= 0x0400 */
#define SS_NOPREFIX         0x00000080L /* Don't do "&" character translation */
#if(WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#endif /* WINVER >= 0x0400 */
#define SS_CENTERIMAGE      0x00000200L
#if(WINVER >= 0x0400)
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#endif /* WINVER >= 0x0400 */

#ifndef NOWINMESSAGES
/*
 * Static Control Mesages
 */
#define STM_SETICON         0x0170
#define STM_GETICON         0x0171
#define STM_SETIMAGE        0x0172
#define STM_GETIMAGE        0x0173
#if(WINVER >= 0x0400)
#define STN_CLICKED         0
#define STN_DBLCLK          1
#define STN_ENABLE          2
#define STN_DISABLE         3
#endif /* WINVER >= 0x0400 */
#define STM_MSGMAX          0x0174
#endif /* !NOWINMESSAGES */

/*
 * Dialog window class
 */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/*
 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
 */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

/*
 * Dialog Manager Routines
 */

#ifndef NOMSG

WINUSERAPI
BOOL
WINAPI
IsDialogMessageA(
    HWND hDlg,
    LPMSG lpMsg);
WINUSERAPI
BOOL
WINAPI
IsDialogMessageW(
    HWND hDlg,
    LPMSG lpMsg);
#ifdef UNICODE
#define IsDialogMessage  IsDialogMessageW
#else
#define IsDialogMessage  IsDialogMessageA
#endif // !UNICODE

#endif /* !NOMSG */

WINUSERAPI
BOOL
WINAPI
MapDialogRect(
    HWND hDlg,
    LPRECT lpRect);

WINUSERAPI
int
WINAPI
DlgDirListA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
WINUSERAPI
int
WINAPI
DlgDirListW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
#ifdef UNICODE
#define DlgDirList  DlgDirListW
#else
#define DlgDirList  DlgDirListA
#endif // !UNICODE

/*
 * DlgDirList, DlgDirListComboBox flags values
 */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000

WINUSERAPI
BOOL
WINAPI
DlgDirSelectExA(
    HWND hDlg,
    LPSTR lpString,
    int nCount,
    int nIDListBox);
WINUSERAPI
BOOL
WINAPI
DlgDirSelectExW(
    HWND hDlg,
    LPWSTR lpString,
    int nCount,
    int nIDListBox);
#ifdef UNICODE
#define DlgDirSelectEx  DlgDirSelectExW
#else
#define DlgDirSelectEx  DlgDirSelectExA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
DlgDirListComboBoxA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
WINUSERAPI
int
WINAPI
DlgDirListComboBoxW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
#ifdef UNICODE
#define DlgDirListComboBox  DlgDirListComboBoxW
#else
#define DlgDirListComboBox  DlgDirListComboBoxA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
DlgDirSelectComboBoxExA(
    HWND hDlg,
    LPSTR lpString,
    int nCount,
    int nIDComboBox);
WINUSERAPI
BOOL
WINAPI
DlgDirSelectComboBoxExW(
    HWND hDlg,
    LPWSTR lpString,
    int nCount,
    int nIDComboBox);
#ifdef UNICODE
#define DlgDirSelectComboBoxEx  DlgDirSelectComboBoxExW
#else
#define DlgDirSelectComboBoxEx  DlgDirSelectComboBoxExA
#endif // !UNICODE

/*
 * Dialog Styles
 */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */
#define DS_SETFOREGROUND    0x200L  /* not in win3.1 */

#if(WINVER >= 0x0400)
#define DS_3DLOOK           0x0004L
#define DS_FIXEDSYS         0x0008L
#define DS_NOFAILCREATE     0x0010L
#define DS_CONTROL          0x0400L
#define DS_CENTER           0x0800L
#define DS_CENTERMOUSE      0x1000L
#define DS_CONTEXTHELP      0x2000L

#endif /* WINVER >= 0x0400 */

#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

#if(WINVER >= 0x0400)
#define DM_REPOSITION       (WM_USER+2)

#define PSM_PAGEINFO        (WM_USER+100)
#define PSM_SHEETINFO       (WM_USER+101)

#define PSI_SETACTIVE       0x0001L
#define PSI_KILLACTIVE      0x0002L
#define PSI_APPLY           0x0003L
#define PSI_RESET           0x0004L
#define PSI_HASHELP         0x0005L
#define PSI_HELP            0x0006L

#define PSI_CHANGED         0x0001L
#define PSI_GUISTART        0x0002L
#define PSI_REBOOT          0x0003L
#define PSI_GETSIBLINGS     0x0004L
#endif /* WINVER >= 0x0400 */
/*
 * Returned in HIWORD() of DM_GETDEFID result if msg is supported
 */
#define DC_HASDEFID         0x534B

/*
 * Dialog Codes
 */
#define DLGC_WANTARROWS     0x0001      /* Control wants arrow keys         */
#define DLGC_WANTTAB        0x0002      /* Control wants tab keys           */
#define DLGC_WANTALLKEYS    0x0004      /* Control wants all keys           */
#define DLGC_WANTMESSAGE    0x0004      /* Pass message to control          */
#define DLGC_HASSETSEL      0x0008      /* Understands EM_SETSEL message    */
#define DLGC_DEFPUSHBUTTON  0x0010      /* Default pushbutton               */
#define DLGC_UNDEFPUSHBUTTON 0x0020     /* Non-default pushbutton           */
#define DLGC_RADIOBUTTON    0x0040      /* Radio button                     */
#define DLGC_WANTCHARS      0x0080      /* Want WM_CHAR messages            */
#define DLGC_STATIC         0x0100      /* Static item: don't include       */
#define DLGC_BUTTON         0x2000      /* Button item: can be checked      */

#define LB_CTLCODE          0L

/*
 * Listbox Return Values
 */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */

/*
 * Listbox Notification Codes
 */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

#ifndef NOWINMESSAGES

/*
 * Listbox messages
 */
#define LB_ADDSTRING            0x0180
#define LB_INSERTSTRING         0x0181
#define LB_DELETESTRING         0x0182
#define LB_SELITEMRANGEEX       0x0183
#define LB_RESETCONTENT         0x0184
#define LB_SETSEL               0x0185
#define LB_SETCURSEL            0x0186
#define LB_GETSEL               0x0187
#define LB_GETCURSEL            0x0188
#define LB_GETTEXT              0x0189
#define LB_GETTEXTLEN           0x018A
#define LB_GETCOUNT             0x018B
#define LB_SELECTSTRING         0x018C
#define LB_DIR                  0x018D
#define LB_GETTOPINDEX          0x018E
#define LB_FINDSTRING           0x018F
#define LB_GETSELCOUNT          0x0190
#define LB_GETSELITEMS          0x0191
#define LB_SETTABSTOPS          0x0192
#define LB_GETHORIZONTALEXTENT  0x0193
#define LB_SETHORIZONTALEXTENT  0x0194
#define LB_SETCOLUMNWIDTH       0x0195
#define LB_ADDFILE              0x0196
#define LB_SETTOPINDEX          0x0197
#define LB_GETITEMRECT          0x0198
#define LB_GETITEMDATA          0x0199
#define LB_SETITEMDATA          0x019A
#define LB_SELITEMRANGE         0x019B
#define LB_SETANCHORINDEX       0x019C
#define LB_GETANCHORINDEX       0x019D
#define LB_SETCARETINDEX        0x019E
#define LB_GETCARETINDEX        0x019F
#define LB_SETITEMHEIGHT        0x01A0
#define LB_GETITEMHEIGHT        0x01A1
#define LB_FINDSTRINGEXACT      0x01A2
#define LB_SETLOCALE            0x01A5
#define LB_GETLOCALE            0x01A6
#define LB_SETCOUNT             0x01A7
#if(WINVER >= 0x0400)
#define LB_INITSTORAGE          0x01A8
#define LB_ITEMFROMPOINT        0x01A9
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0400)
#define LB_MSGMAX               0x01B0
#else
#define LB_MSGMAX               0x01A8
#endif

#endif /* !NOWINMESSAGES */

#ifndef NOWINSTYLES

/*
 * Listbox Styles
 */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_DISABLENOSCROLL   0x1000L
#define LBS_NODATA            0x2000L
#if(WINVER >= 0x0400)
#define LBS_NOSEL             0x4000L
#endif /* WINVER >= 0x0400 */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#endif /* !NOWINSTYLES */

/*
 * Combo Box return Values
 */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)

/*
 * Combo Box Notification Codes
 */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10

/*
 * Combo Box styles
 */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#define CBS_DISABLENOSCROLL   0x0800L
#if(WINVER >= 0x0400)
#define CBS_UPPERCASE           0x2000L
#define CBS_LOWERCASE           0x4000L
#endif /* WINVER >= 0x0400 */
#endif  /* !NOWINSTYLES */

/*
 * Combo Box messages
 */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL               0x0140
#define CB_LIMITTEXT                0x0141
#define CB_SETEDITSEL               0x0142
#define CB_ADDSTRING                0x0143
#define CB_DELETESTRING             0x0144
#define CB_DIR                      0x0145
#define CB_GETCOUNT                 0x0146
#define CB_GETCURSEL                0x0147
#define CB_GETLBTEXT                0x0148
#define CB_GETLBTEXTLEN             0x0149
#define CB_INSERTSTRING             0x014A
#define CB_RESETCONTENT             0x014B
#define CB_FINDSTRING               0x014C
#define CB_SELECTSTRING             0x014D
#define CB_SETCURSEL                0x014E
#define CB_SHOWDROPDOWN             0x014F
#define CB_GETITEMDATA              0x0150
#define CB_SETITEMDATA              0x0151
#define CB_GETDROPPEDCONTROLRECT    0x0152
#define CB_SETITEMHEIGHT            0x0153
#define CB_GETITEMHEIGHT            0x0154
#define CB_SETEXTENDEDUI            0x0155
#define CB_GETEXTENDEDUI            0x0156
#define CB_GETDROPPEDSTATE          0x0157
#define CB_FINDSTRINGEXACT          0x0158
#define CB_SETLOCALE                0x0159
#define CB_GETLOCALE                0x015A
#if(WINVER >= 0x0400)
#define CB_GETTOPINDEX              0x015b
#define CB_SETTOPINDEX              0x015c
#define CB_GETHORIZONTALEXTENT      0x015d
#define CB_SETHORIZONTALEXTENT      0x015e
#define CB_GETDROPPEDWIDTH          0x015f
#define CB_SETDROPPEDWIDTH          0x0160
#define CB_INITSTORAGE              0x0161
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0400)
#define CB_MSGMAX                   0x0162
#else
#define CB_MSGMAX                   0x015B
#endif
#endif  /* !NOWINMESSAGES */

#ifndef NOWINSTYLES

/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#if(WINVER >= 0x0400)
#define SBS_SIZEGRIP                0x0010L
#endif /* WINVER >= 0x0400 */
#endif /* !NOWINSTYLES */

/*
 * Scroll bar messages
 */
#ifndef NOWINMESSAGES
#define SBM_SETPOS                  0x00E0 /*not in win3.1 */
#define SBM_GETPOS                  0x00E1 /*not in win3.1 */
#define SBM_SETRANGE                0x00E2 /*not in win3.1 */
#define SBM_SETRANGEREDRAW          0x00E6 /*not in win3.1 */
#define SBM_GETRANGE                0x00E3 /*not in win3.1 */
#define SBM_ENABLE_ARROWS           0x00E4 /*not in win3.1 */
#if(WINVER >= 0x0400)
#define SBM_SETSCROLLINFO           0x00E9
#define SBM_GETSCROLLINFO           0x00EA

#define SIF_RANGE           0x0001
#define SIF_PAGE            0x0002
#define SIF_POS             0x0004
#define SIF_DISABLENOSCROLL 0x0008
#define SIF_TRACKPOS        0x0010
#define SIF_ALL             (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)

typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO, FAR *LPSCROLLINFO;
typedef SCROLLINFO CONST FAR *LPCSCROLLINFO;

WINUSERAPI int     WINAPI SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL);
WINUSERAPI BOOL    WINAPI GetScrollInfo(HWND, int, LPSCROLLINFO);
#endif /* WINVER >= 0x0400 */
#endif /* !NOWINMESSAGES */
#endif /* !NOCTLMGR */

#ifndef NOMDI

/*
 * MDI client style bits
 */
#define MDIS_ALLCHILDSTYLES    0x0001

/*
 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
 */
#define MDITILE_VERTICAL       0x0000 /*not in win3.1 */
#define MDITILE_HORIZONTAL     0x0001 /*not in win3.1 */
#define MDITILE_SKIPDISABLED   0x0002 /*not in win3.1 */

typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;
#ifdef UNICODE
typedef MDICREATESTRUCTW MDICREATESTRUCT;
typedef LPMDICREATESTRUCTW LPMDICREATESTRUCT;
#else
typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
#endif // UNICODE

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

WINUSERAPI
LRESULT
WINAPI
DefFrameProcA(
    HWND hWnd,
    HWND hWndMDIClient ,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
DefFrameProcW(
    HWND hWnd,
    HWND hWndMDIClient ,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define DefFrameProc  DefFrameProcW
#else
#define DefFrameProc  DefFrameProcA
#endif // !UNICODE

WINUSERAPI
LRESULT
WINAPI
DefMDIChildProcA(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
DefMDIChildProcW(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
#ifdef UNICODE
#define DefMDIChildProc  DefMDIChildProcW
#else
#define DefMDIChildProc  DefMDIChildProcA
#endif // !UNICODE

#ifndef NOMSG

WINUSERAPI
BOOL
WINAPI
TranslateMDISysAccel(
    HWND hWndClient,
    LPMSG lpMsg);

#endif /* !NOMSG */

WINUSERAPI
UINT
WINAPI
ArrangeIconicWindows(
    HWND hWnd);

WINUSERAPI
HWND
WINAPI
CreateMDIWindowA(
    LPSTR lpClassName,
    LPSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam
    );
WINUSERAPI
HWND
WINAPI
CreateMDIWindowW(
    LPWSTR lpClassName,
    LPWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam
    );
#ifdef UNICODE
#define CreateMDIWindow  CreateMDIWindowW
#else
#define CreateMDIWindow  CreateMDIWindowA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI WORD    WINAPI TileWindows(HWND hwndParent, UINT wHow, CONST RECT * lpRect, UINT cKids, const HWND FAR * lpKids);
WINUSERAPI WORD    WINAPI CascadeWindows(HWND hwndParent, UINT wHow, CONST RECT * lpRect, UINT cKids,  const HWND FAR * lpKids);
#endif /* WINVER >= 0x0400 */
#endif /* !NOMDI */

#if(WINVER >= 0x0400)
#ifndef NOIME

/*
 *  IME class support
 */

// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW      0x0001
#define IMN_OPENSTATUSWINDOW       0x0002
#define IMN_CHANGECANDIDATE        0x0003
#define IMN_CLOSECANDIDATE         0x0004
#define IMN_OPENCANDIDATE          0x0005
#define IMN_SETCONVERSIONMODE      0x0006
#define IMN_SETSENTENCEMODE        0x0007
#define IMN_SETOPENSTATUS          0x0008
#define IMN_SETCANDIDATEPOS        0x0009
#define IMN_SETCOMPOSITIONFONT     0x000A
#define IMN_SETCOMPOSITIONWINDOW   0x000B
#define IMN_SETSTATUSWINDOWPOS     0x000C
#define IMN_GUIDELINE              0x000D
#define IMN_PRIVATE                0x000E

#endif /* !NOIME */
#endif /* WINVER >= 0x0400 */
#endif /* !NOUSER */

/****** Help support ********************************************************/

#ifndef NOHELP

typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
    DWORD  mkSize;
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
    DWORD  mkSize;
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;
#ifdef UNICODE
typedef MULTIKEYHELPW MULTIKEYHELP;
typedef PMULTIKEYHELPW PMULTIKEYHELP;
typedef LPMULTIKEYHELPW LPMULTIKEYHELP;
#else
typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
#endif // UNICODE

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;
#ifdef UNICODE
typedef HELPWININFOW HELPWININFO;
typedef PHELPWININFOW PHELPWININFO;
typedef LPHELPWININFOW LPHELPWININFO;
#else
typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
#endif // UNICODE

/*
 * Commands to pass to WinHelp()
 */
#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_QUIT         0x0002L  /* Terminate help */
#define HELP_INDEX        0x0003L  /* Display index */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_SETINDEX     0x0005L  /* Set current Index for multi index help */
#define HELP_SETCONTENTS  0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE    0x0009L
#define HELP_KEY          0x0101L  /* Display topic for keyword in offabData */
#define HELP_COMMAND      0x0102L
#define HELP_PARTIALKEY   0x0105L
#define HELP_MULTIKEY     0x0201L
#define HELP_SETWINPOS    0x0203L
#if(WINVER >= 0x0400)
#define HELP_CONTEXTMENU  0x000a
#define HELP_FINDER       0x000b
#define HELP_WM_HELP      0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD              0x8000
#define HELP_TCARD_DATA         0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

// These are in winhelp.h in Win95.
#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445

#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
WinHelpA(
    HWND hWndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );
WINUSERAPI
BOOL
WINAPI
WinHelpW(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );
#ifdef UNICODE
#define WinHelp  WinHelpW
#else
#define WinHelp  WinHelpA
#endif // !UNICODE

#endif /* !NOHELP */

#ifndef NOSYSPARAMSINFO

/*
 * Parameter for SystemParametersInfo()
 */

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_GETKEYBOARDSPEED       10
#define SPI_SETKEYBOARDSPEED       11
#define SPI_LANGDRIVER             12
#define SPI_ICONHORIZONTALSPACING  13
#define SPI_GETSCREENSAVETIMEOUT   14
#define SPI_SETSCREENSAVETIMEOUT   15
#define SPI_GETSCREENSAVEACTIVE    16
#define SPI_SETSCREENSAVEACTIVE    17
#define SPI_GETGRIDGRANULARITY     18
#define SPI_SETGRIDGRANULARITY     19
#define SPI_SETDESKWALLPAPER       20
#define SPI_SETDESKPATTERN         21
#define SPI_GETKEYBOARDDELAY       22
#define SPI_SETKEYBOARDDELAY       23
#define SPI_ICONVERTICALSPACING    24
#define SPI_GETICONTITLEWRAP       25
#define SPI_SETICONTITLEWRAP       26
#define SPI_GETMENUDROPALIGNMENT   27
#define SPI_SETMENUDROPALIGNMENT   28
#define SPI_SETDOUBLECLKWIDTH      29
#define SPI_SETDOUBLECLKHEIGHT     30
#define SPI_GETICONTITLELOGFONT    31
#define SPI_SETDOUBLECLICKTIME     32
#define SPI_SETMOUSEBUTTONSWAP     33
#define SPI_SETICONTITLELOGFONT    34
#define SPI_GETFASTTASKSWITCH      35
#define SPI_SETFASTTASKSWITCH      36
#if(WINVER >= 0x0400)
#define SPI_SETDRAGFULLWINDOWS     37
#define SPI_GETDRAGFULLWINDOWS     38
#define SPI_GETNONCLIENTMETRICS    41
#define SPI_SETNONCLIENTMETRICS    42
#define SPI_GETMINIMIZEDMETRICS    43
#define SPI_SETMINIMIZEDMETRICS    44
#define SPI_GETICONMETRICS         45
#define SPI_SETICONMETRICS         46
#define SPI_SETWORKAREA            47
#define SPI_GETWORKAREA            48
#define SPI_SETPENWINDOWS          49

#define SPI_GETHIGHCONTRAST        66
#define SPI_SETHIGHCONTRAST        67
#define SPI_GETKEYBOARDPREF        68
#define SPI_SETKEYBOARDPREF        69
#define SPI_GETSCREENREADER        70
#define SPI_SETSCREENREADER        71
#define SPI_GETANIMATION           72
#define SPI_SETANIMATION           73
#define SPI_GETFONTSMOOTHING       74
#define SPI_SETFONTSMOOTHING       75
#define SPI_SETDRAGWIDTH           76
#define SPI_SETDRAGHEIGHT          77
#define SPI_SETHANDHELD            78
#define SPI_GETLOWPOWERTIMEOUT     79
#define SPI_GETPOWEROFFTIMEOUT     80
#define SPI_SETLOWPOWERTIMEOUT     81
#define SPI_SETPOWEROFFTIMEOUT     82
#define SPI_GETLOWPOWERACTIVE      83
#define SPI_GETPOWEROFFACTIVE      84
#define SPI_SETLOWPOWERACTIVE      85
#define SPI_SETPOWEROFFACTIVE      86
#define SPI_SETCURSORS             87
#define SPI_SETICONS               88
#define SPI_GETDEFAULTINPUTLANG    89
#define SPI_SETDEFAULTINPUTLANG    90
#define SPI_SETLANGTOGGLE          91
#define SPI_GETWINDOWSEXTENSION    92
#define SPI_SETMOUSETRAILS         93
#define SPI_GETMOUSETRAILS         94
#define SPI_SCREENSAVERRUNNING     97
#endif /* WINVER >= 0x0400 */
#define SPI_GETFILTERKEYS          50
#define SPI_SETFILTERKEYS          51
#define SPI_GETTOGGLEKEYS          52
#define SPI_SETTOGGLEKEYS          53
#define SPI_GETMOUSEKEYS           54
#define SPI_SETMOUSEKEYS           55
#define SPI_GETSHOWSOUNDS          56
#define SPI_SETSHOWSOUNDS          57
#define SPI_GETSTICKYKEYS          58
#define SPI_SETSTICKYKEYS          59
#define SPI_GETACCESSTIMEOUT       60
#define SPI_SETACCESSTIMEOUT       61
#if(WINVER >= 0x0400)
#define SPI_GETSERIALKEYS          62
#define SPI_SETSERIALKEYS          63
#endif /* WINVER >= 0x0400 */
#define SPI_GETSOUNDSENTRY         64
#define SPI_SETSOUNDSENTRY         65

/*
 * Flags
 */
#define SPIF_UPDATEINIFILE    0x0001
#define SPIF_SENDWININICHANGE 0x0002
#define SPIF_SENDCHANGE       SPIF_SENDWININICHANGE

#if(WINVER >= 0x0400)
#define METRICS_USEDEFAULT -1
#ifdef _WINGDI_
#ifndef NOGDI
typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, FAR* LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, FAR* LPNONCLIENTMETRICSW;
#ifdef UNICODE
typedef NONCLIENTMETRICSW NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSW PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSW LPNONCLIENTMETRICS;
#else
typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
#endif // UNICODE
#endif /* NOGDI */
#endif /* _WINGDI_ */

#define ARW_BOTTOMLEFT              0x0000L
#define ARW_BOTTOMRIGHT             0x0001L
#define ARW_TOPLEFT                 0x0002L
#define ARW_TOPRIGHT                0x0003L
#define ARW_STARTMASK               0x0003L
#define ARW_STARTRIGHT              0x0001L
#define ARW_STARTTOP                0x0002L

#define ARW_LEFT                    0x0000L
#define ARW_RIGHT                   0x0000L
#define ARW_UP                      0x0004L
#define ARW_DOWN                    0x0004L
#define ARW_HIDE                    0x0008L
#define ARW_VALID                   0x000FL

typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;

typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;
#ifdef UNICODE
typedef ICONMETRICSW ICONMETRICS;
typedef PICONMETRICSW PICONMETRICS;
typedef LPICONMETRICSW LPICONMETRICS;
#else
typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
#endif // UNICODE

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;
#ifdef UNICODE
typedef SERIALKEYSW SERIALKEYS;
typedef LPSERIALKEYSW LPSERIALKEYS;
#else
typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
#endif // UNICODE

/* flags for SERIALKEYS dwFlags field */
#define SERKF_SERIALKEYSON  0x00000001
#define SERKF_AVAILABLE     0x00000002
#define SERKF_INDICATOR     0x00000004

typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;
#ifdef UNICODE
typedef HIGHCONTRASTW HIGHCONTRAST;
typedef LPHIGHCONTRASTW LPHIGHCONTRAST;
#else
typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
#endif // UNICODE

/* flags for HIGHCONTRAST dwFlags field */
#define HCF_HIGHCONTRASTON  0x00000001
#define HCF_AVAILABLE       0x00000002
#define HCF_HOTKEYACTIVE    0x00000004
#define HCF_CONFIRMHOTKEY   0x00000008
#define HCF_HOTKEYSOUND     0x00000010
#define HCF_INDICATOR       0x00000020
#define HCF_HOTKEYAVAILABLE 0x00000040

/* Flags for ChangeDisplaySettings */
#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004

/* Return values */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4

WINUSERAPI
LONG
WINAPI
ChangeDisplaySettingsA(
    LPDEVMODEA lpDevMode,
    DWORD dwFlags);
WINUSERAPI
LONG
WINAPI
ChangeDisplaySettingsW(
    LPDEVMODEW lpDevMode,
    DWORD dwFlags);
#ifdef UNICODE
#define ChangeDisplaySettings  ChangeDisplaySettingsW
#else
#define ChangeDisplaySettings  ChangeDisplaySettingsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    LPDEVMODEA lpDevMode);
WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    LPDEVMODEW lpDevMode);
#ifdef UNICODE
#define EnumDisplaySettings  EnumDisplaySettingsW
#else
#define EnumDisplaySettings  EnumDisplaySettingsA
#endif // !UNICODE

#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
SystemParametersInfoA(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);
WINUSERAPI
BOOL
WINAPI
SystemParametersInfoW(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);
#ifdef UNICODE
#define SystemParametersInfo  SystemParametersInfoW
#else
#define SystemParametersInfo  SystemParametersInfoA
#endif // !UNICODE

#endif  /* !NOSYSPARAMSINFO  */

/*
 * Accessibility support
 */
typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            // Acceptance Delay
    DWORD iDelayMSec;           // Delay Until Repeat
    DWORD iRepeatMSec;          // Repeat Rate
    DWORD iBounceMSec;          // Debounce Time
} FILTERKEYS, *LPFILTERKEYS;

/*
 * FILTERKEYS dwFlags field
 */
#define FKF_FILTERKEYSON    0x00000001
#define FKF_AVAILABLE       0x00000002
#define FKF_HOTKEYACTIVE    0x00000004
#define FKF_CONFIRMHOTKEY   0x00000008
#define FKF_HOTKEYSOUND     0x00000010
#define FKF_INDICATOR       0x00000020
#define FKF_CLICKON         0x00000040

typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

/*
 * STICKYKEYS dwFlags field
 */
#define SKF_STICKYKEYSON    0x00000001
#define SKF_AVAILABLE       0x00000002
#define SKF_HOTKEYACTIVE    0x00000004
#define SKF_CONFIRMHOTKEY   0x00000008
#define SKF_HOTKEYSOUND     0x00000010
#define SKF_INDICATOR       0x00000020
#define SKF_AUDIBLEFEEDBACK 0x00000040
#define SKF_TRISTATE        0x00000080
#define SKF_TWOKEYSOFF      0x00000100

typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

/*
 * MOUSEKEYS dwFlags field
 */
#define MKF_MOUSEKEYSON     0x00000001
#define MKF_AVAILABLE       0x00000002
#define MKF_HOTKEYACTIVE    0x00000004
#define MKF_CONFIRMHOTKEY   0x00000008
#define MKF_HOTKEYSOUND     0x00000010
#define MKF_INDICATOR       0x00000020
#define MKF_MODIFIERS       0x00000040
#define MKF_REPLACENUMBERS  0x00000080

typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

/*
 * ACCESSTIMEOUT dwFlags field
 */
#define ATF_TIMEOUTON       0x00000001
#define ATF_ONOFFFEEDBACK   0x00000002

/* values for SOUNDSENTRY iFSGrafEffect field */
#define SSGF_NONE       0
#define SSGF_DISPLAY    3

/* values for SOUNDSENTRY iFSTextEffect field */
#define SSTF_NONE       0
#define SSTF_CHARS      1
#define SSTF_BORDER     2
#define SSTF_DISPLAY    3

/* values for SOUNDSENTRY iWindowsEffect field */
#define SSWF_NONE     0
#define SSWF_TITLE    1
#define SSWF_WINDOW   2
#define SSWF_DISPLAY  3
#define SSWF_CUSTOM   4

typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;
#ifdef UNICODE
typedef SOUNDSENTRYW SOUNDSENTRY;
typedef LPSOUNDSENTRYW LPSOUNDSENTRY;
#else
typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
#endif // UNICODE

/*
 * SOUNDSENTRY dwFlags field
 */
#define SSF_SOUNDSENTRYON   0x00000001
#define SSF_AVAILABLE       0x00000002
#define SSF_INDICATOR       0x00000004

typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

/*
 * TOGGLEKEYS dwFlags field
 */
#define TKF_TOGGLEKEYSON    0x00000001
#define TKF_AVAILABLE       0x00000002
#define TKF_HOTKEYACTIVE    0x00000004
#define TKF_CONFIRMHOTKEY   0x00000008
#define TKF_HOTKEYSOUND     0x00000010
#define TKF_INDICATOR       0x00000020

/*
 * Set debug level
 */

WINUSERAPI
VOID
WINAPI
SetDebugErrorLevel(
    DWORD dwLevel
    );

/*
 * SetLastErrorEx() types.
 */

#define SLE_ERROR       0x00000001
#define SLE_MINORERROR  0x00000002
#define SLE_WARNING     0x00000003

WINUSERAPI
VOID
WINAPI
SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* !_WINUSER_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\NVSYS.H ===
#ifndef _NVSYS_H_
#define _NVSYS_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVSYS.H                                                           *
*   Windows Resource Manager defines and prototypes.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    01/10/95 - wrote it.                    *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
#define DEFAULT_DEVICEHANDLE 0

//---------------------------------------------------------------------------
//
//  Typedefs.
//
//---------------------------------------------------------------------------

//
// Standard types not defined in windows.h
//
typedef          char      CHAR;
typedef          int       INT;
typedef          int       SHORT;
typedef          char     *PCHAR;
typedef          int      *PSHORT;
typedef          void     *PVOID;
typedef          char far *LPCHAR;
typedef          int  far *LPSHORT;
typedef unsigned char      UCHAR;
typedef unsigned int       USHORT;
typedef unsigned long      ULONG;
typedef unsigned char     *PUCHAR;
typedef unsigned int      *PUSHORT;
typedef unsigned long     *PULONG;
typedef unsigned char far *LPUCHAR;
typedef unsigned int  far *LPUSHORT;
typedef unsigned long far *LPULONG;
typedef struct _def_lrect
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} LRECT;
typedef LRECT      * PLRECT;
typedef LRECT FAR  * LPLRECT;
//
// Callback type.
//
typedef VOID (FAR PASCAL * NVSYSCALLBACK)(DWORD, DWORD, WORD, DWORD, WORD);

//---------------------------------------------------------------------------
//
//  Typedefs.
//
//---------------------------------------------------------------------------

typedef struct _def_hw_info      FAR * LPHWINFO;
typedef struct _def_channel_info FAR * LPCHANNELINFO;
typedef struct _def_client_info  FAR * LPCLIENTINFO;
typedef struct _def_rmParams     FAR * LPRMPARAMS;

typedef CANVASREGION FAR * LPCANVASREGION;

//---------------------------------------------------------------------------
//
//  Prototypes.
//
//---------------------------------------------------------------------------

//
// System client entrypoints.
//
LPVOID FAR PASCAL NvSysOpen(U032);
LPVOID FAR PASCAL NvSysOpenDma(DWORD, DWORD, DWORD);
BOOL   FAR PASCAL NvSysClose(LPVOID, U032);
BOOL   FAR PASCAL NvSysInstallCallback(LPVOID, NVSYSCALLBACK);
//
// Internal helper routines.  Subject to change at my whim.
// Use configuration API instead.
//
BOOL  FAR PASCAL NvSysAllocPages(LPVOID FAR *, LPDWORD, DWORD, U032);
BOOL  FAR PASCAL NvSysFreePages(DWORD, U032);
BOOL  FAR PASCAL NvSysLockPages(WORD, DWORD, DWORD, U032);
BOOL  FAR PASCAL NvSysUnlockPages(WORD, DWORD, DWORD, U032);
VOID  FAR PASCAL NvSysMoveCursor(INT, INT, U032);
VOID  FAR PASCAL NvSysMoveCursorMulti(INT, INT, U032, U032);
BOOL  FAR PASCAL NvSysSetCursor(LPBYTE, INT, INT, U032);
DWORD FAR PASCAL NvSysSetColorCursor(LPBYTE, LPBYTE, INT, INT, U032);
DWORD FAR PASCAL NvSysSetColorCursor555(LPBYTE, LPBYTE, INT, INT);
VOID  FAR PASCAL NvSysSetCursorColor(DWORD, DWORD);
VOID  FAR PASCAL NvSysShowHideCursor(INT, U032);
VOID  FAR PASCAL NvSysDmaPushOperation(DWORD, LPVOID);
DWORD FAR PASCAL NvSysGetVBlankStatus(VOID);
DWORD FAR PASCAL NvSysGetGEStatus(VOID);
DWORD FAR PASCAL NvSysGetScreenInfo(U032);
DWORD FAR PASCAL NvSysGetRamInfo(U032);
DWORD FAR PASCAL NvSysGetBufferInfo(U032);
VOID  FAR PASCAL NvSysClearScreen(U032);
VOID  FAR PASCAL NvSysGetHardwarePointers(DWORD FAR *, DWORD FAR *, DWORD FAR *, DWORD FAR *, U032);
DWORD FAR PASCAL NvSysGetCurrentBufferFlatPointer(U032);
VOID  FAR PASCAL NvSysDisplayModeHook(DWORD, U032);
//
// Internal Resource Manager entrypoints.
//
BOOL  FAR PASCAL NvSysClientExit(INT);
BOOL  FAR PASCAL NvSysConnect(HINSTANCE, LPVOID FAR *, LPVOID FAR *, LPVOID FAR *, U032);
BOOL  FAR PASCAL NvSysDisconnect(HINSTANCE);
BOOL  FAR PASCAL NvSysSetCanvas(HWND);
BOOL  FAR PASCAL NvSysSetCanvasRect(LPLRECT);
BOOL  FAR PASCAL NvSysSetCanvasClip(LPLRECT, WORD, LPLRECT);
BOOL  FAR PASCAL NvSysSetCanvasRegion(HWND, LPLRECT, WORD, LPLRECT);
#endif // _NVSYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\nv_ref.inc ===
;option expr32
;option casemap:none

; Begin of file nv_ref.h
;  @(#) $Header: /resman.040/win96/vdd/nv_ref.inc 1     5/13/97 10:43a Jeffwe $
;  NVidia Corporation 
;  basis: nv1 manuals 10.1
;  95/06/27 NVidia Corporation 
;     1 : 
;     2 : /* @(#) $Header: /resman.040/win96/vdd/nv_ref.inc 1     5/13/97 10:43a Jeffwe $
;     3 :  NVidia Corporation */
;     4 : /* basis: nv1 manuals 10.1
;     5 :  95/06/27 NVidia Corporation */
;     6 : 
;     7 : #ifndef _NV_REF_H_
;     8 : #define _NV_REF_H_
_NV_REF_H_              TEXTEQU         <>
;  dev_bus.ref 
;  RW--D 
;     9 : 
;    10 : /* dev_bus.ref */
;    11 : #define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
NV_SPACE                TEXTEQU         <0x01FFFFFF:0x00000000>
;  dev_bus.ref 
;  RW--D 
;    12 : /* dev_bus.ref */
;    13 : #define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
NV_CONFIG               TEXTEQU         <0x000000FF:0x00000000>
;  R--4R 
;    14 : #define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
NV_CONFIG_PCI_NV_0              EQU             000000000h
;        
;    15 : #define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
NV_CONFIG_PCI_NV_0__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_0>
;  C--UF 
;    16 : #define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* C--UF */
NV_CONFIG_PCI_NV_0_VENDOR_ID            TEXTEQU         <15:0>
;  C---V 
;    17 : #define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS          0x000012D2 /* C---V */
NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS         EQU             0000012d2h
;  C--UF 
;    18 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC               TEXTEQU         <18:16>
;  C---V 
;    19 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* C---V */
NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA           EQU             000000000h
;  C--UF 
;    20 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP               TEXTEQU         <31:19>
;  ----V 
;    21 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0           EQU             000000000h
;  ----V 
;    22 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* ----V */
NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1           EQU             000000001h
;  ----V 
;    23 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2           EQU             000000002h
;  C---V 
;    24 : #define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3            0x00000003 /* C---V */
NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3           EQU             000000003h
;  RW-4R 
;    25 : #define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
NV_CONFIG_PCI_NV_1              EQU             000000004h
;        
;    26 : #define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
NV_CONFIG_PCI_NV_1__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_1>
;  RWIVF 
;    27 : #define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
NV_CONFIG_PCI_NV_1_IO_SPACE             TEXTEQU         <0:0>
;  RWI-V 
;    28 : #define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED            EQU             000000000h
;  RW--V 
;    29 : #define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED             EQU             000000001h
;  RWIVF 
;    30 : #define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
NV_CONFIG_PCI_NV_1_MEMORY_SPACE         TEXTEQU         <1:1>
;  RWI-V 
;    31 : #define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED                EQU             000000000h
;  RW--V 
;    32 : #define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED         EQU             000000001h
;  RWIVF 
;    33 : #define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
NV_CONFIG_PCI_NV_1_BUS_MASTER           TEXTEQU         <2:2>
;  RWI-V 
;    34 : #define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED          EQU             000000000h
;  RW--V 
;    35 : #define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED           EQU             000000001h
;  C--VF 
;    36 : #define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* C--VF */
NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL              TEXTEQU         <4:4>
;  C---V 
;    37 : #define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* C---V */
NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED             EQU             000000000h
;  ----V 
;    38 : #define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* ----V */
NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED              EQU             000000001h
;  RWIVF 
;    39 : #define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                        5:5 /* RWIVF */
NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                TEXTEQU         <5:5>
;  RWI-V 
;    40 : #define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED        0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED               EQU             000000000h
;  RW--V 
;    41 : #define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED         0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED                EQU             000000001h
;  R--VF 
;    42 : #define NV_CONFIG_PCI_NV_1_CAPLIST                            20:20 /* R--VF */
NV_CONFIG_PCI_NV_1_CAPLIST              TEXTEQU         <20:20>
;  ----V 
;    43 : #define NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT           0x00000000 /* ----V */
NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT          EQU             000000000h
;  ----V 
;    44 : #define NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT               0x00000001 /* ----V */
NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT              EQU             000000001h
;  C--VF 
;    45 : #define NV_CONFIG_PCI_NV_1_66MHZ                              21:21 /* C--VF */
NV_CONFIG_PCI_NV_1_66MHZ                TEXTEQU         <21:21>
;  ----V 
;    46 : #define NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE               0x00000000 /* ----V */
NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE              EQU             000000000h
;  ----V 
;    47 : #define NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                 0x00000001 /* ----V */
NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                EQU             000000001h
;  C--VF 
;    48 : #define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
NV_CONFIG_PCI_NV_1_FAST_BACK2BACK               TEXTEQU         <23:23>
;  ----V 
;    49 : #define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE             EQU             000000000h
;  C---V 
;    50 : #define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE               EQU             000000001h
;  C--VF 
;    51 : #define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                TEXTEQU         <26:25>
;  ----V 
;    52 : #define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* ----V */
NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST           EQU             000000000h
;  C---V 
;    53 : #define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* C---V */
NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM         EQU             000000001h
;  ----V 
;    54 : #define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW           EQU             000000002h
;  RWIVF 
;    55 : #define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET                    27:27 /* RWIVF */
NV_CONFIG_PCI_NV_1_SIGNALED_TARGET              TEXTEQU         <27:27>
;  R-I-V 
;    56 : #define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT             EQU             000000000h
;  R---V 
;    57 : #define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT         0x00000001 /* R---V */
NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT                EQU             000000001h
;  -W--V 
;    58 : #define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR         0x00000001 /* -W--V */
NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR                EQU             000000001h
;  RWIVF 
;    59 : #define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
NV_CONFIG_PCI_NV_1_RECEIVED_TARGET              TEXTEQU         <28:28>
;  R-I-V 
;    60 : #define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT             EQU             000000000h
;  R---V 
;    61 : #define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT                EQU             000000001h
;  -W--V 
;    62 : #define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR                EQU             000000001h
;  RWIVF 
;    63 : #define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
NV_CONFIG_PCI_NV_1_RECEIVED_MASTER              TEXTEQU         <29:29>
;  R-I-V 
;    64 : #define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT             EQU             000000000h
;  R---V 
;    65 : #define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT                EQU             000000001h
;  -W--V 
;    66 : #define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR                EQU             000000001h
;  R--4R 
;    67 : #define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
NV_CONFIG_PCI_NV_2              EQU             000000008h
;        
;    68 : #define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
NV_CONFIG_PCI_NV_2__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_2>
;  C--UF 
;    69 : #define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
NV_CONFIG_PCI_NV_2_REVISION_ID          TEXTEQU         <7:0>
;  C---V 
;    70 : #define NV_CONFIG_PCI_NV_2_REVISION_ID_A                 0x00000000 /* C---V */
NV_CONFIG_PCI_NV_2_REVISION_ID_A                EQU             000000000h
;  ----V 
;    71 : #define NV_CONFIG_PCI_NV_2_REVISION_ID_B                 0x00000001 /* ----V */
NV_CONFIG_PCI_NV_2_REVISION_ID_B                EQU             000000001h
;  C--VF 
;    72 : #define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
NV_CONFIG_PCI_NV_2_CLASS_CODE           TEXTEQU         <31:8>
;  C---V 
;    73 : #define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* C---V */
NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA               EQU             000030000h
;  ----V 
;    74 : #define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* ----V */
NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA                EQU             000048000h
;  RW-4R 
;    75 : #define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
NV_CONFIG_PCI_NV_3              EQU             00000000ch
;        
;    76 : #define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
NV_CONFIG_PCI_NV_3__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_3>
;  RWIUF 
;    77 : #define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
NV_CONFIG_PCI_NV_3_LATENCY_TIMER                TEXTEQU         <15:11>
;  RWI-V 
;    78 : #define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS               EQU             000000000h
;  RW--V 
;    79 : #define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS               EQU             000000001h
;  RW--V 
;    80 : #define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS             EQU             00000001eh
;  RW--V 
;    81 : #define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS             EQU             00000001fh
;  C--VF 
;    82 : #define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
NV_CONFIG_PCI_NV_3_HEADER_TYPE          TEXTEQU         <23:16>
;  C---V 
;    83 : #define NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC        0x00000000 /* C---V */
NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC               EQU             000000000h
;  ----V 
;    84 : #define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* ----V */
NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC                EQU             000000080h
;  RW-4R 
;    85 : #define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
NV_CONFIG_PCI_NV_4              EQU             000000010h
;        
;    86 : #define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
NV_CONFIG_PCI_NV_4__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_4>
;  C--VF 
;    87 : #define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
NV_CONFIG_PCI_NV_4_SPACE_TYPE           TEXTEQU         <0:0>
;  C---V 
;    88 : #define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY            EQU             000000000h
;  ----V 
;    89 : #define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                EQU             000000001h
;  C--VF 
;    90 : #define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
NV_CONFIG_PCI_NV_4_ADDRESS_TYPE         TEXTEQU         <2:1>
;  C---V 
;    91 : #define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT          EQU             000000000h
;  ----V 
;    92 : #define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT          EQU             000000001h
;  ----V 
;    93 : #define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT          EQU             000000002h
;  C--VF 
;    94 : #define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
NV_CONFIG_PCI_NV_4_PREFETCHABLE         TEXTEQU         <3:3>
;  C---V 
;    95 : #define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* C---V */
NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT             EQU             000000000h
;  ----V 
;    96 : #define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* ----V */
NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE                EQU             000000001h
;  RWXUF 
;    97 : #define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:24 /* RWXUF */
NV_CONFIG_PCI_NV_4_BASE_ADDRESS         TEXTEQU         <31:24>
;  RW-4R 
;    98 : #define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
NV_CONFIG_PCI_NV_5              EQU             000000014h
;        
;    99 : #define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
NV_CONFIG_PCI_NV_5__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_5>
;  C--VF 
;   100 : #define NV_CONFIG_PCI_NV_5_SPACE_TYPE                           0:0 /* C--VF */
NV_CONFIG_PCI_NV_5_SPACE_TYPE           TEXTEQU         <0:0>
;  C---V 
;   101 : #define NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY            EQU             000000000h
;  ----V 
;   102 : #define NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                 0x00000001 /* ----V */
NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                EQU             000000001h
;  C--VF 
;   103 : #define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE                         2:1 /* C--VF */
NV_CONFIG_PCI_NV_5_ADDRESS_TYPE         TEXTEQU         <2:1>
;  C---V 
;   104 : #define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT          EQU             000000000h
;  ----V 
;   105 : #define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT          EQU             000000001h
;  ----V 
;   106 : #define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT          EQU             000000002h
;  C--VF 
;   107 : #define NV_CONFIG_PCI_NV_5_PREFETCHABLE                         3:3 /* C--VF */
NV_CONFIG_PCI_NV_5_PREFETCHABLE         TEXTEQU         <3:3>
;  ----V 
;   108 : #define NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT              0x00000000 /* ----V */
NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT             EQU             000000000h
;  C---V 
;   109 : #define NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE                EQU             000000001h
;  RWXUF 
;   110 : #define NV_CONFIG_PCI_NV_5_BASE_ADDRESS                       31:24 /* RWXUF */
NV_CONFIG_PCI_NV_5_BASE_ADDRESS         TEXTEQU         <31:24>
;  RW-4R 
;   111 : #define NV_CONFIG_PCI_NV_6                               0x00000018 /* RW-4R */
NV_CONFIG_PCI_NV_6              EQU             000000018h
;        
;   112 : #define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
NV_CONFIG_PCI_NV_6__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_6>
;  C--VF 
;   113 : #define NV_CONFIG_PCI_NV_6_SPACE_TYPE                           0:0 /* C--VF */
NV_CONFIG_PCI_NV_6_SPACE_TYPE           TEXTEQU         <0:0>
;  ----V 
;   114 : #define NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY             0x00000000 /* ----V */
NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY            EQU             000000000h
;  C---V 
;   115 : #define NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                 0x00000001 /* C---V */
NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                EQU             000000001h
;  RWXUF 
;   116 : #define NV_CONFIG_PCI_NV_6_BASE_ADDRESS                        31:8 /* RWXUF */
NV_CONFIG_PCI_NV_6_BASE_ADDRESS         TEXTEQU         <31:8>
;  R--4A 
;        
;   117 : #define NV_CONFIG_PCI_NV_7(i)                    (0x0000001C+(i)*4) /* R--4A */
;   118 : #define NV_CONFIG_PCI_NV_7__SIZE_1                                4 /*       */
NV_CONFIG_PCI_NV_7__SIZE_1              EQU             4t
;        
;   119 : #define NV_CONFIG_PCI_NV_7__ALIAS_1                NV_PBUS_PCI_NV_7 /*       */
NV_CONFIG_PCI_NV_7__ALIAS_1             TEXTEQU         <NV_PBUS_PCI_NV_7>
;  C--VF 
;   120 : #define NV_CONFIG_PCI_NV_7_RESERVED                            31:0 /* C--VF */
NV_CONFIG_PCI_NV_7_RESERVED             TEXTEQU         <31:0>
;  C---V 
;   121 : #define NV_CONFIG_PCI_NV_7_RESERVED_0                    0x00000000 /* C---V */
NV_CONFIG_PCI_NV_7_RESERVED_0           EQU             000000000h
;  R--4R 
;   122 : #define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
NV_CONFIG_PCI_NV_11             EQU             00000002ch
;        
;   123 : #define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
NV_CONFIG_PCI_NV_11__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_11>
;  R--UF 
;   124 : #define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID               31:16 /* R--UF */
NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID         TEXTEQU         <31:16>
;  R---V 
;   125 : #define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE            EQU             000000000h
;  R--UF 
;   126 : #define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                       15:0 /* R--UF */
NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                TEXTEQU         <15:0>
;  R---V 
;   127 : #define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE           EQU             000000000h
;  RW-4R 
;   128 : #define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
NV_CONFIG_PCI_NV_12             EQU             000000030h
;        
;   129 : #define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
NV_CONFIG_PCI_NV_12__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_12>
;  RWIVF 
;   130 : #define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
NV_CONFIG_PCI_NV_12_ROM_DECODE          TEXTEQU         <0:0>
;  RWI-V 
;   131 : #define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED         EQU             000000000h
;  RW--V 
;   132 : #define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED          EQU             000000001h
;  RWXUF 
;   133 : #define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
NV_CONFIG_PCI_NV_12_ROM_BASE            TEXTEQU         <31:22>
;  RW-4R 
;   134 : #define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
NV_CONFIG_PCI_NV_13             EQU             000000034h
;        
;   135 : #define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
NV_CONFIG_PCI_NV_13__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_13>
;  C--VF 
;   136 : #define NV_CONFIG_PCI_NV_13_CAP_PTR                             7:0 /* C--VF */
NV_CONFIG_PCI_NV_13_CAP_PTR             TEXTEQU         <7:0>
;  C---V 
;   137 : #define NV_CONFIG_PCI_NV_13_CAP_PTR_AGP                  0x00000044 /* C---V */
NV_CONFIG_PCI_NV_13_CAP_PTR_AGP         EQU             000000044h
;  R--4A 
;   138 : #define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
NV_CONFIG_PCI_NV_14             EQU             000000038h
;        
;   139 : #define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
NV_CONFIG_PCI_NV_14__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_14>
;  C--VF 
;   140 : #define NV_CONFIG_PCI_NV_14_RESERVED                           31:0 /* C--VF */
NV_CONFIG_PCI_NV_14_RESERVED            TEXTEQU         <31:0>
;  C---V 
;   141 : #define NV_CONFIG_PCI_NV_14_RESERVED_0                   0x00000000 /* C---V */
NV_CONFIG_PCI_NV_14_RESERVED_0          EQU             000000000h
;  RW-4R 
;   142 : #define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
NV_CONFIG_PCI_NV_15             EQU             00000003ch
;        
;   143 : #define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
NV_CONFIG_PCI_NV_15__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_15>
;  RWIVF 
;   144 : #define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
NV_CONFIG_PCI_NV_15_INTR_LINE           TEXTEQU         <7:0>
;  RWI-V 
;   145 : #define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0              EQU             000000000h
;  RW--V 
;   146 : #define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1              EQU             000000001h
;  RW--V 
;   147 : #define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15             EQU             00000000fh
;  RW--V 
;   148 : #define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN           EQU             0000000ffh
;  C--VF 
;   149 : #define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
NV_CONFIG_PCI_NV_15_INTR_PIN            TEXTEQU         <15:8>
;  C---V 
;   150 : #define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
NV_CONFIG_PCI_NV_15_INTR_PIN_INTA               EQU             000000001h
;  C--VF 
;   151 : #define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
NV_CONFIG_PCI_NV_15_MIN_GNT             TEXTEQU         <23:16>
;  ----V 
;   152 : #define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS             EQU             000000000h
;  C---V 
;   153 : #define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
NV_CONFIG_PCI_NV_15_MIN_GNT_750NS               EQU             000000003h
;  C--VF 
;   154 : #define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
NV_CONFIG_PCI_NV_15_MAX_LAT             TEXTEQU         <31:24>
;  ----V 
;   155 : #define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS             EQU             000000000h
;  C---V 
;   156 : #define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
NV_CONFIG_PCI_NV_15_MAX_LAT_250NS               EQU             000000001h
;  RW-4R 
;   157 : #define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
NV_CONFIG_PCI_NV_16             EQU             000000040h
;        
;   158 : #define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
NV_CONFIG_PCI_NV_16__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_16>
;  RW-VF 
;   159 : #define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID               31:16 /* RW-VF */
NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID         TEXTEQU         <31:16>
;  R---V 
;   160 : #define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE            EQU             000000000h
;  RW-VF 
;   161 : #define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                       15:0 /* RW-VF */
NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                TEXTEQU         <15:0>
;  R---V 
;   162 : #define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE           EQU             000000000h
;  RW-4R 
;   163 : #define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
NV_CONFIG_PCI_NV_17             EQU             000000044h
;        
;   164 : #define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
NV_CONFIG_PCI_NV_17__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_17>
;  C--VF 
;   165 : #define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR                     23:20 /* C--VF */
NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR               TEXTEQU         <23:20>
;  C---V 
;   166 : #define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1              0x00000001 /* C---V */
NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1             EQU             000000001h
;  C--VF 
;   167 : #define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR                     19:16 /* C--VF */
NV_CONFIG_PCI_NV_17_AGP_REV_MINOR               TEXTEQU         <19:16>
;  C---V 
;   168 : #define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0              0x00000000 /* C---V */
NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0             EQU             000000000h
;  C--VF 
;   169 : #define NV_CONFIG_PCI_NV_17_NEXT_PTR                           15:8 /* C--VF */
NV_CONFIG_PCI_NV_17_NEXT_PTR            TEXTEQU         <15:8>
;  C---V 
;   170 : #define NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL                0x00000000 /* C---V */
NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL               EQU             000000000h
;  C--VF 
;   171 : #define NV_CONFIG_PCI_NV_17_CAP_ID                              7:0 /* C--VF */
NV_CONFIG_PCI_NV_17_CAP_ID              TEXTEQU         <7:0>
;  C---V 
;   172 : #define NV_CONFIG_PCI_NV_17_CAP_ID_AGP                   0x00000002 /* C---V */
NV_CONFIG_PCI_NV_17_CAP_ID_AGP          EQU             000000002h
;  RW-4R 
;   173 : #define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
NV_CONFIG_PCI_NV_18             EQU             000000048h
;        
;   174 : #define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
NV_CONFIG_PCI_NV_18__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_18>
;  C--VF 
;   175 : #define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ                     31:24 /* C--VF */
NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ               TEXTEQU         <31:24>
;  C---V 
;   176 : #define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4              0x00000004 /* C---V */
NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4             EQU             000000004h
;  C--VF 
;   177 : #define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA                      9:9 /* C--VF */
NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA              TEXTEQU         <9:9>
;  C---V 
;   178 : #define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE          0x00000000 /* C---V */
NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE         EQU             000000000h
;  C--VF 
;   179 : #define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE                     1:0 /* C--VF */
NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE             TEXTEQU         <1:0>
;  C---V 
;   180 : #define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X           0x00000001 /* C---V */
NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X          EQU             000000001h
;  RW-4R 
;   181 : #define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
NV_CONFIG_PCI_NV_19             EQU             00000004ch
;        
;   182 : #define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
NV_CONFIG_PCI_NV_19__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_19>
;  RWIVF 
;   183 : #define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH              31:24 /* RWIVF */
NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH                TEXTEQU         <31:24>
;  RWI-V 
;   184 : #define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0       0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0              EQU             000000000h
;  RWIVF 
;   185 : #define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              8:8 /* RWIVF */
NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              TEXTEQU         <8:8>
;  RWI-V 
;   186 : #define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF   0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF          EQU             000000000h
;  RWIVF 
;   187 : #define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               1:0 /* RWIVF */
NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               TEXTEQU         <1:0>
;  RWI-V 
;   188 : #define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF    0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF           EQU             000000000h
;  RW-4R 
;   189 : #define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
NV_CONFIG_PCI_NV_20             EQU             000000050h
;        
;   190 : #define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
NV_CONFIG_PCI_NV_20__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_20>
;  RWIVF 
;   191 : #define NV_CONFIG_PCI_NV_20_SOUND_BLASTER                       0:0 /* RWIVF */
NV_CONFIG_PCI_NV_20_SOUND_BLASTER               TEXTEQU         <0:0>
;  RW--V 
;   192 : #define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED       0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED              EQU             000000000h
;  RWI-V 
;   193 : #define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED        0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED               EQU             000000001h
;  RWIVF 
;   194 : #define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                        1:1 /* RWIVF */
NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                TEXTEQU         <1:1>
;  RW--V 
;   195 : #define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED        0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED               EQU             000000000h
;  RWI-V 
;   196 : #define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED         0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED                EQU             000000001h
;  RWIVF 
;   197 : #define NV_CONFIG_PCI_NV_20_GAME_PORT                           2:2 /* RWIVF */
NV_CONFIG_PCI_NV_20_GAME_PORT           TEXTEQU         <2:2>
;  RW--V 
;   198 : #define NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED           0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED          EQU             000000000h
;  RWI-V 
;   199 : #define NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED            0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED           EQU             000000001h
;  RWIVF 
;   200 : #define NV_CONFIG_PCI_NV_20_MPU401_IO                           3:3 /* RWIVF */
NV_CONFIG_PCI_NV_20_MPU401_IO           TEXTEQU         <3:3>
;  RW--V 
;   201 : #define NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED           0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED          EQU             000000000h
;  RWI-V 
;   202 : #define NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED            0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED           EQU             000000001h
;  RWIVF 
;   203 : #define NV_CONFIG_PCI_NV_20_MPU401_IRQ                          4:4 /* RWIVF */
NV_CONFIG_PCI_NV_20_MPU401_IRQ          TEXTEQU         <4:4>
;  RW--V 
;   204 : #define NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED          0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED         EQU             000000000h
;  RWI-V 
;   205 : #define NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED           0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED          EQU             000000001h
;  RWIVF 
;   206 : #define NV_CONFIG_PCI_NV_20_IO_ALIASING                         5:5 /* RWIVF */
NV_CONFIG_PCI_NV_20_IO_ALIASING         TEXTEQU         <5:5>
;  RW--V 
;   207 : #define NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED         0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED                EQU             000000000h
;  RWI-V 
;   208 : #define NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED          0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED         EQU             000000001h
;  RWIVF 
;   209 : #define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                        7:7 /* RWIVF */
NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                TEXTEQU         <7:7>
;  RW--V 
;   210 : #define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED         0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED                EQU             000000000h
;  RWI-V 
;   211 : #define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED        0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED               EQU             000000001h
;  RWIVF 
;   212 : #define NV_CONFIG_PCI_NV_20_SB_BASE                             9:8 /* RWIVF */
NV_CONFIG_PCI_NV_20_SB_BASE             TEXTEQU         <9:8>
;  RWI-V 
;   213 : #define NV_CONFIG_PCI_NV_20_SB_BASE_220H                 0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_20_SB_BASE_220H                EQU             000000000h
;  RW--V 
;   214 : #define NV_CONFIG_PCI_NV_20_SB_BASE_240H                 0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_20_SB_BASE_240H                EQU             000000001h
;  RW--V 
;   215 : #define NV_CONFIG_PCI_NV_20_SB_BASE_260H                 0x00000002 /* RW--V */
NV_CONFIG_PCI_NV_20_SB_BASE_260H                EQU             000000002h
;  RWIVF 
;   216 : #define NV_CONFIG_PCI_NV_20_MPU_BASE                          13:12 /* RWIVF */
NV_CONFIG_PCI_NV_20_MPU_BASE            TEXTEQU         <13:12>
;  RWI-V 
;   217 : #define NV_CONFIG_PCI_NV_20_MPU_BASE_330H                0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_20_MPU_BASE_330H               EQU             000000000h
;  RW--V 
;   218 : #define NV_CONFIG_PCI_NV_20_MPU_BASE_230H                0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_20_MPU_BASE_230H               EQU             000000001h
;  RW--V 
;   219 : #define NV_CONFIG_PCI_NV_20_MPU_BASE_300H                0x00000002 /* RW--V */
NV_CONFIG_PCI_NV_20_MPU_BASE_300H               EQU             000000002h
;  RWIVF 
;   220 : #define NV_CONFIG_PCI_NV_20_DMA_SNOOP                         16:16 /* RWIVF */
NV_CONFIG_PCI_NV_20_DMA_SNOOP           TEXTEQU         <16:16>
;  RWI-V 
;   221 : #define NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED           0x00000000 /* RWI-V */
NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED          EQU             000000000h
;  RW--V 
;   222 : #define NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED            0x00000001 /* RW--V */
NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED           EQU             000000001h
;  RW-4R 
;   223 : #define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
NV_CONFIG_PCI_NV_21             EQU             000000054h
;        
;   224 : #define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
NV_CONFIG_PCI_NV_21__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_21>
;  RWIVF 
;   225 : #define NV_CONFIG_PCI_NV_21_VGA                                 0:0 /* RWIVF */
NV_CONFIG_PCI_NV_21_VGA         TEXTEQU         <0:0>
;  RW--V 
;   226 : #define NV_CONFIG_PCI_NV_21_VGA_DISABLED                 0x00000000 /* RW--V */
NV_CONFIG_PCI_NV_21_VGA_DISABLED                EQU             000000000h
;  RWI-V 
;   227 : #define NV_CONFIG_PCI_NV_21_VGA_ENABLED                  0x00000001 /* RWI-V */
NV_CONFIG_PCI_NV_21_VGA_ENABLED         EQU             000000001h
;  RW-4R 
;   228 : #define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
NV_CONFIG_PCI_NV_22             EQU             000000058h
;        
;   229 : #define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
NV_CONFIG_PCI_NV_22__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_22>
;  RWIVF 
;   230 : #define NV_CONFIG_PCI_NV_22_SCRATCH                            23:0 /* RWIVF */
NV_CONFIG_PCI_NV_22_SCRATCH             TEXTEQU         <23:0>
;  RWI-V 
;   231 : #define NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT              0x0023D6CE /* RWI-V */
NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT             EQU             00023d6ceh
;  R--4A 
;        
;   232 : #define NV_CONFIG_PCI_NV_23(i)                   (0x0000005C+(i)*4) /* R--4A */
;   233 : #define NV_CONFIG_PCI_NV_23__SIZE_1                              41 /*       */
NV_CONFIG_PCI_NV_23__SIZE_1             EQU             41t
;        
;   234 : #define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
NV_CONFIG_PCI_NV_23__ALIAS_1            TEXTEQU         <NV_PBUS_PCI_NV_23>
;  C--VF 
;   235 : #define NV_CONFIG_PCI_NV_23_RESERVED                           31:0 /* C--VF */
NV_CONFIG_PCI_NV_23_RESERVED            TEXTEQU         <31:0>
;  C---V 
;   236 : #define NV_CONFIG_PCI_NV_23_RESERVED_0                   0x00000000 /* C---V */
NV_CONFIG_PCI_NV_23_RESERVED_0          EQU             000000000h
;  dev_bus.ref 
;  R--4R 
;   237 : /* dev_bus.ref */
;   238 : #define NV_RMA_ID                                        0x00000000 /* R--4R */
NV_RMA_ID               EQU             000000000h
;        
;   239 : #define NV_RMA_ID__ALIAS_1                          NV_PRMIO_RMA_ID /*       */
NV_RMA_ID__ALIAS_1              TEXTEQU         <NV_PRMIO_RMA_ID>
;  C--UF 
;   240 : #define NV_RMA_ID_CODE                                         31:0 /* C--UF */
NV_RMA_ID_CODE          TEXTEQU         <31:0>
;  C---V 
;   241 : #define NV_RMA_ID_CODE_VALID                             0x2B16D065 /* C---V */
NV_RMA_ID_CODE_VALID            EQU             02b16d065h
;  RW-4R 
;   242 : #define NV_RMA_PTR                                       0x00000004 /* RW-4R */
NV_RMA_PTR              EQU             000000004h
;        
;   243 : #define NV_RMA_PTR__ALIAS_1                        NV_PRMIO_RMA_PTR /*       */
NV_RMA_PTR__ALIAS_1             TEXTEQU         <NV_PRMIO_RMA_PTR>
;  RWXUF 
;   244 : #define NV_RMA_PTR_ADDRESS                                     24:2 /* RWXUF */
NV_RMA_PTR_ADDRESS              TEXTEQU         <24:2>
;  RW-4R 
;   245 : #define NV_RMA_DATA                                      0x00000008 /* RW-4R */
NV_RMA_DATA             EQU             000000008h
;        
;   246 : #define NV_RMA_DATA__ALIAS_1                      NV_PRMIO_RMA_DATA /*       */
NV_RMA_DATA__ALIAS_1            TEXTEQU         <NV_PRMIO_RMA_DATA>
;  RWXUF 
;   247 : #define NV_RMA_DATA_PORT                                       31:0 /* RWXUF */
NV_RMA_DATA_PORT                TEXTEQU         <31:0>
;  RW-2R 
;   248 : #define NV_RMA_DATA32                                    0x0000000C /* RW-2R */
NV_RMA_DATA32           EQU             00000000ch
;        
;   249 : #define NV_RMA_DATA32__ALIAS_1                  NV_PRMIO_RMA_DATA32 /*       */
NV_RMA_DATA32__ALIAS_1          TEXTEQU         <NV_PRMIO_RMA_DATA32>
;  -WXUF 
;   250 : #define NV_RMA_DATA32_MSW                                     31:16 /* -WXUF */
NV_RMA_DATA32_MSW               TEXTEQU         <31:16>
;  RWXUF 
;   251 : #define NV_RMA_DATA32_LSW                                      15:0 /* RWXUF */
NV_RMA_DATA32_LSW               TEXTEQU         <15:0>
;  RW-4R 
;   252 : #define NV_RMA_INCDATA                                   0x00000010 /* RW-4R */
NV_RMA_INCDATA          EQU             000000010h
;        
;   253 : #define NV_RMA_INCDATA__ALIAS_1                NV_PRMIO_RMA_INCDATA /*       */
NV_RMA_INCDATA__ALIAS_1         TEXTEQU         <NV_PRMIO_RMA_INCDATA>
;  RWXUF 
;   254 : #define NV_RMA_INCDATA_PORT                                    31:0 /* RWXUF */
NV_RMA_INCDATA_PORT             TEXTEQU         <31:0>
;  RW-4R 
;   255 : #define NV_RMA_INCDATA32                                 0x00000014 /* RW-4R */
NV_RMA_INCDATA32                EQU             000000014h
;        
;   256 : #define NV_RMA_INCDATA32__ALIAS_1            NV_PRMIO_RMA_INCDATA32 /*       */
NV_RMA_INCDATA32__ALIAS_1               TEXTEQU         <NV_PRMIO_RMA_INCDATA32>
;  RWXUF 
;   257 : #define NV_RMA_INCDATA32_PORT                                  31:0 /* RWXUF */
NV_RMA_INCDATA32_PORT           TEXTEQU         <31:0>
;  dev_bus.ref 
;  RW--D 
;   258 : /* dev_bus.ref */
;   259 : #define NV_RMAIO                              0x000000FF:0x00000000 /* RW--D */
NV_RMAIO                TEXTEQU         <0x000000FF:0x00000000>
;  dev_bus.ref 
;  R--4R 
;   260 : /* dev_bus.ref */
;   261 : #define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
NV_PRMIO_RMA_ID         EQU             000007100h
;        
;   262 : #define NV_PRMIO_RMA_ID__ALIAS_1                          NV_RMA_ID /*       */
NV_PRMIO_RMA_ID__ALIAS_1                EQU             000000000h
;  RW-4R 
;   263 : #define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
NV_PRMIO_RMA_PTR                EQU             000007104h
;        
;   264 : #define NV_PRMIO_RMA_PTR__ALIAS_1                        NV_RMA_PTR /*       */
NV_PRMIO_RMA_PTR__ALIAS_1               EQU             000000004h
;  RW-4R 
;   265 : #define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
NV_PRMIO_RMA_DATA               EQU             000007108h
;        
;   266 : #define NV_PRMIO_RMA_DATA__ALIAS_1                      NV_RMA_DATA /*       */
NV_PRMIO_RMA_DATA__ALIAS_1              EQU             000000008h
;  RW-2R 
;   267 : #define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-2R */
NV_PRMIO_RMA_DATA32             EQU             00000710ch
;        
;   268 : #define NV_PRMIO_RMA_DATA32__ALIAS_1                  NV_RMA_DATA32 /*       */
NV_PRMIO_RMA_DATA32__ALIAS_1            EQU             00000000ch
;  RW-4R 
;   269 : #define NV_PRMIO_RMA_INCDATA                             0x00007110 /* RW-4R */
NV_PRMIO_RMA_INCDATA            EQU             000007110h
;        
;   270 : #define NV_PRMIO_RMA_INCDATA__ALIAS_1                NV_RMA_INCDATA /*       */
NV_PRMIO_RMA_INCDATA__ALIAS_1           EQU             000000010h
;  RW-4R 
;   271 : #define NV_PRMIO_RMA_INCDATA32                           0x00007114 /* RW-4R */
NV_PRMIO_RMA_INCDATA32          EQU             000007114h
;        
;   272 : #define NV_PRMIO_RMA_INCDATA32__ALIAS_1            NV_RMA_INCDATA32 /*       */
NV_PRMIO_RMA_INCDATA32__ALIAS_1         EQU             000000014h
;  dev_bus.ref 
;  RW--D 
;   273 : /* dev_bus.ref */
;   274 : #define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
NV_MEMORY               TEXTEQU         <0xFFFFFFFF:0x00000000>
;  dev_realmode.ref 
;  dev_bus.ref 
;  RW--D 
;   275 : /* dev_realmode.ref */
;   276 : /* dev_bus.ref */
;   277 : #define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
NV_IO           TEXTEQU         <0xFFFFFFFF:0x00000000>
;  -W-1R 
;   278 : #define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
NV_IO_DMA_0000          EQU             000000000h
;  -W-UF 
;   279 : #define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
NV_IO_DMA_0000_ADDRESS          TEXTEQU         <7:0>
;  -W-1R 
;   280 : #define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
NV_IO_DMA_0001          EQU             000000001h
;  -W-UF 
;   281 : #define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
NV_IO_DMA_0001_COUNT            TEXTEQU         <7:0>
;  -W-1R 
;   282 : #define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
NV_IO_DMA_0002          EQU             000000002h
;  -W-UF 
;   283 : #define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
NV_IO_DMA_0002_ADDRESS          TEXTEQU         <7:0>
;  -W-1R 
;   284 : #define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
NV_IO_DMA_0003          EQU             000000003h
;  -W-UF 
;   285 : #define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
NV_IO_DMA_0003_COUNT            TEXTEQU         <7:0>
;  -W-1R 
;   286 : #define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
NV_IO_DMA_0004          EQU             000000004h
;  -W-UF 
;   287 : #define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
NV_IO_DMA_0004_ADDRESS          TEXTEQU         <7:0>
;  -W-1R 
;   288 : #define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
NV_IO_DMA_0005          EQU             000000005h
;  -W-UF 
;   289 : #define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
NV_IO_DMA_0005_COUNT            TEXTEQU         <7:0>
;  -W-1R 
;   290 : #define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
NV_IO_DMA_0006          EQU             000000006h
;  -W-UF 
;   291 : #define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
NV_IO_DMA_0006_ADDRESS          TEXTEQU         <7:0>
;  -W-1R 
;   292 : #define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
NV_IO_DMA_0007          EQU             000000007h
;  -W-UF 
;   293 : #define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
NV_IO_DMA_0007_COUNT            TEXTEQU         <7:0>
;  -W-1R 
;   294 : #define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
NV_IO_DMA_0008          EQU             000000008h
;  -W-VF 
;   295 : #define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
NV_IO_DMA_0008_CONTROLLER               TEXTEQU         <2:2>
;  -W--V 
;   296 : #define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
NV_IO_DMA_0008_CONTROLLER_DISABLED              EQU             000000000h
;  -W--V 
;   297 : #define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
NV_IO_DMA_0008_CONTROLLER_ENABLED               EQU             000000001h
;  -W-1R 
;   298 : #define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
NV_IO_DMA_000A          EQU             00000000ah
;  -W-UF 
;   299 : #define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
NV_IO_DMA_000A_CHANNEL          TEXTEQU         <1:0>
;  -W-VF 
;   300 : #define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
NV_IO_DMA_000A_MASK_BIT         TEXTEQU         <2:2>
;  -W--V 
;   301 : #define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
NV_IO_DMA_000A_MASK_BIT_CLEAR           EQU             000000000h
;  -W--V 
;   302 : #define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
NV_IO_DMA_000A_MASK_BIT_SET             EQU             000000001h
;  -W-1R 
;   303 : #define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
NV_IO_DMA_000B          EQU             00000000bh
;  -W-UF 
;   304 : #define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
NV_IO_DMA_000B_CHANNEL          TEXTEQU         <1:0>
;  -W-VF 
;   305 : #define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
NV_IO_DMA_000B_AUTOINITIALIZE           TEXTEQU         <4:4>
;  -W--V 
;   306 : #define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED          EQU             000000000h
;  -W--V 
;   307 : #define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED           EQU             000000001h
;  -W-VF 
;   308 : #define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
NV_IO_DMA_000B_DIRECTION                TEXTEQU         <5:5>
;  -W--V 
;   309 : #define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
NV_IO_DMA_000B_DIRECTION_INCREMENT              EQU             000000000h
;  -W--V 
;   310 : #define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
NV_IO_DMA_000B_DIRECTION_DECREMENT              EQU             000000001h
;  -W-1R 
;   311 : #define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
NV_IO_DMA_000C          EQU             00000000ch
;  -W-VF 
;   312 : #define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
NV_IO_DMA_000C_CLEAR_FLIPFLOP           TEXTEQU         <7:0>
;  -W-1R 
;   313 : #define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
NV_IO_DMA_0081          EQU             000000081h
;  -W-UF 
;   314 : #define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
NV_IO_DMA_0081_ADDRESS          TEXTEQU         <3:0>
;  -W-1R 
;   315 : #define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
NV_IO_DMA_0082          EQU             000000082h
;  -W-UF 
;   316 : #define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
NV_IO_DMA_0082_ADDRESS          TEXTEQU         <3:0>
;  -W-1R 
;   317 : #define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
NV_IO_DMA_0083          EQU             000000083h
;  -W-UF 
;   318 : #define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
NV_IO_DMA_0083_ADDRESS          TEXTEQU         <3:0>
;  -W-1R 
;   319 : #define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
NV_IO_DMA_0087          EQU             000000087h
;  -W-UF 
;   320 : #define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
NV_IO_DMA_0087_ADDRESS          TEXTEQU         <3:0>
;  dev_dac.ref 
;  RW--D 
;   321 : /* dev_dac.ref */
;   322 : #define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
NV_PRAMDAC              TEXTEQU         <0x00680FFF:0x00680300>
;  RW-4R 
;   323 : #define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
NV_PRAMDAC_CU_START_POS         EQU             000680300h
;  RWXSF 
;   324 : #define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
NV_PRAMDAC_CU_START_POS_X               TEXTEQU         <11:0>
;  RWXSF 
;   325 : #define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
NV_PRAMDAC_CU_START_POS_Y               TEXTEQU         <27:16>
;  RW-4R 
;   326 : #define NV_PRAMDAC_APLL_COEFF                            0x00680500 /* RW-4R */
NV_PRAMDAC_APLL_COEFF           EQU             000680500h
;  RWIUF 
;   327 : #define NV_PRAMDAC_APLL_COEFF_MDIV                              7:0 /* RWIUF */
NV_PRAMDAC_APLL_COEFF_MDIV              TEXTEQU         <7:0>
;  RWIUF 
;   328 : #define NV_PRAMDAC_APLL_COEFF_NDIV                             15:8 /* RWIUF */
NV_PRAMDAC_APLL_COEFF_NDIV              TEXTEQU         <15:8>
;  RWIVF 
;   329 : #define NV_PRAMDAC_APLL_COEFF_PDIV                            18:16 /* RWIVF */
NV_PRAMDAC_APLL_COEFF_PDIV              TEXTEQU         <18:16>
;  RW-4R 
;   330 : #define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
NV_PRAMDAC_MPLL_COEFF           EQU             000680504h
;  RWIUF 
;   331 : #define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
NV_PRAMDAC_MPLL_COEFF_MDIV              TEXTEQU         <7:0>
;  RWIUF 
;   332 : #define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
NV_PRAMDAC_MPLL_COEFF_NDIV              TEXTEQU         <15:8>
;  RWIVF 
;   333 : #define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
NV_PRAMDAC_MPLL_COEFF_PDIV              TEXTEQU         <18:16>
;  RW-4R 
;   334 : #define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
NV_PRAMDAC_VPLL_COEFF           EQU             000680508h
NV_PRAMDAC_VPLL2_COEFF          EQU             000680520h
;  RWIUF 
;   335 : #define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
NV_PRAMDAC_VPLL_COEFF_MDIV              TEXTEQU         <7:0>
;  RWIUF 
;   336 : #define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
NV_PRAMDAC_VPLL_COEFF_NDIV              TEXTEQU         <15:8>
;  RWIVF 
;   337 : #define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
NV_PRAMDAC_VPLL_COEFF_PDIV              TEXTEQU         <18:16>
;  RW-4R 
;   338 : #define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
NV_PRAMDAC_PLL_COEFF_SELECT             EQU             00068050ch
;  RWIVF 
;   339 : #define NV_PRAMDAC_PLL_COEFF_SELECT_APLL_SOURCE                 0:0 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_APLL_SOURCE         TEXTEQU         <0:0>
;  RWI-V 
;   340 : #define NV_PRAMDAC_PLL_COEFF_SELECT_APLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_APLL_SOURCE_DEFAULT         EQU             000000000h
;  RW--V 
;   341 : #define NV_PRAMDAC_PLL_COEFF_SELECT_APLL_SOURCE_PROG     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_APLL_SOURCE_PROG            EQU             000000001h
;  RWIVF 
;   342 : #define NV_PRAMDAC_PLL_COEFF_SELECT_APLL_BYPASS                 4:4 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_APLL_BYPASS         TEXTEQU         <4:4>
;  RWI-V 
;   343 : #define NV_PRAMDAC_PLL_COEFF_SELECT_APLL_BYPASS_FALSE    0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_APLL_BYPASS_FALSE           EQU             000000000h
;  RW--V 
;   344 : #define NV_PRAMDAC_PLL_COEFF_SELECT_APLL_BYPASS_TRUE     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_APLL_BYPASS_TRUE            EQU             000000001h
;  RWIVF 
;   345 : #define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE                 8:8 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE         TEXTEQU         <8:8>
;  RWI-V 
;   346 : #define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT         EQU             000000000h
;  RW--V 
;   347 : #define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG            EQU             000000001h
;  RWIVF 
;   348 : #define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS               12:12 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS         TEXTEQU         <12:12>
;  RWI-V 
;   349 : #define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE           EQU             000000000h
;  RW--V 
;   350 : #define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE            EQU             000000001h
;  RWIVF 
;   351 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE               16:16 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE         TEXTEQU         <16:16>
;  RWI-V 
;   352 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT         EQU             000000000h
;  RW--V 
;   353 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG            EQU             000000001h
;  RWIVF 
;   354 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS               20:20 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS         TEXTEQU         <20:20>
;  RWI-V 
;   355 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE           EQU             000000000h
;  RW--V 
;   356 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE            EQU             000000001h
;  RWIVF 
;   357 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO          TEXTEQU         <28:28>
;  RWI-V 
;   358 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1              EQU             000000000h
;  RW--V 
;   359 : #define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2              EQU             000000001h
;  RW-4R 
;   360 : #define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
NV_PRAMDAC_PLL_SETUP_CONTROL            EQU             000680510h
;  RWIVF 
;   361 : #define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE              TEXTEQU         <10:0>
;  RWI-V 
;   362 : #define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                EQU             00000044eh
;  RWIVF 
;   363 : #define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   12:12 /* RWIVF */
NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN             TEXTEQU         <12:12>
;  RWI-V 
;   364 : #define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON          EQU             000000000h
;  RW--V 
;   365 : #define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000001 /* RW--V */
NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF         EQU             000000001h
;  RW-4R 
;   366 : #define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
NV_PRAMDAC_PLL_TEST_COUNTER             EQU             000680514h
;  -WIVF 
;   367 : #define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS          TEXTEQU         <9:0>
;  R--VF 
;   368 : #define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
NV_PRAMDAC_PLL_TEST_COUNTER_VALUE               TEXTEQU         <15:0>
;  RWIVF 
;   369 : #define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE              TEXTEQU         <16:16>
;  RWI-V 
;   370 : #define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED           EQU             000000000h
;  RW--V 
;   371 : #define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED             EQU             000000001h
;  RWIVF 
;   372 : #define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
NV_PRAMDAC_PLL_TEST_COUNTER_RESET               TEXTEQU         <20:20>
;  RWI-V 
;   373 : #define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED            EQU             000000000h
;  RW--V 
;   374 : #define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED              EQU             000000001h
;  RWIVF 
;   375 : #define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE              TEXTEQU         <25:24>
;  RWI-V 
;   376 : #define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK         EQU             000000000h
;  RW--V 
;   377 : #define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK         EQU             000000001h
;  RW--V 
;   378 : #define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK          0x00000010 /* RW--V */
NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK         EQU             000000010h
;  RWIVF 
;   379 : #define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST            TEXTEQU         <28:28>
;  RWI-V 
;   380 : #define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED          EQU             000000000h
;  RW--V 
;   381 : #define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED            EQU             000000001h
;  R--VF 
;   382 : #define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCK                 29:29 /* R--VF */
NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCK           TEXTEQU         <29:29>
;  R---V 
;   383 : #define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_NOTLOCKED       0x00000000 /* R---V */
NV_PRAMDAC_PLL_TEST_COUNTER_APLL_NOTLOCKED              EQU             000000000h
;  R---V 
;   384 : #define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCKED          0x00000001 /* R---V */
NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCKED         EQU             000000001h
;  R--VF 
;   385 : #define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK           TEXTEQU         <30:30>
;  R---V 
;   386 : #define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED              EQU             000000000h
;  R---V 
;   387 : #define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED         EQU             000000001h
;  R--VF 
;   388 : #define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK           TEXTEQU         <31:31>
;  R---V 
;   389 : #define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED              EQU             000000000h
;  R---V 
;   390 : #define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED         EQU             000000001h
;  RW-4R 
;   391 : #define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
NV_PRAMDAC_PALETTE_TEST         EQU             000680518h
;  R--VF 
;   392 : #define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
NV_PRAMDAC_PALETTE_TEST_BLUE_DATA               TEXTEQU         <7:0>
;  R--VF 
;   393 : #define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
NV_PRAMDAC_PALETTE_TEST_GREEN_DATA              TEXTEQU         <15:8>
;  R--VF 
;   394 : #define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
NV_PRAMDAC_PALETTE_TEST_RED_DATA                TEXTEQU         <23:16>
;  RWIVF 
;   395 : #define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
NV_PRAMDAC_PALETTE_TEST_MODE            TEXTEQU         <24:24>
;  RWI-V 
;   396 : #define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
NV_PRAMDAC_PALETTE_TEST_MODE_8BIT               EQU             000000000h
;  RW--V 
;   397 : #define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
NV_PRAMDAC_PALETTE_TEST_MODE_24BIT              EQU             000000001h
;  RWIVF 
;   398 : #define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
NV_PRAMDAC_PALETTE_TEST_ADDRINC         TEXTEQU         <28:28>
;  RWI-V 
;   399 : #define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE               EQU             000000000h
;  RW--V 
;   400 : #define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY               EQU             000000001h
;  RW-4R 
;   401 : #define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
NV_PRAMDAC_GENERAL_CONTROL              EQU             000680600h
;  RWIVF 
;   402 : #define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF                     1:0 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF             TEXTEQU         <1:0>
;  RWI-V 
;   403 : #define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF          0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF         EQU             000000000h
;  RWIVF 
;   404 : #define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE                     4:4 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE             TEXTEQU         <4:4>
;  RWI-V 
;   405 : #define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA        0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA               EQU             000000000h
;  RW--V 
;   406 : #define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX        0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX               EQU             000000001h
;  RWIVF 
;   407 : #define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE            TEXTEQU         <8:8>
;  RWI-V 
;   408 : #define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE       0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE              EQU             000000000h
;  RW--V 
;   409 : #define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL                EQU             000000001h
;  RWIVF 
;   410 : #define NV_PRAMDAC_GENERAL_CONTROL_565_MODE                   12:12 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_565_MODE             TEXTEQU         <12:12>
;  RWI-V 
;   411 : #define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL       0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL              EQU             000000000h
;  RW--V 
;   412 : #define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL          0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL         EQU             000000001h
;  RWIVF 
;   413 : #define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL           TEXTEQU         <16:16>
;  RWI-V 
;   414 : #define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF               EQU             000000000h
;  RW--V 
;   415 : #define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON                EQU             000000001h
;  RWIVF 
;   416 : #define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_TERMINATION          TEXTEQU         <17:17>
;  RWI-V 
;   417 : #define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM            EQU             000000000h
;  RW--V 
;   418 : #define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM            EQU             000000001h
;  RWIVF 
;   419 : #define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_BPC          TEXTEQU         <20:20>
;  RWI-V 
;   420 : #define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS            EQU             000000000h
;  RW--V 
;   421 : #define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS            EQU             000000001h
;  RWIVF 
;   422 : #define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP            TEXTEQU         <24:24>
;  RWI-V 
;   423 : #define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS                EQU             000000000h
;  RW--V 
;   424 : #define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN         EQU             000000001h
;  RWIVF 
;   425 : #define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK          TEXTEQU         <28:28>
;  RWI-V 
;   426 : #define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN               EQU             000000000h
;  RW--V 
;   427 : #define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS              EQU             000000001h
;  R--4R 
;   428 : #define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
NV_PRAMDAC_PALETTE_RECOVERY             EQU             000680604h
;  R--UF 
;   429 : #define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              TEXTEQU         <7:0>
;  R--VF 
;   430 : #define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER         TEXTEQU         <10:8>
;  R---V 
;   431 : #define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED             EQU             000000001h
;  R---V 
;   432 : #define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000010 /* R---V */
NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN           EQU             000000010h
;  R---V 
;   433 : #define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000100 /* R---V */
NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE            EQU             000000100h
;  R--VF 
;   434 : #define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE           TEXTEQU         <13:12>
;  R---V 
;   435 : #define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE             EQU             000000000h
;  R---V 
;   436 : #define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000011 /* R---V */
NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ              EQU             000000011h
;  R--VF 
;   437 : #define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA            TEXTEQU         <23:16>
;  R--VF 
;   438 : #define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA          TEXTEQU         <31:24>
;  RW-4R 
;   439 : #define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
NV_PRAMDAC_TEST_CONTROL         EQU             000680608h
;  RWIVF 
;   440 : #define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_CRC_RESET               TEXTEQU         <0:0>
;  RWI-V 
;   441 : #define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED            EQU             000000000h
;  RW--V 
;   442 : #define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED              EQU             000000001h
;  RWIVF 
;   443 : #define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE              TEXTEQU         <4:4>
;  RWI-V 
;   444 : #define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED           EQU             000000000h
;  RW--V 
;   445 : #define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED             EQU             000000001h
;  RWIVF 
;   446 : #define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL             TEXTEQU         <9:8>
;  RWI-V 
;   447 : #define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE                EQU             000000000h
;  RW--V 
;   448 : #define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN               EQU             000000001h
;  RW--V 
;   449 : #define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000010 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED         EQU             000000010h
;  RWIVF 
;   450 : #define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_TP_INS_EN               TEXTEQU         <12:12>
;  RWI-V 
;   451 : #define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED            EQU             000000000h
;  RW--V 
;   452 : #define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED              EQU             000000001h
;  RWIVF 
;   453 : #define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC              TEXTEQU         <16:16>
;  RWI-V 
;   454 : #define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON           EQU             000000000h
;  RW--V 
;   455 : #define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF          EQU             000000001h
;  RWIVF 
;   456 : #define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_DACTM           TEXTEQU         <20:20>
;  RWI-V 
;   457 : #define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL            EQU             000000000h
;  RW--V 
;   458 : #define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_DACTM_TEST              EQU             000000001h
;  RWIVF 
;   459 : #define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_TPATH1          TEXTEQU         <24:24>
;  RWI-V 
;   460 : #define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR            EQU             000000000h
;  RW--V 
;   461 : #define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_TPATH1_SET              EQU             000000001h
;  RWIVF 
;   462 : #define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
NV_PRAMDAC_TEST_CONTROL_TPATH31         TEXTEQU         <25:25>
;  RWI-V 
;   463 : #define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR           EQU             000000000h
;  RW--V 
;   464 : #define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
NV_PRAMDAC_TEST_CONTROL_TPATH31_SET             EQU             000000001h
;  R--VF 
;   465 : #define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
NV_PRAMDAC_TEST_CONTROL_SENSEB          TEXTEQU         <28:28>
;  R---V 
;   466 : #define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO           EQU             000000000h
;  R---V 
;   467 : #define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI            EQU             000000001h
;  R--4R 
;   468 : #define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
NV_PRAMDAC_CHECKSUM             EQU             00068060ch
;  R--VF 
;   469 : #define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
NV_PRAMDAC_CHECKSUM_VALUE               TEXTEQU         <23:0>
;  -W-4R 
;   470 : #define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
NV_PRAMDAC_TESTPOINT_DATA               EQU             000680610h
;  -W-VF 
;   471 : #define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
NV_PRAMDAC_TESTPOINT_DATA_RED           TEXTEQU         <9:0>
;  -W-VF 
;   472 : #define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
NV_PRAMDAC_TESTPOINT_DATA_GREEN         TEXTEQU         <19:10>
;  -W-VF 
;   473 : #define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
NV_PRAMDAC_TESTPOINT_DATA_BLUE          TEXTEQU         <29:20>
;  -W-VF 
;   474 : #define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
NV_PRAMDAC_TESTPOINT_DATA_BLACK         TEXTEQU         <30:30>
;  -W-VF 
;   475 : #define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK              TEXTEQU         <31:31>
;  RW-4R 
;   476 : #define NV_PRAMDAC_VSERR_WIDTH                           0x00680700 /* RW-4R */
NV_PRAMDAC_VSERR_WIDTH          EQU             000680700h
;  RWIVF 
;   477 : #define NV_PRAMDAC_VSERR_WIDTH_VAL                             10:0 /* RWIVF */
NV_PRAMDAC_VSERR_WIDTH_VAL              TEXTEQU         <10:0>
;  RW-4R 
;   478 : #define NV_PRAMDAC_VEQU_END                              0x00680704 /* RW-4R */
NV_PRAMDAC_VEQU_END             EQU             000680704h
;  RWIVF 
;   479 : #define NV_PRAMDAC_VEQU_END_VAL                                10:0 /* RWIVF */
NV_PRAMDAC_VEQU_END_VAL         TEXTEQU         <10:0>
;  RW-4R 
;   480 : #define NV_PRAMDAC_VBBLANK_END                           0x00680708 /* RW-4R */
NV_PRAMDAC_VBBLANK_END          EQU             000680708h
;  RWIVF 
;   481 : #define NV_PRAMDAC_VBBLANK_END_VAL                             10:0 /* RWIVF */
NV_PRAMDAC_VBBLANK_END_VAL              TEXTEQU         <10:0>
;  RW-4R 
;   482 : #define NV_PRAMDAC_VBLANK_END                            0x0068070C /* RW-4R */
NV_PRAMDAC_VBLANK_END           EQU             00068070ch
;  RWIVF 
;   483 : #define NV_PRAMDAC_VBLANK_END_VAL                              10:0 /* RWIVF */
NV_PRAMDAC_VBLANK_END_VAL               TEXTEQU         <10:0>
;  RW-4R 
;   484 : #define NV_PRAMDAC_VBLANK_START                          0x00680710 /* RW-4R */
NV_PRAMDAC_VBLANK_START         EQU             000680710h
;  RWIVF 
;   485 : #define NV_PRAMDAC_VBLANK_START_VAL                            10:0 /* RWIVF */
NV_PRAMDAC_VBLANK_START_VAL             TEXTEQU         <10:0>
;  RW-4R 
;   486 : #define NV_PRAMDAC_VBBLANK_START                         0x00680714 /* RW-4R */
NV_PRAMDAC_VBBLANK_START                EQU             000680714h
;  RWIVF 
;   487 : #define NV_PRAMDAC_VBBLANK_START_VAL                           10:0 /* RWIVF */
NV_PRAMDAC_VBBLANK_START_VAL            TEXTEQU         <10:0>
;  RW-4R 
;   488 : #define NV_PRAMDAC_VEQU_START                            0x00680718 /* RW-4R */
NV_PRAMDAC_VEQU_START           EQU             000680718h
;  RWIVF 
;   489 : #define NV_PRAMDAC_VEQU_START_VAL                              10:0 /* RWIVF */
NV_PRAMDAC_VEQU_START_VAL               TEXTEQU         <10:0>
;  RW-4R 
;   490 : #define NV_PRAMDAC_VTOTAL                                0x0068071C /* RW-4R */
NV_PRAMDAC_VTOTAL               EQU             00068071ch
;  RWIVF 
;   491 : #define NV_PRAMDAC_VTOTAL_VAL                                  10:0 /* RWIVF */
NV_PRAMDAC_VTOTAL_VAL           TEXTEQU         <10:0>
;  RW-4R 
;   492 : #define NV_PRAMDAC_HSYNC_WIDTH                           0x00680720 /* RW-4R */
NV_PRAMDAC_HSYNC_WIDTH          EQU             000680720h
;  RWIVF 
;   493 : #define NV_PRAMDAC_HSYNC_WIDTH_VAL                             10:0 /* RWIVF */
NV_PRAMDAC_HSYNC_WIDTH_VAL              TEXTEQU         <10:0>
;  RW-4R 
;   494 : #define NV_PRAMDAC_HBURST_START                          0x00680724 /* RW-4R */
NV_PRAMDAC_HBURST_START         EQU             000680724h
;  RWIVF 
;   495 : #define NV_PRAMDAC_HBURST_START_VAL                            10:0 /* RWIVF */
NV_PRAMDAC_HBURST_START_VAL             TEXTEQU         <10:0>
;  RW-4R 
;   496 : #define NV_PRAMDAC_HBURST_END                            0x00680728 /* RW-4R */
NV_PRAMDAC_HBURST_END           EQU             000680728h
;  RWIVF 
;   497 : #define NV_PRAMDAC_HBURST_END_VAL                              10:0 /* RWIVF */
NV_PRAMDAC_HBURST_END_VAL               TEXTEQU         <10:0>
;  RW-4R 
;   498 : #define NV_PRAMDAC_HBLANK_START                          0x0068072C /* RW-4R */
NV_PRAMDAC_HBLANK_START         EQU             00068072ch
;  RWIVF 
;   499 : #define NV_PRAMDAC_HBLANK_START_VAL                            10:0 /* RWIVF */
NV_PRAMDAC_HBLANK_START_VAL             TEXTEQU         <10:0>
;  RW-4R 
;   500 : #define NV_PRAMDAC_HBLANK_END                            0x00680730 /* RW-4R */
NV_PRAMDAC_HBLANK_END           EQU             000680730h
;  RWIVF 
;   501 : #define NV_PRAMDAC_HBLANK_END_VAL                              10:0 /* RWIVF */
NV_PRAMDAC_HBLANK_END_VAL               TEXTEQU         <10:0>
;  RW-4R 
;   502 : #define NV_PRAMDAC_HTOTAL                                0x00680734 /* RW-4R */
NV_PRAMDAC_HTOTAL               EQU             000680734h
;  RWIVF 
;   503 : #define NV_PRAMDAC_HTOTAL_VAL                                  10:0 /* RWIVF */
NV_PRAMDAC_HTOTAL_VAL           TEXTEQU         <10:0>
;  RW-4R 
;   504 : #define NV_PRAMDAC_HEQU_WIDTH                            0x00680738 /* RW-4R */
NV_PRAMDAC_HEQU_WIDTH           EQU             000680738h
;  RWIVF 
;   505 : #define NV_PRAMDAC_HEQU_WIDTH_VAL                              10:0 /* RWIVF */
NV_PRAMDAC_HEQU_WIDTH_VAL               TEXTEQU         <10:0>
;  RW-4R 
;   506 : #define NV_PRAMDAC_HSERR_WIDTH                           0x0068073C /* RW-4R */
NV_PRAMDAC_HSERR_WIDTH          EQU             00068073ch
;  RWIVF 
;   507 : #define NV_PRAMDAC_HSERR_WIDTH_VAL                             10:0 /* RWIVF */
NV_PRAMDAC_HSERR_WIDTH_VAL              TEXTEQU         <10:0>

NV_PRAMDAC_FP_DEBUG_0           EQU             000680880H

;  dev_dac.ref 
;  RW--D 
;   508 : /* dev_dac.ref */
;   509 : #define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
NV_USER_DAC             TEXTEQU         <0x00681FFF:0x00681200>
;  RWI1R 
;   510 : #define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
NV_USER_DAC_PIXEL_MASK          EQU             0006813c6h
;  RWIVF 
;   511 : #define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
NV_USER_DAC_PIXEL_MASK_VALUE            TEXTEQU         <7:0>
;  RWI-V 
;   512 : #define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
NV_USER_DAC_PIXEL_MASK_MASK             EQU             0000000ffh
;  RW-1R 
;   513 : #define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
NV_USER_DAC_READ_MODE_ADDRESS           EQU             0006813c7h
;  RW-VF 
;   514 : #define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
NV_USER_DAC_READ_MODE_ADDRESS_VALUE             TEXTEQU         <7:0>
;  -W-VF 
;   515 : #define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE          TEXTEQU         <7:0>
;  R--VF 
;   516 : #define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE          TEXTEQU         <1:0>
;  R---V 
;   517 : #define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE            EQU             000000000h
;  R---V 
;   518 : #define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000011 /* R---V */
NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ             EQU             000000011h
;  RW-1R 
;   519 : #define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
NV_USER_DAC_WRITE_MODE_ADDRESS          EQU             0006813c8h
;  RW-VF 
;   520 : #define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE            TEXTEQU         <7:0>
;  RW-1R 
;   521 : #define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
NV_USER_DAC_PALETTE_DATA                EQU             0006813c9h
;  RW-VF 
;   522 : #define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
NV_USER_DAC_PALETTE_DATA_VALUE          TEXTEQU         <7:0>
;  dev_realmode.ref 
;  R--1R 
;   523 : /* dev_realmode.ref */
;   524 : #define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
NV_IO_MPU_401_DATA              EQU             000000330h
;  R--1R 
;   525 : #define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
NV_IO_MPU_401_DATA__ALIAS_1             EQU             000000300h
;  R--1R 
;   526 : #define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
NV_IO_MPU_401_DATA__ALIAS_2             EQU             000000230h
;  R--VF 
;   527 : #define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
NV_IO_MPU_401_DATA_VALUE                TEXTEQU         <7:0>
;  R---V 
;   528 : #define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
NV_IO_MPU_401_DATA_ACK          EQU             0000000feh
;  R--1R 
;   529 : #define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
NV_IO_MPU_401_STATUS            EQU             000000331h
;  R--1R 
;   530 : #define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
NV_IO_MPU_401_STATUS__ALIAS_1           EQU             000000301h
;  R--1R 
;   531 : #define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
NV_IO_MPU_401_STATUS__ALIAS_2           EQU             000000231h
;  R--VF 
;   532 : #define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
NV_IO_MPU_401_STATUS_DATA               TEXTEQU         <5:0>
;  R--VF 
;   533 : #define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
NV_IO_MPU_401_STATUS_WRITE              TEXTEQU         <6:6>
;  R---V 
;   534 : #define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
NV_IO_MPU_401_STATUS_WRITE_EMPTY                EQU             000000000h
;  R---V 
;   535 : #define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
NV_IO_MPU_401_STATUS_WRITE_FULL         EQU             000000001h
;  R--VF 
;   536 : #define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
NV_IO_MPU_401_STATUS_READ               TEXTEQU         <7:7>
;  R---V 
;   537 : #define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
NV_IO_MPU_401_STATUS_READ_FULL          EQU             000000000h
;  R---V 
;   538 : #define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
NV_IO_MPU_401_STATUS_READ_EMPTY         EQU             000000001h
;  -W-1R 
;   539 : #define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
NV_IO_MPU_401_COM               EQU             000000331h
;  -W-1R 
;   540 : #define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
NV_IO_MPU_401_COM__ALIAS_1              EQU             000000301h
;  -W-1R 
;   541 : #define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
NV_IO_MPU_401_COM__ALIAS_2              EQU             000000231h
;  -WIVF 
;   542 : #define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
NV_IO_MPU_401_COM_UART_MODE             TEXTEQU         <7:0>
;  -WI-V 
;   543 : #define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
NV_IO_MPU_401_COM_UART_MODE_COMPLEX             EQU             0000000ffh
;  -W--V 
;   544 : #define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
NV_IO_MPU_401_COM_UART_MODE_SIMPLE              EQU             00000003fh
;  dev_master.ref 
;  RW--D 
;   545 : /* dev_master.ref */
;   546 : #define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
NV_PMC          TEXTEQU         <0x00000FFF:0x00000000>
;  R--4R 
;   547 : #define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
NV_PMC_BOOT_0           EQU             000000000h
;  C--VF 
;   548 : #define NV_PMC_BOOT_0_FIB_REVISION                              3:0 /* C--VF */
NV_PMC_BOOT_0_FIB_REVISION              TEXTEQU         <3:0>
;  C---V 
;   549 : #define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* C---V */
NV_PMC_BOOT_0_FIB_REVISION_0            EQU             000000000h
;  C--VF 
;   550 : #define NV_PMC_BOOT_0_MASK_REVISION                             7:4 /* C--VF */
NV_PMC_BOOT_0_MASK_REVISION             TEXTEQU         <7:4>
;  C---V 
;   551 : #define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* C---V */
NV_PMC_BOOT_0_MASK_REVISION_A           EQU             000000000h
;  R--VF 
;   552 : #define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* R--VF */
NV_PMC_BOOT_0_IMPLEMENTATION            TEXTEQU         <15:8>
;  ----V 
;   553 : #define NV_PMC_BOOT_0_IMPLEMENTATION_NV0                 0x00000000 /* ----V */
NV_PMC_BOOT_0_IMPLEMENTATION_NV0                EQU             000000000h
;  ----V 
;   554 : #define NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32              0x00000001 /* ----V */
NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32             EQU             000000001h
;  ----V 
;   555 : #define NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32              0x00000002 /* ----V */
NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32             EQU             000000002h
;  ----V 
;   556 : #define NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO             0x00000003 /* ----V */
NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO            EQU             000000003h
;  ----V 
;   557 : #define NV_PMC_BOOT_0_IMPLEMENTATION_NV2MUTARA           0x00000004 /* ----V */
NV_PMC_BOOT_0_IMPLEMENTATION_NV2MUTARA          EQU             000000004h
;  R---V 
;   558 : #define NV_PMC_BOOT_0_IMPLEMENTATION_NV3                 0x00000005 /* R---V */
NV_PMC_BOOT_0_IMPLEMENTATION_NV3                EQU             000000005h
;  C--VF 
;   559 : #define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
NV_PMC_BOOT_0_ARCHITECTURE              TEXTEQU         <23:16>
;  ----V 
;   560 : #define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
NV_PMC_BOOT_0_ARCHITECTURE_NV0          EQU             000000000h
;  ----V 
;   561 : #define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
NV_PMC_BOOT_0_ARCHITECTURE_NV1          EQU             000000001h
;  ----V 
;   562 : #define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
NV_PMC_BOOT_0_ARCHITECTURE_NV2          EQU             000000002h
;  C---V 
;   563 : #define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* C---V */
NV_PMC_BOOT_0_ARCHITECTURE_NV3          EQU             000000003h
;  C--UF 
;   564 : #define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
NV_PMC_BOOT_0_MANUFACTURER              TEXTEQU         <27:24>
;  C---V 
;   565 : #define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
NV_PMC_BOOT_0_MANUFACTURER_NVIDIA               EQU             000000000h
;  C--VF 
;   566 : #define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
NV_PMC_BOOT_0_FOUNDRY           TEXTEQU         <31:28>
;  C---V 
;   567 : #define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* C---V */
NV_PMC_BOOT_0_FOUNDRY_SGS               EQU             000000000h
;  ----V 
;   568 : #define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
NV_PMC_BOOT_0_FOUNDRY_HELIOS            EQU             000000001h
;  RW-4R 
;   569 : #define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
NV_PMC_INTR_0           EQU             000000100h
;  R--VF 
;   570 : #define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
NV_PMC_INTR_0_PAUDIO            TEXTEQU         <0:0>
;  R---V 
;   571 : #define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
NV_PMC_INTR_0_PAUDIO_NOT_PENDING                EQU             000000000h
;  R---V 
;   572 : #define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
NV_PMC_INTR_0_PAUDIO_PENDING            EQU             000000001h
;  R--VF 
;   573 : #define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
NV_PMC_INTR_0_PMEDIA            TEXTEQU         <4:4>
;  R---V 
;   574 : #define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
NV_PMC_INTR_0_PMEDIA_NOT_PENDING                EQU             000000000h
;  R---V 
;   575 : #define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
NV_PMC_INTR_0_PMEDIA_PENDING            EQU             000000001h
;  R--VF 
;   576 : #define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
NV_PMC_INTR_0_PFIFO             TEXTEQU         <8:8>
;  R---V 
;   577 : #define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
NV_PMC_INTR_0_PFIFO_NOT_PENDING         EQU             000000000h
;  R---V 
;   578 : #define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
NV_PMC_INTR_0_PFIFO_PENDING             EQU             000000001h
;  R--VF 
;   579 : #define NV_PMC_INTR_0_PGRAPH0                                 12:12 /* R--VF */
NV_PMC_INTR_0_PGRAPH0           TEXTEQU         <12:12>
;  R---V 
;   580 : #define NV_PMC_INTR_0_PGRAPH0_NOT_PENDING                0x00000000 /* R---V */
NV_PMC_INTR_0_PGRAPH0_NOT_PENDING               EQU             000000000h
;  R---V 
;   581 : #define NV_PMC_INTR_0_PGRAPH0_PENDING                    0x00000001 /* R---V */
NV_PMC_INTR_0_PGRAPH0_PENDING           EQU             000000001h
;  R--VF 
;   582 : #define NV_PMC_INTR_0_PGRAPH1                                 13:13 /* R--VF */
NV_PMC_INTR_0_PGRAPH1           TEXTEQU         <13:13>
;  R---V 
;   583 : #define NV_PMC_INTR_0_PGRAPH1_NOT_PENDING                0x00000000 /* R---V */
NV_PMC_INTR_0_PGRAPH1_NOT_PENDING               EQU             000000000h
;  R---V 
;   584 : #define NV_PMC_INTR_0_PGRAPH1_PENDING                    0x00000001 /* R---V */
NV_PMC_INTR_0_PGRAPH1_PENDING           EQU             000000001h
;  R--VF 
;   585 : #define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
NV_PMC_INTR_0_PVIDEO            TEXTEQU         <16:16>
;  R---V 
;   586 : #define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
NV_PMC_INTR_0_PVIDEO_NOT_PENDING                EQU             000000000h
;  R---V 
;   587 : #define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
NV_PMC_INTR_0_PVIDEO_PENDING            EQU             000000001h
;  R--VF 
;   588 : #define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
NV_PMC_INTR_0_PTIMER            TEXTEQU         <20:20>
;  R---V 
;   589 : #define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
NV_PMC_INTR_0_PTIMER_NOT_PENDING                EQU             000000000h
;  R---V 
;   590 : #define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
NV_PMC_INTR_0_PTIMER_PENDING            EQU             000000001h
;  R--VF 
;   591 : #define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
NV_PMC_INTR_0_PFB               TEXTEQU         <24:24>
;  R---V 
;   592 : #define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
NV_PMC_INTR_0_PFB_NOT_PENDING           EQU             000000000h
;  R---V 
;   593 : #define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
NV_PMC_INTR_0_PFB_PENDING               EQU             000000001h
;  R--VF 
;   594 : #define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
NV_PMC_INTR_0_PBUS              TEXTEQU         <28:28>
;  R---V 
;   595 : #define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
NV_PMC_INTR_0_PBUS_NOT_PENDING          EQU             000000000h
;  R---V 
;   596 : #define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
NV_PMC_INTR_0_PBUS_PENDING              EQU             000000001h
;  RWIVF 
;   597 : #define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
NV_PMC_INTR_0_SOFTWARE          TEXTEQU         <31:31>
;  RWI-V 
;   598 : #define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
NV_PMC_INTR_0_SOFTWARE_NOT_PENDING              EQU             000000000h
;  RW--V 
;   599 : #define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
NV_PMC_INTR_0_SOFTWARE_PENDING          EQU             000000001h
;  RW-4R 
;   600 : #define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
NV_PMC_INTR_EN_0                EQU             000000140h
;  RWIVF 
;   601 : #define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
NV_PMC_INTR_EN_0_INTA           TEXTEQU         <1:0>
;  RWI-V 
;   602 : #define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
NV_PMC_INTR_EN_0_INTA_DISABLED          EQU             000000000h
;  RW--V 
;   603 : #define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
NV_PMC_INTR_EN_0_INTA_HARDWARE          EQU             000000001h
;  RW--V 
;   604 : #define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
NV_PMC_INTR_EN_0_INTA_SOFTWARE          EQU             000000002h
;  R--4R 
;   605 : #define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
NV_PMC_INTR_READ_0              EQU             000000160h
;  R--VF 
;   606 : #define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
NV_PMC_INTR_READ_0_INTA         TEXTEQU         <0:0>
;  R---V 
;   607 : #define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
NV_PMC_INTR_READ_0_INTA_LOW             EQU             000000000h
;  R---V 
;   608 : #define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
NV_PMC_INTR_READ_0_INTA_HIGH            EQU             000000001h
;  RW-4R 
;   609 : #define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
NV_PMC_ENABLE           EQU             000000200h
;  RWIVF 
;   610 : #define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
NV_PMC_ENABLE_PAUDIO            TEXTEQU         <0:0>
;  RWI-V 
;   611 : #define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
NV_PMC_ENABLE_PAUDIO_DISABLED           EQU             000000000h
;  RW--V 
;   612 : #define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
NV_PMC_ENABLE_PAUDIO_ENABLED            EQU             000000001h
;  RWIVF 
;   613 : #define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
NV_PMC_ENABLE_PMEDIA            TEXTEQU         <4:4>
;  RWI-V 
;   614 : #define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
NV_PMC_ENABLE_PMEDIA_DISABLED           EQU             000000000h
;  RW--V 
;   615 : #define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
NV_PMC_ENABLE_PMEDIA_ENABLED            EQU             000000001h
;  RWIVF 
;   616 : #define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
NV_PMC_ENABLE_PFIFO             TEXTEQU         <8:8>
;  RWI-V 
;   617 : #define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
NV_PMC_ENABLE_PFIFO_DISABLED            EQU             000000000h
;  RW--V 
;   618 : #define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
NV_PMC_ENABLE_PFIFO_ENABLED             EQU             000000001h
;  RWIVF 
;   619 : #define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
NV_PMC_ENABLE_PGRAPH            TEXTEQU         <12:12>
;  RWI-V 
;   620 : #define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
NV_PMC_ENABLE_PGRAPH_DISABLED           EQU             000000000h
;  RW--V 
;   621 : #define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
NV_PMC_ENABLE_PGRAPH_ENABLED            EQU             000000001h
;  RWIVF 
;   622 : #define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
NV_PMC_ENABLE_PPMI              TEXTEQU         <16:16>
;  RWI-V 
;   623 : #define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
NV_PMC_ENABLE_PPMI_DISABLED             EQU             000000000h
;  RW--V 
;   624 : #define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
NV_PMC_ENABLE_PPMI_ENABLED              EQU             000000001h
;  RWIVF 
;   625 : #define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
NV_PMC_ENABLE_PFB               TEXTEQU         <20:20>
;  RW--V 
;   626 : #define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
NV_PMC_ENABLE_PFB_DISABLED              EQU             000000000h
;  RWI-V 
;   627 : #define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
NV_PMC_ENABLE_PFB_ENABLED               EQU             000000001h
;  RWIVF 
;   628 : #define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
NV_PMC_ENABLE_PCRTC             TEXTEQU         <24:24>
;  RWI-V 
;   629 : #define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RWI-V */
NV_PMC_ENABLE_PCRTC_DISABLED            EQU             000000000h
;  RW--V 
;   630 : #define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RW--V */
NV_PMC_ENABLE_PCRTC_ENABLED             EQU             000000001h
;  RWIVF 
;   631 : #define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
NV_PMC_ENABLE_PVIDEO            TEXTEQU         <28:28>
;  RWI-V 
;   632 : #define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
NV_PMC_ENABLE_PVIDEO_DISABLED           EQU             000000000h
;  RW--V 
;   633 : #define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
NV_PMC_ENABLE_PVIDEO_ENABLED            EQU             000000001h
;  dev_bus.ref 
;  RW--D 
;   634 : /* dev_bus.ref */
;   635 : #define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
NV_PBUS         TEXTEQU         <0x00001FFF:0x00001000>
;  RW-4R 
;   636 : #define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
NV_PBUS_DEBUG_0         EQU             000001080h
;  RWIVF 
;   637 : #define NV_PBUS_DEBUG_0_MODE                                    0:0 /* RWIVF */
NV_PBUS_DEBUG_0_MODE            TEXTEQU         <0:0>
;  RWI-V 
;   638 : #define NV_PBUS_DEBUG_0_MODE_DISABLED                    0x00000000 /* RWI-V */
NV_PBUS_DEBUG_0_MODE_DISABLED           EQU             000000000h
;  RW--V 
;   639 : #define NV_PBUS_DEBUG_0_MODE_ENABLED                     0x00000001 /* RW--V */
NV_PBUS_DEBUG_0_MODE_ENABLED            EQU             000000001h
;  RWIVF 
;   640 : #define NV_PBUS_DEBUG_0_DESKEWER                                4:4 /* RWIVF */
NV_PBUS_DEBUG_0_DESKEWER                TEXTEQU         <4:4>
;  RWI-V 
;   641 : #define NV_PBUS_DEBUG_0_DESKEWER_ENABLED                 0x00000000 /* RWI-V */
NV_PBUS_DEBUG_0_DESKEWER_ENABLED                EQU             000000000h
;  RW--V 
;   642 : #define NV_PBUS_DEBUG_0_DESKEWER_BYPASS                  0x00000001 /* RW--V */
NV_PBUS_DEBUG_0_DESKEWER_BYPASS         EQU             000000001h
;  RWIVF 
;   643 : #define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                        11:8 /* RWIVF */
NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY         TEXTEQU         <11:8>
;  RWI-V 
;   644 : #define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8               EQU             000000008h
;  RW-4R 
;   645 : #define NV_PBUS_DEBUG_SEL_0                              0x00001090 /* RW-4R */
NV_PBUS_DEBUG_SEL_0             EQU             000001090h
;  RWXUF 
;   646 : #define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
NV_PBUS_DEBUG_SEL_0_X           TEXTEQU         <2:0>
;  RW-4R 
;   647 : #define NV_PBUS_DEBUG_SEL_1                              0x00001094 /* RW-4R */
NV_PBUS_DEBUG_SEL_1             EQU             000001094h
;  RWXUF 
;   648 : #define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
NV_PBUS_DEBUG_SEL_1_X           TEXTEQU         <2:0>
;  RW-4R 
;   649 : #define NV_PBUS_DEBUG_SEL_2                              0x00001098 /* RW-4R */
NV_PBUS_DEBUG_SEL_2             EQU             000001098h
;  RWXUF 
;   650 : #define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
NV_PBUS_DEBUG_SEL_2_X           TEXTEQU         <2:0>
;  RW-4R 
;   651 : #define NV_PBUS_DEBUG_SEL_3                              0x0000109C /* RW-4R */
NV_PBUS_DEBUG_SEL_3             EQU             00000109ch
;  RWXUF 
;   652 : #define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
NV_PBUS_DEBUG_SEL_3_X           TEXTEQU         <2:0>
;  RW-4R 
;   653 : #define NV_PBUS_DEBUG_HOST                               0x000010A0 /* RW-4R */
NV_PBUS_DEBUG_HOST              EQU             0000010a0h
;  RWXUF 
;   654 : #define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
NV_PBUS_DEBUG_HOST_SEL          TEXTEQU         <2:0>
;  RW-4R 
;   655 : #define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
NV_PBUS_DEBUG_1         EQU             000001084h
;  RWIVF 
;   656 : #define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
NV_PBUS_DEBUG_1_PCIM_THROTTLE           TEXTEQU         <0:0>
;  RW--V 
;   657 : #define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED          EQU             000000000h
;  RWI-V 
;   658 : #define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED           EQU             000000001h
;  RWIVF 
;   659 : #define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
NV_PBUS_DEBUG_1_PCIM_CMD                TEXTEQU         <1:1>
;  RWI-V 
;   660 : #define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED             EQU             000000000h
;  RW--V 
;   661 : #define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY               EQU             000000001h
;  RWIVF 
;   662 : #define NV_PBUS_DEBUG_1_PCIM_AGP                                2:2 /* RWIVF */
NV_PBUS_DEBUG_1_PCIM_AGP                TEXTEQU         <2:2>
;  RWI-V 
;   663 : #define NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP                  0x00000000 /* RWI-V */
NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP         EQU             000000000h
;  RW--V 
;   664 : #define NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI                  0x00000001 /* RW--V */
NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI         EQU             000000001h
;  RWIVF 
;   665 : #define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
NV_PBUS_DEBUG_1_AGPM_CMD                TEXTEQU         <4:3>
;  RW--V 
;   666 : #define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST              EQU             000000000h
;  RWI-V 
;   667 : #define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                EQU             000000001h
;  RW--V 
;   668 : #define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                EQU             000000002h
;  RWIVF 
;   669 : #define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_WRITE              TEXTEQU         <5:5>
;  RW--V 
;   670 : #define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE              EQU             000000000h
;  RWI-V 
;   671 : #define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE              EQU             000000001h
;  RWIVF 
;   672 : #define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_2_1                TEXTEQU         <6:6>
;  RW--V 
;   673 : #define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED               EQU             000000000h
;  RWI-V 
;   674 : #define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                EQU             000000001h
;  RWIVF 
;   675 : #define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_RETRY              TEXTEQU         <7:7>
;  RW--V 
;   676 : #define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED             EQU             000000000h
;  RWI-V 
;   677 : #define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED              EQU             000000001h
;  RWIVF 
;   678 : #define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_RD_BURST           TEXTEQU         <8:8>
;  RWI-V 
;   679 : #define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED          EQU             000000000h
;  RW--V 
;   680 : #define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED           EQU             000000001h
;  RWIVF 
;   681 : #define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_WR_BURST           TEXTEQU         <9:9>
;  RWI-V 
;   682 : #define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED          EQU             000000000h
;  RW--V 
;   683 : #define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED           EQU             000000001h
;  RWIVF 
;   684 : #define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_EARLY_RTY          TEXTEQU         <10:10>
;  RW--V 
;   685 : #define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED         EQU             000000000h
;  RWI-V 
;   686 : #define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED          EQU             000000001h
;  RWIVF 
;   687 : #define NV_PBUS_DEBUG_1_PCIS_RMAIO                            11:11 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_RMAIO              TEXTEQU         <11:11>
;  RW--V 
;   688 : #define NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED              0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED             EQU             000000000h
;  RWI-V 
;   689 : #define NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED               0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED              EQU             000000001h
;  RWIVF 
;   690 : #define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
NV_PBUS_DEBUG_1_PCIS_CPUQ               TEXTEQU         <12:12>
;  RW--V 
;   691 : #define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED              EQU             000000000h
;  RWI-V 
;   692 : #define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED               EQU             000000001h
;  RWIVF 
;   693 : #define NV_PBUS_DEBUG_1_SPARE1                                13:13 /* RWIVF */
NV_PBUS_DEBUG_1_SPARE1          TEXTEQU         <13:13>
;  RWI-V 
;   694 : #define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
NV_PBUS_DEBUG_1_SPARE1_ZERO             EQU             000000000h
;  RW--V 
;   695 : #define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
NV_PBUS_DEBUG_1_SPARE1_ONE              EQU             000000001h
;  RWIVF 
;   696 : #define NV_PBUS_DEBUG_1_SPARE2                                14:14 /* RWIVF */
NV_PBUS_DEBUG_1_SPARE2          TEXTEQU         <14:14>
;  RWI-V 
;   697 : #define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
NV_PBUS_DEBUG_1_SPARE2_ZERO             EQU             000000000h
;  RW--V 
;   698 : #define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
NV_PBUS_DEBUG_1_SPARE2_ONE              EQU             000000001h
;  RW-4R 
;   699 : #define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
NV_PBUS_INTR_0          EQU             000001100h
;  RWXVF 
;   700 : #define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
NV_PBUS_INTR_0_PCI_BUS_ERROR            TEXTEQU         <0:0>
;  R---V 
;   701 : #define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING                EQU             000000000h
;  R---V 
;   702 : #define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING            EQU             000000001h
;  -W--V 
;   703 : #define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET              EQU             000000001h
;  RWI4R 
;   704 : #define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
NV_PBUS_INTR_EN_0               EQU             000001140h
;  RWIVF 
;   705 : #define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
NV_PBUS_INTR_EN_0_PCI_BUS_ERROR         TEXTEQU         <0:0>
;  RWI-V 
;   706 : #define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED                EQU             000000000h
;  RW--V 
;   707 : #define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED         EQU             000000001h
;  RW-4R 
;   708 : #define NV_PBUS_RMC_DMA_0                                0x00001E80 /* RW-4R */
NV_PBUS_RMC_DMA_0               EQU             000001e80h
;  RWXUF 
;   709 : #define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                TEXTEQU         <7:0>
;  RWXUF 
;   710 : #define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                TEXTEQU         <15:8>
;  RWXUF 
;   711 : #define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                TEXTEQU         <23:16>
;  RWXVF 
;   712 : #define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
NV_PBUS_RMC_DMA_0_MASK_BIT              TEXTEQU         <24:24>
;  RW--V 
;   713 : #define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                EQU             000000000h
;  RW--V 
;   714 : #define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
NV_PBUS_RMC_DMA_0_MASK_BIT_SET          EQU             000000001h
;  RWXVF 
;   715 : #define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                TEXTEQU         <25:25>
;  RW--V 
;   716 : #define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED               EQU             000000000h
;  RW--V 
;   717 : #define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED                EQU             000000001h
;  RWXVF 
;   718 : #define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
NV_PBUS_RMC_DMA_0_DIRECTION             TEXTEQU         <26:26>
;  RW--V 
;   719 : #define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT           EQU             000000000h
;  RW--V 
;   720 : #define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT           EQU             000000001h
;  RWXUF 
;   721 : #define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
NV_PBUS_RMC_DMA_0_CHANNEL               TEXTEQU         <29:28>
;  RWXVF 
;   722 : #define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
NV_PBUS_RMC_DMA_0_CONTROLLER            TEXTEQU         <30:30>
;  RW--V 
;   723 : #define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED           EQU             000000000h
;  RW--V 
;   724 : #define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED            EQU             000000001h
;  RWIVF 
;   725 : #define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
NV_PBUS_RMC_DMA_0_FLIPFLOP              TEXTEQU         <31:31>
;  RWI-V 
;   726 : #define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0               EQU             000000000h
;  RW--V 
;   727 : #define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1               EQU             000000001h
;  RW-4R 
;   728 : #define NV_PBUS_RMC_DMA_1                                0x00001E84 /* RW-4R */
NV_PBUS_RMC_DMA_1               EQU             000001e84h
;  RWXUF 
;   729 : #define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
NV_PBUS_RMC_DMA_1_COUNT_BYTE_0          TEXTEQU         <7:0>
;  RWXUF 
;   730 : #define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
NV_PBUS_RMC_DMA_1_COUNT_BYTE_1          TEXTEQU         <15:8>
;  RWXVF 
;   731 : #define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
NV_PBUS_RMC_DMA_1_STATE         TEXTEQU         <28:28>
;  RW--V 
;   732 : #define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
NV_PBUS_RMC_DMA_1_STATE_CLEAN           EQU             000000000h
;  RW--V 
;   733 : #define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
NV_PBUS_RMC_DMA_1_STATE_DIRTY           EQU             000000001h
;  R--4R 
;   734 : #define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
NV_PBUS_PCI_NV_0                EQU             000001800h
;        
;   735 : #define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
NV_PBUS_PCI_NV_0__ALIAS_1               EQU             000000000h
;  RW-4R 
;   736 : #define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
NV_PBUS_PCI_NV_1                EQU             000001804h
;        
;   737 : #define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
NV_PBUS_PCI_NV_1__ALIAS_1               EQU             000000004h
;  R--4R 
;   738 : #define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
NV_PBUS_PCI_NV_2                EQU             000001808h
;        
;   739 : #define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
NV_PBUS_PCI_NV_2__ALIAS_1               EQU             000000008h
;  RW-4R 
;   740 : #define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
NV_PBUS_PCI_NV_3                EQU             00000180ch
;        
;   741 : #define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
NV_PBUS_PCI_NV_3__ALIAS_1               EQU             00000000ch
;  RW-4R 
;   742 : #define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
NV_PBUS_PCI_NV_4                EQU             000001810h
;        
;   743 : #define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
NV_PBUS_PCI_NV_4__ALIAS_1               EQU             000000010h
;  RW-4R 
;   744 : #define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
NV_PBUS_PCI_NV_5                EQU             000001814h
;        
;   745 : #define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
NV_PBUS_PCI_NV_5__ALIAS_1               EQU             000000014h
;  RW-4R 
;   746 : #define NV_PBUS_PCI_NV_6                                 0x00001818 /* RW-4R */
NV_PBUS_PCI_NV_6                EQU             000001818h
;        
;   747 : #define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
NV_PBUS_PCI_NV_6__ALIAS_1               EQU             000000018h
;  R--4A 
;        
;   748 : #define NV_PBUS_PCI_NV_7(i)                      (0x0000181C+(i)*4) /* R--4A */
;   749 : #define NV_PBUS_PCI_NV_7__SIZE_1                                  4 /*       */
NV_PBUS_PCI_NV_7__SIZE_1                EQU             4t
;        
;   750 : #define NV_PBUS_PCI_NV_7__ALIAS_1                NV_CONFIG_PCI_NV_7 /*       */
NV_PBUS_PCI_NV_7__ALIAS_1               TEXTEQU         <NV_CONFIG_PCI_NV_7>
;  R--4R 
;   751 : #define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
NV_PBUS_PCI_NV_11               EQU             00000182ch
;        
;   752 : #define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
NV_PBUS_PCI_NV_11__ALIAS_1              EQU             00000002ch
;  RW-4R 
;   753 : #define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
NV_PBUS_PCI_NV_12               EQU             000001830h
;        
;   754 : #define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
NV_PBUS_PCI_NV_12__ALIAS_1              EQU             000000030h
;  RW-4R 
;   755 : #define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
NV_PBUS_PCI_NV_13               EQU             000001834h
;        
;   756 : #define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
NV_PBUS_PCI_NV_13__ALIAS_1              EQU             000000034h
;  R--4A 
;   757 : #define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
NV_PBUS_PCI_NV_14               EQU             000001838h
;        
;   758 : #define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
NV_PBUS_PCI_NV_14__ALIAS_1              EQU             000000038h
;  RW-4R 
;   759 : #define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
NV_PBUS_PCI_NV_15               EQU             00000183ch
;        
;   760 : #define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
NV_PBUS_PCI_NV_15__ALIAS_1              EQU             00000003ch
;  RW-4R 
;   761 : #define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
NV_PBUS_PCI_NV_16               EQU             000001840h
;        
;   762 : #define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
NV_PBUS_PCI_NV_16__ALIAS_1              EQU             000000040h
;  RW-4R 
;   763 : #define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
NV_PBUS_PCI_NV_17               EQU             000001844h
;        
;   764 : #define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
NV_PBUS_PCI_NV_17__ALIAS_1              EQU             000000044h
;  RW-4R 
;   765 : #define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
NV_PBUS_PCI_NV_18               EQU             000001848h
;        
;   766 : #define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
NV_PBUS_PCI_NV_18__ALIAS_1              EQU             000000048h
;  RW-4R 
;   767 : #define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
NV_PBUS_PCI_NV_19               EQU             00000184ch
;        
;   768 : #define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
NV_PBUS_PCI_NV_19__ALIAS_1              EQU             00000004ch
;  RW-4R 
;   769 : #define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
NV_PBUS_PCI_NV_20               EQU             000001850h
;        
;   770 : #define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
NV_PBUS_PCI_NV_20__ALIAS_1              EQU             000000050h
;  RW-4R 
;   771 : #define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
NV_PBUS_PCI_NV_21               EQU             000001854h
;        
;   772 : #define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
NV_PBUS_PCI_NV_21__ALIAS_1              EQU             000000054h
;  RW-4R 
;   773 : #define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
NV_PBUS_PCI_NV_22               EQU             000001858h
;        
;   774 : #define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
NV_PBUS_PCI_NV_22__ALIAS_1              EQU             000000058h
;  R--4A 
;        
;   775 : #define NV_PBUS_PCI_NV_23(i)                     (0x0000185C+(i)*4) /* R--4A */
;   776 : #define NV_PBUS_PCI_NV_23__SIZE_1                                41 /*       */
NV_PBUS_PCI_NV_23__SIZE_1               EQU             41t
;        
;   777 : #define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
NV_PBUS_PCI_NV_23__ALIAS_1              TEXTEQU         <NV_CONFIG_PCI_NV_23>
;  dev_fifo.ref 
;  RW--D 
;   778 : /* dev_fifo.ref */
;   779 : #define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
NV_PFIFO                TEXTEQU         <0x00003FFF:0x00002000>
;  RW-4R 
;   780 : #define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
NV_PFIFO_DELAY_0                EQU             000002040h
;  RWIUF 
;   781 : #define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
NV_PFIFO_DELAY_0_WAIT_RETRY             TEXTEQU         <7:0>
;  RWI-V 
;   782 : #define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
NV_PFIFO_DELAY_0_WAIT_RETRY_0           EQU             000000000h
;  R--4R 
;   783 : #define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
NV_PFIFO_DEBUG_0                EQU             000002080h
;  R-XVF 
;   784 : #define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
NV_PFIFO_DEBUG_0_CACHE_ERROR0           TEXTEQU         <0:0>
;  R---V 
;   785 : #define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING               EQU             000000000h
;  R---V 
;   786 : #define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING           EQU             000000001h
;  R-XVF 
;   787 : #define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
NV_PFIFO_DEBUG_0_CACHE_ERROR1           TEXTEQU         <4:4>
;  R---V 
;   788 : #define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING               EQU             000000000h
;  R---V 
;   789 : #define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING           EQU             000000001h
;  RW-4R 
;   790 : #define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
NV_PFIFO_INTR_0         EQU             000002100h
;  RWXVF 
;   791 : #define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
NV_PFIFO_INTR_0_CACHE_ERROR             TEXTEQU         <0:0>
;  R---V 
;   792 : #define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING         EQU             000000000h
;  R---V 
;   793 : #define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
NV_PFIFO_INTR_0_CACHE_ERROR_PENDING             EQU             000000001h
;  -W--V 
;   794 : #define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
NV_PFIFO_INTR_0_CACHE_ERROR_RESET               EQU             000000001h
;  RWXVF 
;   795 : #define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
NV_PFIFO_INTR_0_RUNOUT          TEXTEQU         <4:4>
;  R---V 
;   796 : #define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING              EQU             000000000h
;  R---V 
;   797 : #define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
NV_PFIFO_INTR_0_RUNOUT_PENDING          EQU             000000001h
;  -W--V 
;   798 : #define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
NV_PFIFO_INTR_0_RUNOUT_RESET            EQU             000000001h
;  RWXVF 
;   799 : #define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
NV_PFIFO_INTR_0_RUNOUT_OVERFLOW         TEXTEQU         <8:8>
;  R---V 
;   800 : #define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING             EQU             000000000h
;  R---V 
;   801 : #define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING         EQU             000000001h
;  -W--V 
;   802 : #define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET           EQU             000000001h
;  RWXVF 
;   803 : #define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
NV_PFIFO_INTR_0_DMA_PUSHER              TEXTEQU         <12:12>
;  R---V 
;   804 : #define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING          EQU             000000000h
;  R---V 
;   805 : #define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
NV_PFIFO_INTR_0_DMA_PUSHER_PENDING              EQU             000000001h
;  -W--V 
;   806 : #define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
NV_PFIFO_INTR_0_DMA_PUSHER_RESET                EQU             000000001h
;  RWXVF 
;   807 : #define NV_PFIFO_INTR_0_DMA_PTE                               16:16 /* RWXVF */
NV_PFIFO_INTR_0_DMA_PTE         TEXTEQU         <16:16>
;  R---V 
;   808 : #define NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING              0x00000000 /* R---V */
NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING             EQU             000000000h
;  R---V 
;   809 : #define NV_PFIFO_INTR_0_DMA_PTE_PENDING                  0x00000001 /* R---V */
NV_PFIFO_INTR_0_DMA_PTE_PENDING         EQU             000000001h
;  -W--V 
;   810 : #define NV_PFIFO_INTR_0_DMA_PTE_RESET                    0x00000001 /* -W--V */
NV_PFIFO_INTR_0_DMA_PTE_RESET           EQU             000000001h
;  RW-4R 
;   811 : #define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
NV_PFIFO_INTR_EN_0              EQU             000002140h
;  RWIVF 
;   812 : #define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
NV_PFIFO_INTR_EN_0_CACHE_ERROR          TEXTEQU         <0:0>
;  RWI-V 
;   813 : #define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED         EQU             000000000h
;  RW--V 
;   814 : #define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED          EQU             000000001h
;  RWIVF 
;   815 : #define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
NV_PFIFO_INTR_EN_0_RUNOUT               TEXTEQU         <4:4>
;  RWI-V 
;   816 : #define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED              EQU             000000000h
;  RW--V 
;   817 : #define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED               EQU             000000001h
;  RWIVF 
;   818 : #define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW              TEXTEQU         <8:8>
;  RWI-V 
;   819 : #define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED             EQU             000000000h
;  RW--V 
;   820 : #define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED              EQU             000000001h
;  RWIVF 
;   821 : #define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
NV_PFIFO_INTR_EN_0_DMA_PUSHER           TEXTEQU         <12:12>
;  RWI-V 
;   822 : #define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED          EQU             000000000h
;  RW--V 
;   823 : #define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED           EQU             000000001h
;  RWIVF 
;   824 : #define NV_PFIFO_INTR_EN_0_DMA_PTE                            16:16 /* RWIVF */
NV_PFIFO_INTR_EN_0_DMA_PTE              TEXTEQU         <16:16>
;  RWI-V 
;   825 : #define NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED              0x00000000 /* RWI-V */
NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED             EQU             000000000h
;  RW--V 
;   826 : #define NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED               0x00000001 /* RW--V */
NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED              EQU             000000001h
;  RW-4R 
;   827 : #define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
NV_PFIFO_CONFIG_0               EQU             000002200h
;  RWXVF 
;   828 : #define NV_PFIFO_CONFIG_0_DMA_FETCH                            10:8 /* RWXVF */
NV_PFIFO_CONFIG_0_DMA_FETCH             TEXTEQU         <10:8>
;  RW--V 
;   829 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES             0x00000000 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES            EQU             000000000h
;  RW--V 
;   830 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES             0x00000001 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES            EQU             000000001h
;  RW--V 
;   831 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES             0x00000002 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES            EQU             000000002h
;  RW--V 
;   832 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES            0x00000003 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES           EQU             000000003h
;  RW--V 
;   833 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES            0x00000004 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES           EQU             000000004h
;  RW--V 
;   834 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES            0x00000005 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES           EQU             000000005h
;  RW--V 
;   835 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES            0x00000006 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES           EQU             000000006h
;  RW--V 
;   836 : #define NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES            0x00000007 /* RW--V */
NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES           EQU             000000007h
;  RWXVF 
;   837 : #define NV_PFIFO_CONFIG_0_DMA_WATERMARK                       22:18 /* RWXVF */
NV_PFIFO_CONFIG_0_DMA_WATERMARK         TEXTEQU         <22:18>
;  RW-4R 
;   838 : #define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
NV_PFIFO_RAMHT          EQU             000002210h
;  RWXVF 
;   839 : #define NV_PFIFO_RAMHT_BASE_ADDRESS                           15:12 /* RWXVF */
NV_PFIFO_RAMHT_BASE_ADDRESS             TEXTEQU         <15:12>
;  RWI-V 
;   840 : #define NV_PFIFO_RAMHT_BASE_ADDRESS_0                    0x00000000 /* RWI-V */
NV_PFIFO_RAMHT_BASE_ADDRESS_0           EQU             000000000h
;  RWXVF 
;   841 : #define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWXVF */
NV_PFIFO_RAMHT_SIZE             TEXTEQU         <17:16>
;  RWI-V 
;   842 : #define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
NV_PFIFO_RAMHT_SIZE_4K          EQU             000000000h
;  RW--V 
;   843 : #define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
NV_PFIFO_RAMHT_SIZE_8K          EQU             000000001h
;  RW--V 
;   844 : #define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
NV_PFIFO_RAMHT_SIZE_16K         EQU             000000002h
;  RW--V 
;   845 : #define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
NV_PFIFO_RAMHT_SIZE_32K         EQU             000000003h
;  RW-4R 
;   846 : #define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
NV_PFIFO_RAMFC          EQU             000002214h
;  RWXVF 
;   847 : #define NV_PFIFO_RAMFC_BASE_ADDRESS                            15:9 /* RWXVF */
NV_PFIFO_RAMFC_BASE_ADDRESS             TEXTEQU         <15:9>
;  RWI-V 
;   848 : #define NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                 0x00001C00 /* RWI-V */
NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                EQU             000001c00h
;  RW-4R 
;   849 : #define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
NV_PFIFO_RAMRO          EQU             000002218h
;  RWXVF 
;   850 : #define NV_PFIFO_RAMRO_BASE_ADDRESS                            15:9 /* RWXVF */
NV_PFIFO_RAMRO_BASE_ADDRESS             TEXTEQU         <15:9>
;  RWI-V 
;   851 : #define NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                 0x00001E00 /* RWI-V */
NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                EQU             000001e00h
;  RWXVF 
;   852 : #define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWXVF */
NV_PFIFO_RAMRO_SIZE             TEXTEQU         <16:16>
;  RWI-V 
;   853 : #define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
NV_PFIFO_RAMRO_SIZE_512         EQU             000000000h
;  RW--V 
;   854 : #define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
NV_PFIFO_RAMRO_SIZE_8K          EQU             000000001h
;  RW-4R 
;   855 : #define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
NV_PFIFO_CACHES         EQU             000002500h
;  RWIVF 
;   856 : #define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
NV_PFIFO_CACHES_REASSIGN                TEXTEQU         <0:0>
;  RWI-V 
;   857 : #define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
NV_PFIFO_CACHES_REASSIGN_DISABLED               EQU             000000000h
;  RW--V 
;   858 : #define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
NV_PFIFO_CACHES_REASSIGN_ENABLED                EQU             000000001h
;  RW-4R 
;   859 : #define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
NV_PFIFO_CACHE0_PUSH0           EQU             000003000h
;  RWIVF 
;   860 : #define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
NV_PFIFO_CACHE0_PUSH0_ACCESS            TEXTEQU         <0:0>
;  RWI-V 
;   861 : #define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED           EQU             000000000h
;  RW--V 
;   862 : #define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED            EQU             000000001h
;  RW-4R 
;   863 : #define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
NV_PFIFO_CACHE1_PUSH0           EQU             000003200h
;  RWIVF 
;   864 : #define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
NV_PFIFO_CACHE1_PUSH0_ACCESS            TEXTEQU         <0:0>
;  RWI-V 
;   865 : #define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED           EQU             000000000h
;  RW--V 
;   866 : #define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED            EQU             000000001h
;  RW-4R 
;   867 : #define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
NV_PFIFO_CACHE0_PUSH1           EQU             000003004h
;  RWXUF 
;   868 : #define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */
NV_PFIFO_CACHE0_PUSH1_CHID              TEXTEQU         <6:0>
;  RW-4R 
;   869 : #define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
NV_PFIFO_CACHE1_PUSH1           EQU             000003204h
;  RWXUF 
;   870 : #define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
NV_PFIFO_CACHE1_PUSH1_CHID              TEXTEQU         <6:0>
;  RW-4R 
;   871 : #define NV_PFIFO_CACHE1_DMA0                             0x00003220 /* RW-4R */
NV_PFIFO_CACHE1_DMA0            EQU             000003220h
;  RWIVF 
;   872 : #define NV_PFIFO_CACHE1_DMA0_ACCESS                             0:0 /* RWIVF */
NV_PFIFO_CACHE1_DMA0_ACCESS             TEXTEQU         <0:0>
;  RWI-V 
;   873 : #define NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED             0x00000000 /* RWI-V */
NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED            EQU             000000000h
;  RW--V 
;   874 : #define NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED              0x00000001 /* RW--V */
NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED             EQU             000000001h
;  R-IVF 
;   875 : #define NV_PFIFO_CACHE1_DMA0_STATE                              4:4 /* R-IVF */
NV_PFIFO_CACHE1_DMA0_STATE              TEXTEQU         <4:4>
;  R-I-V 
;   876 : #define NV_PFIFO_CACHE1_DMA0_STATE_IDLE                  0x00000000 /* R-I-V */
NV_PFIFO_CACHE1_DMA0_STATE_IDLE         EQU             000000000h
;  R---V 
;   877 : #define NV_PFIFO_CACHE1_DMA0_STATE_BUSY                  0x00000001 /* R---V */
NV_PFIFO_CACHE1_DMA0_STATE_BUSY         EQU             000000001h
;  RW-4R 
;   878 : #define NV_PFIFO_CACHE1_DMA1                             0x00003224 /* RW-4R */
NV_PFIFO_CACHE1_DMA1            EQU             000003224h
;  RWXUF 
;   879 : #define NV_PFIFO_CACHE1_DMA1_LENGTH                            23:2 /* RWXUF */
NV_PFIFO_CACHE1_DMA1_LENGTH             TEXTEQU         <23:2>
;  RW-4R 
;   880 : #define NV_PFIFO_CACHE1_DMA2                             0x00003228 /* RW-4R */
NV_PFIFO_CACHE1_DMA2            EQU             000003228h
;  RWXUF 
;   881 : #define NV_PFIFO_CACHE1_DMA2_ADDRESS                           23:2 /* RWXUF */
NV_PFIFO_CACHE1_DMA2_ADDRESS            TEXTEQU         <23:2>
;  RW-4R 
;   882 : #define NV_PFIFO_CACHE1_DMA3                             0x0000322C /* RW-4R */
NV_PFIFO_CACHE1_DMA3            EQU             00000322ch
;  RWXUF 
;   883 : #define NV_PFIFO_CACHE1_DMA3_TARGET_NODE                        1:0 /* RWXUF */
NV_PFIFO_CACHE1_DMA3_TARGET_NODE                TEXTEQU         <1:0>
;  RW--V 
;   884 : #define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI             0x00000002 /* RW--V */
NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI            EQU             000000002h
;  RW--V 
;   885 : #define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP             0x00000003 /* RW--V */
NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP            EQU             000000003h
;  RW-4R 
;   886 : #define NV_PFIFO_CACHE1_DMA_STATUS                       0x00003218 /* RW-4R */
NV_PFIFO_CACHE1_DMA_STATUS              EQU             000003218h
;  RWXUF 
;   887 : #define NV_PFIFO_CACHE1_DMA_STATUS_METHOD                      12:2 /* RWXUF */
NV_PFIFO_CACHE1_DMA_STATUS_METHOD               TEXTEQU         <12:2>
;  RWXUF 
;   888 : #define NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL                 15:13 /* RWXUF */
NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL           TEXTEQU         <15:13>
;  RWXUF 
;   889 : #define NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT               28:18 /* RWXUF */
NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT         TEXTEQU         <28:18>
;  RWXUF 
;   890 : #define NV_PFIFO_CACHE1_DMA_STATUS_REASON                     30:30 /* RWXUF */
NV_PFIFO_CACHE1_DMA_STATUS_REASON               TEXTEQU         <30:30>
;  RW--V 
;   891 : #define NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE           0x00000000 /* RW--V */
NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE          EQU             000000000h
;  RW--V 
;   892 : #define NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE      0x00000001 /* RW--V */
NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE             EQU             000000001h
;  RW-4R 
;   893 : #define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003230 /* RW-4R */
NV_PFIFO_CACHE1_DMA_TLB_TAG             EQU             000003230h
;  RWXUF 
;   894 : #define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   23:12 /* RWXUF */
NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS             TEXTEQU         <23:12>
;  RW-4R 
;   895 : #define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x00003234 /* RW-4R */
NV_PFIFO_CACHE1_DMA_TLB_PTE             EQU             000003234h
;  RWXVF 
;   896 : #define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                        0:0 /* RWXVF */
NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                TEXTEQU         <0:0>
;  RW--V 
;   897 : #define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT     0x00000000 /* RW--V */
NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT            EQU             000000000h
;  RW--V 
;   898 : #define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT         0x00000001 /* RW--V */
NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT                EQU             000000001h
;  RWXUF 
;   899 : #define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS               TEXTEQU         <31:12>
;  RW-4R 
;   900 : #define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE                  0x00003238 /* RW-4R */
NV_PFIFO_CACHE1_DMA_TLB_PT_BASE         EQU             000003238h
;  RWXUF 
;   901 : #define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS                19:2 /* RWXUF */
NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS         TEXTEQU         <19:2>
;  RW-4R 
;   902 : #define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
NV_PFIFO_CACHE0_PULL0           EQU             000003040h
;  RWIVF 
;   903 : #define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
NV_PFIFO_CACHE0_PULL0_ACCESS            TEXTEQU         <0:0>
;  RWI-V 
;   904 : #define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED           EQU             000000000h
;  RW--V 
;   905 : #define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED            EQU             000000001h
;  R-XVF 
;   906 : #define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
NV_PFIFO_CACHE0_PULL0_HASH              TEXTEQU         <4:4>
;  R---V 
;   907 : #define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED            EQU             000000000h
;  R---V 
;   908 : #define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
NV_PFIFO_CACHE0_PULL0_HASH_FAILED               EQU             000000001h
;  R-XVF 
;   909 : #define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
NV_PFIFO_CACHE0_PULL0_DEVICE            TEXTEQU         <8:8>
;  R---V 
;   910 : #define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE           EQU             000000000h
;  R---V 
;   911 : #define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE           EQU             000000001h
;  RW-4R 
;   912 : #define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* RW-4R */
NV_PFIFO_CACHE1_PULL0           EQU             000003240h
;  RWIVF 
;   913 : #define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
NV_PFIFO_CACHE1_PULL0_ACCESS            TEXTEQU         <0:0>
;  RWI-V 
;   914 : #define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED           EQU             000000000h
;  RW--V 
;   915 : #define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED            EQU             000000001h
;  R-XVF 
;   916 : #define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
NV_PFIFO_CACHE1_PULL0_HASH              TEXTEQU         <4:4>
;  R---V 
;   917 : #define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED            EQU             000000000h
;  R---V 
;   918 : #define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
NV_PFIFO_CACHE1_PULL0_HASH_FAILED               EQU             000000001h
;  R-XVF 
;   919 : #define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
NV_PFIFO_CACHE1_PULL0_DEVICE            TEXTEQU         <8:8>
;  R---V 
;   920 : #define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE           EQU             000000000h
;  R---V 
;   921 : #define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE           EQU             000000001h
;  RW-4R 
;   922 : #define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
NV_PFIFO_CACHE1_PULL1           EQU             000003250h
;  RWXVF 
;   923 : #define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
NV_PFIFO_CACHE1_PULL1_CTX               TEXTEQU         <4:4>
;  RW--V 
;   924 : #define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
NV_PFIFO_CACHE1_PULL1_CTX_CLEAN         EQU             000000000h
;  RW--V 
;   925 : #define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
NV_PFIFO_CACHE1_PULL1_CTX_DIRTY         EQU             000000001h
;  R--4R 
;   926 : #define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
NV_PFIFO_CACHE0_STATUS          EQU             000003014h
;  R--VF 
;   927 : #define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
NV_PFIFO_CACHE0_STATUS_LOW_MARK         TEXTEQU         <4:4>
;  R---V 
;   928 : #define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY               EQU             000000000h
;  R---V 
;   929 : #define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY           EQU             000000001h
;  R--VF 
;   930 : #define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
NV_PFIFO_CACHE0_STATUS_HIGH_MARK                TEXTEQU         <8:8>
;  R---V 
;   931 : #define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL               EQU             000000000h
;  R---V 
;   932 : #define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL           EQU             000000001h
;  R--4R 
;   933 : #define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
NV_PFIFO_CACHE1_STATUS          EQU             000003214h
;  R-XVF 
;   934 : #define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
NV_PFIFO_CACHE1_STATUS_RANOUT           TEXTEQU         <0:0>
;  R---V 
;   935 : #define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE             EQU             000000000h
;  R---V 
;   936 : #define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE              EQU             000000001h
;  R--VF 
;   937 : #define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
NV_PFIFO_CACHE1_STATUS_LOW_MARK         TEXTEQU         <4:4>
;  R---V 
;   938 : #define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY               EQU             000000000h
;  R---V 
;   939 : #define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY           EQU             000000001h
;  R--VF 
;   940 : #define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
NV_PFIFO_CACHE1_STATUS_HIGH_MARK                TEXTEQU         <8:8>
;  R---V 
;   941 : #define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL               EQU             000000000h
;  R---V 
;   942 : #define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL           EQU             000000001h
;  RW-4R 
;   943 : #define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
NV_PFIFO_CACHE0_PUT             EQU             000003010h
;  RWXUF 
;   944 : #define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
NV_PFIFO_CACHE0_PUT_ADDRESS             TEXTEQU         <2:2>
;  RW-4R 
;   945 : #define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
NV_PFIFO_CACHE1_PUT             EQU             000003210h
;  RWXUF 
;   946 : #define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
NV_PFIFO_CACHE1_PUT_ADDRESS             TEXTEQU         <6:2>
;  RW-4R 
;   947 : #define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
NV_PFIFO_CACHE0_GET             EQU             000003070h
;  RWXUF 
;   948 : #define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
NV_PFIFO_CACHE0_GET_ADDRESS             TEXTEQU         <2:2>
;  RW-4R 
;   949 : #define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
NV_PFIFO_CACHE1_GET             EQU             000003270h
;  RWXUF 
;   950 : #define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
NV_PFIFO_CACHE1_GET_ADDRESS             TEXTEQU         <6:2>
;  RW-4A 
;        
;   951 : #define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
;   952 : #define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
NV_PFIFO_CACHE0_CTX__SIZE_1             EQU             1t
;  RWXUF 
;   953 : #define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
NV_PFIFO_CACHE0_CTX_INSTANCE            TEXTEQU         <15:0>
;  RWXUF 
;   954 : #define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
NV_PFIFO_CACHE0_CTX_DEVICE              TEXTEQU         <22:16>
;  RWXVF 
;   955 : #define NV_PFIFO_CACHE0_CTX_ENGINE                            23:23 /* RWXVF */
NV_PFIFO_CACHE0_CTX_ENGINE              TEXTEQU         <23:23>
;  RW--V 
;   956 : #define NV_PFIFO_CACHE0_CTX_ENGINE_SW                    0x00000000 /* RW--V */
NV_PFIFO_CACHE0_CTX_ENGINE_SW           EQU             000000000h
;  RW--V 
;   957 : #define NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS             EQU             000000001h
;  RW-4A 
;        
;   958 : #define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
;   959 : #define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
NV_PFIFO_CACHE1_CTX__SIZE_1             EQU             8t
;  RWXUF 
;   960 : #define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
NV_PFIFO_CACHE1_CTX_INSTANCE            TEXTEQU         <15:0>
;  RWXUF 
;   961 : #define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
NV_PFIFO_CACHE1_CTX_DEVICE              TEXTEQU         <22:16>
;  RWXVF 
;   962 : #define NV_PFIFO_CACHE1_CTX_ENGINE                            23:23 /* RWXVF */
NV_PFIFO_CACHE1_CTX_ENGINE              TEXTEQU         <23:23>
;  RW--V 
;   963 : #define NV_PFIFO_CACHE1_CTX_ENGINE_SW                    0x00000000 /* RW--V */
NV_PFIFO_CACHE1_CTX_ENGINE_SW           EQU             000000000h
;  RW--V 
;   964 : #define NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS             EQU             000000001h
;  RW-4A 
;        
;   965 : #define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
;   966 : #define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
NV_PFIFO_CACHE0_METHOD__SIZE_1          EQU             1t
;  RWXUF 
;   967 : #define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
NV_PFIFO_CACHE0_METHOD_ADDRESS          TEXTEQU         <12:2>
;  RWXUF 
;   968 : #define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
NV_PFIFO_CACHE0_METHOD_SUBCHANNEL               TEXTEQU         <15:13>
;  RW-4A 
;        
;   969 : #define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
;   970 : #define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
NV_PFIFO_CACHE1_METHOD__SIZE_1          EQU             32t
;  RWXUF 
;   971 : #define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
NV_PFIFO_CACHE1_METHOD_ADDRESS          TEXTEQU         <12:2>
;  RWXUF 
;   972 : #define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
NV_PFIFO_CACHE1_METHOD_SUBCHANNEL               TEXTEQU         <15:13>
;  RW-4A 
;        
;   973 : #define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
;   974 : #define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
NV_PFIFO_CACHE0_DATA__SIZE_1            EQU             1t
;  RWXVF 
;   975 : #define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
NV_PFIFO_CACHE0_DATA_VALUE              TEXTEQU         <31:0>
;  RW-4A 
;        
;   976 : #define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
;   977 : #define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
NV_PFIFO_CACHE1_DATA__SIZE_1            EQU             32t
;  RWXVF 
;   978 : #define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
NV_PFIFO_CACHE1_DATA_VALUE              TEXTEQU         <31:0>
;  R--4A 
;        
;   979 : #define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
;   980 : #define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
NV_PFIFO_DEVICE__SIZE_1         EQU             128t
;  R--UF 
;   981 : #define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
NV_PFIFO_DEVICE_CHID            TEXTEQU         <6:0>
;  R--VF 
;   982 : #define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
NV_PFIFO_DEVICE_SWITCH          TEXTEQU         <24:24>
;  R---V 
;   983 : #define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE              EQU             000000000h
;  R---V 
;   984 : #define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
NV_PFIFO_DEVICE_SWITCH_AVAILABLE                EQU             000000001h
;  R--4R 
;   985 : #define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
NV_PFIFO_RUNOUT_STATUS          EQU             000002400h
;  R--VF 
;   986 : #define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
NV_PFIFO_RUNOUT_STATUS_RANOUT           TEXTEQU         <0:0>
;  R---V 
;   987 : #define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE             EQU             000000000h
;  R---V 
;   988 : #define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE              EQU             000000001h
;  R--VF 
;   989 : #define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
NV_PFIFO_RUNOUT_STATUS_LOW_MARK         TEXTEQU         <4:4>
;  R---V 
;   990 : #define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY               EQU             000000000h
;  R---V 
;   991 : #define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY           EQU             000000001h
;  R--VF 
;   992 : #define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                TEXTEQU         <8:8>
;  R---V 
;   993 : #define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL               EQU             000000000h
;  R---V 
;   994 : #define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL           EQU             000000001h
;  RW-4R 
;   995 : #define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
NV_PFIFO_RUNOUT_PUT             EQU             000002410h
;  RWXUF 
;   996 : #define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
NV_PFIFO_RUNOUT_PUT_ADDRESS             TEXTEQU         <12:3>
;        
;   997 : #define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /*       */
NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0             TEXTEQU         <8:3>
;        
;   998 : #define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /*       */
NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1             TEXTEQU         <12:3>
;  RW-4R 
;   999 : #define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
NV_PFIFO_RUNOUT_GET             EQU             000002420h
;  RWXUF 
;  1000 : #define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
NV_PFIFO_RUNOUT_GET_ADDRESS             TEXTEQU         <13:3>
;  dev_audio.ref 
;  RW--D 
;  1001 : /* dev_audio.ref */
;  1002 : #define NV_PAUDIO                             0x00300FFF:0x00300000 /* RW--D */
NV_PAUDIO               TEXTEQU         <0x00300FFF:0x00300000>
;  RW-4R 
;  1003 : #define NV_PAUDIO_PINS                                   0x00300000 /* RW-4R */
NV_PAUDIO_PINS          EQU             000300000h
;  RWIVF 
;  1004 : #define NV_PAUDIO_PINS_SI_DELAY                                 0:0 /* RWIVF */
NV_PAUDIO_PINS_SI_DELAY         TEXTEQU         <0:0>
;  RWI-V 
;  1005 : #define NV_PAUDIO_PINS_SI_DELAY_NORMAL                   0x00000000 /* RWI-V */
NV_PAUDIO_PINS_SI_DELAY_NORMAL          EQU             000000000h
;  RW--V 
;  1006 : #define NV_PAUDIO_PINS_SI_DELAY_I2S                      0x00000001 /* RW--V */
NV_PAUDIO_PINS_SI_DELAY_I2S             EQU             000000001h
;  RWIVF 
;  1007 : #define NV_PAUDIO_PINS_SI_EDGE                                  1:1 /* RWIVF */
NV_PAUDIO_PINS_SI_EDGE          TEXTEQU         <1:1>
;  RWI-V 
;  1008 : #define NV_PAUDIO_PINS_SI_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
NV_PAUDIO_PINS_SI_EDGE_NEGATIVE         EQU             000000000h
;  RW--V 
;  1009 : #define NV_PAUDIO_PINS_SI_EDGE_POSITIVE                  0x00000001 /* RW--V */
NV_PAUDIO_PINS_SI_EDGE_POSITIVE         EQU             000000001h
;  RWIVF 
;  1010 : #define NV_PAUDIO_PINS_SO_DELAY                                 4:4 /* RWIVF */
NV_PAUDIO_PINS_SO_DELAY         TEXTEQU         <4:4>
;  RWI-V 
;  1011 : #define NV_PAUDIO_PINS_SO_DELAY_NORMAL                   0x00000000 /* RWI-V */
NV_PAUDIO_PINS_SO_DELAY_NORMAL          EQU             000000000h
;  RW--V 
;  1012 : #define NV_PAUDIO_PINS_SO_DELAY_I2S                      0x00000001 /* RW--V */
NV_PAUDIO_PINS_SO_DELAY_I2S             EQU             000000001h
;  RWIVF 
;  1013 : #define NV_PAUDIO_PINS_SO_EDGE                                  5:5 /* RWIVF */
NV_PAUDIO_PINS_SO_EDGE          TEXTEQU         <5:5>
;  RWI-V 
;  1014 : #define NV_PAUDIO_PINS_SO_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
NV_PAUDIO_PINS_SO_EDGE_NEGATIVE         EQU             000000000h
;  RW--V 
;  1015 : #define NV_PAUDIO_PINS_SO_EDGE_POSITIVE                  0x00000001 /* RW--V */
NV_PAUDIO_PINS_SO_EDGE_POSITIVE         EQU             000000001h
;  RWIVF 
;  1016 : #define NV_PAUDIO_PINS_FMT_AC97                                 8:8 /* RWIVF */
NV_PAUDIO_PINS_FMT_AC97         TEXTEQU         <8:8>
;  RWIVF 
;  1017 : #define NV_PAUDIO_PINS_SERIAL                                   9:9 /* RWIVF */
NV_PAUDIO_PINS_SERIAL           TEXTEQU         <9:9>
;  RWI-V 
;  1018 : #define NV_PAUDIO_PINS_SERIAL_DISABLED                   0x00000000 /* RWI-V */
NV_PAUDIO_PINS_SERIAL_DISABLED          EQU             000000000h
;  RW--V 
;  1019 : #define NV_PAUDIO_PINS_SERIAL_ENABLED                    0x00000001 /* RW--V */
NV_PAUDIO_PINS_SERIAL_ENABLED           EQU             000000001h
;  RWIVF 
;  1020 : #define NV_PAUDIO_PINS_LEFT_JUST                              10:10 /* RWIVF */
NV_PAUDIO_PINS_LEFT_JUST                TEXTEQU         <10:10>
;  RWIVF 
;  1021 : #define NV_PAUDIO_PINS_LEFT_SENSE                             11:11 /* RWIVF */
NV_PAUDIO_PINS_LEFT_SENSE               TEXTEQU         <11:11>
;  RWI-V 
;  1022 : #define NV_PAUDIO_PINS_LEFT_LOW                          0x00000000 /* RWI-V */
NV_PAUDIO_PINS_LEFT_LOW         EQU             000000000h
;  RW--V 
;  1023 : #define NV_PAUDIO_PINS_LEFT_HIGH                         0x00000001 /* RW--V */
NV_PAUDIO_PINS_LEFT_HIGH                EQU             000000001h
;  RWIVF 
;  1024 : #define NV_PAUDIO_PINS_CONTROL                                14:12 /* RWIVF */
NV_PAUDIO_PINS_CONTROL          TEXTEQU         <14:12>
;  RWI-V 
;  1025 : #define NV_PAUDIO_PINS_CONTROL_0                         0x00000000 /* RWI-V */
NV_PAUDIO_PINS_CONTROL_0                EQU             000000000h
;  RW--V 
;  1026 : #define NV_PAUDIO_PINS_CONTROL_1                         0x00000001 /* RW--V */
NV_PAUDIO_PINS_CONTROL_1                EQU             000000001h
;  RW--V 
;  1027 : #define NV_PAUDIO_PINS_CONTROL_2                         0x00000002 /* RW--V */
NV_PAUDIO_PINS_CONTROL_2                EQU             000000002h
;  RW--V 
;  1028 : #define NV_PAUDIO_PINS_CONTROL_3                         0x00000003 /* RW--V */
NV_PAUDIO_PINS_CONTROL_3                EQU             000000003h
;  RW--V 
;  1029 : #define NV_PAUDIO_PINS_CONTROL_4                         0x00000004 /* RW--V */
NV_PAUDIO_PINS_CONTROL_4                EQU             000000004h
;  RW--V 
;  1030 : #define NV_PAUDIO_PINS_CONTROL_5                         0x00000005 /* RW--V */
NV_PAUDIO_PINS_CONTROL_5                EQU             000000005h
;  RW--V 
;  1031 : #define NV_PAUDIO_PINS_CONTROL_6                         0x00000006 /* RW--V */
NV_PAUDIO_PINS_CONTROL_6                EQU             000000006h
;  RW--V 
;  1032 : #define NV_PAUDIO_PINS_CONTROL_7                         0x00000007 /* RW--V */
NV_PAUDIO_PINS_CONTROL_7                EQU             000000007h
;  RW-4R 
;  1033 : #define NV_PAUDIO_GREEN_0                                0x003000C0 /* RW-4R */
NV_PAUDIO_GREEN_0               EQU             0003000c0h
;  RWIVF 
;  1034 : #define NV_PAUDIO_GREEN_0_CODEC                                 0:0 /* RWIVF */
NV_PAUDIO_GREEN_0_CODEC         TEXTEQU         <0:0>
;  RWI-V 
;  1035 : #define NV_PAUDIO_GREEN_0_CODEC_DISABLED                 0x00000000 /* RWI-V */
NV_PAUDIO_GREEN_0_CODEC_DISABLED                EQU             000000000h
;  RW--V 
;  1036 : #define NV_PAUDIO_GREEN_0_CODEC_ENABLED                  0x00000001 /* RW--V */
NV_PAUDIO_GREEN_0_CODEC_ENABLED         EQU             000000001h
;  RWIVF 
;  1037 : #define NV_PAUDIO_GREEN_0_AUDIO                                 4:4 /* RWIVF */
NV_PAUDIO_GREEN_0_AUDIO         TEXTEQU         <4:4>
;  RWI-V 
;  1038 : #define NV_PAUDIO_GREEN_0_AUDIO_DISABLED                 0x00000000 /* RWI-V */
NV_PAUDIO_GREEN_0_AUDIO_DISABLED                EQU             000000000h
;  RW--V 
;  1039 : #define NV_PAUDIO_GREEN_0_AUDIO_ENABLED                  0x00000001 /* RW--V */
NV_PAUDIO_GREEN_0_AUDIO_ENABLED         EQU             000000001h
;  RWIVF 
;  1040 : #define NV_PAUDIO_GREEN_0_APUMP                                 8:8 /* RWIVF */
NV_PAUDIO_GREEN_0_APUMP         TEXTEQU         <8:8>
;  RWI-V 
;  1041 : #define NV_PAUDIO_GREEN_0_APUMP_DISABLED                 0x00000000 /* RWI-V */
NV_PAUDIO_GREEN_0_APUMP_DISABLED                EQU             000000000h
;  RW--V 
;  1042 : #define NV_PAUDIO_GREEN_0_APUMP_ENABLED                  0x00000001 /* RW--V */
NV_PAUDIO_GREEN_0_APUMP_ENABLED         EQU             000000001h
;  RWIVF 
;  1043 : #define NV_PAUDIO_GREEN_0_CODEC_WARM                            8:8 /* RWIVF */
NV_PAUDIO_GREEN_0_CODEC_WARM            TEXTEQU         <8:8>
;  RWI-V 
;  1044 : #define NV_PAUDIO_GREEN_0_CODEC_WARM_END                 0x00000000 /* RWI-V */
NV_PAUDIO_GREEN_0_CODEC_WARM_END                EQU             000000000h
;  RW--V 
;  1045 : #define NV_PAUDIO_GREEN_0_APUMP_WARM_UP                  0x00000001 /* RW--V */
NV_PAUDIO_GREEN_0_APUMP_WARM_UP         EQU             000000001h
;  RW-4R 
;  1046 : #define NV_PAUDIO_INTR_0                                 0x00300100 /* RW-4R */
NV_PAUDIO_INTR_0                EQU             000300100h
;  RWIVF 
;  1047 : #define NV_PAUDIO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
NV_PAUDIO_INTR_0_NOTIFY         TEXTEQU         <0:0>
;  R-I-V 
;  1048 : #define NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING             EQU             000000000h
;  R---V 
;  1049 : #define NV_PAUDIO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
NV_PAUDIO_INTR_0_NOTIFY_PENDING         EQU             000000001h
;  -W--V 
;  1050 : #define NV_PAUDIO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
NV_PAUDIO_INTR_0_NOTIFY_RESET           EQU             000000001h
;  RWIVF 
;  1051 : #define NV_PAUDIO_INTR_0_OVERFLOW                               4:4 /* RWIVF */
NV_PAUDIO_INTR_0_OVERFLOW               TEXTEQU         <4:4>
;  R-I-V 
;  1052 : #define NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING            0x00000000 /* R-I-V */
NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING           EQU             000000000h
;  R---V 
;  1053 : #define NV_PAUDIO_INTR_0_OVERFLOW_PENDING                0x00000001 /* R---V */
NV_PAUDIO_INTR_0_OVERFLOW_PENDING               EQU             000000001h
;  -W--V 
;  1054 : #define NV_PAUDIO_INTR_0_OVERFLOW_RESET                  0x00000001 /* -W--V */
NV_PAUDIO_INTR_0_OVERFLOW_RESET         EQU             000000001h
;  RWIVF 
;  1055 : #define NV_PAUDIO_INTR_0_AN_OVFL                                8:8 /* RWIVF */
NV_PAUDIO_INTR_0_AN_OVFL                TEXTEQU         <8:8>
;  R-I-V 
;  1056 : #define NV_PAUDIO_INTR_0_AN_OVFL_NOT_PENDING             0x00000000 /* R-I-V */
NV_PAUDIO_INTR_0_AN_OVFL_NOT_PENDING            EQU             000000000h
;  R---V 
;  1057 : #define NV_PAUDIO_INTR_0_AN_OVFL_PENDING                 0x00000001 /* R---V */
NV_PAUDIO_INTR_0_AN_OVFL_PENDING                EQU             000000001h
;  -W--V 
;  1058 : #define NV_PAUDIO_INTR_0_AN_OVFL_RESET                   0x00000001 /* -W--V */
NV_PAUDIO_INTR_0_AN_OVFL_RESET          EQU             000000001h
;  RWIVF 
;  1059 : #define NV_PAUDIO_INTR_0_AN_UNFL                              12:12 /* RWIVF */
NV_PAUDIO_INTR_0_AN_UNFL                TEXTEQU         <12:12>
;  R-I-V 
;  1060 : #define NV_PAUDIO_INTR_0_AN_UNFL_NOT_PENDING             0x00000000 /* R-I-V */
NV_PAUDIO_INTR_0_AN_UNFL_NOT_PENDING            EQU             000000000h
;  R---V 
;  1061 : #define NV_PAUDIO_INTR_0_AN_UNFL_PENDING                 0x00000001 /* R---V */
NV_PAUDIO_INTR_0_AN_UNFL_PENDING                EQU             000000001h
;  -W--V 
;  1062 : #define NV_PAUDIO_INTR_0_AN_UNFL_RESET                   0x00000001 /* -W--V */
NV_PAUDIO_INTR_0_AN_UNFL_RESET          EQU             000000001h
;  RW-4R 
;  1063 : #define NV_PAUDIO_INTR_1                                 0x00300104 /* RW-4R */
NV_PAUDIO_INTR_1                EQU             000300104h
;  RWIVF 
;  1064 : #define NV_PAUDIO_INTR_1_SYNC                                   0:0 /* RWIVF */
NV_PAUDIO_INTR_1_SYNC           TEXTEQU         <0:0>
;  R-I-V 
;  1065 : #define NV_PAUDIO_INTR_1_SYNC_NOT_PENDING                0x00000000 /* R-I-V */
NV_PAUDIO_INTR_1_SYNC_NOT_PENDING               EQU             000000000h
;  R---V 
;  1066 : #define NV_PAUDIO_INTR_1_SYNC_PENDING                    0x00000001 /* R---V */
NV_PAUDIO_INTR_1_SYNC_PENDING           EQU             000000001h
;  -W--V 
;  1067 : #define NV_PAUDIO_INTR_1_SYNC_RESET                      0x00000001 /* -W--V */
NV_PAUDIO_INTR_1_SYNC_RESET             EQU             000000001h
;  RWIVF 
;  1068 : #define NV_PAUDIO_INTR_1_IDLE                                   4:4 /* RWIVF */
NV_PAUDIO_INTR_1_IDLE           TEXTEQU         <4:4>
;  R-I-V 
;  1069 : #define NV_PAUDIO_INTR_1_IDLE_NOT_PENDING                0x00000000 /* R-I-V */
NV_PAUDIO_INTR_1_IDLE_NOT_PENDING               EQU             000000000h
;  R---V 
;  1070 : #define NV_PAUDIO_INTR_1_IDLE_PENDING                    0x00000001 /* R---V */
NV_PAUDIO_INTR_1_IDLE_PENDING           EQU             000000001h
;  -W--V 
;  1071 : #define NV_PAUDIO_INTR_1_IDLE_RESET                      0x00000001 /* -W--V */
NV_PAUDIO_INTR_1_IDLE_RESET             EQU             000000001h
;  RWIVF 
;  1072 : #define NV_PAUDIO_INTR_1_NEAR_BUSY                              8:8 /* RWIVF */
NV_PAUDIO_INTR_1_NEAR_BUSY              TEXTEQU         <8:8>
;  R-I-V 
;  1073 : #define NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING           0x00000000 /* R-I-V */
NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING          EQU             000000000h
;  R---V 
;  1074 : #define NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING               0x00000001 /* R---V */
NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING              EQU             000000001h
;  -W--V 
;  1075 : #define NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                 0x00000001 /* -W--V */
NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                EQU             000000001h
;  RWIVF 
;  1076 : #define NV_PAUDIO_INTR_1_TOO_BUSY                             12:12 /* RWIVF */
NV_PAUDIO_INTR_1_TOO_BUSY               TEXTEQU         <12:12>
;  R-I-V 
;  1077 : #define NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING            0x00000000 /* R-I-V */
NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING           EQU             000000000h
;  R---V 
;  1078 : #define NV_PAUDIO_INTR_1_TOO_BUSY_PENDING                0x00000001 /* R---V */
NV_PAUDIO_INTR_1_TOO_BUSY_PENDING               EQU             000000001h
;  -W--V 
;  1079 : #define NV_PAUDIO_INTR_1_TOO_BUSY_RESET                  0x00000001 /* -W--V */
NV_PAUDIO_INTR_1_TOO_BUSY_RESET         EQU             000000001h
;  RW-4R 
;  1080 : #define NV_PAUDIO_INTR_2                                 0x00300108 /* RW-4R */
NV_PAUDIO_INTR_2                EQU             000300108h
;  RWIVF 
;  1081 : #define NV_PAUDIO_INTR_2_DMA_INSTANCE                           0:0 /* RWIVF */
NV_PAUDIO_INTR_2_DMA_INSTANCE           TEXTEQU         <0:0>
;  R-I-V 
;  1082 : #define NV_PAUDIO_INTR_2_DMA_INSTANCE_NOT_PENDING        0x00000000 /* R-I-V */
NV_PAUDIO_INTR_2_DMA_INSTANCE_NOT_PENDING               EQU             000000000h
;  R---V 
;  1083 : #define NV_PAUDIO_INTR_2_DMA_INSTANCE_PENDING            0x00000001 /* R---V */
NV_PAUDIO_INTR_2_DMA_INSTANCE_PENDING           EQU             000000001h
;  -W--V 
;  1084 : #define NV_PAUDIO_INTR_2_DMA_INSTANCE_RESET              0x00000001 /* -W--V */
NV_PAUDIO_INTR_2_DMA_INSTANCE_RESET             EQU             000000001h
;  RWIVF 
;  1085 : #define NV_PAUDIO_INTR_2_DMA_PRESENT                            4:4 /* RWIVF */
NV_PAUDIO_INTR_2_DMA_PRESENT            TEXTEQU         <4:4>
;  R-I-V 
;  1086 : #define NV_PAUDIO_INTR_2_DMA_PRESENT_NOT_PENDING         0x00000000 /* R-I-V */
NV_PAUDIO_INTR_2_DMA_PRESENT_NOT_PENDING                EQU             000000000h
;  R---V 
;  1087 : #define NV_PAUDIO_INTR_2_DMA_PRESENT_PENDING             0x00000001 /* R---V */
NV_PAUDIO_INTR_2_DMA_PRESENT_PENDING            EQU             000000001h
;  -W--V 
;  1088 : #define NV_PAUDIO_INTR_2_DMA_PRESENT_RESET               0x00000001 /* -W--V */
NV_PAUDIO_INTR_2_DMA_PRESENT_RESET              EQU             000000001h
;  RWIVF 
;  1089 : #define NV_PAUDIO_INTR_2_DMA_PROTECT                            8:8 /* RWIVF */
NV_PAUDIO_INTR_2_DMA_PROTECT            TEXTEQU         <8:8>
;  R-I-V 
;  1090 : #define NV_PAUDIO_INTR_2_DMA_PROTECT_NOT_PENDING         0x00000000 /* R-I-V */
NV_PAUDIO_INTR_2_DMA_PROTECT_NOT_PENDING                EQU             000000000h
;  R---V 
;  1091 : #define NV_PAUDIO_INTR_2_DMA_PROTECT_PENDING             0x00000001 /* R---V */
NV_PAUDIO_INTR_2_DMA_PROTECT_PENDING            EQU             000000001h
;  -W--V 
;  1092 : #define NV_PAUDIO_INTR_2_DMA_PROTECT_RESET               0x00000001 /* -W--V */
NV_PAUDIO_INTR_2_DMA_PROTECT_RESET              EQU             000000001h
;  RWIVF 
;  1093 : #define NV_PAUDIO_INTR_2_DMA_BUS_ERROR                        12:12 /* RWIVF */
NV_PAUDIO_INTR_2_DMA_BUS_ERROR          TEXTEQU         <12:12>
;  R-I-V 
;  1094 : #define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_NOT_PENDING       0x00000000 /* R-I-V */
NV_PAUDIO_INTR_2_DMA_BUS_ERROR_NOT_PENDING              EQU             000000000h
;  R---V 
;  1095 : #define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_PENDING           0x00000001 /* R---V */
NV_PAUDIO_INTR_2_DMA_BUS_ERROR_PENDING          EQU             000000001h
;  -W--V 
;  1096 : #define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_RESET             0x00000001 /* -W--V */
NV_PAUDIO_INTR_2_DMA_BUS_ERROR_RESET            EQU             000000001h
;  RW-4R 
;  1097 : #define NV_PAUDIO_INTR_3                                 0x0030010C /* RW-4R */
NV_PAUDIO_INTR_3                EQU             00030010ch
;  RWIVF 
;  1098 : #define NV_PAUDIO_INTR_3_PINS_0                                 0:0 /* RWIVF */
NV_PAUDIO_INTR_3_PINS_0         TEXTEQU         <0:0>
;  R-I-V 
;  1099 : #define NV_PAUDIO_INTR_3_PINS_0_NOT_PENDING              0x00000000 /* R-I-V */
NV_PAUDIO_INTR_3_PINS_0_NOT_PENDING             EQU             000000000h
;  R---V 
;  1100 : #define NV_PAUDIO_INTR_3_PINS_0_PENDING                  0x00000001 /* R---V */
NV_PAUDIO_INTR_3_PINS_0_PENDING         EQU             000000001h
;  -W--V 
;  1101 : #define NV_PAUDIO_INTR_3_PINS_0_RESET                    0x00000001 /* -W--V */
NV_PAUDIO_INTR_3_PINS_0_RESET           EQU             000000001h
;  RWIVF 
;  1102 : #define NV_PAUDIO_INTR_3_PINS_1                                 4:4 /* RWIVF */
NV_PAUDIO_INTR_3_PINS_1         TEXTEQU         <4:4>
;  R-I-V 
;  1103 : #define NV_PAUDIO_INTR_3_PINS_1_NOT_PENDING              0x00000000 /* R-I-V */
NV_PAUDIO_INTR_3_PINS_1_NOT_PENDING             EQU             000000000h
;  R---V 
;  1104 : #define NV_PAUDIO_INTR_3_PINS_1_PENDING                  0x00000001 /* R---V */
NV_PAUDIO_INTR_3_PINS_1_PENDING         EQU             000000001h
;  -W--V 
;  1105 : #define NV_PAUDIO_INTR_3_PINS_1_RESET                    0x00000001 /* -W--V */
NV_PAUDIO_INTR_3_PINS_1_RESET           EQU             000000001h
;  RWIVF 
;  1106 : #define NV_PAUDIO_INTR_3_PINS_2                                 8:8 /* RWIVF */
NV_PAUDIO_INTR_3_PINS_2         TEXTEQU         <8:8>
;  R-I-V 
;  1107 : #define NV_PAUDIO_INTR_3_PINS_2_NOT_PENDING              0x00000000 /* R-I-V */
NV_PAUDIO_INTR_3_PINS_2_NOT_PENDING             EQU             000000000h
;  R---V 
;  1108 : #define NV_PAUDIO_INTR_3_PINS_2_PENDING                  0x00000001 /* R---V */
NV_PAUDIO_INTR_3_PINS_2_PENDING         EQU             000000001h
;  -W--V 
;  1109 : #define NV_PAUDIO_INTR_3_PINS_2_RESET                    0x00000001 /* -W--V */
NV_PAUDIO_INTR_3_PINS_2_RESET           EQU             000000001h
;  RWIVF 
;  1110 : #define NV_PAUDIO_INTR_3_PINS_3                               12:12 /* RWIVF */
NV_PAUDIO_INTR_3_PINS_3         TEXTEQU         <12:12>
;  R-I-V 
;  1111 : #define NV_PAUDIO_INTR_3_PINS_3_NOT_PENDING              0x00000000 /* R-I-V */
NV_PAUDIO_INTR_3_PINS_3_NOT_PENDING             EQU             000000000h
;  R---V 
;  1112 : #define NV_PAUDIO_INTR_3_PINS_3_PENDING                  0x00000001 /* R---V */
NV_PAUDIO_INTR_3_PINS_3_PENDING         EQU             000000001h
;  -W--V 
;  1113 : #define NV_PAUDIO_INTR_3_PINS_3_RESET                    0x00000001 /* -W--V */
NV_PAUDIO_INTR_3_PINS_3_RESET           EQU             000000001h
;  RW-4R 
;  1114 : #define NV_PAUDIO_INTR_EN_0                              0x00300140 /* RW-4R */
NV_PAUDIO_INTR_EN_0             EQU             000300140h
;  RWIVF 
;  1115 : #define NV_PAUDIO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
NV_PAUDIO_INTR_EN_0_NOTIFY              TEXTEQU         <0:0>
;  RWI-V 
;  1116 : #define NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED             EQU             000000000h
;  RW--V 
;  1117 : #define NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED              EQU             000000001h
;  RWIVF 
;  1118 : #define NV_PAUDIO_INTR_EN_0_OVERFLOW                            4:4 /* RWIVF */
NV_PAUDIO_INTR_EN_0_OVERFLOW            TEXTEQU         <4:4>
;  RWI-V 
;  1119 : #define NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED            0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED           EQU             000000000h
;  RW--V 
;  1120 : #define NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED             0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED            EQU             000000001h
;  RWIVF 
;  1121 : #define NV_PAUDIO_INTR_EN_0_AN_OVFL                             8:8 /* RWIVF */
NV_PAUDIO_INTR_EN_0_AN_OVFL             TEXTEQU         <8:8>
;  RWI-V 
;  1122 : #define NV_PAUDIO_INTR_EN_0_AN_OVFL_DISABLED             0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_0_AN_OVFL_DISABLED            EQU             000000000h
;  RW--V 
;  1123 : #define NV_PAUDIO_INTR_EN_0_AN_OVFL_ENABLED              0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_0_AN_OVFL_ENABLED             EQU             000000001h
;  RWIVF 
;  1124 : #define NV_PAUDIO_INTR_EN_0_AN_UNFL                           12:12 /* RWIVF */
NV_PAUDIO_INTR_EN_0_AN_UNFL             TEXTEQU         <12:12>
;  RWI-V 
;  1125 : #define NV_PAUDIO_INTR_EN_0_AN_UNFL_DISABLED             0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_0_AN_UNFL_DISABLED            EQU             000000000h
;  RW--V 
;  1126 : #define NV_PAUDIO_INTR_EN_0_AN_UNFL_ENABLED              0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_0_AN_UNFL_ENABLED             EQU             000000001h
;  RW-4R 
;  1127 : #define NV_PAUDIO_INTR_EN_1                              0x00300144 /* RW-4R */
NV_PAUDIO_INTR_EN_1             EQU             000300144h
;  RWIVF 
;  1128 : #define NV_PAUDIO_INTR_EN_1_SYNC                                0:0 /* RWIVF */
NV_PAUDIO_INTR_EN_1_SYNC                TEXTEQU         <0:0>
;  RWI-V 
;  1129 : #define NV_PAUDIO_INTR_EN_1_SYNC_DISABLED                0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_1_SYNC_DISABLED               EQU             000000000h
;  RW--V 
;  1130 : #define NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                 0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                EQU             000000001h
;  RWIVF 
;  1131 : #define NV_PAUDIO_INTR_EN_1_IDLE                                4:4 /* RWIVF */
NV_PAUDIO_INTR_EN_1_IDLE                TEXTEQU         <4:4>
;  RWI-V 
;  1132 : #define NV_PAUDIO_INTR_EN_1_IDLE_DISABLED                0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_1_IDLE_DISABLED               EQU             000000000h
;  RW--V 
;  1133 : #define NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                 0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                EQU             000000001h
;  RWIVF 
;  1134 : #define NV_PAUDIO_INTR_EN_1_NEAR_BUSY                           8:8 /* RWIVF */
NV_PAUDIO_INTR_EN_1_NEAR_BUSY           TEXTEQU         <8:8>
;  RWI-V 
;  1135 : #define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED           0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED          EQU             000000000h
;  RW--V 
;  1136 : #define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED            0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED           EQU             000000001h
;  RWIVF 
;  1137 : #define NV_PAUDIO_INTR_EN_1_TOO_BUSY                          12:12 /* RWIVF */
NV_PAUDIO_INTR_EN_1_TOO_BUSY            TEXTEQU         <12:12>
;  RWI-V 
;  1138 : #define NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED            0x00000000 /* RWI-V */
NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED           EQU             000000000h
;  RW--V 
;  1139 : #define NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED             0x00000001 /* RW--V */
NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED            EQU             000000001h
;  RW-4R 
;  1140 : #define NV_PAUDIO_INTR_EN_2                              0x00300148 /* RW-4R */
NV_PAUDIO_INTR_EN_2             EQU             000300148h
;  RWIVF 
;  1141 : #define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE                        0:0 /* RWIVF */
NV_PAUDIO_INTR_EN_2_DMA_INSTANCE                TEXTEQU         <0:0>
;  R-I-V 
;  1142 : #define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_NOT_PENDING     0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_NOT_PENDING            EQU             000000000h
;  R---V 
;  1143 : #define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_PENDING         0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_PENDING                EQU             000000001h
;  -W--V 
;  1144 : #define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_RESET           0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_RESET          EQU             000000001h
;  RWIVF 
;  1145 : #define NV_PAUDIO_INTR_EN_2_DMA_PRESENT                         4:4 /* RWIVF */
NV_PAUDIO_INTR_EN_2_DMA_PRESENT         TEXTEQU         <4:4>
;  R-I-V 
;  1146 : #define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_NOT_PENDING      0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_2_DMA_PRESENT_NOT_PENDING             EQU             000000000h
;  R---V 
;  1147 : #define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_PENDING          0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_2_DMA_PRESENT_PENDING         EQU             000000001h
;  -W--V 
;  1148 : #define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_RESET            0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_2_DMA_PRESENT_RESET           EQU             000000001h
;  RWIVF 
;  1149 : #define NV_PAUDIO_INTR_EN_2_DMA_PROTECT                         8:8 /* RWIVF */
NV_PAUDIO_INTR_EN_2_DMA_PROTECT         TEXTEQU         <8:8>
;  R-I-V 
;  1150 : #define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_NOT_PENDING      0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_2_DMA_PROTECT_NOT_PENDING             EQU             000000000h
;  R---V 
;  1151 : #define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_PENDING          0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_2_DMA_PROTECT_PENDING         EQU             000000001h
;  -W--V 
;  1152 : #define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_RESET            0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_2_DMA_PROTECT_RESET           EQU             000000001h
;  RWIVF 
;  1153 : #define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR                     12:12 /* RWIVF */
NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR               TEXTEQU         <12:12>
;  R-I-V 
;  1154 : #define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_NOT_PENDING    0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_NOT_PENDING           EQU             000000000h
;  R---V 
;  1155 : #define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_PENDING        0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_PENDING               EQU             000000001h
;  -W--V 
;  1156 : #define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_RESET          0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_RESET         EQU             000000001h
;  RW-4R 
;  1157 : #define NV_PAUDIO_INTR_EN_3                              0x0030014C /* RW-4R */
NV_PAUDIO_INTR_EN_3             EQU             00030014ch
;  RWIVF 
;  1158 : #define NV_PAUDIO_INTR_EN_3_PINS_0                              0:0 /* RWIVF */
NV_PAUDIO_INTR_EN_3_PINS_0              TEXTEQU         <0:0>
;  R-I-V 
;  1159 : #define NV_PAUDIO_INTR_EN_3_PINS_0_NOT_PENDING           0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_3_PINS_0_NOT_PENDING          EQU             000000000h
;  R---V 
;  1160 : #define NV_PAUDIO_INTR_EN_3_PINS_0_PENDING               0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_3_PINS_0_PENDING              EQU             000000001h
;  -W--V 
;  1161 : #define NV_PAUDIO_INTR_EN_3_PINS_0_RESET                 0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_3_PINS_0_RESET                EQU             000000001h
;  RWIVF 
;  1162 : #define NV_PAUDIO_INTR_EN_3_PINS_1                              4:4 /* RWIVF */
NV_PAUDIO_INTR_EN_3_PINS_1              TEXTEQU         <4:4>
;  R-I-V 
;  1163 : #define NV_PAUDIO_INTR_EN_3_PINS_1_NOT_PENDING           0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_3_PINS_1_NOT_PENDING          EQU             000000000h
;  R---V 
;  1164 : #define NV_PAUDIO_INTR_EN_3_PINS_1_PENDING               0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_3_PINS_1_PENDING              EQU             000000001h
;  -W--V 
;  1165 : #define NV_PAUDIO_INTR_EN_3_PINS_1_RESET                 0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_3_PINS_1_RESET                EQU             000000001h
;  RWIVF 
;  1166 : #define NV_PAUDIO_INTR_EN_3_PINS_2                              8:8 /* RWIVF */
NV_PAUDIO_INTR_EN_3_PINS_2              TEXTEQU         <8:8>
;  R-I-V 
;  1167 : #define NV_PAUDIO_INTR_EN_3_PINS_2_NOT_PENDING           0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_3_PINS_2_NOT_PENDING          EQU             000000000h
;  R---V 
;  1168 : #define NV_PAUDIO_INTR_EN_3_PINS_2_PENDING               0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_3_PINS_2_PENDING              EQU             000000001h
;  -W--V 
;  1169 : #define NV_PAUDIO_INTR_EN_3_PINS_2_RESET                 0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_3_PINS_2_RESET                EQU             000000001h
;  RWIVF 
;  1170 : #define NV_PAUDIO_INTR_EN_3_PINS_3                            12:12 /* RWIVF */
NV_PAUDIO_INTR_EN_3_PINS_3              TEXTEQU         <12:12>
;  R-I-V 
;  1171 : #define NV_PAUDIO_INTR_EN_3_PINS_3_NOT_PENDING           0x00000000 /* R-I-V */
NV_PAUDIO_INTR_EN_3_PINS_3_NOT_PENDING          EQU             000000000h
;  R---V 
;  1172 : #define NV_PAUDIO_INTR_EN_3_PINS_3_PENDING               0x00000001 /* R---V */
NV_PAUDIO_INTR_EN_3_PINS_3_PENDING              EQU             000000001h
;  -W--V 
;  1173 : #define NV_PAUDIO_INTR_EN_3_PINS_3_RESET                 0x00000001 /* -W--V */
NV_PAUDIO_INTR_EN_3_PINS_3_RESET                EQU             000000001h
;  RW-4R 
;  1174 : #define NV_PAUDIO_BLOCK_NEW                              0x00300200 /* RW-4R */
NV_PAUDIO_BLOCK_NEW             EQU             000300200h
;  RWXUF 
;  1175 : #define NV_PAUDIO_BLOCK_NEW_LENGTH                              7:0 /* RWXUF */
NV_PAUDIO_BLOCK_NEW_LENGTH              TEXTEQU         <7:0>
;  RWXUF 
;  1176 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_LG2                     14:12 /* RWXUF */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_LG2               TEXTEQU         <14:12>
;  RW--V 
;  1177 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_1                  0x00000000 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_1         EQU             000000000h
;  RW--V 
;  1178 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_2                  0x00000001 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_2         EQU             000000001h
;  RW--V 
;  1179 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_4                  0x00000002 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_4         EQU             000000002h
;  RW--V 
;  1180 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_8                  0x00000003 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_8         EQU             000000003h
;  RW--V 
;  1181 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_16                 0x00000004 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_16                EQU             000000004h
;  RW--V 
;  1182 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_32                 0x00000005 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_32                EQU             000000005h
;  RW--V 
;  1183 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_64                 0x00000006 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_64                EQU             000000006h
;  RW--V 
;  1184 : #define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_128                0x00000007 /* RW--V */
NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_128               EQU             000000007h
;  RW-4R 
;  1185 : #define NV_PAUDIO_BLOCK_ENGINE                           0x00300204 /* RW-4R */
NV_PAUDIO_BLOCK_ENGINE          EQU             000300204h
;  RWXUF 
;  1186 : #define NV_PAUDIO_BLOCK_ENGINE_LENGTH                           7:0 /* RWXUF */
NV_PAUDIO_BLOCK_ENGINE_LENGTH           TEXTEQU         <7:0>
;  R-XVF 
;  1187 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_LG2                  14:12 /* R-XVF */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_LG2            TEXTEQU         <14:12>
;  R---V 
;  1188 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_1               0x00000000 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_1              EQU             000000000h
;  R---V 
;  1189 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_2               0x00000001 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_2              EQU             000000001h
;  R---V 
;  1190 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_4               0x00000002 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_4              EQU             000000002h
;  R---V 
;  1191 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_8               0x00000003 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_8              EQU             000000003h
;  R---V 
;  1192 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_16              0x00000004 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_16             EQU             000000004h
;  R---V 
;  1193 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_32              0x00000005 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_32             EQU             000000005h
;  R---V 
;  1194 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_64              0x00000006 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_64             EQU             000000006h
;  R---V 
;  1195 : #define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_128             0x00000007 /* R---V */
NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_128            EQU             000000007h
;  RW-4R 
;  1196 : #define NV_PAUDIO_RAMAU                                  0x00300210 /* RW-4R */
NV_PAUDIO_RAMAU         EQU             000300210h
;  RWXVF 
;  1197 : #define NV_PAUDIO_RAMAU_BASE_ADDRESS                          15:12 /* RWXVF */
NV_PAUDIO_RAMAU_BASE_ADDRESS            TEXTEQU         <15:12>
;  RWI-V 
;  1198 : #define NV_PAUDIO_RAMAU_BASE_ADDRESS_1000                0x00001000 /* RWI-V */
NV_PAUDIO_RAMAU_BASE_ADDRESS_1000               EQU             000001000h
;  RW-4R 
;  1199 : #define NV_PAUDIO_ISA_SEL                                0x00300280 /* RW-4R */
NV_PAUDIO_ISA_SEL               EQU             000300280h
;  RWXVF 
;  1200 : #define NV_PAUDIO_ISA_SEL_IRQ                                   2:0 /* RWXVF */
NV_PAUDIO_ISA_SEL_IRQ           TEXTEQU         <2:0>
;  RWI-V 
;  1201 : #define NV_PAUDIO_ISA_SEL_IRQ_0                          0x00000001 /* RWI-V */
NV_PAUDIO_ISA_SEL_IRQ_0         EQU             000000001h
;  RWI-V 
;  1202 : #define NV_PAUDIO_ISA_SEL_IRQ_1                          0x00000002 /* RWI-V */
NV_PAUDIO_ISA_SEL_IRQ_1         EQU             000000002h
;  RWI-V 
;  1203 : #define NV_PAUDIO_ISA_SEL_IRQ_2                          0x00000004 /* RWI-V */
NV_PAUDIO_ISA_SEL_IRQ_2         EQU             000000004h
;  RWXVF 
;  1204 : #define NV_PAUDIO_ISA_SEL_DRQ                                   9:8 /* RWXVF */
NV_PAUDIO_ISA_SEL_DRQ           TEXTEQU         <9:8>
;  RWI-V 
;  1205 : #define NV_PAUDIO_ISA_SEL_DRQ_0                          0x00000001 /* RWI-V */
NV_PAUDIO_ISA_SEL_DRQ_0         EQU             000000001h
;  RWI-V 
;  1206 : #define NV_PAUDIO_ISA_SEL_DRQ_1                          0x00000002 /* RWI-V */
NV_PAUDIO_ISA_SEL_DRQ_1         EQU             000000002h
;  R-X4R 
;  1207 : #define NV_PAUDIO_TLB_PTE                                0x00300310 /* R-X4R */
NV_PAUDIO_TLB_PTE               EQU             000300310h
;  R-XVF 
;  1208 : #define NV_PAUDIO_TLB_PTE_PAGE                                31:10 /* R-XVF */
NV_PAUDIO_TLB_PTE_PAGE          TEXTEQU         <31:10>
;  R-XVF 
;  1209 : #define NV_PAUDIO_TLB_PTE_READ_ONLY                             1:1 /* R-XVF */
NV_PAUDIO_TLB_PTE_READ_ONLY             TEXTEQU         <1:1>
;  R-XVF 
;  1210 : #define NV_PAUDIO_TLB_PTE_PRESENT                               0:0 /* R-XVF */
NV_PAUDIO_TLB_PTE_PRESENT               TEXTEQU         <0:0>
;  R-X4R 
;  1211 : #define NV_PAUDIO_TLB_TAG                                0x00300320 /* R-X4R */
NV_PAUDIO_TLB_TAG               EQU             000300320h
;  R-XVF 
;  1212 : #define NV_PAUDIO_DMA_TLB_TAG                                 31:12 /* R-XVF */
NV_PAUDIO_DMA_TLB_TAG           TEXTEQU         <31:12>
;  R-X4R 
;  1213 : #define NV_PAUDIO_DMAIA                                  0x00300330 /* R-X4R */
NV_PAUDIO_DMAIA         EQU             000300330h
;  R-XVF 
;  1214 : #define NV_PAUDIO_DMA_INSTANCE                                 31:2 /* R-XVF */
NV_PAUDIO_DMA_INSTANCE          TEXTEQU         <31:2>
;  R-XVF 
;  1215 : #define NV_PAUDIO_DMA_INSTANCE_TARGET                           1:0 /* R-XVF */
NV_PAUDIO_DMA_INSTANCE_TARGET           TEXTEQU         <1:0>
;  RW-4R 
;  1216 : #define NV_PAUDIO_NEAR_MARK                              0x00300400 /* RW-4R */
NV_PAUDIO_NEAR_MARK             EQU             000300400h
;  RWXUF 
;  1217 : #define NV_PAUDIO_NEAR_MARK_COUNT                               7:0 /* RWXUF */
NV_PAUDIO_NEAR_MARK_COUNT               TEXTEQU         <7:0>
;  R--4R 
;  1218 : #define NV_PAUDIO_SAMPLE_COUNT                           0x00300410 /* R--4R */
NV_PAUDIO_SAMPLE_COUNT          EQU             000300410h
;  R-XUF 
;  1219 : #define NV_PAUDIO_SAMPLE_COUNT_VALUE                            7:0 /* R-XUF */
NV_PAUDIO_SAMPLE_COUNT_VALUE            TEXTEQU         <7:0>
;  R-XUF 
;  1220 : #define NV_PAUDIO_SAMPLE_COUNT_BUFFER                           8:8 /* R-XUF */
NV_PAUDIO_SAMPLE_COUNT_BUFFER           TEXTEQU         <8:8>
;  R--4R 
;  1221 : #define NV_PAUDIO_PROG_COUNTER                           0x00300420 /* R--4R */
NV_PAUDIO_PROG_COUNTER          EQU             000300420h
;  R-XUF 
;  1222 : #define NV_PAUDIO_PROG_COUNTER_VALUE                            7:0 /* R-XUF */
NV_PAUDIO_PROG_COUNTER_VALUE            TEXTEQU         <7:0>
;  RWI4R 
;  1223 : #define NV_PAUDIO_AN_VOLUME                              0x00300430 /* RWI4R */
NV_PAUDIO_AN_VOLUME             EQU             000300430h
;  RWI-V 
;  1224 : #define NV_PAUDIO_AN_VOLUME_INITIAL                               7 /* RWI-V */
NV_PAUDIO_AN_VOLUME_INITIAL             EQU             7t
;  RWXUF 
;  1225 : #define NV_PAUDIO_AN_VOLUME_VALUE                               2:0 /* RWXUF */
NV_PAUDIO_AN_VOLUME_VALUE               TEXTEQU         <2:0>
;  RW-4R 
;  1226 : #define NV_PAUDIO_TERM_USAGE                             0x00300C0C /* RW-4R */
NV_PAUDIO_TERM_USAGE            EQU             000300c0ch
;  RWXUF 
;  1227 : #define NV_PAUDIO_TERMINATION_LEVEL                           31:16 /* RWXUF */
NV_PAUDIO_TERMINATION_LEVEL             TEXTEQU         <31:16>
;  RW--V 
;  1228 : #define NV_PAUDIO_TERMINATION_LEVEL_DISABLED             0x00000000 /* RW--V */
NV_PAUDIO_TERMINATION_LEVEL_DISABLED            EQU             000000000h
;  RWXUF 
;  1229 : #define NV_PAUDIO_USAGE_LEVEL                                  15:0 /* RWXUF */
NV_PAUDIO_USAGE_LEVEL           TEXTEQU         <15:0>
;  RW-4R 
;  1230 : #define NV_PAUDIO_CONTEXT                                0x00300E10 /* RW-4R */
NV_PAUDIO_CONTEXT               EQU             000300e10h
;  RWXUF 
;  1231 : #define NV_PAUDIO_CONTEXT_INSTANCE                             31:0 /* RWXUF */
NV_PAUDIO_CONTEXT_INSTANCE              TEXTEQU         <31:0>
;  RW-1A 
;        
;  1232 : #define NV_PAUDIO_BLASTER(i)                       (0x00301000+(i)) /* RW-1A */
;  1233 : #define NV_PAUDIO_BLASTER__SIZE_1                                 1 /*       */
NV_PAUDIO_BLASTER__SIZE_1               EQU             1t
;  RW-VF 
;  1234 : #define NV_PAUDIO_BLASTER_DATA                                  7:0 /* RW-VF */
NV_PAUDIO_BLASTER_DATA          TEXTEQU         <7:0>
;  RW-4A 
;        
;  1235 : #define NV_PAUDIO_CODEC(i)                       (0x00302800+(i)*4) /* RW-4A */
;  1236 : #define NV_PAUDIO_CODEC__SIZE_1                                 256 /*       */
NV_PAUDIO_CODEC__SIZE_1         EQU             256t
;  RW-VF 
;  1237 : #define NV_PAUDIO_CODEC_DATA                                   19:0 /* RW-VF */
NV_PAUDIO_CODEC_DATA            TEXTEQU         <19:0>
;  RW--V 
;  1238 : #define NV_PAUDIO_INST_TARGET_NVM                        0x00000000 /* RW--V */
NV_PAUDIO_INST_TARGET_NVM               EQU             000000000h
;  RW--V 
;  1239 : #define NV_PAUDIO_INST_TARGET_CART                       0x00000001 /* RW--V */
NV_PAUDIO_INST_TARGET_CART              EQU             000000001h
;  RW--V 
;  1240 : #define NV_PAUDIO_INST_TARGET_PCI                        0x00000002 /* RW--V */
NV_PAUDIO_INST_TARGET_PCI               EQU             000000002h
;  RW-4R 
;  1241 : #define NV_PAUDIO_ROOT_INPUT                             0x00300C00 /* RW-4R */
NV_PAUDIO_ROOT_INPUT            EQU             000300c00h
;  RWXUF 
;  1242 : #define NV_PAUDIO_ROOT_INPUT_TARGET                             1:0 /* RWXUF */
NV_PAUDIO_ROOT_INPUT_TARGET             TEXTEQU         <1:0>
;  RWXUF 
;  1243 : #define NV_PAUDIO_ROOT_INPUT_INSTANCE                          31:2 /* RWXUF */
NV_PAUDIO_ROOT_INPUT_INSTANCE           TEXTEQU         <31:2>
;  RW-4R 
;  1244 : #define NV_PAUDIO_ROOT_OUTPUT                            0x00300C04 /* RW-4R */
NV_PAUDIO_ROOT_OUTPUT           EQU             000300c04h
;  RWXUF 
;  1245 : #define NV_PAUDIO_ROOT_OUTPUT_TARGET                            1:0 /* RWXUF */
NV_PAUDIO_ROOT_OUTPUT_TARGET            TEXTEQU         <1:0>
;  RWXUF 
;  1246 : #define NV_PAUDIO_ROOT_OUTPUT_INSTANCE                         31:2 /* RWXUF */
NV_PAUDIO_ROOT_OUTPUT_INSTANCE          TEXTEQU         <31:2>
;  RW-4R 
;  1247 : #define NV_PAUDIO_ROOT_NOTE                              0x00300C08 /* RW-4R */
NV_PAUDIO_ROOT_NOTE             EQU             000300c08h
;  RWXUF 
;  1248 : #define NV_PAUDIO_ROOT_NOTE_TARGET                              1:0 /* RWXUF */
NV_PAUDIO_ROOT_NOTE_TARGET              TEXTEQU         <1:0>
;  RWXUF 
;  1249 : #define NV_PAUDIO_ROOT_NOTE_INSTANCE                           31:2 /* RWXUF */
NV_PAUDIO_ROOT_NOTE_INSTANCE            TEXTEQU         <31:2>
;  RW-4A 
;        
;  1250 : #define NV_PAUDIO_DIAG(i)                        (0x00300C10+(i)*4) /* RW-4A */
;  1251 : #define NV_PAUDIO_DIAG__SIZE_1                                  252 /*       */
NV_PAUDIO_DIAG__SIZE_1          EQU             252t
;  RW-VF 
;  1252 : #define NV_PAUDIO_DIAG_DATA                                    31:0 /* RW-VF */
NV_PAUDIO_DIAG_DATA             TEXTEQU         <31:0>
;  dev_graphics.ref 
;  RW--D 
;  1253 : /* dev_graphics.ref */
;  1254 : #define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
NV_PGRAPH               TEXTEQU         <0x00401FFF:0x00400000>
;  RW-4R 
;  1255 : #define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
NV_PGRAPH_DEBUG_0               EQU             000400080h
;  CW-VF 
;  1256 : #define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
NV_PGRAPH_DEBUG_0_STATE         TEXTEQU         <0:0>
;  CW--V 
;  1257 : #define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_0_STATE_NORMAL          EQU             000000000h
;  -W--V 
;  1258 : #define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_0_STATE_RESET           EQU             000000001h
;  CW-VF 
;  1259 : #define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE                         1:1 /* CW-VF */
NV_PGRAPH_DEBUG_0_AP_PIPE_STATE         TEXTEQU         <1:1>
;  CW--V 
;  1260 : #define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL          EQU             000000000h
;  -W--V 
;  1261 : #define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET            0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET           EQU             000000001h
;  CW-VF 
;  1262 : #define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE                         2:2 /* CW-VF */
NV_PGRAPH_DEBUG_0_3D_PIPE_STATE         TEXTEQU         <2:2>
;  CW--V 
;  1263 : #define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL          EQU             000000000h
;  -W--V 
;  1264 : #define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET            0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET           EQU             000000001h
;  CW-VF 
;  1265 : #define NV_PGRAPH_DEBUG_0_CACHE_STATE                           3:3 /* CW-VF */
NV_PGRAPH_DEBUG_0_CACHE_STATE           TEXTEQU         <3:3>
;  CW--V 
;  1266 : #define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL            EQU             000000000h
;  -W--V 
;  1267 : #define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET             EQU             000000001h
;  RWIVF 
;  1268 : #define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
NV_PGRAPH_DEBUG_0_BULK_READS            TEXTEQU         <4:4>
;  RWI-V 
;  1269 : #define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED           EQU             000000000h
;  RW--V 
;  1270 : #define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED            EQU             000000001h
;  RWIVF 
;  1271 : #define NV_PGRAPH_DEBUG_0_SPARE1                                8:8 /* RWIVF */
NV_PGRAPH_DEBUG_0_SPARE1                TEXTEQU         <8:8>
;  RWI-V 
;  1272 : #define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_SPARE1_DISABLED               EQU             000000000h
;  RW--V 
;  1273 : #define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                EQU             000000001h
;  RWIVF 
;  1274 : #define NV_PGRAPH_DEBUG_0_SPARE2                              12:12 /* RWIVF */
NV_PGRAPH_DEBUG_0_SPARE2                TEXTEQU         <12:12>
;  RWI-V 
;  1275 : #define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_SPARE2_DISABLED               EQU             000000000h
;  RW--V 
;  1276 : #define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                EQU             000000001h
;  RWIVF 
;  1277 : #define NV_PGRAPH_DEBUG_0_SPARE3                              16:16 /* RWIVF */
NV_PGRAPH_DEBUG_0_SPARE3                TEXTEQU         <16:16>
;  RWI-V 
;  1278 : #define NV_PGRAPH_DEBUG_0_SPARE3_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_SPARE3_DISABLED               EQU             000000000h
;  RW--V 
;  1279 : #define NV_PGRAPH_DEBUG_0_SPARE3_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_SPARE3_ENABLED                EQU             000000001h
;  RWIVF 
;  1280 : #define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS                     20:20 /* RWIVF */
NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS               TEXTEQU         <20:20>
;  RWI-V 
;  1281 : #define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_DISABLED       0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_DISABLED              EQU             000000000h
;  RW--V 
;  1282 : #define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_ENABLED        0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_ENABLED               EQU             000000001h
;  RWIVF 
;  1283 : #define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO          TEXTEQU         <24:24>
;  RWI-V 
;  1284 : #define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED         EQU             000000000h
;  RW--V 
;  1285 : #define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED          EQU             000000001h
;  RWIVF 
;  1286 : #define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
NV_PGRAPH_DEBUG_0_DRAWDIR_Y             TEXTEQU         <25:25>
;  RWI-V 
;  1287 : #define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                EQU             000000000h
;  RW--V 
;  1288 : #define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                EQU             000000001h
;  RWIVF 
;  1289 : #define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
NV_PGRAPH_DEBUG_0_ALPHA_ABORT           TEXTEQU         <28:28>
;  RWI-V 
;  1290 : #define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED          EQU             000000000h
;  RW--V 
;  1291 : #define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED           EQU             000000001h
;  RW-4R 
;  1292 : #define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
NV_PGRAPH_DEBUG_1               EQU             000400084h
;  RWIVF 
;  1293 : #define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
NV_PGRAPH_DEBUG_1_VOLATILE_RESET                TEXTEQU         <0:0>
;  RWI-V 
;  1294 : #define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST               EQU             000000000h
;  RW--V 
;  1295 : #define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST           EQU             000000001h
;  CW-VF 
;  1296 : #define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
NV_PGRAPH_DEBUG_1_DMA_ACTIVITY          TEXTEQU         <4:4>
;  CW--V 
;  1297 : #define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE           EQU             000000000h
;  -W--V 
;  1298 : #define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL           EQU             000000001h
;  RWIVF 
;  1299 : #define NV_PGRAPH_DEBUG_1_TURBO3D_2X                            8:8 /* RWIVF */
NV_PGRAPH_DEBUG_1_TURBO3D_2X            TEXTEQU         <8:8>
;  RWI-V 
;  1300 : #define NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED          EQU             000000000h
;  RW--V 
;  1301 : #define NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED            EQU             000000001h
;  RWIVF 
;  1302 : #define NV_PGRAPH_DEBUG_1_TURBO3D_4X                            9:9 /* RWIVF */
NV_PGRAPH_DEBUG_1_TURBO3D_4X            TEXTEQU         <9:9>
;  RWI-V 
;  1303 : #define NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED          EQU             000000000h
;  RW--V 
;  1304 : #define NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED            EQU             000000001h
;  RWIVF 
;  1305 : #define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
NV_PGRAPH_DEBUG_1_TRI_OPTS              TEXTEQU         <12:12>
;  RWI-V 
;  1306 : #define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED             EQU             000000000h
;  RW--V 
;  1307 : #define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED              EQU             000000001h
;  RWIVF 
;  1308 : #define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
NV_PGRAPH_DEBUG_1_INSTANCE              TEXTEQU         <16:16>
;  RWI-V 
;  1309 : #define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED             EQU             000000000h
;  RW--V 
;  1310 : #define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED              EQU             000000001h
;  RWIVF 
;  1311 : #define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
NV_PGRAPH_DEBUG_1_CTX           TEXTEQU         <20:20>
;  RWI-V 
;  1312 : #define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_CTX_DISABLED          EQU             000000000h
;  RW--V 
;  1313 : #define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_CTX_ENABLED           EQU             000000001h
;  CW-VF 
;  1314 : #define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CW-VF */
NV_PGRAPH_DEBUG_1_CACHE         TEXTEQU         <24:24>
;  CW--V 
;  1315 : #define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_1_CACHE_IGNORE          EQU             000000000h
;  -W--V 
;  1316 : #define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_1_CACHE_FLUSH           EQU             000000001h
;  RWIVF 
;  1317 : #define NV_PGRAPH_DEBUG_1_SPARE1                              28:28 /* RWIVF */
NV_PGRAPH_DEBUG_1_SPARE1                TEXTEQU         <28:28>
;  RWI-V 
;  1318 : #define NV_PGRAPH_DEBUG_1_SPARE1_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_1_SPARE1_DISABLED               EQU             000000000h
;  RW--V 
;  1319 : #define NV_PGRAPH_DEBUG_1_SPARE1_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_1_SPARE1_ENABLED                EQU             000000001h
;  RW-4R 
;  1320 : #define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
NV_PGRAPH_DEBUG_2               EQU             000400088h
;  RWIVF 
;  1321 : #define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND               TEXTEQU         <0:0>
;  RWI-V 
;  1322 : #define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED              EQU             000000000h
;  RW--V 
;  1323 : #define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED               EQU             000000001h
;  RWIVF 
;  1324 : #define NV_PGRAPH_DEBUG_2_ALPHA_ABORT                           4:4 /* RWIVF */
NV_PGRAPH_DEBUG_2_ALPHA_ABORT           TEXTEQU         <4:4>
;  RWI-V 
;  1325 : #define NV_PGRAPH_DEBUG_2_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_ALPHA_ABORT_DISABLED          EQU             000000000h
;  RW--V 
;  1326 : #define NV_PGRAPH_DEBUG_2_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_ALPHA_ABORT_ENABLED           EQU             000000001h
;  RWIVF 
;  1327 : #define NV_PGRAPH_DEBUG_2_DPWR_FIFO                             8:8 /* RWIVF */
NV_PGRAPH_DEBUG_2_DPWR_FIFO             TEXTEQU         <8:8>
;  RWI-V 
;  1328 : #define NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED            EQU             000000000h
;  RW--V 
;  1329 : #define NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED              0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED             EQU             000000001h
;  RWIVF 
;  1330 : #define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
NV_PGRAPH_DEBUG_2_BILINEAR_3D           TEXTEQU         <12:12>
;  RWI-V 
;  1331 : #define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED          EQU             000000000h
;  RW--V 
;  1332 : #define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED           EQU             000000001h
;  RWIVF 
;  1333 : #define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                TEXTEQU         <13:13>
;  RWI-V 
;  1334 : #define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED               EQU             000000000h
;  RW--V 
;  1335 : #define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED                EQU             000000001h
;  RWIVF 
;  1336 : #define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
NV_PGRAPH_DEBUG_2_FOG_3D                TEXTEQU         <14:14>
;  RWI-V 
;  1337 : #define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED               EQU             000000000h
;  RW--V 
;  1338 : #define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                EQU             000000001h
;  RWIVF 
;  1339 : #define NV_PGRAPH_DEBUG_2_LIGHTING_3D                         15:15 /* RWIVF */
NV_PGRAPH_DEBUG_2_LIGHTING_3D           TEXTEQU         <15:15>
;  RWI-V 
;  1340 : #define NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED          EQU             000000000h
;  RW--V 
;  1341 : #define NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED            0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED           EQU             000000001h
;  RWIVF 
;  1342 : #define NV_PGRAPH_DEBUG_2_BILINEAR_2D                         16:16 /* RWIVF */
NV_PGRAPH_DEBUG_2_BILINEAR_2D           TEXTEQU         <16:16>
;  RWI-V 
;  1343 : #define NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED           0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED          EQU             000000000h
;  RW--V 
;  1344 : #define NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED            0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED           EQU             000000001h
;  RWIVF 
;  1345 : #define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                      17:17 /* RWIVF */
NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                TEXTEQU         <17:17>
;  RWI-V 
;  1346 : #define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED               EQU             000000000h
;  RW--V 
;  1347 : #define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED                EQU             000000001h
;  RWIVF 
;  1348 : #define NV_PGRAPH_DEBUG_2_COELESCE                            20:20 /* RWIVF */
NV_PGRAPH_DEBUG_2_COELESCE              TEXTEQU         <20:20>
;  RWI-V 
;  1349 : #define NV_PGRAPH_DEBUG_2_COELESCE_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_COELESCE_DISABLED             EQU             000000000h
;  RW--V 
;  1350 : #define NV_PGRAPH_DEBUG_2_COELESCE_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_COELESCE_ENABLED              EQU             000000001h
;  RWIVF 
;  1351 : #define NV_PGRAPH_DEBUG_2_PREFETCH                            24:24 /* RWIVF */
NV_PGRAPH_DEBUG_2_PREFETCH              TEXTEQU         <24:24>
;  RWI-V 
;  1352 : #define NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED             EQU             000000000h
;  RW--V 
;  1353 : #define NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED              EQU             000000001h
;  RWIVF 
;  1354 : #define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
NV_PGRAPH_DEBUG_2_VOLATILE_RESET                TEXTEQU         <28:28>
;  RWI-V 
;  1355 : #define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED               EQU             000000000h
;  RW--V 
;  1356 : #define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED                EQU             000000001h
;  RW-4R 
;  1357 : #define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
NV_PGRAPH_DEBUG_3               EQU             00040008ch
;  RWIVF 
;  1358 : #define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
NV_PGRAPH_DEBUG_3_CULLING               TEXTEQU         <0:0>
;  RWI-V 
;  1359 : #define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_CULLING_DISABLED              EQU             000000000h
;  RW--V 
;  1360 : #define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_CULLING_ENABLED               EQU             000000001h
;  RWIVF 
;  1361 : #define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH              TEXTEQU         <4:4>
;  RWI-V 
;  1362 : #define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED             EQU             000000000h
;  RW--V 
;  1363 : #define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED              EQU             000000001h
;  RWIVF 
;  1364 : #define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
NV_PGRAPH_DEBUG_3_FAST_DATA_D3D         TEXTEQU         <5:5>
;  RWI-V 
;  1365 : #define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED                EQU             000000000h
;  RW--V 
;  1366 : #define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED         EQU             000000001h
;  RWIVF 
;  1367 : #define NV_PGRAPH_DEBUG_3_AUTOZFLUSH                            8:8 /* RWIVF */
NV_PGRAPH_DEBUG_3_AUTOZFLUSH            TEXTEQU         <8:8>
;  RWI-V 
;  1368 : #define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_DISABLED            0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_AUTOZFLUSH_DISABLED           EQU             000000000h
;  RW--V 
;  1369 : #define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_AUTOZFLUSH_ENABLED            EQU             000000001h
;  CW-VF 
;  1370 : #define NV_PGRAPH_DEBUG_3_ZFLUSH                                9:9 /* CW-VF */
NV_PGRAPH_DEBUG_3_ZFLUSH                TEXTEQU         <9:9>
;  CW--V 
;  1371 : #define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CW--V */
NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE         EQU             000000000h
;  -W--V 
;  1372 : #define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--V */
NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE               EQU             000000001h
;  RWIVF 
;  1373 : #define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        12:12 /* RWIVF */
NV_PGRAPH_DEBUG_3_EARLYZ_ABORT          TEXTEQU         <12:12>
;  RWI-V 
;  1374 : #define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED         EQU             000000000h
;  RW--V 
;  1375 : #define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED          EQU             000000001h
;  RWIVF 
;  1376 : #define NV_PGRAPH_DEBUG_3_LINEARZ                             16:16 /* RWIVF */
NV_PGRAPH_DEBUG_3_LINEARZ               TEXTEQU         <16:16>
;  RWI-V 
;  1377 : #define NV_PGRAPH_DEBUG_3_LINEARZ_DISABLED               0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_LINEARZ_DISABLED              EQU             000000000h
;  RW--V 
;  1378 : #define NV_PGRAPH_DEBUG_3_LINEARZ_ENABLED                0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_LINEARZ_ENABLED               EQU             000000001h
;  RWIVF 
;  1379 : #define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
NV_PGRAPH_DEBUG_3_DATA_CHECK            TEXTEQU         <20:20>
;  RWI-V 
;  1380 : #define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED           EQU             000000000h
;  RW--V 
;  1381 : #define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED            EQU             000000001h
;  RWIVF 
;  1382 : #define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL               TEXTEQU         <21:21>
;  RWI-V 
;  1383 : #define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED              EQU             000000000h
;  RW--V 
;  1384 : #define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED               EQU             000000001h
;  RWIVF 
;  1385 : #define NV_PGRAPH_DEBUG_3_SPARE1                              24:24 /* RWIVF */
NV_PGRAPH_DEBUG_3_SPARE1                TEXTEQU         <24:24>
;  RWI-V 
;  1386 : #define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_SPARE1_DISABLED               EQU             000000000h
;  RW--V 
;  1387 : #define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                EQU             000000001h
;  RWIVF 
;  1388 : #define NV_PGRAPH_DEBUG_3_SPARE2                              28:28 /* RWIVF */
NV_PGRAPH_DEBUG_3_SPARE2                TEXTEQU         <28:28>
;  RWI-V 
;  1389 : #define NV_PGRAPH_DEBUG_3_SPARE2_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_DEBUG_3_SPARE2_DISABLED               EQU             000000000h
;  RW--V 
;  1390 : #define NV_PGRAPH_DEBUG_3_SPARE2_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_DEBUG_3_SPARE2_ENABLED                EQU             000000001h
;  RW-4R 
;  1391 : #define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
NV_PGRAPH_INTR_0                EQU             000400100h
;  RW-VF 
;  1392 : #define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
NV_PGRAPH_INTR_0_RESERVED               TEXTEQU         <0:0>
;  R---V 
;  1393 : #define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING           EQU             000000000h
;  R---V 
;  1394 : #define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
NV_PGRAPH_INTR_0_RESERVED_PENDING               EQU             000000001h
;  -W--V 
;  1395 : #define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_RESERVED_RESET         EQU             000000001h
;  RWIVF 
;  1396 : #define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
NV_PGRAPH_INTR_0_CONTEXT_SWITCH         TEXTEQU         <4:4>
;  R-I-V 
;  1397 : #define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING             EQU             000000000h
;  R---V 
;  1398 : #define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING         EQU             000000001h
;  -W--V 
;  1399 : #define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET           EQU             000000001h
;  RWIVF 
;  1400 : #define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
NV_PGRAPH_INTR_0_VBLANK         TEXTEQU         <8:8>
;  R-I-V 
;  1401 : #define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING             EQU             000000000h
;  R---V 
;  1402 : #define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
NV_PGRAPH_INTR_0_VBLANK_PENDING         EQU             000000001h
;  -W--V 
;  1403 : #define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_VBLANK_RESET           EQU             000000001h
;  RWIVF 
;  1404 : #define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
NV_PGRAPH_INTR_0_RANGE          TEXTEQU         <12:12>
;  R-I-V 
;  1405 : #define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_RANGE_NOT_PENDING              EQU             000000000h
;  R---V 
;  1406 : #define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
NV_PGRAPH_INTR_0_RANGE_PENDING          EQU             000000001h
;  -W--V 
;  1407 : #define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_RANGE_RESET            EQU             000000001h
;  RWIVF 
;  1408 : #define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
NV_PGRAPH_INTR_0_METHOD_COUNT           TEXTEQU         <16:16>
;  R-I-V 
;  1409 : #define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING               EQU             000000000h
;  R---V 
;  1410 : #define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING           EQU             000000001h
;  -W--V 
;  1411 : #define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_METHOD_COUNT_RESET             EQU             000000001h
;  RWIVF 
;  1412 : #define NV_PGRAPH_INTR_0_FORMAT_                              20:20 /* RWIVF */
NV_PGRAPH_INTR_0_FORMAT_                TEXTEQU         <20:20>
;  R-I-V 
;  1413 : #define NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING              0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING             EQU             000000000h
;  R---V 
;  1414 : #define NV_PGRAPH_INTR_0_FORMAT_PENDING                  0x00000001 /* R---V */
NV_PGRAPH_INTR_0_FORMAT_PENDING         EQU             000000001h
;  -W--V 
;  1415 : #define NV_PGRAPH_INTR_0_FORMAT_RESET                    0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_FORMAT_RESET           EQU             000000001h
;  RWIVF 
;  1416 : #define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
NV_PGRAPH_INTR_0_COMPLEX_CLIP           TEXTEQU         <24:24>
;  R-I-V 
;  1417 : #define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING               EQU             000000000h
;  R---V 
;  1418 : #define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING           EQU             000000001h
;  -W--V 
;  1419 : #define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET             EQU             000000001h
;  RWIVF 
;  1420 : #define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
NV_PGRAPH_INTR_0_NOTIFY         TEXTEQU         <28:28>
;  R-I-V 
;  1421 : #define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING             EQU             000000000h
;  R---V 
;  1422 : #define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
NV_PGRAPH_INTR_0_NOTIFY_PENDING         EQU             000000001h
;  -W--V 
;  1423 : #define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
NV_PGRAPH_INTR_0_NOTIFY_RESET           EQU             000000001h
;  RW-4R 
;  1424 : #define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
NV_PGRAPH_INTR_1                EQU             000400104h
;  RWIVF 
;  1425 : #define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
NV_PGRAPH_INTR_1_METHOD         TEXTEQU         <0:0>
;  R-I-V 
;  1426 : #define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
NV_PGRAPH_INTR_1_METHOD_NOT_PENDING             EQU             000000000h
;  R---V 
;  1427 : #define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
NV_PGRAPH_INTR_1_METHOD_PENDING         EQU             000000001h
;  -W--V 
;  1428 : #define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
NV_PGRAPH_INTR_1_METHOD_RESET           EQU             000000001h
;  RWIVF 
;  1429 : #define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
NV_PGRAPH_INTR_1_DATA           TEXTEQU         <4:4>
;  R-I-V 
;  1430 : #define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
NV_PGRAPH_INTR_1_DATA_NOT_PENDING               EQU             000000000h
;  R---V 
;  1431 : #define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
NV_PGRAPH_INTR_1_DATA_PENDING           EQU             000000001h
;  -W--V 
;  1432 : #define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
NV_PGRAPH_INTR_1_DATA_RESET             EQU             000000001h
;  RWIVF 
;  1433 : #define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
NV_PGRAPH_INTR_1_DOUBLE_NOTIFY          TEXTEQU         <12:12>
;  R-I-V 
;  1434 : #define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING              EQU             000000000h
;  R---V 
;  1435 : #define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING          EQU             000000001h
;  -W--V 
;  1436 : #define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET            EQU             000000001h
;  RWIVF 
;  1437 : #define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
NV_PGRAPH_INTR_1_CTXSW_NOTIFY           TEXTEQU         <16:16>
;  R-I-V 
;  1438 : #define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING               EQU             000000000h
;  R---V 
;  1439 : #define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING           EQU             000000001h
;  -W--V 
;  1440 : #define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET             EQU             000000001h
;  RW-4R 
;  1441 : #define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
NV_PGRAPH_INTR_EN_0             EQU             000400140h
;  RWIVF 
;  1442 : #define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
NV_PGRAPH_INTR_EN_0_RESERVED            TEXTEQU         <0:0>
;  RWI-V 
;  1443 : #define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED           EQU             000000000h
;  RW--V 
;  1444 : #define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED            EQU             000000001h
;  RWIVF 
;  1445 : #define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH              TEXTEQU         <4:4>
;  RWI-V 
;  1446 : #define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED             EQU             000000000h
;  RW--V 
;  1447 : #define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED              EQU             000000001h
;  RWIVF 
;  1448 : #define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
NV_PGRAPH_INTR_EN_0_VBLANK              TEXTEQU         <8:8>
;  RWI-V 
;  1449 : #define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED             EQU             000000000h
;  RW--V 
;  1450 : #define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED              EQU             000000001h
;  RWIVF 
;  1451 : #define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
NV_PGRAPH_INTR_EN_0_RANGE               TEXTEQU         <12:12>
;  RWI-V 
;  1452 : #define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_RANGE_DISABLED              EQU             000000000h
;  RW--V 
;  1453 : #define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_RANGE_ENABLED               EQU             000000001h
;  RWIVF 
;  1454 : #define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
NV_PGRAPH_INTR_EN_0_METHOD_COUNT                TEXTEQU         <16:16>
;  RWI-V 
;  1455 : #define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED               EQU             000000000h
;  RW--V 
;  1456 : #define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED                EQU             000000001h
;  RWIVF 
;  1457 : #define NV_PGRAPH_INTR_EN_0_FORMAT                            20:20 /* RWIVF */
NV_PGRAPH_INTR_EN_0_FORMAT              TEXTEQU         <20:20>
;  RWI-V 
;  1458 : #define NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED             EQU             000000000h
;  RW--V 
;  1459 : #define NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED              EQU             000000001h
;  RWIVF 
;  1460 : #define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                TEXTEQU         <24:24>
;  RWI-V 
;  1461 : #define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED               EQU             000000000h
;  RW--V 
;  1462 : #define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED                EQU             000000001h
;  RWIVF 
;  1463 : #define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
NV_PGRAPH_INTR_EN_0_NOTIFY              TEXTEQU         <28:28>
;  RWI-V 
;  1464 : #define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED             EQU             000000000h
;  RW--V 
;  1465 : #define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED              EQU             000000001h
;  RW-4R 
;  1466 : #define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
NV_PGRAPH_INTR_EN_1             EQU             000400144h
;  RWIVF 
;  1467 : #define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
NV_PGRAPH_INTR_EN_1_METHOD              TEXTEQU         <0:0>
;  RWI-V 
;  1468 : #define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_1_METHOD_DISABLED             EQU             000000000h
;  RW--V 
;  1469 : #define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_1_METHOD_ENABLED              EQU             000000001h
;  RWIVF 
;  1470 : #define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
NV_PGRAPH_INTR_EN_1_DATA                TEXTEQU         <4:4>
;  RWI-V 
;  1471 : #define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_1_DATA_DISABLED               EQU             000000000h
;  RW--V 
;  1472 : #define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_1_DATA_ENABLED                EQU             000000001h
;  RWIVF 
;  1473 : #define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY               TEXTEQU         <12:12>
;  RWI-V 
;  1474 : #define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED              EQU             000000000h
;  RW--V 
;  1475 : #define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED               EQU             000000001h
;  RWIVF 
;  1476 : #define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                TEXTEQU         <16:16>
;  RWI-V 
;  1477 : #define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED               EQU             000000000h
;  RW--V 
;  1478 : #define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED                EQU             000000001h
;  RW-4R 
;  1479 : #define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
NV_PGRAPH_CTX_SWITCH            EQU             000400180h
;  RWIVF 
;  1480 : #define NV_PGRAPH_CTX_SWITCH_COLOR                              2:0 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_COLOR              TEXTEQU         <2:0>
;  RWI-V 
;  1481 : #define NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5                0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5               EQU             000000000h
;  RW--V 
;  1482 : #define NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8                0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8               EQU             000000001h
;  RW--V 
;  1483 : #define NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10             0x00000002 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10            EQU             000000002h
;  RW--V 
;  1484 : #define NV_PGRAPH_CTX_SWITCH_COLOR_Y8                    0x00000003 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_Y8           EQU             000000003h
;  RW--V 
;  1485 : #define NV_PGRAPH_CTX_SWITCH_COLOR_Y16                   0x00000004 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_Y16          EQU             000000004h
;  RW--V 
;  1486 : #define NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08            0x00000005 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08           EQU             000000005h
;  RW--V 
;  1487 : #define NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8            0x00000006 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8           EQU             000000006h
;  RW--V 
;  1488 : #define NV_PGRAPH_CTX_SWITCH_COLOR_Y420                  0x00000007 /* RW--V */
NV_PGRAPH_CTX_SWITCH_COLOR_Y420         EQU             000000007h
;  RWIVF 
;  1489 : #define NV_PGRAPH_CTX_SWITCH_ALPHA                              3:3 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_ALPHA              TEXTEQU         <3:3>
;  RWI-V 
;  1490 : #define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED             EQU             000000000h
;  RW--V 
;  1491 : #define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED              EQU             000000001h
;  RWIVF 
;  1492 : #define NV_PGRAPH_CTX_SWITCH_SPARE1                             4:4 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_SPARE1             TEXTEQU         <4:4>
;  RWI-V 
;  1493 : #define NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED            EQU             000000000h
;  RW--V 
;  1494 : #define NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED              0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED             EQU             000000001h
;  RWIVF 
;  1495 : #define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                        8:8 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                TEXTEQU         <8:8>
;  RWI-V 
;  1496 : #define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED               EQU             000000000h
;  RW--V 
;  1497 : #define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED                EQU             000000001h
;  RWXVF 
;  1498 : #define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS                         9:9 /* RWXVF */
NV_PGRAPH_CTX_SWITCH_DAC_BYPASS         TEXTEQU         <9:9>
;  RWI-V 
;  1499 : #define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED         0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED                EQU             000000000h
;  RW--V 
;  1500 : #define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED          0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED         EQU             000000001h
;  RWIVF 
;  1501 : #define NV_PGRAPH_CTX_SWITCH_SPARE2                           10:10 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_SPARE2             TEXTEQU         <10:10>
;  RWI-V 
;  1502 : #define NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED            EQU             000000000h
;  RW--V 
;  1503 : #define NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED              0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED             EQU             000000001h
;  RWIVF 
;  1504 : #define NV_PGRAPH_CTX_SWITCH_ZWRITE                           12:12 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_ZWRITE             TEXTEQU         <12:12>
;  RWI-V 
;  1505 : #define NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED            EQU             000000000h
;  RW--V 
;  1506 : #define NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED              0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED             EQU             000000001h
;  RWIVF 
;  1507 : #define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                       13:13 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_CHROMA_KEY         TEXTEQU         <13:13>
;  RWI-V 
;  1508 : #define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED                EQU             000000000h
;  RW--V 
;  1509 : #define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED         EQU             000000001h
;  RWIVF 
;  1510 : #define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                       14:14 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_PLANE_MASK         TEXTEQU         <14:14>
;  RWI-V 
;  1511 : #define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED                EQU             000000000h
;  RW--V 
;  1512 : #define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED         EQU             000000001h
;  RWIVF 
;  1513 : #define NV_PGRAPH_CTX_SWITCH_USER_CLIP                        15:15 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_USER_CLIP          TEXTEQU         <15:15>
;  RWI-V 
;  1514 : #define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED         EQU             000000000h
;  RW--V 
;  1515 : #define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED          EQU             000000001h
;  RWIVF 
;  1516 : #define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER                       17:16 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_SRC_BUFFER         TEXTEQU         <17:16>
;  RWI-V 
;  1517 : #define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0                0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0               EQU             000000000h
;  RW--V 
;  1518 : #define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1                0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1               EQU             000000001h
;  RW--V 
;  1519 : #define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2                0x00000002 /* RW--V */
NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2               EQU             000000002h
;  RW--V 
;  1520 : #define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3                0x00000003 /* RW--V */
NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3               EQU             000000003h
;  RWIVF 
;  1521 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                      20:20 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                TEXTEQU         <20:20>
;  RWI-V 
;  1522 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED               EQU             000000000h
;  RW--V 
;  1523 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED                EQU             000000001h
;  RWIVF 
;  1524 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                      21:21 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                TEXTEQU         <21:21>
;  RWI-V 
;  1525 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED               EQU             000000000h
;  RW--V 
;  1526 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED                EQU             000000001h
;  RWIVF 
;  1527 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                      22:22 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                TEXTEQU         <22:22>
;  RWI-V 
;  1528 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED               EQU             000000000h
;  RW--V 
;  1529 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED                EQU             000000001h
;  RWIVF 
;  1530 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                      23:23 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                TEXTEQU         <23:23>
;  RWI-V 
;  1531 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED               EQU             000000000h
;  RW--V 
;  1532 : #define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED                EQU             000000001h
;  RWIVF 
;  1533 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                     28:24 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG               TEXTEQU         <28:24>
;  RWI-V 
;  1534 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0          0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0         EQU             000000000h
;  RW--V 
;  1535 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC    0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC           EQU             000000001h
;  RW--V 
;  1536 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST    0x00000002 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST           EQU             000000002h
;  RW--V 
;  1537 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC    0x00000003 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC           EQU             000000003h
;  RW--V 
;  1538 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST    0x00000004 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST           EQU             000000004h
;  RW--V 
;  1539 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC    0x00000005 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC           EQU             000000005h
;  RW--V 
;  1540 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST    0x00000006 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST           EQU             000000006h
;  RW--V 
;  1541 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0   0x00000007 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0          EQU             000000007h
;  RW--V 
;  1542 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1   0x00000008 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1          EQU             000000008h
;  RW--V 
;  1543 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT    0x00000009 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT           EQU             000000009h
;  RW--V 
;  1544 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC    0x0000000a /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC           EQU             00000000ah
;  RW--V 
;  1545 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT    0x0000000b /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT           EQU             00000000bh
;  RW--V 
;  1546 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC    0x0000000c /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC           EQU             00000000ch
;  RW--V 
;  1547 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT    0x0000000d /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT           EQU             00000000dh
;  RW--V 
;  1548 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC    0x0000000e /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC           EQU             00000000eh
;  RW--V 
;  1549 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1          0x0000000f /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1         EQU             00000000fh
;  RW--V 
;  1550 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST    0x00000010 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST           EQU             000000010h
;  RW--V 
;  1551 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC    0x00000011 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC           EQU             000000011h
;  RW--V 
;  1552 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST    0x00000012 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST           EQU             000000012h
;  RW--V 
;  1553 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT    0x00000013 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT           EQU             000000013h
;  RW--V 
;  1554 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC    0x00000014 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC           EQU             000000014h
;  RW--V 
;  1555 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT    0x00000015 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT           EQU             000000015h
;  RW--V 
;  1556 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2          0x00000016 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2         EQU             000000016h
;  RW--V 
;  1557 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS     0x00000017 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS            EQU             000000017h
;  RW--V 
;  1558 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0    0x00000018 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0           EQU             000000018h
;  RW--V 
;  1559 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST  0x00000019 /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST         EQU             000000019h
;  RW--V 
;  1560 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC  0x0000001a /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC         EQU             00000001ah
;  RW--V 
;  1561 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1    0x0000001b /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1           EQU             00000001bh
;  RW--V 
;  1562 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2    0x0000001c /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2           EQU             00000001ch
;  RW--V 
;  1563 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC      0x0000001d /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC             EQU             00000001dh
;  RW--V 
;  1564 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3    0x0000001e /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3           EQU             00000001eh
;  RW--V 
;  1565 : #define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4    0x0000001f /* RW--V */
NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4           EQU             00000001fh
;  RWIVF 
;  1566 : #define NV_PGRAPH_CTX_SWITCH_SPARE3                           29:29 /* RWIVF */
NV_PGRAPH_CTX_SWITCH_SPARE3             TEXTEQU         <29:29>
;  RWI-V 
;  1567 : #define NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED            EQU             000000000h
;  RW--V 
;  1568 : #define NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED              0x00000001 /* RW--V */
NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED             EQU             000000001h
;  CWIVF 
;  1569 : #define NV_PGRAPH_CTX_SWITCH_VOLATILE                         31:31 /* CWIVF */
NV_PGRAPH_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  CWI-V 
;  1570 : #define NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* CWI-V */
NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  1571 : #define NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  RW-4A 
;        
;  1572 : #define NV_PGRAPH_CTX_CACHE(i)                   (0x004001a0+(i)*4) /* RW-4A */
;  1573 : #define NV_PGRAPH_CTX_CACHE__SIZE_1                               8 /*       */
NV_PGRAPH_CTX_CACHE__SIZE_1             EQU             8t
;  RWIVF 
;  1574 : #define NV_PGRAPH_CTX_CACHE_COLOR                              2:0  /* RWIVF */
NV_PGRAPH_CTX_CACHE_COLOR               TEXTEQU         <2:0>
;  RWIVF 
;  1575 : #define NV_PGRAPH_CTX_CACHE_ALPHA                              3:3  /* RWIVF */
NV_PGRAPH_CTX_CACHE_ALPHA               TEXTEQU         <3:3>
;  RWIVF 
;  1576 : #define NV_PGRAPH_CTX_CACHE_SPARE1                             4:4  /* RWIVF */
NV_PGRAPH_CTX_CACHE_SPARE1              TEXTEQU         <4:4>
;  RWIVF 
;  1577 : #define NV_PGRAPH_CTX_CACHE_MONO_FORMAT                        8:8  /* RWIVF */
NV_PGRAPH_CTX_CACHE_MONO_FORMAT         TEXTEQU         <8:8>
;  RWXVF 
;  1578 : #define NV_PGRAPH_CTX_CACHE_DAC_BYPASS                         9:9  /* RWXVF */
NV_PGRAPH_CTX_CACHE_DAC_BYPASS          TEXTEQU         <9:9>
;  RWXVF 
;  1579 : #define NV_PGRAPH_CTX_CACHE_SPARE2                            10:10 /* RWXVF */
NV_PGRAPH_CTX_CACHE_SPARE2              TEXTEQU         <10:10>
;  RWIVF 
;  1580 : #define NV_PGRAPH_CTX_CACHE_ZWRITE                            12:12 /* RWIVF */
NV_PGRAPH_CTX_CACHE_ZWRITE              TEXTEQU         <12:12>
;  RWIVF 
;  1581 : #define NV_PGRAPH_CTX_CACHE_CHROMA_KEY                        13:13 /* RWIVF */
NV_PGRAPH_CTX_CACHE_CHROMA_KEY          TEXTEQU         <13:13>
;  RWIVF 
;  1582 : #define NV_PGRAPH_CTX_CACHE_PLANE_MASK                        14:14 /* RWIVF */
NV_PGRAPH_CTX_CACHE_PLANE_MASK          TEXTEQU         <14:14>
;  RWIVF 
;  1583 : #define NV_PGRAPH_CTX_CACHE_USER_CLIP                         15:15 /* RWIVF */
NV_PGRAPH_CTX_CACHE_USER_CLIP           TEXTEQU         <15:15>
;  RWIVF 
;  1584 : #define NV_PGRAPH_CTX_CACHE_SRC_BUFFER                        17:16 /* RWIVF */
NV_PGRAPH_CTX_CACHE_SRC_BUFFER          TEXTEQU         <17:16>
;  RWIVF 
;  1585 : #define NV_PGRAPH_CTX_CACHE_DST_BUFFER0                       20:20 /* RWIVF */
NV_PGRAPH_CTX_CACHE_DST_BUFFER0         TEXTEQU         <20:20>
;  RWIVF 
;  1586 : #define NV_PGRAPH_CTX_CACHE_DST_BUFFER1                       21:21 /* RWIVF */
NV_PGRAPH_CTX_CACHE_DST_BUFFER1         TEXTEQU         <21:21>
;  RWIVF 
;  1587 : #define NV_PGRAPH_CTX_CACHE_DST_BUFFER2                       22:22 /* RWIVF */
NV_PGRAPH_CTX_CACHE_DST_BUFFER2         TEXTEQU         <22:22>
;  RWIVF 
;  1588 : #define NV_PGRAPH_CTX_CACHE_DST_BUFFER3                       23:23 /* RWIVF */
NV_PGRAPH_CTX_CACHE_DST_BUFFER3         TEXTEQU         <23:23>
;  RWIVF 
;  1589 : #define NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                      28:24 /* RWIVF */
NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                TEXTEQU         <28:24>
;  RWXVF 
;  1590 : #define NV_PGRAPH_CTX_CACHE_SPARE3                            29:29 /* RWXVF */
NV_PGRAPH_CTX_CACHE_SPARE3              TEXTEQU         <29:29>
;  RW-4R 
;  1591 : #define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
NV_PGRAPH_CTX_CONTROL           EQU             000400190h
;  RWIVF 
;  1592 : #define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME              TEXTEQU         <1:0>
;  RWI-V 
;  1593 : #define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US         EQU             000000000h
;  RW--V 
;  1594 : #define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US                EQU             000000001h
;  RW--V 
;  1595 : #define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS          EQU             000000002h
;  RW--V 
;  1596 : #define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS         EQU             000000003h
;  RWIVF 
;  1597 : #define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
NV_PGRAPH_CTX_CONTROL_TIME              TEXTEQU         <8:8>
;  RWI-V 
;  1598 : #define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED              EQU             000000000h
;  RW--V 
;  1599 : #define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED          EQU             000000001h
;  RWIVF 
;  1600 : #define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
NV_PGRAPH_CTX_CONTROL_CHID              TEXTEQU         <16:16>
;  RWI-V 
;  1601 : #define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
NV_PGRAPH_CTX_CONTROL_CHID_INVALID              EQU             000000000h
;  RW--V 
;  1602 : #define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
NV_PGRAPH_CTX_CONTROL_CHID_VALID                EQU             000000001h
;  R--VF 
;  1603 : #define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
NV_PGRAPH_CTX_CONTROL_SWITCH            TEXTEQU         <20:20>
;  R---V 
;  1604 : #define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE                EQU             000000000h
;  R---V 
;  1605 : #define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE          EQU             000000001h
;  RWIVF 
;  1606 : #define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
NV_PGRAPH_CTX_CONTROL_SWITCHING         TEXTEQU         <24:24>
;  RWI-V 
;  1607 : #define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE            EQU             000000000h
;  RW--V 
;  1608 : #define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY            EQU             000000001h
;  RWIVF 
;  1609 : #define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
NV_PGRAPH_CTX_CONTROL_DEVICE            TEXTEQU         <28:28>
;  RWI-V 
;  1610 : #define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED           EQU             000000000h
;  RW--V 
;  1611 : #define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED            EQU             000000001h
;  RW-4R 
;  1612 : #define NV_PGRAPH_CTX_USER                               0x00400194 /* RW-4R */
NV_PGRAPH_CTX_USER              EQU             000400194h
;  RWXVF 
;  1613 : #define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWXVF */
NV_PGRAPH_CTX_USER_SUBCH                TEXTEQU         <15:13>
;  RWXVF 
;  1614 : #define NV_PGRAPH_CTX_USER_CLASS                              20:16 /* RWXVF */
NV_PGRAPH_CTX_USER_CLASS                TEXTEQU         <20:16>
;  RWXVF 
;  1615 : #define NV_PGRAPH_CTX_USER_CHID                               30:24 /* RWXVF */
NV_PGRAPH_CTX_USER_CHID         TEXTEQU         <30:24>
;  RW-4R 
;  1616 : #define NV_PGRAPH_FIFO                                   0x004006A4 /* RW-4R */
NV_PGRAPH_FIFO          EQU             0004006a4h
;  RWIVF 
;  1617 : #define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
NV_PGRAPH_FIFO_ACCESS           TEXTEQU         <0:0>
;  RW--V 
;  1618 : #define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
NV_PGRAPH_FIFO_ACCESS_DISABLED          EQU             000000000h
;  RWI-V 
;  1619 : #define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
NV_PGRAPH_FIFO_ACCESS_ENABLED           EQU             000000001h
;  R--4R 
;  1620 : #define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
NV_PGRAPH_STATUS                EQU             0004006b0h
;  R-IVF 
;  1621 : #define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
NV_PGRAPH_STATUS_STATE          TEXTEQU         <0:0>
;  R-I-V 
;  1622 : #define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_STATE_IDLE             EQU             000000000h
;  R---V 
;  1623 : #define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
NV_PGRAPH_STATUS_STATE_BUSY             EQU             000000001h
;  R-IVF 
;  1624 : #define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
NV_PGRAPH_STATUS_XY_LOGIC               TEXTEQU         <4:4>
;  R-I-V 
;  1625 : #define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_XY_LOGIC_IDLE          EQU             000000000h
;  R---V 
;  1626 : #define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
NV_PGRAPH_STATUS_XY_LOGIC_BUSY          EQU             000000001h
;  R-IVF 
;  1627 : #define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
NV_PGRAPH_STATUS_PORT_NOTIFY            TEXTEQU         <8:8>
;  R-I-V 
;  1628 : #define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE               EQU             000000000h
;  R---V 
;  1629 : #define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY               EQU             000000001h
;  R-IVF 
;  1630 : #define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
NV_PGRAPH_STATUS_PORT_REGISTER          TEXTEQU         <12:12>
;  R-I-V 
;  1631 : #define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_PORT_REGISTER_IDLE             EQU             000000000h
;  R---V 
;  1632 : #define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
NV_PGRAPH_STATUS_PORT_REGISTER_BUSY             EQU             000000001h
;  R-IVF 
;  1633 : #define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
NV_PGRAPH_STATUS_PORT_DMA               TEXTEQU         <16:16>
;  R-I-V 
;  1634 : #define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_PORT_DMA_IDLE          EQU             000000000h
;  R---V 
;  1635 : #define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
NV_PGRAPH_STATUS_PORT_DMA_BUSY          EQU             000000001h
;  R-IVF 
;  1636 : #define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
NV_PGRAPH_STATUS_DMA_ENGINE             TEXTEQU         <17:17>
;  R-I-V 
;  1637 : #define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                EQU             000000000h
;  R---V 
;  1638 : #define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                EQU             000000001h
;  R-IVF 
;  1639 : #define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
NV_PGRAPH_STATUS_DMA_NOTIFY             TEXTEQU         <20:20>
;  R-I-V 
;  1640 : #define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                EQU             000000000h
;  R---V 
;  1641 : #define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                EQU             000000001h
;  R-IVF 
;  1642 : #define NV_PGRAPH_STATUS_3D                                   24:24 /* R-IVF */
NV_PGRAPH_STATUS_3D             TEXTEQU         <24:24>
;  R-I-V 
;  1643 : #define NV_PGRAPH_STATUS_3D_IDLE                         0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_3D_IDLE                EQU             000000000h
;  R---V 
;  1644 : #define NV_PGRAPH_STATUS_3D_BUSY                         0x00000001 /* R---V */
NV_PGRAPH_STATUS_3D_BUSY                EQU             000000001h
;  R-IVF 
;  1645 : #define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
NV_PGRAPH_STATUS_CACHE          TEXTEQU         <25:25>
;  R-I-V 
;  1646 : #define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_CACHE_IDLE             EQU             000000000h
;  R---V 
;  1647 : #define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
NV_PGRAPH_STATUS_CACHE_BUSY             EQU             000000001h
;  R-IVF 
;  1648 : #define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
NV_PGRAPH_STATUS_LIGHTING               TEXTEQU         <26:26>
;  R-I-V 
;  1649 : #define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_LIGHTING_IDLE          EQU             000000000h
;  R---V 
;  1650 : #define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
NV_PGRAPH_STATUS_LIGHTING_BUSY          EQU             000000001h
;  R-IVF 
;  1651 : #define NV_PGRAPH_STATUS_ZFIFO                                27:27 /* R-IVF */
NV_PGRAPH_STATUS_ZFIFO          TEXTEQU         <27:27>
;  R-I-V 
;  1652 : #define NV_PGRAPH_STATUS_ZFIFO_IDLE                      0x00000000 /* R-I-V */
NV_PGRAPH_STATUS_ZFIFO_IDLE             EQU             000000000h
;  R---V 
;  1653 : #define NV_PGRAPH_STATUS_ZFIFO_BUSY                      0x00000001 /* R---V */
NV_PGRAPH_STATUS_ZFIFO_BUSY             EQU             000000001h
;  R--4R 
;  1654 : #define NV_PGRAPH_TRAPPED_ADDR                           0x004006B4 /* R--4R */
NV_PGRAPH_TRAPPED_ADDR          EQU             0004006b4h
;  R-XUF 
;  1655 : #define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
NV_PGRAPH_TRAPPED_ADDR_MTHD             TEXTEQU         <12:2>
;  R-XUF 
;  1656 : #define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
NV_PGRAPH_TRAPPED_ADDR_SUBCH            TEXTEQU         <15:13>
;  R-XUF 
;  1657 : #define NV_PGRAPH_TRAPPED_ADDR_CLASS                          20:16 /* R-XUF */
NV_PGRAPH_TRAPPED_ADDR_CLASS            TEXTEQU         <20:16>
;  R-XUF 
;  1658 : #define NV_PGRAPH_TRAPPED_ADDR_CHID                           30:24 /* R-XUF */
NV_PGRAPH_TRAPPED_ADDR_CHID             TEXTEQU         <30:24>
;  R--4R 
;  1659 : #define NV_PGRAPH_TRAPPED_DATA                           0x004006B8 /* R--4R */
NV_PGRAPH_TRAPPED_DATA          EQU             0004006b8h
;  R-XVF 
;  1660 : #define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
NV_PGRAPH_TRAPPED_DATA_VALUE            TEXTEQU         <31:0>
;  R--4R 
;  1661 : #define NV_PGRAPH_TRAPPED_INST                           0x004006BC /* R--4R */
NV_PGRAPH_TRAPPED_INST          EQU             0004006bch
;  R-XVF 
;  1662 : #define NV_PGRAPH_TRAPPED_INST_VALUE                           15:0 /* R-XVF */
NV_PGRAPH_TRAPPED_INST_VALUE            TEXTEQU         <15:0>
;  RW-4R 
;  1663 : #define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
NV_PGRAPH_CLIP_MISC             EQU             0004006a0h
;  RWIUF 
;  1664 : #define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
NV_PGRAPH_CLIP_MISC_REGIONS             TEXTEQU         <1:0>
;  RWI-V 
;  1665 : #define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED            EQU             000000000h
;  RW--V 
;  1666 : #define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
NV_PGRAPH_CLIP_MISC_REGIONS_1           EQU             000000001h
;  RW--V 
;  1667 : #define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
NV_PGRAPH_CLIP_MISC_REGIONS_2           EQU             000000002h
;  RWIVF 
;  1668 : #define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
NV_PGRAPH_CLIP_MISC_RENDER              TEXTEQU         <4:4>
;  RWI-V 
;  1669 : #define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED             EQU             000000000h
;  RW--V 
;  1670 : #define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED             EQU             000000001h
;  RWIVF 
;  1671 : #define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
NV_PGRAPH_CLIP_MISC_COMPLEX             TEXTEQU         <8:8>
;  RWI-V 
;  1672 : #define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED            EQU             000000000h
;  RW--V 
;  1673 : #define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED             EQU             000000001h
;  RW-4R 
;  1674 : #define NV_PGRAPH_SRC_CANVAS_MIN                         0x00400550 /* RW-4R */
NV_PGRAPH_SRC_CANVAS_MIN                EQU             000400550h
;  RWXUF 
;  1675 : #define NV_PGRAPH_SRC_CANVAS_MIN_X                             10:0 /* RWXUF */
NV_PGRAPH_SRC_CANVAS_MIN_X              TEXTEQU         <10:0>
;  RWXUF 
;  1676 : #define NV_PGRAPH_SRC_CANVAS_MIN_Y                            29:16 /* RWXUF */
NV_PGRAPH_SRC_CANVAS_MIN_Y              TEXTEQU         <29:16>
;  RW-4R 
;  1677 : #define NV_PGRAPH_DST_CANVAS_MIN                         0x00400558 /* RW-4R */
NV_PGRAPH_DST_CANVAS_MIN                EQU             000400558h
;  RWXUF 
;  1678 : #define NV_PGRAPH_DST_CANVAS_MIN_X                             10:0 /* RWXUF */
NV_PGRAPH_DST_CANVAS_MIN_X              TEXTEQU         <10:0>
;  RWXUF 
;  1679 : #define NV_PGRAPH_DST_CANVAS_MIN_Y                            29:16 /* RWXUF */
NV_PGRAPH_DST_CANVAS_MIN_Y              TEXTEQU         <29:16>
;  RW-4R 
;  1680 : #define NV_PGRAPH_SRC_CANVAS_MAX                         0x00400554 /* RW-4R */
NV_PGRAPH_SRC_CANVAS_MAX                EQU             000400554h
;  RWXUF 
;  1681 : #define NV_PGRAPH_SRC_CANVAS_MAX_X                             10:0 /* RWXUF */
NV_PGRAPH_SRC_CANVAS_MAX_X              TEXTEQU         <10:0>
;  RWXUF 
;  1682 : #define NV_PGRAPH_SRC_CANVAS_MAX_Y                            29:16 /* RWXUF */
NV_PGRAPH_SRC_CANVAS_MAX_Y              TEXTEQU         <29:16>
;  RW-4R 
;  1683 : #define NV_PGRAPH_DST_CANVAS_MAX                         0x0040055C /* RW-4R */
NV_PGRAPH_DST_CANVAS_MAX                EQU             00040055ch
;  RWXUF 
;  1684 : #define NV_PGRAPH_DST_CANVAS_MAX_X                             10:0 /* RWXUF */
NV_PGRAPH_DST_CANVAS_MAX_X              TEXTEQU         <10:0>
;  RWXUF 
;  1685 : #define NV_PGRAPH_DST_CANVAS_MAX_Y                            29:16 /* RWXUF */
NV_PGRAPH_DST_CANVAS_MAX_Y              TEXTEQU         <29:16>
;  RW-4R 
;  1686 : #define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
NV_PGRAPH_CLIP0_MIN             EQU             000400690h
;  RWXSF 
;  1687 : #define NV_PGRAPH_CLIP0_MIN_X                                  10:0 /* RWXSF */
NV_PGRAPH_CLIP0_MIN_X           TEXTEQU         <10:0>
;  RWXSF 
;  1688 : #define NV_PGRAPH_CLIP0_MIN_Y                                 27:16 /* RWXSF */
NV_PGRAPH_CLIP0_MIN_Y           TEXTEQU         <27:16>
;  RW-4R 
;  1689 : #define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
NV_PGRAPH_CLIP1_MIN             EQU             000400698h
;  RWXSF 
;  1690 : #define NV_PGRAPH_CLIP1_MIN_X                                  10:0 /* RWXSF */
NV_PGRAPH_CLIP1_MIN_X           TEXTEQU         <10:0>
;  RWXSF 
;  1691 : #define NV_PGRAPH_CLIP1_MIN_Y                                 27:16 /* RWXSF */
NV_PGRAPH_CLIP1_MIN_Y           TEXTEQU         <27:16>
;  RW-4R 
;  1692 : #define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
NV_PGRAPH_CLIP0_MAX             EQU             000400694h
;  RWXSF 
;  1693 : #define NV_PGRAPH_CLIP0_MAX_X                                  10:0 /* RWXSF */
NV_PGRAPH_CLIP0_MAX_X           TEXTEQU         <10:0>
;  RWXSF 
;  1694 : #define NV_PGRAPH_CLIP0_MAX_Y                                 27:16 /* RWXSF */
NV_PGRAPH_CLIP0_MAX_Y           TEXTEQU         <27:16>
;  RW-4R 
;  1695 : #define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
NV_PGRAPH_CLIP1_MAX             EQU             00040069ch
;  RWXSF 
;  1696 : #define NV_PGRAPH_CLIP1_MAX_X                                  10:0 /* RWXSF */
NV_PGRAPH_CLIP1_MAX_X           TEXTEQU         <10:0>
;  RWXSF 
;  1697 : #define NV_PGRAPH_CLIP1_MAX_Y                                 27:16 /* RWXSF */
NV_PGRAPH_CLIP1_MAX_Y           TEXTEQU         <27:16>
;  RW-4R 
;  1698 : #define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
NV_PGRAPH_DMA           EQU             000400680h
;  RWXUF 
;  1699 : #define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
NV_PGRAPH_DMA_INSTANCE          TEXTEQU         <15:0>
;  RW-4R 
;  1700 : #define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
NV_PGRAPH_NOTIFY                EQU             000400684h
;  RWXUF 
;  1701 : #define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
NV_PGRAPH_NOTIFY_INSTANCE               TEXTEQU         <15:0>
;  RWIVF 
;  1702 : #define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
NV_PGRAPH_NOTIFY_REQ            TEXTEQU         <16:16>
;  RWI-V 
;  1703 : #define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                EQU             000000000h
;  RW--V 
;  1704 : #define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
NV_PGRAPH_NOTIFY_REQ_PENDING            EQU             000000001h
;  RWIVF 
;  1705 : #define NV_PGRAPH_NOTIFY_TYPE                                 23:20 /* RWIVF */
NV_PGRAPH_NOTIFY_TYPE           TEXTEQU         <23:20>
;  RWI-V 
;  1706 : #define NV_PGRAPH_NOTIFY_TYPE_HW                         0x00000000 /* RWI-V */
NV_PGRAPH_NOTIFY_TYPE_HW                EQU             000000000h
;  RW--V 
;  1707 : #define NV_PGRAPH_NOTIFY_TYPE_SW_1                       0x00000001 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_1              EQU             000000001h
;  RW--V 
;  1708 : #define NV_PGRAPH_NOTIFY_TYPE_SW_2                       0x00000002 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_2              EQU             000000002h
;  RW--V 
;  1709 : #define NV_PGRAPH_NOTIFY_TYPE_SW_3                       0x00000003 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_3              EQU             000000003h
;  RW--V 
;  1710 : #define NV_PGRAPH_NOTIFY_TYPE_SW_4                       0x00000004 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_4              EQU             000000004h
;  RW--V 
;  1711 : #define NV_PGRAPH_NOTIFY_TYPE_SW_5                       0x00000005 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_5              EQU             000000005h
;  RW--V 
;  1712 : #define NV_PGRAPH_NOTIFY_TYPE_SW_6                       0x00000006 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_6              EQU             000000006h
;  RW--V 
;  1713 : #define NV_PGRAPH_NOTIFY_TYPE_SW_7                       0x00000007 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_7              EQU             000000007h
;  RW--V 
;  1714 : #define NV_PGRAPH_NOTIFY_TYPE_SW_8                       0x00000008 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_8              EQU             000000008h
;  RW--V 
;  1715 : #define NV_PGRAPH_NOTIFY_TYPE_SW_9                       0x00000009 /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_9              EQU             000000009h
;  RW--V 
;  1716 : #define NV_PGRAPH_NOTIFY_TYPE_SW_10                      0x0000000A /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_10             EQU             00000000ah
;  RW--V 
;  1717 : #define NV_PGRAPH_NOTIFY_TYPE_SW_11                      0x0000000B /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_11             EQU             00000000bh
;  RW--V 
;  1718 : #define NV_PGRAPH_NOTIFY_TYPE_SW_12                      0x0000000C /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_12             EQU             00000000ch
;  RW--V 
;  1719 : #define NV_PGRAPH_NOTIFY_TYPE_SW_13                      0x0000000D /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_13             EQU             00000000dh
;  RW--V 
;  1720 : #define NV_PGRAPH_NOTIFY_TYPE_SW_14                      0x0000000E /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_14             EQU             00000000eh
;  RW--V 
;  1721 : #define NV_PGRAPH_NOTIFY_TYPE_SW_15                      0x0000000F /* RW--V */
NV_PGRAPH_NOTIFY_TYPE_SW_15             EQU             00000000fh
;  RW-4R 
;  1722 : #define NV_PGRAPH_INSTANCE                               0x00400688 /* RW-4R */
NV_PGRAPH_INSTANCE              EQU             000400688h
;  RWXUF 
;  1723 : #define NV_PGRAPH_INSTANCE_TAG                                 15:0 /* RWXUF */
NV_PGRAPH_INSTANCE_TAG          TEXTEQU         <15:0>
;  RWI-V 
;  1724 : #define NV_PGRAPH_INSTANCE_TAG_INVALID                   0x00000000 /* RWI-V */
NV_PGRAPH_INSTANCE_TAG_INVALID          EQU             000000000h
;  RW-4R 
;  1725 : #define NV_PGRAPH_MEMFMT                                 0x0040068C /* RW-4R */
NV_PGRAPH_MEMFMT                EQU             00040068ch
;  RWXUF 
;  1726 : #define NV_PGRAPH_MEMFMT_INSTANCE                              15:0 /* RWXUF */
NV_PGRAPH_MEMFMT_INSTANCE               TEXTEQU         <15:0>
;  RWIVF 
;  1727 : #define NV_PGRAPH_MEMFMT_LINEAR                               16:16 /* RWIVF */
NV_PGRAPH_MEMFMT_LINEAR         TEXTEQU         <16:16>
;  RW--V 
;  1728 : #define NV_PGRAPH_MEMFMT_LINEAR_OUT                      0x00000000 /* RW--V */
NV_PGRAPH_MEMFMT_LINEAR_OUT             EQU             000000000h
;  RW--V 
;  1729 : #define NV_PGRAPH_MEMFMT_LINEAR_IN                       0x00000001 /* RW--V */
NV_PGRAPH_MEMFMT_LINEAR_IN              EQU             000000001h
;  RW-4R 
;  1730 : #define NV_PGRAPH_BOFFSET0                               0x00400630 /* RW-4R */
NV_PGRAPH_BOFFSET0              EQU             000400630h
;  RWIUF 
;  1731 : #define NV_PGRAPH_BOFFSET0_LINADRS                             22:0 /* RWIUF */
NV_PGRAPH_BOFFSET0_LINADRS              TEXTEQU         <22:0>
;  RWI-V 
;  1732 : #define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
NV_PGRAPH_BOFFSET0_LINADRS_0            EQU             000000000h
;  RW-4R 
;  1733 : #define NV_PGRAPH_BOFFSET1                               0x00400634 /* RW-4R */
NV_PGRAPH_BOFFSET1              EQU             000400634h
;  RWIUF 
;  1734 : #define NV_PGRAPH_BOFFSET1_LINADRS                             22:0 /* RWIUF */
NV_PGRAPH_BOFFSET1_LINADRS              TEXTEQU         <22:0>
;  RWI-V 
;  1735 : #define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
NV_PGRAPH_BOFFSET1_LINADRS_0            EQU             000000000h
;  RW-4R 
;  1736 : #define NV_PGRAPH_BOFFSET2                               0x00400638 /* RW-4R */
NV_PGRAPH_BOFFSET2              EQU             000400638h
;  RWIUF 
;  1737 : #define NV_PGRAPH_BOFFSET2_LINADRS                             22:0 /* RWIUF */
NV_PGRAPH_BOFFSET2_LINADRS              TEXTEQU         <22:0>
;  RWI-V 
;  1738 : #define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
NV_PGRAPH_BOFFSET2_LINADRS_0            EQU             000000000h
;  RW-4R 
;  1739 : #define NV_PGRAPH_BOFFSET3                               0x0040063C /* RW-4R */
NV_PGRAPH_BOFFSET3              EQU             00040063ch
;  RWIUF 
;  1740 : #define NV_PGRAPH_BOFFSET3_LINADRS                             22:0 /* RWIUF */
NV_PGRAPH_BOFFSET3_LINADRS              TEXTEQU         <22:0>
;  RWI-V 
;  1741 : #define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
NV_PGRAPH_BOFFSET3_LINADRS_0            EQU             000000000h
;  RW-4R 
;  1742 : #define NV_PGRAPH_BPITCH0                                0x00400650 /* RW-4R */
NV_PGRAPH_BPITCH0               EQU             000400650h
;  RWXUF 
;  1743 : #define NV_PGRAPH_BPITCH0_VALUE                                15:0 /* RWXUF */
NV_PGRAPH_BPITCH0_VALUE         TEXTEQU         <15:0>
;  RW-4R 
;  1744 : #define NV_PGRAPH_BPITCH1                                0x00400654 /* RW-4R */
NV_PGRAPH_BPITCH1               EQU             000400654h
;  RWXUF 
;  1745 : #define NV_PGRAPH_BPITCH1_VALUE                                15:0 /* RWXUF */
NV_PGRAPH_BPITCH1_VALUE         TEXTEQU         <15:0>
;  RW-4R 
;  1746 : #define NV_PGRAPH_BPITCH2                                0x00400658 /* RW-4R */
NV_PGRAPH_BPITCH2               EQU             000400658h
;  RWXUF 
;  1747 : #define NV_PGRAPH_BPITCH2_VALUE                                15:0 /* RWXUF */
NV_PGRAPH_BPITCH2_VALUE         TEXTEQU         <15:0>
;  RW-4R 
;  1748 : #define NV_PGRAPH_BPITCH3                                0x0040065C /* RW-4R */
NV_PGRAPH_BPITCH3               EQU             00040065ch
;  RWXUF 
;  1749 : #define NV_PGRAPH_BPITCH3_VALUE                                15:0 /* RWXUF */
NV_PGRAPH_BPITCH3_VALUE         TEXTEQU         <15:0>
;  RW-4R 
;  1750 : #define NV_PGRAPH_BPIXEL                                 0x004006a8 /* RW-4R */
NV_PGRAPH_BPIXEL                EQU             0004006a8h
;  RWXVF 
;  1751 : #define NV_PGRAPH_BPIXEL_DEPTH0_FMT                             1:0 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH0_FMT             TEXTEQU         <1:0>
;  RW--V 
;  1752 : #define NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS             0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS            EQU             000000000h
;  RW--V 
;  1753 : #define NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS               0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS              EQU             000000001h
;  RW--V 
;  1754 : #define NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS              0x00000002 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS             EQU             000000002h
;  RW--V 
;  1755 : #define NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS              0x00000003 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS             EQU             000000003h
;  RWXVF 
;  1756 : #define NV_PGRAPH_BPIXEL_DEPTH0                                 2:2 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH0         TEXTEQU         <2:2>
;  RW--V 
;  1757 : #define NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID                0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID               EQU             000000000h
;  RW--V 
;  1758 : #define NV_PGRAPH_BPIXEL_DEPTH0_VALID                    0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH0_VALID           EQU             000000001h
;  RWXVF 
;  1759 : #define NV_PGRAPH_BPIXEL_DEPTH1_FMT                             5:4 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH1_FMT             TEXTEQU         <5:4>
;  RW--V 
;  1760 : #define NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS             0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS            EQU             000000000h
;  RW--V 
;  1761 : #define NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS               0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS              EQU             000000001h
;  RW--V 
;  1762 : #define NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS              0x00000002 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS             EQU             000000002h
;  RW--V 
;  1763 : #define NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS              0x00000003 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS             EQU             000000003h
;  RWXVF 
;  1764 : #define NV_PGRAPH_BPIXEL_DEPTH1                                 6:6 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH1         TEXTEQU         <6:6>
;  RW--V 
;  1765 : #define NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID                0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID               EQU             000000000h
;  RW--V 
;  1766 : #define NV_PGRAPH_BPIXEL_DEPTH1_VALID                    0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH1_VALID           EQU             000000001h
;  RWXVF 
;  1767 : #define NV_PGRAPH_BPIXEL_DEPTH2_FMT                             9:8 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH2_FMT             TEXTEQU         <9:8>
;  RW--V 
;  1768 : #define NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS             0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS            EQU             000000000h
;  RW--V 
;  1769 : #define NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS               0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS              EQU             000000001h
;  RW--V 
;  1770 : #define NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS              0x00000002 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS             EQU             000000002h
;  RW--V 
;  1771 : #define NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS              0x00000003 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS             EQU             000000003h
;  RWXVF 
;  1772 : #define NV_PGRAPH_BPIXEL_DEPTH2                               10:10 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH2         TEXTEQU         <10:10>
;  RW--V 
;  1773 : #define NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID                0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID               EQU             000000000h
;  RW--V 
;  1774 : #define NV_PGRAPH_BPIXEL_DEPTH2_VALID                    0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH2_VALID           EQU             000000001h
;  RWXVF 
;  1775 : #define NV_PGRAPH_BPIXEL_DEPTH3_FMT                           13:12 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH3_FMT             TEXTEQU         <13:12>
;  RW--V 
;  1776 : #define NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS             0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS            EQU             000000000h
;  RW--V 
;  1777 : #define NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS               0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS              EQU             000000001h
;  RW--V 
;  1778 : #define NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS              0x00000002 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS             EQU             000000002h
;  RW--V 
;  1779 : #define NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS              0x00000003 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS             EQU             000000003h
;  RWXVF 
;  1780 : #define NV_PGRAPH_BPIXEL_DEPTH3                               14:14 /* RWXVF */
NV_PGRAPH_BPIXEL_DEPTH3         TEXTEQU         <14:14>
;  RW--V 
;  1781 : #define NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID                0x00000000 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID               EQU             000000000h
;  RW--V 
;  1782 : #define NV_PGRAPH_BPIXEL_DEPTH3_VALID                    0x00000001 /* RW--V */
NV_PGRAPH_BPIXEL_DEPTH3_VALID           EQU             000000001h
;  RW-4R 
;  1783 : #define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
NV_PGRAPH_PATT_COLOR0_0         EQU             000400600h
;  RWXUF 
;  1784 : #define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
NV_PGRAPH_PATT_COLOR0_0_BLUE            TEXTEQU         <9:0>
;  RWXUF 
;  1785 : #define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
NV_PGRAPH_PATT_COLOR0_0_GREEN           TEXTEQU         <19:10>
;  RWXUF 
;  1786 : #define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
NV_PGRAPH_PATT_COLOR0_0_RED             TEXTEQU         <29:20>
;  RW-4R 
;  1787 : #define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
NV_PGRAPH_PATT_COLOR0_1         EQU             000400604h
;  RWXUF 
;  1788 : #define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
NV_PGRAPH_PATT_COLOR0_1_ALPHA           TEXTEQU         <7:0>
;  RW-4R 
;  1789 : #define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
NV_PGRAPH_PATT_COLOR1_0         EQU             000400608h
;  RWXUF 
;  1790 : #define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
NV_PGRAPH_PATT_COLOR1_0_BLUE            TEXTEQU         <9:0>
;  RWXUF 
;  1791 : #define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
NV_PGRAPH_PATT_COLOR1_0_GREEN           TEXTEQU         <19:10>
;  RWXUF 
;  1792 : #define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
NV_PGRAPH_PATT_COLOR1_0_RED             TEXTEQU         <29:20>
;  RW-4R 
;  1793 : #define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
NV_PGRAPH_PATT_COLOR1_1         EQU             00040060ch
;  RWXUF 
;  1794 : #define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
NV_PGRAPH_PATT_COLOR1_1_ALPHA           TEXTEQU         <7:0>
;  RW-4A 
;        
;  1795 : #define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
;  1796 : #define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
NV_PGRAPH_PATTERN__SIZE_1               EQU             2t
;  RWXVF 
;  1797 : #define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
NV_PGRAPH_PATTERN_BITMAP                TEXTEQU         <31:0>
;  RW-4R 
;  1798 : #define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
NV_PGRAPH_PATTERN_SHAPE         EQU             000400618h
;  RWXVF 
;  1799 : #define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
NV_PGRAPH_PATTERN_SHAPE_VALUE           TEXTEQU         <1:0>
;  RW--V 
;  1800 : #define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8               EQU             000000000h
;  RW--V 
;  1801 : #define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1              EQU             000000001h
;  RW--V 
;  1802 : #define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64              EQU             000000002h
;  RW-4R 
;  1803 : #define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
NV_PGRAPH_MONO_COLOR0           EQU             00040061ch
;  RWXUF 
;  1804 : #define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
NV_PGRAPH_MONO_COLOR0_BLUE              TEXTEQU         <9:0>
;  RWXUF 
;  1805 : #define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
NV_PGRAPH_MONO_COLOR0_GREEN             TEXTEQU         <19:10>
;  RWXUF 
;  1806 : #define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
NV_PGRAPH_MONO_COLOR0_RED               TEXTEQU         <29:20>
;  RWXUF 
;  1807 : #define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
NV_PGRAPH_MONO_COLOR0_ALPHA             TEXTEQU         <30:30>
;  RW-4R 
;  1808 : #define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
NV_PGRAPH_ROP3          EQU             000400624h
;  RWXVF 
;  1809 : #define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
NV_PGRAPH_ROP3_VALUE            TEXTEQU         <7:0>
;  RW-4R 
;  1810 : #define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
NV_PGRAPH_PLANE_MASK            EQU             000400628h
;  RWXUF 
;  1811 : #define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
NV_PGRAPH_PLANE_MASK_BLUE               TEXTEQU         <9:0>
;  RWXUF 
;  1812 : #define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
NV_PGRAPH_PLANE_MASK_GREEN              TEXTEQU         <19:10>
;  RWXUF 
;  1813 : #define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
NV_PGRAPH_PLANE_MASK_RED                TEXTEQU         <29:20>
;  RWXUF 
;  1814 : #define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
NV_PGRAPH_PLANE_MASK_ALPHA              TEXTEQU         <30:30>
;  RW-4R 
;  1815 : #define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
NV_PGRAPH_CHROMA                EQU             00040062ch
;  RWXUF 
;  1816 : #define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
NV_PGRAPH_CHROMA_BLUE           TEXTEQU         <9:0>
;  RWXUF 
;  1817 : #define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
NV_PGRAPH_CHROMA_GREEN          TEXTEQU         <19:10>
;  RWXUF 
;  1818 : #define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
NV_PGRAPH_CHROMA_RED            TEXTEQU         <29:20>
;  RWXUF 
;  1819 : #define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
NV_PGRAPH_CHROMA_ALPHA          TEXTEQU         <30:30>
;  RW-4R 
;  1820 : #define NV_PGRAPH_BETA                                   0x00400640 /* RW-4R */
NV_PGRAPH_BETA          EQU             000400640h
;  RWXUF 
;  1821 : #define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
NV_PGRAPH_BETA_VALUE_FRACTION           TEXTEQU         <30:23>
;  RW-4R 
;  1822 : #define NV_PGRAPH_CONTROL_OUT                            0x00400644 /* RW-4R */
NV_PGRAPH_CONTROL_OUT           EQU             000400644h
;  -W-UF 
;  1823 : #define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_INTERPOLATOR              TEXTEQU         <1:0>
;  -W-UV 
;  1824 : #define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH          EQU             000000000h
;  -W-UV 
;  1825 : #define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS               EQU             000000001h
;  -W-UV 
;  1826 : #define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH          EQU             000000002h
;  -W-UF 
;  1827 : #define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_WRAP_U            TEXTEQU         <5:4>
;  -W-UV 
;  1828 : #define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL                EQU             000000000h
;  -W-UV 
;  1829 : #define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP               EQU             000000001h
;  -W-UV 
;  1830 : #define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR             EQU             000000002h
;  -W-UV 
;  1831 : #define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP              EQU             000000003h
;  -W-UF 
;  1832 : #define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_WRAP_V            TEXTEQU         <7:6>
;  -W-UV 
;  1833 : #define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL                EQU             000000000h
;  -W-UV 
;  1834 : #define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP               EQU             000000001h
;  -W-UV 
;  1835 : #define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR             EQU             000000002h
;  -W-UV 
;  1836 : #define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP              EQU             000000003h
;  -W-UF 
;  1837 : #define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT              TEXTEQU         <8:8>
;  -W-UV 
;  1838 : #define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8          EQU             000000000h
;  -W-UV 
;  1839 : #define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8          EQU             000000001h
;  -W-UF 
;  1840 : #define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_CULLING           TEXTEQU         <13:12>
;  -W-UV 
;  1841 : #define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_CULLING_NONE              EQU             000000001h
;  -W-UV 
;  1842 : #define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE         EQU             000000002h
;  -W-UV 
;  1843 : #define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE          EQU             000000003h
;  -W-UF 
;  1844 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE              TEXTEQU         <19:16>
;  -W-UV 
;  1845 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE                EQU             000000001h
;  -W-UV 
;  1846 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT           EQU             000000002h
;  -W-UV 
;  1847 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ           EQU             000000003h
;  -W-UV 
;  1848 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE           EQU             000000004h
;  -W-UV 
;  1849 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT           EQU             000000005h
;  -W-UV 
;  1850 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE           EQU             000000006h
;  -W-UV 
;  1851 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE           EQU             000000007h
;  -W-UV 
;  1852 : #define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE         EQU             000000008h
;  -W-UF 
;  1853 : #define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                TEXTEQU         <22:20>
;  -W-UV 
;  1854 : #define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER          EQU             000000000h
;  -W-UV 
;  1855 : #define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA          EQU             000000001h
;  -W-UV 
;  1856 : #define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA             EQU             000000002h
;  -W-UV 
;  1857 : #define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA           EQU             000000003h
;  -W-UV 
;  1858 : #define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS         EQU             000000004h
;  -W-UF 
;  1859 : #define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     25:24 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_COLOR_WRITE               TEXTEQU         <25:24>
;  -W-UV 
;  1860 : #define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER         EQU             000000000h
;  -W-UV 
;  1861 : #define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA         EQU             000000001h
;  -W-UV 
;  1862 : #define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA            EQU             000000002h
;  -W-UF 
;  1863 : #define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -W-UF */
NV_PGRAPH_CONTROL_OUT_ROP               TEXTEQU         <28:28>
;  -W-UV 
;  1864 : #define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND             EQU             000000000h
;  -W-UV 
;  1865 : #define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION           EQU             000000001h
;  RW-4R 
;  1866 : #define NV_PGRAPH_DPRAM_INDEX                            0x00400648 /* RW-4R */
NV_PGRAPH_DPRAM_INDEX           EQU             000400648h
;  RWIVF 
;  1867 : #define NV_PGRAPH_DPRAM_INDEX_ADRS                              5:0 /* RWIVF */
NV_PGRAPH_DPRAM_INDEX_ADRS              TEXTEQU         <5:0>
;  RWI-V 
;  1868 : #define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
NV_PGRAPH_DPRAM_INDEX_ADRS_0            EQU             000000000h
;  RWIVF 
;  1869 : #define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
NV_PGRAPH_DPRAM_INDEX_SELECT            TEXTEQU         <10:8>
;  RWI-V 
;  1870 : #define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0             EQU             000000000h
;  RW--V 
;  1871 : #define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1             EQU             000000001h
;  RW--V 
;  1872 : #define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0             EQU             000000002h
;  RW--V 
;  1873 : #define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1             EQU             000000003h
;  RW--V 
;  1874 : #define NV_PGRAPH_DPRAM_INDEX_SELECT_WE                  0x00000004 /* RW--V */
NV_PGRAPH_DPRAM_INDEX_SELECT_WE         EQU             000000004h
;  RW--V 
;  1875 : #define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000005 /* RW--V */
NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA              EQU             000000005h
;  RW-4R 
;  1876 : #define NV_PGRAPH_DPRAM_DATA                             0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_DATA            EQU             00040064ch
;  RWXVF 
;  1877 : #define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
NV_PGRAPH_DPRAM_DATA_VALUE              TEXTEQU         <31:0>
;  RW-4R 
;  1878 : #define NV_PGRAPH_DPRAM_ADRS_0                           0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_ADRS_0          EQU             00040064ch
;        
;  1879 : #define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1         EQU             00040064ch
;  RWXVF 
;  1880 : #define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
NV_PGRAPH_DPRAM_ADRS_0_VALUE            TEXTEQU         <19:0>
;  RW-4R 
;  1881 : #define NV_PGRAPH_DPRAM_ADRS_1                           0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_ADRS_1          EQU             00040064ch
;        
;  1882 : #define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1         EQU             00040064ch
;  RWXVF 
;  1883 : #define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
NV_PGRAPH_DPRAM_ADRS_1_VALUE            TEXTEQU         <19:0>
;  RW-4R 
;  1884 : #define NV_PGRAPH_DPRAM_DATA_0                           0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_DATA_0          EQU             00040064ch
;        
;  1885 : #define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
NV_PGRAPH_DPRAM_DATA_0__ALIAS_1         EQU             00040064ch
;  RWXVF 
;  1886 : #define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
NV_PGRAPH_DPRAM_DATA_0_VALUE            TEXTEQU         <31:0>
;  RW-4R 
;  1887 : #define NV_PGRAPH_DPRAM_DATA_1                           0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_DATA_1          EQU             00040064ch
;        
;  1888 : #define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
NV_PGRAPH_DPRAM_DATA_1__ALIAS_1         EQU             00040064ch
;  RWXVF 
;  1889 : #define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
NV_PGRAPH_DPRAM_DATA_1_VALUE            TEXTEQU         <31:0>
;  RW-4R 
;  1890 : #define NV_PGRAPH_DPRAM_WE                               0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_WE              EQU             00040064ch
;        
;  1891 : #define NV_PGRAPH_DPRAM_WE__ALIAS_1            NV_PGRAPH_DPRAM_DATA /*       */
NV_PGRAPH_DPRAM_WE__ALIAS_1             EQU             00040064ch
;  RWXVF 
;  1892 : #define NV_PGRAPH_DPRAM_WE_VALUE                               31:0 /* RWXVF */
NV_PGRAPH_DPRAM_WE_VALUE                TEXTEQU         <31:0>
;  RW-4R 
;  1893 : #define NV_PGRAPH_DPRAM_ALPHA                            0x0040064c /* RW-4R */
NV_PGRAPH_DPRAM_ALPHA           EQU             00040064ch
;        
;  1894 : #define NV_PGRAPH_DPRAM_ALPHA__ALIAS_1         NV_PGRAPH_DPRAM_DATA /*       */
NV_PGRAPH_DPRAM_ALPHA__ALIAS_1          EQU             00040064ch
;  RWXVF 
;  1895 : #define NV_PGRAPH_DPRAM_ALPHA_VALUE                            31:0 /* RWXVF */
NV_PGRAPH_DPRAM_ALPHA_VALUE             TEXTEQU         <31:0>
;  RW-4A 
;        
;  1896 : #define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
;  1897 : #define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
NV_PGRAPH_ABS_X_RAM__SIZE_1             EQU             32t
;  RWXUF 
;  1898 : #define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
NV_PGRAPH_ABS_X_RAM_VALUE               TEXTEQU         <31:0>
;  R--4A 
;        
;  1899 : #define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
;  1900 : #define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
NV_PGRAPH_X_RAM_BPORT__SIZE_1           EQU             32t
;  R--UF 
;  1901 : #define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
NV_PGRAPH_X_RAM_BPORT_VALUE             TEXTEQU         <31:0>
;  RW-4A 
;        
;  1902 : #define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
;  1903 : #define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
NV_PGRAPH_ABS_Y_RAM__SIZE_1             EQU             32t
;  RWXUF 
;  1904 : #define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
NV_PGRAPH_ABS_Y_RAM_VALUE               TEXTEQU         <31:0>
;  R--4A 
;        
;  1905 : #define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
;  1906 : #define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
NV_PGRAPH_Y_RAM_BPORT__SIZE_1           EQU             32t
;  R--UF 
;  1907 : #define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
NV_PGRAPH_Y_RAM_BPORT_VALUE             TEXTEQU         <31:0>
;  RW-4R 
;  1908 : #define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
NV_PGRAPH_XY_LOGIC_MISC0                EQU             000400514h
;  RWIUF 
;  1909 : #define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWIUF */
NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                TEXTEQU         <17:0>
;  RWI-V 
;  1910 : #define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0              EQU             000000000h
;  RWXVF 
;  1911 : #define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWXVF */
NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION              TEXTEQU         <20:20>
;  RW--V 
;  1912 : #define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO              EQU             000000000h
;  RW--V 
;  1913 : #define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO         EQU             000000001h
;  RWIUF 
;  1914 : #define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
NV_PGRAPH_XY_LOGIC_MISC0_INDEX          TEXTEQU         <31:28>
;  RWI-V 
;  1915 : #define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                EQU             000000000h
;  RW-4R 
;  1916 : #define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
NV_PGRAPH_XY_LOGIC_MISC1                EQU             000400518h
;  RWIVF 
;  1917 : #define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                TEXTEQU         <0:0>
;  RWI-V 
;  1918 : #define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED         EQU             000000000h
;  RW--V 
;  1919 : #define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE           EQU             000000001h
;  RWIVF 
;  1920 : #define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX              TEXTEQU         <4:4>
;  RWI-V 
;  1921 : #define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL              EQU             000000000h
;  RW--V 
;  1922 : #define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL         EQU             000000001h
;  RWIVF 
;  1923 : #define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY              TEXTEQU         <5:5>
;  RWI-V 
;  1924 : #define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL              EQU             000000000h
;  RW--V 
;  1925 : #define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL         EQU             000000001h
;  RWIVF 
;  1926 : #define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX              TEXTEQU         <8:8>
;  RWI-V 
;  1927 : #define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL              EQU             000000000h
;  RW--V 
;  1928 : #define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL         EQU             000000001h
;  RWIVF 
;  1929 : #define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY              TEXTEQU         <9:9>
;  RWI-V 
;  1930 : #define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL              EQU             000000000h
;  RW--V 
;  1931 : #define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL         EQU             000000001h
;  RWIVF 
;  1932 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN              TEXTEQU         <12:12>
;  RWI-V 
;  1933 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN            EQU             000000000h
;  RW--V 
;  1934 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN              EQU             000000001h
;  RWIVF 
;  1935 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX              TEXTEQU         <13:13>
;  RWI-V 
;  1936 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX            EQU             000000000h
;  RW--V 
;  1937 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX              EQU             000000001h
;  RWIVF 
;  1938 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX              TEXTEQU         <14:14>
;  RWI-V 
;  1939 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX                EQU             000000000h
;  RW--V 
;  1940 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX             EQU             000000001h
;  RWIVF 
;  1941 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN              TEXTEQU         <16:16>
;  RWI-V 
;  1942 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN            EQU             000000000h
;  RW--V 
;  1943 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN              EQU             000000001h
;  RWIVF 
;  1944 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX              TEXTEQU         <17:17>
;  RWI-V 
;  1945 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX            EQU             000000000h
;  RW--V 
;  1946 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX              EQU             000000001h
;  RWIVF 
;  1947 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX              TEXTEQU         <18:18>
;  RWI-V 
;  1948 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX                EQU             000000000h
;  RW--V 
;  1949 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX             EQU             000000001h
;  RWIVF 
;  1950 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA              TEXTEQU         <20:20>
;  RWI-V 
;  1951 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX              EQU             000000000h
;  RW--V 
;  1952 : #define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX             EQU             000000001h
;  RWIVF 
;  1953 : #define NV_PGRAPH_XY_LOGIC_MISC1_DUDX                         27:24 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_DUDX           TEXTEQU         <27:24>
;  RWI-V 
;  1954 : #define NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE              0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE             EQU             000000000h
;  RW-4R 
;  1955 : #define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
NV_PGRAPH_XY_LOGIC_MISC2                EQU             00040051ch
;  RWIVF 
;  1956 : #define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                TEXTEQU         <0:0>
;  RWI-V 
;  1957 : #define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE                EQU             000000000h
;  RW--V 
;  1958 : #define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE         EQU             000000001h
;  RWIVF 
;  1959 : #define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX              TEXTEQU         <4:4>
;  RWI-V 
;  1960 : #define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL              EQU             000000000h
;  RW--V 
;  1961 : #define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL         EQU             000000001h
;  RWIVF 
;  1962 : #define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY              TEXTEQU         <5:5>
;  RWI-V 
;  1963 : #define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL              EQU             000000000h
;  RW--V 
;  1964 : #define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL         EQU             000000001h
;  RWIVF 
;  1965 : #define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX                      8:8 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX              TEXTEQU         <8:8>
;  RWI-V 
;  1966 : #define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL              EQU             000000000h
;  RW--V 
;  1967 : #define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL         EQU             000000001h
;  RWIVF 
;  1968 : #define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY                      9:9 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY              TEXTEQU         <9:9>
;  RWI-V 
;  1969 : #define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL              EQU             000000000h
;  RW--V 
;  1970 : #define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL         EQU             000000001h
;  RWIVF 
;  1971 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN                    12:12 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN              TEXTEQU         <12:12>
;  RWI-V 
;  1972 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN            EQU             000000000h
;  RW--V 
;  1973 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN              EQU             000000001h
;  RWIVF 
;  1974 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX                    13:13 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX              TEXTEQU         <13:13>
;  RWI-V 
;  1975 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX            EQU             000000000h
;  RW--V 
;  1976 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX              EQU             000000001h
;  RWIVF 
;  1977 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    14:14 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX              TEXTEQU         <14:14>
;  RWI-V 
;  1978 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX                EQU             000000000h
;  RW--V 
;  1979 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX             EQU             000000001h
;  RWIVF 
;  1980 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN                    16:16 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN              TEXTEQU         <16:16>
;  RWI-V 
;  1981 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN            EQU             000000000h
;  RW--V 
;  1982 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN              EQU             000000001h
;  RWIVF 
;  1983 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX                    17:17 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX              TEXTEQU         <17:17>
;  RWI-V 
;  1984 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX            EQU             000000000h
;  RW--V 
;  1985 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX              EQU             000000001h
;  RWIVF 
;  1986 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    18:18 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX              TEXTEQU         <18:18>
;  RWI-V 
;  1987 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX                EQU             000000000h
;  RW--V 
;  1988 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX             EQU             000000001h
;  RWIVF 
;  1989 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA              TEXTEQU         <20:20>
;  RWI-V 
;  1990 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX              EQU             000000000h
;  RW--V 
;  1991 : #define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX             EQU             000000001h
;  RWIVF 
;  1992 : #define NV_PGRAPH_XY_LOGIC_MISC1_DVDY                         27:24 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC1_DVDY           TEXTEQU         <27:24>
;  RWI-V 
;  1993 : #define NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE              0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE             EQU             000000000h
;  RW-4R 
;  1994 : #define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
NV_PGRAPH_XY_LOGIC_MISC3                EQU             000400520h
;  RWXVF 
;  1995 : #define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0             TEXTEQU         <0:0>
;  RW--V 
;  1996 : #define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL                EQU             000000000h
;  RW--V 
;  1997 : #define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE                EQU             000000001h
;  RWXVF 
;  1998 : #define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY           TEXTEQU         <4:4>
;  RW--V 
;  1999 : #define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL              EQU             000000000h
;  RW--V 
;  2000 : #define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE              EQU             000000001h
;  RWIVF 
;  2001 : #define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX              TEXTEQU         <8:8>
;  RWI-V 
;  2002 : #define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL         EQU             000000000h
;  RW--V 
;  2003 : #define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE         EQU             000000001h
;  RWIVF 
;  2004 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG               TEXTEQU         <12:12>
;  RWI-V 
;  2005 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL          EQU             000000000h
;  RW--V 
;  2006 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE          EQU             000000001h
;  RWXUF 
;  2007 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX              TEXTEQU         <22:16>
;  RW--V 
;  2008 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0            EQU             000000000h
;  RWXUF 
;  2009 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX             TEXTEQU         <30:24>
;  RW--V 
;  2010 : #define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0           EQU             000000000h
;  RW-4R 
;  2011 : #define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
NV_PGRAPH_X_MISC                EQU             000400500h
;  RWIVF 
;  2012 : #define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
NV_PGRAPH_X_MISC_BIT33_0                TEXTEQU         <0:0>
;  RWI-V 
;  2013 : #define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_BIT33_0_0              EQU             000000000h
;  RWIVF 
;  2014 : #define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
NV_PGRAPH_X_MISC_BIT33_1                TEXTEQU         <1:1>
;  RWI-V 
;  2015 : #define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_BIT33_1_0              EQU             000000000h
;  RWIVF 
;  2016 : #define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
NV_PGRAPH_X_MISC_BIT33_2                TEXTEQU         <2:2>
;  RWI-V 
;  2017 : #define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_BIT33_2_0              EQU             000000000h
;  RWIVF 
;  2018 : #define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
NV_PGRAPH_X_MISC_BIT33_3                TEXTEQU         <3:3>
;  RWI-V 
;  2019 : #define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_BIT33_3_0              EQU             000000000h
;  RWIVF 
;  2020 : #define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
NV_PGRAPH_X_MISC_RANGE_0                TEXTEQU         <4:4>
;  RWI-V 
;  2021 : #define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_RANGE_0_0              EQU             000000000h
;  RWIVF 
;  2022 : #define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
NV_PGRAPH_X_MISC_RANGE_1                TEXTEQU         <5:5>
;  RWI-V 
;  2023 : #define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_RANGE_1_0              EQU             000000000h
;  RWIVF 
;  2024 : #define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
NV_PGRAPH_X_MISC_RANGE_2                TEXTEQU         <6:6>
;  RWI-V 
;  2025 : #define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_RANGE_2_0              EQU             000000000h
;  RWIVF 
;  2026 : #define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
NV_PGRAPH_X_MISC_RANGE_3                TEXTEQU         <7:7>
;  RWI-V 
;  2027 : #define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
NV_PGRAPH_X_MISC_RANGE_3_0              EQU             000000000h
;  RWXVF 
;  2028 : #define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
NV_PGRAPH_X_MISC_ADDER_OUTPUT           TEXTEQU         <29:28>
;  RW--V 
;  2029 : #define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0              EQU             000000000h
;  RW--V 
;  2030 : #define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0              EQU             000000001h
;  RW--V 
;  2031 : #define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0              EQU             000000002h
;  RW-4R 
;  2032 : #define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
NV_PGRAPH_Y_MISC                EQU             000400504h
;  RWIVF 
;  2033 : #define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
NV_PGRAPH_Y_MISC_BIT33_0                TEXTEQU         <0:0>
;  RWI-V 
;  2034 : #define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_BIT33_0_0              EQU             000000000h
;  RWIVF 
;  2035 : #define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
NV_PGRAPH_Y_MISC_BIT33_1                TEXTEQU         <1:1>
;  RWI-V 
;  2036 : #define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_BIT33_1_0              EQU             000000000h
;  RWIVF 
;  2037 : #define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
NV_PGRAPH_Y_MISC_BIT33_2                TEXTEQU         <2:2>
;  RWI-V 
;  2038 : #define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_BIT33_2_0              EQU             000000000h
;  RWIVF 
;  2039 : #define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
NV_PGRAPH_Y_MISC_BIT33_3                TEXTEQU         <3:3>
;  RWI-V 
;  2040 : #define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_BIT33_3_0              EQU             000000000h
;  RWIVF 
;  2041 : #define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_0                TEXTEQU         <4:4>
;  RWI-V 
;  2042 : #define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_0_0              EQU             000000000h
;  RWIVF 
;  2043 : #define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_1                TEXTEQU         <5:5>
;  RWI-V 
;  2044 : #define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_1_0              EQU             000000000h
;  RWIVF 
;  2045 : #define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_2                TEXTEQU         <6:6>
;  RWI-V 
;  2046 : #define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_2_0              EQU             000000000h
;  RWIVF 
;  2047 : #define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_3                TEXTEQU         <7:7>
;  RWI-V 
;  2048 : #define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_3_0              EQU             000000000h
;  RWXVF 
;  2049 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT           TEXTEQU         <29:28>
;  RW--V 
;  2050 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0              EQU             000000000h
;  RW--V 
;  2051 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0              EQU             000000001h
;  RW--V 
;  2052 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0              EQU             000000002h
;  RW-4R 
;  2053 : #define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
NV_PGRAPH_ABS_UCLIP_XMIN                EQU             00040053ch
;  RWXSF 
;  2054 : #define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_XMIN_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2055 : #define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
NV_PGRAPH_ABS_UCLIP_XMAX                EQU             000400544h
;  RWXSF 
;  2056 : #define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_XMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2057 : #define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
NV_PGRAPH_ABS_UCLIP_YMIN                EQU             000400540h
;  RWXSF 
;  2058 : #define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_YMIN_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2059 : #define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
NV_PGRAPH_ABS_UCLIP_YMAX                EQU             000400548h
;  RWXSF 
;  2060 : #define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_YMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2061 : #define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_XMIN               EQU             000400560h
;  RWXSF 
;  2062 : #define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2063 : #define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_XMAX               EQU             000400568h
;  RWXSF 
;  2064 : #define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2065 : #define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_YMIN               EQU             000400564h
;  RWXSF 
;  2066 : #define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2067 : #define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_YMAX               EQU             00040056ch
;  RWXSF 
;  2068 : #define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2069 : #define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
NV_PGRAPH_SOURCE_COLOR          EQU             00040050ch
;  RWXVF 
;  2070 : #define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
NV_PGRAPH_SOURCE_COLOR_VALUE            TEXTEQU         <31:0>
;  RW-4R 
;  2071 : #define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
NV_PGRAPH_EXCEPTIONS            EQU             000400508h
;  RWIVF 
;  2072 : #define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_VALID              TEXTEQU         <27:0>
;  RWI-V 
;  2073 : #define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_VALID_0            EQU             000000000h
;  RWIVF 
;  2074 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIP_MIN           TEXTEQU         <28:28>
;  RWI-V 
;  2075 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR          EQU             000000000h
;  RW--V 
;  2076 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY              EQU             000000001h
;  RWIVF 
;  2077 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIPA_MIN          TEXTEQU         <29:29>
;  RWI-V 
;  2078 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR         EQU             000000000h
;  RW--V 
;  2079 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY             EQU             000000001h
;  RWIVF 
;  2080 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIP_MAX           TEXTEQU         <30:30>
;  RWI-V 
;  2081 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR          EQU             000000000h
;  RW--V 
;  2082 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY              EQU             000000001h
;  RWIVF 
;  2083 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIPA_MAX          TEXTEQU         <31:31>
;  RWI-V 
;  2084 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR         EQU             000000000h
;  RW--V 
;  2085 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY             EQU             000000001h
;  RW-4R 
;  2086 : #define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
NV_PGRAPH_ABS_ICLIP_XMAX                EQU             000400534h
;  RWXSF 
;  2087 : #define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_ICLIP_XMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2088 : #define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
NV_PGRAPH_ABS_ICLIP_YMAX                EQU             000400538h
;  RWXSF 
;  2089 : #define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_ICLIP_YMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2090 : #define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
NV_PGRAPH_CLIPX_0               EQU             000400524h
;  RWIVF 
;  2091 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP0_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2092 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT          EQU             000000000h
;  RWI-V 
;  2093 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT          EQU             000000001h
;  RW--V 
;  2094 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2095 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP0_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2096 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT          EQU             000000000h
;  RWI-V 
;  2097 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT          EQU             000000001h
;  RW--V 
;  2098 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2099 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP1_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2100 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT          EQU             000000000h
;  RWI-V 
;  2101 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT          EQU             000000001h
;  RW--V 
;  2102 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2103 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP1_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2104 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT          EQU             000000000h
;  RWI-V 
;  2105 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT          EQU             000000001h
;  RW--V 
;  2106 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2107 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP2_MIN             TEXTEQU         <9:8>
;  RW--V 
;  2108 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT          EQU             000000000h
;  RWI-V 
;  2109 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT          EQU             000000001h
;  RW--V 
;  2110 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2111 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP2_MAX             TEXTEQU         <11:10>
;  RW--V 
;  2112 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT          EQU             000000000h
;  RWI-V 
;  2113 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT          EQU             000000001h
;  RW--V 
;  2114 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2115 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP3_MIN             TEXTEQU         <13:12>
;  RW--V 
;  2116 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT          EQU             000000000h
;  RWI-V 
;  2117 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT          EQU             000000001h
;  RW--V 
;  2118 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2119 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP3_MAX             TEXTEQU         <15:14>
;  RW--V 
;  2120 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT          EQU             000000000h
;  RWI-V 
;  2121 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT          EQU             000000001h
;  RW--V 
;  2122 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2123 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP4_MIN             TEXTEQU         <17:16>
;  RW--V 
;  2124 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT          EQU             000000000h
;  RWI-V 
;  2125 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT          EQU             000000001h
;  RW--V 
;  2126 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2127 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP4_MAX             TEXTEQU         <19:18>
;  RW--V 
;  2128 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT          EQU             000000000h
;  RWI-V 
;  2129 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT          EQU             000000001h
;  RW--V 
;  2130 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2131 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP5_MIN             TEXTEQU         <21:20>
;  RW--V 
;  2132 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT          EQU             000000000h
;  RWI-V 
;  2133 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT          EQU             000000001h
;  RW--V 
;  2134 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2135 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP5_MAX             TEXTEQU         <23:22>
;  RW--V 
;  2136 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT          EQU             000000000h
;  RWI-V 
;  2137 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT          EQU             000000001h
;  RW--V 
;  2138 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2139 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP6_MIN             TEXTEQU         <25:24>
;  RW--V 
;  2140 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT          EQU             000000000h
;  RWI-V 
;  2141 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT          EQU             000000001h
;  RW--V 
;  2142 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2143 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP6_MAX             TEXTEQU         <27:26>
;  RW--V 
;  2144 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT          EQU             000000000h
;  RWI-V 
;  2145 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT          EQU             000000001h
;  RW--V 
;  2146 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2147 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP7_MIN             TEXTEQU         <29:28>
;  RW--V 
;  2148 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT          EQU             000000000h
;  RWI-V 
;  2149 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT          EQU             000000001h
;  RW--V 
;  2150 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2151 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP7_MAX             TEXTEQU         <31:30>
;  RW--V 
;  2152 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT          EQU             000000000h
;  RWI-V 
;  2153 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT          EQU             000000001h
;  RW--V 
;  2154 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ          EQU             000000002h
;  RW-4R 
;  2155 : #define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
NV_PGRAPH_CLIPX_1               EQU             000400528h
;  RWIVF 
;  2156 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP8_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2157 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT          EQU             000000000h
;  RWI-V 
;  2158 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT          EQU             000000001h
;  RW--V 
;  2159 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2160 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP8_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2161 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT          EQU             000000000h
;  RWI-V 
;  2162 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT          EQU             000000001h
;  RW--V 
;  2163 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2164 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP9_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2165 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT          EQU             000000000h
;  RWI-V 
;  2166 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT          EQU             000000001h
;  RW--V 
;  2167 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2168 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP9_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2169 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT          EQU             000000000h
;  RWI-V 
;  2170 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT          EQU             000000001h
;  RW--V 
;  2171 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2172 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP10_MIN            TEXTEQU         <9:8>
;  RW--V 
;  2173 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT         EQU             000000000h
;  RWI-V 
;  2174 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT         EQU             000000001h
;  RW--V 
;  2175 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2176 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP10_MAX            TEXTEQU         <11:10>
;  RW--V 
;  2177 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT         EQU             000000000h
;  RWI-V 
;  2178 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT         EQU             000000001h
;  RW--V 
;  2179 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2180 : #define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP11_MIN            TEXTEQU         <13:12>
;  RW--V 
;  2181 : #define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT         EQU             000000000h
;  RWI-V 
;  2182 : #define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT         EQU             000000001h
;  RW--V 
;  2183 : #define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ          EQU             000000002h
;  RWIVF 
;  2184 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP11_MAX            TEXTEQU         <15:14>
;  RW--V 
;  2185 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT         EQU             000000000h
;  RWI-V 
;  2186 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT         EQU             000000001h
;  RW--V 
;  2187 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2188 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP12_MIN            TEXTEQU         <17:16>
;  RW--V 
;  2189 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT         EQU             000000000h
;  RWI-V 
;  2190 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT         EQU             000000001h
;  RW--V 
;  2191 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2192 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP12_MAX            TEXTEQU         <19:18>
;  RW--V 
;  2193 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT         EQU             000000000h
;  RWI-V 
;  2194 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT         EQU             000000001h
;  RW--V 
;  2195 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2196 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP13_MIN            TEXTEQU         <21:20>
;  RW--V 
;  2197 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT         EQU             000000000h
;  RWI-V 
;  2198 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT         EQU             000000001h
;  RW--V 
;  2199 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2200 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP13_MAX            TEXTEQU         <23:22>
;  RW--V 
;  2201 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT         EQU             000000000h
;  RWI-V 
;  2202 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT         EQU             000000001h
;  RW--V 
;  2203 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2204 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP14_MIN            TEXTEQU         <25:24>
;  RW--V 
;  2205 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT         EQU             000000000h
;  RWI-V 
;  2206 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT         EQU             000000001h
;  RW--V 
;  2207 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2208 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP14_MAX            TEXTEQU         <27:26>
;  RW--V 
;  2209 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT         EQU             000000000h
;  RWI-V 
;  2210 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT         EQU             000000001h
;  RW--V 
;  2211 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2212 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP15_MIN            TEXTEQU         <29:28>
;  RW--V 
;  2213 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT         EQU             000000000h
;  RWI-V 
;  2214 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT         EQU             000000001h
;  RW--V 
;  2215 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2216 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP15_MAX            TEXTEQU         <31:30>
;  RW--V 
;  2217 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT         EQU             000000000h
;  RWI-V 
;  2218 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT         EQU             000000001h
;  RW--V 
;  2219 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ         EQU             000000002h
;  RW-4R 
;  2220 : #define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
NV_PGRAPH_CLIPY_0               EQU             00040052ch
;  RWIVF 
;  2221 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP0_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2222 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT          EQU             000000000h
;  RWI-V 
;  2223 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT          EQU             000000001h
;  RW--V 
;  2224 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2225 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP0_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2226 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT          EQU             000000000h
;  RWI-V 
;  2227 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT          EQU             000000001h
;  RW--V 
;  2228 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2229 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP1_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2230 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT          EQU             000000000h
;  RWI-V 
;  2231 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT          EQU             000000001h
;  RW--V 
;  2232 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2233 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP1_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2234 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT          EQU             000000000h
;  RWI-V 
;  2235 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT          EQU             000000001h
;  RW--V 
;  2236 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2237 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP2_MIN             TEXTEQU         <9:8>
;  RW--V 
;  2238 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT          EQU             000000000h
;  RWI-V 
;  2239 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT          EQU             000000001h
;  RW--V 
;  2240 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2241 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP2_MAX             TEXTEQU         <11:10>
;  RW--V 
;  2242 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT          EQU             000000000h
;  RWI-V 
;  2243 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT          EQU             000000001h
;  RW--V 
;  2244 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2245 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP3_MIN             TEXTEQU         <13:12>
;  RW--V 
;  2246 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT          EQU             000000000h
;  RWI-V 
;  2247 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT          EQU             000000001h
;  RW--V 
;  2248 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2249 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP3_MAX             TEXTEQU         <15:14>
;  RW--V 
;  2250 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT          EQU             000000000h
;  RWI-V 
;  2251 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT          EQU             000000001h
;  RW--V 
;  2252 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2253 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP4_MIN             TEXTEQU         <17:16>
;  RW--V 
;  2254 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT          EQU             000000000h
;  RWI-V 
;  2255 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT          EQU             000000001h
;  RW--V 
;  2256 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2257 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP4_MAX             TEXTEQU         <19:18>
;  RW--V 
;  2258 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT          EQU             000000000h
;  RWI-V 
;  2259 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT          EQU             000000001h
;  RW--V 
;  2260 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2261 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP5_MIN             TEXTEQU         <21:20>
;  RW--V 
;  2262 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT          EQU             000000000h
;  RWI-V 
;  2263 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT          EQU             000000001h
;  RW--V 
;  2264 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2265 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP5_MAX             TEXTEQU         <23:22>
;  RW--V 
;  2266 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT          EQU             000000000h
;  RWI-V 
;  2267 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT          EQU             000000001h
;  RW--V 
;  2268 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2269 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP6_MIN             TEXTEQU         <25:24>
;  RW--V 
;  2270 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT          EQU             000000000h
;  RWI-V 
;  2271 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT          EQU             000000001h
;  RW--V 
;  2272 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2273 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP6_MAX             TEXTEQU         <27:26>
;  RW--V 
;  2274 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT          EQU             000000000h
;  RWI-V 
;  2275 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT          EQU             000000001h
;  RW--V 
;  2276 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2277 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP7_MIN             TEXTEQU         <29:28>
;  RW--V 
;  2278 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT          EQU             000000000h
;  RWI-V 
;  2279 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT          EQU             000000001h
;  RW--V 
;  2280 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2281 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP7_MAX             TEXTEQU         <31:30>
;  RW--V 
;  2282 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT          EQU             000000000h
;  RWI-V 
;  2283 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT          EQU             000000001h
;  RW--V 
;  2284 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ          EQU             000000002h
;  RW-4R 
;  2285 : #define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
NV_PGRAPH_CLIPY_1               EQU             000400530h
;  RWIVF 
;  2286 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP8_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2287 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT          EQU             000000000h
;  RWI-V 
;  2288 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT          EQU             000000001h
;  RW--V 
;  2289 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2290 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP8_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2291 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT          EQU             000000000h
;  RWI-V 
;  2292 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT          EQU             000000001h
;  RW--V 
;  2293 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2294 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP9_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2295 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT          EQU             000000000h
;  RWI-V 
;  2296 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT          EQU             000000001h
;  RW--V 
;  2297 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2298 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP9_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2299 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT          EQU             000000000h
;  RWI-V 
;  2300 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT          EQU             000000001h
;  RW--V 
;  2301 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2302 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP10_MIN            TEXTEQU         <9:8>
;  RW--V 
;  2303 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT         EQU             000000000h
;  RWI-V 
;  2304 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT         EQU             000000001h
;  RW--V 
;  2305 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2306 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP10_MAX            TEXTEQU         <11:10>
;  RW--V 
;  2307 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT         EQU             000000000h
;  RWI-V 
;  2308 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT         EQU             000000001h
;  RW--V 
;  2309 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2310 : #define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP11_MIN            TEXTEQU         <13:12>
;  RW--V 
;  2311 : #define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT         EQU             000000000h
;  RWI-V 
;  2312 : #define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT         EQU             000000001h
;  RW--V 
;  2313 : #define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ          EQU             000000002h
;  RWIVF 
;  2314 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP11_MAX            TEXTEQU         <15:14>
;  RW--V 
;  2315 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT         EQU             000000000h
;  RWI-V 
;  2316 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT         EQU             000000001h
;  RW--V 
;  2317 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2318 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP12_MIN            TEXTEQU         <17:16>
;  RW--V 
;  2319 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT         EQU             000000000h
;  RWI-V 
;  2320 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT         EQU             000000001h
;  RW--V 
;  2321 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2322 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP12_MAX            TEXTEQU         <19:18>
;  RW--V 
;  2323 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT         EQU             000000000h
;  RWI-V 
;  2324 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT         EQU             000000001h
;  RW--V 
;  2325 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2326 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP13_MIN            TEXTEQU         <21:20>
;  RW--V 
;  2327 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT         EQU             000000000h
;  RWI-V 
;  2328 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT         EQU             000000001h
;  RW--V 
;  2329 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2330 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP13_MAX            TEXTEQU         <23:22>
;  RW--V 
;  2331 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT         EQU             000000000h
;  RWI-V 
;  2332 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT         EQU             000000001h
;  RW--V 
;  2333 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2334 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP14_MIN            TEXTEQU         <25:24>
;  RW--V 
;  2335 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT         EQU             000000000h
;  RWI-V 
;  2336 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT         EQU             000000001h
;  RW--V 
;  2337 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2338 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP14_MAX            TEXTEQU         <27:26>
;  RW--V 
;  2339 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT         EQU             000000000h
;  RWI-V 
;  2340 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT         EQU             000000001h
;  RW--V 
;  2341 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2342 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP15_MIN            TEXTEQU         <29:28>
;  RW--V 
;  2343 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT         EQU             000000000h
;  RWI-V 
;  2344 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT         EQU             000000001h
;  RW--V 
;  2345 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2346 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP15_MAX            TEXTEQU         <31:30>
;  RW--V 
;  2347 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT         EQU             000000000h
;  RWI-V 
;  2348 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT         EQU             000000001h
;  RW--V 
;  2349 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ         EQU             000000002h
;  RW-4R 
;  2350 : #define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
NV_PGRAPH_MISC24_0              EQU             000400510h
;  RWXSF 
;  2351 : #define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
NV_PGRAPH_MISC24_0_VALUE                TEXTEQU         <23:0>
;  RW-4R 
;  2352 : #define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
NV_PGRAPH_MISC24_1              EQU             000400570h
;  RWXSF 
;  2353 : #define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
NV_PGRAPH_MISC24_1_VALUE                TEXTEQU         <23:0>
;  RW-4R 
;  2354 : #define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
NV_PGRAPH_PASSTHRU              EQU             00040054ch
;  RWXSF 
;  2355 : #define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
NV_PGRAPH_PASSTHRU_VALUE                TEXTEQU         <23:0>
;  RW-4A 
;        
;  2356 : #define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
;  2357 : #define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
NV_PGRAPH_ZFOG_RAM__SIZE_1              EQU             16t
;  RWXUF 
;  2358 : #define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
NV_PGRAPH_ZFOG_RAM_ZETA         TEXTEQU         <15:0>
;  RWXUF 
;  2359 : #define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
NV_PGRAPH_ZFOG_RAM_FOG          TEXTEQU         <23:16>
;  RW-4R 
;  2360 : #define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
NV_PGRAPH_D3D_XY                EQU             0004005c0h
;  RWXSF 
;  2361 : #define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
NV_PGRAPH_D3D_XY_X_VALUE                TEXTEQU         <15:0>
;  RWXSF 
;  2362 : #define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
NV_PGRAPH_D3D_XY_Y_VALUE                TEXTEQU         <31:16>
;  RW-4R 
;  2363 : #define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
NV_PGRAPH_D3D_UV                EQU             0004005c4h
;  RWXSF 
;  2364 : #define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
NV_PGRAPH_D3D_UV_U_VALUE                TEXTEQU         <15:0>
;  RWXSF 
;  2365 : #define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
NV_PGRAPH_D3D_UV_V_VALUE                TEXTEQU         <31:16>
;  RW-4R 
;  2366 : #define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
NV_PGRAPH_D3D_ZETA              EQU             0004005c8h
;  RWXSF 
;  2367 : #define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
NV_PGRAPH_D3D_ZETA_VALUE                TEXTEQU         <15:0>
;  RW-4R 
;  2368 : #define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
NV_PGRAPH_D3D_RGB               EQU             0004005cch
;  RWXSF 
;  2369 : #define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
NV_PGRAPH_D3D_RGB_VALUE         TEXTEQU         <15:0>
;  RW-4R 
;  2370 : #define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
NV_PGRAPH_D3D_FOG               EQU             0004005d0h
;  RWXSF 
;  2371 : #define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
NV_PGRAPH_D3D_FOG_I0            TEXTEQU         <3:0>
;  RWXSF 
;  2372 : #define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
NV_PGRAPH_D3D_FOG_I1            TEXTEQU         <7:4>
;  RWXSF 
;  2373 : #define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
NV_PGRAPH_D3D_FOG_I2            TEXTEQU         <11:8>
;  RWXSF 
;  2374 : #define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
NV_PGRAPH_D3D_FOG_I3            TEXTEQU         <15:12>
;  RWXSF 
;  2375 : #define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
NV_PGRAPH_D3D_FOG_I4            TEXTEQU         <19:16>
;  RWXSF 
;  2376 : #define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
NV_PGRAPH_D3D_FOG_I5            TEXTEQU         <23:20>
;  RWXSF 
;  2377 : #define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
NV_PGRAPH_D3D_FOG_FOG_VALUE             TEXTEQU         <31:24>
;  RW-4R 
;  2378 : #define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
NV_PGRAPH_D3D_M         EQU             0004005d4h
;  RWXSF 
;  2379 : #define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
NV_PGRAPH_D3D_M_VALUE           TEXTEQU         <31:0>
;  RW-4R 
;  2380 : #define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
NV_PGRAPH_DMA_INTR_0            EQU             000401100h
;  RWXVF 
;  2381 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_INSTANCE           TEXTEQU         <0:0>
;  R---V 
;  2382 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING               EQU             000000000h
;  R---V 
;  2383 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING           EQU             000000001h
;  -W--V 
;  2384 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET             EQU             000000001h
;  RWXVF 
;  2385 : #define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_PRESENT            TEXTEQU         <4:4>
;  R---V 
;  2386 : #define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING                EQU             000000000h
;  R---V 
;  2387 : #define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING            EQU             000000001h
;  -W--V 
;  2388 : #define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_PRESENT_RESET              EQU             000000001h
;  RWXVF 
;  2389 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_PROTECTION         TEXTEQU         <8:8>
;  R---V 
;  2390 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING             EQU             000000000h
;  R---V 
;  2391 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING         EQU             000000001h
;  -W--V 
;  2392 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET           EQU             000000001h
;  RWXVF 
;  2393 : #define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_LINEAR             TEXTEQU         <12:12>
;  R---V 
;  2394 : #define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING         EQU             000000000h
;  R---V 
;  2395 : #define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING             EQU             000000001h
;  -W--V 
;  2396 : #define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_LINEAR_RESET               EQU             000000001h
;  RWXVF 
;  2397 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_NOTIFY             TEXTEQU         <16:16>
;  R---V 
;  2398 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING         EQU             000000000h
;  R---V 
;  2399 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING             EQU             000000001h
;  -W--V 
;  2400 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET               EQU             000000001h
;  RW-4R 
;  2401 : #define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
NV_PGRAPH_DMA_INTR_EN_0         EQU             000401140h
;  RWIVF 
;  2402 : #define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                TEXTEQU         <0:0>
;  RWI-V 
;  2403 : #define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED               EQU             000000000h
;  RW--V 
;  2404 : #define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED                EQU             000000001h
;  RWIVF 
;  2405 : #define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_PRESENT         TEXTEQU         <4:4>
;  RWI-V 
;  2406 : #define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED                EQU             000000000h
;  RW--V 
;  2407 : #define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED         EQU             000000001h
;  RWIVF 
;  2408 : #define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_PROTECTION              TEXTEQU         <8:8>
;  RWI-V 
;  2409 : #define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED             EQU             000000000h
;  RW--V 
;  2410 : #define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED              EQU             000000001h
;  RWIVF 
;  2411 : #define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_LINEAR          TEXTEQU         <12:12>
;  RWI-V 
;  2412 : #define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED         EQU             000000000h
;  RW--V 
;  2413 : #define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED          EQU             000000001h
;  RWIVF 
;  2414 : #define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_NOTIFY          TEXTEQU         <16:16>
;  RWI-V 
;  2415 : #define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED         EQU             000000000h
;  RW--V 
;  2416 : #define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED          EQU             000000001h
;  -W-4R 
;  2417 : #define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
NV_PGRAPH_DMA_ACCESS            EQU             000401200h
;  -W-VF 
;  2418 : #define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
NV_PGRAPH_DMA_PTE_ACCESS_PTE            TEXTEQU         <0:0>
;  -W--V 
;  2419 : #define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE             EQU             000000001h
;  RW-4R 
;  2420 : #define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
NV_PGRAPH_DMA_CONTROL           EQU             000401210h
;  RWXUF 
;  2421 : #define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
NV_PGRAPH_DMA_CONTROL_ADJUST            TEXTEQU         <11:0>
;  RWXVF 
;  2422 : #define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                TEXTEQU         <16:16>
;  RW--V 
;  2423 : #define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT            EQU             000000000h
;  RW--V 
;  2424 : #define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT                EQU             000000001h
;  RWXUF 
;  2425 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE               TEXTEQU         <25:24>
;  RW--V 
;  2426 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM           EQU             000000000h
;  RW--V 
;  2427 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART          EQU             000000001h
;  RW--V 
;  2428 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI           EQU             000000002h
;  RW--V 
;  2429 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP           EQU             000000003h
;  RW-4R 
;  2430 : #define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
NV_PGRAPH_DMA_LIMIT             EQU             000401220h
;  RWXUF 
;  2431 : #define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
NV_PGRAPH_DMA_LIMIT_OFFSET              TEXTEQU         <31:0>
;  RW-4R 
;  2432 : #define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
NV_PGRAPH_DMA_TLB_PTE           EQU             000401230h
;  RWXVF 
;  2433 : #define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
NV_PGRAPH_DMA_TLB_PTE_PAGE              TEXTEQU         <0:0>
;  RW--V 
;  2434 : #define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT          EQU             000000000h
;  RW--V 
;  2435 : #define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT              EQU             000000001h
;  RWXVF 
;  2436 : #define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
NV_PGRAPH_DMA_TLB_PTE_ACCESS            TEXTEQU         <1:1>
;  RW--V 
;  2437 : #define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY          EQU             000000000h
;  RW--V 
;  2438 : #define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE         EQU             000000001h
;  RWXUF 
;  2439 : #define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS             TEXTEQU         <31:12>
;  RW-4R 
;  2440 : #define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
NV_PGRAPH_DMA_TLB_TAG           EQU             000401240h
;  RWXUF 
;  2441 : #define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
NV_PGRAPH_DMA_TLB_TAG_ADDRESS           TEXTEQU         <31:12>
;  RW-4R 
;  2442 : #define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
NV_PGRAPH_DMA_ADJ_OFFSET                EQU             000401250h
;  RWXUF 
;  2443 : #define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
NV_PGRAPH_DMA_ADJ_OFFSET_VALUE          TEXTEQU         <31:0>
;  RW-4R 
;  2444 : #define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
NV_PGRAPH_DMA_OFFSET            EQU             000401260h
;  RW-UF 
;  2445 : #define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
NV_PGRAPH_DMA_OFFSET_VALUE              TEXTEQU         <31:0>
;  RW-4R 
;  2446 : #define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
NV_PGRAPH_DMA_SIZE              EQU             000401270h
;  RW-UF 
;  2447 : #define NV_PGRAPH_DMA_SIZE_VALUE                               18:0 /* RW-UF */
NV_PGRAPH_DMA_SIZE_VALUE                TEXTEQU         <18:0>
;  RW-4R 
;  2448 : #define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
NV_PGRAPH_DMA_XLATE_INST                EQU             000401280h
;  RWXUF 
;  2449 : #define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
NV_PGRAPH_DMA_XLATE_INST_VALUE          TEXTEQU         <15:0>
;  RW-4R 
;  2450 : #define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
NV_PGRAPH_DMA_Y_SIZE            EQU             000401290h
;  RW-UF 
;  2451 : #define NV_PGRAPH_DMA_Y_SIZE_VALUE                             18:0 /* RW-UF */
NV_PGRAPH_DMA_Y_SIZE_VALUE              TEXTEQU         <18:0>
;  RW-4R 
;  2452 : #define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
NV_PGRAPH_DMA_LINEAR_LIMIT              EQU             000401400h
;  RWXUF 
;  2453 : #define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       21:0 /* RWXUF */
NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                TEXTEQU         <21:0>
;  RW-4A 
;        
;  2454 : #define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
;  2455 : #define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
NV_PGRAPH_DMA_START__SIZE_1             EQU             3t
;  RWXUF 
;  2456 : #define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
NV_PGRAPH_DMA_START_VALUE               TEXTEQU         <31:0>
;  RW-4R 
;  2457 : #define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
NV_PGRAPH_DMA_PITCH             EQU             000401830h
;  RWXS4 
;  2458 : #define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
NV_PGRAPH_DMA_PITCH_0           TEXTEQU         <15:0>
;  RWXS4 
;  2459 : #define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
NV_PGRAPH_DMA_PITCH_1           TEXTEQU         <31:16>
;  RW-4R 
;  2460 : #define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
NV_PGRAPH_DMA_FORMAT            EQU             000401840h
;  RWXS4 
;  2461 : #define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
NV_PGRAPH_DMA_FORMAT_SRC                TEXTEQU         <2:0>
;  RW--V 
;  2462 : #define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
NV_PGRAPH_DMA_FORMAT_SRC_INC_1          EQU             000000001h
;  RW--V 
;  2463 : #define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
NV_PGRAPH_DMA_FORMAT_SRC_INC_2          EQU             000000002h
;  RW--V 
;  2464 : #define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
NV_PGRAPH_DMA_FORMAT_SRC_INC_4          EQU             000000004h
;  RWXS4 
;  2465 : #define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
NV_PGRAPH_DMA_FORMAT_DST                TEXTEQU         <10:8>
;  RW--V 
;  2466 : #define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
NV_PGRAPH_DMA_FORMAT_DST_INC_1          EQU             000000001h
;  RW--V 
;  2467 : #define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
NV_PGRAPH_DMA_FORMAT_DST_INC_2          EQU             000000002h
;  RW--V 
;  2468 : #define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
NV_PGRAPH_DMA_FORMAT_DST_INC_4          EQU             000000004h
;  RW-4R 
;  2469 : #define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
NV_PGRAPH_DMA_MTMF_NOTIFY               EQU             000401820h
;  RWIVF 
;  2470 : #define NV_PGRAPH_MTMF_NOTIFY_TYPE                             31:0 /* RWIVF */
NV_PGRAPH_MTMF_NOTIFY_TYPE              TEXTEQU         <31:0>
;  RWI-V 
;  2471 : #define NV_PGRAPH_MTMF_NOTIFY_TYPE_HW                    0x00000000 /* RWI-V */
NV_PGRAPH_MTMF_NOTIFY_TYPE_HW           EQU             000000000h
;  dev_video.ref 
;  RW--D 
;  2472 : /* dev_video.ref */
;  2473 : #define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
NV_PVIDEO               TEXTEQU         <0x006802FF:0x00680000>
;  RWI4R 
;  2474 : #define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
NV_PVIDEO_INTR_0                EQU             000680100h
;  RWIVF 
;  2475 : #define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
NV_PVIDEO_INTR_0_NOTIFY         TEXTEQU         <0:0>
;  R-I-V 
;  2476 : #define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING             EQU             000000000h
;  R---V 
;  2477 : #define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
NV_PVIDEO_INTR_0_NOTIFY_PENDING         EQU             000000001h
;  -W--V 
;  2478 : #define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
NV_PVIDEO_INTR_0_NOTIFY_RESET           EQU             000000001h
;  RWI4R 
;  2479 : #define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
NV_PVIDEO_INTR_EN_0             EQU             000680140h
;  RWIVF 
;  2480 : #define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
NV_PVIDEO_INTR_EN_0_NOTIFY              TEXTEQU         <0:0>
;  RWI-V 
;  2481 : #define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED             EQU             000000000h
;  RW--V 
;  2482 : #define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED              EQU             000000001h
;  RW-4R 
;  2483 : #define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
NV_PVIDEO_STEP_SIZE             EQU             000680200h
;  RWXVF 
;  2484 : #define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
NV_PVIDEO_STEP_SIZE_X           TEXTEQU         <11:0>
;  RWXVF 
;  2485 : #define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
NV_PVIDEO_STEP_SIZE_Y           TEXTEQU         <27:16>
;  RW-4R 
;  2486 : #define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
NV_PVIDEO_CONTROL_Y             EQU             000680204h
;  RW--F 
;  2487 : #define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
NV_PVIDEO_CONTROL_Y_BLUR                TEXTEQU         <0:0>
;  RW--V 
;  2488 : #define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_Y_BLUR_OFF            EQU             000000000h
;  RW--V 
;  2489 : #define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_Y_BLUR_ON             EQU             000000001h
;  RW--F 
;  2490 : #define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
NV_PVIDEO_CONTROL_Y_LINE                TEXTEQU         <4:4>
;  RW--V 
;  2491 : #define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_Y_LINE_HALF           EQU             000000000h
;  RW--V 
;  2492 : #define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_Y_LINE_FULL           EQU             000000001h
;  RW-4R 
;  2493 : #define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
NV_PVIDEO_CONTROL_X             EQU             000680208h
;  RW--F 
;  2494 : #define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
NV_PVIDEO_CONTROL_X_WEIGHT              TEXTEQU         <0:0>
;  RW--V 
;  2495 : #define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                EQU             000000000h
;  RW--V 
;  2496 : #define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                EQU             000000001h
;  RW--F 
;  2497 : #define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
NV_PVIDEO_CONTROL_X_SHARPENING          TEXTEQU         <4:4>
;  RW--V 
;  2498 : #define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_X_SHARPENING_OFF              EQU             000000000h
;  RW--V 
;  2499 : #define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_X_SHARPENING_ON               EQU             000000001h
;  RW--F 
;  2500 : #define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
NV_PVIDEO_CONTROL_X_SMOOTHING           TEXTEQU         <8:8>
;  RW--V 
;  2501 : #define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_X_SMOOTHING_OFF               EQU             000000000h
;  RW--V 
;  2502 : #define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_X_SMOOTHING_ON                EQU             000000001h
;  RW-4R 
;  2503 : #define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
NV_PVIDEO_BUFF0_START           EQU             00068020ch
;  RW-UF 
;  2504 : #define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
NV_PVIDEO_BUFF0_START_ADDRESS           TEXTEQU         <22:2>
;  RW-4R 
;  2505 : #define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
NV_PVIDEO_BUFF1_START           EQU             000680210h
;  RW-UF 
;  2506 : #define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
NV_PVIDEO_BUFF1_START_ADDRESS           TEXTEQU         <22:2>
;  RW-4R 
;  2507 : #define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
NV_PVIDEO_BUFF0_PITCH           EQU             000680214h
;  RW-UF 
;  2508 : #define NV_PVIDEO_BUFF0_PITCH_LENGTH                           11:2 /* RW-UF */
NV_PVIDEO_BUFF0_PITCH_LENGTH            TEXTEQU         <11:2>
;  RW-4R 
;  2509 : #define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
NV_PVIDEO_BUFF1_PITCH           EQU             000680218h
;  RW-UF 
;  2510 : #define NV_PVIDEO_BUFF1_PITCH_LENGTH                           11:2 /* RW-UF */
NV_PVIDEO_BUFF1_PITCH_LENGTH            TEXTEQU         <11:2>
;  RW-4R 
;  2511 : #define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
NV_PVIDEO_BUFF0_OFFSET          EQU             00068021ch
;  RW--F 
;  2512 : #define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
NV_PVIDEO_BUFF0_OFFSET_X                TEXTEQU         <0:0>
;  RW--V 
;  2513 : #define NV_PVIDEO_BUFF0_OFFSET_X_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_X_OFF            EQU             000000000h
;  RW--V 
;  2514 : #define NV_PVIDEO_BUFF0_OFFSET_X_ON                      0x00000001 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_X_ON             EQU             000000001h
;  RW--F 
;  2515 : #define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
NV_PVIDEO_BUFF0_OFFSET_Y                TEXTEQU         <5:4>
;  RW--V 
;  2516 : #define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_Y_OFF            EQU             000000000h
;  RW--V 
;  2517 : #define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                EQU             000000001h
;  RW--V 
;  2518 : #define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_Y_HALF           EQU             000000002h
;  RW-4R 
;  2519 : #define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
NV_PVIDEO_BUFF1_OFFSET          EQU             000680220h
;  RW--F 
;  2520 : #define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
NV_PVIDEO_BUFF1_OFFSET_X                TEXTEQU         <0:0>
;  RW--V 
;  2521 : #define NV_PVIDEO_BUFF1_OFFSET_X_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_X_OFF            EQU             000000000h
;  RW--V 
;  2522 : #define NV_PVIDEO_BUFF1_OFFSET_X_ON                      0x00000001 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_X_ON             EQU             000000001h
;  RW--F 
;  2523 : #define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
NV_PVIDEO_BUFF1_OFFSET_Y                TEXTEQU         <5:4>
;  RW--V 
;  2524 : #define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_Y_OFF            EQU             000000000h
;  RW--V 
;  2525 : #define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                EQU             000000001h
;  RW--V 
;  2526 : #define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_Y_HALF           EQU             000000002h
;  RW-4R 
;  2527 : #define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
NV_PVIDEO_OE_STATE              EQU             000680224h
;  RWXVF 
;  2528 : #define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY            TEXTEQU         <0:0>
;  RWXVF 
;  2529 : #define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY            TEXTEQU         <4:4>
;  RWXVF 
;  2530 : #define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF0_ERROR          TEXTEQU         <8:8>
;  RWXVF 
;  2531 : #define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF1_ERROR          TEXTEQU         <12:12>
;  RWXVF 
;  2532 : #define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF0_IN_USE         TEXTEQU         <16:16>
;  RWXVF 
;  2533 : #define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF1_IN_USE         TEXTEQU         <20:20>
;  RWXVF 
;  2534 : #define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
NV_PVIDEO_OE_STATE_CURRENT_BUFFER               TEXTEQU         <24:24>
;  RW--V 
;  2535 : #define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0             EQU             000000000h
;  RW--V 
;  2536 : #define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1             EQU             000000001h
;  RW-4R 
;  2537 : #define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
NV_PVIDEO_SU_STATE              EQU             000680228h
;  RWXVF 
;  2538 : #define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
NV_PVIDEO_SU_STATE_BUFF0_IN_USE         TEXTEQU         <16:16>
;  RWXVF 
;  2539 : #define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
NV_PVIDEO_SU_STATE_BUFF1_IN_USE         TEXTEQU         <20:20>
;  RW-4R 
;  2540 : #define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
NV_PVIDEO_RM_STATE              EQU             00068022ch
;  RWXVF 
;  2541 : #define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY            TEXTEQU         <0:0>
;  RWXVF 
;  2542 : #define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY            TEXTEQU         <4:4>
;  RW-4R 
;  2543 : #define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
NV_PVIDEO_WINDOW_START          EQU             000680230h
;  RWXUF 
;  2544 : #define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
NV_PVIDEO_WINDOW_START_X                TEXTEQU         <10:0>
;  RWXUF 
;  2545 : #define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
NV_PVIDEO_WINDOW_START_Y                TEXTEQU         <26:16>
;  RW-4R 
;  2546 : #define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
NV_PVIDEO_WINDOW_SIZE           EQU             000680234h
;  RWXUF 
;  2547 : #define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
NV_PVIDEO_WINDOW_SIZE_X         TEXTEQU         <10:0>
;  RWXUF 
;  2548 : #define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
NV_PVIDEO_WINDOW_SIZE_Y         TEXTEQU         <26:16>
;  RW-4R 
;  2549 : #define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
NV_PVIDEO_FIFO_THRES            EQU             000680238h
;  RW--F 
;  2550 : #define NV_PVIDEO_FIFO_THRES_SIZE                               7:3 /* RW--F */
NV_PVIDEO_FIFO_THRES_SIZE               TEXTEQU         <7:3>
;  RW-4R 
;  2551 : #define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
NV_PVIDEO_FIFO_BURST            EQU             00068023ch
;  RW--F 
;  2552 : #define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
NV_PVIDEO_FIFO_BURST_LENGTH             TEXTEQU         <1:0>
;  RW--V 
;  2553 : #define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
NV_PVIDEO_FIFO_BURST_LENGTH_32          EQU             000000001h
;  RW--V 
;  2554 : #define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
NV_PVIDEO_FIFO_BURST_LENGTH_64          EQU             000000002h
;  RW--V 
;  2555 : #define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
NV_PVIDEO_FIFO_BURST_LENGTH_128         EQU             000000003h
;  RW-4R 
;  2556 : #define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
NV_PVIDEO_KEY           EQU             000680240h
;  RW-VF 
;  2557 : #define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
NV_PVIDEO_KEY_INDEX             TEXTEQU         <7:0>
;  RW-VF 
;  2558 : #define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
NV_PVIDEO_KEY_565               TEXTEQU         <15:0>
;  RW-VF 
;  2559 : #define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
NV_PVIDEO_KEY_555               TEXTEQU         <14:0>
;  RW-VF 
;  2560 : #define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
NV_PVIDEO_KEY_888               TEXTEQU         <23:0>
;  RW-VF 
;  2561 : #define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
NV_PVIDEO_KEY_PACK              TEXTEQU         <31:24>
;  RWI4R 
;  2562 : #define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
NV_PVIDEO_OVERLAY               EQU             000680244h
;  RWI-F 
;  2563 : #define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
NV_PVIDEO_OVERLAY_VIDEO         TEXTEQU         <0:0>
;  RWI-V 
;  2564 : #define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
NV_PVIDEO_OVERLAY_VIDEO_OFF             EQU             000000000h
;  RW--V 
;  2565 : #define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
NV_PVIDEO_OVERLAY_VIDEO_ON              EQU             000000001h
;  RW--F 
;  2566 : #define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
NV_PVIDEO_OVERLAY_KEY           TEXTEQU         <4:4>
;  RW--V 
;  2567 : #define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
NV_PVIDEO_OVERLAY_KEY_OFF               EQU             000000000h
;  RW--V 
;  2568 : #define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
NV_PVIDEO_OVERLAY_KEY_ON                EQU             000000001h
;  RW--F 
;  2569 : #define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
NV_PVIDEO_OVERLAY_FORMAT                TEXTEQU         <8:8>
;  RW--V 
;  2570 : #define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
NV_PVIDEO_OVERLAY_FORMAT_CCIR           EQU             000000000h
;  RW--V 
;  2571 : #define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
NV_PVIDEO_OVERLAY_FORMAT_YUY2           EQU             000000001h
;  RW-4R 
;  2572 : #define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
NV_PVIDEO_RED_CSC               EQU             000680280h
;  RWX-F 
;  2573 : #define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
NV_PVIDEO_RED_CSC_OFFSET                TEXTEQU         <7:0>
;  RW-4R 
;  2574 : #define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
NV_PVIDEO_GREEN_CSC             EQU             000680284h
;  RWX-F 
;  2575 : #define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
NV_PVIDEO_GREEN_CSC_OFFSET              TEXTEQU         <7:0>
;  RW-4R 
;  2576 : #define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
NV_PVIDEO_BLUE_CSC              EQU             000680288h
;  RWX-F 
;  2577 : #define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
NV_PVIDEO_BLUE_CSC_OFFSET               TEXTEQU         <7:0>
;  RW-4R 
;  2578 : #define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
NV_PVIDEO_CSC_ADJUST            EQU             00068028ch
;  RW--F 
;  2579 : #define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
NV_PVIDEO_CSC_ADJUST_B_FLAG             TEXTEQU         <0:0>
;  RW--V 
;  2580 : #define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2581 : #define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_B_FLAG_ON          EQU             000000001h
;  RW--F 
;  2582 : #define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
NV_PVIDEO_CSC_ADJUST_G_FLAG             TEXTEQU         <4:4>
;  RW--V 
;  2583 : #define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2584 : #define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_G_FLAG_ON          EQU             000000001h
;  RW--F 
;  2585 : #define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
NV_PVIDEO_CSC_ADJUST_R_FLAG             TEXTEQU         <8:8>
;  RW--V 
;  2586 : #define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2587 : #define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_R_FLAG_ON          EQU             000000001h
;  RW--F 
;  2588 : #define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
NV_PVIDEO_CSC_ADJUST_L_FLAG             TEXTEQU         <12:12>
;  RW--V 
;  2589 : #define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2590 : #define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_L_FLAG_ON          EQU             000000001h
;  RW--F 
;  2591 : #define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
NV_PVIDEO_CSC_ADJUST_CHROMA             TEXTEQU         <16:16>
;  RW--V 
;  2592 : #define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_CHROMA_OFF         EQU             000000000h
;  RW--V 
;  2593 : #define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_CHROMA_ON          EQU             000000001h
;  vga.ref 
;  RW--D 
;  2594 : /* vga.ref */
;  2595 : #define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
NV_PRMCIO               TEXTEQU         <0x00601FFF:0x00601000>
;  R--1R 
;  2596 : #define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
NV_PRMCIO_INP0          EQU             0006013c2h
;  R--1R 
;  2597 : #define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
NV_PRMCIO_INP0__MONO            EQU             0006013bah
;  R--1R 
;  2598 : #define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
NV_PRMCIO_INP0__COLOR           EQU             0006013dah
;  R--1R 
;  2599 : #define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
NV_PRMCIO_INP0__READ_MONO               EQU             0006013cah
;  -W-1R 
;  2600 : #define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
NV_PRMCIO_INP0__WRITE_MONO              EQU             0006013bah
;  -W-1R 
;  2601 : #define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
NV_PRMCIO_INP0__WRITE_COLOR             EQU             0006013dah
;  RW-1R 
;  2602 : #define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
NV_PRMCIO_ARX           EQU             0006013c0h
;  -W-1R 
;  2603 : #define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
NV_PRMCIO_AR_PALETTE__WRITE             EQU             0006013c0h
;  R--1R 
;  2604 : #define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
NV_PRMCIO_AR_PALETTE__READ              EQU             0006013c1h
;  -W-1R 
;  2605 : #define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
NV_PRMCIO_AR_MODE__WRITE                EQU             0006013c0h
;  R--1R 
;  2606 : #define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
NV_PRMCIO_AR_MODE__READ         EQU             0006013c1h
;        
;  2607 : #define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
NV_PRMCIO_AR_MODE_INDEX         EQU             000000010h
;  -W-1R 
;  2608 : #define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
NV_PRMCIO_AR_OSCAN__WRITE               EQU             0006013c0h
;  R--1R 
;  2609 : #define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
NV_PRMCIO_AR_OSCAN__READ                EQU             0006013c1h
;        
;  2610 : #define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
NV_PRMCIO_AR_OSCAN_INDEX                EQU             000000011h
;  -W-1R 
;  2611 : #define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
NV_PRMCIO_AR_PLANE__WRITE               EQU             0006013c0h
;  R--1R 
;  2612 : #define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
NV_PRMCIO_AR_PLANE__READ                EQU             0006013c1h
;        
;  2613 : #define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
NV_PRMCIO_AR_PLANE_INDEX                EQU             000000012h
;  -W-1R 
;  2614 : #define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
NV_PRMCIO_AR_HPP__WRITE         EQU             0006013c0h
;  R--1R 
;  2615 : #define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
NV_PRMCIO_AR_HPP__READ          EQU             0006013c1h
;        
;  2616 : #define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
NV_PRMCIO_AR_HPP_INDEX          EQU             000000013h
;  -W-1R 
;  2617 : #define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
NV_PRMCIO_AR_CSEL__WRITE                EQU             0006013c0h
;  R--1R 
;  2618 : #define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
NV_PRMCIO_AR_CSEL__READ         EQU             0006013c1h
;        
;  2619 : #define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
NV_PRMCIO_AR_CSEL_INDEX         EQU             000000014h
;  RW-1R 
;  2620 : #define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
NV_PRMCIO_CRX__MONO             EQU             0006013b4h
;  RW-1R 
;  2621 : #define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
NV_PRMCIO_CRX__COLOR            EQU             0006013d4h
;  RW-1R 
;  2622 : #define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
NV_PRMCIO_CR__MONO              EQU             0006013b5h
;  RW-1R 
;  2623 : #define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
NV_PRMCIO_CR__COLOR             EQU             0006013d5h
;  RW-1R 
;  2624 : #define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
NV_PRMCIO_CRE__MONO             EQU             0006013b5h
;  RW-1R 
;  2625 : #define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */
NV_PRMCIO_CRE__COLOR            EQU             0006013d5h
;  vga.ref 
;  ----- 
;  2626 : /* vga.ref */
;  2627 : #define NV_CIO                                          0x3DF:0x3B0 /* ----- */
NV_CIO          TEXTEQU         <0x3DF:0x3B0>
;  R--1R 
;  2628 : #define NV_CIO_INP0                                      0x000003c2 /* R--1R */
NV_CIO_INP0             EQU             0000003c2h
;  R--1R 
;  2629 : #define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
NV_CIO_INP0__MONO               EQU             0000003bah
;  R--1R 
;  2630 : #define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
NV_CIO_INP0__COLOR              EQU             0000003dah
;  R--1R 
;  2631 : #define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
NV_CIO_INP0__READ_MONO          EQU             0000003cah
;  -W-1R 
;  2632 : #define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
NV_CIO_INP0__WRITE_MONO         EQU             0000003bah
;  -W-1R 
;  2633 : #define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
NV_CIO_INP0__WRITE_COLOR                EQU             0000003dah
;  RW-1R 
;  2634 : #define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
NV_CIO_ARX              EQU             0000003c0h
;  -W-1R 
;  2635 : #define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
NV_CIO_AR_PALETTE__WRITE                EQU             0000003c0h
;  R--1R 
;  2636 : #define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
NV_CIO_AR_PALETTE__READ         EQU             0000003c1h
;  -W-1R 
;  2637 : #define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
NV_CIO_AR_MODE__WRITE           EQU             0000003c0h
;  R--1R 
;  2638 : #define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
NV_CIO_AR_MODE__READ            EQU             0000003c1h
;        
;  2639 : #define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
NV_CIO_AR_MODE_INDEX            EQU             000000010h
;  -W-1R 
;  2640 : #define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
NV_CIO_AR_OSCAN__WRITE          EQU             0000003c0h
;  R--1R 
;  2641 : #define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
NV_CIO_AR_OSCAN__READ           EQU             0000003c1h
;        
;  2642 : #define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
NV_CIO_AR_OSCAN_INDEX           EQU             000000011h
;  -W-1R 
;  2643 : #define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
NV_CIO_AR_PLANE__WRITE          EQU             0000003c0h
;  R--1R 
;  2644 : #define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
NV_CIO_AR_PLANE__READ           EQU             0000003c1h
;        
;  2645 : #define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
NV_CIO_AR_PLANE_INDEX           EQU             000000012h
;  -W-1R 
;  2646 : #define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
NV_CIO_AR_HPP__WRITE            EQU             0000003c0h
;  R--1R 
;  2647 : #define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
NV_CIO_AR_HPP__READ             EQU             0000003c1h
;        
;  2648 : #define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
NV_CIO_AR_HPP_INDEX             EQU             000000013h
;  -W-1R 
;  2649 : #define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
NV_CIO_AR_CSEL__WRITE           EQU             0000003c0h
;  R--1R 
;  2650 : #define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
NV_CIO_AR_CSEL__READ            EQU             0000003c1h
;        
;  2651 : #define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
NV_CIO_AR_CSEL_INDEX            EQU             000000014h
;  RW-1R 
;  2652 : #define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
NV_CIO_CRX__MONO                EQU             0000003b4h
;  RW-1R 
;  2653 : #define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
NV_CIO_CRX__COLOR               EQU             0000003d4h
;  RW-1R 
;  2654 : #define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
NV_CIO_CR__MONO         EQU             0000003b5h
;  RW-1R 
;  2655 : #define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
NV_CIO_CR__COLOR                EQU             0000003d5h
;        
;  2656 : #define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
NV_CIO_CR_HDT_INDEX             EQU             000000000h
;        
;  2657 : #define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
NV_CIO_CR_HDE_INDEX             EQU             000000001h
;        
;  2658 : #define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
NV_CIO_CR_HBS_INDEX             EQU             000000002h
;        
;  2659 : #define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
NV_CIO_CR_HBE_INDEX             EQU             000000003h
;  RW--F 
;  2660 : #define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
NV_CIO_CR_HBE_4_0               TEXTEQU         <4:0>
;        
;  2661 : #define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
NV_CIO_CR_HRS_INDEX             EQU             000000004h
;        
;  2662 : #define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
NV_CIO_CR_HRE_INDEX             EQU             000000005h
;  RW--F 
;  2663 : #define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
NV_CIO_CR_HRE_HBE_5             TEXTEQU         <7:7>
;  RW--F 
;  2664 : #define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
NV_CIO_CR_HRE_4_0               TEXTEQU         <4:0>
;        
;  2665 : #define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
NV_CIO_CR_VDT_INDEX             EQU             000000006h
;        
;  2666 : #define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
NV_CIO_CR_OVL_INDEX             EQU             000000007h
;  RW--F 
;  2667 : #define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
NV_CIO_CR_OVL_VDE_8             TEXTEQU         <1:1>
;  RW--F 
;  2668 : #define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
NV_CIO_CR_OVL_VDE_9             TEXTEQU         <6:6>
;  RW--F 
;  2669 : #define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
NV_CIO_CR_OVL_VDT_8             TEXTEQU         <0:0>
;  RW--F 
;  2670 : #define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
NV_CIO_CR_OVL_VDT_9             TEXTEQU         <5:5>
;  RW--F 
;  2671 : #define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
NV_CIO_CR_OVL_VBS_8             TEXTEQU         <3:3>
;  RW--F 
;  2672 : #define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
NV_CIO_CR_OVL_VRS_8             TEXTEQU         <2:2>
;  RW--F 
;  2673 : #define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
NV_CIO_CR_OVL_VRS_9             TEXTEQU         <7:7>
;        
;  2674 : #define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
NV_CIO_CR_RSAL_INDEX            EQU             000000008h
;  RW--F 
;  2675 : #define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
NV_CIO_CR_RSAL_PANNING          TEXTEQU         <6:5>
;        
;  2676 : #define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
NV_CIO_CR_CELL_HT_INDEX         EQU             000000009h
;  RW--F 
;  2677 : #define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
NV_CIO_CR_CELL_HT_SCANDBL               TEXTEQU         <7:7>
;  RW--F 
;  2678 : #define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
NV_CIO_CR_CELL_HT_VBS_9         TEXTEQU         <5:5>
;        
;  2679 : #define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
NV_CIO_CR_CURS_ST_INDEX         EQU             00000000ah
;        
;  2680 : #define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
NV_CIO_CR_CURS_END_INDEX                EQU             00000000bh
;        
;  2681 : #define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
NV_CIO_CR_SA_HI_INDEX           EQU             00000000ch
;        
;  2682 : #define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
NV_CIO_CR_SA_LO_INDEX           EQU             00000000dh
;        
;  2683 : #define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
NV_CIO_CR_TCOFF_HI_INDEX                EQU             00000000eh
;        
;  2684 : #define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
NV_CIO_CR_TCOFF_LO_INDEX                EQU             00000000fh
;        
;  2685 : #define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
NV_CIO_CR_VRS_INDEX             EQU             000000010h
;        
;  2686 : #define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
NV_CIO_CR_VRE_INDEX             EQU             000000011h
;  RW--F 
;  2687 : #define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
NV_CIO_CR_VRE_3_0               TEXTEQU         <3:0>
;        
;  2688 : #define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
NV_CIO_CR_VDE_INDEX             EQU             000000012h
;        
;  2689 : #define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
NV_CIO_CR_OFFSET_INDEX          EQU             000000013h
;        
;  2690 : #define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
NV_CIO_CR_ULINE_INDEX           EQU             000000014h
;        
;  2691 : #define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
NV_CIO_CR_VBS_INDEX             EQU             000000015h
;        
;  2692 : #define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
NV_CIO_CR_VBE_INDEX             EQU             000000016h
;        
;  2693 : #define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
NV_CIO_CR_MODE_INDEX            EQU             000000017h
;        
;  2694 : #define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
NV_CIO_CR_LCOMP_INDEX           EQU             000000018h
;        
;  2695 : #define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
NV_CIO_CR_GDATA_INDEX           EQU             000000022h
;        
;  2696 : #define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
NV_CIO_CR_ARFF_INDEX            EQU             000000024h
;        
;  2697 : #define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
NV_CIO_CR_ARX_INDEX             EQU             000000026h
;  RW-1R 
;  2698 : #define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
NV_CIO_CRE__MONO                EQU             0000003b5h
;  RW-1R 
;  2699 : #define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
NV_CIO_CRE__COLOR               EQU             0000003d5h
;        
;  2700 : #define NV_CIO_CRE_RPC0_INDEX                            0x00000019 /*       */
NV_CIO_CRE_RPC0_INDEX           EQU             000000019h
;  RW--F 
;  2701 : #define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
NV_CIO_CRE_RPC0_START           TEXTEQU         <4:0>
;  RW--F 
;  2702 : #define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
NV_CIO_CRE_RPC0_OFFSET_10_8             TEXTEQU         <7:5>
;        
;  2703 : #define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
NV_CIO_CRE_RPC1_INDEX           EQU             00000001ah
;        
;  2704 : #define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
NV_CIO_CRE_FF_INDEX             EQU             00000001bh
;  RW--F 
;  2705 : #define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
NV_CIO_CRE_FF_BURST             TEXTEQU         <2:0>
;  RW--V 
;  2706 : #define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
NV_CIO_CRE_FF_BURST_8           EQU             000000000h
;  RW--V 
;  2707 : #define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
NV_CIO_CRE_FF_BURST_32          EQU             000000001h
;  RW--V 
;  2708 : #define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
NV_CIO_CRE_FF_BURST_64          EQU             000000002h
;  RW--V 
;  2709 : #define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
NV_CIO_CRE_FF_BURST_128         EQU             000000003h
;  RW--V 
;  2710 : #define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
NV_CIO_CRE_FF_BURST_256         EQU             000000004h
;        
;  2711 : #define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
NV_CIO_CRE_ENH_INDEX            EQU             00000001ch
;        
;  2712 : #define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
NV_CIO_CRE_PAGE0_INDEX          EQU             00000001dh
;        
;  2713 : #define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
NV_CIO_CRE_PAGE1_INDEX          EQU             00000001eh
;        
;  2714 : #define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
NV_CIO_CRE_FFLWM__INDEX         EQU             000000020h
;  RW--F 
;  2715 : #define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
NV_CIO_CRE_FFLWM_LWM            TEXTEQU         <5:0>
;        
;  2716 : #define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
NV_CIO_CRE_LSR_INDEX            EQU             000000025h
;  RW--F 
;  2717 : #define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
NV_CIO_CRE_LSR_FORMAT           TEXTEQU         <7:6>
;  RW--V 
;  2718 : #define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
NV_CIO_CRE_LSR_FORMAT_8BIT              EQU             000000001h
;  RW--V 
;  2719 : #define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
NV_CIO_CRE_LSR_FORMAT_555               EQU             000000002h
;  RW--V 
;  2720 : #define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
NV_CIO_CRE_LSR_FORMAT_565               EQU             000000003h
;  RW--F 
;  2721 : #define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
NV_CIO_CRE_LSR_VDE_10           TEXTEQU         <1:1>
;  RW--F 
;  2722 : #define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
NV_CIO_CRE_LSR_VDT_10           TEXTEQU         <0:0>
;  RW--F 
;  2723 : #define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
NV_CIO_CRE_LSR_HBE_6            TEXTEQU         <4:4>
;  RW--F 
;  2724 : #define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
NV_CIO_CRE_LSR_VBS_10           TEXTEQU         <3:3>
;  RW--F 
;  2725 : #define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
NV_CIO_CRE_LSR_VRS_10           TEXTEQU         <2:2>
;        
;  2726 : #define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
NV_CIO_CRE_PIXEL_INDEX          EQU             000000028h
;  RW--F 
;  2727 : #define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
NV_CIO_CRE_PIXEL_FORMAT         TEXTEQU         <1:0>
;  RW--V 
;  2728 : #define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_VGA             EQU             000000000h
;  RW--V 
;  2729 : #define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_8BPP            EQU             000000001h
;  RW--V 
;  2730 : #define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_16BPP           EQU             000000002h
;  RW--V 
;  2731 : #define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_32BPP           EQU             000000003h
;  RW--F 
;  2732 : #define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
NV_CIO_CRE_PIXEL_TILING         TEXTEQU         <2:2>
;        
;  2733 : #define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
NV_CIO_CRE_DEC__INDEX           EQU             000000029h
;        
;  2734 : #define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
NV_CIO_CRE_OSCOL__INDEX         EQU             00000002ah
;        
;  2735 : #define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
NV_CIO_CRE_SCRATCH0__INDEX              EQU             00000002bh
;        
;  2736 : #define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
NV_CIO_CRE_SCRATCH1__INDEX              EQU             00000002ch
;        
;  2737 : #define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
NV_CIO_CRE_HEB__INDEX           EQU             00000002dh
;  RW--F 
;  2738 : #define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
NV_CIO_CRE_HEB_ILC_8            TEXTEQU         <4:4>
;  RW--F 
;  2739 : #define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
NV_CIO_CRE_HEB_HRS_8            TEXTEQU         <3:3>
;  RW--F 
;  2740 : #define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
NV_CIO_CRE_HEB_HBS_8            TEXTEQU         <2:2>
;  RW--F 
;  2741 : #define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
NV_CIO_CRE_HEB_HDE_8            TEXTEQU         <1:1>
;  RW--F 
;  2742 : #define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
NV_CIO_CRE_HEB_HDT_8            TEXTEQU         <0:0>
;        
;  2743 : #define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
NV_CIO_CRE_HCUR_ADDR0_INDEX             EQU             000000030h
;  RW--F 
;  2744 : #define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
NV_CIO_CRE_HCUR_ADDR0_ADR               TEXTEQU         <6:0>
;        
;  2745 : #define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
NV_CIO_CRE_HCUR_ADDR1_INDEX             EQU             000000031h
;  RW--F 
;  2746 : #define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
NV_CIO_CRE_HCUR_ADDR1_ADR               TEXTEQU         <7:3>
;  RW--F 
;  2747 : #define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
NV_CIO_CRE_HCUR_ADDR1_CUR_DBL           TEXTEQU         <1:1>
;  RW--F 
;  2748 : #define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
NV_CIO_CRE_HCUR_ADDR1_ENABLE            TEXTEQU         <0:0>
;        
;  2749 : #define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
NV_CIO_CRE_VID_END0__INDEX              EQU             000000032h
;        
;  2750 : #define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
NV_CIO_CRE_VID_END1__INDEX              EQU             000000033h
;        
;  2751 : #define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
NV_CIO_CRE_RL0__INDEX           EQU             000000034h
;        
;  2752 : #define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
NV_CIO_CRE_RL1__INDEX           EQU             000000035h
;        
;  2753 : #define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
NV_CIO_CRE_RMA__INDEX           EQU             000000038h
;        
;  2754 : #define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
NV_CIO_CRE_ILACE__INDEX         EQU             000000039h
;        
;  2755 : #define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
NV_CIO_CRE_TREG__INDEX          EQU             00000003dh
;        
;  2756 : #define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
NV_CIO_CRE_DDC_STATUS__INDEX            EQU             00000003eh
;        
;  2757 : #define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
NV_CIO_CRE_DDC_WR__INDEX                EQU             00000003fh
;  vga.ref 
;  RW--D 
;  2758 : /* vga.ref */
;  2759 : #define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
NV_PRMVIO               TEXTEQU         <0x000C7FFF:0x000C0000>
;  RW-1R 
;  2760 : #define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
NV_PRMVIO_MBEN          EQU             0000c0094h
;  RW-1R 
;  2761 : #define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
NV_PRMVIO_ADDEN         EQU             0000c46e8h
;  RW-1R 
;  2762 : #define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
NV_PRMVIO_VSE1          EQU             0000c0102h
;  RW-1R 
;  2763 : #define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
NV_PRMVIO_VSE2          EQU             0000c03c3h
;  R--1R 
;  2764 : #define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
NV_PRMVIO_MISC__READ            EQU             0000c03cch
;  -W-1R 
;  2765 : #define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
NV_PRMVIO_MISC__WRITE           EQU             0000c03c2h
;  RW-1R 
;  2766 : #define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
NV_PRMVIO_SRX           EQU             0000c03c4h
;  RW-1R 
;  2767 : #define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_RESET              EQU             0000c03c5h
;        
;  2768 : #define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
NV_PRMVIO_SR_RESET_INDEX                EQU             000000000h
;  RW-1R 
;  2769 : #define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_CLOCK              EQU             0000c03c5h
;        
;  2770 : #define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
NV_PRMVIO_SR_CLOCK_INDEX                EQU             000000001h
;  RW-1R 
;  2771 : #define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_PLANE_MASK         EQU             0000c03c5h
;        
;  2772 : #define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
NV_PRMVIO_SR_PLANE_MASK_INDEX           EQU             000000002h
;  RW-1R 
;  2773 : #define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_CHAR_MAP           EQU             0000c03c5h
;        
;  2774 : #define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
NV_PRMVIO_SR_CHAR_MAP_INDEX             EQU             000000003h
;  RW-1R 
;  2775 : #define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_MEM_MODE           EQU             0000c03c5h
;        
;  2776 : #define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
NV_PRMVIO_SR_MEM_MODE_INDEX             EQU             000000004h
;  RW-1R 
;  2777 : #define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_LOCK               EQU             0000c03c5h
;        
;  2778 : #define NV_PRMVIO_SR_LOCK_INDEX                          0x00000005 /*       */
NV_PRMVIO_SR_LOCK_INDEX         EQU             000000005h
;  RW-1R 
;  2779 : #define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
NV_PRMVIO_GRX           EQU             0000c03ceh
;  RW-1R 
;  2780 : #define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
NV_PRMVIO_GX_SR         EQU             0000c03cfh
;        
;  2781 : #define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
NV_PRMVIO_GX_SR_INDEX           EQU             000000000h
;  RW-1R 
;  2782 : #define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
NV_PRMVIO_GX_SREN               EQU             0000c03cfh
;        
;  2783 : #define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
NV_PRMVIO_GX_SREN_INDEX         EQU             000000001h
;  RW-1R 
;  2784 : #define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
NV_PRMVIO_GX_CCOMP              EQU             0000c03cfh
;        
;  2785 : #define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
NV_PRMVIO_GX_CCOMP_INDEX                EQU             000000002h
;  RW-1R 
;  2786 : #define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
NV_PRMVIO_GX_ROP                EQU             0000c03cfh
;        
;  2787 : #define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
NV_PRMVIO_GX_ROP_INDEX          EQU             000000003h
;  RW-1R 
;  2788 : #define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
NV_PRMVIO_GX_READ_MAP           EQU             0000c03cfh
;        
;  2789 : #define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
NV_PRMVIO_GX_READ_MAP_INDEX             EQU             000000004h
;  RW-1R 
;  2790 : #define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
NV_PRMVIO_GX_MODE               EQU             0000c03cfh
;        
;  2791 : #define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
NV_PRMVIO_GX_MODE_INDEX         EQU             000000005h
;  RW-1R 
;  2792 : #define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
NV_PRMVIO_GX_MISC               EQU             0000c03cfh
;        
;  2793 : #define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
NV_PRMVIO_GX_MISC_INDEX         EQU             000000006h
;  RW-1R 
;  2794 : #define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
NV_PRMVIO_GX_DONT_CARE          EQU             0000c03cfh
;        
;  2795 : #define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
NV_PRMVIO_GX_DONT_CARE_INDEX            EQU             000000007h
;  RW-1R 
;  2796 : #define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
NV_PRMVIO_GX_BIT_MASK           EQU             0000c03cfh
;        
;  2797 : #define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
NV_PRMVIO_GX_BIT_MASK_INDEX             EQU             000000008h
;  vga.ref 
;  RW--D 
;  2798 : /* vga.ref */
;  2799 : #define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
NV_PRMVGA               TEXTEQU         <0x000BFFFF:0x000A0000>
;  dev_media.ref 
;  RW--D 
;  2800 : /* dev_media.ref */
;  2801 : #define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
NV_PME          TEXTEQU         <0x00200FFF:0x00200000>
;  RWI4R 
;  2802 : #define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
NV_PME_INTR_0           EQU             000200100h
;  RWIVF 
;  2803 : #define NV_PME_INTR_0_NOTIFY                                    0:0 /* RWIVF */
NV_PME_INTR_0_NOTIFY            TEXTEQU         <0:0>
;  R-I-V 
;  2804 : #define NV_PME_INTR_0_NOTIFY_NOT_PENDING                 0x00000000 /* R-I-V */
NV_PME_INTR_0_NOTIFY_NOT_PENDING                EQU             000000000h
;  R---V 
;  2805 : #define NV_PME_INTR_0_NOTIFY_PENDING                     0x00000001 /* R---V */
NV_PME_INTR_0_NOTIFY_PENDING            EQU             000000001h
;  -W--V 
;  2806 : #define NV_PME_INTR_0_NOTIFY_RESET                       0x00000001 /* -W--V */
NV_PME_INTR_0_NOTIFY_RESET              EQU             000000001h
;  RWIVF 
;  2807 : #define NV_PME_INTR_0_VMI                                       4:4 /* RWIVF */
NV_PME_INTR_0_VMI               TEXTEQU         <4:4>
;  R-I-V 
;  2808 : #define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
NV_PME_INTR_0_VMI_NOT_PENDING           EQU             000000000h
;  R---V 
;  2809 : #define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
NV_PME_INTR_0_VMI_PENDING               EQU             000000001h
;  -W--V 
;  2810 : #define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
NV_PME_INTR_0_VMI_RESET         EQU             000000001h
;  RWI4R 
;  2811 : #define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
NV_PME_INTR_EN_0                EQU             000200140h
;  RWIVF 
;  2812 : #define NV_PME_INTR_EN_0_NOTIFY                                 0:0 /* RWIVF */
NV_PME_INTR_EN_0_NOTIFY         TEXTEQU         <0:0>
;  RWI-V 
;  2813 : #define NV_PME_INTR_EN_0_NOTIFY_DISABLED                 0x00000000 /* RWI-V */
NV_PME_INTR_EN_0_NOTIFY_DISABLED                EQU             000000000h
;  RW--V 
;  2814 : #define NV_PME_INTR_EN_0_NOTIFY_ENABLED                  0x00000001 /* RW--V */
NV_PME_INTR_EN_0_NOTIFY_ENABLED         EQU             000000001h
;  RWIVF 
;  2815 : #define NV_PME_INTR_EN_0_VMI                                    4:4 /* RWIVF */
NV_PME_INTR_EN_0_VMI            TEXTEQU         <4:4>
;  RWI-V 
;  2816 : #define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
NV_PME_INTR_EN_0_VMI_DISABLED           EQU             000000000h
;  RW--V 
;  2817 : #define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
NV_PME_INTR_EN_0_VMI_ENABLED            EQU             000000001h
;  RWI4R 
;  2818 : #define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
NV_PME_CONFIG_0         EQU             000200200h
;  RWIVF 
;  2819 : #define NV_PME_CONFIG_0_CCIR656                                 0:0 /* RWIVF */
NV_PME_CONFIG_0_CCIR656         TEXTEQU         <0:0>
;  RWI-V 
;  2820 : #define NV_PME_CONFIG_0_CCIR656_DISABLED                 0x00000000 /* RWI-V */
NV_PME_CONFIG_0_CCIR656_DISABLED                EQU             000000000h
;  RW--V 
;  2821 : #define NV_PME_CONFIG_0_CCIR656_ENABLED                  0x00000001 /* RW--V */
NV_PME_CONFIG_0_CCIR656_ENABLED         EQU             000000001h
;  RWIVF 
;  2822 : #define NV_PME_CONFIG_0_VMI                                     4:4 /* RWIVF */
NV_PME_CONFIG_0_VMI             TEXTEQU         <4:4>
;  RWI-V 
;  2823 : #define NV_PME_CONFIG_0_VMI_DISABLED                     0x00000000 /* RWI-V */
NV_PME_CONFIG_0_VMI_DISABLED            EQU             000000000h
;  RW--V 
;  2824 : #define NV_PME_CONFIG_0_VMI_ENABLED                      0x00000001 /* RW--V */
NV_PME_CONFIG_0_VMI_ENABLED             EQU             000000001h
;  RWIVF 
;  2825 : #define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
NV_PME_CONFIG_0_VBI_MODE                TEXTEQU         <9:8>
;  RWI-V 
;  2826 : #define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
NV_PME_CONFIG_0_VBI_MODE_DISABLED               EQU             000000000h
;  RW--V 
;  2827 : #define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
NV_PME_CONFIG_0_VBI_MODE_1              EQU             000000001h
;  RW--V 
;  2828 : #define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
NV_PME_CONFIG_0_VBI_MODE_2              EQU             000000002h
;  RWIVF 
;  2829 : #define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
NV_PME_CONFIG_0_VID_CD          TEXTEQU         <12:12>
;  RWI-V 
;  2830 : #define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
NV_PME_CONFIG_0_VID_CD_DISABLED         EQU             000000000h
;  RW--V 
;  2831 : #define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
NV_PME_CONFIG_0_VID_CD_ENABLED          EQU             000000001h
;  RWIVF 
;  2832 : #define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
NV_PME_CONFIG_0_AUD_CD          TEXTEQU         <16:16>
;  RWI-V 
;  2833 : #define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
NV_PME_CONFIG_0_AUD_CD_DISABLED         EQU             000000000h
;  RW--V 
;  2834 : #define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
NV_PME_CONFIG_0_AUD_CD_ENABLED          EQU             000000001h
;  RWI4R 
;  2835 : #define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
NV_PME_CONFIG_1         EQU             000200204h
;  RWIVF 
;  2836 : #define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
NV_PME_CONFIG_1_BUFFS           TEXTEQU         <0:0>
;  RWI-V 
;  2837 : #define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
NV_PME_CONFIG_1_BUFFS_PNVM              EQU             000000000h
;  RW--V 
;  2838 : #define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
NV_PME_CONFIG_1_BUFFS_SYS               EQU             000000001h
;  RWIVF 
;  2839 : #define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
NV_PME_CONFIG_1_HOST            TEXTEQU         <4:4>
;  RWI-V 
;  2840 : #define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
NV_PME_CONFIG_1_HOST_PCI                EQU             000000000h
;  RW--V 
;  2841 : #define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
NV_PME_CONFIG_1_HOST_AGP                EQU             000000001h
;  RWI4R 
;  2842 : #define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
NV_PME_VID_BUFF0_START_SYS              EQU             000200300h
;  RWXUF 
;  2843 : #define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_VID_BUFF0_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2844 : #define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
NV_PME_VID_BUFF1_START_SYS              EQU             000200304h
;  RWXUF 
;  2845 : #define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_VID_BUFF1_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2846 : #define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
NV_PME_VID_BUFF0_START_PNVM             EQU             000200308h
;  RWXUF 
;  2847 : #define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_VID_BUFF0_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2848 : #define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
NV_PME_VID_BUFF1_START_PNVM             EQU             00020030ch
;  RWXUF 
;  2849 : #define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_VID_BUFF1_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2850 : #define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
NV_PME_VID_BUFF0_LENGTH         EQU             000200310h
;  RWXUF 
;  2851 : #define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
NV_PME_VID_BUFF0_LENGTH_BITS            TEXTEQU         <15:12>
;  RWI4R 
;  2852 : #define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
NV_PME_VID_BUFF1_LENGTH         EQU             000200314h
;  RWXUF 
;  2853 : #define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
NV_PME_VID_BUFF1_LENGTH_BITS            TEXTEQU         <15:12>
;  RW-4R 
;  2854 : #define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
NV_PME_VID_ME_STATE             EQU             000200318h
;  RWIVF 
;  2855 : #define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2856 : #define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2857 : #define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2858 : #define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWXVF 
;  2859 : #define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2860 : #define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RWXVF 
;  2861 : #define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
NV_PME_VID_ME_STATE_CURRENT_BUFFER              TEXTEQU         <24:24>
;  RW--V 
;  2862 : #define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
NV_PME_VID_ME_STATE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;  2863 : #define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
NV_PME_VID_ME_STATE_CURRENT_BUFFER_1            EQU             000000001h
;  RW-4R 
;  2864 : #define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
NV_PME_VID_SU_STATE             EQU             00020031ch
;  RWXVF 
;  2865 : #define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VID_SU_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2866 : #define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VID_SU_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RW-4R 
;  2867 : #define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
NV_PME_VID_RM_STATE             EQU             000200320h
;  RWXVF 
;  2868 : #define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2869 : #define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2870 : #define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2871 : #define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWI4R 
;  2872 : #define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
NV_PME_VID_CURRENT              EQU             000200324h
;  RWXUF 
;  2873 : #define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
NV_PME_VID_CURRENT_POS          TEXTEQU         <15:2>
;  RWI4R 
;  2874 : #define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
NV_PME_AUD_BUFF0_START_SYS              EQU             000200340h
;  RWXUF 
;  2875 : #define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_AUD_BUFF0_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2876 : #define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
NV_PME_AUD_BUFF1_START_SYS              EQU             000200344h
;  RWXUF 
;  2877 : #define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_AUD_BUFF1_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2878 : #define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
NV_PME_AUD_BUFF0_START_PNVM             EQU             000200348h
;  RWXUF 
;  2879 : #define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_AUD_BUFF0_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2880 : #define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
NV_PME_AUD_BUFF1_START_PNVM             EQU             00020034ch
;  RWXUF 
;  2881 : #define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_AUD_BUFF1_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2882 : #define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
NV_PME_AUD_BUFF0_LENGTH         EQU             000200350h
;  RWXUF 
;  2883 : #define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
NV_PME_AUD_BUFF0_LENGTH_BITS            TEXTEQU         <12:10>
;  RWI4R 
;  2884 : #define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
NV_PME_AUD_BUFF1_LENGTH         EQU             000200354h
;  RWXUF 
;  2885 : #define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
NV_PME_AUD_BUFF1_LENGTH_BITS            TEXTEQU         <12:10>
;  RW-4R 
;  2886 : #define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
NV_PME_AUD_ME_STATE             EQU             000200358h
;  RWIVF 
;  2887 : #define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2888 : #define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2889 : #define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2890 : #define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWXVF 
;  2891 : #define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2892 : #define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RWXVF 
;  2893 : #define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
NV_PME_AUD_ME_STATE_CURRENT_BUFFER              TEXTEQU         <24:24>
;  RW--V 
;  2894 : #define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;  2895 : #define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1            EQU             000000001h
;  RW-4R 
;  2896 : #define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
NV_PME_AUD_SU_STATE             EQU             00020035ch
;  RWXVF 
;  2897 : #define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_AUD_SU_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2898 : #define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_AUD_SU_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RW-4R 
;  2899 : #define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
NV_PME_AUD_RM_STATE             EQU             000200360h
;  RWXVF 
;  2900 : #define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2901 : #define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2902 : #define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2903 : #define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWI4R 
;  2904 : #define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
NV_PME_AUD_CURRENT              EQU             000200364h
;  RWXUF 
;  2905 : #define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
NV_PME_AUD_CURRENT_POS          TEXTEQU         <12:2>
;  RWI4R 
;  2906 : #define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
NV_PME_VBI_BUFF0_START          EQU             000200380h
;  RWXUF 
;  2907 : #define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
NV_PME_VBI_BUFF0_START_ADDRESS          TEXTEQU         <22:4>
;  RWI4R 
;  2908 : #define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
NV_PME_VBI_BUFF1_START          EQU             000200384h
;  RWXUF 
;  2909 : #define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
NV_PME_VBI_BUFF1_START_ADDRESS          TEXTEQU         <22:4>
;  RWI4R 
;  2910 : #define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
NV_PME_VBI_BUFF0_PITCH          EQU             000200388h
;  RWXUF 
;  2911 : #define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
NV_PME_VBI_BUFF0_PITCH_VALUE            TEXTEQU         <13:4>
;  RWI4R 
;  2912 : #define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
NV_PME_VBI_BUFF1_PITCH          EQU             00020038ch
;  RWXUF 
;  2913 : #define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
NV_PME_VBI_BUFF1_PITCH_VALUE            TEXTEQU         <13:4>
;  RWI4R 
;  2914 : #define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
NV_PME_VBI_BUFF0_LENGTH         EQU             000200390h
;  RWXUF 
;  2915 : #define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
NV_PME_VBI_BUFF0_LENGTH_BITS            TEXTEQU         <19:4>
;  RWI4R 
;  2916 : #define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
NV_PME_VBI_BUFF1_LENGTH         EQU             000200394h
;  RWXUF 
;  2917 : #define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
NV_PME_VBI_BUFF1_LENGTH_BITS            TEXTEQU         <19:4>
;  RW-4R 
;  2918 : #define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
NV_PME_VBI_ME_STATE             EQU             000200398h
;  RWXVF 
;  2919 : #define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2920 : #define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2921 : #define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE            TEXTEQU         <10:8>
;  RWXVF 
;  2922 : #define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE            TEXTEQU         <14:12>
;  RWXVF 
;  2923 : #define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2924 : #define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RWXVF 
;  2925 : #define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
NV_PME_VBI_ME_STATE_CURRENT_BUFFER              TEXTEQU         <24:24>
;  RW--V 
;  2926 : #define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;  2927 : #define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1            EQU             000000001h
;  RW-4R 
;  2928 : #define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
NV_PME_VBI_SU_STATE             EQU             00020039ch
;  RWXVF 
;  2929 : #define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF0_FIELD         TEXTEQU         <8:8>
;  RWXVF 
;  2930 : #define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF1_FIELD         TEXTEQU         <12:12>
;  RWXVF 
;  2931 : #define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2932 : #define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RW-4R 
;  2933 : #define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
NV_PME_VBI_RM_STATE             EQU             0002003a0h
;  RWXVF 
;  2934 : #define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2935 : #define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWI4R 
;  2936 : #define NV_PME_VBI                                       0x002003a4 /* RWI4R */
NV_PME_VBI              EQU             0002003a4h
;  RWX-F 
;  2937 : #define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
NV_PME_VBI_START_LINE           TEXTEQU         <4:0>
;  RWX-F 
;  2938 : #define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
NV_PME_VBI_NUM_LINES            TEXTEQU         <20:16>
;  RWI4R 
;  2939 : #define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
NV_PME_IMAGE_BUFF0_START                EQU             000200400h
;  RWXUF 
;  2940 : #define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
NV_PME_IMAGE_BUFF0_START_ADDRESS                TEXTEQU         <22:4>
;  RWI4R 
;  2941 : #define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
NV_PME_IMAGE_BUFF1_START                EQU             000200404h
;  RWXUF 
;  2942 : #define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
NV_PME_IMAGE_BUFF1_START_ADDRESS                TEXTEQU         <22:4>
;  RWI4R 
;  2943 : #define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
NV_PME_IMAGE_BUFF0_PITCH                EQU             000200408h
;  RWXUF 
;  2944 : #define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
NV_PME_IMAGE_BUFF0_PITCH_VALUE          TEXTEQU         <13:4>
;  RWI4R 
;  2945 : #define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
NV_PME_IMAGE_BUFF1_PITCH                EQU             00020040ch
;  RWXUF 
;  2946 : #define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
NV_PME_IMAGE_BUFF1_PITCH_VALUE          TEXTEQU         <13:4>
;  RWI4R 
;  2947 : #define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
NV_PME_IMAGE_BUFF0_LENGTH               EQU             000200410h
;  RWXUF 
;  2948 : #define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
NV_PME_IMAGE_BUFF0_LENGTH_BITS          TEXTEQU         <19:4>
;  RWI4R 
;  2949 : #define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
NV_PME_IMAGE_BUFF1_LENGTH               EQU             000200414h
;  RWXUF 
;  2950 : #define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
NV_PME_IMAGE_BUFF1_LENGTH_BITS          TEXTEQU         <19:4>
;  RW-4R 
;  2951 : #define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
NV_PME_IMAGE_ME_STATE           EQU             000200418h
;  RWXVF 
;  2952 : #define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY         TEXTEQU         <0:0>
;  RWXVF 
;  2953 : #define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY         TEXTEQU         <4:4>
;  RWXVF 
;  2954 : #define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE          TEXTEQU         <10:8>
;  RWXVF 
;  2955 : #define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE          TEXTEQU         <14:12>
;  RWXVF 
;  2956 : #define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE              TEXTEQU         <16:16>
;  RWXVF 
;  2957 : #define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE              TEXTEQU         <20:20>
;  RWXVF 
;  2958 : #define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER            TEXTEQU         <24:24>
;  RW--V 
;  2959 : #define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0          EQU             000000000h
;  RW--V 
;  2960 : #define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1          EQU             000000001h
;  RW-4R 
;  2961 : #define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
NV_PME_IMAGE_SU_STATE           EQU             00020041ch
;  RWXVF 
;  2962 : #define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF0_FIELD               TEXTEQU         <8:8>
;  RWXVF 
;  2963 : #define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF1_FIELD               TEXTEQU         <12:12>
;  RWXVF 
;  2964 : #define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE              TEXTEQU         <16:16>
;  RWXVF 
;  2965 : #define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE              TEXTEQU         <20:20>
;  RW-4R 
;  2966 : #define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
NV_PME_IMAGE_RM_STATE           EQU             000200420h
;  RWXVF 
;  2967 : #define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY         TEXTEQU         <0:0>
;  RWXVF 
;  2968 : #define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY         TEXTEQU         <4:4>
;  RW-4R 
;  2969 : #define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
NV_PME_IMAGE_BUFF0_SCALE_INCR           EQU             000200424h
;  RWXVF 
;  2970 : #define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
NV_PME_IMAGE_BUFF0_SCALE_INCR_Y         TEXTEQU         <26:16>
;  RWXVF 
;  2971 : #define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
NV_PME_IMAGE_BUFF0_SCALE_INCR_X         TEXTEQU         <10:0>
;  RW-4R 
;  2972 : #define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
NV_PME_IMAGE_BUFF1_SCALE_INCR           EQU             000200428h
;  RWXVF 
;  2973 : #define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
NV_PME_IMAGE_BUFF1_SCALE_INCR_Y         TEXTEQU         <26:16>
;  RWXVF 
;  2974 : #define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
NV_PME_IMAGE_BUFF1_SCALE_INCR_X         TEXTEQU         <10:0>
;  R--4R 
;  2975 : #define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
NV_PME_FIFO_LINE_START          EQU             000200480h
;  R-XVF 
;  2976 : #define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
NV_PME_FIFO_LINE_START_ADDRESS          TEXTEQU         <20:4>
;  RWI4R 
;  2977 : #define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
NV_PME_FIFO_CURRENT             EQU             000200484h
;  RWXVF 
;  2978 : #define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
NV_PME_FIFO_CURRENT_ADDRESS             TEXTEQU         <20:2>
;  R--4R 
;  2979 : #define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
NV_PME_VMI_POLL         EQU             000200488h
;  R-IVF 
;  2980 : #define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
NV_PME_VMI_POLL_UNCD            TEXTEQU         <0:0>
;  R-IVF 
;  2981 : #define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
NV_PME_VMI_POLL_UNCD_NOT_PENDING                EQU             000000000h
;  R--VF 
;  2982 : #define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
NV_PME_VMI_POLL_UNCD_PENDING            EQU             000000001h
;  R-IVF 
;  2983 : #define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
NV_PME_VMI_POLL_VIDCD           TEXTEQU         <1:1>
;  R-IVF 
;  2984 : #define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
NV_PME_VMI_POLL_VIDCD_NOT_PENDING               EQU             000000000h
;  R--VF 
;  2985 : #define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
NV_PME_VMI_POLL_VIDCD_PENDING           EQU             000000001h
;  R-IVF 
;  2986 : #define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
NV_PME_VMI_POLL_AUDCD           TEXTEQU         <2:2>
;  R-IVF 
;  2987 : #define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
NV_PME_VMI_POLL_AUDCD_NOT_PENDING               EQU             000000000h
;  R--VF 
;  2988 : #define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
NV_PME_VMI_POLL_AUDCD_PENDING           EQU             000000001h
;  R-IVF 
;  2989 : #define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
NV_PME_VMI_POLL_INT             TEXTEQU         <3:3>
;  R-IVF 
;  2990 : #define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
NV_PME_VMI_POLL_INT_NOT_PENDING         EQU             000000000h
;  R--VF 
;  2991 : #define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
NV_PME_VMI_POLL_INT_PENDING             EQU             000000001h
;  R-IVF 
;  2992 : #define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
NV_PME_VMI_POLL_CPURDREC                TEXTEQU         <4:4>
;  R-IVF 
;  2993 : #define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
NV_PME_VMI_POLL_CPURDREC_NOT_PENDING            EQU             000000000h
;  R--VF 
;  2994 : #define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
NV_PME_VMI_POLL_CPURDREC_PENDING                EQU             000000001h
;  RWI4R 
;  2995 : #define NV_PME_DMA_STATUS_0                              0x00200500 /* RWI4R */
NV_PME_DMA_STATUS_0             EQU             000200500h
;  R-I-F 
;  2996 : #define NV_PME_DMA_STATUS_0_STATE                               0:0 /* R-I-F */
NV_PME_DMA_STATUS_0_STATE               TEXTEQU         <0:0>
;  R-I-V 
;  2997 : #define NV_PME_DMA_STATUS_0_STATE_IDLE                   0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_STATE_IDLE          EQU             000000000h
;  R-I-V 
;  2998 : #define NV_PME_DMA_STATUS_0_STATE_BUSY                   0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_STATE_BUSY          EQU             000000001h
;  R-I-F 
;  2999 : #define NV_PME_DMA_STATUS_0_DRAIN                               8:8 /* R-I-F */
NV_PME_DMA_STATUS_0_DRAIN               TEXTEQU         <8:8>
;  R-I-V 
;  3000 : #define NV_PME_DMA_STATUS_0_DRAIN_IDLE                   0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_DRAIN_IDLE          EQU             000000000h
;  R-I-V 
;  3001 : #define NV_PME_DMA_STATUS_0_DRAIN_BUSY                   0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_DRAIN_BUSY          EQU             000000001h
;  R-I-F 
;  3002 : #define NV_PME_DMA_STATUS_0_FLUSH                             12:12 /* R-I-F */
NV_PME_DMA_STATUS_0_FLUSH               TEXTEQU         <12:12>
;  R-I-V 
;  3003 : #define NV_PME_DMA_STATUS_0_FLUSH_IDLE                   0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_FLUSH_IDLE          EQU             000000000h
;  R-I-V 
;  3004 : #define NV_PME_DMA_STATUS_0_FLUSH_BUSY                   0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_FLUSH_BUSY          EQU             000000001h
;  R-I-F 
;  3005 : #define NV_PME_DMA_STATUS_0_READ                              16:16 /* R-I-F */
NV_PME_DMA_STATUS_0_READ                TEXTEQU         <16:16>
;  R-I-V 
;  3006 : #define NV_PME_DMA_STATUS_0_READ_IDLE                    0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_READ_IDLE           EQU             000000000h
;  R-I-V 
;  3007 : #define NV_PME_DMA_STATUS_0_READ_BUSY                    0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_READ_BUSY           EQU             000000001h
;  RW-4A 
;        
;  3008 : #define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
;  3009 : #define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
NV_PME_EXTERNAL_SIZE_1          EQU             256t
;  RWXVF 
;  3010 : #define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
NV_PME_EXTERNAL_DATA            TEXTEQU         <7:0>
;  usr_beta_solid.ref 
;  -W--D 
;  3011 : /* usr_beta_solid.ref */
;  3012 : #define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
NV_UBETA                TEXTEQU         <0x00411FFF:0x00410000>
;  -W-4R 
;  3013 : #define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
NV_UBETA_CTX_SWITCH             EQU             000410000h
;  -W-UF 
;  3014 : #define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UBETA_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3015 : #define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UBETA_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3016 : #define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UBETA_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3017 : #define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3018 : #define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UBETA_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3019 : #define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
NV_UBETA_SET_NOTIFY             EQU             000410104h
;  -W-VF 
;  3020 : #define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UBETA_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3021 : #define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UBETA_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3022 : #define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
NV_UBETA_SET_BETA1D31           EQU             000410300h
;  -W-UF 
;  3023 : #define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
NV_UBETA_SET_BETA1D31_VALUE_FRACTION            TEXTEQU         <30:21>
;  -W-SF 
;  3024 : #define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
NV_UBETA_SET_BETA1D31_VALUE             TEXTEQU         <31:31>
;  usr_rop_solid.ref 
;  -W--D 
;  3025 : /* usr_rop_solid.ref */
;  3026 : #define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
NV_UROP         TEXTEQU         <0x00421FFF:0x00420000>
;  -W-4R 
;  3027 : #define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
NV_UROP_CTX_SWITCH              EQU             000420000h
;  -W-UF 
;  3028 : #define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
NV_UROP_CTX_SWITCH_INSTANCE             TEXTEQU         <15:0>
;  -W-UF 
;  3029 : #define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
NV_UROP_CTX_SWITCH_CHID         TEXTEQU         <22:16>
;  -W-VF 
;  3030 : #define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
NV_UROP_CTX_SWITCH_VOLATILE             TEXTEQU         <31:31>
;  -W--V 
;  3031 : #define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
NV_UROP_CTX_SWITCH_VOLATILE_IGNORE              EQU             000000000h
;  -W--V 
;  3032 : #define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
NV_UROP_CTX_SWITCH_VOLATILE_RESET               EQU             000000001h
;  -W-4R 
;  3033 : #define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
NV_UROP_SET_NOTIFY              EQU             000420104h
;  -W-VF 
;  3034 : #define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
NV_UROP_SET_NOTIFY_PARAMETER            TEXTEQU         <31:0>
;  -W--V 
;  3035 : #define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
NV_UROP_SET_NOTIFY_PARAMETER_WRITE              EQU             000000000h
;  -W-4R 
;  3036 : #define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
NV_UROP_SET_ROP         EQU             000420300h
;  -W-VF 
;  3037 : #define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
NV_UROP_SET_ROP_VALUE           TEXTEQU         <7:0>
;  usr_color_key.ref 
;  -W--D 
;  3038 : /* usr_color_key.ref */
;  3039 : #define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
NV_UCHROMA              TEXTEQU         <0x00431FFF:0x00430000>
;  -W-4R 
;  3040 : #define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
NV_UCHROMA_CTX_SWITCH           EQU             000430000h
;  -W-UF 
;  3041 : #define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UCHROMA_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3042 : #define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UCHROMA_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3043 : #define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UCHROMA_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3044 : #define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3045 : #define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3046 : #define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
NV_UCHROMA_SET_NOTIFY           EQU             000430104h
;  -W-VF 
;  3047 : #define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UCHROMA_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3048 : #define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3049 : #define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
NV_UCHROMA_SET_COLOR            EQU             000430304h
;  -W-VF 
;  3050 : #define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
NV_UCHROMA_SET_COLOR_VALUE              TEXTEQU         <31:0>
;  usr_plane_switch.ref 
;  -W--D 
;  3051 : /* usr_plane_switch.ref */
;  3052 : #define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
NV_UPLANE               TEXTEQU         <0x00441FFF:0x00440000>
;  -W-4R 
;  3053 : #define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
NV_UPLANE_CTX_SWITCH            EQU             000440000h
;  -W-UF 
;  3054 : #define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UPLANE_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3055 : #define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UPLANE_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3056 : #define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UPLANE_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3057 : #define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3058 : #define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UPLANE_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3059 : #define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
NV_UPLANE_SET_NOTIFY            EQU             000440104h
;  -W-VF 
;  3060 : #define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UPLANE_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3061 : #define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3062 : #define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
NV_UPLANE_SET_COLOR             EQU             000440304h
;  -W-VF 
;  3063 : #define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
NV_UPLANE_SET_COLOR_VALUE               TEXTEQU         <31:0>
;  usr_clipping.ref 
;  -W--D 
;  3064 : /* usr_clipping.ref */
;  3065 : #define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
NV_UCLIP                TEXTEQU         <0x00451FFF:0x00450000>
;  -W-4R 
;  3066 : #define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
NV_UCLIP_CTX_SWITCH             EQU             000450000h
;  -W-UF 
;  3067 : #define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UCLIP_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3068 : #define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UCLIP_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3069 : #define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UCLIP_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3070 : #define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3071 : #define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UCLIP_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3072 : #define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
NV_UCLIP_SET_NOTIFY             EQU             000450104h
;  -W-VF 
;  3073 : #define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UCLIP_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3074 : #define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3075 : #define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
NV_UCLIP_SET_RECT_0             EQU             000450300h
;  -W-SF 
;  3076 : #define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
NV_UCLIP_SET_RECT_0_X           TEXTEQU         <15:0>
;  -W-SF 
;  3077 : #define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
NV_UCLIP_SET_RECT_0_Y           TEXTEQU         <31:16>
;  -W-4R 
;  3078 : #define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
NV_UCLIP_SET_RECT_1             EQU             000450304h
;  -W-UF 
;  3079 : #define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
NV_UCLIP_SET_RECT_1_WIDTH               TEXTEQU         <15:0>
;  -W-UF 
;  3080 : #define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
NV_UCLIP_SET_RECT_1_HEIGHT              TEXTEQU         <31:16>
;  usr_d3d0_triangle_zeta.ref 
;  -W--D 
;  3081 : /* usr_d3d0_triangle_zeta.ref */
;  3082 : #define NV_UD3D0Z                             0x00571FFF:0x00570000 /* -W--D */
NV_UD3D0Z               TEXTEQU         <0x00571FFF:0x00570000>
;  -W-4R 
;  3083 : #define NV_UD3D0Z_CTX_SWITCH                             0x00570000 /* -W-4R */
NV_UD3D0Z_CTX_SWITCH            EQU             000570000h
;  -W-UF 
;  3084 : #define NV_UD3D0Z_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UD3D0Z_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3085 : #define NV_UD3D0Z_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UD3D0Z_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3086 : #define NV_UD3D0Z_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UD3D0Z_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3087 : #define NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3088 : #define NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3089 : #define NV_UD3D0Z_SET_NOTIFY                             0x00570104 /* -W-4R */
NV_UD3D0Z_SET_NOTIFY            EQU             000570104h
;  -W-VF 
;  3090 : #define NV_UD3D0Z_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UD3D0Z_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3091 : #define NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3092 : #define NV_UD3D0Z_TEXTURE_OFFSET                         0x00570304 /* -W-4R */
NV_UD3D0Z_TEXTURE_OFFSET                EQU             000570304h
;  -W-UF 
;  3093 : #define NV_UD3D0Z_TEXTURE_OFFSET_VALUE                         31:0 /* -W-UF */
NV_UD3D0Z_TEXTURE_OFFSET_VALUE          TEXTEQU         <31:0>
;  -W-4R 
;  3094 : #define NV_UD3D0Z_TEXTURE_FORMAT                         0x00570308 /* -W-4R */
NV_UD3D0Z_TEXTURE_FORMAT                EQU             000570308h
;  -W-UF 
;  3095 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK          15:0 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK           TEXTEQU         <15:0>
;  -W-UF 
;  3096 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY                    16:16 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY              TEXTEQU         <16:16>
;  -W-UV 
;  3097 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED      0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED             EQU             000000000h
;  -W-UV 
;  3098 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED       0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED              EQU             000000001h
;  -W-UF 
;  3099 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT                 21:20 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT           TEXTEQU         <21:20>
;  -W-UV 
;  3100 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5   0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5          EQU             000000000h
;  -W-UV 
;  3101 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5   0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5          EQU             000000001h
;  -W-UV 
;  3102 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4   0x00000002 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4          EQU             000000002h
;  -W-UV 
;  3103 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5     0x00000003 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5            EQU             000000003h
;  -W-UF 
;  3104 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN                     27:24 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN               TEXTEQU         <27:24>
;  -W-UV 
;  3105 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1            0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1           EQU             000000000h
;  -W-UV 
;  3106 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2            0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2           EQU             000000001h
;  -W-UV 
;  3107 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4            0x00000002 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4           EQU             000000002h
;  -W-UV 
;  3108 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8            0x00000003 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8           EQU             000000003h
;  -W-UV 
;  3109 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16          0x00000004 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16         EQU             000000004h
;  -W-UV 
;  3110 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32          0x00000005 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32         EQU             000000005h
;  -W-UV 
;  3111 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64          0x00000006 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64         EQU             000000006h
;  -W-UV 
;  3112 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128        0x00000007 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128               EQU             000000007h
;  -W-UV 
;  3113 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256        0x00000008 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256               EQU             000000008h
;  -W-UV 
;  3114 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512        0x00000009 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512               EQU             000000009h
;  -W-UV 
;  3115 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024      0x0000000a /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024             EQU             00000000ah
;  -W-UV 
;  3116 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048      0x0000000b /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048             EQU             00000000bh
;  -W-UF 
;  3117 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX                     31:28 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX               TEXTEQU         <31:28>
;  -W-UV 
;  3118 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1            0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1           EQU             000000000h
;  -W-UV 
;  3119 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2            0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2           EQU             000000001h
;  -W-UV 
;  3120 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4            0x00000002 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4           EQU             000000002h
;  -W-UV 
;  3121 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8            0x00000003 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8           EQU             000000003h
;  -W-UV 
;  3122 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16          0x00000004 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16         EQU             000000004h
;  -W-UV 
;  3123 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32          0x00000005 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32         EQU             000000005h
;  -W-UV 
;  3124 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64          0x00000006 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64         EQU             000000006h
;  -W-UV 
;  3125 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128        0x00000007 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128               EQU             000000007h
;  -W-UV 
;  3126 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256        0x00000008 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256               EQU             000000008h
;  -W-UV 
;  3127 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512        0x00000009 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512               EQU             000000009h
;  -W-UV 
;  3128 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024      0x0000000a /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024             EQU             00000000ah
;  -W-UV 
;  3129 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048      0x0000000b /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048             EQU             00000000bh
;  -W-4R 
;  3130 : #define NV_UD3D0Z_FILTER                                 0x0057030C /* -W-4R */
NV_UD3D0Z_FILTER                EQU             00057030ch
;  -W-UF 
;  3131 : #define NV_UD3D0Z_FILTER_SPREADX                                7:0 /* -W-UF */
NV_UD3D0Z_FILTER_SPREADX                TEXTEQU         <7:0>
;  -W-UF 
;  3132 : #define NV_UD3D0Z_FILTER_SPREADY                               15:8 /* -W-UF */
NV_UD3D0Z_FILTER_SPREADY                TEXTEQU         <15:8>
;  -W-SF 
;  3133 : #define NV_UD3D0Z_FILTER_MIPMAP                               23:16 /* -W-SF */
NV_UD3D0Z_FILTER_MIPMAP         TEXTEQU         <23:16>
;  -W-SF 
;  3134 : #define NV_UD3D0Z_FILTER_TURBO                                31:24 /* -W-SF */
NV_UD3D0Z_FILTER_TURBO          TEXTEQU         <31:24>
;  -W-4R 
;  3135 : #define NV_UD3D0Z_FOG_COLOR                              0x00570310 /* -W-4R */
NV_UD3D0Z_FOG_COLOR             EQU             000570310h
;  -W-UF 
;  3136 : #define NV_UD3D0Z_FOG_COLOR_BLU                                 7:0 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_BLU         TEXTEQU         <7:0>
;  -W-UF 
;  3137 : #define NV_UD3D0Z_FOG_COLOR_GRN                                15:8 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_GRN         TEXTEQU         <15:8>
;  -W-UF 
;  3138 : #define NV_UD3D0Z_FOG_COLOR_RED                               23:16 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_RED         TEXTEQU         <23:16>
;  -W-UF 
;  3139 : #define NV_UD3D0Z_FOG_COLOR_VALUE                              31:0 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3140 : #define NV_UD3D0Z_CONTROL_OUT                            0x00570314 /* -W-4R */
NV_UD3D0Z_CONTROL_OUT           EQU             000570314h
;  -W-UF 
;  3141 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR              TEXTEQU         <1:0>
;  -W-UV 
;  3142 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH          EQU             000000000h
;  -W-UV 
;  3143 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS               EQU             000000001h
;  -W-UV 
;  3144 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH          EQU             000000002h
;  -W-UF 
;  3145 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_WRAP_U            TEXTEQU         <5:4>
;  -W-UV 
;  3146 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL                EQU             000000000h
;  -W-UV 
;  3147 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP               EQU             000000001h
;  -W-UV 
;  3148 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR             EQU             000000002h
;  -W-UV 
;  3149 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP              EQU             000000003h
;  -W-UF 
;  3150 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_WRAP_V            TEXTEQU         <7:6>
;  -W-UV 
;  3151 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL                EQU             000000000h
;  -W-UV 
;  3152 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP               EQU             000000001h
;  -W-UV 
;  3153 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR             EQU             000000002h
;  -W-UV 
;  3154 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP              EQU             000000003h
;  -W-UF 
;  3155 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT              TEXTEQU         <8:8>
;  -W-UV 
;  3156 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8          EQU             000000000h
;  -W-UV 
;  3157 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8          EQU             000000001h
;  -W-UF 
;  3158 : #define NV_UD3D0Z_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_CULLING           TEXTEQU         <13:12>
;  -W-UV 
;  3159 : #define NV_UD3D0Z_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_CULLING_NONE              EQU             000000001h
;  -W-UV 
;  3160 : #define NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE         EQU             000000002h
;  -W-UV 
;  3161 : #define NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE          EQU             000000003h
;  -W-UF 
;  3162 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE              TEXTEQU         <19:16>
;  -W-UV 
;  3163 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE                EQU             000000001h
;  -W-UV 
;  3164 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT           EQU             000000002h
;  -W-UV 
;  3165 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ           EQU             000000003h
;  -W-UV 
;  3166 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE           EQU             000000004h
;  -W-UV 
;  3167 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT           EQU             000000005h
;  -W-UV 
;  3168 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE           EQU             000000006h
;  -W-UV 
;  3169 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE           EQU             000000007h
;  -W-UV 
;  3170 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE         EQU             000000008h
;  -W-UF 
;  3171 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                TEXTEQU         <22:20>
;  -W-UV 
;  3172 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER          EQU             000000000h
;  -W-UV 
;  3173 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA          EQU             000000001h
;  -W-UV 
;  3174 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA             EQU             000000002h
;  -W-UV 
;  3175 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA           EQU             000000003h
;  -W-UV 
;  3176 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS         EQU             000000004h
;  -W-UF 
;  3177 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE                     25:24 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE               TEXTEQU         <25:24>
;  -W-UV 
;  3178 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER         EQU             000000000h
;  -W-UV 
;  3179 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA         EQU             000000001h
;  -W-UV 
;  3180 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA            EQU             000000002h
;  -W-UF 
;  3181 : #define NV_UD3D0Z_CONTROL_OUT_ROP                             28:28 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_ROP               TEXTEQU         <28:28>
;  -W-UV 
;  3182 : #define NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND             EQU             000000000h
;  -W-UV 
;  3183 : #define NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION           EQU             000000001h
;  -W-4A 
;        
;  3184 : #define NV_UD3D0Z_SPECULAR(i)                   (0x00571000+(i)*32) /* -W-4A */
;  3185 : #define NV_UD3D0Z_SPECULAR__SIZE_1                              128 /*       */
NV_UD3D0Z_SPECULAR__SIZE_1              EQU             128t
;  -W-UF 
;  3186 : #define NV_UD3D0Z_SPECULAR_I0                                   3:0 /* -W-UF */
NV_UD3D0Z_SPECULAR_I0           TEXTEQU         <3:0>
;  -W-UF 
;  3187 : #define NV_UD3D0Z_SPECULAR_I1                                   7:4 /* -W-UF */
NV_UD3D0Z_SPECULAR_I1           TEXTEQU         <7:4>
;  -W-UF 
;  3188 : #define NV_UD3D0Z_SPECULAR_I2                                  11:8 /* -W-UF */
NV_UD3D0Z_SPECULAR_I2           TEXTEQU         <11:8>
;  -W-UF 
;  3189 : #define NV_UD3D0Z_SPECULAR_I3                                 15:12 /* -W-UF */
NV_UD3D0Z_SPECULAR_I3           TEXTEQU         <15:12>
;  -W-UF 
;  3190 : #define NV_UD3D0Z_SPECULAR_I4                                 19:16 /* -W-UF */
NV_UD3D0Z_SPECULAR_I4           TEXTEQU         <19:16>
;  -W-UF 
;  3191 : #define NV_UD3D0Z_SPECULAR_I5                                 23:20 /* -W-UF */
NV_UD3D0Z_SPECULAR_I5           TEXTEQU         <23:20>
;  -W-UF 
;  3192 : #define NV_UD3D0Z_SPECULAR_FOG                                31:24 /* -W-UF */
NV_UD3D0Z_SPECULAR_FOG          TEXTEQU         <31:24>
;  -W-4A 
;        
;  3193 : #define NV_UD3D0Z_COLOR(i)                      (0x00571004+(i)*32) /* -W-4A */
;  3194 : #define NV_UD3D0Z_COLOR__SIZE_1                                 128 /*       */
NV_UD3D0Z_COLOR__SIZE_1         EQU             128t
;  -W-UF 
;  3195 : #define NV_UD3D0Z_COLOR_B8                                      7:0 /* -W-UF */
NV_UD3D0Z_COLOR_B8              TEXTEQU         <7:0>
;  -W-UF 
;  3196 : #define NV_UD3D0Z_COLOR_G8                                     16:8 /* -W-UF */
NV_UD3D0Z_COLOR_G8              TEXTEQU         <16:8>
;  -W-UF 
;  3197 : #define NV_UD3D0Z_COLOR_R8                                    23:16 /* -W-UF */
NV_UD3D0Z_COLOR_R8              TEXTEQU         <23:16>
;  -W-UF 
;  3198 : #define NV_UD3D0Z_COLOR_A8                                    32:24 /* -W-UF */
NV_UD3D0Z_COLOR_A8              TEXTEQU         <32:24>
;  -W-4A 
;        
;  3199 : #define NV_UD3D0Z_X(i)                          (0x00571008+(i)*32) /* -W-4A */
;  3200 : #define NV_UD3D0Z_X__SIZE_1                                     128 /*       */
NV_UD3D0Z_X__SIZE_1             EQU             128t
;  -W-FF 
;  3201 : #define NV_UD3D0Z_X_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_X_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3202 : #define NV_UD3D0Z_Y(i)                          (0x0057100C+(i)*32) /* -W-4A */
;  3203 : #define NV_UD3D0Z_Y__SIZE_1                                     128 /*       */
NV_UD3D0Z_Y__SIZE_1             EQU             128t
;  -W-FF 
;  3204 : #define NV_UD3D0Z_Y_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_Y_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3205 : #define NV_UD3D0Z_Z(i)                          (0x00571010+(i)*32) /* -W-4A */
;  3206 : #define NV_UD3D0Z_Z__SIZE_1                                     128 /*       */
NV_UD3D0Z_Z__SIZE_1             EQU             128t
;  -W-FF 
;  3207 : #define NV_UD3D0Z_Z_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_Z_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3208 : #define NV_UD3D0Z_M(i)                          (0x00571014+(i)*32) /* -W-4A */
;  3209 : #define NV_UD3D0Z_M__SIZE_1                                     128 /*       */
NV_UD3D0Z_M__SIZE_1             EQU             128t
;  -W-FF 
;  3210 : #define NV_UD3D0Z_M_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_M_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3211 : #define NV_UD3D0Z_U(i)                          (0x00571018+(i)*32) /* -W-4A */
;  3212 : #define NV_UD3D0Z_U__SIZE_1                                     128 /*       */
NV_UD3D0Z_U__SIZE_1             EQU             128t
;  -W-FF 
;  3213 : #define NV_UD3D0Z_U_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_U_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3214 : #define NV_UD3D0Z_V(i)                          (0x0057101c+(i)*32) /* -W-4A */
;  3215 : #define NV_UD3D0Z_V__SIZE_1                                     128 /*       */
NV_UD3D0Z_V__SIZE_1             EQU             128t
;  -W-FF 
;  3216 : #define NV_UD3D0Z_V_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_V_VALUE               TEXTEQU         <31:0>
;  usr_d3d0_triangle.ref 
;  -W--D 
;  3217 : /* usr_d3d0_triangle.ref */
;  3218 : #define NV_UD3D0                              0x00561FFF:0x00560000 /* -W--D */
NV_UD3D0                TEXTEQU         <0x00561FFF:0x00560000>
;  -W-4R 
;  3219 : #define NV_UD3D0_CTX_SWITCH                              0x00560000 /* -W-4R */
NV_UD3D0_CTX_SWITCH             EQU             000560000h
;  -W-UF 
;  3220 : #define NV_UD3D0_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UD3D0_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3221 : #define NV_UD3D0_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UD3D0_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3222 : #define NV_UD3D0_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UD3D0_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3223 : #define NV_UD3D0_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UD3D0_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3224 : #define NV_UD3D0_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UD3D0_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3225 : #define NV_UD3D0_SET_NOTIFY                              0x00560104 /* -W-4R */
NV_UD3D0_SET_NOTIFY             EQU             000560104h
;  -W-VF 
;  3226 : #define NV_UD3D0_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UD3D0_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3227 : #define NV_UD3D0_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UD3D0_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3228 : #define NV_UD3D0_TEXTURE_OFFSET                          0x00560304 /* -W-4R */
NV_UD3D0_TEXTURE_OFFSET         EQU             000560304h
;  -W-UF 
;  3229 : #define NV_UD3D0_TEXTURE_OFFSET_VALUE                          31:0 /* -W-UF */
NV_UD3D0_TEXTURE_OFFSET_VALUE           TEXTEQU         <31:0>
;  -W-4R 
;  3230 : #define NV_UD3D0_TEXTURE_FORMAT                          0x00560308 /* -W-4R */
NV_UD3D0_TEXTURE_FORMAT         EQU             000560308h
;  -W-UF 
;  3231 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK           15:0 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK            TEXTEQU         <15:0>
;  -W-UF 
;  3232 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY                     16:16 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY               TEXTEQU         <16:16>
;  -W-UV 
;  3233 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED       0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED              EQU             000000000h
;  -W-UV 
;  3234 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_ENABLED        0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_ENABLED               EQU             000000001h
;  -W-UF 
;  3235 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT                  21:20 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT            TEXTEQU         <21:20>
;  -W-UV 
;  3236 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5    0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5           EQU             000000000h
;  -W-UV 
;  3237 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5    0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5           EQU             000000001h
;  -W-UV 
;  3238 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4    0x00000002 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4           EQU             000000002h
;  -W-UV 
;  3239 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5      0x00000003 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5             EQU             000000003h
;  -W-UF 
;  3240 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN                      27:24 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN                TEXTEQU         <27:24>
;  -W-UV 
;  3241 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1X1             0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1X1            EQU             000000000h
;  -W-UV 
;  3242 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2X2             0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2X2            EQU             000000001h
;  -W-UV 
;  3243 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_4X4             0x00000002 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_4X4            EQU             000000002h
;  -W-UV 
;  3244 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_8X8             0x00000003 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_8X8            EQU             000000003h
;  -W-UV 
;  3245 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_16X16           0x00000004 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_16X16          EQU             000000004h
;  -W-UV 
;  3246 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_32X32           0x00000005 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_32X32          EQU             000000005h
;  -W-UV 
;  3247 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_64X64           0x00000006 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_64X64          EQU             000000006h
;  -W-UV 
;  3248 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_128X128         0x00000007 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_128X128                EQU             000000007h
;  -W-UV 
;  3249 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_256X256         0x00000008 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_256X256                EQU             000000008h
;  -W-UV 
;  3250 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_512X512         0x00000009 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_512X512                EQU             000000009h
;  -W-UV 
;  3251 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1024X1024       0x0000000a /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1024X1024              EQU             00000000ah
;  -W-UV 
;  3252 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2048X2048       0x0000000b /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2048X2048              EQU             00000000bh
;  -W-UF 
;  3253 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX                      31:28 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX                TEXTEQU         <31:28>
;  -W-UV 
;  3254 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1X1             0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1X1            EQU             000000000h
;  -W-UV 
;  3255 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2X2             0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2X2            EQU             000000001h
;  -W-UV 
;  3256 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_4X4             0x00000002 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_4X4            EQU             000000002h
;  -W-UV 
;  3257 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_8X8             0x00000003 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_8X8            EQU             000000003h
;  -W-UV 
;  3258 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_16X16           0x00000004 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_16X16          EQU             000000004h
;  -W-UV 
;  3259 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_32X32           0x00000005 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_32X32          EQU             000000005h
;  -W-UV 
;  3260 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_64X64           0x00000006 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_64X64          EQU             000000006h
;  -W-UV 
;  3261 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_128X128         0x00000007 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_128X128                EQU             000000007h
;  -W-UV 
;  3262 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_256X256         0x00000008 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_256X256                EQU             000000008h
;  -W-UV 
;  3263 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_512X512         0x00000009 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_512X512                EQU             000000009h
;  -W-UV 
;  3264 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1024X1024       0x0000000a /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1024X1024              EQU             00000000ah
;  -W-UV 
;  3265 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2048X2048       0x0000000b /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2048X2048              EQU             00000000bh
;  -W-4R 
;  3266 : #define NV_UD3D0_FILTER                                  0x0056030C /* -W-4R */
NV_UD3D0_FILTER         EQU             00056030ch
;  -W-UF 
;  3267 : #define NV_UD3D0_FILTER_SPREADX                                 7:0 /* -W-UF */
NV_UD3D0_FILTER_SPREADX         TEXTEQU         <7:0>
;  -W-UF 
;  3268 : #define NV_UD3D0_FILTER_SPREADY                                15:8 /* -W-UF */
NV_UD3D0_FILTER_SPREADY         TEXTEQU         <15:8>
;  -W-SF 
;  3269 : #define NV_UD3D0_FILTER_MIPMAP                                23:16 /* -W-SF */
NV_UD3D0_FILTER_MIPMAP          TEXTEQU         <23:16>
;  -W-SF 
;  3270 : #define NV_UD3D0_FILTER_TURBO                                 31:24 /* -W-SF */
NV_UD3D0_FILTER_TURBO           TEXTEQU         <31:24>
;  -W-4R 
;  3271 : #define NV_UD3D0_FOG_COLOR                               0x00560310 /* -W-4R */
NV_UD3D0_FOG_COLOR              EQU             000560310h
;  -W-UF 
;  3272 : #define NV_UD3D0_FOG_COLOR_VALUE                               31:0 /* -W-UF */
NV_UD3D0_FOG_COLOR_VALUE                TEXTEQU         <31:0>
;  -W-4R 
;  3273 : #define NV_UD3D0_CONTROL_OUT                             0x00560314 /* -W-4R */
NV_UD3D0_CONTROL_OUT            EQU             000560314h
;  -W-UF 
;  3274 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR                       1:0 /* -W-UF */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR               TEXTEQU         <1:0>
;  -W-UV 
;  3275 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH            0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH           EQU             000000000h
;  -W-UV 
;  3276 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH_MS         0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH_MS                EQU             000000001h
;  -W-UV 
;  3277 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR_FOH            0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR_FOH           EQU             000000002h
;  -W-UF 
;  3278 : #define NV_UD3D0_CONTROL_OUT_WRAP_U                             5:4 /* -W-UF */
NV_UD3D0_CONTROL_OUT_WRAP_U             TEXTEQU         <5:4>
;  -W-UV 
;  3279 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_CYLINDRICAL          0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_CYLINDRICAL         EQU             000000000h
;  -W-UV 
;  3280 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_WRAP                 0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_WRAP                EQU             000000001h
;  -W-UV 
;  3281 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_MIRROR               0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_MIRROR              EQU             000000002h
;  -W-UV 
;  3282 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_CLAMP                0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_CLAMP               EQU             000000003h
;  -W-UF 
;  3283 : #define NV_UD3D0_CONTROL_OUT_WRAP_V                             7:6 /* -W-UF */
NV_UD3D0_CONTROL_OUT_WRAP_V             TEXTEQU         <7:6>
;  -W-UV 
;  3284 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_CYLINDRICAL          0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_CYLINDRICAL         EQU             000000000h
;  -W-UV 
;  3285 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_WRAP                 0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_WRAP                EQU             000000001h
;  -W-UV 
;  3286 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_MIRROR               0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_MIRROR              EQU             000000002h
;  -W-UV 
;  3287 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_CLAMP                0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_CLAMP               EQU             000000003h
;  -W-UF 
;  3288 : #define NV_UD3D0_CONTROL_OUT_COLOR_FORMAT                       8:8 /* -W-UF */
NV_UD3D0_CONTROL_OUT_COLOR_FORMAT               TEXTEQU         <8:8>
;  -W-UV 
;  3289 : #define NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8    0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8           EQU             000000000h
;  -W-UV 
;  3290 : #define NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8    0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8           EQU             000000001h
;  -W-UF 
;  3291 : #define NV_UD3D0_CONTROL_OUT_CULLING                          13:12 /* -W-UF */
NV_UD3D0_CONTROL_OUT_CULLING            TEXTEQU         <13:12>
;  -W-UV 
;  3292 : #define NV_UD3D0_CONTROL_OUT_CULLING_NONE                0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_CULLING_NONE               EQU             000000001h
;  -W-UV 
;  3293 : #define NV_UD3D0_CONTROL_OUT_CULLING_CLOCKWISE           0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_CULLING_CLOCKWISE          EQU             000000002h
;  -W-UV 
;  3294 : #define NV_UD3D0_CONTROL_OUT_CULLING_COUNTERCLOCKWISE    0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_CULLING_COUNTERCLOCKWISE           EQU             000000003h
;  -W-UF 
;  3295 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE                     19:16 /* -W-UF */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE               TEXTEQU         <19:16>
;  -W-UV 
;  3296 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_FALSE          0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_FALSE         EQU             000000001h
;  -W-UV 
;  3297 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LT             0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LT            EQU             000000002h
;  -W-UV 
;  3298 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_EQ             0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_EQ            EQU             000000003h
;  -W-UV 
;  3299 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LE             0x00000004 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LE            EQU             000000004h
;  -W-UV 
;  3300 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GT             0x00000005 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GT            EQU             000000005h
;  -W-UV 
;  3301 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_NE             0x00000006 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_NE            EQU             000000006h
;  -W-UV 
;  3302 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GE             0x00000007 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GE            EQU             000000007h
;  -W-UV 
;  3303 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_TRUE           0x00000008 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_TRUE          EQU             000000008h
;  -W-UF 
;  3304 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE                       22:20 /* -W-UF */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE         TEXTEQU         <22:20>
;  -W-UV 
;  3305 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_NEVER            0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_NEVER           EQU             000000000h
;  -W-UV 
;  3306 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA            0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA           EQU             000000001h
;  -W-UV 
;  3307 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA       0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA              EQU             000000002h
;  -W-UV 
;  3308 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ZETA             0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ZETA            EQU             000000003h
;  -W-UV 
;  3309 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALWAYS           0x00000004 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALWAYS          EQU             000000004h
;  -W-UF 
;  3310 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE                      25:24 /* -W-UF */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE                TEXTEQU         <25:24>
;  -W-UV 
;  3311 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE_NEVER           0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE_NEVER          EQU             000000000h
;  -W-UV 
;  3312 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA           0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA          EQU             000000001h
;  -W-UV 
;  3313 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA             EQU             000000002h
;  -W-UF 
;  3314 : #define NV_UD3D0_CONTROL_OUT_ROP                              28:28 /* -W-UF */
NV_UD3D0_CONTROL_OUT_ROP                TEXTEQU         <28:28>
;  -W-UV 
;  3315 : #define NV_UD3D0_CONTROL_OUT_ROP_BLEND_AND               0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ROP_BLEND_AND              EQU             000000000h
;  -W-UV 
;  3316 : #define NV_UD3D0_CONTROL_OUT_ROP_ADD_WITH_SATURATION     0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ROP_ADD_WITH_SATURATION            EQU             000000001h
;  -W-4A 
;        
;  3317 : #define NV_UD3D0_SPECULAR(i)                    (0x00561000+(i)*32) /* -W-4A */
;  3318 : #define NV_UD3D0_SPECULAR__SIZE_1                               128 /*       */
NV_UD3D0_SPECULAR__SIZE_1               EQU             128t
;  -W-UF 
;  3319 : #define NV_UD3D0_SPECULAR_I0                                    3:0 /* -W-UF */
NV_UD3D0_SPECULAR_I0            TEXTEQU         <3:0>
;  -W-UF 
;  3320 : #define NV_UD3D0_SPECULAR_I1                                    7:4 /* -W-UF */
NV_UD3D0_SPECULAR_I1            TEXTEQU         <7:4>
;  -W-UF 
;  3321 : #define NV_UD3D0_SPECULAR_I2                                   11:8 /* -W-UF */
NV_UD3D0_SPECULAR_I2            TEXTEQU         <11:8>
;  -W-UF 
;  3322 : #define NV_UD3D0_SPECULAR_I3                                  15:12 /* -W-UF */
NV_UD3D0_SPECULAR_I3            TEXTEQU         <15:12>
;  -W-UF 
;  3323 : #define NV_UD3D0_SPECULAR_I4                                  19:16 /* -W-UF */
NV_UD3D0_SPECULAR_I4            TEXTEQU         <19:16>
;  -W-UF 
;  3324 : #define NV_UD3D0_SPECULAR_I5                                  23:20 /* -W-UF */
NV_UD3D0_SPECULAR_I5            TEXTEQU         <23:20>
;  -W-UF 
;  3325 : #define NV_UD3D0_SPECULAR_FOG                                 31:24 /* -W-UF */
NV_UD3D0_SPECULAR_FOG           TEXTEQU         <31:24>
;  -W-4A 
;        
;  3326 : #define NV_UD3D0_COLOR(i)                       (0x00561004+(i)*32) /* -W-4A */
;  3327 : #define NV_UD3D0_COLOR__SIZE_1                                  128 /*       */
NV_UD3D0_COLOR__SIZE_1          EQU             128t
;  -W-UF 
;  3328 : #define NV_UD3D0_COLOR_B8                                       7:0 /* -W-UF */
NV_UD3D0_COLOR_B8               TEXTEQU         <7:0>
;  -W-UF 
;  3329 : #define NV_UD3D0_COLOR_G8                                      16:8 /* -W-UF */
NV_UD3D0_COLOR_G8               TEXTEQU         <16:8>
;  -W-UF 
;  3330 : #define NV_UD3D0_COLOR_R8                                     23:16 /* -W-UF */
NV_UD3D0_COLOR_R8               TEXTEQU         <23:16>
;  -W-UF 
;  3331 : #define NV_UD3D0_COLOR_A8                                     32:24 /* -W-UF */
NV_UD3D0_COLOR_A8               TEXTEQU         <32:24>
;  -W-4A 
;        
;  3332 : #define NV_UD3D0_X(i)                           (0x00561008+(i)*32) /* -W-4A */
;  3333 : #define NV_UD3D0_X__SIZE_1                                      128 /*       */
NV_UD3D0_X__SIZE_1              EQU             128t
;  -W-FF 
;  3334 : #define NV_UD3D0_X_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_X_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3335 : #define NV_UD3D0_Y(i)                           (0x0056100C+(i)*32) /* -W-4A */
;  3336 : #define NV_UD3D0_Y__SIZE_1                                      128 /*       */
NV_UD3D0_Y__SIZE_1              EQU             128t
;  -W-FF 
;  3337 : #define NV_UD3D0_Y_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_Y_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3338 : #define NV_UD3D0_Z(i)                           (0x00561010+(i)*32) /* -W-4A */
;  3339 : #define NV_UD3D0_Z__SIZE_1                                      128 /*       */
NV_UD3D0_Z__SIZE_1              EQU             128t
;  -W-FF 
;  3340 : #define NV_UD3D0_Z_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_Z_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3341 : #define NV_UD3D0_M(i)                           (0x00561014+(i)*32) /* -W-4A */
;  3342 : #define NV_UD3D0_M__SIZE_1                                      128 /*       */
NV_UD3D0_M__SIZE_1              EQU             128t
;  -W-FF 
;  3343 : #define NV_UD3D0_M_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_M_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3344 : #define NV_UD3D0_U(i)                           (0x00561018+(i)*32) /* -W-4A */
;  3345 : #define NV_UD3D0_U__SIZE_1                                      128 /*       */
NV_UD3D0_U__SIZE_1              EQU             128t
;  -W-FF 
;  3346 : #define NV_UD3D0_U_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_U_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3347 : #define NV_UD3D0_V(i)                           (0x0056101c+(i)*32) /* -W-4A */
;  3348 : #define NV_UD3D0_V__SIZE_1                                      128 /*       */
NV_UD3D0_V__SIZE_1              EQU             128t
;  -W-FF 
;  3349 : #define NV_UD3D0_V_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_V_VALUE                TEXTEQU         <31:0>
;  usr_pattern.ref 
;  -W--D 
;  3350 : /* usr_pattern.ref */
;  3351 : #define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
NV_UPATT                TEXTEQU         <0x00461FFF:0x00460000>
;  -W-4R 
;  3352 : #define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
NV_UPATT_CTX_SWITCH             EQU             000460000h
;  -W-UF 
;  3353 : #define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UPATT_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3354 : #define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UPATT_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3355 : #define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UPATT_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3356 : #define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3357 : #define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UPATT_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3358 : #define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
NV_UPATT_SET_NOTIFY             EQU             000460104h
;  -W-VF 
;  3359 : #define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UPATT_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3360 : #define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UPATT_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3361 : #define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
NV_UPATT_SET_SHAPE              EQU             000460308h
;  -W-VF 
;  3362 : #define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
NV_UPATT_SET_SHAPE_VALUE                TEXTEQU         <1:0>
;  -W--V 
;  3363 : #define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
NV_UPATT_SET_SHAPE_VALUE_8X8            EQU             000000000h
;  -W--V 
;  3364 : #define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
NV_UPATT_SET_SHAPE_VALUE_64X1           EQU             000000001h
;  -W--V 
;  3365 : #define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
NV_UPATT_SET_SHAPE_VALUE_1X64           EQU             000000002h
;  -W-4R 
;  3366 : #define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
NV_UPATT_SET_COLOR0             EQU             000460310h
;  -W-VF 
;  3367 : #define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
NV_UPATT_SET_COLOR0_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3368 : #define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
NV_UPATT_SET_COLOR1             EQU             000460314h
;  -W-VF 
;  3369 : #define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
NV_UPATT_SET_COLOR1_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3370 : #define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
;  3371 : #define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
NV_UPATT_SET_PATTERN__SIZE_1            EQU             2t
;  -W-VF 
;  3372 : #define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
NV_UPATT_SET_PATTERN_BITMAP             TEXTEQU         <31:0>
;  usr_point.ref 
;  -W--D 
;  3373 : /* usr_point.ref */
;  3374 : #define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
NV_UPOINT               TEXTEQU         <0x00481FFF:0x00480000>
;  -W-4R 
;  3375 : #define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
NV_UPOINT_CTX_SWITCH            EQU             000480000h
;  -W-UF 
;  3376 : #define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UPOINT_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3377 : #define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UPOINT_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3378 : #define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UPOINT_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3379 : #define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3380 : #define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UPOINT_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3381 : #define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
NV_UPOINT_SET_NOTIFY            EQU             000480104h
;  -W-VF 
;  3382 : #define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UPOINT_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3383 : #define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3384 : #define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
NV_UPOINT_COLOR         EQU             000480304h
;  -W-VF 
;  3385 : #define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
NV_UPOINT_COLOR_VALUE           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3386 : #define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
;  3387 : #define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
NV_UPOINT_POINT__SIZE_1         EQU             32t
;  -W-SF 
;  3388 : #define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
NV_UPOINT_POINT_X               TEXTEQU         <15:0>
;  -W-SF 
;  3389 : #define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
NV_UPOINT_POINT_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3390 : #define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
;  3391 : #define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
NV_UPOINT_POINT32_0__SIZE_1             EQU             16t
;  -W-SF 
;  3392 : #define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
NV_UPOINT_POINT32_0_X           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3393 : #define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
;  3394 : #define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
NV_UPOINT_POINT32_1__SIZE_1             EQU             16t
;  -W-SF 
;  3395 : #define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
NV_UPOINT_POINT32_1_Y           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3396 : #define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
;  3397 : #define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
NV_UPOINT_CPOINT_0__SIZE_1              EQU             16t
;  -W-VF 
;  3398 : #define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
NV_UPOINT_CPOINT_0_COLOR                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3399 : #define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
;  3400 : #define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
NV_UPOINT_CPOINT_1__SIZE_1              EQU             16t
;  -W-SF 
;  3401 : #define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
NV_UPOINT_CPOINT_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3402 : #define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
NV_UPOINT_CPOINT_1_Y            TEXTEQU         <31:16>
;  usr_pointz.ref 
;  -W--D 
;  3403 : /* usr_pointz.ref */
;  3404 : #define NV_UPOINTZ                            0x00581FFF:0x00580000 /* -W--D */
NV_UPOINTZ              TEXTEQU         <0x00581FFF:0x00580000>
;  -W-4R 
;  3405 : #define NV_UPOINTZ_CTX_SWITCH                            0x00580000 /* -W-4R */
NV_UPOINTZ_CTX_SWITCH           EQU             000580000h
;  -W-UF 
;  3406 : #define NV_UPOINTZ_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UPOINTZ_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3407 : #define NV_UPOINTZ_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UPOINTZ_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3408 : #define NV_UPOINTZ_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UPOINTZ_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3409 : #define NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3410 : #define NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3411 : #define NV_UPOINTZ_SET_NOTIFY                            0x00580104 /* -W-4R */
NV_UPOINTZ_SET_NOTIFY           EQU             000580104h
;  -W-VF 
;  3412 : #define NV_UPOINTZ_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UPOINTZ_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3413 : #define NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3414 : #define NV_UPOINTZ_CONTROL_OUT                           0x00580304 /* -W-4R */
NV_UPOINTZ_CONTROL_OUT          EQU             000580304h
;  -W-UF 
;  3415 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE                   19:16 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE             TEXTEQU         <19:16>
;  -W-UV 
;  3416 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE        0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE               EQU             000000001h
;  -W-UV 
;  3417 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT           0x00000002 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT          EQU             000000002h
;  -W-UV 
;  3418 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ           0x00000003 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ          EQU             000000003h
;  -W-UV 
;  3419 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE           0x00000004 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE          EQU             000000004h
;  -W-UV 
;  3420 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT           0x00000005 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT          EQU             000000005h
;  -W-UV 
;  3421 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE           0x00000006 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE          EQU             000000006h
;  -W-UV 
;  3422 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE           0x00000007 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE          EQU             000000007h
;  -W-UV 
;  3423 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE         0x00000008 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE                EQU             000000008h
;  -W-UF 
;  3424 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE                     22:20 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE               TEXTEQU         <22:20>
;  -W-UV 
;  3425 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER          0x00000000 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER         EQU             000000000h
;  -W-UV 
;  3426 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA          0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA         EQU             000000001h
;  -W-UV 
;  3427 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA            EQU             000000002h
;  -W-UV 
;  3428 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA           0x00000003 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA          EQU             000000003h
;  -W-UV 
;  3429 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS         0x00000004 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS                EQU             000000004h
;  -W-UF 
;  3430 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE                    25:24 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE              TEXTEQU         <25:24>
;  -W-UV 
;  3431 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER         0x00000000 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER                EQU             000000000h
;  -W-UV 
;  3432 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA         0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA                EQU             000000001h
;  -W-UV 
;  3433 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA    0x00000002 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA           EQU             000000002h
;  -W-UF 
;  3434 : #define NV_UPOINTZ_CONTROL_OUT_ROP                            28:28 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_ROP              TEXTEQU         <28:28>
;  -W-UV 
;  3435 : #define NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND             0x00000000 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND            EQU             000000000h
;  -W-UV 
;  3436 : #define NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION   0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION          EQU             000000001h
;  -W-4R 
;  3437 : #define NV_UPOINTZ_POINT                                 0x005807FC /* -W-4R */
NV_UPOINTZ_POINT                EQU             0005807fch
;  -W-SF 
;  3438 : #define NV_UPOINTZ_POINT_X                                     15:0 /* -W-SF */
NV_UPOINTZ_POINT_X              TEXTEQU         <15:0>
;  -W-SF 
;  3439 : #define NV_UPOINTZ_POINT_Y                                    31:16 /* -W-SF */
NV_UPOINTZ_POINT_Y              TEXTEQU         <31:16>
;  -W-4A 
;        
;  3440 : #define NV_UPOINTZ_COLOR(i)                      (0x00580800+(i)*8) /* -W-4A */
;  3441 : #define NV_UPOINTZ_COLOR__SIZE_1                                256 /*       */
NV_UPOINTZ_COLOR__SIZE_1                EQU             256t
;  -W-VF 
;  3442 : #define NV_UPOINTZ_COLOR_VALUE                                 31:0 /* -W-VF */
NV_UPOINTZ_COLOR_VALUE          TEXTEQU         <31:0>
;  -W-4A 
;        
;  3443 : #define NV_UPOINTZ_ZETA(i)                       (0x00580804+(i)*8) /* -W-4A */
;  3444 : #define NV_UPOINTZ_ZETA__SIZE_1                                 256 /*       */
NV_UPOINTZ_ZETA__SIZE_1         EQU             256t
;  -W-VF 
;  3445 : #define NV_UPOINTZ_ZETA_VALUE                                  31:0 /* -W-VF */
NV_UPOINTZ_ZETA_VALUE           TEXTEQU         <31:0>
;  usr_line.ref 
;  -W--D 
;  3446 : /* usr_line.ref */
;  3447 : #define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
NV_ULINE                TEXTEQU         <0x00491FFF:0x00490000>
;  -W-4R 
;  3448 : #define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
NV_ULINE_CTX_SWITCH             EQU             000490000h
;  -W-UF 
;  3449 : #define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_ULINE_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3450 : #define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_ULINE_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3451 : #define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_ULINE_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3452 : #define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3453 : #define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_ULINE_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3454 : #define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
NV_ULINE_SET_NOTIFY             EQU             000490104h
;  -W-VF 
;  3455 : #define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_ULINE_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3456 : #define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_ULINE_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3457 : #define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
NV_ULINE_COLOR          EQU             000490304h
;  -W-VF 
;  3458 : #define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
NV_ULINE_COLOR_VALUE            TEXTEQU         <31:0>
;  -W-4A 
;        
;  3459 : #define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
;  3460 : #define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
NV_ULINE_LINE_0__SIZE_1         EQU             16t
;  -W-SF 
;  3461 : #define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
NV_ULINE_LINE_0_X               TEXTEQU         <15:0>
;  -W-SF 
;  3462 : #define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
NV_ULINE_LINE_0_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3463 : #define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
;  3464 : #define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
NV_ULINE_LINE_1__SIZE_1         EQU             16t
;  -W-SF 
;  3465 : #define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
NV_ULINE_LINE_1_X               TEXTEQU         <15:0>
;  -W-SF 
;  3466 : #define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
NV_ULINE_LINE_1_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3467 : #define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
;  3468 : #define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_0__SIZE_1               EQU             8t
;  -W-SF 
;  3469 : #define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
NV_ULINE_LINE32_0_X             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3470 : #define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
;  3471 : #define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_1__SIZE_1               EQU             8t
;  -W-SF 
;  3472 : #define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
NV_ULINE_LINE32_1_Y             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3473 : #define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
;  3474 : #define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_2__SIZE_1               EQU             8t
;  -W-SF 
;  3475 : #define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
NV_ULINE_LINE32_2_X             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3476 : #define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
;  3477 : #define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_3__SIZE_1               EQU             8t
;  -W-SF 
;  3478 : #define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
NV_ULINE_LINE32_3_Y             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3479 : #define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
;  3480 : #define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
NV_ULINE_POLYLINE__SIZE_1               EQU             32t
;  -W-SF 
;  3481 : #define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
NV_ULINE_POLYLINE_X             TEXTEQU         <15:0>
;  -W-SF 
;  3482 : #define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
NV_ULINE_POLYLINE_Y             TEXTEQU         <31:16>
;  -W-4A 
;        
;  3483 : #define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
;  3484 : #define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
NV_ULINE_POLYLINE32_0__SIZE_1           EQU             16t
;  -W-SF 
;  3485 : #define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
NV_ULINE_POLYLINE32_0_X         TEXTEQU         <31:0>
;  -W-4A 
;        
;  3486 : #define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
;  3487 : #define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
NV_ULINE_POLYLINE32_1__SIZE_1           EQU             16t
;  -W-SF 
;  3488 : #define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
NV_ULINE_POLYLINE32_1_Y         TEXTEQU         <31:0>
;  -W-4A 
;        
;  3489 : #define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
;  3490 : #define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
NV_ULINE_CPOLYLINE_0__SIZE_1            EQU             16t
;  -W-VF 
;  3491 : #define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
NV_ULINE_CPOLYLINE_0_COLOR              TEXTEQU         <31:0>
;  -W-4A 
;        
;  3492 : #define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
;  3493 : #define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
NV_ULINE_CPOLYLINE_1__SIZE_1            EQU             16t
;  -W-SF 
;  3494 : #define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
NV_ULINE_CPOLYLINE_1_X          TEXTEQU         <15:0>
;  -W-SF 
;  3495 : #define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
NV_ULINE_CPOLYLINE_1_Y          TEXTEQU         <31:16>
;  usr_lin.ref 
;  -W--D 
;  3496 : /* usr_lin.ref */
;  3497 : #define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
NV_ULIN         TEXTEQU         <0x004A1FFF:0x004A0000>
;  -W-4R 
;  3498 : #define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
NV_ULIN_CTX_SWITCH              EQU             0004a0000h
;  -W-UF 
;  3499 : #define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
NV_ULIN_CTX_SWITCH_INSTANCE             TEXTEQU         <15:0>
;  -W-UF 
;  3500 : #define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
NV_ULIN_CTX_SWITCH_CHID         TEXTEQU         <22:16>
;  -W-VF 
;  3501 : #define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
NV_ULIN_CTX_SWITCH_VOLATILE             TEXTEQU         <31:31>
;  -W--V 
;  3502 : #define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE              EQU             000000000h
;  -W--V 
;  3503 : #define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
NV_ULIN_CTX_SWITCH_VOLATILE_RESET               EQU             000000001h
;  -W-4R 
;  3504 : #define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
NV_ULIN_SET_NOTIFY              EQU             0004a0104h
;  -W-VF 
;  3505 : #define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
NV_ULIN_SET_NOTIFY_PARAMETER            TEXTEQU         <31:0>
;  -W--V 
;  3506 : #define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
NV_ULIN_SET_NOTIFY_PARAMETER_WRITE              EQU             000000000h
;  -W-4R 
;  3507 : #define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
NV_ULIN_COLOR           EQU             0004a0304h
;  -W-VF 
;  3508 : #define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
NV_ULIN_COLOR_VALUE             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3509 : #define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
;  3510 : #define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
NV_ULIN_LIN_0__SIZE_1           EQU             16t
;  -W-SF 
;  3511 : #define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
NV_ULIN_LIN_0_X         TEXTEQU         <15:0>
;  -W-SF 
;  3512 : #define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
NV_ULIN_LIN_0_Y         TEXTEQU         <31:16>
;  -W-4A 
;        
;  3513 : #define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
;  3514 : #define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
NV_ULIN_LIN_1__SIZE_1           EQU             16t
;  -W-SF 
;  3515 : #define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
NV_ULIN_LIN_1_X         TEXTEQU         <15:0>
;  -W-SF 
;  3516 : #define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
NV_ULIN_LIN_1_Y         TEXTEQU         <31:16>
;  -W-4A 
;        
;  3517 : #define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
;  3518 : #define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_0__SIZE_1         EQU             8t
;  -W-SF 
;  3519 : #define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
NV_ULIN_LIN32_0_X               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3520 : #define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
;  3521 : #define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_1__SIZE_1         EQU             8t
;  -W-SF 
;  3522 : #define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
NV_ULIN_LIN32_1_Y               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3523 : #define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
;  3524 : #define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_2__SIZE_1         EQU             8t
;  -W-SF 
;  3525 : #define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
NV_ULIN_LIN32_2_X               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3526 : #define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
;  3527 : #define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_3__SIZE_1         EQU             8t
;  -W-SF 
;  3528 : #define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
NV_ULIN_LIN32_3_Y               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3529 : #define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
;  3530 : #define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
NV_ULIN_POLYLIN__SIZE_1         EQU             32t
;  -W-SF 
;  3531 : #define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
NV_ULIN_POLYLIN_X               TEXTEQU         <15:0>
;  -W-SF 
;  3532 : #define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
NV_ULIN_POLYLIN_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3533 : #define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
;  3534 : #define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
NV_ULIN_POLYLIN32_0__SIZE_1             EQU             16t
;  -W-SF 
;  3535 : #define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
NV_ULIN_POLYLIN32_0_X           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3536 : #define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
;  3537 : #define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
NV_ULIN_POLYLIN32_1__SIZE_1             EQU             16t
;  -W-SF 
;  3538 : #define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
NV_ULIN_POLYLIN32_1_Y           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3539 : #define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
;  3540 : #define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
NV_ULIN_CPOLYLIN_0__SIZE_1              EQU             16t
;  -W-VF 
;  3541 : #define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
NV_ULIN_CPOLYLIN_0_COLOR                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3542 : #define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
;  3543 : #define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
NV_ULIN_CPOLYLIN_1__SIZE_1              EQU             16t
;  -W-SF 
;  3544 : #define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
NV_ULIN_CPOLYLIN_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3545 : #define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
NV_ULIN_CPOLYLIN_1_Y            TEXTEQU         <31:16>
;  usr_mem_to_mem.ref 
;  -W--D 
;  3546 : /* usr_mem_to_mem.ref */
;  3547 : #define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
NV_UMEMFMT              TEXTEQU         <0x004D1FFF:0x004D0000>
;  -W-4R 
;  3548 : #define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
NV_UMEMFMT_CTX_SWITCH           EQU             0004d0000h
;  -W-UF 
;  3549 : #define NV_UMEMFMT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UMEMFMT_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3550 : #define NV_UMEMFMT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UMEMFMT_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3551 : #define NV_UMEMFMT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UMEMFMT_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3552 : #define NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3553 : #define NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3554 : #define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
NV_UMEMFMT_SET_NOTIFY           EQU             0004d0104h
;  -W-VF 
;  3555 : #define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UMEMFMT_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3556 : #define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3557 : #define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
NV_UMEMFMT_OFFSET_IN            EQU             0004d030ch
;  -W-UF 
;  3558 : #define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
NV_UMEMFMT_OFFSET_IN_VALUE              TEXTEQU         <31:0>
;  -W-4R 
;  3559 : #define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
NV_UMEMFMT_OFFSET_OUT           EQU             0004d0310h
;  -W-UF 
;  3560 : #define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
NV_UMEMFMT_OFFSET_OUT_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3561 : #define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
NV_UMEMFMT_PITCH_IN             EQU             0004d0314h
;  -W-SF 
;  3562 : #define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
NV_UMEMFMT_PITCH_IN_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3563 : #define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
NV_UMEMFMT_PITCH_OUT            EQU             0004d0318h
;  -W-SF 
;  3564 : #define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
NV_UMEMFMT_PITCH_OUT_VALUE              TEXTEQU         <31:0>
;  -W-4R 
;  3565 : #define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
NV_UMEMFMT_LINE_LENGTH_IN               EQU             0004d031ch
;  -W-UF 
;  3566 : #define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
NV_UMEMFMT_LINE_LENGTH_IN_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3567 : #define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
NV_UMEMFMT_LINE_COUNT           EQU             0004d0320h
;  -W-UF 
;  3568 : #define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
NV_UMEMFMT_LINE_COUNT_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3569 : #define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
NV_UMEMFMT_FORMAT               EQU             0004d0324h
;  -W-UF 
;  3570 : #define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
NV_UMEMFMT_FORMAT_INPUT_INC             TEXTEQU         <2:0>
;  -WIUV 
;  3571 : #define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
NV_UMEMFMT_FORMAT_INPUT_INC_1           EQU             000000001h
;  -W-UV 
;  3572 : #define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
NV_UMEMFMT_FORMAT_INPUT_INC_2           EQU             000000002h
;  -W-UV 
;  3573 : #define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
NV_UMEMFMT_FORMAT_INPUT_INC_4           EQU             000000004h
;  -W-UF 
;  3574 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
NV_UMEMFMT_FORMAT_OUTPUT_INC            TEXTEQU         <10:8>
;  -WIUV 
;  3575 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
NV_UMEMFMT_FORMAT_OUTPUT_INC_1          EQU             000000001h
;  -W-UV 
;  3576 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
NV_UMEMFMT_FORMAT_OUTPUT_INC_2          EQU             000000002h
;  -W-UV 
;  3577 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
NV_UMEMFMT_FORMAT_OUTPUT_INC_4          EQU             000000004h
;  -W-4R 
;  3578 : #define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
NV_UMEMFMT_BUF_NOTIFY           EQU             0004d0328h
;  -W-UF 
;  3579 : #define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
NV_UMEMFMT_BUF_NOTIFY_VALUE             TEXTEQU         <31:0>
;  usr_triangle.ref 
;  -W--D 
;  3580 : /* usr_triangle.ref */
;  3581 : #define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
NV_UTRI         TEXTEQU         <0x004B1FFF:0x004B0000>
;  -W-4R 
;  3582 : #define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
NV_UTRI_CTX_SWITCH              EQU             0004b0000h
;  -W-UF 
;  3583 : #define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
NV_UTRI_CTX_SWITCH_INSTANCE             TEXTEQU         <15:0>
;  -W-UF 
;  3584 : #define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
NV_UTRI_CTX_SWITCH_CHID         TEXTEQU         <22:16>
;  -W-VF 
;  3585 : #define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
NV_UTRI_CTX_SWITCH_VOLATILE             TEXTEQU         <31:31>
;  -W--V 
;  3586 : #define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE              EQU             000000000h
;  -W--V 
;  3587 : #define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
NV_UTRI_CTX_SWITCH_VOLATILE_RESET               EQU             000000001h
;  -W-4R 
;  3588 : #define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
NV_UTRI_SET_NOTIFY              EQU             0004b0104h
;  -W-VF 
;  3589 : #define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
NV_UTRI_SET_NOTIFY_PARAMETER            TEXTEQU         <31:0>
;  -W--V 
;  3590 : #define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
NV_UTRI_SET_NOTIFY_PARAMETER_WRITE              EQU             000000000h
;  -W-4R 
;  3591 : #define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
NV_UTRI_COLOR           EQU             0004b0304h
;  -W-VF 
;  3592 : #define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
NV_UTRI_COLOR_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3593 : #define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
NV_UTRI_TRIANGLE_0              EQU             0004b0310h
;  -W-SF 
;  3594 : #define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
NV_UTRI_TRIANGLE_0_X            TEXTEQU         <15:0>
;  -W-SF 
;  3595 : #define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
NV_UTRI_TRIANGLE_0_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3596 : #define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
NV_UTRI_TRIANGLE_1              EQU             0004b0314h
;  -W-SF 
;  3597 : #define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
NV_UTRI_TRIANGLE_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3598 : #define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
NV_UTRI_TRIANGLE_1_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3599 : #define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
NV_UTRI_TRIANGLE_2              EQU             0004b0318h
;  -W-SF 
;  3600 : #define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
NV_UTRI_TRIANGLE_2_X            TEXTEQU         <15:0>
;  -W-SF 
;  3601 : #define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
NV_UTRI_TRIANGLE_2_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3602 : #define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
NV_UTRI_TRIANGLE32_0            EQU             0004b0320h
;  -W-SF 
;  3603 : #define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_0_X          TEXTEQU         <31:0>
;  -W-4R 
;  3604 : #define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
NV_UTRI_TRIANGLE32_1            EQU             0004b0324h
;  -W-SF 
;  3605 : #define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_1_Y          TEXTEQU         <31:0>
;  -W-4R 
;  3606 : #define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
NV_UTRI_TRIANGLE32_2            EQU             0004b0328h
;  -W-SF 
;  3607 : #define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_2_X          TEXTEQU         <31:0>
;  -W-4R 
;  3608 : #define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
NV_UTRI_TRIANGLE32_3            EQU             0004b032ch
;  -W-SF 
;  3609 : #define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_3_Y          TEXTEQU         <31:0>
;  -W-4R 
;  3610 : #define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
NV_UTRI_TRIANGLE32_4            EQU             0004b0330h
;  -W-SF 
;  3611 : #define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_4_X          TEXTEQU         <31:0>
;  -W-4R 
;  3612 : #define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
NV_UTRI_TRIANGLE32_5            EQU             0004b0334h
;  -W-SF 
;  3613 : #define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_5_Y          TEXTEQU         <31:0>
;  -W-4A 
;        
;  3614 : #define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
;  3615 : #define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
NV_UTRI_TRIMESH__SIZE_1         EQU             32t
;  -W-SF 
;  3616 : #define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
NV_UTRI_TRIMESH_X               TEXTEQU         <15:0>
;  -W-SF 
;  3617 : #define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
NV_UTRI_TRIMESH_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3618 : #define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
;  3619 : #define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
NV_UTRI_TRIMESH32_0__SIZE_1             EQU             16t
;  -W-SF 
;  3620 : #define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
NV_UTRI_TRIMESH32_0_X           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3621 : #define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
;  3622 : #define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
NV_UTRI_TRIMESH32_1__SIZE_1             EQU             16t
;  -W-SF 
;  3623 : #define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
NV_UTRI_TRIMESH32_1_Y           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3624 : #define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
;  3625 : #define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_0__SIZE_1             EQU             8t
;  -W-VF 
;  3626 : #define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
NV_UTRI_CTRIANGLE_0_COLOR               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3627 : #define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
;  3628 : #define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_1__SIZE_1             EQU             8t
;  -W-SF 
;  3629 : #define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
NV_UTRI_CTRIANGLE_1_X           TEXTEQU         <15:0>
;  -W-SF 
;  3630 : #define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
NV_UTRI_CTRIANGLE_1_Y           TEXTEQU         <31:16>
;  -W-4A 
;        
;  3631 : #define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
;  3632 : #define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_2__SIZE_1             EQU             8t
;  -W-SF 
;  3633 : #define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
NV_UTRI_CTRIANGLE_2_X           TEXTEQU         <15:0>
;  -W-SF 
;  3634 : #define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
NV_UTRI_CTRIANGLE_2_Y           TEXTEQU         <31:16>
;  -W-4A 
;        
;  3635 : #define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
;  3636 : #define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_3__SIZE_1             EQU             8t
;  -W-SF 
;  3637 : #define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
NV_UTRI_CTRIANGLE_3_X           TEXTEQU         <15:0>
;  -W-SF 
;  3638 : #define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
NV_UTRI_CTRIANGLE_3_Y           TEXTEQU         <31:16>
;  -W-4A 
;        
;  3639 : #define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
;  3640 : #define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
NV_UTRI_CTRIMESH_0__SIZE_1              EQU             16t
;  -W-VF 
;  3641 : #define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
NV_UTRI_CTRIMESH_0_COLOR                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3642 : #define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
;  3643 : #define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
NV_UTRI_CTRIMESH_1__SIZE_1              EQU             16t
;  -W-SF 
;  3644 : #define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
NV_UTRI_CTRIMESH_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3645 : #define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
NV_UTRI_CTRIMESH_1_Y            TEXTEQU         <31:16>
;  usr_rectangle.ref 
;  -W--D 
;  3646 : /* usr_rectangle.ref */
;  3647 : #define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
NV_URECT                TEXTEQU         <0x00471FFF:0x00470000>
;  -W-4R 
;  3648 : #define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
NV_URECT_CTX_SWITCH             EQU             000470000h
;  -W-UF 
;  3649 : #define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_URECT_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3650 : #define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_URECT_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3651 : #define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_URECT_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3652 : #define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_URECT_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3653 : #define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_URECT_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3654 : #define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
NV_URECT_SET_NOTIFY             EQU             000470104h
;  -W-VF 
;  3655 : #define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_URECT_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3656 : #define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_URECT_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3657 : #define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
NV_URECT_COLOR          EQU             000470304h
;  -W-VF 
;  3658 : #define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
NV_URECT_COLOR_VALUE            TEXTEQU         <31:0>
;  -W-4A 
;        
;  3659 : #define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
;  3660 : #define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
NV_URECT_RECTANGLE_0__SIZE_1            EQU             16t
;  -W-SF 
;  3661 : #define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
NV_URECT_RECTANGLE_0_X          TEXTEQU         <15:0>
;  -W-SF 
;  3662 : #define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
NV_URECT_RECTANGLE_0_Y          TEXTEQU         <31:16>
;  -W-4A 
;        
;  3663 : #define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
;  3664 : #define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
NV_URECT_RECTANGLE_1__SIZE_1            EQU             16t
;  -W-UF 
;  3665 : #define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
NV_URECT_RECTANGLE_1_WIDTH              TEXTEQU         <15:0>
;  -W-UF 
;  3666 : #define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
NV_URECT_RECTANGLE_1_HEIGHT             TEXTEQU         <31:16>
;  usr_image_blit.ref 
;  -W--D 
;  3667 : /* usr_image_blit.ref */
;  3668 : #define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
NV_UBLIT                TEXTEQU         <0x00501FFF:0x00500000>
;  -W-4R 
;  3669 : #define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
NV_UBLIT_CTX_SWITCH             EQU             000500000h
;  -W-UF 
;  3670 : #define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UBLIT_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3671 : #define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UBLIT_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3672 : #define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UBLIT_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3673 : #define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3674 : #define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UBLIT_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3675 : #define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
NV_UBLIT_SET_NOTIFY             EQU             000500104h
;  -W-VF 
;  3676 : #define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UBLIT_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3677 : #define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3678 : #define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
NV_UBLIT_POINT_IN               EQU             000500300h
;  -W-SF 
;  3679 : #define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
NV_UBLIT_POINT_IN_X             TEXTEQU         <15:0>
;  -W-SF 
;  3680 : #define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
NV_UBLIT_POINT_IN_Y             TEXTEQU         <31:16>
;  -W-4R 
;  3681 : #define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
NV_UBLIT_POINT_OUT              EQU             000500304h
;  -W-SF 
;  3682 : #define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
NV_UBLIT_POINT_OUT_X            TEXTEQU         <15:0>
;  -W-SF 
;  3683 : #define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
NV_UBLIT_POINT_OUT_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3684 : #define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
NV_UBLIT_SIZE           EQU             000500308h
;  -W-UF 
;  3685 : #define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
NV_UBLIT_SIZE_WIDTH             TEXTEQU         <15:0>
;  -W-UF 
;  3686 : #define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
NV_UBLIT_SIZE_HEIGHT            TEXTEQU         <31:16>
;  usr_image_from_cpu.ref 
;  -W--D 
;  3687 : /* usr_image_from_cpu.ref */
;  3688 : #define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
NV_UIMAGE               TEXTEQU         <0x00511FFF:0x00510000>
;  -W-4R 
;  3689 : #define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
NV_UIMAGE_CTX_SWITCH            EQU             000510000h
;  -W-UF 
;  3690 : #define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UIMAGE_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3691 : #define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UIMAGE_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3692 : #define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UIMAGE_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3693 : #define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3694 : #define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3695 : #define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
NV_UIMAGE_SET_NOTIFY            EQU             000510104h
;  -W-VF 
;  3696 : #define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UIMAGE_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3697 : #define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3698 : #define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
NV_UIMAGE_POINT         EQU             000510304h
;  -W-SF 
;  3699 : #define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
NV_UIMAGE_POINT_X               TEXTEQU         <15:0>
;  -W-SF 
;  3700 : #define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
NV_UIMAGE_POINT_Y               TEXTEQU         <31:16>
;  -W-4R 
;  3701 : #define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
NV_UIMAGE_SIZE          EQU             000510308h
;  -W-UF 
;  3702 : #define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
NV_UIMAGE_SIZE_WIDTH            TEXTEQU         <15:0>
;  -W-UF 
;  3703 : #define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
NV_UIMAGE_SIZE_HEIGHT           TEXTEQU         <31:16>
;  -W-4R 
;  3704 : #define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
NV_UIMAGE_SIZE_IN               EQU             00051030ch
;  -W-UF 
;  3705 : #define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
NV_UIMAGE_SIZE_IN_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3706 : #define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
NV_UIMAGE_SIZE_IN_HEIGHT                TEXTEQU         <31:16>
;  -W-4A 
;        
;  3707 : #define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
;  3708 : #define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
NV_UIMAGE_COLOR__SIZE_1         EQU             32t
;  -W-VF 
;  3709 : #define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
NV_UIMAGE_COLOR_VALUE           TEXTEQU         <31:0>
;  usr_bitmap_from_cpu.ref 
;  -W--D 
;  3710 : /* usr_bitmap_from_cpu.ref */
;  3711 : #define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
NV_UBITMAP              TEXTEQU         <0x00521FFF:0x00520000>
;  -W-4R 
;  3712 : #define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
NV_UBITMAP_CTX_SWITCH           EQU             000520000h
;  -W-UF 
;  3713 : #define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UBITMAP_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3714 : #define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UBITMAP_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3715 : #define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UBITMAP_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3716 : #define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3717 : #define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3718 : #define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
NV_UBITMAP_SET_NOTIFY           EQU             000520104h
;  -W-VF 
;  3719 : #define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UBITMAP_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3720 : #define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3721 : #define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
NV_UBITMAP_COLOR0               EQU             000520308h
;  -W-VF 
;  3722 : #define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
NV_UBITMAP_COLOR0_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3723 : #define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
NV_UBITMAP_COLOR1               EQU             00052030ch
;  -W-VF 
;  3724 : #define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
NV_UBITMAP_COLOR1_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3725 : #define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
NV_UBITMAP_POINT                EQU             000520310h
;  -W-SF 
;  3726 : #define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
NV_UBITMAP_POINT_X              TEXTEQU         <15:0>
;  -W-SF 
;  3727 : #define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
NV_UBITMAP_POINT_Y              TEXTEQU         <31:16>
;  -W-4R 
;  3728 : #define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
NV_UBITMAP_SIZE         EQU             000520314h
;  -W-UF 
;  3729 : #define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
NV_UBITMAP_SIZE_WIDTH           TEXTEQU         <15:0>
;  -W-UF 
;  3730 : #define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
NV_UBITMAP_SIZE_HEIGHT          TEXTEQU         <31:16>
;  -W-4R 
;  3731 : #define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
NV_UBITMAP_SIZE_IN              EQU             000520318h
;  -W-UF 
;  3732 : #define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
NV_UBITMAP_SIZE_IN_WIDTH                TEXTEQU         <15:0>
;  -W-UF 
;  3733 : #define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
NV_UBITMAP_SIZE_IN_HEIGHT               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3734 : #define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
;  3735 : #define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
NV_UBITMAP_MONOCHROME__SIZE_1           EQU             32t
;  -W-VF 
;  3736 : #define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
NV_UBITMAP_MONOCHROME_BITMAP            TEXTEQU         <31:0>
;  usr_image_from_mem.ref 
;  -W--D 
;  3737 : /* usr_image_from_mem.ref */
;  3738 : #define NV_UFROMEM                            0x00531FFF:0x00530000 /* -W--D */
NV_UFROMEM              TEXTEQU         <0x00531FFF:0x00530000>
;  -W-4R 
;  3739 : #define NV_UFROMEM_CTX_SWITCH                            0x00530000 /* -W-4R */
NV_UFROMEM_CTX_SWITCH           EQU             000530000h
;  -W-UF 
;  3740 : #define NV_UFROMEM_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UFROMEM_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3741 : #define NV_UFROMEM_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UFROMEM_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3742 : #define NV_UFROMEM_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UFROMEM_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3743 : #define NV_UFROMEM_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UFROMEM_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3744 : #define NV_UFROMEM_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UFROMEM_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4A 
;        
;  3745 : #define NV_UFROMEM_DMA_REPLY(i)                  (0x00530040+(i)*4) /* -W-4A */
;  3746 : #define NV_UFROMEM_DMA_REPLY__SIZE_1                             16 /*       */
NV_UFROMEM_DMA_REPLY__SIZE_1            EQU             16t
;  -W-VF 
;  3747 : #define NV_UFROMEM_DMA_REPLY_DATA                              31:0 /* -W-VF */
NV_UFROMEM_DMA_REPLY_DATA               TEXTEQU         <31:0>
;  -W-4R 
;  3748 : #define NV_UFROMEM_SET_NOTIFY                            0x00530104 /* -W-4R */
NV_UFROMEM_SET_NOTIFY           EQU             000530104h
;  -W-VF 
;  3749 : #define NV_UFROMEM_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UFROMEM_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3750 : #define NV_UFROMEM_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UFROMEM_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3751 : #define NV_UFROMEM_POINT                                 0x00530308 /* -W-4R */
NV_UFROMEM_POINT                EQU             000530308h
;  -W-SF 
;  3752 : #define NV_UFROMEM_POINT_X                                     15:0 /* -W-SF */
NV_UFROMEM_POINT_X              TEXTEQU         <15:0>
;  -W-SF 
;  3753 : #define NV_UFROMEM_POINT_Y                                    31:16 /* -W-SF */
NV_UFROMEM_POINT_Y              TEXTEQU         <31:16>
;  -W-4R 
;  3754 : #define NV_UFROMEM_SIZE                                  0x0053030C /* -W-4R */
NV_UFROMEM_SIZE         EQU             00053030ch
;  -W-UF 
;  3755 : #define NV_UFROMEM_SIZE_WIDTH                                  15:0 /* -W-UF */
NV_UFROMEM_SIZE_WIDTH           TEXTEQU         <15:0>
;  -W-UF 
;  3756 : #define NV_UFROMEM_SIZE_HEIGHT                                31:16 /* -W-UF */
NV_UFROMEM_SIZE_HEIGHT          TEXTEQU         <31:16>
;  -W-4R 
;  3757 : #define NV_UFROMEM_PITCH                                 0x00530310 /* -W-4R */
NV_UFROMEM_PITCH                EQU             000530310h
;  -W-SF 
;  3758 : #define NV_UFROMEM_PITCH_VALUE                                 31:0 /* -W-SF */
NV_UFROMEM_PITCH_VALUE          TEXTEQU         <31:0>
;  -W-4R 
;  3759 : #define NV_UFROMEM_IMAGE_START                           0x00530314 /* -W-4R */
NV_UFROMEM_IMAGE_START          EQU             000530314h
;  -W-UF 
;  3760 : #define NV_UFROMEM_PITCH_START_OFFSET                          31:0 /* -W-UF */
NV_UFROMEM_PITCH_START_OFFSET           TEXTEQU         <31:0>
;  usr_image_to_mem.ref 
;  -W--D 
;  3761 : /* usr_image_to_mem.ref */
;  3762 : #define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
NV_UTOMEM               TEXTEQU         <0x00541FFF:0x00540000>
;  -W-4R 
;  3763 : #define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
NV_UTOMEM_CTX_SWITCH            EQU             000540000h
;  -W-UF 
;  3764 : #define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UTOMEM_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3765 : #define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UTOMEM_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3766 : #define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UTOMEM_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3767 : #define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3768 : #define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3769 : #define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
NV_UTOMEM_SET_NOTIFY            EQU             000540104h
;  -W-VF 
;  3770 : #define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UTOMEM_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3771 : #define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3772 : #define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
NV_UTOMEM_POINT         EQU             000540308h
;  -W-SF 
;  3773 : #define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
NV_UTOMEM_POINT_X               TEXTEQU         <15:0>
;  -W-SF 
;  3774 : #define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
NV_UTOMEM_POINT_Y               TEXTEQU         <31:16>
;  -W-4R 
;  3775 : #define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
NV_UTOMEM_SIZE          EQU             00054030ch
;  -W-UF 
;  3776 : #define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
NV_UTOMEM_SIZE_WIDTH            TEXTEQU         <15:0>
;  -W-UF 
;  3777 : #define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
NV_UTOMEM_SIZE_HEIGHT           TEXTEQU         <31:16>
;  -W-4R 
;  3778 : #define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
NV_UTOMEM_IMAGE_PITCH           EQU             000540310h
;  -W-SF 
;  3779 : #define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
NV_UTOMEM_IMAGE_PITCH_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3780 : #define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
NV_UTOMEM_IMAGE_START           EQU             000540314h
;  -W-UF 
;  3781 : #define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
NV_UTOMEM_IMAGE_START_OFFSET            TEXTEQU         <31:0>
;  usr_scaled_image_from_mem.ref 
;  -W--D 
;  3782 : /* usr_scaled_image_from_mem.ref */
;  3783 : #define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
NV_USCALED              TEXTEQU         <0x004E1FFF:0x004E0000>
;  -W-4R 
;  3784 : #define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
NV_USCALED_CTX_SWITCH           EQU             0004e0000h
;  -W-UF 
;  3785 : #define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_USCALED_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3786 : #define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_USCALED_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3787 : #define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_USCALED_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3788 : #define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3789 : #define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_USCALED_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3790 : #define NV_USCALED_SET_NOTIFY                            0x004E0104 /* -W-4R */
NV_USCALED_SET_NOTIFY           EQU             0004e0104h
;  -W-VF 
;  3791 : #define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_USCALED_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3792 : #define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_USCALED_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3793 : #define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
NV_USCALED_CLIP_0               EQU             0004e0308h
;  -W-SF 
;  3794 : #define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
NV_USCALED_CLIP_0_X             TEXTEQU         <15:0>
;  -W-SF 
;  3795 : #define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
NV_USCALED_CLIP_0_Y             TEXTEQU         <31:16>
;  -W-4R 
;  3796 : #define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
NV_USCALED_CLIP_1               EQU             0004e030ch
;  -W-UF 
;  3797 : #define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
NV_USCALED_CLIP_1_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3798 : #define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
NV_USCALED_CLIP_1_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3799 : #define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
NV_USCALED_RECTANGLE_OUT_0              EQU             0004e0310h
;  -W-SF 
;  3800 : #define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
NV_USCALED_RECTANGLE_OUT_0_X            TEXTEQU         <15:0>
;  -W-SF 
;  3801 : #define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
NV_USCALED_RECTANGLE_OUT_0_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3802 : #define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
NV_USCALED_RECTANGLE_OUT_1              EQU             0004e0314h
;  -W-UF 
;  3803 : #define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
NV_USCALED_RECTANGLE_OUT_1_WIDTH                TEXTEQU         <15:0>
;  -W-UF 
;  3804 : #define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
NV_USCALED_RECTANGLE_OUT_1_HEIGHT               TEXTEQU         <31:16>
;  -W-4R 
;  3805 : #define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
NV_USCALED_DELTA_DU_DX          EQU             0004e0318h
;  -W-SF 
;  3806 : #define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
NV_USCALED_DELTA_DU_DX_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3807 : #define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
NV_USCALED_DELTA_DU_DX_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3808 : #define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
NV_USCALED_DELTA_DU_DX_R                TEXTEQU         <31:0>
;  -W-4R 
;  3809 : #define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
NV_USCALED_DELTA_DV_DY          EQU             0004e031ch
;  -W-SF 
;  3810 : #define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
NV_USCALED_DELTA_DV_DY_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3811 : #define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
NV_USCALED_DELTA_DV_DY_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3812 : #define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
NV_USCALED_DELTA_DV_DY_R                TEXTEQU         <31:0>
;  -W-4R 
;  3813 : #define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
NV_USCALED_SIZE         EQU             0004e0400h
;  -W-UF 
;  3814 : #define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
NV_USCALED_SIZE_WIDTH           TEXTEQU         <15:0>
;  -W-UF 
;  3815 : #define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
NV_USCALED_SIZE_HEIGHT          TEXTEQU         <31:16>
;  -W-4R 
;  3816 : #define NV_USCALED_PITCH                                 0x004E0404 /* -W-4R */
NV_USCALED_PITCH                EQU             0004e0404h
;  -W-SF 
;  3817 : #define NV_USCALED_PITCH_VALUE                                 31:0 /* -W-SF */
NV_USCALED_PITCH_VALUE          TEXTEQU         <31:0>
;  -W-4R 
;  3818 : #define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
NV_USCALED_OFFSET               EQU             0004e0408h
;  -W-UF 
;  3819 : #define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
NV_USCALED_OFFSET_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3820 : #define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
NV_USCALED_POINT                EQU             0004e040ch
;  -W-UF 
;  3821 : #define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
NV_USCALED_POINT_V_FRACTION             TEXTEQU         <11:0>
;  -W-UF 
;  3822 : #define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
NV_USCALED_POINT_V_INT          TEXTEQU         <15:12>
;  -W-UF 
;  3823 : #define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
NV_USCALED_POINT_V_VALUE                TEXTEQU         <15:0>
;  -W-UF 
;  3824 : #define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
NV_USCALED_POINT_U_FRACTION             TEXTEQU         <19:16>
;  -W-UF 
;  3825 : #define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
NV_USCALED_POINT_U_INT          TEXTEQU         <31:20>
;  -W-UF 
;  3826 : #define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
NV_USCALED_POINT_U_VALUE                TEXTEQU         <31:0>
;  -W-4R 
;  3827 : #define NV_USCALED_SIZE_Y                                0x004E0500 /* -W-4R */
NV_USCALED_SIZE_Y               EQU             0004e0500h
;  -W-UF 
;  3828 : #define NV_USCALED_SIZE_Y_WIDTH                                15:0 /* -W-UF */
NV_USCALED_SIZE_Y_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3829 : #define NV_USCALED_SIZE_Y_HEIGHT                              31:16 /* -W-UF */
NV_USCALED_SIZE_Y_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3830 : #define NV_USCALED_PITCH_420                             0x004E0504 /* -W-4R */
NV_USCALED_PITCH_420            EQU             0004e0504h
;  -W-UF 
;  3831 : #define NV_USCALED_PITCH_420_Y                                 15:0 /* -W-UF */
NV_USCALED_PITCH_420_Y          TEXTEQU         <15:0>
;  -W-UF 
;  3832 : #define NV_USCALED_PITCH_420_UV                               31:16 /* -W-UF */
NV_USCALED_PITCH_420_UV         TEXTEQU         <31:16>
;  -W-4R 
;  3833 : #define NV_USCALED_OFFSET_Y                              0x004E0508 /* -W-4R */
NV_USCALED_OFFSET_Y             EQU             0004e0508h
;  -W-UF 
;  3834 : #define NV_USCALED_OFFSET_Y_VALUE                             31:0  /* -W-UF */
NV_USCALED_OFFSET_Y_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3835 : #define NV_USCALED_OFFSET_U                              0x004E050C /* -W-4R */
NV_USCALED_OFFSET_U             EQU             0004e050ch
;  -W-UF 
;  3836 : #define NV_USCALED_OFFSET_U_VALUE                             31:0  /* -W-UF */
NV_USCALED_OFFSET_U_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3837 : #define NV_USCALED_OFFSET_V                              0x004E0510 /* -W-4R */
NV_USCALED_OFFSET_V             EQU             0004e0510h
;  -W-UF 
;  3838 : #define NV_USCALED_OFFSET_V_VALUE                             31:0  /* -W-UF */
NV_USCALED_OFFSET_V_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3839 : #define NV_USCALED_POINT_Y                               0x004E0514 /* -W-4R */
NV_USCALED_POINT_Y              EQU             0004e0514h
;  -W-UF 
;  3840 : #define NV_USCALED_POINT_Y_V_FRACTION                          11:0 /* -W-UF */
NV_USCALED_POINT_Y_V_FRACTION           TEXTEQU         <11:0>
;  -W-UF 
;  3841 : #define NV_USCALED_POINT_Y_V_INT                              15:12 /* -W-UF */
NV_USCALED_POINT_Y_V_INT                TEXTEQU         <15:12>
;  -W-UF 
;  3842 : #define NV_USCALED_POINT_Y_V_VALUE                             15:0 /* -W-UF */
NV_USCALED_POINT_Y_V_VALUE              TEXTEQU         <15:0>
;  -W-UF 
;  3843 : #define NV_USCALED_POINT_Y_U_FRACTION                         19:16 /* -W-UF */
NV_USCALED_POINT_Y_U_FRACTION           TEXTEQU         <19:16>
;  -W-UF 
;  3844 : #define NV_USCALED_POINT_Y_U_INT                              31:20 /* -W-UF */
NV_USCALED_POINT_Y_U_INT                TEXTEQU         <31:20>
;  -W-UF 
;  3845 : #define NV_USCALED_POINT_Y_U_VALUE                            31:16 /* -W-UF */
NV_USCALED_POINT_Y_U_VALUE              TEXTEQU         <31:16>
;  usr_stretch_from_cpu.ref 
;  -W--D 
;  3846 : /* usr_stretch_from_cpu.ref */
;  3847 : #define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
NV_USTRTCH              TEXTEQU         <0x00551FFF:0x00550000>
;  -W-4R 
;  3848 : #define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
NV_USTRTCH_CTX_SWITCH           EQU             000550000h
;  -W-UF 
;  3849 : #define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_USTRTCH_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3850 : #define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_USTRTCH_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3851 : #define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_USTRTCH_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3852 : #define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3853 : #define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3854 : #define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
NV_USTRTCH_SET_NOTIFY           EQU             000550104h
;  -W-VF 
;  3855 : #define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_USTRTCH_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3856 : #define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3857 : #define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
NV_USTRTCH_SIZE_IN              EQU             000550304h
;  -W-UF 
;  3858 : #define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
NV_USTRTCH_SIZE_IN_WIDTH                TEXTEQU         <15:0>
;  -W-UF 
;  3859 : #define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
NV_USTRTCH_SIZE_IN_HEIGHT               TEXTEQU         <31:16>
;  -W-4R 
;  3860 : #define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
NV_USTRTCH_DELTA_DX_DU          EQU             000550308h
;  -W-UF 
;  3861 : #define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
NV_USTRTCH_DELTA_DX_DU_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3862 : #define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
NV_USTRTCH_DELTA_DX_DU_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3863 : #define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
NV_USTRTCH_DELTA_DX_DU_R                TEXTEQU         <31:0>
;  -W-4R 
;  3864 : #define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
NV_USTRTCH_DELTA_DY_DV          EQU             00055030ch
;  -W-UF 
;  3865 : #define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
NV_USTRTCH_DELTA_DY_DV_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3866 : #define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
NV_USTRTCH_DELTA_DY_DV_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3867 : #define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
NV_USTRTCH_DELTA_DY_DV_R                TEXTEQU         <31:0>
;  -W-4R 
;  3868 : #define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
NV_USTRTCH_CLIP_0               EQU             000550310h
;  -W-SF 
;  3869 : #define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
NV_USTRTCH_CLIP_0_X             TEXTEQU         <15:0>
;  -W-SF 
;  3870 : #define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
NV_USTRTCH_CLIP_0_Y             TEXTEQU         <31:16>
;  -W-4R 
;  3871 : #define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
NV_USTRTCH_CLIP_1               EQU             000550314h
;  -W-UF 
;  3872 : #define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
NV_USTRTCH_CLIP_1_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3873 : #define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
NV_USTRTCH_CLIP_1_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3874 : #define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
NV_USTRTCH_POINT12D4            EQU             000550318h
;  -W-SF 
;  3875 : #define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
NV_USTRTCH_POINT12D4_X_FRACTION         TEXTEQU         <3:0>
;  -W-SF 
;  3876 : #define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
NV_USTRTCH_POINT12D4_X_INT              TEXTEQU         <15:4>
;  -W-SF 
;  3877 : #define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
NV_USTRTCH_POINT12D4_X          TEXTEQU         <15:0>
;  -W-SF 
;  3878 : #define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
NV_USTRTCH_POINT12D4_Y_FRACTION         TEXTEQU         <19:16>
;  -W-SF 
;  3879 : #define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
NV_USTRTCH_POINT12D4_Y_INT              TEXTEQU         <31:20>
;  -W-SF 
;  3880 : #define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
NV_USTRTCH_POINT12D4_Y          TEXTEQU         <31:16>
;  -W-4A 
;        
;  3881 : #define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
;  3882 : #define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
NV_USTRTCH_COLOR__SIZE_1                EQU             1792t
;  -W-VF 
;  3883 : #define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
NV_USTRTCH_COLOR_VALUE          TEXTEQU         <31:0>
;  usr_win95_text.ref 
;  -W--D 
;  3884 : /* usr_win95_text.ref */
;  3885 : #define NV_UW95TXT                            0x004C1FFF:0x004C0000 /* -W--D */
NV_UW95TXT              TEXTEQU         <0x004C1FFF:0x004C0000>
;  -W-4R 
;  3886 : #define NV_UW95TXT_CTX_SWITCH                            0x004C0000 /* -W-4R */
NV_UW95TXT_CTX_SWITCH           EQU             0004c0000h
;  -W-UF 
;  3887 : #define NV_UW95TXT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UW95TXT_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3888 : #define NV_UW95TXT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UW95TXT_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3889 : #define NV_UW95TXT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UW95TXT_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3890 : #define NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3891 : #define NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3892 : #define NV_UW95TXT_SET_NOTIFY                            0x004C0104 /* -W-4R */
NV_UW95TXT_SET_NOTIFY           EQU             0004c0104h
;  -W-VF 
;  3893 : #define NV_UW95TXT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UW95TXT_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3894 : #define NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3895 : #define NV_UW95TXT_COLOR_A                               0x004C03FC /* -W-4R */
NV_UW95TXT_COLOR_A              EQU             0004c03fch
;  -W-VF 
;  3896 : #define NV_UW95TXT_COLOR_A_VALUE                               31:0 /* -W-VF */
NV_UW95TXT_COLOR_A_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3897 : #define NV_UW95TXT_RECT_NCLIP_0(i)               (0x004C0400+(i)*8) /* -W-4A */
;  3898 : #define NV_UW95TXT_RECT_NCLIP_0__SIZE_1                          64 /*       */
NV_UW95TXT_RECT_NCLIP_0__SIZE_1         EQU             64t
;  -W-SF 
;  3899 : #define NV_UW95TXT_RECT_NCLIP_0_Y                              15:0 /* -W-SF */
NV_UW95TXT_RECT_NCLIP_0_Y               TEXTEQU         <15:0>
;  -W-SF 
;  3900 : #define NV_UW95TXT_RECT_NCLIP_0_X                             31:16 /* -W-SF */
NV_UW95TXT_RECT_NCLIP_0_X               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3901 : #define NV_UW95TXT_RECT_NCLIP_1(i)               (0x004C0404+(i)*8) /* -W-4A */
;  3902 : #define NV_UW95TXT_RECT_NCLIP_1__SIZE_1                          64 /*       */
NV_UW95TXT_RECT_NCLIP_1__SIZE_1         EQU             64t
;  -W-UF 
;  3903 : #define NV_UW95TXT_RECT_NCLIP_1_HEIGHT                         15:0 /* -W-UF */
NV_UW95TXT_RECT_NCLIP_1_HEIGHT          TEXTEQU         <15:0>
;  -W-UF 
;  3904 : #define NV_UW95TXT_RECT_NCLIP_1_WIDTH                         31:16 /* -W-UF */
NV_UW95TXT_RECT_NCLIP_1_WIDTH           TEXTEQU         <31:16>
;  -W-4R 
;  3905 : #define NV_UW95TXT_CLIP_B_0                              0x004C07F4 /* -W-4R */
NV_UW95TXT_CLIP_B_0             EQU             0004c07f4h
;  -W-SF 
;  3906 : #define NV_UW95TXT_CLIP_B_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_B_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3907 : #define NV_UW95TXT_CLIP_B_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_B_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3908 : #define NV_UW95TXT_CLIP_B_1                              0x004C07F8 /* -W-4R */
NV_UW95TXT_CLIP_B_1             EQU             0004c07f8h
;  -W-SF 
;  3909 : #define NV_UW95TXT_CLIP_B_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_B_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3910 : #define NV_UW95TXT_CLIP_B_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_B_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3911 : #define NV_UW95TXT_COLOR_B                               0x004C07FC /* -W-4R */
NV_UW95TXT_COLOR_B              EQU             0004c07fch
;  -W-VF 
;  3912 : #define NV_UW95TXT_COLOR_B_VALUE                               31:0 /* -W-VF */
NV_UW95TXT_COLOR_B_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3913 : #define NV_UW95TXT_RECT_CLIP_0(i)                (0x004C0800+(i)*8) /* -W-4A */
;  3914 : #define NV_UW95TXT_RECT_CLIP_0__SIZE_1                           64 /*       */
NV_UW95TXT_RECT_CLIP_0__SIZE_1          EQU             64t
;  -W-SF 
;  3915 : #define NV_UW95TXT_RECT_CLIP_0_LEFT                            15:0 /* -W-SF */
NV_UW95TXT_RECT_CLIP_0_LEFT             TEXTEQU         <15:0>
;  -W-SF 
;  3916 : #define NV_UW95TXT_RECT_CLIP_0_TOP                            31:16 /* -W-SF */
NV_UW95TXT_RECT_CLIP_0_TOP              TEXTEQU         <31:16>
;  -W-4A 
;        
;  3917 : #define NV_UW95TXT_RECT_CLIP_1(i)                (0x004C0804+(i)*8) /* -W-4A */
;  3918 : #define NV_UW95TXT_RECT_CLIP_1__SIZE_1                           64 /*       */
NV_UW95TXT_RECT_CLIP_1__SIZE_1          EQU             64t
;  -W-SF 
;  3919 : #define NV_UW95TXT_RECT_CLIP_1_RIGHT                           15:0 /* -W-SF */
NV_UW95TXT_RECT_CLIP_1_RIGHT            TEXTEQU         <15:0>
;  -W-SF 
;  3920 : #define NV_UW95TXT_RECT_CLIP_1_BOTTOM                         31:16 /* -W-SF */
NV_UW95TXT_RECT_CLIP_1_BOTTOM           TEXTEQU         <31:16>
;  -W-4R 
;  3921 : #define NV_UW95TXT_CLIP_C_0                              0x004C0BEC /* -W-4R */
NV_UW95TXT_CLIP_C_0             EQU             0004c0bech
;  -W-SF 
;  3922 : #define NV_UW95TXT_CLIP_C_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_C_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3923 : #define NV_UW95TXT_CLIP_C_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_C_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3924 : #define NV_UW95TXT_CLIP_C_1                              0x004C0BF0 /* -W-4R */
NV_UW95TXT_CLIP_C_1             EQU             0004c0bf0h
;  -W-SF 
;  3925 : #define NV_UW95TXT_CLIP_C_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_C_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3926 : #define NV_UW95TXT_CLIP_C_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_C_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3927 : #define NV_UW95TXT_COLOR1_C                              0x004C0BF4 /* -W-4R */
NV_UW95TXT_COLOR1_C             EQU             0004c0bf4h
;  -W-VF 
;  3928 : #define NV_UW95TXT_COLOR1_C_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR1_C_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3929 : #define NV_UW95TXT_SIZE_C                                0x004C0BF8 /* -W-4R */
NV_UW95TXT_SIZE_C               EQU             0004c0bf8h
;  -W-UF 
;  3930 : #define NV_UW95TXT_SIZE_C_WIDTH                                15:0 /* -W-UF */
NV_UW95TXT_SIZE_C_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3931 : #define NV_UW95TXT_SIZE_C_HEIGHT                              31:16 /* -W-UF */
NV_UW95TXT_SIZE_C_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3932 : #define NV_UW95TXT_POINT_C                               0x004C0BFC /* -W-4R */
NV_UW95TXT_POINT_C              EQU             0004c0bfch
;  -W-SF 
;  3933 : #define NV_UW95TXT_POINT_C_X                                   15:0 /* -W-SF */
NV_UW95TXT_POINT_C_X            TEXTEQU         <15:0>
;  -W-SF 
;  3934 : #define NV_UW95TXT_POINT_C_Y                                  31:16 /* -W-SF */
NV_UW95TXT_POINT_C_Y            TEXTEQU         <31:16>
;  -W-4A 
;        
;  3935 : #define NV_UW95TXT_MONO_COLOR1_C(i)              (0x004C0C00+(i)*4) /* -W-4A */
;  3936 : #define NV_UW95TXT_MONO_COLOR1_C__SIZE_1                        128 /*       */
NV_UW95TXT_MONO_COLOR1_C__SIZE_1                EQU             128t
;  -W-VF 
;  3937 : #define NV_UW95TXT_MONO_COLOR1_C_BITMAP                        31:0 /* -W-VF */
NV_UW95TXT_MONO_COLOR1_C_BITMAP         TEXTEQU         <31:0>
;  -W-4R 
;  3938 : #define NV_UW95TXT_CLIP_D_0                              0x004C0FE8 /* -W-4R */
NV_UW95TXT_CLIP_D_0             EQU             0004c0fe8h
;  -W-SF 
;  3939 : #define NV_UW95TXT_CLIP_D_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_D_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3940 : #define NV_UW95TXT_CLIP_D_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_D_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3941 : #define NV_UW95TXT_CLIP_D_1                              0x004C0FEC /* -W-4R */
NV_UW95TXT_CLIP_D_1             EQU             0004c0fech
;  -W-SF 
;  3942 : #define NV_UW95TXT_CLIP_D_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_D_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3943 : #define NV_UW95TXT_CLIP_D_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_D_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3944 : #define NV_UW95TXT_COLOR1_D                              0x004C0FF0 /* -W-4R */
NV_UW95TXT_COLOR1_D             EQU             0004c0ff0h
;  -W-VF 
;  3945 : #define NV_UW95TXT_COLOR1_D_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR1_D_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3946 : #define NV_UW95TXT_SIZE_IN_D                             0x004C0FF4 /* -W-4R */
NV_UW95TXT_SIZE_IN_D            EQU             0004c0ff4h
;  -W-UF 
;  3947 : #define NV_UW95TXT_SIZE_IN_D_WIDTH                             15:0 /* -W-UF */
NV_UW95TXT_SIZE_IN_D_WIDTH              TEXTEQU         <15:0>
;  -W-UF 
;  3948 : #define NV_UW95TXT_SIZE_IN_D_HEIGHT                           31:16 /* -W-UF */
NV_UW95TXT_SIZE_IN_D_HEIGHT             TEXTEQU         <31:16>
;  -W-4R 
;  3949 : #define NV_UW95TXT_SIZE_OUT_D                            0x004C0FF8 /* -W-4R */
NV_UW95TXT_SIZE_OUT_D           EQU             0004c0ff8h
;  -W-UF 
;  3950 : #define NV_UW95TXT_SIZE_OUT_D_WIDTH                            15:0 /* -W-UF */
NV_UW95TXT_SIZE_OUT_D_WIDTH             TEXTEQU         <15:0>
;  -W-UF 
;  3951 : #define NV_UW95TXT_SIZE_OUT_D_HEIGHT                          31:16 /* -W-UF */
NV_UW95TXT_SIZE_OUT_D_HEIGHT            TEXTEQU         <31:16>
;  -W-4R 
;  3952 : #define NV_UW95TXT_POINT_D                               0x004C0FFC /* -W-4R */
NV_UW95TXT_POINT_D              EQU             0004c0ffch
;  -W-SF 
;  3953 : #define NV_UW95TXT_POINT_D_X                                   15:0 /* -W-SF */
NV_UW95TXT_POINT_D_X            TEXTEQU         <15:0>
;  -W-SF 
;  3954 : #define NV_UW95TXT_POINT_D_Y                                  31:16 /* -W-SF */
NV_UW95TXT_POINT_D_Y            TEXTEQU         <31:16>
;  -W-4A 
;        
;  3955 : #define NV_UW95TXT_MONO_COLOR1_D(i)              (0x004C1000+(i)*4) /* -W-4A */
;  3956 : #define NV_UW95TXT_MONO_COLOR1_D__SIZE_1                        128 /*       */
NV_UW95TXT_MONO_COLOR1_D__SIZE_1                EQU             128t
;  -W-VF 
;  3957 : #define NV_UW95TXT_MONO_COLOR1_D_BITMAP                        31:0 /* -W-VF */
NV_UW95TXT_MONO_COLOR1_D_BITMAP         TEXTEQU         <31:0>
;  -W-4R 
;  3958 : #define NV_UW95TXT_CLIP_E_0                              0x004C13E4 /* -W-4R */
NV_UW95TXT_CLIP_E_0             EQU             0004c13e4h
;  -W-SF 
;  3959 : #define NV_UW95TXT_CLIP_E_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_E_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3960 : #define NV_UW95TXT_CLIP_E_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_E_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3961 : #define NV_UW95TXT_CLIP_E_1                              0x004C13E8 /* -W-4R */
NV_UW95TXT_CLIP_E_1             EQU             0004c13e8h
;  -W-SF 
;  3962 : #define NV_UW95TXT_CLIP_E_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_E_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3963 : #define NV_UW95TXT_CLIP_E_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_E_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3964 : #define NV_UW95TXT_COLOR0_E                              0x004C13EC /* -W-4R */
NV_UW95TXT_COLOR0_E             EQU             0004c13ech
;  -W-VF 
;  3965 : #define NV_UW95TXT_COLOR0_E_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR0_E_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3966 : #define NV_UW95TXT_COLOR1_E                              0x004C13F0 /* -W-4R */
NV_UW95TXT_COLOR1_E             EQU             0004c13f0h
;  -W-VF 
;  3967 : #define NV_UW95TXT_COLOR1_E_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR1_E_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3968 : #define NV_UW95TXT_SIZE_IN_E                             0x004C13F4 /* -W-4R */
NV_UW95TXT_SIZE_IN_E            EQU             0004c13f4h
;  -W-UF 
;  3969 : #define NV_UW95TXT_SIZE_IN_E_WIDTH                             15:0 /* -W-UF */
NV_UW95TXT_SIZE_IN_E_WIDTH              TEXTEQU         <15:0>
;  -W-UF 
;  3970 : #define NV_UW95TXT_SIZE_IN_E_HEIGHT                           31:16 /* -W-UF */
NV_UW95TXT_SIZE_IN_E_HEIGHT             TEXTEQU         <31:16>
;  -W-4R 
;  3971 : #define NV_UW95TXT_SIZE_OUT_E                            0x004C13F8 /* -W-4R */
NV_UW95TXT_SIZE_OUT_E           EQU             0004c13f8h
;  -W-UF 
;  3972 : #define NV_UW95TXT_SIZE_OUT_E_WIDTH                            15:0 /* -W-UF */
NV_UW95TXT_SIZE_OUT_E_WIDTH             TEXTEQU         <15:0>
;  -W-UF 
;  3973 : #define NV_UW95TXT_SIZE_OUT_E_HEIGHT                          31:16 /* -W-UF */
NV_UW95TXT_SIZE_OUT_E_HEIGHT            TEXTEQU         <31:16>
;  -W-4R 
;  3974 : #define NV_UW95TXT_POINT_E                               0x004C13FC /* -W-4R */
NV_UW95TXT_POINT_E              EQU             0004c13fch
;  -W-SF 
;  3975 : #define NV_UW95TXT_POINT_E_X                                   15:0 /* -W-SF */
NV_UW95TXT_POINT_E_X            TEXTEQU         <15:0>
;  -W-SF 
;  3976 : #define NV_UW95TXT_POINT_E_Y                                  31:16 /* -W-SF */
NV_UW95TXT_POINT_E_Y            TEXTEQU         <31:16>
;  -W-4A 
;        
;  3977 : #define NV_UW95TXT_MONO_COLOR01_E(i)             (0x004C1400+(i)*4) /* -W-4A */
;  3978 : #define NV_UW95TXT_MONO_COLOR01_E__SIZE_1                       128 /*       */
NV_UW95TXT_MONO_COLOR01_E__SIZE_1               EQU             128t
;  -W-VF 
;  3979 : #define NV_UW95TXT_MONO_COLOR01_E_BITMAP                       31:0 /* -W-VF */
NV_UW95TXT_MONO_COLOR01_E_BITMAP                TEXTEQU         <31:0>
;  usr_image_in_mem.ref 
;  -W--D 
;  3980 : /* usr_image_in_mem.ref */
;  3981 : #define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
NV_UINMEM               TEXTEQU         <0x005C1FFF:0x005C0000>
;  -W-4R 
;  3982 : #define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
NV_UINMEM_CTX_SWITCH            EQU             0005c0000h
;  -W-UF 
;  3983 : #define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UINMEM_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3984 : #define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UINMEM_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3985 : #define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UINMEM_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3986 : #define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3987 : #define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UINMEM_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3988 : #define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
NV_UINMEM_SET_NOTIFY            EQU             0005c0104h
;  -W-VF 
;  3989 : #define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UINMEM_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3990 : #define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3991 : #define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
NV_UINMEM_PITCH         EQU             0005c0308h
;  -WXUF 
;  3992 : #define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
NV_UINMEM_PITCH_VALUE           TEXTEQU         <15:0>
;  -W-4R 
;  3993 : #define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
NV_UINMEM_OFFSET                EQU             0005c030ch
;  -WIUF 
;  3994 : #define NV_UINMEM_OFFSET_LINADRS                               22:4 /* -WIUF */
NV_UINMEM_OFFSET_LINADRS                TEXTEQU         <22:4>
;  -WI-V 
;  3995 : #define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
NV_UINMEM_OFFSET_LINADRS_0              EQU             000000000h
;  -W-4R 
;  3996 : #define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
NV_UINMEM_FORMAT                EQU             0005c0300h
;  -WXUF 
;  3997 : #define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
NV_UINMEM_FORMAT_VALUE          TEXTEQU         <31:0>
;  -W--V 
;  3998 : #define NV_UINMEM_FORMAT_VALUE_LE_Y8_P4                  0x01010000 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_Y8_P4         EQU             001010000h
;  -W--V 
;  3999 : #define NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                 0x01010001 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                EQU             001010001h
;  -W--V 
;  4000 : #define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2            0x01000000 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2           EQU             001000000h
;  -W--V 
;  4001 : #define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8               0x00000001 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8              EQU             000000001h
;  dev_framebuffer.ref 
;  RW--D 
;  4002 : /* dev_framebuffer.ref */
;  4003 : #define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
NV_PFB          TEXTEQU         <0x00100FFF:0x00100000>
;  RW-4R 
;  4004 : #define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
NV_PFB_BOOT_0           EQU             000100000h
;  RWIVF 
;  4005 : #define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
NV_PFB_BOOT_0_RAM_AMOUNT                TEXTEQU         <1:0>
;  RW--V 
;  4006 : #define NV_PFB_BOOT_0_RAM_AMOUNT_1MB                     0x00000000 /* RW--V */
NV_PFB_BOOT_0_RAM_AMOUNT_1MB            EQU             000000000h
;  RW--V 
;  4007 : #define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
NV_PFB_BOOT_0_RAM_AMOUNT_2MB            EQU             000000001h
;  RW--V 
;  4008 : #define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RW--V */
NV_PFB_BOOT_0_RAM_AMOUNT_4MB            EQU             000000002h
;  RWI-V 
;  4009 : #define NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                 0x00000002 /* RWI-V */
NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                EQU             000000002h
;  RW-VF 
;  4010 : #define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
NV_PFB_BOOT_0_RAM_WIDTH_128             TEXTEQU         <2:2>
;  RW--V 
;  4011 : #define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
NV_PFB_BOOT_0_RAM_WIDTH_128_OFF         EQU             000000000h
;  RW--V 
;  4012 : #define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
NV_PFB_BOOT_0_RAM_WIDTH_128_ON          EQU             000000001h
;  RW-4R 
;  4013 : #define NV_PFB_DELAY_1                                   0x00100044 /* RW-4R */
NV_PFB_DELAY_1          EQU             000100044h
;  RWIUF 
;  4014 : #define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
NV_PFB_DELAY_1_WRITE_ENABLE_RISE                TEXTEQU         <1:0>
;  RWI-V 
;  4015 : #define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0              EQU             000000000h
;  RWIUF 
;  4016 : #define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
NV_PFB_DELAY_1_WRITE_ENABLE_FALL                TEXTEQU         <5:4>
;  RWI-V 
;  4017 : #define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0              EQU             000000000h
;  RWIUF 
;  4018 : #define NV_PFB_DELAY_1_CAS_ENABLE_RISE                          9:8 /* RWIUF */
NV_PFB_DELAY_1_CAS_ENABLE_RISE          TEXTEQU         <9:8>
;  RWI-V 
;  4019 : #define NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                 0x00000000 /* RWI-V */
NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                EQU             000000000h
;  RWIUF 
;  4020 : #define NV_PFB_DELAY_1_CAS_ENABLE_FALL                        13:12 /* RWIUF */
NV_PFB_DELAY_1_CAS_ENABLE_FALL          TEXTEQU         <13:12>
;  RWI-V 
;  4021 : #define NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                 0x00000000 /* RWI-V */
NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                EQU             000000000h
;  RWIUF 
;  4022 : #define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
NV_PFB_DELAY_1_OUTPUT_DATA              TEXTEQU         <17:16>
;  RWI-V 
;  4023 : #define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
NV_PFB_DELAY_1_OUTPUT_DATA_0            EQU             000000000h
;  RWIUF 
;  4024 : #define NV_PFB_DELAY_1_RAS_ENABLE                             21:20 /* RWIUF */
NV_PFB_DELAY_1_RAS_ENABLE               TEXTEQU         <21:20>
;  RWI-V 
;  4025 : #define NV_PFB_DELAY_1_RAS_ENABLE_0                      0x00000000 /* RWI-V */
NV_PFB_DELAY_1_RAS_ENABLE_0             EQU             000000000h
;  RW-4R 
;  4026 : #define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
NV_PFB_DEBUG_0          EQU             000100080h
;  RWIVF 
;  4027 : #define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
NV_PFB_DEBUG_0_PAGE_MODE                TEXTEQU         <0:0>
;  RWI-V 
;  4028 : #define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                EQU             000000000h
;  RW--V 
;  4029 : #define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
NV_PFB_DEBUG_0_PAGE_MODE_DISABLED               EQU             000000001h
;  RWIVF 
;  4030 : #define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
NV_PFB_DEBUG_0_REFRESH          TEXTEQU         <4:4>
;  RWI-V 
;  4031 : #define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
NV_PFB_DEBUG_0_REFRESH_ENABLED          EQU             000000000h
;  RW--V 
;  4032 : #define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
NV_PFB_DEBUG_0_REFRESH_DISABLED         EQU             000000001h
;  RWIVF 
;  4033 : #define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        12:8 /* RWIVF */
NV_PFB_DEBUG_0_REFRESH_COUNTX64         TEXTEQU         <12:8>
;  RWI-V 
;  4034 : #define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT         EQU             000000010h
;  RWIVF 
;  4035 : #define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
NV_PFB_DEBUG_0_CASOE            TEXTEQU         <20:20>
;  RWI-V 
;  4036 : #define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
NV_PFB_DEBUG_0_CASOE_ENABLED            EQU             000000000h
;  RW--V 
;  4037 : #define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
NV_PFB_DEBUG_0_CASOE_DISABLED           EQU             000000001h
;  RWIVF 
;  4038 : #define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
NV_PFB_DEBUG_0_CKE_INVERT               TEXTEQU         <28:28>
;  RWIVF 
;  4039 : #define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWIVF */
NV_PFB_DEBUG_0_CKE_INVERT_OFF           EQU             000000000h
;  RW-VF 
;  4040 : #define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW-VF */
NV_PFB_DEBUG_0_CKE_INVERT_ON            EQU             000000001h
;  RWIVF 
;  4041 : #define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
NV_PFB_DEBUG_0_CKE_ALWAYSON             TEXTEQU         <29:29>
;  RW-VF 
;  4042 : #define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW-VF */
NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF         EQU             000000000h
;  RWIVF 
;  4043 : #define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWIVF */
NV_PFB_DEBUG_0_CKE_ALWAYSON_ON          EQU             000000001h
;  RWIVF 
;  4044 : #define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
NV_PFB_DEBUG_0_SAVE_POWER               TEXTEQU         <30:30>
;  RWIVF 
;  4045 : #define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWIVF */
NV_PFB_DEBUG_0_SAVE_POWER_ON            EQU             000000000h
;  RW-VF 
;  4046 : #define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW-VF */
NV_PFB_DEBUG_0_SAVE_POWER_OFF           EQU             000000001h
;  RW-4R 
;  4047 : #define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
NV_PFB_GREEN_0          EQU             0001000c0h
;  RWIVF 
;  4048 : #define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
NV_PFB_GREEN_0_LEVEL            TEXTEQU         <1:0>
;  RW--V 
;  4049 : #define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED              EQU             000000000h
;  RW--V 
;  4050 : #define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED             EQU             000000001h
;  RW--V 
;  4051 : #define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED            EQU             000000002h
;  RWI-V 
;  4052 : #define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED            EQU             000000003h
;  RW-4R 
;  4053 : #define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
NV_PFB_CONFIG_0         EQU             000100200h
;  RWIVF 
;  4054 : #define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
NV_PFB_CONFIG_0_RESOLUTION              TEXTEQU         <5:0>
;  RW--V 
;  4055 : #define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS           EQU             00000000ah
;  RW--V 
;  4056 : #define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS           EQU             00000000dh
;  RW--V 
;  4057 : #define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS           EQU             00000000fh
;  RW--V 
;  4058 : #define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS           EQU             000000010h
;  RW--V 
;  4059 : #define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS           EQU             000000014h
;  RW--V 
;  4060 : #define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS           EQU             000000019h
;  RW--V 
;  4061 : #define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS           EQU             00000001eh
;  RW--V 
;  4062 : #define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS          EQU             000000020h
;  RW--V 
;  4063 : #define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS          EQU             000000024h
;  RW--V 
;  4064 : #define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS          EQU             000000028h
;  RW--V 
;  4065 : #define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS          EQU             000000032h
;  RWI-V 
;  4066 : #define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
NV_PFB_CONFIG_0_RESOLUTION_DEFAULT              EQU             000000014h
;  RWIVF 
;  4067 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
NV_PFB_CONFIG_0_PIXEL_DEPTH             TEXTEQU         <9:8>
;  RW--V 
;  4068 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS              EQU             000000001h
;  RW--V 
;  4069 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS             EQU             000000002h
;  RW--V 
;  4070 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS             EQU             000000003h
;  RWI-V 
;  4071 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT             EQU             000000001h
;  RWIVF 
;  4072 : #define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
NV_PFB_CONFIG_0_TILING          TEXTEQU         <12:12>
;  RW--V 
;  4073 : #define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
NV_PFB_CONFIG_0_TILING_ENABLED          EQU             000000000h
;  RWI-V 
;  4074 : #define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
NV_PFB_CONFIG_0_TILING_DISABLED         EQU             000000001h
;  RWIVF 
;  4075 : #define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
NV_PFB_CONFIG_0_TILING_DEBUG            TEXTEQU         <23:13>
;  RW--V 
;  4076 : #define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED           EQU             000000000h
;  RW-4R 
;  4077 : #define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
NV_PFB_CONFIG_1         EQU             000100204h
;  RWIVF 
;  4078 : #define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
NV_PFB_CONFIG_1_CAS_LATENCY             TEXTEQU         <2:0>
;  RWI-V 
;  4079 : #define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
NV_PFB_CONFIG_1_CAS_LATENCY_3           EQU             000000003h
;  RWIVF 
;  4080 : #define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
NV_PFB_CONFIG_1_SGRAM100                TEXTEQU         <3:3>
;  RWI-V 
;  4081 : #define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_SGRAM100_ENABLED                EQU             000000000h
;  RW--V 
;  4082 : #define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
NV_PFB_CONFIG_1_SGRAM100_DISABLED               EQU             000000001h
;  RWIUF 
;  4083 : #define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
NV_PFB_CONFIG_1_RAS_RAS         TEXTEQU         <7:4>
;  RWI-V 
;  4084 : #define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
NV_PFB_CONFIG_1_RAS_RAS_DEFAULT         EQU             000000009h
;  RW--V 
;  4085 : #define NV_PFB_CONFIG_1_RAS_RAS_SG100                    0x00000004 /* RW--V */
NV_PFB_CONFIG_1_RAS_RAS_SG100           EQU             000000004h
;  RWIUF 
;  4086 : #define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
NV_PFB_CONFIG_1_RAS_PCHG                TEXTEQU         <10:8>
;  RWI-V 
;  4087 : #define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                EQU             000000002h
;  RW--V 
;  4088 : #define NV_PFB_CONFIG_1_RAS_PCHG_SG100                   0x00000001 /* RW--V */
NV_PFB_CONFIG_1_RAS_PCHG_SG100          EQU             000000001h
;  RWIUF 
;  4089 : #define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
NV_PFB_CONFIG_1_RAS_LOW         TEXTEQU         <14:12>
;  RWI-V 
;  4090 : #define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
NV_PFB_CONFIG_1_RAS_LOW_DEFAULT         EQU             000000006h
;  RW--V 
;  4091 : #define NV_PFB_CONFIG_1_RAS_LOW_SG100                    0x00000003 /* RW--V */
NV_PFB_CONFIG_1_RAS_LOW_SG100           EQU             000000003h
;  RWIUF 
;  4092 : #define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
NV_PFB_CONFIG_1_MRS_TO_RAS              TEXTEQU         <18:16>
;  RWI-V 
;  4093 : #define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT              EQU             000000001h
;  RW--V 
;  4094 : #define NV_PFB_CONFIG_1_MRS_TO_RAS_SG100                 0x00000000 /* RW--V */
NV_PFB_CONFIG_1_MRS_TO_RAS_SG100                EQU             000000000h
;  RWIUF 
;  4095 : #define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
NV_PFB_CONFIG_1_WRITE_TO_READ           TEXTEQU         <22:20>
;  RWI-V 
;  4096 : #define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT           EQU             000000000h
;  RW--V 
;  4097 : #define NV_PFB_CONFIG_1_WRITE_TO_READ_SG100              0x00000000 /* RW--V */
NV_PFB_CONFIG_1_WRITE_TO_READ_SG100             EQU             000000000h
;  RWIUF 
;  4098 : #define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
NV_PFB_CONFIG_1_RAS_TO_CAS_M1           TEXTEQU         <26:24>
;  RWI-V 
;  4099 : #define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT           EQU             000000001h
;  RWI-V 
;  4100 : #define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_SG100              0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_RAS_TO_CAS_M1_SG100             EQU             000000000h
;  RWIUF 
;  4101 : #define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
NV_PFB_CONFIG_1_READ_TO_WRITE           TEXTEQU         <30:28>
;  RWI-V 
;  4102 : #define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */ 
NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT           EQU             000000004h
;  RWI-V 
;  4103 : #define NV_PFB_CONFIG_1_READ_TO_WRITE_SG100              0x00000002 /* RWI-V */ 
NV_PFB_CONFIG_1_READ_TO_WRITE_SG100             EQU             000000002h
;  RWIUF 
;  4104 : #define NV_PFB_CONFIG_1_ED_RAC1                                 0:0 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC1         TEXTEQU         <0:0>
;  RWI-V 
;  4105 : #define NV_PFB_CONFIG_1_ED_RAC1_DEFAULT                  0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC1_DEFAULT         EQU             000000000h
;  RWIUF 
;  4106 : #define NV_PFB_CONFIG_1_ED_RWT1                                 1:1 /* RWIUF */
NV_PFB_CONFIG_1_ED_RWT1         TEXTEQU         <1:1>
;  RWI-V 
;  4107 : #define NV_PFB_CONFIG_1_ED_RWT1_DEFAULT                  0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RWT1_DEFAULT         EQU             000000001h
;  RWIUF 
;  4108 : #define NV_PFB_CONFIG_1_ED_RPC1                                 2:2 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC1         TEXTEQU         <2:2>
;  RWI-V 
;  4109 : #define NV_PFB_CONFIG_1_ED_RPC1_DEFAULT                  0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC1_DEFAULT         EQU             000000001h
;  RWIUF 
;  4110 : #define NV_PFB_CONFIG_1_ED_PMAW                                 4:4 /* RWIUF */
NV_PFB_CONFIG_1_ED_PMAW         TEXTEQU         <4:4>
;  RWI-V 
;  4111 : #define NV_PFB_CONFIG_1_ED_PMAW_DEFAULT                  0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_PMAW_DEFAULT         EQU             000000000h
;  RWIUF 
;  4112 : #define NV_PFB_CONFIG_1_ED_PAGE                                 5:5 /* RWIUF */
NV_PFB_CONFIG_1_ED_PAGE         TEXTEQU         <5:5>
;  RWI-V 
;  4113 : #define NV_PFB_CONFIG_1_ED_PAGE_DEFAULT                  0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_PAGE_DEFAULT         EQU             000000000h
;  RWIUF 
;  4114 : #define NV_PFB_CONFIG_1_ED_RAC0_0                               8:8 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC0_0               TEXTEQU         <8:8>
;  RWI-V 
;  4115 : #define NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT               EQU             000000000h
;  RWIUF 
;  4116 : #define NV_PFB_CONFIG_1_ED_RAC0_1                               9:9 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC0_1               TEXTEQU         <9:9>
;  RWI-V 
;  4117 : #define NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT               EQU             000000000h
;  RWIUF 
;  4118 : #define NV_PFB_CONFIG_1_ED_RAC1_0                             10:10 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC1_0               TEXTEQU         <10:10>
;  RWI-V 
;  4119 : #define NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT               EQU             000000001h
;  RWIUF 
;  4120 : #define NV_PFB_CONFIG_1_ED_RAC1_1                             12:12 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC1_1               TEXTEQU         <12:12>
;  RWI-V 
;  4121 : #define NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT               EQU             000000000h
;  RWIUF 
;  4122 : #define NV_PFB_CONFIG_1_ED_RAD0_0                             13:13 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAD0_0               TEXTEQU         <13:13>
;  RWI-V 
;  4123 : #define NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT               EQU             000000001h
;  RWIUF 
;  4124 : #define NV_PFB_CONFIG_1_ED_RAD0_1                             14:14 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAD0_1               TEXTEQU         <14:14>
;  RWI-V 
;  4125 : #define NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT               EQU             000000001h
;  RWIUF 
;  4126 : #define NV_PFB_CONFIG_1_ED_RPC0_0                             16:16 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC0_0               TEXTEQU         <16:16>
;  RWI-V 
;  4127 : #define NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT               EQU             000000000h
;  RWIUF 
;  4128 : #define NV_PFB_CONFIG_1_ED_RPC0_1                             17:17 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC0_1               TEXTEQU         <17:17>
;  RWI-V 
;  4129 : #define NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT               EQU             000000000h
;  RWIUF 
;  4130 : #define NV_PFB_CONFIG_1_ED_RPC1_0                             18:18 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC1_0               TEXTEQU         <18:18>
;  RWI-V 
;  4131 : #define NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT               EQU             000000001h
;  RWIUF 
;  4132 : #define NV_PFB_CONFIG_1_ED_RPC1_1                             20:20 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC1_1               TEXTEQU         <20:20>
;  RWI-V 
;  4133 : #define NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT               EQU             000000001h
;  RW-4R 
;  4134 : #define NV_PFB_RTL                                       0x00100300 /* RW-4R */
NV_PFB_RTL              EQU             000100300h
;  RWIUF 
;  4135 : #define NV_PFB_RTL_S                                            1:0 /* RWIUF */
NV_PFB_RTL_S            TEXTEQU         <1:0>
;  RWI-V 
;  4136 : #define NV_PFB_RTL_S_DEFAULT                             0x00000002 /* RWI-V */
NV_PFB_RTL_S_DEFAULT            EQU             000000002h
;  RWIUF 
;  4137 : #define NV_PFB_RTL_V                                            5:4 /* RWIUF */
NV_PFB_RTL_V            TEXTEQU         <5:4>
;  RWI-V 
;  4138 : #define NV_PFB_RTL_V_DEFAULT                             0x00000002 /* RWI-V */
NV_PFB_RTL_V_DEFAULT            EQU             000000002h
;  RWIUF 
;  4139 : #define NV_PFB_RTL_M                                            9:8 /* RWIUF */
NV_PFB_RTL_M            TEXTEQU         <9:8>
;  RWI-V 
;  4140 : #define NV_PFB_RTL_M_DEFAULT                             0x00000002 /* RWI-V */
NV_PFB_RTL_M_DEFAULT            EQU             000000002h
;  RWIUF 
;  4141 : #define NV_PFB_RTL_H                                          13:12 /* RWIUF */
NV_PFB_RTL_H            TEXTEQU         <13:12>
;  RWI-V 
;  4142 : #define NV_PFB_RTL_H_DEFAULT                             0x00000001 /* RWI-V */
NV_PFB_RTL_H_DEFAULT            EQU             000000001h
;  RWIUF 
;  4143 : #define NV_PFB_RTL_A                                          17:16 /* RWIUF */
NV_PFB_RTL_A            TEXTEQU         <17:16>
;  RWI-V 
;  4144 : #define NV_PFB_RTL_A_DEFAULT                             0x00000001 /* RWI-V */
NV_PFB_RTL_A_DEFAULT            EQU             000000001h
;  RWIUF 
;  4145 : #define NV_PFB_RTL_G                                          21:20 /* RWIUF */
NV_PFB_RTL_G            TEXTEQU         <21:20>
;  RWI-V 
;  4146 : #define NV_PFB_RTL_G_DEFAULT                             0x00000001 /* RWI-V */
NV_PFB_RTL_G_DEFAULT            EQU             000000001h
;  RWIUF 
;  4147 : #define NV_PFB_RTL_ARB_GR_HI_PRIOR                            24:24 /* RWIUF */
NV_PFB_RTL_ARB_GR_HI_PRIOR              TEXTEQU         <24:24>
;  RWI-V 
;  4148 : #define NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT               0x00000000 /* RWI-V */
NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT              EQU             000000000h
;  RWIUF 
;  4149 : #define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR                         28:28 /* RWIUF */
NV_PFB_RTL_ARB_MEDIA_HI_PRIOR           TEXTEQU         <28:28>
;  RWI-V 
;  4150 : #define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT            0x00000000 /* RWI-V */
NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT           EQU             000000000h
;  dev_framebuffer.ref 
;  RW--M 
;  4151 : /* dev_framebuffer.ref */
;  4152 : #define NV_PNVM                               0x01BFFFFF:0x01800000 /* RW--M */
NV_PNVM         TEXTEQU         <0x01BFFFFF:0x01800000>
;  RW-4A 
;        
;  4153 : #define NV_PNVM_DATA032(i)                       (0x01800000+(i)*4) /* RW-4A */
;  4154 : #define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
NV_PNVM_DATA032__SIZE_1         EQU             524288t
;  RWXVF 
;  4155 : #define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
NV_PNVM_DATA032_VALUE           TEXTEQU         <31:0>
;  RW-3A 
;        
;  4156 : #define NV_PNVM_DATA024(i)           (0x01800000+((i)/2)*4+((i)%2)) /* RW-3A */
;  4157 : #define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
NV_PNVM_DATA024__SIZE_1         EQU             1048576t
;  RWXVF 
;  4158 : #define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
NV_PNVM_DATA024_VALUE           TEXTEQU         <23:0>
;  RW-2A 
;        
;  4159 : #define NV_PNVM_DATA016(i)           (0x01800000+((i)/3)*4+((i)%3)) /* RW-2A */
;  4160 : #define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
NV_PNVM_DATA016__SIZE_1         EQU             1572864t
;  RWXVF 
;  4161 : #define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
NV_PNVM_DATA016_VALUE           TEXTEQU         <15:0>
;  RW-1A 
;        
;  4162 : #define NV_PNVM_DATA008(i)                         (0x01800000+(i)) /* RW-1A */
;  4163 : #define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
NV_PNVM_DATA008__SIZE_1         EQU             2097152t
;  RWXVF 
;  4164 : #define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
NV_PNVM_DATA008_VALUE           TEXTEQU         <7:0>
;  dev_framebuffer.ref 
;  RW--M 
;  4165 : /* dev_framebuffer.ref */
;  4166 : #define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
NV_PRAMIN               TEXTEQU         <0x01FFFFFF:0x01C00000>
;  RW-4A 
;        
;  4167 : #define NV_PRAMIN_DATA032(i)                       (0x01C00000+(i)*4) /* RW-4A */
;  4168 : #define NV_PRAMIN_DATA032__SIZE_1                              524288 /*       */
NV_PRAMIN_DATA032__SIZE_1               EQU             524288t
;  RWXVF 
;  4169 : #define NV_PRAMIN_DATA032_VALUE                                  31:0 /* RWXVF */
NV_PRAMIN_DATA032_VALUE         TEXTEQU         <31:0>
;  RW-3A 
;        
;  4170 : #define NV_PRAMIN_DATA024(i)           (0x01C00000+((i)/2)*4+((i)%2)) /* RW-3A */
;  4171 : #define NV_PRAMIN_DATA024__SIZE_1                             1048576 /*       */
NV_PRAMIN_DATA024__SIZE_1               EQU             1048576t
;  RWXVF 
;  4172 : #define NV_PRAMIN_DATA024_VALUE                                  23:0 /* RWXVF */
NV_PRAMIN_DATA024_VALUE         TEXTEQU         <23:0>
;  RW-2A 
;        
;  4173 : #define NV_PRAMIN_DATA016(i)           (0x01C00000+((i)/3)*4+((i)%3)) /* RW-2A */
;  4174 : #define NV_PRAMIN_DATA016__SIZE_1                             1572864 /*       */
NV_PRAMIN_DATA016__SIZE_1               EQU             1572864t
;  RWXVF 
;  4175 : #define NV_PRAMIN_DATA016_VALUE                                  15:0 /* RWXVF */
NV_PRAMIN_DATA016_VALUE         TEXTEQU         <15:0>
;  RW-1A 
;        
;  4176 : #define NV_PRAMIN_DATA008(i)                         (0x01C00000+(i)) /* RW-1A */
;  4177 : #define NV_PRAMIN_DATA008__SIZE_1                             2097152 /*       */
NV_PRAMIN_DATA008__SIZE_1               EQU             2097152t
;  RWXVF 
;  4178 : #define NV_PRAMIN_DATA008_VALUE                                   7:0 /* RWXVF */
NV_PRAMIN_DATA008_VALUE         TEXTEQU         <7:0>
;  dev_ram.ref 
;  RW--M 
;        
;  4179 : /* dev_ram.ref */
;  4180 : #define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
;  4181 : #define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
NV_PRAMIN_CONTEXT_0             TEXTEQU         <( 0*32+31):( 0*32+ 0)>
;        
;  4182 : #define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
NV_PRAMIN_CONTEXT_1             TEXTEQU         <( 1*32+31):( 1*32+ 0)>
;        
;  4183 : #define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
NV_PRAMIN_CONTEXT_2             TEXTEQU         <( 2*32+31):( 2*32+ 0)>
;        
;  4184 : #define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
NV_PRAMIN_CONTEXT_3             TEXTEQU         <( 3*32+31):( 3*32+ 0)>
;  RW--M 
;  4185 : #define NV_PRAMIN_RAMHT_0                     0x01400FFF:0x01400000 /* RW--M */
NV_PRAMIN_RAMHT_0               TEXTEQU         <0x01400FFF:0x01400000>
;  RW--M 
;     9 : #define NV_PRAMIN_RAMAU_0                     0x01401BFF:0x01401000 /* RW--M */
NV_PRAMIN_RAMAU_0               TEXTEQU         <0x01401BFF:0x01401000>
;  RW--M 
;    10 : #define NV_PRAMIN_RAMFC_0                     0x01401DFF:0x01401C00 /* RW--M */
NV_PRAMIN_RAMFC_0               TEXTEQU         <0x01401DFF:0x01401C00>
;  RW--M 
;    11 : #define NV_PRAMIN_RAMRO_0                     0x01401FFF:0x01401E00 /* RW--M */
NV_PRAMIN_RAMRO_0               TEXTEQU         <0x01401FFF:0x01401E00>
;  RW--M 
;    12 : #define NV_PRAMIN_RAMRM_0                     0x01402FFF:0x01402000 /* RW--M */
NV_PRAMIN_RAMRM_0               TEXTEQU         <0x01402FFF:0x01402000>
;  dev_framebuffer.ref 
;  RW--D 
;    13 : /* dev_framebuffer.ref */
;    14 : #define NV_PDFB                               0x017FFFFF:0x01000000 /* RW--D */
NV_PDFB         TEXTEQU         <0x017FFFFF:0x01000000>
;  RW-4A 
;        
;    15 : #define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
;    16 : #define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
NV_PDFB_DATA032__SIZE_1         EQU             524288t
;  RWXVF 
;    17 : #define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
NV_PDFB_DATA032_VALUE           TEXTEQU         <31:0>
;  RW-3A 
;        
;    18 : #define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
;    19 : #define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
NV_PDFB_DATA024__SIZE_1         EQU             1048576t
;  RWXVF 
;    20 : #define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
NV_PDFB_DATA024_VALUE           TEXTEQU         <23:0>
;  RW-2A 
;        
;    21 : #define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
;    22 : #define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
NV_PDFB_DATA016__SIZE_1         EQU             1572864t
;  RWXVF 
;    23 : #define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
NV_PDFB_DATA016_VALUE           TEXTEQU         <15:0>
;  RW-1A 
;        
;    24 : #define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
;    25 : #define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
NV_PDFB_DATA008__SIZE_1         EQU             2097152t
;  RWXVF 
;    26 : #define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
NV_PDFB_DATA008_VALUE           TEXTEQU         <7:0>
;  dev_ram.ref 
;  RW--D 
;    27 : /* dev_ram.ref */
;    28 : #define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
NV_PRAM         TEXTEQU         <0x00006FFF:0x00006000>
;  dev_ext_devices.ref 
;  RW--D 
;    29 : /* dev_ext_devices.ref */
;    30 : #define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
NV_PEXTDEV              TEXTEQU         <0x00101FFF:0x00101000>
;  R--4R 
;    31 : #define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
NV_PEXTDEV_BOOT_0               EQU             000101000h
;  R-XVF 
;    32 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED               TEXTEQU         <0:0>
;  R---V 
;    33 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ         EQU             000000000h
;  R---V 
;    34 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ         EQU             000000001h
;  R-XVF 
;    35 : #define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR              TEXTEQU         <1:1>
;  R---V 
;    36 : #define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS              EQU             000000000h
;  R---V 
;    37 : #define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS         EQU             000000001h
;  R-XVF 
;    38 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        3:2 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                TEXTEQU         <3:2>
;  R---V 
;    39 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO            EQU             000000000h
;  R---V 
;    40 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K             EQU             000000001h
;  R---V 
;    41 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_RESERVED        0x00000002 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_RESERVED               EQU             000000002h
;  R---V 
;    42 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K      0x00000003 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K             EQU             000000003h
;  R-XVF 
;    43 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH               TEXTEQU         <4:4>
;  R---V 
;    44 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64            EQU             000000000h
;  R---V 
;    45 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128           EQU             000000001h
;  R-XVF 
;    46 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                TEXTEQU         <5:5>
;  R---V 
;    47 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI            EQU             000000000h
;  R---V 
;    48 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP            EQU             000000001h
;  R-XVF 
;    49 : #define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL         TEXTEQU         <6:6>
;  R---V 
;    50 : #define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K          EQU             000000000h
;  R---V 
;    51 : #define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180                EQU             000000001h
;  R-XVF 
;    52 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE          TEXTEQU         <8:7>
;  R---V 
;    53 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM            EQU             000000000h
;  R---V 
;    54 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC             EQU             000000001h
;  R---V 
;    55 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL              EQU             000000002h
;  R---V 
;    56 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED         EQU             000000003h
;  R-XVF 
;    57 : #define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE                        9:9 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE                TEXTEQU         <9:9>
;  R---V 
;    58 : #define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_20              0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_20             EQU             000000000h
;  R---V 
;    59 : #define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_21              0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_21             EQU             000000001h
;  dev_ext_devices.ref 
;  RW--D 
;    60 : /* dev_ext_devices.ref */
;    61 : #define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
NV_PDAC         TEXTEQU         <0x00680FFF:0x00680000>
;  RW-4A 
;        
;    62 : #define NV_PDAC_DATA(i)                          (0x00500000+(i)*4) /* RW-4A */
;    63 : #define NV_PDAC_DATA__SIZE_1                                     16 /*       */
NV_PDAC_DATA__SIZE_1            EQU             16t
;  RW-VF 
;    64 : #define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
NV_PDAC_DATA_VALUE              TEXTEQU         <7:0>
;  dev_ext_devices.ref 
;  dev_ext_devices.ref 
;  RW--D 
;    65 : /* dev_ext_devices.ref */
;    66 : /* dev_ext_devices.ref */
;    67 : #define NV_PROM                               0x0011FFFF:0x00110000 /* RW--D */
NV_PROM         TEXTEQU         <0x0011FFFF:0x00110000>
;  RW-1A 
;        
;    68 : #define NV_PROM_DATA(i)                            (0x00110000+(i)) /* RW-1A */
;    69 : #define NV_PROM_DATA__SIZE_1                                  65536 /*       */
NV_PROM_DATA__SIZE_1            EQU             65536t
;  RW-VF 
;    70 : #define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
NV_PROM_DATA_VALUE              TEXTEQU         <7:0>
;  dev_ext_devices.ref 
;  RW--D 
;    71 : /* dev_ext_devices.ref */
;    72 : #define NV_PALT                               0x0012FFFF:0x00120000 /* RW--D */
NV_PALT         TEXTEQU         <0x0012FFFF:0x00120000>
;  RW-1A 
;        
;    73 : #define NV_PALT_DATA(i)                            (0x00120000+(i)) /* RW-1A */
;    74 : #define NV_PALT_DATA__SIZE_1                                  65536 /*       */
NV_PALT_DATA__SIZE_1            EQU             65536t
;  RW-VF 
;    75 : #define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
NV_PALT_DATA_VALUE              TEXTEQU         <7:0>
;  dev_realmode.ref 
;  RW--D 
;    76 : /* dev_realmode.ref */
;    77 : #define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
NV_PRM          TEXTEQU         <0x00005FFF:0x00004000>
;  RW-4R 
;    78 : #define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
NV_PRM_INTR_0           EQU             000004100h
;  RWXVF 
;    79 : #define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
NV_PRM_INTR_0_TRACE_MPU401              TEXTEQU         <0:0>
;  R---V 
;    80 : #define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING          EQU             000000000h
;  R---V 
;    81 : #define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_MPU401_PENDING              EQU             000000001h
;  -W--V 
;    82 : #define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_MPU401_RESET                EQU             000000001h
;  RWXVF 
;    83 : #define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
NV_PRM_INTR_0_TRACE_FM          TEXTEQU         <4:4>
;  R---V 
;    84 : #define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_FM_NOT_PENDING              EQU             000000000h
;  R---V 
;    85 : #define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_FM_PENDING          EQU             000000001h
;  -W--V 
;    86 : #define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_FM_RESET            EQU             000000001h
;  RWXVF 
;    87 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
NV_PRM_INTR_0_TRACE_SB_DIGITAL          TEXTEQU         <8:8>
;  R---V 
;    88 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING              EQU             000000000h
;  R---V 
;    89 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING          EQU             000000001h
;  -W--V 
;    90 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET            EQU             000000001h
;  RWXVF 
;    91 : #define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
NV_PRM_INTR_0_TRACE_SB_MIXER            TEXTEQU         <12:12>
;  R---V 
;    92 : #define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING                EQU             000000000h
;  R---V 
;    93 : #define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING            EQU             000000001h
;  -W--V 
;    94 : #define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_SB_MIXER_RESET              EQU             000000001h
;  RWXVF 
;    95 : #define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
NV_PRM_INTR_0_TRACE_OVERFLOW            TEXTEQU         <16:16>
;  R---V 
;    96 : #define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING                EQU             000000000h
;  R---V 
;    97 : #define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING            EQU             000000001h
;  -W--V 
;    98 : #define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_OVERFLOW_RESET              EQU             000000001h
;  RW-4R 
;    99 : #define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
NV_PRM_INTR_EN_0                EQU             000004140h
;  RWIVF 
;   100 : #define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_MPU401           TEXTEQU         <0:0>
;  RWI-V 
;   101 : #define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED          EQU             000000000h
;  RW--V 
;   102 : #define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED           EQU             000000001h
;  RWIVF 
;   103 : #define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_FM               TEXTEQU         <4:4>
;  RWI-V 
;   104 : #define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_FM_DISABLED              EQU             000000000h
;  RW--V 
;   105 : #define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_FM_ENABLED               EQU             000000001h
;  RWIVF 
;   106 : #define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL               TEXTEQU         <8:8>
;  RWI-V 
;   107 : #define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED              EQU             000000000h
;  RW--V 
;   108 : #define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED               EQU             000000001h
;  RWIVF 
;   109 : #define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_SB_MIXER         TEXTEQU         <12:12>
;  RWI-V 
;   110 : #define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED                EQU             000000000h
;  RW--V 
;   111 : #define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED         EQU             000000001h
;  RWIVF 
;   112 : #define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_OVERFLOW         TEXTEQU         <16:16>
;  RWI-V 
;   113 : #define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED                EQU             000000000h
;  RW--V 
;   114 : #define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED         EQU             000000001h
;  RW-4R 
;   115 : #define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
NV_PRM_RAMRM            EQU             000004200h
;  RWXVF 
;   116 : #define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
NV_PRM_RAMRM_BASE_ADDRESS               TEXTEQU         <15:12>
;  RWI-V 
;   117 : #define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
NV_PRM_RAMRM_BASE_ADDRESS_2000          EQU             000002000h
;  RW-4R 
;   118 : #define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
NV_PRM_TRACE            EQU             000004300h
;  RWIVF 
;   119 : #define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
NV_PRM_TRACE_IO_CAPTURE         TEXTEQU         <1:0>
;  RWI-V 
;   120 : #define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
NV_PRM_TRACE_IO_CAPTURE_DISABLED                EQU             000000000h
;  RW--V 
;   121 : #define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
NV_PRM_TRACE_IO_CAPTURE_WRITES          EQU             000000001h
;  RW--V 
;   122 : #define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
NV_PRM_TRACE_IO_CAPTURE_READS           EQU             000000002h
;  RW--V 
;   123 : #define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
NV_PRM_TRACE_IO_CAPTURE_READS_WRITES            EQU             000000003h
;  RWXVF 
;   124 : #define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
NV_PRM_TRACE_IO_WRITE           TEXTEQU         <4:4>
;  R---V 
;   125 : #define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
NV_PRM_TRACE_IO_WRITE_NONE              EQU             000000000h
;  R---V 
;   126 : #define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
NV_PRM_TRACE_IO_WRITE_OCCURED           EQU             000000001h
;  -W--V 
;   127 : #define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
NV_PRM_TRACE_IO_WRITE_RESET             EQU             000000001h
;  RWXVF 
;   128 : #define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
NV_PRM_TRACE_IO_READ            TEXTEQU         <5:5>
;  R---V 
;   129 : #define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
NV_PRM_TRACE_IO_READ_NONE               EQU             000000000h
;  R---V 
;   130 : #define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
NV_PRM_TRACE_IO_READ_OCCURED            EQU             000000001h
;  -W--V 
;   131 : #define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
NV_PRM_TRACE_IO_READ_RESET              EQU             000000001h
;  RW-4R 
;   132 : #define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
NV_PRM_TRACE_INDEX              EQU             000004310h
;  RWXUF 
;   133 : #define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
NV_PRM_TRACE_INDEX_ADDRESS              TEXTEQU         <9:0>
;  RW--V 
;   134 : #define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
NV_PRM_TRACE_INDEX_ADDRESS_0            EQU             000000000h
;  RW-4R 
;   135 : #define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
NV_PRM_IGNORE_0         EQU             000004320h
;  RWXVF 
;   136 : #define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
NV_PRM_IGNORE_0_MPU401          TEXTEQU         <1:0>
;  RW--V 
;   137 : #define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
NV_PRM_IGNORE_0_MPU401_DISABLED         EQU             000000000h
;  RW--V 
;   138 : #define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
NV_PRM_IGNORE_0_MPU401_WRITES           EQU             000000001h
;  RW--V 
;   139 : #define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
NV_PRM_IGNORE_0_MPU401_READS            EQU             000000002h
;  RW--V 
;   140 : #define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
NV_PRM_IGNORE_0_MPU401_READS_WRITES             EQU             000000003h
;  RWXVF 
;   141 : #define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
NV_PRM_IGNORE_0_FM              TEXTEQU         <5:4>
;  RW--V 
;   142 : #define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
NV_PRM_IGNORE_0_FM_DISABLED             EQU             000000000h
;  RW--V 
;   143 : #define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
NV_PRM_IGNORE_0_FM_WRITES               EQU             000000001h
;  RW--V 
;   144 : #define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
NV_PRM_IGNORE_0_FM_READS                EQU             000000002h
;  RW--V 
;   145 : #define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
NV_PRM_IGNORE_0_FM_READS_WRITES         EQU             000000003h
;  RWXVF 
;   146 : #define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
NV_PRM_IGNORE_0_SB_DIGITAL              TEXTEQU         <9:8>
;  RW--V 
;   147 : #define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED             EQU             000000000h
;  RW--V 
;   148 : #define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_WRITES               EQU             000000001h
;  RW--V 
;   149 : #define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_READS                EQU             000000002h
;  RW--V 
;   150 : #define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES         EQU             000000003h
;  RWXVF 
;   151 : #define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
NV_PRM_IGNORE_0_SB_MIXER                TEXTEQU         <13:12>
;  RW--V 
;   152 : #define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_DISABLED               EQU             000000000h
;  RW--V 
;   153 : #define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_WRITES         EQU             000000001h
;  RW--V 
;   154 : #define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_READS          EQU             000000002h
;  RW--V 
;   155 : #define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES           EQU             000000003h
;  dev_realmode.ref 
;  RW--D 
;   156 : /* dev_realmode.ref */
;   157 : #define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
NV_PRMIO                TEXTEQU         <0x00007FFF:0x00007000>
;  dev_realmode.ref 
;  dev_fifo.ref 
;  RW--D 
;   158 : /* dev_realmode.ref */
;   159 : /* dev_fifo.ref */
;   160 : #define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
NV_USER         TEXTEQU         <0x00FFFFFF:0x00800000>
;  -W-4A 
;        
;   161 : #define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
;   162 : #define NV_USER_OBJECT__SIZE_1                                  128 /*       */
NV_USER_OBJECT__SIZE_1          EQU             128t
;        
;   163 : #define NV_USER_OBJECT__SIZE_2                                    8 /*       */
NV_USER_OBJECT__SIZE_2          EQU             8t
;  -W-VF 
;   164 : #define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
NV_USER_OBJECT_HANDLE           TEXTEQU         <31:0>
;  R--2A 
;        
;   165 : #define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
;   166 : #define NV_USER_FREE016__SIZE_1                                 128 /*       */
NV_USER_FREE016__SIZE_1         EQU             128t
;        
;   167 : #define NV_USER_FREE016__SIZE_2                                   8 /*       */
NV_USER_FREE016__SIZE_2         EQU             8t
;  C--UF 
;   168 : #define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
NV_USER_FREE016_COUNT_LO                TEXTEQU         <1:0>
;  C---V 
;   169 : #define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
NV_USER_FREE016_COUNT_LO_0              EQU             000000000h
;  R--UF 
;   170 : #define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
NV_USER_FREE016_COUNT           TEXTEQU         <9:2>
;  C--UF 
;   171 : #define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
NV_USER_FREE016_COUNT_HI                TEXTEQU         <15:10>
;  C---V 
;   172 : #define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
NV_USER_FREE016_COUNT_HI_0              EQU             000000000h
;  R--4A 
;        
;   173 : #define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
;   174 : #define NV_USER_FREE032__SIZE_1                                 128 /*       */
NV_USER_FREE032__SIZE_1         EQU             128t
;        
;   175 : #define NV_USER_FREE032__SIZE_2                                   8 /*       */
NV_USER_FREE032__SIZE_2         EQU             8t
;  C--UF 
;   176 : #define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
NV_USER_FREE032_COUNT_LO                TEXTEQU         <1:0>
;  C---V 
;   177 : #define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
NV_USER_FREE032_COUNT_LO_0              EQU             000000000h
;  R--UF 
;   178 : #define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
NV_USER_FREE032_COUNT           TEXTEQU         <9:2>
;  C--UF 
;   179 : #define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
NV_USER_FREE032_COUNT_HI                TEXTEQU         <31:10>
;  C---V 
;   180 : #define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
NV_USER_FREE032_COUNT_HI_0              EQU             000000000h
;  R--2A 
;        
;   181 : #define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
;   182 : #define NV_USER_ZERO016__SIZE_1                                 128 /*       */
NV_USER_ZERO016__SIZE_1         EQU             128t
;        
;   183 : #define NV_USER_ZERO016__SIZE_2                                   8 /*       */
NV_USER_ZERO016__SIZE_2         EQU             8t
;        
;   184 : #define NV_USER_ZERO016__SIZE_3                                   7 /*       */
NV_USER_ZERO016__SIZE_3         EQU             7t
;  C--UF 
;   185 : #define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
NV_USER_ZERO016_COUNT           TEXTEQU         <15:0>
;  C---V 
;   186 : #define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
NV_USER_ZERO016_COUNT_0         EQU             000000000h
;  R--4A 
;        
;   187 : #define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
;   188 : #define NV_USER_ZERO032__SIZE_1                                 128 /*       */
NV_USER_ZERO032__SIZE_1         EQU             128t
;        
;   189 : #define NV_USER_ZERO032__SIZE_2                                   8 /*       */
NV_USER_ZERO032__SIZE_2         EQU             8t
;        
;   190 : #define NV_USER_ZERO032__SIZE_3                                   3 /*       */
NV_USER_ZERO032__SIZE_3         EQU             3t
;  C--UF 
;   191 : #define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
NV_USER_ZERO032_COUNT           TEXTEQU         <31:0>
;  C---V 
;   192 : #define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
NV_USER_ZERO032_COUNT_0         EQU             000000000h
;  dev_misc.ref 
;        
;   193 : /* dev_misc.ref */
;   194 : #define NV_USER_ADR_CHID                                      22:16 /*       */
NV_USER_ADR_CHID                TEXTEQU         <22:16>
;        
;   195 : #define NV_USER_ADR_SUBCHID                                   15:13 /*       */
NV_USER_ADR_SUBCHID             TEXTEQU         <15:13>
;        
;   196 : #define NV_USER_ADR_METHOD                                     12:0 /*       */
NV_USER_ADR_METHOD              TEXTEQU         <12:0>
;        
;   197 : #define NV_USER_DEVICE                                        22:16 /*       */
NV_USER_DEVICE          TEXTEQU         <22:16>
;  dev_timer.ref 
;  RW--D 
;   198 : /* dev_timer.ref */
;   199 : #define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
NV_PTIMER               TEXTEQU         <0x00009FFF:0x00009000>
;  RW-4R 
;   200 : #define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
NV_PTIMER_INTR_0                EQU             000009100h
;  RWXVF 
;   201 : #define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
NV_PTIMER_INTR_0_ALARM          TEXTEQU         <0:0>
;  R---V 
;   202 : #define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
NV_PTIMER_INTR_0_ALARM_NOT_PENDING              EQU             000000000h
;  R---V 
;   203 : #define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
NV_PTIMER_INTR_0_ALARM_PENDING          EQU             000000001h
;  -W--V 
;   204 : #define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
NV_PTIMER_INTR_0_ALARM_RESET            EQU             000000001h
;  RW-4R 
;   205 : #define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
NV_PTIMER_INTR_EN_0             EQU             000009140h
;  RWIVF 
;   206 : #define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
NV_PTIMER_INTR_EN_0_ALARM               TEXTEQU         <0:0>
;  RWI-V 
;   207 : #define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
NV_PTIMER_INTR_EN_0_ALARM_DISABLED              EQU             000000000h
;  RW--V 
;   208 : #define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
NV_PTIMER_INTR_EN_0_ALARM_ENABLED               EQU             000000001h
;  RW-4R 
;   209 : #define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
NV_PTIMER_NUMERATOR             EQU             000009200h
;  RWIUF 
;   210 : #define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
NV_PTIMER_NUMERATOR_VALUE               TEXTEQU         <15:0>
;  RWI-V 
;   211 : #define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
NV_PTIMER_NUMERATOR_VALUE_0             EQU             000000000h
;  RW-4R 
;   212 : #define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
NV_PTIMER_DENOMINATOR           EQU             000009210h
;  RWIUF 
;   213 : #define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
NV_PTIMER_DENOMINATOR_VALUE             TEXTEQU         <15:0>
;  RWI-V 
;   214 : #define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
NV_PTIMER_DENOMINATOR_VALUE_0           EQU             000000000h
;  RW-4R 
;   215 : #define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
NV_PTIMER_TIME_0                EQU             000009400h
;  RWXUF 
;   216 : #define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
NV_PTIMER_TIME_0_NSEC           TEXTEQU         <31:5>
;  RW-4R 
;   217 : #define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
NV_PTIMER_TIME_1                EQU             000009410h
;  RWXUF 
;   218 : #define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
NV_PTIMER_TIME_1_NSEC           TEXTEQU         <28:0>
;  RW-4R 
;   219 : #define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
NV_PTIMER_ALARM_0               EQU             000009420h
;  RWXUF 
;   220 : #define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
NV_PTIMER_ALARM_0_NSEC          TEXTEQU         <31:5>
;  dev_realmode.ref 
;  RW--M 
;   221 : /* dev_realmode.ref */
;   222 : #define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
NV_TRACE                TEXTEQU         <0x0000FFFF:0x00000000>
;  RWXVF 
;   223 : #define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
NV_TRACE_DATA           TEXTEQU         <( 0*32+ 7):( 0*32+ 0)>
;  RWXVF 
;   224 : #define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
NV_TRACE_ACCESS         TEXTEQU         <( 0*32+14):( 0*32+14)>
;  RW--V 
;   225 : #define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
NV_TRACE_ACCESS_WRITE           EQU             000000000h
;  RW--V 
;   226 : #define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
NV_TRACE_ACCESS_READ            EQU             000000001h
;  RWXVF 
;   227 : #define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
NV_TRACE_TYPE           TEXTEQU         <( 0*32+15):( 0*32+15)>
;  RW--V 
;   228 : #define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
NV_TRACE_TYPE_IO                EQU             000000000h
;  RW--V 
;   229 : #define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
NV_TRACE_TYPE_MEMORY            EQU             000000001h
;  RWXUF 
;   230 : #define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
NV_TRACE_ADDRESS                TEXTEQU         <( 0*32+31):( 0*32+16)>
;  dev_ram.ref 
;  RW--M 
;   231 : /* dev_ram.ref */
;   232 : #define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_0                TEXTEQU         <0x00000FFF:0x00000000>
;  RW--M 
;   233 : #define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_1                TEXTEQU         <0x00001FFF:0x00000000>
;  RW--M 
;   234 : #define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_2                TEXTEQU         <0x00003FFF:0x00000000>
;  RW--M 
;   235 : #define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_3                TEXTEQU         <0x00007FFF:0x00000000>
;  RWXVF 
;   236 : #define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
NV_RAMHT_HANDLE         TEXTEQU         <( 0*32+31):( 0*32+ 0)>
;  RWXUF 
;   237 : #define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
NV_RAMHT_INSTANCE               TEXTEQU         <( 1*32+15):( 1*32+ 0)>
;  RWXUF 
;   238 : #define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
NV_RAMHT_DEVICE         TEXTEQU         <( 1*32+22):( 1*32+16)>
;  RWXVF 
;   239 : #define NV_RAMHT_ENGINE                       ( 1*32+23):( 1*32+23) /* RWXVF */
NV_RAMHT_ENGINE         TEXTEQU         <( 1*32+23):( 1*32+23)>
;  RW--V 
;   240 : #define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
NV_RAMHT_ENGINE_SW              EQU             000000000h
;  RW--V 
;   241 : #define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
NV_RAMHT_ENGINE_GRAPHICS                EQU             000000001h
;  RWXUF 
;   242 : #define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
NV_RAMHT_CHID           TEXTEQU         <( 1*32+30):( 1*32+24)>
;  dev_ram.ref 
;  RW--M 
;   243 : /* dev_ram.ref */
;   244 : #define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
NV_RAMRO__SIZE_0                TEXTEQU         <0x000001FF:0x00000000>
;  RW--M 
;   245 : #define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
NV_RAMRO__SIZE_1                TEXTEQU         <0x00001FFF:0x00000000>
;  RWXUF 
;   246 : #define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
NV_RAMRO_METHOD         TEXTEQU         <( 0*32+15):( 0*32+ 0)>
;  RWXUF 
;   247 : #define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
NV_RAMRO_CHID           TEXTEQU         <( 0*32+22):( 0*32+16)>
;  RWXVF 
;   248 : #define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
NV_RAMRO_TYPE           TEXTEQU         <( 0*32+23):( 0*32+23)>
;  RW--V 
;   249 : #define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
NV_RAMRO_TYPE_WRITE             EQU             000000000h
;  RW--V 
;   250 : #define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
NV_RAMRO_TYPE_READ              EQU             000000001h
;  RWXVF 
;   251 : #define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
NV_RAMRO_BYTE_ENABLES           TEXTEQU         <( 0*32+27):( 0*32+24)>
;  RWXVF 
;   252 : #define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
NV_RAMRO_REASON         TEXTEQU         <( 0*32+31):( 0*32+28)>
;  RW--V 
;   253 : #define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
NV_RAMRO_REASON_ILLEGAL_ACCESS          EQU             000000000h
;  RW--V 
;   254 : #define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
NV_RAMRO_REASON_NO_CACHE_AVAILABLE              EQU             000000001h
;  RW--V 
;   255 : #define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
NV_RAMRO_REASON_CACHE_RAN_OUT           EQU             000000002h
;  RW--V 
;   256 : #define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
NV_RAMRO_REASON_FREE_COUNT_OVERRUN              EQU             000000003h
;  RW--V 
;   257 : #define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
NV_RAMRO_REASON_CAUGHT_LYING            EQU             000000004h
;  RW--V 
;   258 : #define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
NV_RAMRO_REASON_RESERVED_ACCESS         EQU             000000005h
;  RWXVF 
;   259 : #define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
NV_RAMRO_DATA           TEXTEQU         <( 1*32+31):( 1*32+ 0)>
;  dev_ram.ref 
;  RW--M 
;   260 : /* dev_ram.ref */
;   261 : #define NV_RAMAU                              0x00000BFF:0x00000000 /* RW--M */
NV_RAMAU                TEXTEQU         <0x00000BFF:0x00000000>
;  RWXVF 
;   262 : #define NV_RAMAU_DATA                                          31:0 /* RWXVF */
NV_RAMAU_DATA           TEXTEQU         <31:0>
;  dev_ram.ref 
;  RW--M 
;   263 : /* dev_ram.ref */
;   264 : #define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
NV_RAMFC__SIZE_0                TEXTEQU         <0x000001FF:0x00000000>
;  RW--M 
;   265 : #define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
NV_RAMFC__SIZE_1                TEXTEQU         <0x00000FFF:0x00000000>
;  RWXUF 
;   266 : #define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
NV_RAMFC_INSTANCE_0             TEXTEQU         <( 0*32+15):( 0*32+ 0)>
;  RWXUF 
;   267 : #define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
NV_RAMFC_DEVICE_0               TEXTEQU         <( 0*32+22):( 0*32+16)>
;  RW--V 
;   268 : #define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
NV_RAMFC_DEVICE_0_NOT_FOUND             EQU             000000000h
;  RWXVF 
;   269 : #define NV_RAMFC_ENGINE_0                     ( 0*32+23):( 0*32+23) /* RWXVF */
NV_RAMFC_ENGINE_0               TEXTEQU         <( 0*32+23):( 0*32+23)>
;  RW--V 
;   270 : #define NV_RAMFC_ENGINE_0_SW                             0x00000000 /* RW--V */
NV_RAMFC_ENGINE_0_SW            EQU             000000000h
;  RW--V 
;   271 : #define NV_RAMFC_ENGINE_0_GRAPHICS                       0x00000001 /* RW--V */
NV_RAMFC_ENGINE_0_GRAPHICS              EQU             000000001h
;  RWXUF 
;   272 : #define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
NV_RAMFC_INSTANCE_1             TEXTEQU         <( 1*32+15):( 1*32+ 0)>
;  RWXUF 
;   273 : #define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
NV_RAMFC_DEVICE_1               TEXTEQU         <( 1*32+22):( 1*32+16)>
;  RW--V 
;   274 : #define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
NV_RAMFC_DEVICE_1_NOT_FOUND             EQU             000000000h
;  RWXVF 
;   275 : #define NV_RAMFC_ENGINE_1                     ( 1*32+23):( 1*32+23) /* RWXVF */
NV_RAMFC_ENGINE_1               TEXTEQU         <( 1*32+23):( 1*32+23)>
;  RW--V 
;   276 : #define NV_RAMFC_ENGINE_1_SW                             0x00000000 /* RW--V */
NV_RAMFC_ENGINE_1_SW            EQU             000000000h
;  RW--V 
;   277 : #define NV_RAMFC_ENGINE_1_GRAPHICS                       0x00000001 /* RW--V */
NV_RAMFC_ENGINE_1_GRAPHICS              EQU             000000001h
;  RWXUF 
;   278 : #define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
NV_RAMFC_INSTANCE_7             TEXTEQU         <( 7*32+15):( 7*32+ 0)>
;  RWXUF 
;   279 : #define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
NV_RAMFC_DEVICE_7               TEXTEQU         <( 7*32+22):( 7*32+16)>
;  RW--V 
;   280 : #define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
NV_RAMFC_DEVICE_7_NOT_FOUND             EQU             000000000h
;  RWXVF 
;   281 : #define NV_RAMFC_ENGINE_7                     ( 7*32+23):( 7*32+23) /* RWXVF */
NV_RAMFC_ENGINE_7               TEXTEQU         <( 7*32+23):( 7*32+23)>
;  RW--V 
;   282 : #define NV_RAMFC_ENGINE_7_SW                             0x00000000 /* RW--V */
NV_RAMFC_ENGINE_7_SW            EQU             000000000h
;  RW--V 
;   283 : #define NV_RAMFC_ENGINE_7_GRAPHICS                       0x00000001 /* RW--V */
NV_RAMFC_ENGINE_7_GRAPHICS              EQU             000000001h
;  dev_ram.ref 
;  dev_ram.ref 
;  dev_ram.ref 
;  RWXUF 
;   284 : /* dev_ram.ref */
;   285 : /* dev_ram.ref */
;   286 : /* dev_ram.ref */
;   287 : #define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
NV_DMA_ADJUST           TEXTEQU         <( 0*32+11):( 0*32+ 0)>
;  RWXVF 
;   288 : #define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
NV_DMA_PAGE_TABLE               TEXTEQU         <( 0*32+16):( 0*32+16)>
;  RW--V 
;   289 : #define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
NV_DMA_PAGE_TABLE_NOT_PRESENT           EQU             000000000h
;  RW--V 
;   290 : #define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
NV_DMA_PAGE_TABLE_PRESENT               EQU             000000001h
;  RWXVF 
;   291 : #define NV_DMA_TARGET_NODE                    ( 0*32+25):( 0*32+24) /* RWXVF */
NV_DMA_TARGET_NODE              TEXTEQU         <( 0*32+25):( 0*32+24)>
;  RW--V 
;   292 : #define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
NV_DMA_TARGET_NODE_NVM          EQU             000000000h
;  RW--V 
;   293 : #define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
NV_DMA_TARGET_NODE_PCI          EQU             000000002h
;  RW--V 
;   294 : #define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
NV_DMA_TARGET_NODE_AGP          EQU             000000003h
;  RWXUF 
;   295 : #define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
NV_DMA_LIMIT            TEXTEQU         <( 1*32+31):( 1*32+ 0)>
;  RWXVF 
;   296 : #define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
NV_DMA_PAGE             TEXTEQU         <( 2*32+ 0):( 2*32+ 0)>
;  RW--V 
;   297 : #define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
NV_DMA_PAGE_NOT_PRESENT         EQU             000000000h
;  RW--V 
;   298 : #define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
NV_DMA_PAGE_PRESENT             EQU             000000001h
;  RWXVF 
;   299 : #define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
NV_DMA_ACCESS           TEXTEQU         <( 2*32+ 1):( 2*32+ 1)>
;  RW--V 
;   300 : #define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
NV_DMA_ACCESS_READ_ONLY         EQU             000000000h
;  RW--V 
;   301 : #define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
NV_DMA_ACCESS_READ_AND_WRITE            EQU             000000001h
;  RWXUF 
;   302 : #define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
NV_DMA_FRAME_ADDRESS            TEXTEQU         <( 2*32+31):( 2*32+12)>
;  dev_ram.ref 
;  RWXUF 
;   303 : /* dev_ram.ref */
;   304 : #define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
NV_SUBCHAN_CTX_SWITCH           TEXTEQU         <( 0*32+31):( 0*32+ 0)>
;  RWXUF 
;   305 : #define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
NV_SUBCHAN_DMA_INSTANCE         TEXTEQU         <( 1*32+15):( 1*32+ 0)>
;  RWXUF 
;   306 : #define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
NV_SUBCHAN_NOTIFY_INSTANCE              TEXTEQU         <( 1*32+31):( 1*32+16)>
;  RWXUF 
;   307 : #define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
NV_SUBCHAN_MEMFMT_INSTANCE              TEXTEQU         <( 2*32+15):( 2*32+ 0)>
;  RWXUF 
;   308 : #define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
NV_SUBCHAN_MEMFMT_LINEAR                TEXTEQU         <( 2*32+16):( 2*32+16)>
;  RW--V 
;   309 : #define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
NV_SUBCHAN_MEMFMT_LINEAR_OUT            EQU             000000000h
;  RW--V 
;   310 : #define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
NV_SUBCHAN_MEMFMT_LINEAR_IN             EQU             000000001h
;  dev_ram.ref 
;  RW--M 
;   311 : /* dev_ram.ref */
;   312 : #define NV_AUDIN                              0x00000033:0x00000000 /* RW--M */
NV_AUDIN                TEXTEQU         <0x00000033:0x00000000>
;  RWWVF 
;   313 : #define NV_AUDIN_AE_STATE                       (0*32+15):(0*32+ 0) /* RWWVF */
NV_AUDIN_AE_STATE               TEXTEQU         <(0*32+15):(0*32+ 0)>
;  RWWUF 
;   314 : #define NV_AUDIN_AE_SKIP_COUNT                  (1*32+31):(1*32+ 0) /* RWWUF */
NV_AUDIN_AE_SKIP_COUNT          TEXTEQU         <(1*32+31):(1*32+ 0)>
;  RWWUF 
;   315 : #define NV_AUDIN_AE_POSITION                    (2*32+31):(2*32+ 0) /* RWWUF */
NV_AUDIN_AE_POSITION            TEXTEQU         <(2*32+31):(2*32+ 0)>
;  RWWUF 
;   316 : #define NV_AUDIN_RM_NEXT_INSTANCE               (3*32+31):(3*32+ 0) /* RWWUF */
NV_AUDIN_RM_NEXT_INSTANCE               TEXTEQU         <(3*32+31):(3*32+ 0)>
;  RWWVF 
;   317 : #define NV_AUDIN_RM_STATE                       (4*32+15):(4*32+ 0) /* RWWVF */
NV_AUDIN_RM_STATE               TEXTEQU         <(4*32+15):(4*32+ 0)>
;  RWWVF 
;   318 : #define NV_AUDIN_SU_STATE                       (5*32+15):(5*32+ 0) /* RWWVF */
NV_AUDIN_SU_STATE               TEXTEQU         <(5*32+15):(5*32+ 0)>
;  RWWUF 
;   319 : #define NV_AUDIN_SU_START_TIME_LOW              (5*32+31):(5*32+16) /* RWWUF */
NV_AUDIN_SU_START_TIME_LOW              TEXTEQU         <(5*32+31):(5*32+16)>
;  RWWUF 
;   320 : #define NV_AUDIN_SU_START_TIME_HIGH             (6*32+31):(6*32+ 0) /* RWWUF */
NV_AUDIN_SU_START_TIME_HIGH             TEXTEQU         <(6*32+31):(6*32+ 0)>
;  RWWUF 
;   321 : #define NV_AUDIN_SU_SKIP_INC                    (7*32+31):(7*32+ 0) /* RWWUF */
NV_AUDIN_SU_SKIP_INC            TEXTEQU         <(7*32+31):(7*32+ 0)>
;  RWWUF 
;   322 : #define NV_AUDIN_SU_BUFF0_DMA_INSTANCE          (8*32+15):(8*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF0_DMA_INSTANCE          TEXTEQU         <(8*32+15):(8*32+ 0)>
;  RWWUF 
;   323 : #define NV_AUDIN_SU_BUFF1_DMA_INSTANCE          (8*32+31):(8*32+16) /* RWWUF */
NV_AUDIN_SU_BUFF1_DMA_INSTANCE          TEXTEQU         <(8*32+31):(8*32+16)>
;  RWWUF 
;   324 : #define NV_AUDIN_SU_BUFF0_START_POSITION        (9*32+31):(9*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF0_START_POSITION                TEXTEQU         <(9*32+31):(9*32+ 0)>
;  RWWUF 
;   325 : #define NV_AUDIN_SU_BUFF0_LAST_PLUS1          (10*32+31):(10*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF0_LAST_PLUS1            TEXTEQU         <(10*32+31):(10*32+ 0)>
;  RWWUF 
;   326 : #define NV_AUDIN_SU_BUFF1_START_POSITION      (11*32+31):(11*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF1_START_POSITION                TEXTEQU         <(11*32+31):(11*32+ 0)>
;  RWWUF 
;   327 : #define NV_AUDIN_SU_BUFF1_LAST_PLUS1          (12*32+31):(12*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF1_LAST_PLUS1            TEXTEQU         <(12*32+31):(12*32+ 0)>
;  RWXVF 
;   328 : #define NV_AUDIN_AE_EVENT_START               ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
NV_AUDIN_AE_EVENT_START         TEXTEQU         <( 0*32+ 3):( 0*32+ 3)>
;  RWXVF 
;   329 : #define NV_AUDIN_AE_BUFF0_INTR_NOTIFY         ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
NV_AUDIN_AE_BUFF0_INTR_NOTIFY           TEXTEQU         <( 0*32+ 4):( 0*32+ 4)>
;  RWXVF 
;   330 : #define NV_AUDIN_AE_BUFF1_INTR_NOTIFY         ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
NV_AUDIN_AE_BUFF1_INTR_NOTIFY           TEXTEQU         <( 0*32+ 5):( 0*32+ 5)>
;  RWXVF 
;   331 : #define NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP      ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP                TEXTEQU         <( 0*32+ 6):( 0*32+ 6)>
;  RWXVF 
;   332 : #define NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP      ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP                TEXTEQU         <( 0*32+ 7):( 0*32+ 7)>
;  RWXVF 
;   333 : #define NV_AUDIN_AE_BUFF0_IN_USE              ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
NV_AUDIN_AE_BUFF0_IN_USE                TEXTEQU         <( 0*32+ 8):( 0*32+ 8)>
;  RWXVF 
;   334 : #define NV_AUDIN_AE_BUFF1_IN_USE              ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
NV_AUDIN_AE_BUFF1_IN_USE                TEXTEQU         <( 0*32+ 9):( 0*32+ 9)>
;  RWXVF 
;   335 : #define NV_AUDIN_AE_CURRENT_BUFFER            ( 0*32+12):( 0*32+12) /* RWXVF */
NV_AUDIN_AE_CURRENT_BUFFER              TEXTEQU         <( 0*32+12):( 0*32+12)>
;  RW--V 
;   336 : #define NV_AUDIN_AE_CURRENT_BUFFER_0                     0x00000000 /* RW--V */
NV_AUDIN_AE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;   337 : #define NV_AUDIN_AE_CURRENT_BUFFER_1                     0x00000001 /* RW--V */
NV_AUDIN_AE_CURRENT_BUFFER_1            EQU             000000001h
;  RWXVF 
;   338 : #define NV_AUDIN_AE_INTR_DMA                  ( 0*32+11):( 0*32+11) /* RWXVF */
NV_AUDIN_AE_INTR_DMA            TEXTEQU         <( 0*32+11):( 0*32+11)>
;  RWXVF 
;   339 : #define NV_AUDIN_RM_BUFF0_INTR_NOTIFY         ( 4*32+ 4):( 4*32+ 4) /* RWXVF */
NV_AUDIN_RM_BUFF0_INTR_NOTIFY           TEXTEQU         <( 4*32+ 4):( 4*32+ 4)>
;  RWXVF 
;   340 : #define NV_AUDIN_RM_BUFF1_INTR_NOTIFY         ( 4*32+ 5):( 4*32+ 5) /* RWXVF */
NV_AUDIN_RM_BUFF1_INTR_NOTIFY           TEXTEQU         <( 4*32+ 5):( 4*32+ 5)>
;  RWXVF 
;   341 : #define NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP      ( 4*32+ 6):( 4*32+ 6) /* RWXVF */
NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP                TEXTEQU         <( 4*32+ 6):( 4*32+ 6)>
;  RWXVF 
;   342 : #define NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP      ( 4*32+ 7):( 4*32+ 7) /* RWXVF */
NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP                TEXTEQU         <( 4*32+ 7):( 4*32+ 7)>
;  RWXVF 
;   343 : #define NV_AUDIN_SU_BUFF0_OFFSET              ( 5*32+ 1):( 5*32+ 0) /* RWXVF */
NV_AUDIN_SU_BUFF0_OFFSET                TEXTEQU         <( 5*32+ 1):( 5*32+ 0)>
;  RWXVF 
;   344 : #define NV_AUDIN_SU_BUFF1_OFFSET              ( 5*32+ 3):( 5*32+ 2) /* RWXVF */
NV_AUDIN_SU_BUFF1_OFFSET                TEXTEQU         <( 5*32+ 3):( 5*32+ 2)>
;  RWXVF 
;   345 : #define NV_AUDIN_SU_BYPASS_PTE                ( 5*32+ 4):( 5*32+ 4) /* RWXVF */
NV_AUDIN_SU_BYPASS_PTE          TEXTEQU         <( 5*32+ 4):( 5*32+ 4)>
;  RW--V 
;   346 : #define NV_AUDIN_SU_BYPASS_PTE_DISABLED                  0x00000000 /* RW--V */
NV_AUDIN_SU_BYPASS_PTE_DISABLED         EQU             000000000h
;  RW--V 
;   347 : #define NV_AUDIN_SU_BYPASS_PTE_ENABLED                   0x00000001 /* RW--V */
NV_AUDIN_SU_BYPASS_PTE_ENABLED          EQU             000000001h
;  RWXVF 
;   348 : #define NV_AUDIN_SU_BYPASS_TARGET             ( 5*32+ 6):( 5*32+ 5) /* RWXVF */
NV_AUDIN_SU_BYPASS_TARGET               TEXTEQU         <( 5*32+ 6):( 5*32+ 5)>
;  RW--V 
;   349 : #define NV_AUDIN_SU_BYPASS_TARGET_NVM                    0x00000000 /* RW--V */
NV_AUDIN_SU_BYPASS_TARGET_NVM           EQU             000000000h
;  RW--V 
;   350 : #define NV_AUDIN_SU_BYPASS_TARGET_PCI                    0x00000002 /* RW--V */
NV_AUDIN_SU_BYPASS_TARGET_PCI           EQU             000000002h
;  RW--V 
;   351 : #define NV_AUDIN_SU_BYPASS_TARGET_AGP                    0x00000003 /* RW--V */
NV_AUDIN_SU_BYPASS_TARGET_AGP           EQU             000000003h
;  RWXVF 
;   352 : #define NV_AUDIN_SU_BUFF0_IN_USE              ( 5*32+ 8):( 5*32+ 8) /* RWXVF */
NV_AUDIN_SU_BUFF0_IN_USE                TEXTEQU         <( 5*32+ 8):( 5*32+ 8)>
;  RWXVF 
;   353 : #define NV_AUDIN_SU_BUFF1_IN_USE              ( 5*32+ 9):( 5*32+ 9) /* RWXVF */
NV_AUDIN_SU_BUFF1_IN_USE                TEXTEQU         <( 5*32+ 9):( 5*32+ 9)>
;  RWXVF 
;   354 : #define NV_AUDIN_SU_BUFF0_NOTIFY              (16*32+10):(16*32+10) /* RWXVF */
NV_AUDIN_SU_BUFF0_NOTIFY                TEXTEQU         <(16*32+10):(16*32+10)>
;  RW--V 
;   355 : #define NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE              EQU             000000000h
;  RW--V 
;   356 : #define NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT              EQU             000000001h
;  RWXVF 
;   357 : #define NV_AUDIN_SU_BUFF1_NOTIFY              (16*32+11):(16*32+11) /* RWXVF */
NV_AUDIN_SU_BUFF1_NOTIFY                TEXTEQU         <(16*32+11):(16*32+11)>
;  RW--V 
;   358 : #define NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE              EQU             000000000h
;  RW--V 
;   359 : #define NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT              EQU             000000001h
;  RWXVF 
;   360 : #define NV_AUDIN_SU_CHANNEL                   ( 5*32+12):( 5*32+12) /* RWXVF */
NV_AUDIN_SU_CHANNEL             TEXTEQU         <( 5*32+12):( 5*32+12)>
;  RW--V 
;   361 : #define NV_AUDIN_SU_CHANNEL_MONO                         0x00000000 /* RW--V */
NV_AUDIN_SU_CHANNEL_MONO                EQU             000000000h
;  RW--V 
;   362 : #define NV_AUDIN_SU_CHANNEL_STEREO                       0x00000001 /* RW--V */
NV_AUDIN_SU_CHANNEL_STEREO              EQU             000000001h
;  RWXVF 
;   363 : #define NV_AUDIN_SU_FORMAT                    ( 5*32+15):( 5*32+13) /* RWXVF */
NV_AUDIN_SU_FORMAT              TEXTEQU         <( 5*32+15):( 5*32+13)>
;  RW--V 
;   364 : #define NV_AUDIN_SU_FORMAT_LINEAR                        0x00000000 /* RW--V */
NV_AUDIN_SU_FORMAT_LINEAR               EQU             000000000h
;  RW--V 
;   365 : #define NV_AUDIN_SU_FORMAT_ULAW                          0x00000001 /* RW--V */
NV_AUDIN_SU_FORMAT_ULAW         EQU             000000001h
;  RW--V 
;   366 : #define NV_AUDIN_SU_FORMAT_ALAW                          0x00000002 /* RW--V */
NV_AUDIN_SU_FORMAT_ALAW         EQU             000000002h
;  RW--V 
;   367 : #define NV_AUDIN_SU_FORMAT_OFFSET8                       0x00000003 /* RW--V */
NV_AUDIN_SU_FORMAT_OFFSET8              EQU             000000003h
;  dev_ram.ref 
;  RW--M 
;   368 : /* dev_ram.ref */
;   369 : #define NV_AUDOUT                             0x0000003b:0x00000000 /* RW--M */
NV_AUDOUT               TEXTEQU         <0x0000003b:0x00000000>
;  RWWVF 
;   370 : #define NV_AUDOUT_AE_STATE                      (0*32+15):(0*32+ 0) /* RWWVF */
NV_AUDOUT_AE_STATE              TEXTEQU         <(0*32+15):(0*32+ 0)>
;  RWWUF 
;   371 : #define NV_AUDOUT_AE_POSITION_LOW               (0*32+31):(0*32+16) /* RWWUF */
NV_AUDOUT_AE_POSITION_LOW               TEXTEQU         <(0*32+31):(0*32+16)>
;  RWWUF 
;   372 : #define NV_AUDOUT_AE_POSITION                   (1*32+31):(1*32+ 0) /* RWWUF */
NV_AUDOUT_AE_POSITION           TEXTEQU         <(1*32+31):(1*32+ 0)>
;  RWWUF 
;   373 : #define NV_AUDOUT_AE_VOLUME_1                   (2*32+15):(2*32+ 0) /* RWWUF */
NV_AUDOUT_AE_VOLUME_1           TEXTEQU         <(2*32+15):(2*32+ 0)>
;  RWWUF 
;   374 : #define NV_AUDOUT_AE_VOLUME_0                   (2*32+31):(2*32+16) /* RWWUF */
NV_AUDOUT_AE_VOLUME_0           TEXTEQU         <(2*32+31):(2*32+16)>
;  RWWUF 
;   375 : #define NV_AUDOUT_RM_VOLUME_0                   (3*32+15):(3*32+ 0) /* RWWUF */
NV_AUDOUT_RM_VOLUME_0           TEXTEQU         <(3*32+15):(3*32+ 0)>
;  RWWUF 
;   376 : #define NV_AUDOUT_SU_VOLUME_0                   (3*32+31):(3*32+16) /* RWWUF */
NV_AUDOUT_SU_VOLUME_0           TEXTEQU         <(3*32+31):(3*32+16)>
;  RWWUF 
;   377 : #define NV_AUDOUT_RM_VOLUME_1                   (4*32+15):(4*32+ 0) /* RWWUF */
NV_AUDOUT_RM_VOLUME_1           TEXTEQU         <(4*32+15):(4*32+ 0)>
;  RWWUF 
;   378 : #define NV_AUDOUT_SU_VOLUME_1                   (4*32+31):(4*32+16) /* RWWUF */
NV_AUDOUT_SU_VOLUME_1           TEXTEQU         <(4*32+31):(4*32+16)>
;  RWWUF 
;   379 : #define NV_AUDOUT_AE_POSITION_INC               (5*32+31):(5*32+ 0) /* RWWUF */
NV_AUDOUT_AE_POSITION_INC               TEXTEQU         <(5*32+31):(5*32+ 0)>
;  RWWUF 
;   380 : #define NV_AUDOUT_RM_NEXT_INSTANCE              (6*32+31):(6*32+ 0) /* RWWUF */
NV_AUDOUT_RM_NEXT_INSTANCE              TEXTEQU         <(6*32+31):(6*32+ 0)>
;  RWWVF 
;   381 : #define NV_AUDOUT_RM_STATE                      (7*32+15):(7*32+ 0) /* RWWVF */
NV_AUDOUT_RM_STATE              TEXTEQU         <(7*32+15):(7*32+ 0)>
;  RWWVF 
;   382 : #define NV_AUDOUT_SU_STATE                      (8*32+15):(8*32+ 0) /* RWWVF */
NV_AUDOUT_SU_STATE              TEXTEQU         <(8*32+15):(8*32+ 0)>
;  RWWUF 
;   383 : #define NV_AUDOUT_SU_START_TIME_LOW             (8*32+31):(8*32+16) /* RWWUF */
NV_AUDOUT_SU_START_TIME_LOW             TEXTEQU         <(8*32+31):(8*32+16)>
;  RWWUF 
;   384 : #define NV_AUDOUT_SU_START_TIME_HIGH            (9*32+31):(9*32+ 0) /* RWWUF */
NV_AUDOUT_SU_START_TIME_HIGH            TEXTEQU         <(9*32+31):(9*32+ 0)>
;  RWWUF 
;   385 : #define NV_AUDOUT_SU_BUFF0_DMA_INSTANCE       (10*32+15):(10*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF0_DMA_INSTANCE         TEXTEQU         <(10*32+15):(10*32+ 0)>
;  RWWUF 
;   386 : #define NV_AUDOUT_SU_BUFF1_DMA_INSTANCE       (10*32+31):(10*32+16) /* RWWUF */
NV_AUDOUT_SU_BUFF1_DMA_INSTANCE         TEXTEQU         <(10*32+31):(10*32+16)>
;  RWWUF 
;   387 : #define NV_AUDOUT_SU_BUFF0_START_POSITION     (11*32+31):(11*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF0_START_POSITION               TEXTEQU         <(11*32+31):(11*32+ 0)>
;  RWWUF 
;   388 : #define NV_AUDOUT_SU_BUFF0_LAST_PLUS1         (12*32+31):(12*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF0_LAST_PLUS1           TEXTEQU         <(12*32+31):(12*32+ 0)>
;  RWWUF 
;   389 : #define NV_AUDOUT_SU_BUFF1_START_POSITION     (13*32+31):(13*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF1_START_POSITION               TEXTEQU         <(13*32+31):(13*32+ 0)>
;  RWWUF 
;   390 : #define NV_AUDOUT_SU_BUFF1_LAST_PLUS1         (14*32+31):(14*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF1_LAST_PLUS1           TEXTEQU         <(14*32+31):(14*32+ 0)>
;  RWXVF 
;   391 : #define NV_AUDOUT_AE_INTR_MIXING              ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
NV_AUDOUT_AE_INTR_MIXING                TEXTEQU         <( 0*32+ 0):( 0*32+ 0)>
;  RWXVF 
;   392 : #define NV_AUDOUT_AE_INTR_VOLUME              ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
NV_AUDOUT_AE_INTR_VOLUME                TEXTEQU         <( 0*32+ 1):( 0*32+ 1)>
;  RWXVF 
;   393 : #define NV_AUDOUT_AE_EVENT_START              ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
NV_AUDOUT_AE_EVENT_START                TEXTEQU         <( 0*32+ 3):( 0*32+ 3)>
;  RWXVF 
;   394 : #define NV_AUDOUT_AE_BUFF0_INTR_NOTIFY        ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
NV_AUDOUT_AE_BUFF0_INTR_NOTIFY          TEXTEQU         <( 0*32+ 4):( 0*32+ 4)>
;  RWXVF 
;   395 : #define NV_AUDOUT_AE_BUFF1_INTR_NOTIFY        ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
NV_AUDOUT_AE_BUFF1_INTR_NOTIFY          TEXTEQU         <( 0*32+ 5):( 0*32+ 5)>
;  RWXVF 
;   396 : #define NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP     ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP               TEXTEQU         <( 0*32+ 6):( 0*32+ 6)>
;  RWXVF 
;   397 : #define NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP     ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP               TEXTEQU         <( 0*32+ 7):( 0*32+ 7)>
;  RWXVF 
;   398 : #define NV_AUDOUT_AE_BUFF0_IN_USE             ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
NV_AUDOUT_AE_BUFF0_IN_USE               TEXTEQU         <( 0*32+ 8):( 0*32+ 8)>
;  RWXVF 
;   399 : #define NV_AUDOUT_AE_BUFF1_IN_USE             ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
NV_AUDOUT_AE_BUFF1_IN_USE               TEXTEQU         <( 0*32+ 9):( 0*32+ 9)>
;  RWXVF 
;   400 : #define NV_AUDOUT_AE_GAP_DETECT               ( 0*32+10):( 0*32+10) /* RWXVF */
NV_AUDOUT_AE_GAP_DETECT         TEXTEQU         <( 0*32+10):( 0*32+10)>
;  RWXVF 
;   401 : #define NV_AUDOUT_AE_INTR_DMA                 ( 0*32+11):( 0*32+11) /* RWXVF */
NV_AUDOUT_AE_INTR_DMA           TEXTEQU         <( 0*32+11):( 0*32+11)>
;  RWXVF 
;   402 : #define NV_AUDOUT_AE_CURRENT_BUFFER           ( 0*32+12):( 0*32+12) /* RWXVF */
NV_AUDOUT_AE_CURRENT_BUFFER             TEXTEQU         <( 0*32+12):( 0*32+12)>
;  RW--V 
;   403 : #define NV_AUDOUT_AE_CURRENT_BUFFER_0                    0x00000000 /* RW--V */
NV_AUDOUT_AE_CURRENT_BUFFER_0           EQU             000000000h
;  RW--V 
;   404 : #define NV_AUDOUT_AE_CURRENT_BUFFER_1                    0x00000001 /* RW--V */
NV_AUDOUT_AE_CURRENT_BUFFER_1           EQU             000000001h
;  RWXVF 
;   405 : #define NV_AUDOUT_RM_INTR_MIXING              (15*32+ 0):(15*32+ 0) /* RWXVF */
NV_AUDOUT_RM_INTR_MIXING                TEXTEQU         <(15*32+ 0):(15*32+ 0)>
;  RWXVF 
;   406 : #define NV_AUDOUT_RM_INTR_VOLUME              (15*32+ 1):(15*32+ 1) /* RWXVF */
NV_AUDOUT_RM_INTR_VOLUME                TEXTEQU         <(15*32+ 1):(15*32+ 1)>
;  RWXVF 
;   407 : #define NV_AUDOUT_RM_BUFF0_INTR_NOTIFY        (15*32+ 4):(15*32+ 4) /* RWXVF */
NV_AUDOUT_RM_BUFF0_INTR_NOTIFY          TEXTEQU         <(15*32+ 4):(15*32+ 4)>
;  RWXVF 
;   408 : #define NV_AUDOUT_RM_BUFF1_INTR_NOTIFY        (15*32+ 5):(15*32+ 5) /* RWXVF */
NV_AUDOUT_RM_BUFF1_INTR_NOTIFY          TEXTEQU         <(15*32+ 5):(15*32+ 5)>
;  RWXVF 
;   409 : #define NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP     (15*32+ 6):(15*32+ 6) /* RWXVF */
NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP               TEXTEQU         <(15*32+ 6):(15*32+ 6)>
;  RWXVF 
;   410 : #define NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP     (15*32+ 7):(15*32+ 7) /* RWXVF */
NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP               TEXTEQU         <(15*32+ 7):(15*32+ 7)>
;  RWXVF 
;   411 : #define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
NV_AUDOUT_SU_BUFF0_OFFSET               TEXTEQU         <(16*32+ 1):(16*32+ 0)>
;  RWXVF 
;   412 : #define NV_AUDOUT_SU_BUFF1_OFFSET             (16*32+ 3):(16*32+ 2) /* RWXVF */
NV_AUDOUT_SU_BUFF1_OFFSET               TEXTEQU         <(16*32+ 3):(16*32+ 2)>
;  RWXVF 
;   413 : #define NV_AUDOUT_SU_BYPASS_PTE               (16*32+ 4):(16*32+ 4) /* RWXVF */
NV_AUDOUT_SU_BYPASS_PTE         TEXTEQU         <(16*32+ 4):(16*32+ 4)>
;  RW--V 
;   414 : #define NV_AUDOUT_SU_BYPASS_PTE_DISABLED                 0x00000000 /* RW--V */
NV_AUDOUT_SU_BYPASS_PTE_DISABLED                EQU             000000000h
;  RW--V 
;   415 : #define NV_AUDOUT_SU_BYPASS_PTE_ENABLED                  0x00000001 /* RW--V */
NV_AUDOUT_SU_BYPASS_PTE_ENABLED         EQU             000000001h
;  RWXVF 
;   416 : #define NV_AUDOUT_SU_BYPASS_TARGET            (16*32+ 6):(16*32+ 5) /* RWXVF */
NV_AUDOUT_SU_BYPASS_TARGET              TEXTEQU         <(16*32+ 6):(16*32+ 5)>
;  RW--V 
;   417 : #define NV_AUDOUT_SU_BYPASS_TARGET_NVM                   0x00000000 /* RW--V */
NV_AUDOUT_SU_BYPASS_TARGET_NVM          EQU             000000000h
;  RW--V 
;   418 : #define NV_AUDOUT_SU_BYPASS_TARGET_PCI                   0x00000002 /* RW--V */
NV_AUDOUT_SU_BYPASS_TARGET_PCI          EQU             000000002h
;  RW--V 
;   419 : #define NV_AUDOUT_SU_BYPASS_TARGET_AGP                   0x00000003 /* RW--V */
NV_AUDOUT_SU_BYPASS_TARGET_AGP          EQU             000000003h
;  RWXVF 
;   420 : #define NV_AUDOUT_SU_BUFF0_IN_USE             (16*32+ 8):(16*32+ 8) /* RWXVF */
NV_AUDOUT_SU_BUFF0_IN_USE               TEXTEQU         <(16*32+ 8):(16*32+ 8)>
;  RWXVF 
;   421 : #define NV_AUDOUT_SU_BUFF1_IN_USE             (16*32+ 9):(16*32+ 9) /* RWXVF */
NV_AUDOUT_SU_BUFF1_IN_USE               TEXTEQU         <(16*32+ 9):(16*32+ 9)>
;  RWXVF 
;   422 : #define NV_AUDOUT_SU_BUFF0_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
NV_AUDOUT_SU_BUFF0_NOTIFY               TEXTEQU         <(16*32+10):(16*32+10)>
;  RW--V 
;   423 : #define NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE             EQU             000000000h
;  RW--V 
;   424 : #define NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT             EQU             000000001h
;  RWXVF 
;   425 : #define NV_AUDOUT_SU_BUFF1_NOTIFY             (16*32+11):(16*32+11) /* RWXVF */
NV_AUDOUT_SU_BUFF1_NOTIFY               TEXTEQU         <(16*32+11):(16*32+11)>
;  RW--V 
;   426 : #define NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE             EQU             000000000h
;  RW--V 
;   427 : #define NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT             EQU             000000001h
;  RWXVF 
;   428 : #define NV_AUDOUT_SU_CHANNEL                  (16*32+12):(16*32+12) /* RWXVF */
NV_AUDOUT_SU_CHANNEL            TEXTEQU         <(16*32+12):(16*32+12)>
;  RW--V 
;   429 : #define NV_AUDOUT_SU_CHANNEL_MONO                        0x00000000 /* RW--V */
NV_AUDOUT_SU_CHANNEL_MONO               EQU             000000000h
;  RW--V 
;   430 : #define NV_AUDOUT_SU_CHANNEL_STEREO                      0x00000001 /* RW--V */
NV_AUDOUT_SU_CHANNEL_STEREO             EQU             000000001h
;  RWXVF 
;   431 : #define NV_AUDOUT_SU_FORMAT                   (16*32+15):(16*32+13) /* RWXVF */
NV_AUDOUT_SU_FORMAT             TEXTEQU         <(16*32+15):(16*32+13)>
;  RW--V 
;   432 : #define NV_AUDOUT_SU_FORMAT_LINEAR                       0x00000000 /* RW--V */
NV_AUDOUT_SU_FORMAT_LINEAR              EQU             000000000h
;  RW--V 
;   433 : #define NV_AUDOUT_SU_FORMAT_ULAW                         0x00000001 /* RW--V */
NV_AUDOUT_SU_FORMAT_ULAW                EQU             000000001h
;  RW--V 
;   434 : #define NV_AUDOUT_SU_FORMAT_ALAW                         0x00000002 /* RW--V */
NV_AUDOUT_SU_FORMAT_ALAW                EQU             000000002h
;  RW--V 
;   435 : #define NV_AUDOUT_SU_FORMAT_OFFSET8                      0x00000003 /* RW--V */
NV_AUDOUT_SU_FORMAT_OFFSET8             EQU             000000003h
;  RWXVF 
;  dev_ram.ref 
;  RW--M 
;   436 : #define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
;   437 : /* dev_ram.ref */
;   438 : #define NV_AUDNOTE                            0x00000083:0x00000000 /* RW--M */
NV_AUDNOTE              TEXTEQU         <0x00000083:0x00000000>
;  RWWVF 
;   439 : #define NV_AUDNOTE_AE_STATE                     (0*32+15):(0*32+ 0) /* RWWVF */
NV_AUDNOTE_AE_STATE             TEXTEQU         <(0*32+15):(0*32+ 0)>
;  RWWUF 
;   440 : #define NV_AUDNOTE_AE_POSITION_LOW              (0*32+31):(0*32+16) /* RWWUF */
NV_AUDNOTE_AE_POSITION_LOW              TEXTEQU         <(0*32+31):(0*32+16)>
;  RWWUF 
;   441 : #define NV_AUDNOTE_AE_POSITION                  (1*32+31):(1*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_POSITION          TEXTEQU         <(1*32+31):(1*32+ 0)>
;  RWWUF 
;   442 : #define NV_AUDNOTE_AE_POSITION_INC              (2*32+31):(2*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_POSITION_INC              TEXTEQU         <(2*32+31):(2*32+ 0)>
;  RWWUF 
;   443 : #define NV_AUDNOTE_AE_EG_ADSR_LEVEL             (3*32+31):(3*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_EG_ADSR_LEVEL             TEXTEQU         <(3*32+31):(3*32+ 0)>
;  RWWUF 
;   444 : #define NV_AUDNOTE_AE_PE_ADSR_LEVEL             (4*32+31):(4*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_PE_ADSR_LEVEL             TEXTEQU         <(4*32+31):(4*32+ 0)>
;  RWWUF 
;   445 : #define NV_AUDNOTE_AE_ADSR_VOLUME               (5*32+15):(5*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_ADSR_VOLUME               TEXTEQU         <(5*32+15):(5*32+ 0)>
;  RWWUF 
;   446 : #define NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL     (5*32+31):(5*32+16) /* RWWUF */
NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL             TEXTEQU         <(5*32+31):(5*32+16)>
;  RWWUF 
;   447 : #define NV_AUDNOTE_AE_VIBRATO_POSITION          (6*32+31):(6*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_VIBRATO_POSITION          TEXTEQU         <(6*32+31):(6*32+ 0)>
;  RWWUF 
;   448 : #define NV_AUDNOTE_AE_TREMOLO_POSITION          (7*32+31):(7*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_TREMOLO_POSITION          TEXTEQU         <(7*32+31):(7*32+ 0)>
;  RWWUF 
;   449 : #define NV_AUDNOTE_AE_VOLUME_1                  (8*32+15):(8*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_VOLUME_1          TEXTEQU         <(8*32+15):(8*32+ 0)>
;  RWWUF 
;   450 : #define NV_AUDNOTE_AE_VOLUME_0                  (8*32+31):(8*32+16) /* RWWUF */
NV_AUDNOTE_AE_VOLUME_0          TEXTEQU         <(8*32+31):(8*32+16)>
;  RWWUF 
;   451 : #define NV_AUDNOTE_RM_NEXT_INSTANCE             (9*32+31):(9*32+ 0) /* RWWUF */
NV_AUDNOTE_RM_NEXT_INSTANCE             TEXTEQU         <(9*32+31):(9*32+ 0)>
;  RWWUF 
;   452 : #define NV_AUDNOTE_RM_VOLUME_0                (10*32+15):(10*32+ 0) /* RWWUF */
NV_AUDNOTE_RM_VOLUME_0          TEXTEQU         <(10*32+15):(10*32+ 0)>
;  RWWUF 
;   453 : #define NV_AUDNOTE_SU_VOLUME_0                (10*32+31):(10*32+16) /* RWWUF */
NV_AUDNOTE_SU_VOLUME_0          TEXTEQU         <(10*32+31):(10*32+16)>
;  RWWUF 
;   454 : #define NV_AUDNOTE_RM_VOLUME_1                (11*32+15):(11*32+ 0) /* RWWUF */
NV_AUDNOTE_RM_VOLUME_1          TEXTEQU         <(11*32+15):(11*32+ 0)>
;  RWWUF 
;   455 : #define NV_AUDNOTE_SU_VOLUME_1                (11*32+31):(11*32+16) /* RWWUF */
NV_AUDNOTE_SU_VOLUME_1          TEXTEQU         <(11*32+31):(11*32+16)>
;  RWWVF 
;   456 : #define NV_AUDNOTE_RM_STATE                   (12*32+15):(12*32+ 0) /* RWWVF */
NV_AUDNOTE_RM_STATE             TEXTEQU         <(12*32+15):(12*32+ 0)>
;  RWWUF 
;   457 : #define NV_AUDNOTE_SU_STOP_TIME_LOW           (12*32+31):(12*32+16) /* RWWUF */
NV_AUDNOTE_SU_STOP_TIME_LOW             TEXTEQU         <(12*32+31):(12*32+16)>
;  RWWVF 
;   458 : #define NV_AUDNOTE_SU_STATE                   (13*32+15):(13*32+ 0) /* RWWVF */
NV_AUDNOTE_SU_STATE             TEXTEQU         <(13*32+15):(13*32+ 0)>
;  RWWUF 
;   459 : #define NV_AUDNOTE_SU_START_TIME_LOW          (13*32+31):(13*32+16) /* RWWUF */
NV_AUDNOTE_SU_START_TIME_LOW            TEXTEQU         <(13*32+31):(13*32+16)>
;  RWWUF 
;   460 : #define NV_AUDNOTE_SU_START_TIME_HIGH         (14*32+31):(14*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_START_TIME_HIGH           TEXTEQU         <(14*32+31):(14*32+ 0)>
;  RWWUF 
;   461 : #define NV_AUDNOTE_SU_STOP_TIME_HIGH          (15*32+31):(15*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_STOP_TIME_HIGH            TEXTEQU         <(15*32+31):(15*32+ 0)>
;  RWWVF 
;   462 : #define NV_AUDNOTE_SU_FM_STATE                (16*32+15):(16*32+ 0) /* RWWVF */
NV_AUDNOTE_SU_FM_STATE          TEXTEQU         <(16*32+15):(16*32+ 0)>
;  RWWUF 
;   463 : #define NV_AUDNOTE_SU_RELEASE_TIME_LOW        (16*32+31):(16*32+16) /* RWWUF */
NV_AUDNOTE_SU_RELEASE_TIME_LOW          TEXTEQU         <(16*32+31):(16*32+16)>
;  RWWUF 
;   464 : #define NV_AUDNOTE_SU_DMA_INSTANCE            (17*32+15):(17*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_DMA_INSTANCE              TEXTEQU         <(17*32+15):(17*32+ 0)>
;  RWWUF 
;   465 : #define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO (17*32+31):(17*32+16) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO           TEXTEQU         <(17*32+31):(17*32+16)>
;  RWWUF 
;   466 : #define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI (18*32+31):(18*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI           TEXTEQU         <(18*32+31):(18*32+ 0)>
;  RWWUF 
;   467 : #define NV_AUDNOTE_SU_RELEASE_TIME_HIGH       (19*32+31):(19*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_RELEASE_TIME_HIGH         TEXTEQU         <(19*32+31):(19*32+ 0)>
;  RWWUF 
;   468 : #define NV_AUDNOTE_SU_POSITION_INC            (20*32+31):(20*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_POSITION_INC              TEXTEQU         <(20*32+31):(20*32+ 0)>
;  RWWUF 
;   469 : #define NV_AUDNOTE_SU_LOOP_START              (21*32+31):(21*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_LOOP_START                TEXTEQU         <(21*32+31):(21*32+ 0)>
;  RWWUF 
;   470 : #define NV_AUDNOTE_SU_LOOP_END_PLUS1          (22*32+31):(22*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_LOOP_END_PLUS1            TEXTEQU         <(22*32+31):(22*32+ 0)>
;  RWWUF 
;   471 : #define NV_AUDNOTE_SU_LAST_PLUS1              (23*32+31):(23*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_LAST_PLUS1                TEXTEQU         <(23*32+31):(23*32+ 0)>
;  RWWUF 
;   472 : #define NV_AUDNOTE_SU_EG_ATTACK_RATE          (24*32+15):(24*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_EG_ATTACK_RATE            TEXTEQU         <(24*32+15):(24*32+ 0)>
;  RWWUF 
;   473 : #define NV_AUDNOTE_SU_EG_DECAY_RATE           (24*32+31):(24*32+16) /* RWWUF */
NV_AUDNOTE_SU_EG_DECAY_RATE             TEXTEQU         <(24*32+31):(24*32+16)>
;  RWWUF 
;   474 : #define NV_AUDNOTE_SU_EG_SUSTAIN_RATE         (25*32+15):(25*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_EG_SUSTAIN_RATE           TEXTEQU         <(25*32+15):(25*32+ 0)>
;  RWWUF 
;   475 : #define NV_AUDNOTE_SU_EG_RELEASE_RATE         (25*32+31):(25*32+16) /* RWWUF */
NV_AUDNOTE_SU_EG_RELEASE_RATE           TEXTEQU         <(25*32+31):(25*32+16)>
;  RWWUF 
;   476 : #define NV_AUDNOTE_SU_PE_ATTACK_RATE          (26*32+15):(26*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_PE_ATTACK_RATE            TEXTEQU         <(26*32+15):(26*32+ 0)>
;  RWWUF 
;   477 : #define NV_AUDNOTE_SU_PE_DECAY_RATE           (26*32+31):(26*32+16) /* RWWUF */
NV_AUDNOTE_SU_PE_DECAY_RATE             TEXTEQU         <(26*32+31):(26*32+16)>
;  RWWUF 
;   478 : #define NV_AUDNOTE_SU_PE_SUSTAIN_RATE         (27*32+15):(27*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_PE_SUSTAIN_RATE           TEXTEQU         <(27*32+15):(27*32+ 0)>
;  RWWUF 
;   479 : #define NV_AUDNOTE_SU_PE_RELEASE_RATE         (27*32+31):(27*32+16) /* RWWUF */
NV_AUDNOTE_SU_PE_RELEASE_RATE           TEXTEQU         <(27*32+31):(27*32+16)>
;  RWWUF 
;   480 : #define NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK  (28*32+15):(28*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK            TEXTEQU         <(28*32+15):(28*32+ 0)>
;  RWWUF 
;   481 : #define NV_AUDNOTE_SU_VIBRATO_DEPTH           (29*32+15):(29*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_DEPTH             TEXTEQU         <(29*32+15):(29*32+ 0)>
;  RWWUF 
;   482 : #define NV_AUDNOTE_SU_EG_SUSTAIN_LEVEL        (29*32+31):(29*32+16) /* RWWUF */
NV_AUDNOTE_SU_EG_SUSTAIN_LEVEL          TEXTEQU         <(29*32+31):(29*32+16)>
;  RWWUF 
;   483 : #define NV_AUDNOTE_SU_PE_SCALE                (30*32+15):(30*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_PE_SCALE          TEXTEQU         <(30*32+15):(30*32+ 0)>
;  RWWUF 
;   484 : #define NV_AUDNOTE_SU_PE_SUSTAIN_LEVEL        (30*32+31):(30*32+16) /* RWWUF */
NV_AUDNOTE_SU_PE_SUSTAIN_LEVEL          TEXTEQU         <(30*32+31):(30*32+16)>
;  RWWUF 
;   485 : #define NV_AUDNOTE_SU_TREMOLO_POSITION_INC    (31*32+15):(31*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_TREMOLO_POSITION_INC              TEXTEQU         <(31*32+15):(31*32+ 0)>
;  RWWUF 
;   486 : #define NV_AUDNOTE_SU_VIBRATO_POSITION_INC    (31*32+31):(31*32+16) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_POSITION_INC              TEXTEQU         <(31*32+31):(31*32+16)>
;  RWWUF 
;   487 : #define NV_AUDNOTE_SU_TREMOLO_DEPTH           (32*32+15):(32*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_TREMOLO_DEPTH             TEXTEQU         <(32*32+15):(32*32+ 0)>
;  RWWUF 
;   488 : #define NV_AUDNOTE_SU_TREMOLO_OFFSET          (32*32+31):(32*32+16) /* RWWUF */
NV_AUDNOTE_SU_TREMOLO_OFFSET            TEXTEQU         <(32*32+31):(32*32+16)>
;  RWXVF 
;   489 : #define NV_AUDNOTE_AE_INTR_MIXING             ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
NV_AUDNOTE_AE_INTR_MIXING               TEXTEQU         <( 0*32+ 0):( 0*32+ 0)>
;  RWXVF 
;   490 : #define NV_AUDNOTE_AE_INTR_VOLUME             ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
NV_AUDNOTE_AE_INTR_VOLUME               TEXTEQU         <( 0*32+ 1):( 0*32+ 1)>
;  RWXVF 
;   491 : #define NV_AUDNOTE_AE_EVENT_STOP              ( 0*32+ 2):( 0*32+ 2) /* RWXVF */
NV_AUDNOTE_AE_EVENT_STOP                TEXTEQU         <( 0*32+ 2):( 0*32+ 2)>
;  RWXVF 
;   492 : #define NV_AUDNOTE_AE_EVENT_START             ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
NV_AUDNOTE_AE_EVENT_START               TEXTEQU         <( 0*32+ 3):( 0*32+ 3)>
;  RWXVF 
;   493 : #define NV_AUDNOTE_AE_INTR_NOTIFY             ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
NV_AUDNOTE_AE_INTR_NOTIFY               TEXTEQU         <( 0*32+ 4):( 0*32+ 4)>
;  RWXVF 
;   494 : #define NV_AUDNOTE_AE_PE_STATE                ( 0*32+ 7):( 0*32+ 6) /* RWXVF */
NV_AUDNOTE_AE_PE_STATE          TEXTEQU         <( 0*32+ 7):( 0*32+ 6)>
;  RW--V 
;   495 : #define NV_AUDNOTE_AE_PE_ATTACK                          0x00000000 /* RW--V */
NV_AUDNOTE_AE_PE_ATTACK         EQU             000000000h
;  RW--V 
;   496 : #define NV_AUDNOTE_AE_PE_DECAY                           0x00000001 /* RW--V */
NV_AUDNOTE_AE_PE_DECAY          EQU             000000001h
;  RW--V 
;   497 : #define NV_AUDNOTE_AE_PE_SUSTAIN                         0x00000002 /* RW--V */
NV_AUDNOTE_AE_PE_SUSTAIN                EQU             000000002h
;  RW--V 
;   498 : #define NV_AUDNOTE_AE_PE_RELEASE                         0x00000003 /* RW--V */
NV_AUDNOTE_AE_PE_RELEASE                EQU             000000003h
;  RWXVF 
;   499 : #define NV_AUDNOTE_AE_IN_USE                  ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
NV_AUDNOTE_AE_IN_USE            TEXTEQU         <( 0*32+ 8):( 0*32+ 8)>
;  RWXVF 
;   500 : #define NV_AUDNOTE_AE_GAP_DETECT              ( 0*32+10):( 0*32+10) /* RWXVF */
NV_AUDNOTE_AE_GAP_DETECT                TEXTEQU         <( 0*32+10):( 0*32+10)>
;  RWXVF 
;   501 : #define NV_AUDNOTE_AE_INTR_DMA                ( 0*32+11):( 0*32+11) /* RWXVF */
NV_AUDNOTE_AE_INTR_DMA          TEXTEQU         <( 0*32+11):( 0*32+11)>
;  RWXVF 
;   502 : #define NV_AUDNOTE_AE_EG_STATE                ( 0*32+14):( 0*32+13) /* RWXVF */
NV_AUDNOTE_AE_EG_STATE          TEXTEQU         <( 0*32+14):( 0*32+13)>
;  RW--V 
;   503 : #define NV_AUDNOTE_AE_EG_ATTACK                          0x00000000 /* RW--V */
NV_AUDNOTE_AE_EG_ATTACK         EQU             000000000h
;  RW--V 
;   504 : #define NV_AUDNOTE_AE_EG_DECAY                           0x00000001 /* RW--V */
NV_AUDNOTE_AE_EG_DECAY          EQU             000000001h
;  RW--V 
;   505 : #define NV_AUDNOTE_AE_EG_SUSTAIN                         0x00000002 /* RW--V */
NV_AUDNOTE_AE_EG_SUSTAIN                EQU             000000002h
;  RW--V 
;   506 : #define NV_AUDNOTE_AE_EG_RELEASE                         0x00000003 /* RW--V */
NV_AUDNOTE_AE_EG_RELEASE                EQU             000000003h
;  RWXVF 
;   507 : #define NV_AUDNOTE_AE_POS_VALID               ( 0*32+15):( 0*32+15) /* RWXVF */
NV_AUDNOTE_AE_POS_VALID         TEXTEQU         <( 0*32+15):( 0*32+15)>
;  RWXVF 
;   508 : #define NV_AUDNOTE_RM_INTR_MIXING             (14*32+ 0):(14*32+ 0) /* RWXVF */
NV_AUDNOTE_RM_INTR_MIXING               TEXTEQU         <(14*32+ 0):(14*32+ 0)>
;  RWXVF 
;   509 : #define NV_AUDNOTE_RM_INTR_VOLUME             (14*32+ 1):(14*32+ 1) /* RWXVF */
NV_AUDNOTE_RM_INTR_VOLUME               TEXTEQU         <(14*32+ 1):(14*32+ 1)>
;  RWXVF 
;   510 : #define NV_AUDNOTE_RM_INTR_NOTIFY             (14*32+ 4):(14*32+ 4) /* RWXVF */
NV_AUDNOTE_RM_INTR_NOTIFY               TEXTEQU         <(14*32+ 4):(14*32+ 4)>
;  RWXVF 
;   511 : #define NV_AUDNOTE_SU_BYPASS_PTE              (12*32+ 4):(12*32+ 4) /* RWXVF */
NV_AUDNOTE_SU_BYPASS_PTE                TEXTEQU         <(12*32+ 4):(12*32+ 4)>
;  RW--V 
;   512 : #define NV_AUDNOTE_SU_BYPASS_PTE_DISABLED                0x00000000 /* RW--V */
NV_AUDNOTE_SU_BYPASS_PTE_DISABLED               EQU             000000000h
;  RW--V 
;   513 : #define NV_AUDNOTE_SU_BYPASS_PTE_ENABLED                 0x00000001 /* RW--V */
NV_AUDNOTE_SU_BYPASS_PTE_ENABLED                EQU             000000001h
;  RWXVF 
;   514 : #define NV_AUDNOTE_SU_BYPASS_TARGET           (12*32+ 6):(12*32+ 5) /* RWXVF */
NV_AUDNOTE_SU_BYPASS_TARGET             TEXTEQU         <(12*32+ 6):(12*32+ 5)>
;  RW--V 
;   515 : #define NV_AUDNOTE_SU_BYPASS_TARGET_NVM                  0x00000000 /* RW--V */
NV_AUDNOTE_SU_BYPASS_TARGET_NVM         EQU             000000000h
;  RW--V 
;   516 : #define NV_AUDNOTE_SU_BYPASS_TARGET_PCI                  0x00000002 /* RW--V */
NV_AUDNOTE_SU_BYPASS_TARGET_PCI         EQU             000000002h
;  RW--V 
;   517 : #define NV_AUDNOTE_SU_BYPASS_TARGET_AGP                  0x00000003 /* RW--V */
NV_AUDNOTE_SU_BYPASS_TARGET_AGP         EQU             000000003h
;  RWXVF 
;   518 : #define NV_AUDNOTE_SU_EG_LINEAR               (12*32+ 7):(12*32+ 7) /* RWXVF */
NV_AUDNOTE_SU_EG_LINEAR         TEXTEQU         <(12*32+ 7):(12*32+ 7)>
;  RW--V 
;   519 : #define NV_AUDNOTE_SU_EG_ATCK_NV1                        0x00000000 /* RW--V */
NV_AUDNOTE_SU_EG_ATCK_NV1               EQU             000000000h
;  RW--V 
;   520 : #define NV_AUDNOTE_SU_EG_ATCK_LINEAR                     0x00000001 /* RW--V */
NV_AUDNOTE_SU_EG_ATCK_LINEAR            EQU             000000001h
;  RWXVF 
;   521 : #define NV_AUDNOTE_SU_IN_USE                  (12*32+ 8):(12*32+ 8) /* RWXVF */
NV_AUDNOTE_SU_IN_USE            TEXTEQU         <(12*32+ 8):(12*32+ 8)>
;  RWXVF 
;   522 : #define NV_AUDNOTE_SU_BUFF_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
NV_AUDNOTE_SU_BUFF_NOTIFY               TEXTEQU         <(16*32+10):(16*32+10)>
;  RW--V 
;   523 : #define NV_AUDNOTE_SU_BUFF_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
NV_AUDNOTE_SU_BUFF_NOTIFY_DMA_WRITE             EQU             000000000h
;  RW--V 
;   524 : #define NV_AUDNOTE_SU_BUFF_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
NV_AUDNOTE_SU_BUFF_NOTIFY_INTERRUPT             EQU             000000001h
;  RWXVF 
;   525 : #define NV_AUDNOTE_SU_CHANNEL                 (12*32+12):(12*32+12) /* RWXVF */
NV_AUDNOTE_SU_CHANNEL           TEXTEQU         <(12*32+12):(12*32+12)>
;  RW--V 
;   526 : #define NV_AUDNOTE_SU_CHANNEL_MONO                       0x00000000 /* RW--V */
NV_AUDNOTE_SU_CHANNEL_MONO              EQU             000000000h
;  RW--V 
;   527 : #define NV_AUDNOTE_SU_CHANNEL_STEREO                     0x00000001 /* RW--V */
NV_AUDNOTE_SU_CHANNEL_STEREO            EQU             000000001h
;  RWXVF 
;   528 : #define NV_AUDNOTE_SU_FORMAT                  (12*32+15):(12*32+13) /* RWXVF */
NV_AUDNOTE_SU_FORMAT            TEXTEQU         <(12*32+15):(12*32+13)>
;  RW--V 
;   529 : #define NV_AUDNOTE_SU_FORMAT_LINEAR                      0x00000000 /* RW--V */
NV_AUDNOTE_SU_FORMAT_LINEAR             EQU             000000000h
;  RW--V 
;   530 : #define NV_AUDNOTE_SU_FORMAT_ULAW                        0x00000001 /* RW--V */
NV_AUDNOTE_SU_FORMAT_ULAW               EQU             000000001h
;  RW--V 
;   531 : #define NV_AUDNOTE_SU_FORMAT_ALAW                        0x00000002 /* RW--V */
NV_AUDNOTE_SU_FORMAT_ALAW               EQU             000000002h
;  RW--V 
;   532 : #define NV_AUDNOTE_SU_FORMAT_OFFSET8                     0x00000003 /* RW--V */
NV_AUDNOTE_SU_FORMAT_OFFSET8            EQU             000000003h
;  RWXVF 
;   533 : #define NV_AUDNOTE_FM_FEEDBACK                (15*32+ 6):(15*32+ 4) /* RWXVF */
NV_AUDNOTE_FM_FEEDBACK          TEXTEQU         <(15*32+ 6):(15*32+ 4)>
;  RW--V 
;   534 : #define NV_AUDNOTE_FM_FB_0                               0x00000000 /* RW--V */
NV_AUDNOTE_FM_FB_0              EQU             000000000h
;  RW--V 
;   535 : #define NV_AUDNOTE_FM_FB_PI_16                           0x00000001 /* RW--V */
NV_AUDNOTE_FM_FB_PI_16          EQU             000000001h
;  RW--V 
;   536 : #define NV_AUDNOTE_FM_FB_PI_8                            0x00000002 /* RW--V */
NV_AUDNOTE_FM_FB_PI_8           EQU             000000002h
;  RW--V 
;   537 : #define NV_AUDNOTE_FM_FB_PI_4                            0x00000003 /* RW--V */
NV_AUDNOTE_FM_FB_PI_4           EQU             000000003h
;  RW--V 
;   538 : #define NV_AUDNOTE_FM_FB_PI_2                            0x00000004 /* RW--V */
NV_AUDNOTE_FM_FB_PI_2           EQU             000000004h
;  RW--V 
;   539 : #define NV_AUDNOTE_FM_FB_1_PI                            0x00000005 /* RW--V */
NV_AUDNOTE_FM_FB_1_PI           EQU             000000005h
;  RW--V 
;   540 : #define NV_AUDNOTE_FM_FB_2_PI                            0x00000006 /* RW--V */
NV_AUDNOTE_FM_FB_2_PI           EQU             000000006h
;  RW--V 
;   541 : #define NV_AUDNOTE_FM_FB_4_PI                            0x00000007 /* RW--V */
NV_AUDNOTE_FM_FB_4_PI           EQU             000000007h
;  RWXVF 
;   542 : #define NV_AUDNOTE_FM_WAVE_SELECT             (15*32+ 2):(15*32+ 0) /* RWXVF */
NV_AUDNOTE_FM_WAVE_SELECT               TEXTEQU         <(15*32+ 2):(15*32+ 0)>
;  RW--V 
;   543 : #define NV_AUDNOTE_FM_WS_SINE                            0x00000000 /* RW--V */
NV_AUDNOTE_FM_WS_SINE           EQU             000000000h
;  RW--V 
;   544 : #define NV_AUDNOTE_FM_WS_HALF_SINE                       0x00000001 /* RW--V */
NV_AUDNOTE_FM_WS_HALF_SINE              EQU             000000001h
;  RW--V 
;   545 : #define NV_AUDNOTE_FM_WS_ABS_SINE                        0x00000002 /* RW--V */
NV_AUDNOTE_FM_WS_ABS_SINE               EQU             000000002h
;  RW--V 
;   546 : #define NV_AUDNOTE_FM_WS_SHARK_SINE                      0x00000003 /* RW--V */
NV_AUDNOTE_FM_WS_SHARK_SINE             EQU             000000003h
;  RW--V 
;   547 : #define NV_AUDNOTE_FM_WS_QUICK_SINE                      0x00000004 /* RW--V */
NV_AUDNOTE_FM_WS_QUICK_SINE             EQU             000000004h
;  RW--V 
;   548 : #define NV_AUDNOTE_FM_WS_ABS_QUICK                       0x00000005 /* RW--V */
NV_AUDNOTE_FM_WS_ABS_QUICK              EQU             000000005h
;  RW--V 
;   549 : #define NV_AUDNOTE_FM_WS_SQUARE                          0x00000006 /* RW--V */
NV_AUDNOTE_FM_WS_SQUARE         EQU             000000006h
;  RW--V 
;   550 : #define NV_AUDNOTE_FM_WS_INV_SINE                        0x00000007 /* RW--V */
NV_AUDNOTE_FM_WS_INV_SINE               EQU             000000007h
;  RWXVF 
;   551 : #define NV_AUDNOTE_FM_PHASE_OUT               (15*32+ 8):(15*32+ 8) /* RWXVF */
NV_AUDNOTE_FM_PHASE_OUT         TEXTEQU         <(15*32+ 8):(15*32+ 8)>
;  RWXVF 
;   552 : #define NV_AUDNOTE_FM_SYNTHESIS               (15*32+12):(15*32+12) /* RWXVF */
NV_AUDNOTE_FM_SYNTHESIS         TEXTEQU         <(15*32+12):(15*32+12)>
;  _NV_REF_H_ 
;   553 : #endif /* _NV_REF_H_ */
;   554 : 
; End of file nv_ref.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\nv_sim.inc ===
;       Copyright (C) 1996-1997 NVidia Corporation
;
;       NV_SIM.INC - NVidia simulation specific macro definitions
;
;       Written by:     Mark Stephen Krueger
;       Date:           9/13/96
;
;       $Revision: 1 $
;       $Date: 5/13/97 10:43a $
;       $Logfile: /resman.040/win96/vdd/nv_sim.inc $
;       $Log: /resman.040/win96/vdd/nv_sim.inc $
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 2     1/23/97 10:58a Markk
; Removed tabs.
; Fixed copyright.
; 
; 1     11/15/96 6:12p Markk
; Used for simulating NV3.
; 
; 1     9/24/96 3:44p Markk
; Created from part of nv_mac.inc.
; 
;
;       SIM_NO - Simulate an out to an NV I/O port
;
;       Parameters: port - dx or constant I/O port below 00100h
;                   value - ax or al
;       Entry:  dx - I/O port (optional)
;               ax/al - Value
;       Exit:   None
;       Return: None
;       Uses:   None
;
SIM_NO macro port:req, value:req
    IFDEF SERIAL_OUT_OPS
        ifidni <port>, <DX>
            ifidni <value>, <AX>
                call    NVLogOutWord
            else
                call    NVLogOutByte
            endif
        else
            ifidni <value>, <AX>
                push    dx
                mov     dx, port
                call    NVLogOutWord
                pop     dx
            else
                push    dx
                mov     dx, port
                call    NVLogOutByte
                pop     dx
            endif
        endif
    ELSE ; SERIAL_OUT_OPS
        IFDEF NVIDIA_SIMULATE
                ifidni <port>, <DX>
                    ifidni <value>, <AX>
                        call    NVSimulateOutWord
                    else
                        call    NVSimulateOutByte
                    endif
                else
                    ifidni <value>, <AX>
                        push    dx
                        mov     dx, port
                        call    NVSimulateOutWord
                        pop     dx
                    else
                        push    dx
                        mov     dx, port
                        call    NVSimulateOutByte
                        pop     dx
                    endif
                endif
        ELSE ; NVIDIA_SIMULATE
                IFNDEF WEITEK_PROTO
                    out port, value
                ENDIF ; WEITEK_PROTO
        ENDIF ; NVIDIA_SIMULATE
    ENDIF ; SERIAL_OUT_OPS
endm
;
;       SIM_WO - Simulate an out to a Weitek I/O port
;
;       Parameters: port - dx or constant I/O port below 00100h
;                   value - ax or al
;       Entry:  dx - I/O port (optional)
;               ax/al - Value
;       Exit:   None
;       Return: None
;       Uses:   None
;
SIM_WO macro port:req, value:req
    IFDEF WEITEK_PROTO
        out port, value
    ELSE
        .err <Use of SIM_WO without WEITEK_PROTO defined.>
    ENDIF ; WEITEK_PROTO
endm
;
;       SIM_NI - Simulate an in from an NV I/O port
;
;       Parameters: dest - ax or al
;                   port - dX or constant I/O port below 00100h
;       Entry:  dx - I/O port (optional)
;       Exit:   al or ax - value
;       Return: None
;       Uses:   None
;
SIM_NI macro dest:req, port:req
    IFDEF NVIDIA_SIMULATE
        ifidni <port>, <DX>
            ifidni <dest>, <AX>
                call    NVSimulateInWord
            else
                call    NVSimulateInByte
            endif
        else
            .err <Can not do SIM_NI from system port>
        endif
    ELSE ; NVIDIA_SIMULATE
        in dest, port
    ENDIF ; NVIDIA_SIMULATE
endm
;
;       SIM_WI - Simulate an in from a Weitek I/O port
;
;       Parameters: dest - ax or al
;                   port - dX or constant I/O port below 00100h
;       Entry:  dx - I/O port (optional)
;       Exit:   al or ax - value
;       Return: None
;       Uses:   None
;
SIM_WI macro dest:req, port:req
    IFDEF WEITEK_PROTO
        in dest, port
    ELSE
        .err <Use of SIM_WI without WEITEK_PROTO defined.>
    ENDIF ; WEITEK_PROTO
endm
;
;       SIM_GET_INDEX_REGISTER_WTK - Simulate an in from a Weitek indexed I/O port
;
;       Parameters: None
;       Entry:  dx - I/O port
;               al - Index
;       Exit:   ah - Value
;       Return: None
;       Uses:   None
;
SIM_GET_INDEX_REGISTER_WTK macro
        IFDEF NVIDIA_SIMULATE
                call    WTKGetIndexRegister
        ELSE ; NVIDIA_SIMULATE
                call    GetIndexRegister
        ENDIF ; NVIDIA_SIMULATE
endm
;
;       SIM_GET_INDEX_REGISTER_NV - Simulate an in from an NV indexed I/O port
;
;       Parameters: None
;       Entry:  dx - I/O port
;               al - Index
;       Exit:   ah - Value
;       Return: None
;       Uses:   None
;
SIM_GET_INDEX_REGISTER_NV macro
        IFDEF NVIDIA_SIMULATE
                call    NVGetIndexRegister
        ELSE ; NVIDIA_SIMULATE
                call    GetIndexRegister
        ENDIF ; NVIDIA_SIMULATE
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\OS.H ===
#ifndef _OS_H_
#define _OS_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.H                                                              *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    06/22/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Debug macros.
//
//---------------------------------------------------------------------------

// debug module, levels, and defines
#include <nv_dbg.h>


// registry path for RM lookups
#define RM_REGISTRY_AGP_BASE_PATH   NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY

#ifndef toupper
#define toupper(c)  (((c)>='a'&&(c)<='z')?((c)-'a'+'A'):(c))
#endif

// correct type to use to convert a pointer to an integer
typedef U032 SIZE_PTR;

//---------------------------------------------------------------------------
//
//  Function prototypes for OS interface.
//
//---------------------------------------------------------------------------

// macro to allow different syntax between NT and Win9x
#define OS_READ_REGISTRY_DWORD(pDev, a, b, c) osReadRegistryDword(pDev, a, b, c)

RM_STATUS  osCopyIn(U008 *src, U008 *target, U032 count);
RM_STATUS  osCopyOut(U008 *src, U008 *target, U032 count);
RM_STATUS  osAllocMem(VOID **, U032);
RM_STATUS  osFreeMem(VOID *);
RM_STATUS  osAllocPages(PHWINFO,VOID **, U032, U032, U032, U032, U032, VOID **);
RM_STATUS  osFreePages(PHWINFO,VOID *, U032, U032, VOID *, BOOL);
RM_STATUS  osVirtualToPhysicalAddr(VOID*, VOID**);
RM_STATUS  osCalculatePteAdjust( PHWINFO, U032, VOID*, U032 *);
RM_STATUS  osGetAddressInfo(PHWINFO, U032, U032, VOID**, U032, VOID**, U032 *);
RM_STATUS  osLockUserMem(PHWINFO, U032, U032, VOID*, VOID*, U032 *, U032, U032, U032 *, VOID**, VOID**);
RM_STATUS  osUnlockUserMem(PHWINFO, U032, VOID*, VOID*, U032, U032, U032, VOID*, U032);
RM_STATUS  osGetCurrentTime(U032 *, U032 *, U032 *, U032 *, U032 *, U032 *, U032 *);
RM_STATUS  osError(POBJECT, U032, V032, RM_STATUS);
RM_STATUS  osExit(char *);
RM_STATUS  osDelay(U032);
RM_STATUS  osDelayUs(U032);
RM_STATUS  osUpdateAGPLimit(PHWINFO);

#ifdef OBSOLETE_FUNCTIONS
RM_STATUS  osRedrawScreen(VOID);
RM_STATUS  osBeginWatchCanvas(U032);
RM_STATUS  osEndWatchCanvas(U032);
RM_STATUS  osValidateGameportSource(char *, U032 *, U032 *, U032 *);
RM_STATUS  osValidateAudioSink(char *, U032 *);
RM_STATUS  osValidateAudioSource(char *, U032 *, U032 *);
RM_STATUS  osValidateVideoSink(char *);
RM_STATUS  osValidateImageVideo(char *, U032 *);
RM_STATUS  osValidateDMAObject(char *, U032, U032 *);
#endif // OBSOLETE_FUNCTIONS

char*      osStringCopy(char *, const char *);
S032       osStringCompare( const char *s1, const char *s2);
U032       osStringLength(const char *);
unsigned char * osMemCopy(unsigned char *, const unsigned char *, U032);
RM_STATUS  osReadRegistryDword(PHWINFO,char *, char *, U032 *);
RM_STATUS  osWriteRegistryDword(PHWINFO,char *, char *, U032);
RM_STATUS  osReadRegistryBinary(PHWINFO,char *, char *, U008 *, U032 *);
RM_STATUS  osWriteRegistryBinary(PHWINFO,char *, char *, U008 *, U032);
RM_STATUS  osDeleteRegistryValue(char *, char *);
RM_STATUS  osMapFrameBuffer(PHWINFO, U032, U032, U032, VOID **);
RM_STATUS  osMapInstanceMemory(PHWINFO, U032, U032, U032, VOID **);
RM_STATUS  osMapFifo(PHWINFO, U032, U032, VOID **);
RM_STATUS  osUnmapMemory(PHWINFO, U032, VOID *, U032);
RM_STATUS  osSetFifoDmaParams(PHWINFO, U032 *, U032 *, U032 *);
RM_STATUS  osDeviceNameToDeviceClass(char *, U032 *);

U032       osGetCpuFrequency(VOID);
U032       osPciReadDword(VOID *, U032);
U016       osPciReadWord(VOID *, U032);
U008       osPciReadByte(VOID *, U032);
VOID       osPciWriteDword (VOID *, U032, U032);
VOID       osPciWriteWord(VOID *, U032, U016);
VOID       osPciWriteByte(VOID *, U032, U008);
VOID*      osPciInitHandle(U008, U008, U008, U016*, U016*);
U016       ReadIndexedpDev(PHWINFO, U032, U008);

VOID       osEnsureDeviceEnabled(PHWINFO);
VOID       osmpCheckCallbacks(PHWINFO, U032);
VOID       osDisplayModeHook(PHWINFO, U032);
VOID       osStateDacEx(PHWINFO, U032);
VOID       osPreModeSet(PHWINFO, U032);
VOID       osPostModeSet(PHWINFO, U032);
VOID       osSetupForNewStyleModeSet(PHWINFO);

VOID 	   osStateFbEx(PHWINFO);
RM_STATUS  osSetVideoMode(PHWINFO);
RM_STATUS  osNotifyEvent(PHWINFO, POBJECT, U032, U032, U032, RM_STATUS, U032);
VOID       NvUpdateAGPConfig(PHWINFO);
RM_STATUS  NvGetAGPBaseLimit(PHWINFO, U032 *, U032 *);
RM_STATUS  mmWaitSemaphore(VOID);
RM_STATUS  mmSignalSemaphore(VOID);
RM_STATUS  initStack_frame(PHWINFO);

RM_STATUS  osCallVideoBIOS(PHWINFO, U032 *, U032 *, U032 *, U032 *, VOID *);
VOID       RmEnableInterrupts(PHWINFO);

#define    osDisableHardwareInterrupts(pDev)    _asm cli
#define    osEnableHardwareInterrupts(pDev)     _asm sti

// These were in modehw.h. There is no real reason these should be os dependent. However,
// in NT these are defined in the miniport. So for now it can't go into the kernel.
//JJV-These are no longer needed.
////VOID OEMEnableExtensions(VOID);
////VOID OEMDisableExtensions(VOID);
////VOID WriteFb32(U032 datum, U032 addr);
////U032 ReadFb32(U032 addr);
////VOID WritePriv32(U032 datum, U032 addr);
////U032 ReadPriv32(U032 addr);
////VOID WriteIndexed(U032 addr, U016 datum);
////VOID WritePriv08(U032 addr, U008 datum);
////U016 ReadIndexed(U032 addr, U008 reg);

// Define away NT only procedures.
#define osRmInitialized() 1
#define osInitMpSync()
#define osInitMpSync() 	
#define osAcquireMpSync()		 
#define osReleaseMpSync()		 
#define osAcquireMpSyncForInt()
#define osReleaseMpSyncForInt()
#define osMapUserMemory(x)	0
#define osUnmapUserMemory(x, y)
#define osIsr(pDev) mcService(pDev)
#define osEnterCriticalCode(p)
#define osExitCriticalCode(p)

#define osMapKernelSpace(a,b,c)   0
#define osMapUserSpace(a,b,c,d)   0
#define osMapIOSpace(a,b,c,d)     0
#define osUnmapIOSpace(a,b,c,d)   0
#define osSetMemRange(a,b,c)      0
#define osAllocContigPages(a)     0
#define osAllocPool(a,b)          1
#define osFreePool(a)
#define osMemSet(a,b,c)
#define osGetAGPPhysAddr(a,b,c,d) 1
#define osGetKernPhysAddr(a)      0
#define osUnmapUserSpace(a,b)
#define osUnmapKernelSpace(a,b) 
#define osFreeContigPages(a)

#define osFlushCpuCache(p) ((VOID)0)

#define osDldLinkImg(p) RM_ERROR
#define osDldUnlinkImg(p) RM_ERROR

// define away mac-only routines
#define osReadRegistryBoolean(a,b,c)    1

// 2/28/96 msk - Used to find out if os is terminating
BOOL osTerminating(VOID);
//
// Misc functions.
//

/* TO DO: remove these
RM_STATUS initMapping(VOID);
RM_STATUS initFbEx(VOID);
RM_STATUS initGrEx(VOID);
RM_STATUS initDacEx(VOID);
RM_STATUS initCodecEx(VOID);
RM_STATUS initFifoEx(VOID);
*/
RM_STATUS initMapping	(PHWINFO);
RM_STATUS initFbEx	 	(PHWINFO);
RM_STATUS initFifoEx 	(PHWINFO);
RM_STATUS initGrEx	 	(PHWINFO);
RM_STATUS initDacEx	 	(PHWINFO);
RM_STATUS initCodecEx	(PHWINFO);

//---------------------------------------------------------------------------
//
//  Required defines for OS interface.
//
//---------------------------------------------------------------------------

#define NV_MEMORY_TYPE_SYSTEM       0
#define NV_MEMORY_TYPE_AGP          1

#define NV_MEMORY_NONCONTIGUOUS     0
#define NV_MEMORY_CONTIGUOUS        1

#define NV_MEMORY_DEFAULT           0
#define NV_MEMORY_UNCACHED          1
#define NV_MEMORY_WRITECOMBINED     2
#define NV_MEMORY_WRITETHRU         3
#define NV_MEMORY_WRITEPROTECT      4
#define NV_MEMORY_WRITEBACK         5

typedef struct _def_win9x_hw_info *PWIN9XHWINFO;
typedef struct _def_win9x_hw_info
{
	U008	filler1;
	U016	filler2;

	U032 dllIpcOffset;
    U032 dllIpcSelector;	
    U032 dllNotifyOffset;
    U032 dllNotifySelector;

	U032 osDeviceHandle;

	U008	osScheduled;
	VOID	(*miniVDDPostModeChange)();		// callback to miniVDD PostCRTCModeChange
	char	*osDeviceName;					// device name string
	U032	*NvSaveVmmStack;
	U032	*NvIsrStackFrame;
	U032	*NvIsrStackFrameBase;
} WIN9XHWINFO;


#endif // _OS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\osdbg.h ===
#ifndef _OS_DBG_H_

#define _OS_DBG_H_

// Function Table to use to Output Messages
#define DBG_OBJECT_OS (0)
#define DBG_OBJECT_SERIAL (1)
// All of these below are currently unimplemented
#define DBG_OBJECT_PARALLEL (2)
#define DBG_OBJECT_INFRARED (3)
#define DBG_OBJECT_USB (4)
#define DBG_OBJECT_I2C (5)
#define DBG_OBJECT_LAST DBG_OBJECT_I2C

typedef struct dbgserialinfo {
   NvU32 uPort;
   NvU32 uBaud;
   } DBGSERIALINFO;

typedef struct dbgtbdinfo {
   NvU32 uTBD;
} DBGTBDINFO;

typedef struct dbgport {
   NvU32 uType;
   union {
   DBGSERIALINFO Serial;
   DBGTBDINFO Parallel;
   DBGTBDINFO IIR;
   DBGTBDINFO USB;
   DBGTBDINFO I2C;
   } uTag;
} DBGPORT, * PDBGPORT;

//
// Function Prototypes
//
typedef VOID (* PFNCONFIG)(NvV32 * pDev);
typedef VOID (* PFNINIT)(PDBGPORT pdbgPort);
typedef VOID (* PFNOPEN)(NvV32 * pDev);
typedef VOID (* PFNDISPLAY)(char * pStr);
typedef VOID (* PFNCLOSE)(NvV32 * pDev);

typedef struct dbgobject {
	PFNCONFIG pConfig;
	PFNINIT pInit;
	PFNOPEN pOpen;
	PFNDISPLAY pDisplay;
	PFNCLOSE pClose;
} DBGOBJECT, * PDBGOBJECT;

//
// Simple Macros for IO
//
#define OUTB outpb
#define OUTW outpw
#define INB inpb
#define INW inpw

//
// Indexes fro Name strings
//
#define DBG_COM1_PORT_INDEX (0)
#define DBG_COM2_PORT_INDEX (1)
#define DBG_PARALLEL_PORT_INDEX (2)

//
// Standard PC Plug-n-Play ID's for 16550 and Printer Port
//
// Windows 98
#define DBG_W98_COM1_KEY_STR1 "ACPI\\*PNP0501\\00000001"
#define DBG_W98_COM1_KEY_STR2 "ACPI\\*PNP0500\\00000001"
// Windows 95
#define DBG_COM1_KEY_STR3 "BIOS\\*PNP0501\\02"
#define DBG_COM1_KEY_STR4 "BIOS\\*PNP0500\\00"

// Windows 98
#define DBG_W98_COM2_KEY_STR1 "ACPI\\*PNP0501\\00000002"
#define DBG_W98_COM2_KEY_STR2 "ACPI\\*PNP0500\\00000002"
// Windows 95
#define DBG_COM2_KEY_STR3 "BIOS\\*PNP0501\\03"
#define DBG_COM2_KEY_STR4 "BIOS\\*PNP0500\\01"

#define DBG_W98_PARALLEL_KEY_STR1 "ACPI\\*PNP0400\\0"
#define DBG_PARALLEL_KEY_STR2 "BIOS\\*PNP0400\\0"

#define DBG_COM1_PORTNAME "COM1"
#define DBG_COM2_PORTNAME "COM2"
#define DBG_PARALLEL_PORTNAME "LPT1"

//
// Prototypes
//
// PNP Routines
NvU32 Locate_DevNode(PDEVNODE pdnDevNode, char * pStr[], NvU32 ulSize);
NvU32 dbgEnableDevice(NvU32 nPort);
NvU32 dbgEnableDevice2(PDBGPORT pDbgPort);
NvU32 dbgDisableDevice2(PDBGPORT pDbgPort);
NvU32 dbgDisableDevice(NvU32 nPort);

// Simple Format Routine
VOID dbgFormat(char * pStr, NvU32 value);

//
// Null Routines so we can skipping Null Pointer checking
//
void dbgConfigNull(NvV32 * pDev);
void dbgInitNull(PDBGPORT pDbgPort);
void dbgDisplayNull(char * pStr);
void dbgOpenNull(NvV32 * pDev);
void dbgCloseNull(NvV32 * pDev);

// Simple PIO routines
NvU8 inpb(NvU16 uPort);
NvU16 inpw(NvU16 uPort);
VOID outpb(NvU16 uPort, NvU8 bValue);
VOID outpw(NvU16 uPort, NvU16 wValue);


//
//  This is where I added the Vxd Services that I am using
//  The driver is configured to build with Win95 but I want to use
//  some Win 98 Serivces in the Config Manager so I have added them
//  here
//

#define	CONFIG98_VERSION	(0x040A)
#define  ___CONFIGMG_Get_DevNode_PowerState (0x00330065)
#define  ___CONFIGMG_Set_DevNode_PowerState (0x00330064)

#define CM_POWERSTATE_D0                        0x00000001
#define CM_POWERSTATE_D1			0x00000002
#define CM_POWERSTATE_D2                        0x00000004
#define CM_POWERSTATE_D3                        0x00000008
#define CM_POWERSTATE_BITS                      0x0000000f

//
// Return value is hidden so disable no return value detection warning
//
#pragma warning(disable:4035)
DWORD VXDINLINE __declspec(naked) CMxx_Get_Version(VOID)
{
   _asm  push  ebp
   _asm  mov   ebp, esp
   _asm  push  ecx
   _asm  push  ebx
   _asm  push  esi
   _asm  push  edi
   VMMCall(_CONFIGMG_Get_Version)
   _asm  pop   edi
   _asm  pop   esi
   _asm  pop   ebx
   _asm  pop   ecx
   _asm  mov   esp, ebp
   _asm  pop   ebp
   _asm  ret
}

DWORD VXDINLINE __declspec(naked) CMxx_Locate_DevNode(PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Locate_DevNode);
}

DWORD VXDINLINE __declspec(naked) CMxx_Disable_DevNode (DEVNODE dnDevNode, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Disable_DevNode);
}

DWORD VXDINLINE __declspec(naked) CMxx_Enable_DevNode (DEVNODE dnDevNode, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Enable_DevNode);
}

DWORD VXDINLINE __declspec(naked) CMxx_Read_Registry_Value (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Read_Registry_Value);
}

DWORD VXDINLINE __declspec(naked) CMxx_Write_Registry_Value (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Write_Registry_Value);
}

DWORD VXDINLINE __declspec(naked) CMxx_Debug_DevNode (DEVNODE dnDevNode, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Debug_DevNode);
}

DWORD VXDINLINE __declspec(naked) CMxx_Set_DevNode_PowerState(DEVNODE dnDevNode, ULONG ulPowerState, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Set_DevNode_PowerState);
}

DWORD VXDINLINE __declspec(naked) CMxx_Get_DevNode_PowerState(DEVNODE dnDevNode, PFARULONG pulPowerState, ULONG ulFlags)
{
   VMMJmp(_CONFIGMG_Get_DevNode_PowerState);
}

#define ___ACPI_GetVersion (0x004C0000)

DWORD VXDINLINE __declspec(naked) ACPI_Get_Version(VOID)
{
   _asm  push  ebp
   _asm  mov   ebp, esp
   _asm  push  ecx
   _asm  push  ebx
   _asm  push  esi
   _asm  push  edi
   VxDCall(_ACPI_GetVersion);
   _asm  pop   edi
   _asm  pop   esi
   _asm  pop   ebx
   _asm  pop   ecx
   _asm  mov   esp, ebp
   _asm  pop   ebp
   _asm  ret
}

#define ___ACPI_IdentifyDebuggerCommInfo (0x004C0015)

DWORD VXDINLINE __declspec(naked) ACPI_IdentifyDebuggerCommInfo(DEVNODE dnDevNode, ULONG ulFlags)
{
   VMMJmp(_ACPI_IdentifyDebuggerCommInfo);
}

#define ___VCD_Set_Port_Global (0x000E0001)

DWORD VXDINLINE __declspec(naked) VCD_Set_Port_Global(DWORD nPort)
{
   _asm  push  ebp
   _asm  mov   ebp, esp
   _asm  push  edx
   _asm  push  ecx
   _asm  push  ebx
   _asm  push  esi
   _asm  push  edi
   _asm  mov   eax, nPort
   _asm  xor  edx, edx
   VMMCall(_VCD_Set_Port_Global)
   _asm  pop   edi
   _asm  pop   esi
   _asm  pop   ebx
   _asm  pop   ecx
   _asm  pop   edx
   _asm  mov   esp, ebp
   _asm  pop   ebp
   _asm  ret
}

DWORD VXDINLINE __declspec(naked) VCOMM_OpenComm(char * pStr, DWORD hVM)
{
   VMMJmp(_VCOMM_OpenComm);
}

DWORD VXDINLINE __declspec(naked) VCOMM_CloseComm(DWORD hPort)
{
   VMMJmp(_VCOMM_CloseComm);
}

typedef DWORD (* PFNNOTIFY)(DWORD dwRefData, DWORD dwType);
typedef DWORD (* PFNCONTENT)(DWORD dwType, DWORD dwResource, PFNNOTIFY pFn, DWORD dwRefData, DWORD dwSteal);

PFNCONTENT VXDINLINE __declspec(naked) VCOMM_Get_Contention_Handler(char * pStr)
{
   VMMJmp(_VCOMM_Get_Contention_Handler);
}

DWORD VXDINLINE __declspec(naked) VCOMM_Map_Name_To_Resource(char * pStr)
{
   VMMJmp(_VCOMM_Map_Name_To_Resource);
}

#define ___VCOMM_PowerOnOffComm (___VCOMM_Map_Name_To_Resource+1)

DWORD VXDINLINE __declspec(naked) VCOMM_PowerOnOffComm(DWORD devNode, DWORD PowerState)
{
   VMMJmp(_VCOMM_PowerOnOffComm);
}



//
// Enable detection of no return values
//
#pragma warning(default:4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\OSWIN.H ===
#ifndef _OSWIN_H_
#define _OSWIN_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OSWIN.H                                                           *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    11/22/93 - wrote it.                    *
*       David Schmenk (dschmenk)    06/22/94 - rewrote it.                  *
*       Jeff Westerinen (jsw)    	05/05/97 - Modified to build under MS   *
*                                                                           *
\***************************************************************************/

//
// necessary definitions due to (missing in) new headers
//
#define CARRY       void
//
// necessary abstract types due to new headers (jsw)
// typedef struct VxD_Desc_Block DDB;
//
typedef CLIENT_STRUCT *PCS;
//
// IOCTL functions.
//
typedef VOID (*IOCTL_DISPATCH)(U032, DWORD, PVOID);

//---------------------------------------------------------------------------
//
//  OS specific defines.
//
//---------------------------------------------------------------------------

//
// Number of outstanding callbacks.
//
#define NUM_CALLBACKS                   64
#define MAX_PARAMS                      10
//
// Size of service stack.
//
#define STACK_SIZE                      8192

//---------------------------------------------------------------------------
//
//  OS specific structures.
//
//---------------------------------------------------------------------------

//
// Array of callback parameters.
//
typedef struct _def_callback
{
    U016 Selector;
    U016 Offset;
    U032 Count;
    U032 Params[MAX_PARAMS];
    struct _def_callback *Next;
} CALLBACK, *PCALLBACK;

//---------------------------------------------------------------------------
//
//  External variable definitions.
//
//---------------------------------------------------------------------------

// JJV-MM
//extern PCHANNELINFO channelInfo;
extern PCLIENTINFO    clientInfo;
// JJV-MM
//extern U032         hpicIRQ;
//extern IOCTL_DISPATCH rmArchDispatchTable[];
extern U032           rmInService;
extern U032           osInService;
extern U032           rmInSafeService;
extern U032           rmInCallback;
extern U032           rmSemaphore;
extern U032           osSemaphore;
extern U032           mmSemaphore;
extern U032         * rmStackBase;
extern U032         * rmStack;
extern U032           vmmStack;

// Registry string globals.
extern char strDevNodeRM[];
extern char strRegistryGlobalParameters[];
extern char strRmCoreName[];
extern char strRmCoreVxd[];

extern char strMaxRefreshRate[];
extern char strMaxOptimalRefreshRate[];
extern char strOptimalNotFromEDID[];
extern char strDMTOverride[];
extern char strMonitorTiming[];
extern char strCursorCacheOverride[];
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strStartUp[];
extern char strTVOutType[];
extern char strNewModeSet[];
extern char strFpMode[];


//
// Callback functions into the 16 bit RM DLL.
//
// JJV-MM
//extern U032      dllNotifyOffset;
//extern U032      dllNotifySelector;
//extern U032      dllIpcOffset;
//extern U032      dllIpcSelector;
extern PCALLBACK osCallbackTable;
extern PCALLBACK osCallbackList;
extern PCALLBACK osCallbackFreeList;

//---------------------------------------------------------------------------
//
// Function prototypes.
//
//---------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

//
//  PCI BIOS interface.
//
VOID CDECL PCI(PCS);  // (jsw)

//
// VBE BIOS interface.
//
VOID CDECL VBE(PCS);  // (jsw)
VOID CDECL readToshibaEDID(PCS);  // (lpl)
VOID CDECL VBE30(PCS);  // (jsw)

//
//  Timer BIOS interface.
//
VOID CDECL TIMER(CLIENT_STRUCT *);


#ifdef __cplusplus
};
#endif

#define CLI	_asm cli

#define STI _asm sti

//
// Function prototypes for Resource Manager entrypoints.
//
RM_STATUS CDECL rmControl(U032, U032);
U032      CDECL rmGetVersion(VOID);
U032      CDECL rmSysRegister(U032, NVRMSYSAPI *);
U032      CDECL rmEnableVga(PHWINFO, BOOL);
U032      CDECL rmFixUpVga(VOID);
U032	  CDECL rmGetAddress(U032);
U032      CDECL rmEnableHiRes(PHWINFO, BOOL);
U032      CDECL rmSetDpmLevel(U032);
U032      CDECL rmDDC(U032 *);
RM_STATUS CDECL rmSysAPI(U032, U032, V032, V032);
RM_STATUS  __fastcall     rmUsrAPI(U032, PCS);
//RM_STATUS CDECL rmUsrAPI(U032, PCS);  // (jsw)
//VOID            rmUsrPrivAPI(U032, PCRS); (jsw)
S032            rmGetDevInfo(U032);
VOID            rmInterrupt(U032, U032);
VOID            osInterrupt(U032, U032);
U032            osInterruptProcess(PHWINFO *,U032, U032);
BOOL      CDECL osService(PHWINFO);
VOID      CDECL osBoostService(VOID);
VOID      CDECL osSafeService(VOID);
VOID            osVMIntEOI(U032, U032);
VOID            osNopInt(U032, U032);
RM_STATUS CDECL osScheduleCallback(PHWINFO,U016, U016, U032, U032, ...);
VOID            osCallback(U032);
//
// Initialization routines.
//
RM_STATUS initStack(VOID);
RM_STATUS initSemaphore(VOID);
RM_STATUS initCallbackFreeList(VOID);
RM_STATUS initClientInfo(VOID);
RM_STATUS initChannelInfo(VOID);
RM_STATUS initDevInfo(VOID);
RM_STATUS initNv(VOID);
//
// Stack switch routine.
//
U032 osSwapStack(U032);
/*** Watcom syntax...  (jsw)
#pragma aux osSwapStack   =                         \
            "xchg   EAX, ESP"                       \
            parm [EAX]                              \
            value [EAX];
*/

//
// Register push/pop routines.
//
/* (jsw)
VOID osPushRegs(VOID);
VOID osPopRegs(VOID);
#pragma aux osPushRegs    =                         \
            "push   EBP"                            \
            "push   EAX"                            \
            "push   EBX"                            \
            "push   ECX"                            \
            "push   EDX"                            \
            "push   ESI"                            \
            "push   EDI"                            \
            modify [];
#pragma aux osPopRegs    =                          \
            "pop    EDI"                            \
            "pop    ESI"                            \
            "pop    EDX"                            \
            "pop    ECX"                            \
            "pop    EBX"                            \
            "pop    EAX"                            \
            "pop    EBP"                            \
            modify [];
*/

//---------------------------------------------------------------------------
//
//  Compiler specific options are set here to interface to the VMM and other
//  VxDs in the system.  Different calling conventions are used for almost
//  every function.  Inlining of functions and assembly interface operations
//  are used extensively for performance and size considerations.
//
//---------------------------------------------------------------------------

//
// Handy functions used in this module.
//
/* (jsw)
DWORD asmGetCS(VOID);
#pragma aux asmGetCS =                              \
            "xor    EAX, EAX"                       \
            "mov    AX, CS"                         \
            value [EAX];
DWORD asmGetDS(VOID);
#pragma aux asmGetDS =                              \
            "xor    EAX, EAX"                       \
            "mov    AX, DS"                         \
            value [EAX];
*/

/*  Watcom syntax  (jsw)
VOID CLI(VOID);
#pragma aux CLI = "cli";
VOID STI(VOID);
#pragma aux STI = "sti";
*/
//VOID CLI(VOID);
//VOID STI(VOID);

//
// Parameter passing/return value mapping to entrypoints.
//
/*  no such specific parameter passing tweaking in MSC -- will this kill performance???
#pragma aux (VMM_CTL)   rmControl;
#pragma aux (VMM_API)   rmUsrAPI;
#pragma aux (VPICD_INT) rmInterrupt;
#pragma aux (VMM_CB)    osCallBack;
#pragma aux (VPICD_INT) osInterrupt;
#pragma aux (VPICD_INT) osVMIntEOI;
#pragma aux (VPICD_INT) osNopInt;
*/

#endif // _OSWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\serial.h ===
#ifndef _SERIAL_H_
#define _SERIAL_H_

#define DBG_COM1_PORT (0x3F8)
#define DBG_COM2_PORT (0x2F8)

#define DATA_OFFSET (0)
#define DLOW_OFFSET (0)
#define ICR_OFFSET (1)
#define DHI_OFFSET (1)
#define IIR_OFFSET (2)
#define FIFO_OFFSET (2)
#define LCR_OFFSET (3)
#define MCR_OFFSET (4)
#define LSR_OFFSET (5)
#define MRR_OFFSET (6)
#define SPARE_OFFSET (7)

#ifndef PSTR
typedef char * PSTR;
#endif

NvU16 dbgBaudRate(NvU32 uBaudRate);
VOID dbgInitSerial(PDBGPORT pDbgPort);
VOID dbgDisplaySerial(PSTR pStr);


#define DBG_FFLAGS_BINARY (0x00000001)
#define DBG_FFLAGS_PARITY (0x00000002)
#define DBG_FFLAGS_CTSFLOW (0x00000004)
#define DBG_FFLAGS_DSRFLOW (0x00000008)
#define DBG_FFLAGS_DTRCONTROL (0x00000030)
#define DBG_FFLAGS_TXONOFF (0x00000040)
#define DBG_FFLAGS_OUTX (0x00000080)
#define DBG_FFLAGS_INX (0x00000100)
#define DBG_FFLAGS_ERRORCHAR (0x00000200)
#define DBG_FFLAGS_FNULL (0x00000400)
#define DBG_FFLAGS_RTS (0x00001800)
#define DBG_FFLAGS_ABORT (0x00020000)
#define DBG_FFLAGS_DUMMY2 (0xFFFC0000)

#define FAR far

typedef struct _WIN32DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fFlags;         /* All the stuff blow is one dword */ 
#if 0
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
#endif
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Recieved Event character        */
    char xx1;
    char xx2;
} WIN32DCB, * PWIN32DCB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\nv_mac.inc ===
;       Copyright (C) 1996-1997 NVidia Corporation
;
;       NV_MAC.INC - NVidia specific macro definitions for the VxD environment
;
;       Written by:     Mark Stephen Krueger
;       Date:           7/22/96
;
;       $Revision: 5 $
;       $Date: 3/10/98 10:36a $
;       $Logfile: /resman.040/win96/vdd/nv_mac.inc $
;       $Log: /resman.040/win96/vdd/nv_mac.inc $
; 
; 5     3/10/98 10:36a Jhinman
; Fix bug in reg_rd08 (read 32).
; 
; 4     2/13/98 3:36p Jhinman
; Add reg_wr08/reg_rd08 macros.
; 
; 3     1/09/98 2:03p Jhinman
; Address of chip (nvAddr) is now local, since RM is separate from
; miniVDD. Removed the underscore, since its not a "C" declaration.
; 
; 2     10/30/97 6:43p Jhinman
; Add underscore to nvAddr, since its now declared in osapi.c.
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 4     1/23/97 10:57a Markk
; Removed tabs.
; 
; 3     11/15/96 6:07p Markk
; Added code for simulating NV accesses.
; 
; 2     11/13/96 12:33p Markk
; Fixed bugs with REG_WR32 and REG_RD32 macros.
; 
; 1     10/16/96 9:15a Markk
; Contains NV macros for the VDD environment.
;

;
;       REG_WR32 - Writes the value in eax to an NV register
;
;       Parameters: nv_address - Address to write to (optional)
;       Entry:  esi - Address to write to (optional)
;               eax - Value
;       Exit:   None
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_WR32 macro nv_address:=<esi>, data
    ifnb <data>
        mov     eax,data
    endif
IFDEF NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        push    eax
        push    ebx
        mov     ebx,eax
        mov     eax,esi
        call    NVSimulateWriteReg
        pop     ebx
        pop     eax
    else
        mov     esi,nv_address
        push    eax
        push    ebx
        mov     ebx,eax
        mov     eax,esi
        call    NVSimulateWriteReg
        pop     ebx
        pop     eax
    endif
ELSE ; NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     [esi],eax
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     [esi],eax
;        sub     esi,nvAddr
    endif
ENDIF ; NVIDIA_SIMULATE
    exitm <>
endm
;
;       REG_RD32 - Reads the value in an NV register into eax
;
;       Parameters: nv_address - Address to read from  (optional)
;       Entry:  esi - Address to read from  (optional)
;       Exit:   eax - Value
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_RD32 macro nv_address:=<esi>
IFDEF NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        push    ebx
        mov     eax,esi
        call    NVSimulateReadReg
        mov     eax,ebx
        pop     ebx
    else
        mov     esi,nv_address
        push    ebx
        mov     eax,esi
        call    NVSimulateReadReg
        mov     eax,ebx
        pop     ebx
    endif
ELSE ; NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     eax,[esi]
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     eax,[esi]         
;        sub     esi,nvAddr
    endif
ENDIF ; NVIDIA_SIMULATE
    exitm <>
endm
;
;
;       REG_WR08 - Writes the value in eax to an NV register
;
;       Parameters: nv_address - Address to write to (optional)
;       Entry:  esi - Address to write to (optional)
;               al - Value
;       Exit:   None
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_WR08 macro nv_address:=<esi>, data
    ifnb <data>
        mov     eax,data
    endif
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     [esi],al
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     [esi],al
    endif
    exitm <>
endm
;
;       REG_RD08 - Reads the value in an NV register into eax
;
;       Parameters: nv_address - Address to read from  (optional)
;       Entry:  esi - Address to read from  (optional)
;       Exit:   al - Value
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_RD08 macro nv_address:=<esi>
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     al,[esi]
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     al,[esi]         
    endif
    exitm <>
endm

;----------------------------------------------------------------------
; hex = 0x00000000
; decimal = 0
; Note: if esi and eax usage is hard to work with, could add push/pop's
;----------------------------------------------------------------------
;
;       BIT(b) - Returns a bit mask with bit 'b' set
;
;       Parameters: b - Bit
;       Entry:  None
;       Exit:   None
;       Return: Mask
;
;#define BIT(b)                  (1<<(b))
BIT macro b
    exitm %(1 SHL b)
endm
;
;       DEVICE_BASE(d) - Returns the base address of a device
;
;       Parameters: d - Device
;       Entry:  None
;       Exit:   None
;       Return: Base address in hex
;
;       Requires that definition of device be hex:hex
;
;#define DEVICE_BASE(d)          (0?d)
DEVICE_BASE macro nv_device
    local pos
    pos = @InStr(1,%nv_device,<:>)
    exitm @CatStr(@SubStr( %nv_device, %pos + 3, %@SizeStr(%nv_device) - pos - 2),<h>)
endm
;
;       DRF_SHIFT(drf) - Returns the least significant bit of a field
;
;       Parameters: drf - Field
;       Entry:  None
;       Exit:   None
;       Return: Bit
;
;       Requires that definition of drf be decimal:decimal
;
;#define DRF_SHIFT(drf)          (0?drf)
DRF_SHIFT macro drf
        local pos
;        echo    DRF_SHIFT
;%       echo    drf
    pos = @InStr(1,%drf,<:>)
;temp3   TEXTEQU %pos
;%       echo    temp3
    exitm @SubStr( %drf, %pos + 1, %@SizeStr(%drf) - pos)
endm
;
;       DRF_MASK(drf) - Returns the bit mask of a field
;
;       Parameters: drf - Field
;       Entry:  None
;       Exit:   None
;       Return: Mask
;
;       Requires that definition of drf be decimal:decimal
;
;#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-(1?drf)+(0?drf)))
DRF_MASK macro drf
    local pos, value1, value0, result
    pos = @InStr(1,%drf,<:>)
;temp3 TEXTEQU %pos
;%   echo temp3
    value1 = @SubStr( %drf, 1, %pos - 1)
    value0 = @SubStr( %drf, %pos + 1, %@SizeStr(%drf) - pos)
;    result TEXTEQU %(0FFFFFFFFh SHR (31 - value1 + value0))
;temp3 TEXTEQU %result
;%   echo temp3
    exitm %(0FFFFFFFFh SHR (31 - value1 + value0))
endm
;
;       DRF_DEF(d,r,f,c) - Returns the value of a constant shifted into a field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   c - Constant
;       Entry:  None
;       Exit:   None
;       Return: Value
;
;#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
DRF_DEF macro d, r, f, c
    local value, shift
;    value = %@CatStr(<NV>, %d, %r, %f, %c)
    value = @CatStr(<NV>, d, r, f, c)
;    shift = %DRF_SHIFT(%@CatStr(<NV>, %d, %r, %f))
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    exitm %(value SHL shift)
endm
;
;       DRF_NUM(d,r,f,n) - Returns the value of a number shifted into a field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   n - Number
;       Entry:  None
;       Exit:   eax - result, if number is not a constant value
;       Return: Value, if number is a constant value
;
;#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
DRF_NUM macro d, r, f, n
    local value, shift
    value = DRF_MASK(@CatStr(<NV>, d, r, f))
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    if (((opattr n) AND 4) NE 0)        ; Check for immediate value
        exitm %((n AND value) SHL shift)
    else                                ; Must be non-immediate, move to eax
        ifdifi <n>, <eax>               ; See if its already in eax
                if ((type n) NE 4)      ; Make sure its a dword value
                        .err <Must pass a dword number for n in DRF_NUM>
                else
                        mov     eax, n
                endif
        endif
        and     eax, value
        if (shift gt 0)
            shl     eax, shift
        endif
        exitm <>
    endif
endm
;
;       DRF_VAL(d,r,f,v) - Returns the contents of a field within a value
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   v - Value
;       Entry:  None
;       Exit:   eax - result, if number is not a constant value
;       Return: Value, if number is a constant value
;
;#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
DRF_VAL macro d, r, f, v:=<eax>
    local value, shift
    value = DRF_MASK(@CatStr(<NV>, d, r, f))
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    if (((opattr v) AND 4) NE 0)        ; Check for immediate value
            exitm %((v SHR shift) AND value)
    else                                ; Must be non-immediate, move to eax
        ifdifi <v>, <eax>               ; See if its already in eax
                if ((type v) NE 4)      ; Make sure its a dword value
                        .err <Must pass a dword number for n in DRF_NUM>
                else
                        mov     eax, v
                endif
        endif
        if (shift gt 0)
            shr     eax, shift
        endif
        and     eax, value
        exitm <>
    endif
endm
;
;       REG_WR_DRF_NUM(d,r,f,n) - Writes a field number into an NV register
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   n - Number
;       Entry:  None
;       Exit:   eax - result, if number is not a constant value
;       Return: Value, if number is a constant value
;       Uses:   esi, eax
;
;#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
REG_WR_DRF_NUM macro d, r, f, n:=<eax>
    mov     esi,@CatStr(<NV>,d,r)
    if (((opattr n) AND 4) NE 0)        ; Check for immediate value
            mov     eax,DRF_NUM(d,r,f,n)
    else                                ; Must be non-immediate, move to eax
        DRF_NUM(d,r,f,n)
    endif
    REG_WR32 esi
    exitm <>
endm
;
;       REG_WR_DRF_DEF(d,r,f,c) - Writes a field constant into an NV register
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   c - Constant
;       Entry:  None
;       Exit:   None
;       Return: None
;       Uses:   esi, eax
;
;#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
REG_WR_DRF_DEF macro d, r, f, c
    mov     esi,@CatStr(<NV>,d,r)
    mov     eax,DRF_DEF(d,r,f,c)
    REG_WR32 esi
    exitm <>
endm
;
;       FLD_WR_DRF_NUM(d,r,f,n) - Writes a number into an NV field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   n - Number
;       Entry:  None
;       Exit:   None
;       Return: None
;       Uses:   esi, eax, ebx
;
;#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
FLD_WR_DRF_NUM macro d, r, f, n:=<eax>
    ifidni  <n>, <eax>                  ; See if its already in eax
        push    eax                     ; Save it on stack
    endif
    mov     esi,@CatStr(<NV>,d,r)
    REG_RD32  esi
    and     eax,NOT (DRF_MASK(@CatStr(<NV>, d, r, f)) SHL DRF_SHIFT(@CatStr(<NV>, d, r, f)))
    
    ifidni  <n>, <eax>                  ; See if its already in eax
        mov     ebx, eax                ; Move read value into ebx
        pop     eax                     ; Restore eax for DRF_NUM function (n=eax)
        DRF_NUM(d,r,f,n)                ; Loads number into eax (same as DRF_NUM(d,r,f,eax))
        or      eax, ebx                ; OR with value read
    elseif (((opattr n) AND 4) NE 0)    ; Check for immediate value
        or     eax,DRF_NUM(d,r,f,n)
    else                                ; Must be non-immediate, move to eax
        push    eax
        DRF_NUM(d,r,f,n)                ; Loads number into eax
        pop     ebx                     ; Pop saved eax into ebx
        or      eax, ebx
    endif
    REG_WR32 esi
    exitm <>
endm
;
;       FLD_WR_DRF_DEF(d,r,f,c) - Writes a constant into an NV field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   c - Constant
;       Entry:  None
;       Exit:   None
;       Return: None
;       Uses:   esi, eax
;
;#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
FLD_WR_DRF_DEF macro d, r, f, c
    mov     esi,@CatStr(<NV>,d,r)
    REG_RD32  esi
    and     eax,NOT (DRF_MASK(@CatStr(<NV>, d, r, f)) SHL DRF_SHIFT(@CatStr(<NV>, d, r, f)))
    or      eax,DRF_DEF(d,r,f,c)
    REG_WR32 esi
    exitm <>
endm
;
;       REG_RD_DRF(d,r,f) - Reads the contents of an NV field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;       Entry:  None
;       Exit:   None
;       Return: eax - Field contents
;       Uses:   esi
;
;#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
REG_RD_DRF macro d, r, f
    local shift
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    mov     esi,@CatStr(<NV>,d,r)
    REG_RD32(esi)
;temp9 TEXTEQU %shift
;%   echo temp9
    if (shift gt 0)
        shr     eax,shift
    endif
    and     eax,DRF_MASK(@CatStr(<NV>, d, r, f))
    exitm <>
endm
; Dumb macro to read PCI Config space.
ReadPCI	macro
  push   eax
  
  mov    dx, 0cf8h
  out    dx, eax
  mov    dx, 0cfch
  in     eax, dx
  mov    edx,eax
  
  pop    eax
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\VNVRMD.H ===
#ifndef _VNVRMD_H_
#define _VNVRMD_H_
/********* Operating System Interface for NVidia Resource Manager **********\
*                                                                           *
* Module: NVRM.H                                                            *
*       Header file for NVRM defines and service exports.                   *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)  06/21/94 - wrote it                      *
*        Jeff Westerinen (jsw)     05/05/97 - Modified to build under MS    *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//
// Version numbers.
//

#define NVRM_Major_Version  1
#define NVRM_Minor_Version  0

//
// Device IDs.
//

#define NVRM_Device_ID      0x32DC

//
// Init order.
//

//#define NVRM_Init_Order     (VDD_Init_Order - 0x00100000)	// init before VDD  (jsw)
#define NVRM_Init_Order     (VDD_INIT_ORDER - 0x00100000)	// init before VDD

//
// Virtual device services.
//

#define NVRM_Get_Version        0
#define NVRM_Register           1

//
// Prototypes to call NVRM services.
//

typedef DWORD (CDECL *NVRMSYSAPI)(DWORD, DWORD, DWORD, DWORD);

/* (jsw)

DWORD nvrmGetVersion(VOID);
LONG  nvrmRegister(DWORD, NVRMSYSAPI);

#pragma aux nvrmGetVersion =                            \
            CALL_VXD(NVRM_Device_ID, NVRM_Get_Version)  \
            parm caller []                              \
            value no8087 [EAX]                          \
            modify [EAX EBX ECX EDX];

#pragma aux nvrmRegister =                          \
            CALL_VXD(NVRM_Device_ID, NVRM_Register) \
            parm caller []                          \
            value no8087 [EAX]                      \
            modify [EAX EBX ECX EDX];

*/

#endif // _VNVRMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\VNVRMD.INC ===
;********* Operating System Interface for NVidia Resource Manager **********;
;                                                                           ;
; Module: NVRM.INC                                                          ;
;       Header file for NVRM defines and service exports.                   ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/19/93 - wrote it                   ;
;                                                                           ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

;
; Version numbers.
;

NVRM_Major_Version  EQU     01h
NVRM_Minor_Version  EQU     00h

;
; Device IDs.
;

NVRM_Device_ID      EQU     032DCh

;
; Init order.
;

NVRM_Init_Order     EQU     070000000h

;===========================================================================;
;                                                                           ;
;                     Virtual device services.                              ;
;                                                                           ;
;       The virtual device services are declared here, along with their     ;
;       cod segments.  The service entrypoints are declared with a preceding;
;       underscore, the service is a C based function with stack based      ;
;       parameters.  Otherwise, it is an assembly based function with       ;
;       register based parameters.                                          ;
;                                                                           ;
;===========================================================================;

Begin_Service_Table NVRM
        NVRM_Service    NVRM_Get_Version,   LOCAL
        NVRM_Service    NVRM_Enable_Vga,    LOCAL
        NVRM_Service    NVRM_Fixup_Vga,     LOCAL
        NVRM_Service    NVRM_Enable_Hires,  LOCAL
        NVRM_Service    NVRM_Set_Dpm_Level, LOCAL
        NVRM_Service    NVRM_DDC,           LOCAL
        NVRM_Service    NVRM_ServicePlace,  LOCAL
        NVRM_Service    NVRM_GetAddress,    LOCAL
        NVRM_Service    NVRM_AuNote,        LOCAL
End_Service_Table NVRM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\VBE30.INC ===
;       Copyright (C) 1996-1997 NVidia Corporation
;
;       VBE30.INC - VESA VBE 3.0 constants, structure and data definitions
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/10/96
;
;       $Revision: 1 $
;       $Date: 5/13/97 10:43a $
;       $Logfile: /resman.040/win96/vdd/VBE30.INC $
;       $Log: /resman.040/win96/vdd/VBE30.INC $
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 3     1/23/97 11:02a Markk
; Removed tabs.
; 
; 2     11/19/96 2:03p Markk
; Fixed bug with size of ModeInfoBlock.
; 
; 1     10/16/96 9:16a Markk
; VESA VBE 3.0 definitions for use by the Mini-VDD.
; 
;
VESA_SET_MODE           equ     04F02h
;
VESA_SUCCESS            equ     004Fh        
VESA_NOSUCCESS          equ     014fh        ; Supported function unsuccessful.
;
; VBE_InfoBlock data structure (as defined by VBE 2.0 revision 0.3)
;
VBE_InfoBlock   struc
        VESASignature           db      'VESA'          ; VBE Signature
        VESAVersion             dw      200h            ; VBE Version
        OEMStringPtr            dd      ?               ; Pointer to OEM string
        VBE_Capabilities        db      4 dup (?)       ; Capabilities of graphics
        VBE_ModePtr             dd      ?               ; Pointer to VBE mode list
        VBE_TotalMemory         dw      ?               ; Number of 64K memory blocks
; VBE 2.0 stuff
        VBE_SoftwareRev         dw      ?               ; VBE BIOS Software revision
        VBE_VendorNamePtr       dd      ?               ; Pointer to Vendor Name string
        VBE_ProductNamePtr      dd      ?               ; Pointer to Product Name string
        VBE_ProductRevPtr       dd      ?               ; Pointer to Product Revision string
IFDEF VESA30_REFRESH
        VBE_DotClockPtr         dd      ?               ; Pointer to DotClockList
ENDIF ; VESA30_REFRESH
        Reserved                db      222 dup (?)     ; Reserved
        VBE_OEM_Data            db      256 dup (?)     ; Data Scratch for OEM strings
VBE_InfoBlock   ends
;
VBE_InfoBlock_102       struc   ; Old version of info block structure
        VESASignature_102       db      'VESA'          ; VBE Signature
        VESAVersion_102         dw      102h            ; VBE Version
        OEMStringPtrOff_102     dw      ?               ; Pointer to OEM string (offset)
        OEMStringPtrSeg_102     dw      ?               ; Pointer to OEM string (segment)
        Capabilities_102        dd      ?               ; Capabilities of graphics
        VideoModePtrOff_102     dw      ?               ; Pointer to VBE mode list (offset)
        VideoModePtrSeg_102     dw      ?               ; Pointer to VBE mode list (segment)
        TotalMemory_102         dw      ?               ; Number of 64K memory blocks
VBE_InfoBlock_102       ends
;
; VBE_ModeInfoBlock data structure (as defined by VBE 2.0 revision 0.3)
;
VBE_ModeInfoBlock       struc
; Mandatory (all revisions)
        ModeAttributes          dw      ?       ; Mode attributes
        WinAAttributes          db      ?       ; Window A attributes
        WinBAttributes          db      ?       ; Window B attributes
        WinGranularity          dw      ?       ; Window granularity
        WinSize                 dw      ?       ; Window size
        WinASegment             dw      ?       ; Window A start segment
        WinBSegment             dw      ?       ; Window B start segment
        WinFuncPtr              dd      ?       ; Pointer to window function
        BytesPerScanLine        dw      ?       ; Bytes per scan line
; Mandatory (VBE 1.20 and above)
        XResolution             dw      ?       ; Horizontal resolution
        YResolution             dw      ?       ; Vertical resolution
        XCharSize               db      ?       ; Character cell width
        YCharSize               db      ?       ; Character cell height
        NumberOfPlanes          db      ?       ; Number of memory planes
        BitsPerPixel            db      ?       ; Bits per pixel
        NumberOfBanks           db      ?       ; Number of banks
        MemoryModel             db      ?       ; Memory model type
        BankSize                db      ?       ; Bank size in KB
        NumberOfImagePages      db      ?       ; Number of images
        Reserved1               db      1       ; Reserved for page function
; Direct color fields (required for direct/6 and YUV/7 models)
        RedMaskSize             db      ?       ; Size of direct color red mask in bits
        RedFieldPosition        db      ?       ; Bit position of LSB of red mask
        GreenMaskSize           db      ?       ; Size of direct color green mask in bits
        GreenFieldPosition      db      ?       ; Bit position of LSB of green mask
        BlueMaskSize            db      ?       ; Size of direct color blue mask in bits
        BlueFieldPosition       db      ?       ; Bit position of LSB of blue mask
        ReservedMaskSize        db      ?       ; Size of direct color reserved mask in bits
        ReservedFieldPosition   db      ?       ; Bit position of LSB of reserved mask
        DirectColorModeInfo     db      ?       ; Direct color mode attributes
; Mandatory information (VBE 2.00 and above)
        PhysBasePtr             dd      ?       ; Physical address for flat frame buffer
        OffScreenMemPtr         dd      ?       ; Pointer to start of off-screen memory
        OffScreenMemPtrSize     dw      ?       ; Amount of off-screen memory in 1K units
IFDEF VESA30
; Optional information for VBE 3.0 and above (filled with zeroes if same in linear modes)
        LinBytesPerScanLine     dw      ?       ; Bytes per scan line for linear modes
        BnkNumberOfImagePages   db      ?       ; Number of images for banked modes
        LinNumberOfImagePages   db      ?       ; Number of images for linear modes
        LinRedMaskSize          db      ?       ; Size of direct color red mask (linear modes)
        LinRedFieldPosition     db      ?       ; Bit position of lsb of red mask (linear modes)
        LinGreenMaskSize        db      ?       ; Size of direct color green mask  (linear modes)
        LinGreenFieldPosition   db      ?       ; Bit position of lsb of green mask (linear modes)
        LinBlueMaskSize         db      ?       ; Size of direct color blue mask  (linear modes)
        LinBlueFieldPosition    db      ?       ; Bit position of lsb of blue mask (linear modes)
        LinRsvdMaskSize         db      ?       ; Size of direct color reserved mask (linear modes)
        LinRsvdFieldPosition    db      ?       ; Bit position of lsb of reserved mask (linear modes)
IFDEF VESA30_REFRESH
; Mandatory information (VBE 3.0 and above)
        MaxDotClock             dw      ?       ; Maximum dot clock for graphics mode
        DotClockScaleFactor     dw      ?       ; Dot clock scaling factor for mode
        IntDotClockScaleFactor  dw      ?       ; Interlaced dot clock scaling factor for mode
        Reserved2               db      188 dup (?)
ELSE ; VESA30_REFRESH
        Reserved2               db      194 dup (?)
ENDIF ; VESA30_REFRESH
ELSE ; VESA30
        Reserved2               db      206 dup (?)
ENDIF ; VESA30
VBE_ModeInfoBlock   ends
;
IFDEF VESA30_REFRESH
CRTCInfoBlock           struc
HorizontalTotal                 dw      ?       ; Normalized horizontal total in pixels
HorizontalSyncStart             dw      ?       ; Normalized horizontal sync start in pixels
HorizontalSyncEnd               dw      ?       ; Normalized horizontal sync end in pixels
VerticalTotal                   dw      ?       ; Normalized vertical total in lines
VerticalSyncStart               dw      ?       ; Normalized vertical sync start in lines
VerticalSyncEnd                 dw      ?       ; Normalized vertical sync end in lines
HorizontalSyncPolarity          db      ?       ; Horizontal sync polarity '+' or '-'
VerticalSyncPolarity            db      ?       ; Vertical sync polarity '+' or '-'
Flags                           db      ?       ; 0 for non-interlaced, 1 for interlaced
PhysDotClock                    dw      ?       ; Physical dot clock in KHz * 100 
RefreshRate                     dw      ?       ; Refresh rate in Hz * 100
Reserved                        db      40 dup (?)  ; remainder of ModeInfoBlock
CRTCInfoBlock           ends
ENDIF ; VESA30_REFRESH
;
VBEStateSave    struc
        SeqIndex        db      ?               ; SEQ index
        Miscreg         db      ?               ; Extended misc reg (3C5[11])
        GraIndex        db      ?               ; GDC index
        CRTIndex        db      ?               ; CRTC index
        ATCToggle       db      ?               ; ATC toggle state
        ATCIndex        db      ?               ; ATC index register
        OvrColH         db      ?               ; Overscan Color High (3C0[15])
        BankSelReg      db      ?               ; Bank Select
        LowSeqRegs      db      2 dup (?)       ; SEQ[5..6]
        HighSeqRegs     db      5 dup (?)       ; SEQ[12..16]
        CRTRegs         db      5 dup (?)       ; CRTC[19..1D]
        GDCRegs         db      8 dup (?)       ; GDC[9..10]
        DACMode         db      ?               ; DAC Mode control
        FreqIndex       db      ?               ; Frequency synthesizer index
        FreqRegs        dw      8 dup (?)       ; Frequency synthesizer clock words
        DACAuxCtrl      db      ?               ; DAC auxiliary and power down control
VBEStateSave    ends
;
; Number of 64-byte blocks needed for save/restore state information
;
if ((size VBEStateSave) MOD 64) GT 0
  SVGABLOCKS    equ     (size VBEStateSave)/64 + 1
else
  SVGABLOCKS    equ     (size VBEStateSave)/64
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\CMACROS.INC ===
IFNDEF MASM6
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
ELSE  ;MASM6
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
??CM_Paste macro arg1:req, arg2:req
exitm <arg1&arg2>
endm
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
%out e r r o r ----- msg
.err e r r o r ----- msg
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.30 - Copyright (c) Microsoft Corp. 1984-1991>
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small Model>
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = ?PLM
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ??CM_Paste(?,x))
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ??CM_Paste(?,x))
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ??CM_Paste(?,x)
n=n or ??CM_Paste(?,x)
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?pcc
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmH macro n
?pp <n>,<word>,4,2
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
ife ?pcc
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?pcc
n equ (t ptr [bp][+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc macro po
uconcat <n>,,<equ>,,<(t ptr [bp][+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp][-o-2])
.xcref ?t_&n
?t_&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp][-o])
.xcref ?t_&n
?t_&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ??CM_Paste(?,x) eq ??CM_Paste(?,r)
n equ (byte ptr [bp][-o])
??CM_Paste(?t_,n)=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <%??CM_Paste(seg_,x)>,<word ptr>,2,2,1
?aloc <%??CM_Paste(off_,x)>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp][-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ word ptr n[0]
seg_&n equ word ptr n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?ex2
extrn ??CM_Paste(_,x):&d
x equ ??CM_Paste(_,x)
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ??CM_Paste(?CC,x)
.cref
??CM_Paste(?CC,x)=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?lb2
if ?lblpu
public ??CM_Paste(_,x)
endif
??CM_Paste(_,x) label &d
x equ ??CM_Paste(_,x)
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t_&n
.cref
n macro
	push	s
	push	o
endm
?t_&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i macro
?ap <n>
endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t_&n
ife ?t_&n-1
	push	word ptr (n)
exitm
endif
ife ?t_&n-2
	push	n
exitm
endif
ife ?t_&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t_&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t_&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t_&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 macro arg
purge ?PLMParm0
endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
endm
.xcref ?utpe
?utpe macro
??error <unterminated procedure definition: "&n">
endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,(-2)[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
endm
.cref
endm
assumes macro s,ln
ifdef MS_STARTUP
ifidn <code>,<ln>
assume s&:_TEXT
exitm
elseifidn <CODE>,<ln>
assume s&:_TEXT
exitm
elseifidn <data>,<ln>
assume s&:dgroup
exitm
elseifidn <DATA>,<ln>
assume s&:dgroup
exitm
endif
endif
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
ifnb <grp>
grp group n
?cs3 <ln>,<grp>
ln&OFFSET equ <offset grp:>
ln&BASE equ <grp>
else
?cs3 <ln>,<n>
ln&OFFSET equ <offset>
ln&BASE equ <n>
endif
endm
addseg macro grp,seg
.xcref
.xcref grp&_add
.cref
grp&_add macro s
grp&_in <seg>,s
endm
.xcref
.xcref grp&_in
.cref
grp&_in macro sl,s
ifb <s>
grp group sl
else
grp&_add macro ns
grp&_in <sl,s>,ns
endm
endif
endm
endm
defgrp macro grp,ln
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin macro
?cs2 <ln>,<n>
n segment
.xcref
.xcref ?mf
.cref
?mf macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
endm
endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd macro arg
n ends
purge ?mf
purge sEnd
endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes macro s
assume s:&n
endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
ifnb <x>
.errnz (x),<x>
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
callcrt MACRO funcname
ifdef _QC2
call funcname
else
if sizeC
push cs
call near ptr (funcname)
else
call funcname
endif
endif
ENDM
.cref
ENDIF ;MASM6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\CONFIGMG.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

//#ifdef	GOLDEN	
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
//#endif

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
	"Find_Range", \
	"Get_Global_State", \
	"Broadcast_Device_Change_Message", \
	"Call_DevNode_Handler", \
	"Remove_Reinsert_All", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_NO_MORE_HW_PROFILES	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_FREE_RESOURCES	0x00000029
#define	CR_QUERY_VETOED		0x0000002A
#define	CR_CANT_SHARE_IRQ	0x0000002B
#define	NUM_CR_RESULTS		0x0000002C

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E
#define	NUM_CM_PROB				0x0000001F

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down

#define	NUM_CONFIG_COMMANDS	0x00000013	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\basedef.inc ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

option expr32

IFNDEF	basedef_inc
basedef_inc	EQU		1

; Begin of file ..\..\..\dev\ddk\inc\basedef.h
FALSE		EQU		0t
TRUE		EQU		1t
NULL		EQU		000000000h
_INT		TYPEDEF		SWORD

UINT		TYPEDEF		WORD

BOOL		TYPEDEF		SWORD

CHAR		TYPEDEF		SBYTE

UCHAR		TYPEDEF		BYTE

_SHORT		TYPEDEF		SWORD

USHORT		TYPEDEF		WORD

LONG		TYPEDEF		SDWORD

ULONG		TYPEDEF		DWORD

PVOID		TYPEDEF		PTR 

PPVOID		TYPEDEF		PTR PVOID

PINT		TYPEDEF		PTR _INT

PUINT		TYPEDEF		PTR UINT

PBYTE		TYPEDEF		PTR BYTE

PWORD		TYPEDEF		PTR WORD

PDWORD		TYPEDEF		PTR DWORD

PCHAR		TYPEDEF		PTR CHAR

PSHORT		TYPEDEF		PTR _SHORT

PLONG		TYPEDEF		PTR LONG

PUCHAR		TYPEDEF		PTR UCHAR

PUSHORT		TYPEDEF		PTR USHORT

PULONG		TYPEDEF		PTR ULONG

PBOOL		TYPEDEF		PTR BOOL

SZ		TYPEDEF		UCHAR

PSZ		TYPEDEF		PTR UCHAR

SZZ		TYPEDEF		UCHAR

PSZZ		TYPEDEF		PTR UCHAR

SEL		TYPEDEF		USHORT

PSEL		TYPEDEF		PTR SEL

PPHYS		TYPEDEF		ULONG

PFN		TYPEDEF		PTR 

PPFN		TYPEDEF		PTR PFN

HANDLE		TYPEDEF		PVOID

PHANDLE		TYPEDEF		PTR HANDLE

HTIMEOUT		TYPEDEF		ULONG

CMS		TYPEDEF		ULONG

; End of file ..\..\..\dev\ddk\inc\basedef.h

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\BASEDEF.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/***    BASEDEF.H
 *
 *      Basic constants and types for the VMM and VxDs
 *
 *      NOBASEDEFS turns off the base definations
 */

#ifndef NOBASEDEFS
#define NOBASEDEFS

/*
 *  No warnings generated on non-standard usuage such as double
 *  slash for comments
 */
#pragma warning (disable:4206)
#pragma warning (disable:4214)
#pragma warning (disable:4505)
#pragma warning (disable:4001)

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE	1
#endif
#ifndef NULL
#define NULL    '\0'                    // Null pointer
#endif

#define CDECL   _cdecl
#define PASCAL  _pascal
#define VOID    void
#define CONST   const
#define VOLATILE volatile

typedef int INT;                        // i
typedef unsigned int UINT;              // u
typedef int BOOL;                       // f

typedef unsigned char BYTE;             // b
typedef unsigned short WORD;            // w
typedef unsigned long DWORD;            // dw

#ifndef _H2INC

typedef struct qword_s {                /* qword */
   DWORD qword_lo;
   DWORD qword_hi;
} QWORD;				// qw

#endif 

typedef char CHAR;                      // ch
typedef unsigned char UCHAR;            // uch
typedef short SHORT;                    // s
typedef unsigned short USHORT;          // us
typedef long LONG;                      // l
typedef unsigned long ULONG;            // ul

typedef VOID *PVOID;                    // p
typedef PVOID *PPVOID;                  // pp

typedef INT *PINT;                      // pi
typedef UINT *PUINT;                    // pu
typedef BYTE *PBYTE;                    // pb
typedef WORD *PWORD;                    // pw
typedef DWORD *PDWORD;                  // pdw
typedef CHAR *PCHAR;                    // pch
typedef SHORT *PSHORT;                  // ps
typedef LONG *PLONG;                    // pl
typedef UCHAR *PUCHAR;                  // puch
typedef USHORT *PUSHORT;                // pus
typedef ULONG *PULONG;                  // pul
typedef BOOL *PBOOL;                    // pf

typedef UCHAR SZ[];                     // sz
typedef UCHAR *PSZ;                     // psz
typedef UCHAR SZZ[];                    // szz
typedef UCHAR *PSZZ;                    // pszz

typedef USHORT SEL;                     // sel
typedef SEL *PSEL;                      // psel

typedef ULONG PPHYS;                    // pphys

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

typedef PVOID HANDLE;                   // h
typedef HANDLE *PHANDLE;                // ph

typedef ULONG HTIMEOUT;			// timeout handle
typedef ULONG CMS;			// count of milliseconds

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))

#endif // NOBASEDEFS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\CONFIGMG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef _CONFIGMG_H
_CONFIGMG_H	EQU	1
CONFIGMG_VERSION	EQU	0400H
PNPDRVS_Major_Ver	EQU	0004H
PNPDRVS_Minor_Ver	EQU	0000H
ifdef	MAXDEBUG
CM_PERFORMANCE_INFO	EQU	1
endif
ifndef	DEBUG
CM_GOLDEN_RETAIL	EQU	1
endif
ifndef	NORESDES
ResType_All	EQU	00000000H
ResType_None	EQU	00000000H
ResType_Mem	EQU	00000001H
ResType_IO	EQU	00000002H
ResType_DMA	EQU	00000003H
ResType_IRQ	EQU	00000004H
ResType_Max	EQU	00000004H
ResType_Ignored_Bit	EQU	00008000H
DEBUG_RESTYPE_NAMES	EQU	<charCMFAR*lpszResourceName[ResType_Max+1]{"All/None","Mem","IO","DMA","IRQ",}>
MType_Range	EQU	SIZE Mem_Range_s
fMD_MemoryType	EQU	1
fMD_ROM	EQU	0
fMD_RAM	EQU	1
fMD_32_24	EQU	2
fMD_24	EQU	0
fMD_32	EQU	2

Mem_Range_s	STRUC
MR_Align	DD	?
MR_nBytes	DD	?
MR_Min	DD	?
MR_Max	DD	?
MR_Flags	DW	?
MR_Reserved	DW	?
Mem_Range_s	ENDS

Mem_Des_s	STRUC
MD_Count	DW	?
MD_Type	DW	?
MD_Alloc_Base	DD	?
MD_Alloc_End	DD	?
MD_Flags	DW	?
MD_Reserved	DW	?
Mem_Des_s	ENDS
IOType_Range	EQU	SIZE IO_Range_s

IO_Range_s	STRUC
IOR_Align	DW	?
IOR_nPorts	DW	?
IOR_Min	DW	?
IOR_Max	DW	?
IOR_RangeFlags	DW	?
IOR_Alias	DB	?
IOR_Decode	DB	?
IO_Range_s	ENDS

IO_Des_s	STRUC
IOD_Count	DW	?
IOD_Type	DW	?
IOD_Alloc_Base	DW	?
IOD_Alloc_End	DW	?
IOD_DesFlags	DW	?
IOD_Alloc_Alias	DB	?
IOD_Alloc_Decode	DB	?
IO_Des_s	ENDS
IOA_Local	EQU	0ffH
mDD_Width	EQU	0003H
fDD_BYTE	EQU	0
fDD_WORD	EQU	1
fDD_DWORD	EQU	2
szDMA_Des_Flags	EQU	<"WD">

DMA_Des_s	STRUC
DD_Flags	DB	?
DD_Alloc_Chan	DB	?
DD_Req_Mask	DB	?
DD_Reserved	DB	?
DMA_Des_s	ENDS
fIRQD_Share	EQU	1
cIRQ_Des_Flags	EQU	<'S'>

IRQ_Des_s	STRUC
IRQD_Flags	DW	?
IRQD_Alloc_Num	DW	?
IRQD_Req_Mask	DW	?
IRQD_Reserved	DW	?
IRQ_Des_s	ENDS
endif
LCPRI_FORCECONFIG	EQU	00000000H
LCPRI_BOOTCONFIG	EQU	00000001H
LCPRI_DESIRED	EQU	00002000H
LCPRI_NORMAL	EQU	00003000H
LCPRI_LASTBESTCONFIG	EQU	00003FFFH
LCPRI_SUBOPTIMAL	EQU	00005000H
LCPRI_LASTSOFTCONFIG	EQU	00007FFFH
LCPRI_RESTART	EQU	00008000H
LCPRI_REBOOT	EQU	00009000H
LCPRI_POWEROFF	EQU	0000A000H
LCPRI_HARDRECONFIG	EQU	0000C000H
LCPRI_HARDWIRED	EQU	0000E000H
LCPRI_IMPOSSIBLE	EQU	0000F000H
LCPRI_DISABLED	EQU	0000FFFFH
MAX_LCPRI	EQU	0000FFFFH
MAX_MEM_REGISTERS	EQU	9
MAX_IO_PORTS	EQU	20
MAX_IRQS	EQU	7
MAX_DMA_CHANNELS	EQU	7

Config_Buff_s	STRUC
wNumMemWindows	DW	?
dMemBase	DD	MAX_MEM_REGISTERS DUP (?)
dMemLength	DD	MAX_MEM_REGISTERS DUP (?)
wMemAttrib	DW	MAX_MEM_REGISTERS DUP (?)
wNumIOPorts	DW	?
wIOPortBase	DW	MAX_IO_PORTS DUP (?)
wIOPortLength	DW	MAX_IO_PORTS DUP (?)
wNumIRQs	DW	?
bIRQRegisters	DB	MAX_IRQS DUP (?)
bIRQAttrib	DB	MAX_IRQS DUP (?)
wNumDMAs	DW	?
bDMALst	DB	MAX_DMA_CHANNELS DUP (?)
wDMAAttrib	DW	MAX_DMA_CHANNELS DUP (?)
bReserved1	DB	3 DUP (?)
Config_Buff_s	ENDS
ifndef	CMJUSTRESDES
MAX_DEVICE_ID_LEN	EQU	200
INCLUDE vmmreg.INC
Begin_Service_Table CONFIGMG, VxD
CONFIGMG_Service	 _CONFIGMG_Get_Version, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Initialize, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Locate_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Parent, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Child, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Sibling, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Device_ID_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Device_ID, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Depth, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Create_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Remove_SubTree, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Remove_SubTree, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Device_Driver, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Enumerator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Arbitrator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Deregister_Arbitrator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Sort_NodeList, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Yield, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Lock, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Unlock, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_Empty_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Free_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_First_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Next_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Modify_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Free_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Next_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Performance_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Res_Des_Data, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Process_Events_Now, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Create_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Delete_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Test_Range_Available, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Dup_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Free_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Invert_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Intersect_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_First_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Next_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Dump_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Load_DLVxDs, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DDBs, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_CRC_CheckSum, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_DevLoader, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Reenumerate_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Setup_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Reset_Children_Marks, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DevNode_Status, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Remove_Unmarked_Children, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_ISAPNP_To_CM, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_CallBack_Device_Driver, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_CallBack_Enumerator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DevNode_Key_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DevNode_Key, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Read_Registry_Value, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Write_Registry_Value, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Disable_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Enable_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Move_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Bus_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Bus_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Recompute_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Change_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_HW_Prof_Flags, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_HW_Prof_Flags, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Read_Registry_Log_Confs, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Run_Detection, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Call_At_Appy_Time, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Fail_Change_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Private_Problem, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Debug_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Enumerator_Function, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Call_Enumerator_Function, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_ID, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Find_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Global_State, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Call_DevNode_Handler, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Remove_Reinsert_All, VxD_CODE
End_Service_Table CONFIGMG, VxD
BusType_None	EQU	00000000H
BusType_ISA	EQU	00000001H
BusType_EISA	EQU	00000002H
BusType_PCI	EQU	00000004H
BusType_PCMCIA	EQU	00000008H
BusType_ISAPNP	EQU	00000010H
BusType_MCA	EQU	00000020H
BusType_BIOS	EQU	00000040H
CR_SUCCESS	EQU	00000000H
CR_DEFAULT	EQU	00000001H
CR_OUT_OF_MEMORY	EQU	00000002H
CR_INVALID_POINTER	EQU	00000003H
CR_INVALID_FLAG	EQU	00000004H
CR_INVALID_DEVNODE	EQU	00000005H
CR_INVALID_RES_DES	EQU	00000006H
CR_INVALID_LOG_CONF	EQU	00000007H
CR_INVALID_ARBITRATOR	EQU	00000008H
CR_INVALID_NODELIST	EQU	00000009H
CR_DEVNODE_HAS_REQS	EQU	0000000AH
CR_INVALID_RESOURCEID	EQU	0000000BH
CR_DLVXD_NOT_FOUND	EQU	0000000CH
CR_NO_SUCH_DEVNODE	EQU	0000000DH
CR_NO_MORE_LOG_CONF	EQU	0000000EH
CR_NO_MORE_RES_DES	EQU	0000000FH
CR_ALREADY_SUCH_DEVNODE	EQU	00000010H
CR_INVALID_RANGE_LIST	EQU	00000011H
CR_INVALID_RANGE	EQU	00000012H
CR_FAILURE	EQU	00000013H
CR_NO_SUCH_LOGICAL_DEV	EQU	00000014H
CR_CREATE_BLOCKED	EQU	00000015H
CR_NOT_SYSTEM_VM	EQU	00000016H
CR_REMOVE_VETOED	EQU	00000017H
CR_APM_VETOED	EQU	00000018H
CR_INVALID_LOAD_TYPE	EQU	00000019H
CR_BUFFER_SMALL	EQU	0000001AH
CR_NO_ARBITRATOR	EQU	0000001BH
CR_NO_REGISTRY_HANDLE	EQU	0000001CH
CR_REGISTRY_ERROR	EQU	0000001DH
CR_INVALID_DEVICE_ID	EQU	0000001EH
CR_INVALID_DATA	EQU	0000001FH
CR_INVALID_API	EQU	00000020H
CR_DEVLOADER_NOT_READY	EQU	00000021H
CR_NEED_RESTART	EQU	00000022H
CR_NO_MORE_HW_PROFILES	EQU	00000023H
CR_DEVICE_NOT_THERE	EQU	00000024H
CR_NO_SUCH_VALUE	EQU	00000025H
CR_WRONG_TYPE	EQU	00000026H
CR_INVALID_PRIORITY	EQU	00000027H
CR_NOT_DISABLEABLE	EQU	00000028H
CR_FREE_RESOURCES	EQU	00000029H
CR_QUERY_VETOED	EQU	0000002AH
CR_CANT_SHARE_IRQ	EQU	0000002BH
NUM_CR_RESULTS	EQU	0000002CH
CM_PROB_NOT_CONFIGURED	EQU	00000001H
CM_PROB_DEVLOADER_FAILED	EQU	00000002H
CM_PROB_OUT_OF_MEMORY	EQU	00000003H
CM_PROB_ENTRY_IS_WRONG_TYPE	EQU	00000004H
CM_PROB_LACKED_ARBITRATOR	EQU	00000005H
CM_PROB_BOOT_CONFIG_CONFLICT	EQU	00000006H
CM_PROB_FAILED_FILTER	EQU	00000007H
CM_PROB_DEVLOADER_NOT_FOUND	EQU	00000008H
CM_PROB_INVALID_DATA	EQU	00000009H
CM_PROB_FAILED_START	EQU	0000000AH
CM_PROB_LIAR	EQU	0000000BH
CM_PROB_NORMAL_CONFLICT	EQU	0000000CH
CM_PROB_NOT_VERIFIED	EQU	0000000DH
CM_PROB_NEED_RESTART	EQU	0000000EH
CM_PROB_REENUMERATION	EQU	0000000FH
CM_PROB_PARTIAL_LOG_CONF	EQU	00000010H
CM_PROB_UNKNOWN_RESOURCE	EQU	00000011H
CM_PROB_REINSTALL	EQU	00000012H
CM_PROB_REGISTRY	EQU	00000013H
CM_PROB_VXDLDR	EQU	00000014H
CM_PROB_WILL_BE_REMOVED	EQU	00000015H
CM_PROB_DISABLED	EQU	00000016H
CM_PROB_DEVLOADER_NOT_READY	EQU	00000017H
CM_PROB_DEVICE_NOT_THERE	EQU	00000018H
CM_PROB_MOVED	EQU	00000019H
CM_PROB_TOO_EARLY	EQU	0000001AH
CM_PROB_NO_VALID_LOG_CONF	EQU	0000001BH
CM_PROB_FAILED_INSTALL	EQU	0000001CH
CM_PROB_HARDWARE_DISABLED	EQU	0000001DH
CM_PROB_CANT_SHARE_IRQ	EQU	0000001EH
NUM_CM_PROB	EQU	0000001FH
CM_INITIALIZE_VMM	EQU	00000000H
CM_INITIALIZE_VXDLDR	EQU	00000001H
CM_INITIALIZE_BITS	EQU	00000001H
CM_YIELD_NO_RESUME_EXEC	EQU	00000000H
CM_YIELD_RESUME_EXEC	EQU	00000001H
CM_YIELD_BITS	EQU	00000001H
CM_CREATE_DEVNODE_NORMAL	EQU	00000000H
CM_CREATE_DEVNODE_NO_WAIT_INSTALL	EQU	00000001H
CM_CREATE_DEVNODE_BITS	EQU	00000001H
CM_REGISTER_DEVICE_DRIVER_STATIC	EQU	00000000H
CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	EQU	00000001H
CM_REGISTER_DEVICE_DRIVER_REMOVABLE	EQU	00000002H
CM_REGISTER_DEVICE_DRIVER_BITS	EQU	00000003H
CM_REGISTER_ENUMERATOR_SOFTWARE	EQU	00000000H
CM_REGISTER_ENUMERATOR_HARDWARE	EQU	00000001H
CM_REGISTER_ENUMERATOR_BITS	EQU	00000001H
CM_QUERY_REMOVE_UI_OK	EQU	00000000H
CM_QUERY_REMOVE_UI_NOT_OK	EQU	00000001H
CM_QUERY_REMOVE_BITS	EQU	00000001H
CM_REMOVE_UI_OK	EQU	00000000H
CM_REMOVE_UI_NOT_OK	EQU	00000001H
CM_REMOVE_BITS	EQU	00000001H
CM_SETUP_DEVNODE_READY	EQU	00000000H
CM_SETUP_DOWNLOAD	EQU	00000001H
CM_SETUP_WRITE_LOG_CONFS	EQU	00000002H
CM_SETUP_PROP_CHANGE	EQU	00000003H
CM_SETUP_BITS	EQU	00000003H
CM_ADD_RANGE_ADDIFCONFLICT	EQU	00000000H
CM_ADD_RANGE_DONOTADDIFCONFLICT	EQU	00000001H
CM_ADD_RANGE_BITS	EQU	00000001H
CM_ISAPNP_ADD_RES_DES	EQU	00000000H
CM_ISAPNP_SETUP	EQU	00000001H
CM_ISAPNP_ADD_BOOT_RES_DES	EQU	00000002H
CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	EQU	00000003H
CM_ISAPNP_BITS	EQU	00000003H
CM_GET_PERFORMANCE_INFO_DATA	EQU	00000000H
CM_GET_PERFORMANCE_INFO_RESET	EQU	00000001H
CM_GET_PERFORMANCE_INFO_START	EQU	00000002H
CM_GET_PERFORMANCE_INFO_STOP	EQU	00000003H
CM_RESET_HIT_DATA	EQU	00000004H
CM_GET_HIT_DATA	EQU	00000005H
CM_GET_PERFORMANCE_INFO_BITS	EQU	0000000FH
CM_HIT_DATA_FILES	EQU	0FFFF0000H
CM_HIT_DATA_SIZE	EQU	((256*8)+8)
CM_GET_ALLOC_LOG_CONF_ALLOC	EQU	00000000H
CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	EQU	00000001H
CM_GET_ALLOC_LOG_CONF_BITS	EQU	00000001H
CM_REGISTRY_HARDWARE	EQU	00000000H
CM_REGISTRY_SOFTWARE	EQU	00000001H
CM_REGISTRY_USER	EQU	00000100H
CM_REGISTRY_CONFIG	EQU	00000200H
CM_REGISTRY_BITS	EQU	00000301H
CM_DISABLE_POLITE	EQU	00000000H
CM_DISABLE_ABSOLUTE	EQU	00000001H
CM_DISABLE_HARDWARE	EQU	00000002H
CM_DISABLE_BITS	EQU	00000003H
CM_HW_PROF_UNDOCK	EQU	00000000H
CM_HW_PROF_DOCK	EQU	00000001H
CM_HW_PROF_RECOMPUTE_BITS	EQU	00000001H
CM_HW_PROF_DOCK_KNOWN	EQU	00000002H
CM_HW_PROF_QUERY_CHANGE_BITS	EQU	00000003H
CM_DETECT_NEW_PROFILE	EQU	00000001H
CM_DETECT_CRASHED	EQU	00000002H
CM_DETECT_HWPROF_FIRST_BOOT	EQU	00000004H
CM_DETECT_RUN	EQU	80000000H
CM_ADD_ID_HARDWARE	EQU	00000000H
CM_ADD_ID_COMPATIBLE	EQU	00000001H
CM_ADD_ID_BITS	EQU	00000001H
CM_REENUMERATE_NORMAL	EQU	00000000H
CM_REENUMERATE_SYNCHRONOUS	EQU	00000001H
CM_REENUMERATE_BITS	EQU	00000001H
CM_BROADCAST_SEND	EQU	00000000H
CM_BROADCAST_QUERY	EQU	00000001H
CM_BROADCAST_BITS	EQU	00000001H
CM_CALL_HANDLER_ENUMERATOR	EQU	00000000H
CM_CALL_HANDLER_DEVICE_DRIVER	EQU	00000001H
CM_CALL_HANDLER_BITS	EQU	00000001H
CM_GLOBAL_STATE_CAN_DO_UI	EQU	00000001H
CM_GLOBAL_STATE_ON_BIG_STACK	EQU	00000002H
CM_GLOBAL_STATE_SERVICES_AVAILABLE	EQU	00000004H
CM_GLOBAL_STATE_SHUTING_DOWN	EQU	00000008H
CM_GLOBAL_STATE_DETECTION_PENDING	EQU	00000010H
CM_REMOVE_REINSERT_ALL_REMOVE	EQU	00000000H
CM_REMOVE_REINSERT_ALL_REINSERT	EQU	00000001H
CM_REMOVE_REINSERT_ALL_BITS	EQU	00000001H
CONFIG_FILTER	EQU	00000000H
CONFIG_START	EQU	00000001H
CONFIG_STOP	EQU	00000002H
CONFIG_TEST	EQU	00000003H
CONFIG_REMOVE	EQU	00000004H
CONFIG_ENUMERATE	EQU	00000005H
CONFIG_SETUP	EQU	00000006H
CONFIG_CALLBACK	EQU	00000007H
CONFIG_APM	EQU	00000008H
CONFIG_TEST_FAILED	EQU	00000009H
CONFIG_TEST_SUCCEEDED	EQU	0000000AH
CONFIG_VERIFY_DEVICE	EQU	0000000BH
CONFIG_PREREMOVE	EQU	0000000CH
CONFIG_SHUTDOWN	EQU	0000000DH
CONFIG_PREREMOVE2	EQU	0000000EH
CONFIG_READY	EQU	0000000FH
CONFIG_PROP_CHANGE	EQU	00000010H
CONFIG_PRIVATE	EQU	00000011H
CONFIG_PRESHUTDOWN	EQU	00000012H
NUM_CONFIG_COMMANDS	EQU	00000013H
CONFIG_START_DYNAMIC_START	EQU	00000000H
CONFIG_START_FIRST_START	EQU	00000001H
CONFIG_STOP_DYNAMIC_STOP	EQU	00000000H
CONFIG_STOP_HAS_PROBLEM	EQU	00000001H
CONFIG_REMOVE_DYNAMIC	EQU	00000000H
CONFIG_REMOVE_SHUTDOWN	EQU	00000001H
CONFIG_REMOVE_REBOOT	EQU	00000002H
CONFIG_TEST_CAN_STOP	EQU	00000000H
CONFIG_TEST_CAN_REMOVE	EQU	00000001H
CONFIG_APM_TEST_STANDBY	EQU	00000000H
CONFIG_APM_TEST_SUSPEND	EQU	00000001H
CONFIG_APM_TEST_STANDBY_FAILED	EQU	00000002H
CONFIG_APM_TEST_SUSPEND_FAILED	EQU	00000003H
CONFIG_APM_TEST_STANDBY_SUCCEEDED	EQU	00000004H
CONFIG_APM_TEST_SUSPEND_SUCCEEDED	EQU	00000005H
CONFIG_APM_RESUME_STANDBY	EQU	00000006H
CONFIG_APM_RESUME_SUSPEND	EQU	00000007H
CONFIG_APM_RESUME_CRITICAL	EQU	00000008H
CONFIG_APM_UI_ALLOWED	EQU	80000000H
ARB_TEST_ALLOC	EQU	00000000H
ARB_RETEST_ALLOC	EQU	00000001H
ARB_SET_ALLOC	EQU	00000002H
ARB_RELEASE_ALLOC	EQU	00000003H
ARB_QUERY_FREE	EQU	00000004H
ARB_REMOVE	EQU	00000005H
ARB_FORCE_ALLOC	EQU	00000006H
NUM_ARB_COMMANDS	EQU	00000007H
DEBUG_ARB_NAMES	EQU	<charCMFAR*lpszArbFuncName[NUM_ARB_COMMANDS]{"ARB_TEST_ALLOC","ARB_RETEST_ALLOC","ARB_SET_ALLOC","ARB_RELEASE_ALLOC","ARB_QUERY_FREE","ARB_REMOVE","ARB_FORCE_ALLOC",}>
DN_ROOT_ENUMERATED	EQU	00000001H
DN_DRIVER_LOADED	EQU	00000002H
DN_ENUM_LOADED	EQU	00000004H
DN_STARTED	EQU	00000008H
DN_MANUAL	EQU	00000010H
DN_NEED_TO_ENUM	EQU	00000020H
DN_NOT_FIRST_TIME	EQU	00000040H
DN_HARDWARE_ENUM	EQU	00000080H
DN_LIAR	EQU	00000100H
DN_HAS_MARK	EQU	00000200H
DN_HAS_PROBLEM	EQU	00000400H
DN_FILTERED	EQU	00000800H
DN_MOVED	EQU	00001000H
DN_DISABLEABLE	EQU	00002000H
DN_REMOVABLE	EQU	00004000H
DN_PRIVATE_PROBLEM	EQU	00008000H
DN_MF_PARENT	EQU	00010000H
DN_MF_CHILD	EQU	00020000H
DN_WILL_BE_REMOVED	EQU	00040000H
DLVXD_LOAD_ENUMERATOR	EQU	00000000H
DLVXD_LOAD_DEVLOADER	EQU	00000001H
DLVXD_LOAD_DRIVER	EQU	00000002H
NUM_DLVXD_LOAD_TYPE	EQU	00000003H
ARB_GLOBAL	EQU	00000001H
ARB_LOCAL	EQU	00000000H
ARB_SCOPE_BIT	EQU	00000001H
BASIC_LOG_CONF	EQU	00000000H
FILTERED_LOG_CONF	EQU	00000001H
ALLOC_LOG_CONF	EQU	00000002H
BOOT_LOG_CONF	EQU	00000003H
FORCED_LOG_CONF	EQU	00000004H
NUM_LOG_CONF	EQU	00000005H
LOG_CONF_BITS	EQU	00000007H
DEBUG_LOG_CONF_NAMES	EQU	<charCMFAR*lpszLogConfName[NUM_LOG_CONF]{"BASIC_LOG_CONF","FILTERED_LOG_CONF","ALLOC_LOG_CONF","BOOT_LOG_CONF","FORCED_LOG_CONF",}>
PRIORITY_EQUAL_FIRST	EQU	00000008H
PRIORITY_EQUAL_LAST	EQU	00000000H
PRIORITY_BIT	EQU	00000008H
ifndef	Not_VxD

nodelist_s	STRUC
nl_Next	DD	?
nl_Previous	DD	?
nl_ItsDevNode	DD	?
nl_Test_Req	DD	?
nl_ulSortDWord	DD	?
nodelist_s	ENDS

nodelistheader_s	STRUC
nlh_Head	DD	?
nlh_Tail	DD	?
nodelistheader_s	ENDS

arbitfree_s	STRUC
af_PointerToInfo	DD	?
af_SizeOfInfo	DD	?
arbitfree_s	ENDS
endif

MEM_Arb_s	STRUC
MEMA_Alloc	DD	?
MEM_Arb_s	ENDS

IO_Arb_s	STRUC
IOA_Alloc	DD	?
IO_Arb_s	ENDS

DMA_Arb_s	STRUC
DMAA_Alloc	DW	?
DMA_Arb_s	ENDS

IRQ_Arb_s	STRUC
IRQA_Alloc	DW	?
IRQA_Share	DW	?
IRQA_Share_Count	DB	16 DUP (?)
IRQ_Arb_s	ENDS
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF


CM_API_s	STRUC
pCMAPIStack	DD	?
dwCMAPIService	DD	?
dwCMAPIRet	DD	?
CM_API_s	ENDS
ifndef	MAX_PROFILE_LEN
MAX_PROFILE_LEN	EQU	80
endif

HWProfileInfo_s	STRUC
HWPI_ulHWProfile	DD	?
HWPI_szFriendlyName	DB	MAX_PROFILE_LEN DUP (?)
HWPI_dwFlags	DD	?
HWProfileInfo_s	ENDS
CM_HWPI_NOT_DOCKABLE	EQU	00000000H
CM_HWPI_UNDOCKED	EQU	00000001H
CM_HWPI_DOCKED	EQU	00000002H
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\DEBUG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

NOBUGBUG	EQU	1










BUGBUG	macro	d, id, note
endm





























IsDebugOnlyLoaded	macro	lab
	local	var, magic
_DBOSTART segment
var	label	byte
_DBOSTART ends
	db	0F7h, 05h
	dd	OFFSET32 magic
magic	dd	OFFSET32 var - (MAXSYSTEMLADDR + 1)
ifnb <lab>
	jz	lab
endif
	endm










DPublic MACRO	arg
if DEBLEVEL GT DEBLEVELRETAIL
	public	arg
endif
        ENDM















Assumes_Fall_Through MACRO L
ifndef MASM6
IF2
 IFDEF profileall
  IF (?prolog_&L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ELSE
  IF (L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ENDIF
ENDIF
else
 IFDEF profileall
.errnz ((?prolog_&L - $) GT 3), <ERROR: Fall through to &L invalid>
 ELSE
.errnz ((L - $) GT 3), <ERROR: Fall through to &L invalid>
 ENDIF
endif

     ENDM


ifndef Not_VxD





























??avh_parse_one_arg macro arg
    ifidni <arg>, <USES_FLAGS>
	??_fUsesFlagsPushfd equ <>
	??_fUsesFlagsPopfd equ <>
    elseifnb <arg>
	??_debLevel = arg
    endif
endm

??avh_parse_args macro DL, fUSES_FLAGS
	??_fUsesFlagsPushfd equ <pushfd>
	??_fUsesFlagsPopfd equ <popfd>
	??_debLevel = DEBLEVELNORMAL
	??avh_parse_one_arg <DL>
	??avh_parse_one_arg <fUSES_FLAGS>
endm

Assert_VM_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	[R].CB_Signature, VMCB_ID
	je	SHORT l1
ENDIF
ENDIF

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall	Debug_Test_Valid_Handle
IFDIFI <ebx>, <R>
	pop	ebx
ENDIF

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF
ENDIF

ENDIF

ENDIF
	ENDM




























Assert_Thread_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	dword ptr [R.TCB_Signature], SCHED_OBJ_ID_THREAD
	je	SHORT l1
ENDIF

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Valid_Thread_Handle
IFDIFI <edi>,<R>
        pop     edi
ENDIF

IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF

ENDIF

ENDIF
	ENDM

















Assert_Cur_Thread_Handle MACRO R, DL
	LOCAL myDebLevel
	LOCAL	OK

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel EQU DEBLEVELNORMAL
ELSE
	myDebLevel EQU <DL>
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Cur_Thread
IFDIFI <edi>,<R>
        pop     edi
ENDIF

ENDIF

ENDIF
	ENDM













Debug_Printf	macro	fmt, args, dl
	local	fmtlab, myDebLevel

ife ?_DBOCODE
    ??_fDoit = VMM_TRUE
else
    ??_fDoit = FALSE
endif

if DEBLEVEL GT DEBLEVELRETAIL

ifb <dl>
	myDebLevel EQU <DEBLEVELNORMAL>
else
	myDebLevel EQU <dl>
endif

if DEBLEVEL GE myDebLevel
    ??_fDoit = VMM_TRUE
endif

endif

if ??_fDoit

ife ?_DBOCODE

VxD_DEBUG_ONLY_DATA_SEG
fmtlab	db	fmt, 0
VxD_DEBUG_ONLY_DATA_ENDS

else

ifdef VMMSYS

VMM_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VMM_LOCKED_DATA_ENDS

else

VxD_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VxD_LOCKED_DATA_ENDS

endif

endif

	ifb <args>
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp>
	else
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp, args>
	endif

endif

	endm







CHECK_EOL MACRO f, x, ln
	ifdifi <x>,<noeol>
	ifdifi <x>,<no_eol>
	ifdifi <x>,<nocrlf>
	ifdifi <x>,</noeol>
		%OUT Line ln: Unknown symbol (x) in f, taken as NOEOL
	endif
	endif
	endif
	endif

ENDM

??_Gen_String macro lbl:req, str:req
	ife ?_ICODE
	    ??_segName textequ <_IDATA>
	elseife ?_PCODE
	    ??_segName textequ <_PDATA>
	elseife ?_SCODE
	    ??_segName textequ <_SDATA>
	elseife ?_DBOCODE
	    ??_segName textequ <_DBODATA>
	else
	    ??_segName textequ <_LDATA>
	endif

	??_segName segment
	    lbl	db	str
	    ife ??_nocrlf
		db	0dh,0ah
	    endif
		db	0
	??_segName ends
endm


??Trace_Debug_Helper macro typ, str, arg1, arg2
	local	string

    ife ?_DBOCODE
	??_fDoit = VMM_TRUE
    else
	??_fDoit = 0
    endif

    if (DEBLEVEL GT DEBLEVELRETAIL) OR ??_fDoit

	??_nocrlf = 0
	??_debLevel = DEBLEVELNORMAL

	irp x, <arg1, arg2>
	    ifnb <x>
		if ((.TYPE x) AND 20h) GT 0
		    ??_debLevel = x
		else
		    Check_EOL <typ>, <x>, %(@Line)
		    ??_nocrlf = 1
		endif
	    endif
	endm

	if DEBLEVEL GE ??_debLevel
	    ??_fDoit = VMM_TRUE
	endif

    endif

    if ??_fDoit

	irpc c, str
	    ifidn <c>, <">
		??_is_string = 1
	    else
	    ifidni <c>, <'>
		??_is_string = 1
	    else
		??_is_string = 0
	    endif
	    endif
	    exitm
	endm

	if ??_is_string
	    ??_Gen_String string, <str>
	    ??_debug_out_str textequ <OFFSET32 string>
	else
	    ??_debug_out_str textequ <str>
	endif

	ifdef WIN31COMPAT
		pushfd
		pushad
		mov	esi, ??_debug_out_str
		VMMCall Out_Debug_String
	    ifidni <typ>, <Debug_Out>
		VMMCall Test_Debug_Installed
		jz	SHORT $+4
		int	1
	    endif
		popad
		popfd
	else
		push	??_debug_out_str
	    ifidni <typ>, <Debug_Out>
		VMMCall _Debug_Out_Service
	    else
		VMMCall _Trace_Out_Service
	    endif
	endif

    endif

	endm
















irp     cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Trace_Out&cond macro str, arg1, arg2
	?trace_out <str>,jn&cond, <arg1>, <arg2>
	endm

Trace_OutN&cond macro str, arg1, arg2
	?trace_out <str>,j&cond, <arg1>, <arg2>
	endm

endm

Trace_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Trace_Out>, <str>, <arg1>, <arg2>
endm

Trace_OutECXZ   macro str, arg1, arg2
	local	l1,l2
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jecxz	l1
	jmp	short l2
l1:	Trace_Out <str>, <arg1>, <arg2>
l2:
endif
	endm

Trace_OutECXNZ macro str, arg1, arg2
	?trace_out <str>,jecxz, <arg1>, <arg2>
	endm

Trace_OutEAXz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jnz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

Trace_OutEAXnz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

?trace_out macro str, jmpop, arg1, arg2
	Local	nomsg
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jmpop	short nomsg
	Trace_Out <str>,<arg1>,<arg2>
nomsg:
endif
	endm


















irp	cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Debug_Out&cond &macro str, arg1
	?debug_out <str>,jn&cond,<arg1>
	&endm

Debug_OutN&cond &macro str, arg1
	?debug_out <str>,j&cond,<arg1>
	&endm

endm

Debug_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Debug_Out>, <str>, <arg1>, <arg2>
endm

Debug_OutECXZ	macro str, arg1
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	Debug_Out <str>, <arg1>
l2:
endif
	endm

Debug_OutECXNZ macro str, arg1
	?debug_out <str>,jecxz, <arg1>
	endm

Debug_OutEAXz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jnz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

Debug_OutEAXnz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

?debug_out macro str,jmpop, arg1
	Local	nomsg
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short nomsg
	Debug_Out <str>, <arg1>
nomsg:
endif
	endm








Queue_Out MACRO S, V1, V2, DL
	LOCAL	Str_Off
	LOCAL MyDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

_LDATA SEGMENT
Str_Off db S, 0dh,0ah, 0
_LDATA ENDS

	push	esi
IFNB <V1>
    IF	TYPE V1 GT 0
	push	dword ptr V1
    ELSE
	push	V1
    ENDIF
ELSE
	push	eax
ENDIF
IFNB <V2>
    IF	TYPE V2 GT 0
	push	dword ptr V2
    ELSE
	push	V2
    ENDIF
ELSE
	push	ebx
ENDIF
	mov	esi, OFFSET32 Str_Off
	VMMCall Queue_Debug_String
	pop	esi
ENDIF

ENDIF
	ENDM








Mono_Out MACRO S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM








Mono_Out_At MACRO Row, Col, S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	dx, (Row SHL 8)+Col
	VMMCall Set_Mono_Cur_Pos
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM










Assert_Ints_Disabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aidMessage
	_LDATA segment
	??_aidMessage	db	"ERROR:  Ints enabled at Assert_Ints_Disabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	!ZERO?
	push	OFFSET32 ??_aidMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM








Assert_Ints_Enabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aieMessage
	_LDATA segment
	??_aieMessage	db	"ERROR:  Ints disabled at Assert_Ints_Enabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	ZERO?
	push	OFFSET32 ??_aieMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM

















Assert_Cur_VM_Handle MACRO R, DL
	LOCAL	OK
	LOCAL myDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall Debug_Test_Cur_VM
IFDIFI <ebx>,<R>
	pop	ebx
ENDIF

ENDIF

ENDIF
	ENDM


Assert_Client_Ptr MACRO Reg, DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel
IFDIFI <ebp>,<Reg>
	push	ebp
	mov	ebp, Reg
ENDIF
	VMMCall Validate_Client_Ptr
IFDIFI <ebp>,<Reg>
	pop	ebp
ENDIF
ENDIF

ENDIF
	ENDM

endif























irp	cond,<s,c,a,ae,b,be,e,z,g,ge,l,le,o>

TRAP&cond &macro
	?trap	jn&cond
	&endm

TRAPn&cond &macro
	?trap	j&cond
	&endm

TRAPFATAL&cond &macro
	?trap	jn&cond, FATAL
	&endm

TRAPFATALn&cond &macro
	?trap	j&cond, FATAL
	&endm
endm

TRAP	macro
if DEBLEVEL GT DEBLEVELRETAIL
	int	3
endif
	endm

TRAPFATAL	macro
	local	l
if DEBLEVEL GT DEBLEVELRETAIL
l:	int	3
	jmp	short l
endif
	endm

TRAPecxz macro
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	int	3
l2:
endif
	endm

TRAPecxnz macro
	?trap	jecxz
	endm

?trap	macro	jmpop, fatal
	Local	l, n
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short n
l:	int	3
ifnb	<fatal>
	jmp	short l
endif
n:
endif
	endm

ifndef Not_VxD




Dump_Struc_Head MACRO
if DEBLEVEL GT DEBLEVELRETAIL
	Trace_Out "  Base    Address   Offs     Value  Field name"
ENDIF
	ENDM

Dump_Struc MACRO Base, X
if DEBLEVEL GT DEBLEVELRETAIL
	pushfd
	pushad
	lea	esi, [Base]
	mov	ecx, X
	lea	edx, [esi+ecx]

IF SIZE X EQ 6
	mov	bx, WORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #BX:#EAX  &X"
ELSE
IF SIZE X EQ 4
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #EAX  &X"
ELSE
IF SIZE X EQ 2
	mov	ax, WORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX      #AX  &X"
ELSE
	mov	al, BYTE PTR [edx]
	Trace_Out "#ESI  #EDX  #CX        #AL  &X"
ENDIF
ENDIF
ENDIF

	popad
	popfd
ENDIF
	ENDM

BeginDoc



























EndDoc

Begin_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Enable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM



End_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Disable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM

endif

IFDEF	DEBUG
TrashThis Macro	l:vararg
    ?TrashThisVal equ <0FFFFFF80h>
    ?TrashThisValSet = 0
    for r, <l>
	or	r, ?TrashThisVal
      ife ?TrashThisValSet
        if (OPATTR r) and 10h
	    ?TrashThisVal equ <r>
	    ?TrashThisValSet = 1
	endif
      endif
    endm
endm
ELSE
TrashThis Macro	l:vararg
endm
ENDIF


ifndef Not_VxD

if DEBLEVEL GT DEBLEVELRETAIL

ENTER_NOBLOCK MACRO
	push	DFS_ENTER_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

EXIT_NOBLOCK MACRO
	push	DFS_EXIT_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_CLD MACRO
	pushfd
	test	dword ptr [esp], DF_MASK
	Debug_OutNZ "Direction flag is not clear."
	popfd
	ENDM

Assert_Might_Block MACRO
	push	DFS_TEST_BLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_Not_Nest_Exec MACRO
	push	DFS_TEST_NEST_EXEC
	VMMCall _Debug_Flags_Service
	ENDM

ELSE

ENTER_NOBLOCK EQU <>
EXIT_NOBLOCK EQU <>
Assert_CLD EQU <>
Assert_Might_Block EQU <>
Assert_Not_Nest_Exec EQU <>

ENDIF


ifdef Begin_Service_Table
Begin_Service_Table DEBUG
DEBUG_Service	 DEBUG_Get_Version, LOCAL
DEBUG_Service	 DEBUG_Fault, LOCAL
DEBUG_Service	 DEBUG_CheckFault, LOCAL
DEBUG_Service	 _DEBUG_LoadSyms
End_Service_Table DEBUG
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MINIVDD.H ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49
#define TURN_VGA_OFF                         50
#define TURN_VGA_ON                          51
#define SET_ADAPTER_POWER_STATE              52
#define GET_ADAPTER_POWER_STATE_CAPS         53
#define SET_MONITOR_POWER_STATE              54
#define GET_MONITOR_POWER_STATE_CAPS         55
#define NBR_MINI_VDD_FUNCTIONS_41            56

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)
//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_ENUM                            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle, or device id (1-N)
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flag
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_TEST       0x00000001


//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//          NotifyMask      - bitfield of events
//          NotifyType      - type of notify
//          NotifyProc      - notify procedure
//          NotifyData      - client data
//
//  output:
//           none
//
//  return:
//          ERROR_SUCCES
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;


//
// NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1


//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MINIVDD.INC ===
ifndef _MINIVDD_H_
_MINIVDD_H_     EQU     1
ifndef Not_VxD
ifdef MINIVDD
ifdef NEC_98
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Register_Mini_VDD
VDD_Service     VDD_Install_IO_Handler
VDD_Service     VDD_Install_Mult_IO_Handlers
VDD_Service     VDD_Enable_Local_Trapping
VDD_Service     VDD_Disable_Local_Trapping
VDD_Service     VDD_Trap_Suspend
VDD_Service     Test_Vid_VM_Handle
VDD_Service     VDD_Set_Core_Graphics
VDD_Service     VDD_Load_AccBIOS
VDD_Service     VDD_Map_AccBIOS
VDD_Service     VDD_Map_VRAM
End_Service_Table VDD
else
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Set_Sleep_Flag_Addr
End_Service_Table VDD
endif
endif
VDD_VerNum      EQU     0400H
VDD_MinVerNum   EQU     030AH
ifdef NEC_98
bVidTextMd      EQU     4
fVidTextMd      EQU     (1 SHL 4)
bVidNTModeFF    EQU     0
fVidNTModeFF    EQU     (1 SHL 0)
bVidNTModeFFC16 EQU     1
fVidNTModeFFC16 EQU     (1 SHL 1)
bVidNTDispRW    EQU     2
fVidNTDispRW    EQU     (1 SHL 2)
bVidNTPal       EQU     3
fVidNTPal       EQU     (1 SHL 3)
bVidNTGDC       EQU     5
fVidNTGDC       EQU     (1 SHL 5)
bVidNTGDCTON    EQU     6
fVidNTGDCTON    EQU     (1 SHL 6)
bVidNTGDCGON    EQU     7
fVidNTGDCGON    EQU     (1 SHL 7)
bVidNTFont      EQU     8
fVidNTFont      EQU     (1 SHL 8)
bVidCRTC        EQU     9
fVidCRTC        EQU     (1 SHL 9)
bVidDispDataXfer        EQU     10
fVidDispDataXfer        EQU     (1 SHL 10)
bVidXFERPlane0  EQU     11
fVidXFERPlane0  EQU     (1 SHL 11)
bVidXFERPlane1  EQU     12
fVidXFERPlane1  EQU     (1 SHL 12)
bVidXFERPlane2  EQU     13
fVidXFERPlane2  EQU     (1 SHL 13)
bVidXFERPlane3  EQU     14
fVidXFERPlane3  EQU     (1 SHL 14)
mVidXFERPlane   EQU     (fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
mVidNTH98       EQU     (fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
else
fVidTxtEmulate  EQU     0001H
fVidNoTrpTxt    EQU     0002H
fVidNoTrpLRGrfx EQU     0004H
fVidNoTrpHRGrfx EQU     0008H
fVidTextMd      EQU     0010H
fVidLowRsGrfxMd EQU     0020H
fVidHghRsGrfxMd EQU     0040H
fVidRetainAllo  EQU     0080H
endif
ifdef NEC_98
REGISTER_DISPLAY_DRIVER EQU     0
PRE_HIRES_TO_VGA        EQU     1
SAVE_REGISTERS  EQU     2
RESTORE_REGISTERS       EQU     3
ENABLE_TRAPS    EQU     4
DISABLE_TRAPS   EQU     5
DISPLAY_DRIVER_DISABLING        EQU     6
ENABLE_ACCELERATER      EQU     7
DISABLE_ACCELERATER     EQU     8
CHECK_UPDATE    EQU     9
CHECK_WINDOWED  EQU     10
ACC_VBE_PM      EQU     11
ACC_VBE_DDC     EQU     12
ACC_INT_10      EQU     13
ACC_GET_CAPABILITIES    EQU     14
ACC_GET_EXT_MODE_INFO   EQU     15
ACC_GET_FLAT_SELECTOR   EQU     16
ACC_ENABLE_BIOS EQU     17
ACC_DISABLE_BIOS        EQU     18
ACC_SET_PALETTE EQU     19
ACC_GET_PALETTE EQU     20
ACC_SET_CURSOR  EQU     21
ACC_SHOW_CURSOR EQU     22
ACC_HIDE_CURSOR EQU     23
ACC_SET_CURSOR_POS      EQU     24
ACC_GET_CURSOR_POS      EQU     25
NBR_MINI_VDD_FUNCTIONS_40       EQU     26
GET_NUM_UNITS   EQU     26
SET_ADAPTER_POWER_STATE EQU     27
GET_ADAPTER_POWER_STATE_CAPS    EQU     28
SET_MONITOR_POWER_STATE EQU     29
GET_MONITOR_POWER_STATE_CAPS    EQU     30
GET_MONITOR_INFO        EQU     31
NBR_MINI_VDD_FUNCTIONS_41       EQU     32
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
else
REGISTER_DISPLAY_DRIVER EQU     0
GET_VDD_BANK    EQU     1
SET_VDD_BANK    EQU     2
RESET_BANK      EQU     3
PRE_HIRES_TO_VGA        EQU     4
POST_HIRES_TO_VGA       EQU     5
PRE_VGA_TO_HIRES        EQU     6
POST_VGA_TO_HIRES       EQU     7
SAVE_REGISTERS  EQU     8
RESTORE_REGISTERS       EQU     9
MODIFY_REGISTER_STATE   EQU     10
ACCESS_VGA_MEMORY_MODE  EQU     11
ACCESS_LINEAR_MEMORY_MODE       EQU     12
ENABLE_TRAPS    EQU     13
DISABLE_TRAPS   EQU     14
MAKE_HARDWARE_NOT_BUSY  EQU     15
VIRTUALIZE_CRTC_IN      EQU     16
VIRTUALIZE_CRTC_OUT     EQU     17
VIRTUALIZE_SEQUENCER_IN EQU     18
VIRTUALIZE_SEQUENCER_OUT        EQU     19
VIRTUALIZE_GCR_IN       EQU     20
VIRTUALIZE_GCR_OUT      EQU     21
SET_LATCH_BANK  EQU     22
RESET_LATCH_BANK        EQU     23
SAVE_LATCHES    EQU     24
RESTORE_LATCHES EQU     25
DISPLAY_DRIVER_DISABLING        EQU     26
SELECT_PLANE    EQU     27
PRE_CRTC_MODE_CHANGE    EQU     28
POST_CRTC_MODE_CHANGE   EQU     29
VIRTUALIZE_DAC_OUT      EQU     30
VIRTUALIZE_DAC_IN       EQU     31
GET_CURRENT_BANK_WRITE  EQU     32
GET_CURRENT_BANK_READ   EQU     33
SET_BANK        EQU     34
CHECK_HIRES_MODE        EQU     35
GET_TOTAL_VRAM_SIZE     EQU     36
GET_BANK_SIZE   EQU     37
SET_HIRES_MODE  EQU     38
PRE_HIRES_SAVE_RESTORE  EQU     39
POST_HIRES_SAVE_RESTORE EQU     40
VESA_SUPPORT    EQU     41
GET_CHIP_ID     EQU     42
CHECK_SCREEN_SWITCH_OK  EQU     43
VIRTUALIZE_BLTER_IO     EQU     44
SAVE_MESSAGE_MODE_STATE EQU     45
SAVE_FORCED_PLANAR_STATE        EQU     46
VESA_CALL_POST_PROCESSING       EQU     47
PRE_INT_10_MODE_SET     EQU     48
NBR_MINI_VDD_FUNCTIONS_40       EQU     49
GET_NUM_UNITS   EQU     49
TURN_VGA_OFF    EQU     50
TURN_VGA_ON     EQU     51
SET_ADAPTER_POWER_STATE EQU     52
GET_ADAPTER_POWER_STATE_CAPS    EQU     53
SET_MONITOR_POWER_STATE EQU     54
GET_MONITOR_POWER_STATE_CAPS    EQU     55
GET_MONITOR_INFO        EQU     56
I2C_OPEN        EQU     57
I2C_ACCESS      EQU     58
GPIO_OPEN       EQU     59
GPIO_ACCESS     EQU     60
COPYPROTECTION_ACCESS   EQU     61
NBR_MINI_VDD_FUNCTIONS_41       EQU     62
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
endif
endif
VDD_QUERY_VERSION       EQU     0
MINIVDD_SVC_BASE_OFFSET EQU     80H
VDD_DRIVER_REGISTER     EQU     (0+MINIVDD_SVC_BASE_OFFSET)
VDD_DRIVER_UNREGISTER   EQU     (1+MINIVDD_SVC_BASE_OFFSET)
VDD_SAVE_DRIVER_STATE   EQU     (2+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_DISPLAY_DRIVER_INFO        EQU     (3+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_SSB_FLAGS  EQU     (4+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG  EQU     (5+MINIVDD_SVC_BASE_OFFSET)
VDD_PRE_MODE_CHANGE     EQU     (6+MINIVDD_SVC_BASE_OFFSET)
VDD_POST_MODE_CHANGE    EQU     (7+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_USER_FLAGS      EQU     (8+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_BUSY_FLAG_ADDR  EQU     (9+MINIVDD_SVC_BASE_OFFSET)
VDD_PC98_RESERVED       EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_VBE_PM      EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_ENABLE      EQU     (11+MINIVDD_SVC_BASE_OFFSET)
VDD_GETMEMBASE  EQU     (12+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN        EQU     (13+MINIVDD_SVC_BASE_OFFSET)
VDD_CLOSE       EQU     (14+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN_KEY    EQU     (15+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_POWER_STATE     EQU     (16+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_POWER_STATE_CAPS        EQU     (17+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG2 EQU     8085H
ENABLE_IO       EQU     00000001H
ENABLE_MEM      EQU     00000002H
ENABLE_VGA      EQU     00000030H
ENABLE_ROM      EQU     00000080H
ENABLE_ALL      EQU     000000FFH
ENABLE_NONE     EQU     00000000H
ENABLE_VALID    EQU     000000FFH
ENABLE_ERROR    EQU     0FFFFFFFFH
VDD_OPEN_EXIST  EQU     00000001H
VDD_OPEN_ENUM   EQU     00000002H
VDD_OPEN_LOCK   EQU     00000000H
VDD_OPEN_TEST   EQU     VDD_OPEN_EXIST
VDD_OPEN_KEY_WRITE      EQU     00000001H
VDD_OPEN_KEY_READ       EQU     00000002H
VDD_OPEN_KEY_USER       EQU     00000010H
VDD_OPEN_KEY_GLOBAL     EQU     00000020H
VDD_IOCTL_SET_NOTIFY    EQU     10000001H
VDD_IOCTL_GET_DDHAL     EQU     10000002H

tagVDD_IOCTL_SET_NOTIFY_INPUT   STRUC
NotifyMask      DD      ?
NotifyType      DD      ?
NotifyProc      DD      ?
NotifyData      DD      ?
tagVDD_IOCTL_SET_NOTIFY_INPUT   ENDS
VDD_NOTIFY_START_MODE_CHANGE    EQU     00000001H
VDD_NOTIFY_END_MODE_CHANGE      EQU     00000002H
VDD_NOTIFY_ENABLE       EQU     00000004H
VDD_NOTIFY_DISABLE      EQU     00000008H
VDD_NOTIFY_TYPE_CALLBACK        EQU     1
BYTE_LENGTHED   EQU     1
WORD_LENGTHED   EQU     2
GOING_TO_WINDOWS_MODE   EQU     1
GOING_TO_VGA_MODE       EQU     2
DISPLAY_DRIVER_DISABLED EQU     4
IN_WINDOWS_HIRES_MODE   EQU     8

DISPLAYINFO     STRUC
diHdrSize       DW      ?
diInfoFlags     DW      ?
diDevNodeHandle DD      ?
diDriverName    DB      16 DUP (?)
diXRes  DW      ?
diYRes  DW      ?
diDPI   DW      ?
diPlanes        DB      ?
diBpp   DB      ?
diRefreshRateMax        DW      ?
diRefreshRateMin        DW      ?
diLowHorz       DW      ?
diHighHorz      DW      ?
diLowVert       DW      ?
diHighVert      DW      ?
diMonitorDevNodeHandle  DD      ?
diHorzSyncPolarity      DB      ?
diVertSyncPolarity      DB      ?
diUnitNumber    DD      ?
diDisplayFlags  DD      ?
diXDesktopPos   DD      ?
diYDesktopPos   DD      ?
diXDesktopSize  DD      ?
diYDesktopSize  DD      ?
DISPLAYINFO     ENDS
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize

RETURNED_DATA_IS_STALE  EQU     0001H
MINIVDD_FAILED_TO_LOAD  EQU     0002H
MINIVDD_CHIP_ID_DIDNT_MATCH     EQU     0004H
REGISTRY_BPP_NOT_VALID  EQU     0008H
REGISTRY_RESOLUTION_NOT_VALID   EQU     0010H
REGISTRY_DPI_NOT_VALID  EQU     0020H
MONITOR_DEVNODE_NOT_ACTIVE      EQU     0040H
MONITOR_INFO_NOT_VALID  EQU     0080H
MONITOR_INFO_DISABLED_BY_USER   EQU     0100H
REFRESH_RATE_MAX_ONLY   EQU     0200H
CARD_VDD_LOADED_OK      EQU     0400H
DEVICE_IS_NOT_VGA       EQU     0800H
NoTrace_VIRTUALIZE_CRTC_IN      EQU     1
NoTrace_VIRTUALIZE_CRTC_OUT     EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_IN EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_OUT        EQU     1
NoTrace_VIRTUALIZE_GCR_IN       EQU     1
NoTrace_VIRTUALIZE_GCR_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_IN       EQU     1
NoTrace_CHECK_HIRES_MODE        EQU     1

ifdef NEC_98







vFlg_Machine_Std        equ                     00000001b
vFlg_Machine_Multi      equ                     00000010b
vFlg_Machine_Mate       equ                     00000100b
vFlg_Machine_H98        equ                     00001000b
vFlg_CRT_New            equ                     00010000b
vFlg_CRT_NonInter       equ                     00100000b
vFlg_GDC_5MHz           equ                     01000000b
vFlg_GDC_Emulate        equ                     10000000b
vFlg_Acc_Internal       equ             0000000100000000b
vFlg_Acc_External       equ             0000001000000000b
vFlg_Acc_PCI            equ             0000010000000000b
vFlg_Acc_ML             equ             0000100000000000b
vFlg_Acc_PVD            equ             0001000000000000b
vFlg_Mode_NH            equ             0010000000000000b
vFlg_Mode_H             equ             0100000000000000b
vFlg_Initialized        equ             1000000000000000b
vFlg_Opt_MFR            equ     000000010000000000000000b
vFlg_Opt_NewMFR         equ     000000100000000000000000b
vFlg_Opt_VDP            equ     000001000000000000000000b
vFlg_Opt_NewVDP         equ     000010000000000000000000b

vFlg_Local              equ     000000000100000010000000b




MaxMiniVDD      equ     16
MaxMiniTrap     equ     32
MaxMultiTrap    equ     3
MaxMultiFunc    equ     MaxMiniVDD





LT_Enable       equ     00000001b
LT_Enable_bit   equ     0
LT_Initialized  equ     10000000b
LT_Initialized_bit equ  7










Vids_struct struc



        Vids_SFlags             dd      ?
        Vids_CB_Offset          dd      ?
        Vids_Msg_Pseudo_VM      dd      ?




        VDD_TGDC_Draw_Off       dd      ?
        VDD_TGDC_Sync_Off       dd      ?
        VDD_TGDC_Sync_On        dd      ?
        VDD_TGDC_FIFO_Empty     dd      ?
        VDD_GGDC_Draw_Off       dd      ?
        VDD_GGDC_Sync_Off       dd      ?
        VDD_GGDC_Sync_On        dd      ?
        VDD_GGDC_FIFO_Empty     dd      ?
        VDD_GGDC_MOD_Emulate    dd      ?




        H98_FLORA_Change        dd      ?
        H98_Clear_Text          dd      ?
        H98_Rest_GCs            dd      ?
        H98_Rest_etc            dd      ?
        H98_Save_ModeFF         dd      ?

Vids_struct ends


Vid_SFlags              equ     <Vids.Vids_SFlags>
VDD_CB_Offset           equ     <Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM       equ     <Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off           equ     <Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off           equ     <Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On            equ     <Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off           equ     <Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty         equ     <Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty         equ     <Vids.VDD_GGDC_FIFO_Empty>





MiniFuncStruct  STRUC
MF_ProcAddr     dd      ?



MiniFuncStruct  ENDS




MiniVDD_Proc_Struct     STRUC
Proc_Address    dd      ?
Proc_Order      dw      ?
Proc_MiniID     db      ?
Proc_Flags      db      ?
MiniVDD_Proc_Struct     ENDS
.errnz  (size MiniVDD_Proc_Struct) mod 4





MiniVDD_GTrap_Struct    STRUC
GTrap_ProcAddr  dd      ?
GTrap_PortAddr  dw      ?
GTrap_NumMini   dw      ?
GTrap_ProcTable db      ((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct    ENDS

MiniVDD_LTrap_Struct    STRUC
LTrap_ProcAddr  dd      ?
LTrap_Status    db      ?
LTrap_Flags     db      MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct    ENDS












EndMiniFunc_    MACRO   n
ifdef   MiniFunc&n
        dd      OFFSET32 MiniFunc&n
else
        dd      0
endif
                ENDM

MiniFunc_       MACRO   FuncID, FuncName
                MiniFunc&FuncID equ <FuncName>
                ENDM

BeginMiniFunc   MACRO   TableName
public  TableName
TableName       label   near
                ENDM

if 1
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS_41
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
else
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
endif

MiniFunc        MACRO   FuncID, FuncName
                MiniFunc_ %(FuncID), <FuncName>
                ENDM




MiniVDDCall     MACRO   FuncID, SetCarry
                local   MiniCall_Loop
                local   MiniCall_Exit

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                mov     ecx, [MiniVDD_NumMini]
MiniCall_Loop:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
                jc      MiniCall_Exit
                add     esi, size MiniVDD_Proc_Struct
                loop    MiniCall_Loop
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall2    MACRO   FuncID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall3    MACRO   FuncID, MiniID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Loop
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                movzx   ecx, MiniID
MiniCall_Loop:
                cmp     ecx, 0
                jz      MiniCall_Proc
                add     esi, size MiniVDD_Proc_Struct
                dec     ecx
                jmp     MiniCall_Loop
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM




MiniVDDFunc     MACRO   TmpReg, FuncID
                mov     TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                ENDM











ExecModeLL      macro   Num
ExecMode_L&Num:
                endm

ExecModeLE      macro   Num
ExecMode_E&Num:
                endm

ExecModeJE      macro   Num
        jmp     ExecMode_E&Num
                endm

ExecModeJZ      macro   Num
        jz      ExecMode_L&Num
                endm

ExecModeJNZ     macro   Num
        jnz     ExecMode_L&Num
                endm

ExecModeJEZ     macro   Num
        jz      ExecMode_E&Num
                endm

ExecModeJENZ    macro   Num
        jnz     ExecMode_E&Num
                endm


ExecModeTest    macro   ModeFlag, CB_Reg
if      ModeFlag and vFlg_Local
ifidni  <CB_Reg>, <Vid>
        push    ebx
        mov     ebx, [Vid_VM_Handle]
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifidni  <CB_Reg>, <Cur>
        push    ebx
        VMMCall Get_Cur_VM_Handle
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifb     <CB_Reg>
        push    ebx
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
        test    [CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
        test    [Vid_SFlags], ModeFlag
endif
        endm


ExecModeChk     macro   HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni  <HdrFlag>, <Jmp>
.erre   FlgExecMode
        ExecModeJE      %EndExecMode
endif
ExecModeLL      %NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb    <ModeFlag>
        ExecModeTest    <ModeFlag>, <CB_Reg>
ifidni  <JmpLabel>, <End>
ifidni  <JmpFlag>, <Not>
        ExecModeJENZ    %EndExecMode
else
        ExecModeJEZ     %EndExecMode
endif
else
ifidni  <JmpFlag>, <Not>
        ExecModeJNZ     %NumExecMode
else
        ExecModeJZ      %NumExecMode
endif
endif
endif
                endm

ExecModeEnd     macro
ExecModeLL      %NumExecMode
ExecModeLE      %EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
                endm





ExecModeJmp     macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jnz     JmpLabel
                endm

ExecModeJmpNot  macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jz      JmpLabel
                endm

ExecMode        macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeNot     macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeOnly    macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
                endm

ExecModeOnlyNot macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
                endm

ExecModeElse    macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeElseNot macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeThru    macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeThruNot macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
                endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else




ifdef MAINVDD
externdef       MiniVDDDispatchTable:dword
endif


MiniVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm


CardVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm


MiniVDDCall             macro   FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi
ifnb    <SaveFlags>
        pushfd
endif
        mov     edi,OFFSET32 MiniVDDDispatchTable
        cmp     dword ptr [edi+(FunctionCode*4)],0
        je      MiniVDDCallLeave
ifnb    <SaveFlags>
        popfd
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb    <SaveFlags>
        jmp     MiniVDDCallExit
endif

MiniVDDCallLeave:
ifnb    <SaveFlags>
        popfd
endif

MiniVDDCallExit:
        pop     edi
endm
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MMDEVLDR.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 */

#define Multimedia_OEM_ID   0x0440	//            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10 	//;MMDEVLDR's device ID

#ifdef Begin_Service_Table		// define only if vmm.h is included

#define	MMDEVLDR_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service	(MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service	(MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS       

#pragma warning (default:4003)		// turn on not enough params warning

#pragma warning (disable:4035)		// turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD           dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)		// turn on no return code warning

#endif // Begin_Service_Table
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MMDEVLDR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	_MMDEVLDR_SetDevicePresence
        MMDEVLDR_Service        _MMDEVLDR_SetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_GetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_RemoveEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_AddEnvironmentString
End_Service_Table MMDEVLDR	

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MTRR.H ===
#ifndef	_MTRR_H_
#define	_MTRR_H_

#define	MTRR_Ver_Major	0x01
#define	MTRR_Ver_Minor	0x00

#define	MTRR_DEVICE_ID	DDS_DEVICE_ID

/*INT32*/

/*XLATOFF*/
#define MTRR_Service	Declare_Service
#define MTRR_StdCall_Service Declare_SCService
#pragma	warning (disable:4003)

/*XLATON*/

#define		MmNonCached			0
#define		MmCached			1
#define		MmFrameBufferCached		2
#define		MmHardwareCoherentCached        3
#define		MmMaximumCacheType		4

/*MACROS*/
Begin_Service_Table(MTRR, VxD)

MTRR_Service		(_MTRR_Get_Version, LOCAL)
MTRR_StdCall_Service    (MTRRSetPhysicalCacheTypeRange, 4)

End_Service_Table(MTRR, VxD)

/*ENDMACROS*/

/*XLATOFF*/

WORD VXDINLINE
MTRRGetVersion() {

   WORD w;
   VxDCall(_MTRR_Get_Version);
   _asm mov [w], ax;
   return (w);

}

ULONG VXDINLINE
MTRRSetPhysicalCacheTypeRange(
   PVOID PhysicalAddress,
   ULONG NumberOfBytes,
   MEMORY_CACHING_TYPE CacheType) {

   ULONG	ulResult;

   _asm push CacheType;
   _asm push NumberOfBytes;
   _asm push 0;
   _asm push PhysicalAddress;
   VxDCall(MTRRSetPhysicalCacheTypeRange);
   _asm	mov [ulResult], eax;
   
   return (ulResult);
}

/*XLATON*/

#endif // ifndef _MTRR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\INT2FAPI.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT2FAPI.INC - Windows/386 V86 Application Program Interface
;
;   Version:	3.00
;
;   Date:	10-Mar-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Mar-1989 RAL Original for 3.0
;   07-Apr-1989 RAL Added device broadcast equate
;
;==============================================================================
;
;   For inforamtion on these APIs please refer to the Windows/386 DDK
;   appendix on the Int 2Fh Application Program Interface.
;
;------------------------------------------------------------------------------

;
;   Interrupt 2Fh is used for Windows/386 API calls.
;
W386_API_Int		EQU	2Fh

;
;   All Windows/386 API Int 2Fh calls must be issued with AH = 16h
;
W386_Int_Multiplex	EQU	16h

;
;   Values for AL for all Windows/386 API calls
;
W386_Get_Version	EQU	00h		; Install check/Get version
W386_Old_Get_VMID_API	EQU	02h		; Version 2.xx get VMID API call
W386_Startup		EQU	05h		; Broadcast when Win386 starting
W386_Exit		EQU	06h		; Broadcast when Win386 exited
W386_Device_Broadcast	EQU	07h		; Broadcast by virtual device
W386_Startup_Complete	EQU	08h		; Broadcast when Win386 start is complete
W386_Begin_Exit 	EQU	09h		; Broadcast when Win386 is starting
						;   a NORMAL exit sequence
W386_Windows_ID 	EQU	0Ah		; Identify windows ver/type
W386_TSR_Identify	EQU	0Bh		; Identify TSRs
W386_ROM_Detect 	EQU	0Ch		; Used by ROM win to detect ROMs

W386_Release_Time	EQU	80h		; Release cur VM's time-slice
W386_Begin_Critical	EQU	81h		; Begin critical section
W386_End_Critical	EQU	82h		; End critical section
W386_Get_Cur_VMID	EQU	83h		; Returns BX = ID of current VM
W386_Get_Device_API	EQU	84h		; Returns ES:DI -> Device API
W386_Switch_And_Call	EQU	85h		; Change VMs and call-back
W386_Test_Int31_Avail	EQU	86h		; Returns AX=0 if Int 31 avail
W386_Get_PM_Switch_Addr EQU	87h		; Get call-back addr for PM
W386_Get_LDT_Base_Sel	EQU	88h		; Get selector to LDT
W386_Win_Kernel_Idle	EQU	89h		; Windows kernel idle call
W386_DPMI_Extension	EQU	8Ah		; DPMI extension Int 2Fh
W386_Set_Focus		EQU	8Bh		; Set focus to specified VM
W386_Restart_Cmd	EQU	8Ch		; Win.Com execs specified app

;
;   Structure for real mode device initialization API.
;
Win386_Startup_Info_Struc STRUC
SIS_Version		db	3, 0		; Structure version
SIS_Next_Ptr		dd	?		; Seg:Off of next dev in list
SIS_Virt_Dev_File_Ptr	dd	0		; Ptr to ASCIZ file name to loa