rned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Find session with session ID of 0");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionFindFromID failed as expected");
	}
	else
	{
		XOnlineTaskClose(hSearch);
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Find session from ID with a NULL work handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSessionFindFromID(SessionID, NULL, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Find session from ID with a valid work handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Try to find a session that doesn't exist");
	// -----------------------------------------------------------------

	*((ULONGLONG *) &SessionID) = 0x8000000000000000;
	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully indicated that session doesn't exist!");

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Find session from ID that doesn't have any pub/priv available");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(0, 0, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Open and close a find-session task without calling work pump");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
	}

	XOnlineTaskClose(hSearch);
	hSearch = NULL;

	PASS_TESTCASE("XOnlineTaskClose completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);	



	// -----------------------------------------------------------------
	START_TESTCASE("Cancel a find-session task that has already completed and then close it");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}
	
	XOnlineTaskClose(hSearch);
	hSearch = NULL;
	
	PASS_TESTCASE("XOnlineTaskClose completed successfully");
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hSearch)
		XOnlineTaskClose(hSearch);

	return hr;
} // XMatchTest_FindSessionFromID


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\sendsearch.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_SendSearch(HANDLE hLog);

//==================================================================================
// XMatchTest_SendSearch
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for sending searches via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_SendSearch(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	PXMATCH_SEARCHRESULT *ppSearchResults = NULL;
	XONLINETASK_HANDLE hSearch = NULL;
	XNADDR LocalXnAddr;
	XNKID SessionID, NewSessionID;
	ATTRIBUTE AttributeTest[4];
	PARAMETER ParameterTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0, *pdwOffset = NULL, *pdwAttributeType = NULL, dwAddrStatus = 0;
	DWORD dwAttributeType = 0, dwAttributeLen = 0, dwNumResults = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;
	BYTE bAttributeBuffer[100];

	memset(&SessionID, 0, sizeof(SessionID));
	memset(&NewSessionID, 0, sizeof(NewSessionID));

	dwAddrStatus = XNetGetTitleXnAddr(&LocalXnAddr);
	if(dwAddrStatus == XNET_GET_XNADDR_PENDING)
		xLog(hLog, XLL_FAIL, "Local address still pending, some tests will fail.");
	else if(dwAddrStatus & XNET_GET_XNADDR_NONE)
		xLog(hLog, XLL_FAIL, "Local address not available, some tests will fail.");

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Send with NULL session handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchSend(NULL);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchSend failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend returned success but should have failed!");
	}

	END_TESTCASE();
*/

	// -----------------------------------------------------------------
	START_TESTCASE("Send search and poll without waiting for event handle");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	ReadSearchResults(hLog, hSearch, 1, FALSE);
		
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	
/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Send a search task that has already been sent");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchSend failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend returned success but should have failed!");
	}
		
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Send search where results will contain 1 integer attribute");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 1, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSINT_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);

	// -----------------------------------------------------------------
	START_TESTCASE("Send search where results will contain 1 string attribute");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 1, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSTR_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);

	

	// -----------------------------------------------------------------
	START_TESTCASE("Send search where results will contain 1 blob attribute");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 1, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSBLB_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	


	// -----------------------------------------------------------------
	START_TESTCASE("Send search without adding expected parameters");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}
	
	PASS_TESTCASE("Search completed successfully");
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	

	// -----------------------------------------------------------------
	START_TESTCASE("Int/String/Blob params and Int/String/Blob results");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(INTSTRBLB_INDEX, 10, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[1].Value.pvValue = (VOID *) STRING1;
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[2].Value.pvValue = (VOID *) BLOB1;
	
	fRet = AddParameters(hSearch, ParameterTest, 3);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Int/Blob/String params and Int/Blob/String results");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(INTBLBSTR_INDEX, 10, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[1].Value.pvValue = (VOID *) BLOB1;
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[2].Value.pvValue = (VOID *) STRING1;
	
	fRet = AddParameters(hSearch, ParameterTest, 3);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("String/Int/Blob params and String/Int/Blob results");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(STRINTBLB_INDEX, 10, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[0].Value.pvValue = (VOID *) STRING1;
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[1].Value.qwValue = *((ULONGLONG *) &SessionID);
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[2].Value.pvValue = (VOID *) BLOB1;
	
	fRet = AddParameters(hSearch, ParameterTest, 3);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Blob/Int/String params and Blob/Int/String results");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(BLBINTSTR_INDEX, 10, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[0].Value.pvValue = (VOID *) BLOB1;
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[1].Value.qwValue = *((ULONGLONG *) &SessionID);
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[2].Value.pvValue = (VOID *) STRING1;
	
	fRet = AddParameters(hSearch, ParameterTest, 3);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("String/Blob/Int params and String/Blob/Int results");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(STRBLBINT_INDEX, 10, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[0].Value.pvValue = (VOID *) STRING1;
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[1].Value.pvValue = (VOID *) BLOB1;
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[2].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 3);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);

	// -----------------------------------------------------------------
	START_TESTCASE("Blob/String/Int params and Blob/String/Int results");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(BLBSTRINT_INDEX, 10, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[0].Value.pvValue = (VOID *) BLOB1;
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[1].Value.pvValue = (VOID *) STRING1;
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[2].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 3);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	PASS_TESTCASE("Search results contained expected attributes");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


Exit:
	if(hEvent)
		CloseHandle(hEvent);
	
	if(!fCompleted && hSearch)
		XOnlineTaskClose(hSearch);
	
	return hr;
} // XMatchTest_SendSearch


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\sendsession.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_SendSession(HANDLE hLog);

//==================================================================================
// XMatchTest_SendSession
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for sending sessions via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_SendSession(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	XONLINETASK_HANDLE hMatch = NULL;
	XNKID SessionID, NewSessionID;
	ATTRIBUTE AttributeTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));
	memset(&NewSessionID, 0, sizeof(NewSessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Send with NULL session handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionSend(NULL);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSend failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend returned success but should have failed!");
	}

	END_TESTCASE();
*/

	// -----------------------------------------------------------------
	START_TESTCASE("Send and poll without waiting for event handle");
	// -----------------------------------------------------------------

	hMatch = NULL;
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	// -----------------------------------------------------------------
	START_TESTCASE("Send without adding expected attributes");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);

	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}
	
	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Send a task handle that has already been sent");
	// -----------------------------------------------------------------

	hMatch = NULL;
	hr = XOnlineMatchSessionCreate(0, 0, 0, hEvent, &hMatch );

	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSend failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

Exit:
	if(hEvent)
		CloseHandle(hEvent);
	
	if(!fCompleted && hMatch)
		XOnlineTaskClose(hMatch);
	
	return hr;
} // XMatchTest_SendSession


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\searchresults.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_SearchResults(HANDLE hLog);

//==================================================================================
// XMatchTest_SearchResults
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for sending searches via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_SearchResults(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	PXMATCH_SEARCHRESULT pSearchResult = NULL;
	XONLINETASK_HANDLE hSearch = NULL;
	XNKID SessionID, NewSessionID;
	ATTRIBUTE AttributeTest[4];
	PARAMETER ParameterTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));
	memset(&NewSessionID, 0, sizeof(NewSessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get first result with NULL search handle");
	// -----------------------------------------------------------------

	hr = XMatchGetFirstSearchResult(NULL, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetFirstSearchResult returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetFirstSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetFirstSearchResult returned success but should have failed!");
	}

	END_TESTCASE();
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get next result with NULL search handle");
	// -----------------------------------------------------------------

	hr = XMatchGetNextSearchResult(NULL, &pSearchResult);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetFirstSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetFirstSearchResult returned success but should have failed!");
	}

	END_TESTCASE();
*/
/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get first result with NULL search result pointer");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XMatchGetFirstSearchResult(hSearch, NULL);

	xLog(hLog, XLL_INFO, "XMatchGetFirstSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetFirstSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetFirstSearchResult returned success but should have failed!");
	}
		
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get next result with NULL search result pointer");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XMatchGetFirstSearchResult(hSearch, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetFirstSearchResult returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XMatchGetFirstSearchResult failed unexpectedly");
	}

	hr = XMatchGetNextSearchResult(hSearch, NULL);

	xLog(hLog, XLL_INFO, "XMatchGetNextSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetNextSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetNextSearchResult returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get first result before sending search");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}


	pSearchResult = NULL;
	hr = XMatchGetFirstSearchResult(hSearch, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetFirstSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetFirstSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetFirstSearchResult returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get next result before sending search");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	pSearchResult = NULL;
	hr = XMatchGetNextSearchResult(hSearch, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetNextSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetNextSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetNextSearchResult returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get first result before search completes");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	pSearchResult = NULL;
	hr = XMatchGetFirstSearchResult(hSearch, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetFirstSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetFirstSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetFirstSearchResult returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get next result before search completes");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	pSearchResult = NULL;
	hr = XMatchGetNextSearchResult(hSearch, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetNextSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetNextSearchResult failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetNextSearchResult returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get next result without getting first result");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	pSearchResult = NULL;
	hr = XMatchGetNextSearchResult(hSearch, &pSearchResult);

	xLog(hLog, XLL_INFO, "XMatchGetNextSearchResult returned 0x%08x", hr);
	if (FAILED(hr))
	{
		PASS_TESTCASE("XMatchGetNextSearchResult failed as expected");
	}
	else if(hr == S_OK)
	{
		PASS_TESTCASE("XMatchGetNextSearchResult even though first result hadn't been retrieved, acceptable");
	}
	else
	{
		FAIL_TESTCASE("XMatchGetNextSearchResult returned success but should have failed!");
	}
		
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

	// -----------------------------------------------------------------
	START_TESTCASE("Loop through search results twice");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETTITLEALL_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 2000, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}


	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	if(ReadSearchResults(hLog, hSearch, 2, TRUE))
		ReadSearchResults(hLog, hSearch, 2, TRUE);
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hSearch)
		XOnlineTaskClose(hSearch);

	return hr;
} // XMatchTest_SearchResults


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\opensession.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_OpenSession(HANDLE hLog);

//==================================================================================
// XMatchTest_OpenSession
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for creating sessions via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_OpenSession(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	XONLINETASK_HANDLE hMatch = NULL;
	XNKID SessionID, NewSessionID;
	ATTRIBUTE AttributeTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));
	memset(&NewSessionID, 0, sizeof(NewSessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* CAUSES RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Non-zero attrib count, but zero attrib len");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 10, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hMatch);
		FAIL_TESTCASE("XOnlineMatchSessionCreate returned success but should have failed!");
	}

	END_TESTCASE();
	hMatch = NULL;
*/

/* CAUSES RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Non-zero attrib len, but zero attrib count");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 0, 1000, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hMatch);
		FAIL_TESTCASE("XOnlineMatchSessionCreate returned success but should have failed!");
	}

	END_TESTCASE();
	hMatch = NULL;
*/

/* CAUSES RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Null phSession parameter");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 10, 1000, hEvent, NULL );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hMatch);
		FAIL_TESTCASE("XOnlineMatchSessionCreate returned success but should have failed!");
	}

	END_TESTCASE();
	hMatch = NULL;
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Try to modify a session that doesn't exist");
	// -----------------------------------------------------------------

	hMatch = NULL;
	*((ULONGLONG *) &SessionID) = 1;
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	
	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(hr != XMATCH_E_INVALID_SESSION_ID)
	{
		FAIL_TESTCASE("Session creation didn't return expected error code");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}
	
	FAIL_TESTCASE("Received expected error code from server.");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a new session with no attributes");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");
	
	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Modify the session that was just created without adding attributes");
	// -----------------------------------------------------------------

	memset(&NewSessionID, 0, sizeof(NewSessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &NewSessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(memcmp(&SessionID, &NewSessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but returned a different session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned expected session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Use a null work event");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, NULL, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a new session with one of each attribute type");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 3);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Modify the session that was just created adding attributes of each type");
	// -----------------------------------------------------------------

	memset(&NewSessionID, 0, sizeof(NewSessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALINT_ID2;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID2;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID2;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 3);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &NewSessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(memcmp(&SessionID, &NewSessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but returned a different session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned expected session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Modify session and re-add existing attributes");
	// -----------------------------------------------------------------

	memset(&NewSessionID, 0, sizeof(NewSessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 3, GetBufferLenForInt() + GetBufferLenForString(STRING1) + GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID2;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID2;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID2;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 3);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}
	
	hr = XOnlineMatchSessionGetID (hMatch, &NewSessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(memcmp(&SessionID, &NewSessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but returned a different session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned expected session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Open and close an XMatch request without calling the work pump");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	XOnlineTaskClose(hMatch);
	hMatch = NULL;

	PASS_TESTCASE("XOnlineTaskClose completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);	



	// -----------------------------------------------------------------
	START_TESTCASE("Open a session request and immediately call work pump");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	dwPollCounter = 1;
	fRet = XOnlineTaskDoWork(hMatch, 0);
	
	if(fRet)
	{
		PASS_TESTCASE("XOnlineTaskDoWork returned TRUE");
	}
	else
	{
		FAIL_TESTCASE("XOnlineTaskDoWork returned FALSE, but should have returned TRUE");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hMatch);	

	// -----------------------------------------------------------------
	START_TESTCASE("Cancel a session request that has already been sent and then close it");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	XOnlineTaskClose(hMatch);
	hMatch = NULL;

	PASS_TESTCASE("XOnlineTaskClose completed successfully");
	
	END_TESTCASE();
	CLEANUP_TASK(hMatch);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hMatch)
		XOnlineTaskClose(hMatch);

	return hr;
} // XMatchTest_OpenSession


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\setattribute.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_SetAttributes(HANDLE hLog);

//==================================================================================
// XMatchTest_SetAttributes
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for creating sessions via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_SetAttributes(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	XONLINETASK_HANDLE hMatch;
	ULONGLONG qwUserID = 0;
	XNKID SessionID;
	ATTRIBUTE AttributeTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0, dwTemp = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Set integer with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionSetInt(NULL, GLOBALINT_ID1, qwUserID, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt returned success but should have failed!");
	}

	END_TESTCASE();
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Try to add integer attribute beyond max index");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt() + GetBufferLenForInt(), hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALINT_ID1, qwUserID, INT1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALINT_ID2, qwUserID, INT2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Try to add integer attribute when there isn't enough space available");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForInt() + GetBufferLenForInt() - 1, hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALINT_ID1, qwUserID, INT1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALINT_ID2, qwUserID, INT2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add integer attribute with non-integer ID");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALSTR_ID1, qwUserID, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to set an integer for a session that has already been sent");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = 10;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALINT_ID1, qwUserID, 10);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add user integer attribute with NULL user ID");
	// -----------------------------------------------------------------

	qwUserID = 0;
	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, qwUserID, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed.  User attributes with NULL user ID's are failing.");
	}
	else
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt succeeded.  User attributes with NULL user ID's are working.");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add non-user integer attribute with non-NULL user ID");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForUserInt(), hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	qwUserID = USER1;
	
	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALINT_ID1, qwUserID, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
	qwUserID = 0;
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Add public available when zero attribute were expected");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE since it's no longer supported
	AttributeTest[0].dwAttributeID = /*XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE*/ 0;
	AttributeTest[0].Value.qwValue = 10;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Add private availalbe when zero attribute were expected");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE since it's no longer supported
	AttributeTest[0].dwAttributeID = /*XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE*/ 0;
	AttributeTest[0].Value.qwValue = 10;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Add public available when additional attributes are expected");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt(), hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE since it's no longer supported
	AttributeTest[0].dwAttributeID = /*XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE*/ 0;
	AttributeTest[0].Value.qwValue = 10;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[1].Value.qwValue = INT1;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Add private available when additional attributes are expected");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt(), hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
// BUGBUG: Removed XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE since it's no longer supported
	AttributeTest[0].dwAttributeID = /*XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE*/ 0;
	AttributeTest[0].Value.qwValue = 10;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[1].Value.qwValue = INT1;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Update existing public available attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE since it's no longer supported
	AttributeTest[0].dwAttributeID = /*XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE*/ 0;
	AttributeTest[0].Value.qwValue = 1;
	AttributeTest[0].qwUserID = 0;
// BUGBUG: Removed XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE since it's no longer supported
	AttributeTest[1].dwAttributeID = /*XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE*/ 0;
	AttributeTest[1].Value.qwValue = 0xFFFFFFFF;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Update existing private available attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE since it's no longer supported
	AttributeTest[0].dwAttributeID = /*XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE*/ 0;
	AttributeTest[0].Value.qwValue = 1;
	AttributeTest[0].qwUserID = 0;
// BUGBUG: Removed XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE since it's no longer supported
	AttributeTest[1].dwAttributeID = /*XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE*/ 0;
	AttributeTest[1].Value.qwValue = 0xFFFFFFFF;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	
	
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add integer attribute when there is exactly enough space available");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt(), hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session and add the same integer attribute twice");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[1].Value.qwValue = INT2;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global session integer attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific session integer attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global user integer attribute for non-existent player");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
	
	AttributeTest[0].dwAttributeID = GLOBALUSERINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	
	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Creating session with non-exisitent player integer failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global user integer attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() * 2, hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
	
	AttributeTest[0].dwAttributeID = GLOBALUSERINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific user integer attribute for non-existent user");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEUSERINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Creating session with non-exisitent player integer failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific user integer attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, 2 * GetBufferLenForUserInt(), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEUSERINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Set string with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionSetString(NULL, GLOBALSTR_ID1, qwUserID, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString returned success but should have failed!");
	}

	END_TESTCASE();
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Try to add string attribute beyond max index");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForString(STRING1) + GetBufferLenForString(STRING2), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSessionSetString(hMatch, GLOBALSTR_ID1, qwUserID, STRING1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetString(hMatch, GLOBALSTR_ID2, qwUserID, STRING2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
	

	
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add string attribute when there isn't enough space available");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForString(STRING1) + 1, hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
		
	hr = XOnlineMatchSessionSetString(hMatch, GLOBALSTR_ID1, qwUserID, STRING1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetString(hMatch, GLOBALSTR_ID2, qwUserID, STRING2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
	

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add string attribute with non-string ID");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}


	hr = XOnlineMatchSessionSetString(hMatch, GLOBALINT_ID1, qwUserID, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to set a string for a session that has already been sent");
	// -----------------------------------------------------------------

	hMatch = NULL;
	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetString(hMatch, GLOBALSTR_ID1, qwUserID, STRING2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/
	
/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add user string attribute with NULL user ID");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForUserString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSessionSetString(hMatch, GLOBALUSERSTR_ID1, qwUserID, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed.  User attributes with NULL user ID's are failing.");
	}
	else
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString succeeded.  User attributes with NULL user ID's are working.");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add non-user string attribute with non-NULL user ID");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	qwUserID = USER1;
	
	hr = XOnlineMatchSessionSetString(hMatch, GLOBALSTR_ID1, qwUserID, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetString returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
	qwUserID = 0;
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Try to add string attribute when there is exactly enough space available");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session and add an empty string");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForString(L""), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) L"";
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	

	// -----------------------------------------------------------------
	START_TESTCASE("Resize max-length strings");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, 2 * GetBufferLenForString(RESIZESTRING_MID), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) RESIZESTRING_MID;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID2;
	AttributeTest[1].Value.pvValue = (VOID *) RESIZESTRING_MID;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) RESIZESTRING_MIN;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID2;
	AttributeTest[1].Value.pvValue = (VOID *) RESIZESTRING_MAX;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}
	
	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	

	// -----------------------------------------------------------------
	START_TESTCASE("Create a session and add the same string attribute twice");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForString(STRING2), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING2;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global session string attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific session string attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLESTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global user string attribute for a non-existent user");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALUSERSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Creating session with non-exisitent player string failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global user string attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() + GetBufferLenForUserString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALUSERSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific user string attribute for a non-existent user");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEUSERSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Creating session with non-exisitent player string failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific user string attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() + GetBufferLenForUserString(STRING1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEUSERSTR_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) STRING1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Set blob with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionSetBlob(NULL, GLOBALBLB_ID1, qwUserID, strlen(BLOB1), BLOB1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob returned success but should have failed!");
	}

	END_TESTCASE();
*/

	// -----------------------------------------------------------------
	START_TESTCASE("Try to add blob attribute beyond max index");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID1, qwUserID, strlen(BLOB1), BLOB1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID2, qwUserID, strlen(BLOB2), BLOB2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	

	// -----------------------------------------------------------------
	START_TESTCASE("Try to add blob attribute when there isn't enough space available");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForBlob(BLOB1) + 1, hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID1, qwUserID, strlen(BLOB1), BLOB1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID2, qwUserID, strlen(BLOB2), BLOB2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
	

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add blob attribute with non-blob ID");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALINT_ID1, qwUserID, strlen(BLOB1), BLOB1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to set a blob for a session that has already been sent");
	// -----------------------------------------------------------------

	hMatch = NULL;
	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID1, qwUserID, strlen(BLOB2), BLOB2);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/
	

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add user blob attribute with NULL user ID");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForUserBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALUSERBLB_ID1, qwUserID, strlen(BLOB1), BLOB1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed.  User attributes with NULL user ID's are failing.");
	}
	else
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob succeeded.  User attributes with NULL user ID's are working.");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to add non-user blob attribute with non-NULL user ID");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionCreate(0, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	qwUserID = USER1;

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID1, qwUserID, strlen(BLOB1), BLOB1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionSetBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
	qwUserID = 0;
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Try to add blob attribute when there is exactly enough space available");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	
	// -----------------------------------------------------------------
	START_TESTCASE("Create a session and add an empty blob");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForBlob(""), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetBlob(hMatch, GLOBALBLB_ID1, 0, 0, NULL);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetBlob failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	// -----------------------------------------------------------------
	START_TESTCASE("Resize max-length blobs");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, 2 * GetBufferLenForBlob(RESIZEBLOB_MID), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) RESIZEBLOB_MID;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALBLB_ID2;
	AttributeTest[1].Value.pvValue = (VOID *) RESIZEBLOB_MID;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) "";
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALBLB_ID2;
	AttributeTest[1].Value.pvValue = (VOID *) RESIZEBLOB_MAX;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}
	
	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

	

	// -----------------------------------------------------------------
	START_TESTCASE("Create a session and add the same blob attribute twice");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForBlob(BLOB2), hEvent, &hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) BLOB2;
	AttributeTest[1].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 2);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global session blob attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}
	
	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific session blob attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = 0;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global user blob attribute for a non-existent user");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALUSERBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Creating session with non-exisitent player blob failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with global user blob attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() + GetBufferLenForUserBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = GLOBALUSERBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific user blob attribute for non-existent user");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEUSERBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Creating session with non-exisitent player blob failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a session with title-specific user blob attribute");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() + GetBufferLenForUserBlob(BLOB1), hEvent, &hMatch );
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	AttributeTest[0].dwAttributeID = TITLEUSERBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[0].qwUserID = USER1;
	
	fRet = AddAttributes(hMatch, AttributeTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add attributes to session!");
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hMatch)
		XOnlineTaskClose(hMatch);

	return hr;
} // XMatchTest_SetAttributes


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\CParameter_CreateSession.h ===
#ifndef __CPARAMETER_CREATESESSION_H__
#define __CPARAMETER_CREATESESSION_H__

#include "matchcoretest.h"
#include "CTestCase_CreateSession.h"

//#include <xonlinep.h>
namespace MatchCoreTestNamespace {

class CParameter_CreateSession
{
	friend class CTestCase_CreateSession;
	
    DWORD m_dwPublicCurrent;
    DWORD m_dwPublicAvailable;
    DWORD m_dwPrivateCurrent;
    DWORD m_dwPrivateAvailable;
    DWORD m_dwNumAttributes;
    PXONLINE_ATTRIBUTE m_pAttributes;
    BOOL  m_bAttrAllocated;
    HANDLE m_hWorkEvent;
    BOOL	m_bEventCreated;
    XONLINETASK_HANDLE* m_phTask;
//    BOOL  m_bHTaskAllocated;
    XONLINETASK_HANDLE m_hTask;

public:
	CParameter_CreateSession();
	~CParameter_CreateSession();
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\CParameter_CreateSession.cpp ===
#include "CParameter_CreateSession.h"

using namespace MatchCoreTestNamespace;

namespace MatchCoreTestNamespace {

// CParameter_CreateSession member functions
CParameter_CreateSession::CParameter_CreateSession()
	: m_bAttrAllocated(FALSE), m_bEventCreated(FALSE)
{
}

CParameter_CreateSession::~CParameter_CreateSession()
{
	if(m_bEventCreated)
		CloseHandle(m_hWorkEvent);
	if(m_bAttrAllocated)
		delete[] m_pAttributes;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\CTestCase_CreateSession.h ===
#ifndef __CTESTCASE_CREATESESSION_H__
#define __CTESTCASE_CREATESESSION_H__

#include "TestCaseAndResult_CreateSession.h"
#include "CParameter_CreateSession.h"

namespace MatchCoreTestNamespace {

//Parameter combinations
enum DWordCase
{
	DWZero,
	DWOne,
	DWMaxSignedInt,
	DWMinSignedInt,
	DWMaxDword,

	EndOFDWordCase
};

enum AttributeCase
{
	ZeroNum_Null,
	ZeroNum_Alloc,
	ZeroNum_Garbage,
	One_Int,
	One_Str,
	One_Blob,
	One_EachType,
	Int1000,
	Str1000,
	Blob1000,
// Failure cases	
	OneNum_Null,	
	TwoNum_OneAlloc,
	OneNum_Garbage,

	EndOfDAttributeCase
};

enum EventCase
{
	NullEvent,
	ValidEvent,
// Failure cases	
	GarbageEvent,

	EndOfEventCase
};

enum TaskCreateCase
{
	ValildTask,
// Failure cases	
	NullTask,

	EndOfTaskCreateCase
};
	
class CParameter_CreateSession;

class CTestCase_CreateSession
{
private:
	INT				m_nCase;

	TestCaseAndExpected_CreateSession	m_tcae;

	CParameter_CreateSession*	m_pPara;
	CParameter_CreateSession*	m_pParaUpdate;

	void 	EvaluateAttr(TestCase_CreateSession& tc, CParameter_CreateSession* pPara);
	void	EvaluateHEvent(TestCase_CreateSession& tc, CParameter_CreateSession* pPara);
	void	EvaluateTask(TestCase_CreateSession& tc, CParameter_CreateSession* pPara);


	INT	CheckResultOf_SessionCreate(HRESULT hr, XONLINETASK_HANDLE* phMatchTask);
	INT	CheckResultOf_SessionGetID(HRESULT hr, XNKID SessionID);
	INT	CheckResultOf_SessionDelete(HRESULT hr, XNKID SessionID);

public:
	CTestCase_CreateSession();
	~CTestCase_CreateSession();
	void	BringPameterAndExpected();
	void	EvaluateParameters(TestCase_CreateSession& tc, CParameter_CreateSession* pPara);
	
	int		RunTest();
//	CParameter_CreateSession GetPara();
	void SetnCase(int ii) {m_nCase = ii;}


};

DWORD EvaluateSlot(INT nCaseSlot);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\xmatchtest.h ===
#ifndef __XMATCHTEST_H__
#define __XMATCHTEST_H__

//@@@ drm: XOnlineTaskDoWork replaced with XOnlineTaskContinue
#define XOnlineTaskDoWork(a, b) (FALSE)

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <netsync.h>
#include <xlog.h>


#include <xonlinep.h>
#include <xnetref.h>

// Until this is defined in a header, we'll have to reproduce the extended header structure here
typedef enum
{
    xmatchWorking = 0,
    xmatchCancelled,
    xmatchDone

} XMATCH_STATE;

namespace XMatchTestNamespace {

//
// BUGBUG: Dummy stubs to let it compile
//

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionCreate(
    IN XNKID SessionID,
    IN DWORD dwNumAttributes,
    IN DWORD dwAttributesLen,
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE* phSession
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetInt(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN ULONGLONG qwAttributeValue
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetString(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN LPCWSTR pwszAttributeValue
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetBlob(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN DWORD dwAttributeLength,
    IN PVOID pvAttributeValue
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionAddPlayer(
    IN XONLINETASK_HANDLE hSession,
    IN ULONGLONG qwUserPUID
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionRemovePlayer(
    IN XONLINETASK_HANDLE hSession,
    IN ULONGLONG qwUserPUID
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSend(
    IN XONLINETASK_HANDLE hSession
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionGetID (
    IN XONLINETASK_HANDLE hSession,
    OUT XNKID* pSessionID
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionDelete(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phDelete
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionFindFromID(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phSearch
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchCreate(
    IN DWORD dwProcedureIndex,
    IN DWORD dwNumResults,
    IN DWORD dwNumParameters,
    IN DWORD dwParametersLen,
    IN DWORD dwResultsLen,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phSearch
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendInt(
    IN XONLINETASK_HANDLE hSearch,
    IN ULONGLONG qwParameterValue
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendString(
    IN XONLINETASK_HANDLE hSearch,
    IN LPCWSTR pwszParameterValue
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendBlob(
    IN XONLINETASK_HANDLE hSearch,
    IN DWORD dwParameterLen,
    IN LPVOID pvParameterValue
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchSend(
    IN XONLINETASK_HANDLE hSearch
    );
    
XBOXAPI
HRESULT 
WINAPI
XOnlineMatchSearchGetResults(
    IN XONLINETASK_HANDLE hSearch,
    OUT PXMATCH_SEARCHRESULT **prgpSearchResults,
    OUT DWORD *pdwReturnedResults
    );
 
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchGetAttribute(
    IN XONLINETASK_HANDLE hSearch,
    IN DWORD dwSearchResultIndex,
    IN DWORD dwAttributeIndex,
    OUT DWORD *pdwAttributeID,
    OUT VOID *pAttributeValue,
    OUT DWORD *pcbAttributeValue
    );

//==================================================================================
// Defines
//==================================================================================
#define PUMP_CS_EVENT()					fDone = XOnlineTaskDoWork(hLogon, 0); \
										if(fDone) \
										{ \
											xLog(hLog, XLL_FAIL, "Lost connection with CS, exiting test!"); \
										    goto Exit; \
										}
#define FAIL_TESTCASE(FailureMessage)	xLog(hLog, XLL_FAIL, FailureMessage); \
										break
#define PASS_TESTCASE(PassMessage)		xLog(hLog, XLL_PASS, PassMessage);
#define START_TESTCASE(TestCaseName)	while(TRUE) \
										{ \
											xStartVariation(hLog, TestCaseName)
#define END_TESTCASE()						break; \
										}; \
										PUMP_CS_EVENT()\
										xEndVariation(hLog)
#define CLEANUP_TASK(hTask)				if(hTask) \
										{ \
											XOnlineTaskClose(hTask); \
											hTask = NULL; \
										}

#define NUM_SERVICES 1
#define XMATCH_SERVER_DLL_W L"xmatchserv.dll"
#define XMATCH_SERVER_MAIN_FUNCTION_A "XMatchServerCallbackFunction"
#define XMATCH_SERVER_START_FUNCTION_A "XMatchServerStartFunction"
#define XMATCH_SERVER_STOP_FUNCTION_A "XMatchServerStopFunction"

// BUGBUG: Removed X_ATTRIBUTE_TYPE_* since they are no longer supported

#define GLOBALINT_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALINT_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003
#define GLOBALINT_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000004

#define XMATCHUSERINT_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001

#define GLOBALUSERINT_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALUSERINT_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003
#define GLOBALUSERINT_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000004

#define GLOBALSTR_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALSTR_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define GLOBALSTR_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define GLOBALUSERSTR_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALUSERSTR_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define GLOBALUSERSTR_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define GLOBALBLB_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALBLB_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define GLOBALBLB_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define GLOBALUSERBLB_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALUSERBLB_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define GLOBALUSERBLB_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define TITLEINT_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define TITLEINT_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define TITLEINT_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define TITLEUSERINT_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define TITLEUSERINT_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define TITLEUSERINT_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define TITLESTR_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define TITLESTR_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define TITLESTR_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define TITLEUSERSTR_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define TITLEUSERSTR_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define TITLEUSERSTR_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define TITLEBLB_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define TITLEBLB_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define TITLEBLB_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_SESSION |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define TITLEUSERBLB_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define TITLEUSERBLB_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define TITLEUSERBLB_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | /*X_ATTRIBUTE_TYPE_USER |*/ X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define INT1 111222333444555666
#define INT2 777888
#define INT3 999

#define STRING1 L"AAAAABBBBB"
#define STRING2 L"CCCCCDDDDDEEEEE"	// Code expects STRING2 to be longer than STRING1
#define STRING3 L"FFFFF"

#define RESIZESTRING_MID L"1234567890123456789012345678901234567890123456789"
#define RESIZESTRING_MAX L"12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
#define RESIZESTRING_MIN L""

#define BLOB1 "ZZZZZYYYYY"
#define BLOB2 "XXXXXWWWWWVVVVV"		// Code expectes BLOB2 to be longer than BLOB1
#define BLOB3 "UUUUU"

#define RESIZEBLOB_MID "12345678901234567890123456789012345678901234567890"
#define RESIZEBLOB_MAX "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"

#define USER1 0xFFFFFFFF00000001
#define USER2 0xFFFFFFFF00000002
#define USER3 0xFFFFFFFF00000003

#define INVALIDSP_INDEX 0xAAAAAAAA
#define NOPARAM_INDEX 0x00000000
#define INTPARAM_INDEX 0x00000001
#define STRINGPARAM_INDEX 0x00000002
#define BLOBPARAM_INDEX 0x00000003
#define INTSTRBLB_INDEX 0x00000004
#define INTBLBSTR_INDEX 0x00000005
#define STRINTBLB_INDEX 0x00000006
#define BLBINTSTR_INDEX 0x00000007
#define STRBLBINT_INDEX 0x00000008
#define BLBSTRINT_INDEX 0x00000009
#define GETSESSSP_INDEX 0x0000000A
#define GETSESSINT_INDEX 0x0000000B
#define GETSESSSTR_INDEX 0x0000000C
#define GETSESSBLB_INDEX 0x0000000D
#define GETSESSALL_INDEX 0x0000000E
#define GETTITLEALL_INDEX 0x0000000F
#define NOEXECPERM_INDEX 0x00000010

#define MAX_DISPLAY_RESULTS 50
//==================================================================================
// Typedefs
//==================================================================================

//==================================================================================
// Structures
//==================================================================================
typedef struct
{
	ULONGLONG		qwUserID;
	DWORD			dwAttributeID;
	union
	{
		ULONGLONG		qwValue;
		VOID			*pvValue;
	} Value;
} ATTRIBUTE, *PATTRIBUTE;

typedef struct
{
	DWORD			dwParameterType;
	union
	{
		ULONGLONG		qwValue;
		VOID			*pvValue;
	} Value;
} PARAMETER, *PPARAMETER;

// XMATCH test case IDs
typedef enum _XMATCHMSG_LOCAL_TESTTYPES
{
	XMATCHMSG_LOCAL_BASE = 0,
	XMATCHMSG_OPENSESSION = 0,
	XMATCHMSG_SETATTRIBUTES,
	XMATCHMSG_SENDSESSION,
	XMATCHMSG_CREATESEARCH,
	XMATCHMSG_APPENDPARAMS,
	XMATCHMSG_SENDSEARCH,
	XMATCHMSG_SEARCHRESULTS,
	XMATCHMSG_ADDREMOVEPLAYERS,
	XMATCHMSG_DELETESESSION,
	XMATCHMSG_FINDFROMID,
	XMATCHMSG_GETSESSIONID,
	
	XMATCHMSG_LOCAL_MAXTEST
} XMATCHMSG_LOCAL_TESTTYPES, *PXMATCHMSG_LOCAL_TESTTYPES;

// XMATCH test function
typedef HRESULT (*PXMATCH_LOCAL_TEST_FUNCTION)(HANDLE hLog, XONLINETASK_HANDLE hLogon);

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI XMatchTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI XMatchTestStartTest(IN HANDLE hLog);
VOID WINAPI XMatchTestEndTest();

// Helper functions
LPVOID MemAlloc(DWORD dwSize);
BOOL MemFree(LPVOID pBuffer);
DWORD GetBufferLenForInt();
DWORD GetBufferLenForString(LPWSTR szString);
DWORD GetBufferLenForBlob(LPSTR szBlob);
DWORD GetBufferLenForUserInt();
DWORD GetBufferLenForUserString(LPWSTR szString);
DWORD GetBufferLenForUserBlob(LPSTR szBlob);
BOOL ReadSearchResults(HANDLE hLog, XONLINETASK_HANDLE hSearch, DWORD dwResultsExpected, BOOL fMoreResultsOK);

BOOL AddAttributes(XONLINETASK_HANDLE, PATTRIBUTE, DWORD);
BOOL AddParameters(XONLINETASK_HANDLE, PPARAMETER, DWORD);
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE, HANDLE, DWORD, DWORD *, BOOL *, BOOL);
BOOL CreateSession(ULONGLONG, ULONGLONG, PATTRIBUTE, DWORD, XNKID *);

// Local test cases
HRESULT XMatchTest_OpenSession(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_SetAttributes(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_SendSession(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_CreateSearch(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_AppendParams(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_SendSearch(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_SearchResults(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_AddRemovePlayers(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_DeleteSession(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_FindSessionFromID(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT XMatchTest_GetSessionID(HANDLE hLog, XONLINETASK_HANDLE hLogon);

} // namespace XMatchTestNamespace

#endif // __XMATCHTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\CTestCase_CreateSession.cpp ===
#include <common.h>
#include "TestCaseAndResult_CreateSession.h"
#include "CTestCase_CreateSession.h"
#include "matchcoretest.h"

using namespace MatchCoreTestNamespace;

namespace MatchCoreTestNamespace {

//Constructors
CTestCase_CreateSession::CTestCase_CreateSession()
	:m_nCase(0)
{
	m_pPara = new(CParameter_CreateSession);
	m_pParaUpdate = new(CParameter_CreateSession);
}

//Destructor
CTestCase_CreateSession::~CTestCase_CreateSession()
{
	delete m_pPara;
	delete m_pParaUpdate;
}


//Member functions
		
void	CTestCase_CreateSession::EvaluateParameters(TestCase_CreateSession& tc, CParameter_CreateSession* pPara)
{
	pPara->m_dwPublicCurrent = EvaluateSlot(tc.m_nDwordCasePubCurr);
	pPara->m_dwPublicAvailable = EvaluateSlot(tc.m_nDwordCasePubAvail);
	pPara->m_dwPrivateCurrent = EvaluateSlot(tc.m_nDwordCasePriCurr);
	pPara->m_dwPrivateAvailable = EvaluateSlot(tc.m_nDwordCasePriAvail);
	this->EvaluateAttr(tc, pPara);
	this->EvaluateHEvent(tc, pPara);
	this->EvaluateTask(tc, pPara);
	
	
}

void	CTestCase_CreateSession::EvaluateHEvent(TestCase_CreateSession& tc, CParameter_CreateSession* pPara)
{
	switch(tc.m_nEventCase)
	{
		case NullEvent :
			pPara->m_hWorkEvent = NULL;
			break;
		case ValidEvent :
			pPara->m_hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			pPara->m_bEventCreated = TRUE;
			break;
	// Failure cases	
		case GarbageEvent :
			pPara->m_hWorkEvent = (HANDLE) 0x1234;
			break;
			
	}

}

void	CTestCase_CreateSession::EvaluateAttr(TestCase_CreateSession& tc, CParameter_CreateSession* pPara)
{
	switch(tc.m_nAttributeCase)
	{
		case ZeroNum_Null:
		case ZeroNum_Alloc:
		case ZeroNum_Garbage:
			pPara->m_dwNumAttributes = 0;
			break;
		case One_Int:
		case One_Str:
		case One_Blob:
		case OneNum_Null:	
		case OneNum_Garbage:
			pPara->m_dwNumAttributes = 1;
			break;
		case TwoNum_OneAlloc:	
			pPara->m_dwNumAttributes = 2;
			break;
		case One_EachType:
			pPara->m_dwNumAttributes = 3;
			break;
		case Int1000:
		case Str1000:
		case Blob1000:
			pPara->m_dwNumAttributes = 1000;
			break;
			
	}

	switch(tc.m_nAttributeCase)
	{
		case ZeroNum_Null:
			pPara->m_pAttributes = NULL;
			break;
		case ZeroNum_Alloc:
			pPara->m_pAttributes = new XONLINE_ATTRIBUTE[1];
			pPara->m_bAttrAllocated = TRUE;
			break;
		case ZeroNum_Garbage:
			pPara->m_pAttributes = (PXONLINE_ATTRIBUTE) 0x1234;
			break;
		case One_Int:
			pPara->m_pAttributes = new XONLINE_ATTRIBUTE[1];
			pPara->m_bAttrAllocated = TRUE;
			pPara->m_pAttributes[0].dwAttributeID = GLOBALINT_ID1;
			pPara->m_pAttributes[0].info.integer.qwValue = INT1;
			break;
			
	}
}
void	CTestCase_CreateSession::EvaluateTask(TestCase_CreateSession& tc, CParameter_CreateSession* pPara)
{
	switch(tc.m_nAttributeCase)
	{
		case ValildTask :
			pPara->m_phTask = &pPara->m_hTask;
			break;
// Failure cases	
		case	NullTask :
			pPara->m_phTask = NULL;
			break;
			
	}

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int	CTestCase_CreateSession::RunTest()
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr;
	int		iResult;
	XONLINETASK_HANDLE	hDeleteTask, *phDeleteTask;
	DWORD dwExceptionCode = 0;
	XNKID	SessionID;
	
	__try
	{

	    hr = XOnlineMatchSessionCreate(m_pPara->m_dwPublicCurrent,
	    								m_pPara->m_dwPublicAvailable,
	    								m_pPara->m_dwPrivateCurrent,
	    								m_pPara->m_dwPrivateAvailable,
	    								m_pPara->m_dwNumAttributes,
	    								m_pPara->m_pAttributes,
	    								m_pPara->m_hWorkEvent,
	    								m_pPara->m_phTask);
		
	    iResult = this->CheckResultOf_SessionCreate(hr, m_pPara->m_phTask);
	    RaiseExceptionIfNecessary(iResult)
	    if(SUCCEEDED(hr))
	    {
			PUMP_CS_AND_EXIT_IF_FAILED(g_hTestLog,g_hLogonTask)
			iResult = PumpTaskUntilTimeout(g_hTestLog,*m_pPara->m_phTask, m_pPara->m_hWorkEvent, ALLOWEDPUMPINGTIME, NULL, FALSE, &hr);
		    RaiseExceptionIfNecessary(iResult);
		    
			hr = XOnlineMatchSessionGetID (m_pPara->m_phTask, &SessionID);
		    iResult = this->CheckResultOf_SessionGetID(hr, SessionID);
		    RaiseExceptionIfNecessary(iResult);

			if(m_tcae.m_nUpdate != SY_NOUPDATE)
			{
				iResult = RunTestUpdate(SessionID);
			    RaiseExceptionIfNecessary(iResult)
			}
			
			phDeleteTask = &hDeleteTask;
		    hr = XOnlineMatchSessionDelete(SessionID, hSessionEvent, phDeleteTask);
		    iResult = this->CheckResultOf_SessionDelete(hr, phDeleteTask);
		    RaiseExceptionIfNecessary(iResult)

			PUMP_CS_AND_EXIT_IF_FAILED(g_hTestLog,g_hLogonTask)
			iResult = PumpTaskUntilTimeout(g_hTestLog,phDeleteTask, hSessionEvent, ALLOWEDPUMPINGTIME, NULL, FALSE, &hr);
		    RaiseExceptionIfNecessary(iResult);
	    }
		PASS_TESTCASE(g_hTestLog,"Session successfully advertised");
	}	
	__except((GetExceptionCode() == SY_EXCEPTION_FAIL_THIS_TESTCASE) || (GetExceptionCode() == SY_EXCEPTION_STOP_WHOLE_TEST)?
				EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
		DWORD dwExceptionCode = GetExceptionCode();
		if(dwExceptionCode == SY_EXCEPTION_FAIL_THIS_TESTCASE)
		{
			FAIL_TESTCASE(g_hTestLog,"Creating session failed");
		}
		else if(dwExceptionCode == SY_EXCEPTION_STOP_WHOLE_TEST)
		{
			FAIL_TESTCASE(g_hTestLog,"Creating session failed and met critical test blocking");
		}
		
	}

// Clean up 

//
	if(dwExceptionCode == SY_EXCEPTION_STOP_WHOLE_TEST)
		return SY_EXCEPTION_STOP_WHOLE_TEST;
	else 
		return 0;
	    
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int	CTestCase_CreateSession::RunTestUpdate(XNKID	SessionID)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr;
	XNKID UpdateSessionID;
	
	if(m_tcae.m_nUpdate == SY_VALIDSESSIONID)
	{
		UpdateSessionID = SessionID;
	}
	else if(m_tcae.m_nUpdate == SY_INVALIDSESSIONID)
	{
		*((ULONGLONG *) &UpdateSessionID) = 0x1234;
	}
	else if(m_tcae.m_nUpdate == SY_NULLSESSIONID)
	{
		*((ULONGLONG *) &UpdateSessionID) = 0;
	}

    hr = XOnlineMatchSessionUpdate( UpdateSessionID,
    								m_pParaUpdate->m_dwPublicCurrent,
    								m_pParaUpdate->m_dwPublicAvailable,
    								m_pParaUpdate->m_dwPrivateCurrent,
    								m_pParaUpdate->m_dwPrivateAvailable,
    								m_pParaUpdate->m_dwNumAttributes,
    								m_pParaUpdate->m_pAttributes,
    								m_pParaUpdate->m_hWorkEvent,
    								m_pParaUpdate->m_phTask);

    iResult = this->CheckResultOf_SessionUpdate(hr, m_pParaUpdate->m_phTask);
    RaiseExceptionIfNecessary(iResult)

    if(SUCCEEDED(hr))
    {
		PUMP_CS_AND_EXIT_IF_FAILED(g_hTestLog,g_hLogonTask)
		iResult = PumpTaskUntilTimeout(g_hTestLog,*m_pPara->m_phTask, m_pPara->m_hWorkEvent, ALLOWEDPUMPINGTIME, NULL, FALSE, &hr);
	    RaiseExceptionIfNecessary(iResult);
	    
		hr = XOnlineMatchSessionGetID (m_pPara->m_phTask, &SessionID);
	    iResult = this->CheckResultOf_SessionGetID(hr, SessionID);
	    RaiseExceptionIfNecessary(iResult);
    }

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT	CTestCase_CreateSession::CheckResultOf_SessionCreate(HRESULT hr, XONLINETASK_HANDLE* phMatchTask)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
	INT 	iResult;
	
	xLog(g_hTestLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	xLog(g_hTestLog, XLL_INFO, "Returned task for XOnlineMatchSessionCreate is 0x%08x", *phMatchTask);

	iResult = this->CheckResultOf_SessionApiCall(hr, phMatchTask, m_tcae.m_te);
	
	return iResult;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT	CTestCase_CreateSession::CheckResultOf_SessionUpdate(HRESULT hr, XONLINETASK_HANDLE* phMatchTask)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
	INT 	iResult;
	
	xLog(g_hTestLog, XLL_INFO, "XOnlineMatchSessionUpdate returned 0x%08x", hr);
	xLog(g_hTestLog, XLL_INFO, "Returned task for XOnlineMatchSessionUpdate is 0x%08x", *phMatchTask);

	iResult = this->CheckResultOf_SessionApiCall(hr, phMatchTask, m_tcae.m_teUpdate);
	
	return iResult;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT	CTestCase_CreateSession::CheckResultOf_SessionApiCall(HRESULT hr, XONLINETASK_HANDLE* phMatchTask,
														TestExpected_CreateSession tExpected)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
	INT 	iResult;
	
	if( (  (tExpected.m_HrExpected == SY_SUCCESS)&& SUCCEEDED(hr)) ||
		(  (tExpected.m_HrExpected == SY_FAIL) && FAILED(hr)) 
	  )
	{
		xLog(g_hTestLog, XLL_INFO, "This hr is expected");
		iResult = SY_SUCCESS;
	}
	else
	{
		xLog(g_hTestLog, XLL_INFO, "This hr is NOT expected");
		iResult = SY_FAIL;
		return iResult;
	}

	if( (  (tExpected.m_HTaskExpected == SY_NONNULL) && (*phMatchTask != NULL) ) ||
		(  (tExpected.m_HTaskExpected == SY_NULL) && (*phMatchTask == NULL) ) 
	  )
	{
		xLog(g_hTestLog, XLL_INFO, "This *phMatchTask is expected");
		iResult = SY_SUCCESS;
	}
	else
	{
		xLog(g_hTestLog, XLL_INFO, "This *phMatchTask is NOT expected");
		iResult = SY_FAIL;
	}

	return iResult;
}


INT	CTestCase_CreateSession::CheckResultOf_SessionGetID(HRESULT hr, XNKID SessionID)
{
	INT 	iResult = SY_SUCCESS;

	xLog(g_hTestLog, XLL_INFO, "XOnlineMatchSessionGetID returned 0x%08x", hr);
	if( SUCCEEDED(hr)) 
	{
		xLog(g_hTestLog, XLL_INFO, "This hr is expected");
		iResult = SY_SUCCESS;
	}
	else
	{
		xLog(g_hTestLog, XLL_INFO, "This hr is NOT expected");
		iResult = SY_FAIL;
		return iResult;
	}

	xLog(g_hTestLog, XLL_INFO, "Session ID 0x%08x returned", SessionID);
	if( (*((ULONGLONG *) &SessionID) != 0) ) 
	{
		xLog(g_hTestLog, XLL_INFO, "This SessionID is expected");
		iResult = SY_SUCCESS;
	}
	else
	{
		xLog(g_hTestLog, XLL_INFO, "This SessionID is NOT expected");
		iResult = SY_FAIL;
	}

	return iResult;
}

INT	CTestCase_CreateSession::CheckResultOf_SessionDelete(HRESULT hr, XONLINETASK_HANDLE* phMatchTask)
{
	INT 	iResult = SY_SUCCESS;

	xLog(g_hTestLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if( SUCCEEDED(hr)) 
	{
		xLog(g_hTestLog, XLL_INFO, "This hr is expected");
		iResult = SY_SUCCESS;
	}
	else
	{
		xLog(g_hTestLog, XLL_INFO, "This hr is NOT expected");
		iResult = SY_FAIL;
		return iResult;
	}

	xLog(g_hTestLog, XLL_INFO, "Returned task for XOnlineMatchSessionDelete is 0x%08x", *phMatchTask);
	if( (*phMatchTask != NULL) ) 
	{
		xLog(g_hTestLog, XLL_INFO, "This *phMatchTask is expected");
		iResult = SY_SUCCESS;
	}
	else
	{
		xLog(g_hTestLog, XLL_INFO, "This *phMatchTask is NOT expected");
		iResult = SY_FAIL;
	}
	return iResult;
}

	
void	CTestCase_CreateSession::BringPameterAndExpected()
{
	m_tcae.m_tc.m_nDwordCasePubCurr = 	g_TCAE_CreateSession[m_nCase].m_tc.m_nDwordCasePubCurr;
	m_tcae.m_tc.m_nDwordCasePubAvail = 	g_TCAE_CreateSession[m_nCase].m_tc.m_nDwordCasePubAvail;
	m_tcae.m_tc.m_nDwordCasePriCurr = 	g_TCAE_CreateSession[m_nCase].m_tc.m_nDwordCasePriCurr;
	m_tcae.m_tc.m_nDwordCasePriAvail = 	g_TCAE_CreateSession[m_nCase].m_tc.m_nDwordCasePriAvail;
	m_tcae.m_tc.m_nAttributeCase = 		g_TCAE_CreateSession[m_nCase].m_tc.m_nAttributeCase;
	m_tcae.m_tc.m_nEventCase = 			g_TCAE_CreateSession[m_nCase].m_tc.m_nEventCase;
	m_tcae.m_tc.m_nTaskCreateCase = 	g_TCAE_CreateSession[m_nCase].m_tc.m_nTaskCreateCase;

	m_tcae.m_te.m_HrExpected =			g_TCAE_CreateSession[m_nCase].m_te.m_HrExpected;
	m_tcae.m_te.m_HTaskExpected =		g_TCAE_CreateSession[m_nCase].m_te.m_HTaskExpected;

	m_tcae.m_nUpdate = g_TCAE_CreateSession[m_nCase].m_nUpdate;

	if(m_tcae.m_nUpdate != SY_NOUPDATE)
	{
		m_tcae.m_tcUpdate.m_nDwordCasePubCurr = 	g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nDwordCasePubCurr;
		m_tcae.m_tcUpdate.m_nDwordCasePubAvail = 	g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nDwordCasePubAvail;
		m_tcae.m_tcUpdate.m_nDwordCasePriCurr = 	g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nDwordCasePriCurr;
		m_tcae.m_tcUpdate.m_nDwordCasePriAvail = 	g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nDwordCasePriAvail;
		m_tcae.m_tcUpdate.m_nAttributeCase = 		g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nAttributeCase;
		m_tcae.m_tcUpdate.m_nEventCase = 			g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nEventCase;
		m_tcae.m_tcUpdate.m_nTaskCreateCase = 	g_TCAE_CreateSession[m_nCase].m_tcUpdate.m_nTaskCreateCase;
	}

}

// Non member Functions

DWORD EvaluateSlot(INT nCaseSlot)
{
	DWORD dwReturn;
	
	switch(nCaseSlot)
	{
		case DWZero:
			dwReturn = 0;
			break;
		case DWOne:
			dwReturn = 1;
			break;
		case DWMaxSignedInt:
			dwReturn = 0x0fffffff;
			break;
		case DWMinSignedInt:
			dwReturn = 0x10000000;
			break;
		case DWMaxDword:
			dwReturn = 0xffffffff;
			break;
	}

	return dwReturn;
}


#if 0
void CTestCase_CreateSession::PrepareFirstParameters()
{
	this->EvaluateParameters();
}

BOOL CTestCase_CreateSession::PrepareNextParameters()
{
	if(!this->IncreaseCaseNumber())
		return FALSE;

	this->EvaluateParameters();
	

	
}

BOOL	CTestCase_CreateSession::IncreaseCaseNumber()
{
	m_nDwordCasePubCurr++;

	if(m_nDwordCasePubCurr == EndOFDWordCase){
		m_nDwordCasePubCurr = 0;
		m_nDwordCasePubAvail++;
	}
	if(m_nDwordCasePubAvail == EndOFDWordCase){
		m_nDwordCasePubAvail = 0;
		m_nDwordCasePriCurr++;
	}
	if(m_nDwordCasePriCurr == EndOFDWordCase){
		m_nDwordCasePriCurr = 0;
		m_nDwordCasePubAvail++;
	}
	if(m_nDwordCasePriAvail == EndOFDWordCase){
		m_nDwordCasePriAvail = 0;
		m_nAttributeCase++;
	}
	if(m_nAttributeCase == EndOfDAttributeCase){
		m_nAttributeCase = 0;
		m_nEventCase++;
	}
	if(m_nEventCase == EndOfEventCase){
		m_nEventCase = 0;
		m_nTaskCreateCase++;
	}
	if(m_nTaskCreateCase == EndOfTaskCreateCase){
		return FALSE
	}

	return TRUE;
		
}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\matchcoretest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include <common.h>
#include "matchcoretest.h"
#include "CTestCase_CreateSession.h"
#include "CParameter_CreateSession.h"
#include "TestCaseAndResult_CreateSession.h"

using namespace MatchCoreTestNamespace;

namespace MatchCoreTestNamespace {

//==================================================================================
// Globals
//==================================================================================
// Test specific globals

static CRITICAL_SECTION g_csSerializeAccess;
HANDLE g_hTestLog = INVALID_HANDLE_VALUE;
XONLINETASK_HANDLE g_hLogonTask = NULL;
HANDLE g_hHeap = NULL;

static PMATCH_CORE_TEST_FUNCTION g_LocalTestFunctions[MATCHMSG_LOCAL_MAXTEST] = 
{
	MatchCoreTest_CreateSession							//MATCHMSG_CREATESESSION
};

static LPSTR g_LocalTestNames[MATCHMSG_LOCAL_MAXTEST] = 
{
	"Open session"									//MATCHMSG_CREATESESSION
};

//==================================================================================
// MatchCoreTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI MatchCoreTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;
	XNADDR xnaddr;
	DWORD dwElapsedTime = 0, dwStartTime = 0, dwCurrentTime = 0, dwResult = 0;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		
		dwElapsedTime = 0;
		dwStartTime = GetTickCount();
		
		// Wait until stack initialization completes
		do
		{
			dwCurrentTime = GetTickCount();
			
			// Calculate the elapsed time based on whether the time has wrapped around
			if(dwCurrentTime < dwStartTime)
				dwElapsedTime =  MAXDWORD - dwStartTime + dwCurrentTime;
			else
				dwElapsedTime = dwCurrentTime - dwStartTime;
			
			if(dwElapsedTime > 10000)
			{
				OutputDebugString(TEXT("Net stack failed to initialize"));
				return FALSE;
			}
			
			dwResult = XNetGetTitleXnAddr (&xnaddr);		
			
		} while (XNET_GET_XNADDR_PENDING == dwResult);

		WSAStartup(MAKEWORD(2, 2), &WSAData);
		g_hHeap = HeapCreate(0,0,0);
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		DeleteCriticalSection(&g_csSerializeAccess);
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}

//==================================================================================
// MatchCoreTestStart
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		g_hTestLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI MatchCoreTestStart(IN HANDLE  hTestLog)
{
	XONLINETASK_HANDLE hLogonTask = NULL;
	HRESULT hr = S_OK;
	HANDLE hPingObject = NULL, hEnumObject = NULL, hClientObject = NULL;
	DWORD dwInitialized = 0, dwServices = 0;
	INT nRet = 0, i;
	BOOL	bRet = TRUE;

	g_hTestLog = hTestLog;
	
	DWORD ServicesArray[NUM_SERVICES] =
	{
		XONLINE_MATCHMAKING_SERVICE
	};

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

    // Set XLog info
	xSetOwnerAlias(g_hTestLog, "styoo");
    xSetComponent(g_hTestLog, "Online(S)", "Matching - Client (S-o)");
	xSetFunctionName(g_hTestLog, "<none>");

	dwServices = (sizeof(ServicesArray)/sizeof(DWORD));

	bRet = LogonForTest(hTestLog, NULL, &g_hLogonTask, ServicesArray, dwServices, ALLOWEDLOGONINTERVAL);
    if (bRet == FALSE)
	{
		xLog(g_hTestLog, XLL_FAIL, "Failed to Logon for Test");
		goto Exit;
	}

	// Run tests that don't require another machine
	for(i = MATCHMSG_LOCAL_BASE; i < MATCHMSG_LOCAL_MAXTEST; i++)
	{
		xSetFunctionName(g_hTestLog, g_LocalTestNames[i]);

		g_LocalTestFunctions[i]();

		xSetFunctionName(g_hTestLog, "");
	}
Exit:

	g_hTestLog = INVALID_HANDLE_VALUE;

	CLEANUP_TASK(g_hLogonTask);

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);
}            

//==================================================================================
// MatchCoreTest_CreateSession
//----------------------------------------------------------------------------------
//
// Description:  
//
// Arguments:
 // Returns:
 //==================================================================================

void MatchCoreTest_CreateSession()
{
	int		ii; 

	
//	int		nTotalCase = sizeof g_TCAE_CreateSession / sizeof(TestCaseAndExpected_CreateSession);

	for(ii=0; ii<g_nCase_CreateSession ; ii++)
	{
		CTestCase_CreateSession* pTestCase = new(CTestCase_CreateSession);

		pTestCase->SetnCase(ii);
		pTestCase->BringPameterAndExpected();
		pTestCase->EvaluateParameters(m_tc, m_pPara);
		if(pTestCase->m_nUpdate != SY_NOUPDATE)
			pTestCase->EvaluateParameters(m_tcUpdate, m_pParaUpdate);
		
		xStartVariation(g_hTestLog, "");	// Add Calling find Test Name 
		if( pTestCase->RunTest() == SY_EXCEPTION_STOP_WHOLE_TEST )
			break;
		xEndVariation(g_hTestLog);

		delete(pTestCase);
	}

}



//==================================================================================
// MatchCoreTestEnd
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI MatchCoreTestEnd()
{
	// We already cleaned up everything at the end of StartTest
}
#if 0
//==================================================================================
// MemAlloc
//----------------------------------------------------------------------------------
//
// MemAlloc: Private heap allocation function
//
// Arguments:
//	DWORD		dwSize		Size of buffer to allocate from the private heap
//
// Returns: Valid pointer to newly allocated memory, NULL otherwise
//==================================================================================
LPVOID MemAlloc(DWORD dwSize)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return NULL;
	}

	return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize);
}

//==================================================================================
// MemFree
//----------------------------------------------------------------------------------
//
// Description: Private heap deallocation function
//
// Arguments:
//	LPVOID		pBuffer		Pointer to buffer to be released
//
// Returns: TRUE if the buffer was deallocated, FALSE otherwise
//==================================================================================
BOOL MemFree(LPVOID pBuffer)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return FALSE;
	}

	return HeapFree(g_hHeap, 0, pBuffer);
}

DWORD GetBufferLenForInt()
{
	return sizeof(DWORD) + sizeof(ULONGLONG);
}

DWORD GetBufferLenForString(LPWSTR szString)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += (wcslen(szString) + 1) * sizeof(WCHAR);
	return dwSize;
}

DWORD GetBufferLenForBlob(LPSTR szBlob)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += strlen(szBlob) * sizeof(CHAR);
	return dwSize;
}

DWORD GetBufferLenForUserInt()
{
	return (sizeof(ULONGLONG) + GetBufferLenForInt());
}

DWORD GetBufferLenForUserString(LPWSTR szString)
{
	return (sizeof(ULONGLONG) + GetBufferLenForString(szString));
}

DWORD GetBufferLenForUserBlob(LPSTR szBlob)
{
	return (sizeof(ULONGLONG) + GetBufferLenForBlob(szBlob));
}

//==================================================================================
// ReadSearchResults
//----------------------------------------------------------------------------------
//
// Description: Adds attributes from a list to the async task indicated
//
// Arguments:
//	HANDLE				hTestLog				Handle to logging subsystem
//	XONLINETASK_HANDLE	hSearch				Handle to search task
//	DWORD				dwResultsExpected	Number of results expected
//	BOOL				fMoreResultsOK		Indicates whether an exact number of results is expected, or just a minimum
//
// Returns: TRUE if the search results were returned and formatted correctly, FALSE otherwise
//==================================================================================
BOOL ReadSearchResults(HANDLE hTestLog, XONLINETASK_HANDLE hSearch, DWORD dwResultsExpected, BOOL fMoreResultsOK)
{
	PXMATCH_SEARCHRESULT *ppSearchResults = NULL;
	HRESULT hr = S_OK;
	DWORD dwNumResults = 0;
	BOOL fPassed = TRUE;

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);
	if(FAILED(hr))
	{
		xLog(hTestLog, XLL_FAIL, "Getting search results failed with 0x%08x", hr);
		return FALSE;
	}

	if(fMoreResultsOK)
	{
		if(dwNumResults < dwResultsExpected)
		{
			xLog(hTestLog, XLL_FAIL, "Received %u results but at least %u were expected",
				dwNumResults, dwResultsExpected);
			return FALSE;
		}
	}
	else
	{
		if(dwNumResults != dwResultsExpected)
		{
			xLog(hTestLog, XLL_FAIL, "Received %u results but exactly %u were expected",
				dwNumResults, dwResultsExpected);
			return FALSE;
		}
	}

	xLog(hTestLog, XLL_PASS, "Recieved %u results as expected", dwNumResults, dwResultsExpected);
	return TRUE;
}

//==================================================================================
// AddAttributes
//----------------------------------------------------------------------------------
//
// Description: Adds attributes from a list to the async task indicated
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	PATTRIBUTE			pAttributeArray		Pointer to an array of attributes
//	DWORD				dwAttributeCount	Indicates number of attributes in array
//
// Returns: TRUE if the attributes were added successfully, FALSE otherwise
//==================================================================================
BOOL AddAttributes(XONLINETASK_HANDLE hAsyncHandle, PATTRIBUTE pAttributeArray, DWORD dwAttributeCount)
{
	HRESULT hr = S_OK;
	DWORD dwAttributeIndex = 0;
	BOOL fRet = TRUE;

	if(!pAttributeArray)
	{
		fRet = FALSE;
		goto Exit;
	}

	for (dwAttributeIndex = 0; dwAttributeIndex < dwAttributeCount; ++dwAttributeIndex)
	{
		switch (pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSessionSetInt(hAsyncHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].qwUserID, pAttributeArray[dwAttributeIndex].Value.qwValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding integer to session 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSessionSetString(hAsyncHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].qwUserID, (LPWSTR) pAttributeArray[dwAttributeIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to session 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSessionSetBlob(hAsyncHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].qwUserID, strlen((LPSTR)pAttributeArray[dwAttributeIndex].Value.pvValue),
					pAttributeArray[dwAttributeIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to session 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}
		}
	}

Exit:

	return fRet;
}

//==================================================================================
// AddParameters
//----------------------------------------------------------------------------------
//
// Description: Adds parameters from a list to the async task indicated
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	PPARAMETER			pParameterArray		Pointer to an array of parameters
//	DWORD				dwParameterCount	Indicates number of parameters in array
//
// Returns: TRUE if the attributes were added successfully, FALSE otherwise
//==================================================================================
BOOL AddParameters(XONLINETASK_HANDLE hAsyncHandle, PPARAMETER pParameterArray, DWORD dwParameterCount)
{
	HRESULT hr = S_OK;
	DWORD dwParameterIndex = 0;
	BOOL fRet = TRUE;

	if(!pParameterArray)
	{
		fRet = FALSE;
		goto Exit;
	}

	for (dwParameterIndex = 0; dwParameterIndex < dwParameterCount; ++dwParameterIndex)
	{
		switch (pParameterArray[dwParameterIndex].dwParameterType & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSearchAppendInt(hAsyncHandle, pParameterArray[dwParameterIndex].Value.qwValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding integer to search 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSearchAppendString(hAsyncHandle, (LPWSTR) pParameterArray[dwParameterIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to search 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSearchAppendBlob(hAsyncHandle, strlen((LPSTR)pParameterArray[dwParameterIndex].Value.pvValue),
					pParameterArray[dwParameterIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to search 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}
		}
	}

Exit:

	return fRet;
}


//==================================================================================
// CreateSession
//----------------------------------------------------------------------------------
//
// Description: Creates a session with the specified attributes and returns the session ID 
//
// Arguments:
//	DWORD		dwPublicAvailable	Number of public slots available
//	DWORD		dwPrivateAvailable	Number of private slots available
//	PATTRIBUTE	pAttributeArray		Array of attributes to add to this session
//	DWORD		dwAttributeCount	Number of attributes in the array
//	DWORD		*pdwSessionID		Variable that passes back the creates session's ID
//
// Returns: TRUE if the session was created successfully, FALSE otherwise
//==================================================================================
BOOL CreateSession(ULONGLONG qwPublicAvailable, ULONGLONG qwPrivateAvailable, PATTRIBUTE pAttributeArray, DWORD dwAttributeCount, XNKID *pSessionID)
{
	XONLINETASK_HANDLE hMatch = NULL;
	ULONGLONG qwUserID = 0;
	HRESULT hr = S_OK;
    HANDLE hEvent = NULL;
	DWORD dwAttributeSize = 0, dwAttributeIndex = 0, dwPollCounter = 0;
	XNKID SessionID;
	BOOL fSuccess = FALSE, fCompleted = TRUE;

	if(!pSessionID || (!pAttributeArray && dwAttributeCount)) 
	{
		goto Exit;
	}

	memset(pSessionID, 0, sizeof(XNKID));
	qwUserID = 0;

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
	{
		goto Exit;
	}

	for(dwAttributeIndex = 0;dwAttributeIndex < dwAttributeCount; ++dwAttributeIndex)
	{
		switch(pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
		{
		case X_ATTRIBUTE_DATATYPE_INTEGER:
			dwAttributeSize += sizeof(DWORD) + sizeof(ULONGLONG);
			break;
		case X_ATTRIBUTE_DATATYPE_STRING:
			dwAttributeSize += sizeof(DWORD) + sizeof(WORD) + (wcslen((WCHAR * ) (pAttributeArray[dwAttributeIndex].Value.pvValue)) + 1) * sizeof(WCHAR);
			break;
		case X_ATTRIBUTE_DATATYPE_BLOB:
			dwAttributeSize += sizeof(DWORD) + sizeof(WORD) + strlen((CHAR * ) (pAttributeArray[dwAttributeIndex].Value.pvValue));
			break;
		default:
			goto Exit;
		}

		// Add space for the user ID
// BUGBUG: Removed X_ATTRIBUTE_TYPE_MASK since it's no longer supported
//		if(!(pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_TYPE_MASK))
//		{
			dwAttributeSize += sizeof(ULONGLONG);
//		}
	}

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, dwAttributeCount, dwAttributeSize, hEvent, &hMatch );
	if(FAILED(hr))
	{
		fSuccess = FALSE;
		goto Exit;
	}

	if(dwAttributeCount)
	{
		if(!AddAttributes(hMatch, pAttributeArray, dwAttributeCount))
		{
			fSuccess = FALSE;
			goto Exit;
		}
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE since it's no longer supported
	hr = XOnlineMatchSessionSetInt(hMatch, /*XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE*/ 0, qwUserID, qwPublicAvailable);
	if(FAILED(hr))
	{		
		fSuccess = FALSE;
		goto Exit;
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE since it's no longer supported
	hr = XOnlineMatchSessionSetInt(hMatch, /*XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE*/ 0, qwUserID, qwPrivateAvailable);
	if(FAILED(hr))
	{		
		fSuccess = FALSE;
		goto Exit;
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if (FAILED(hr))
	{
		fSuccess = FALSE;
		goto Exit;
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
	if((hr == S_OK) && fCompleted)
	{
		XOnlineMatchSessionGetID (hMatch, pSessionID);
		
		if(*((ULONGLONG *) pSessionID))
		{
			fSuccess = TRUE;
		}
		
		hMatch = NULL;
	}
	else
	{
		if(fCompleted)
			hMatch = NULL;
		fSuccess = FALSE;
		goto Exit;
	}

Exit:

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskClose(hMatch);
		hMatch = NULL;
	}

	if(hEvent)
		CloseHandle(hEvent);

	return fSuccess;
}
#endif



} // namespace MatchCoreTestNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( matchcoretest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( matchcoretest )
    EXPORT_TABLE_ENTRY( "StartTest", MatchCoreTestStart )
    EXPORT_TABLE_ENTRY( "EndTest", MatchCoreTestEnd )
    EXPORT_TABLE_ENTRY( "DllMain", MatchCoreTestDllMain )
END_EXPORT_TABLE( matchcoretest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\xmatchtest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//
// BUGBUG: Dummy stubs to let it compile
//

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionCreate(
    IN XNKID SessionID,
    IN DWORD dwNumAttributes,
    IN DWORD dwAttributesLen,
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE* phSession
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetInt(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN ULONGLONG qwAttributeValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetString(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN LPCWSTR pwszAttributeValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetBlob(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN DWORD dwAttributeLength,
    IN PVOID pvAttributeValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionAddPlayer(
    IN XONLINETASK_HANDLE hSession,
    IN ULONGLONG qwUserPUID
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionRemovePlayer(
    IN XONLINETASK_HANDLE hSession,
    IN ULONGLONG qwUserPUID
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSend(
    IN XONLINETASK_HANDLE hSession
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionGetID (
    IN XONLINETASK_HANDLE hSession,
    OUT XNKID* pSessionID
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionDelete(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phDelete
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionFindFromID(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phSearch
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchCreate(
    IN DWORD dwProcedureIndex,
    IN DWORD dwNumResults,
    IN DWORD dwNumParameters,
    IN DWORD dwParametersLen,
    IN DWORD dwResultsLen,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phSearch
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendInt(
    IN XONLINETASK_HANDLE hSearch,
    IN ULONGLONG qwParameterValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendString(
    IN XONLINETASK_HANDLE hSearch,
    IN LPCWSTR pwszParameterValue
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendBlob(
    IN XONLINETASK_HANDLE hSearch,
    IN DWORD dwParameterLen,
    IN LPVOID pvParameterValue
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchSend(
    IN XONLINETASK_HANDLE hSearch
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT 
WINAPI
XOnlineMatchSearchGetResults(
    IN XONLINETASK_HANDLE hSearch,
    OUT PXMATCH_SEARCHRESULT **prgpSearchResults,
    OUT DWORD *pdwReturnedResults
    )
{
    return S_OK;
}
 
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchGetAttribute(
    IN XONLINETASK_HANDLE hSearch,
    IN DWORD dwSearchResultIndex,
    IN DWORD dwAttributeIndex,
    OUT DWORD *pdwAttributeID,
    OUT VOID *pAttributeValue,
    OUT DWORD *pcbAttributeValue
    )
{
    return S_OK;
}

//==================================================================================
// Globals
//==================================================================================
// Test specific globals
static CRITICAL_SECTION g_csSerializeAccess;
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
HANDLE g_hHeap = NULL;

static PXMATCH_LOCAL_TEST_FUNCTION g_LocalTestFunctions[XMATCHMSG_LOCAL_MAXTEST] = 
{
	XMatchTest_OpenSession,							//XMATCHMSG_OPENSESSION
	XMatchTest_SetAttributes,						//XMATCHMSG_SETATTRIBUTES
	XMatchTest_SendSession,							//XMATCHMSG_SENDSESSION
	XMatchTest_CreateSearch,						//XMATCHMSG_CREATESEARCH
	XMatchTest_AppendParams,						//XMATCHMSG_APPENDPARAMS
	XMatchTest_SendSearch,							//XMATCHMSG_SENDSEARCH
	XMatchTest_SearchResults,						//XMATCHMSG_SEARCHRESULTS
	XMatchTest_AddRemovePlayers,					//XMATCHMSG_ADDREMOVEPLAYERS
	XMatchTest_DeleteSession,						//XMATCHMSG_DELETESESSION
	XMatchTest_FindSessionFromID,					//XMATCHMSG_FINDFROMID
	XMatchTest_GetSessionID							//XMATCHMSG_GETSESSIONID
};

static LPSTR g_LocalTestNames[XMATCHMSG_LOCAL_MAXTEST] = 
{
	"Open session",									//XMATCHMSG_OPENSESSION
	"Set attributes",								//XMATCHMSG_SETATTRIBUTES
	"Send session",									//XMATCHMSG_SENDSESSION
	"Create search",								//XMATCHMSG_CREATESEARCH
	"Append params",								//XMATCHMSG_APPENDPARAMS
	"Send search",									//XMATCHMSG_SENDSEARCH
	"Search results",								//XMATCHMSG_SEARCHRESULTS
	"Add/Remove players",							//XMATCHMSG_ADDREMOVEPLAYERS
	"Delete session",								//XMATCHMSG_DELETESESSION
	"Find session from ID",							//XMATCHMSG_FINDFROMID
	"Get session ID"								//XMATCHMSG_GETSESSIONID
};

//==================================================================================
// MemAlloc
//----------------------------------------------------------------------------------
//
// MemAlloc: Private heap allocation function
//
// Arguments:
//	DWORD		dwSize		Size of buffer to allocate from the private heap
//
// Returns: Valid pointer to newly allocated memory, NULL otherwise
//==================================================================================
LPVOID MemAlloc(DWORD dwSize)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return NULL;
	}

	return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize);
}

//==================================================================================
// MemFree
//----------------------------------------------------------------------------------
//
// Description: Private heap deallocation function
//
// Arguments:
//	LPVOID		pBuffer		Pointer to buffer to be released
//
// Returns: TRUE if the buffer was deallocated, FALSE otherwise
//==================================================================================
BOOL MemFree(LPVOID pBuffer)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return FALSE;
	}

	return HeapFree(g_hHeap, 0, pBuffer);
}

DWORD GetBufferLenForInt()
{
	return sizeof(DWORD) + sizeof(ULONGLONG);
}

DWORD GetBufferLenForString(LPWSTR szString)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += (wcslen(szString) + 1) * sizeof(WCHAR);
	return dwSize;
}

DWORD GetBufferLenForBlob(LPSTR szBlob)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += strlen(szBlob) * sizeof(CHAR);
	return dwSize;
}

DWORD GetBufferLenForUserInt()
{
	return (sizeof(ULONGLONG) + GetBufferLenForInt());
}

DWORD GetBufferLenForUserString(LPWSTR szString)
{
	return (sizeof(ULONGLONG) + GetBufferLenForString(szString));
}

DWORD GetBufferLenForUserBlob(LPSTR szBlob)
{
	return (sizeof(ULONGLONG) + GetBufferLenForBlob(szBlob));
}

//==================================================================================
// XOnlineLogonWrapper
//----------------------------------------------------------------------------------
//
// Description: XOnlineLogon wrapper code stolen from dev tests
//
// Arguments:
//	HANDLE				hLog			Handle to logging subsystem
//	DWORD*          	pServices		Pointer to services for which credentials are desired
//	DWORD				cServices		Number of services
//	DWORD				dwMaxWaitTime	Maximum number of seconds to allow for logon to complete
//
// Returns: Passes back async completion result
//==================================================================================
HRESULT XOnlineLogonWrapper(HANDLE hLog, PXONLINETASK_HANDLE phLogon, DWORD* pServices, DWORD cServices, DWORD dwMaxWaitTime)
{
	XONLINE_USER		UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	HRESULT				hr = S_OK;
	HANDLE				hEvent = NULL;
	DWORD				dwNumUsers = 0, dwStartTime = 0, dwCurrentTime = 0, dwElapsedTime = 0;
	BOOL				fDone = FALSE;
	
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

	// Get local users (we assume that the hard-drive has been populated)
	hr = XOnlineGetUsers( UsersArray, &dwNumUsers );
	if (FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "Getting users from hard-drive failed with 0x%08x", hr);
		hr = E_FAIL;
		goto Exit;
	}

	if(!dwNumUsers)
	{
		OutputDebugString(TEXT("No users were found on the hard-drive, run the SetupOnline tool!"));
		xLog(hLog, XLL_INFO, "No users were found on the hard-drive, run the SetupOnline tool!");
		hr = E_FAIL;
		goto Exit;
	}

	// Initialize services
	xLog(hLog, XLL_INFO, "Logging into %u services with %u users", cServices, dwNumUsers);
	hr = XOnlineLogon(UsersArray, pServices, cServices, hEvent, phLogon);
	if (FAILED(hr))
        goto Exit;

	dwElapsedTime = 0;
	dwStartTime = GetTickCount();

	// Pump until logon succeeds (PARTIAL_RESULTS flag set) or fails (DONT_CONTINUE flag set)
	xLog(hLog, XLL_INFO, "Waiting for logon to complete");
	do
	{

		dwCurrentTime = GetTickCount();

		// Calculate the elapsed time based on whether the time has wrapped around
		if(dwCurrentTime < dwStartTime)
			dwElapsedTime =  MAXDWORD - dwStartTime + dwCurrentTime;
		else
			dwElapsedTime = dwCurrentTime - dwStartTime;

		if(dwElapsedTime > dwMaxWaitTime)
		{
			xLog(hLog, XLL_INFO, "Logon didn't complete in allowed time");
			hr = E_FAIL;
			goto Exit;
		}

		if( WaitForSingleObject( hEvent, dwMaxWaitTime - dwElapsedTime ) == WAIT_OBJECT_0 )
		{
			fDone = XOnlineTaskDoWork(*phLogon, 0);
		}
		else
		{
			xLog(hLog, XLL_INFO, "Waiting for logon event failed!");
			hr = E_FAIL;
			break;
		}

	} while(!fDone);


	hr = XOnlineLogonTaskGetResults(*phLogon);
	
	xLog(hLog, XLL_INFO, "Logon returned 0x%08x", hr);
	if (hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
	{
		xLog(hLog, XLL_INFO, "Logon failed asynchronously");
		hr = E_FAIL;
		goto Exit;
	}

	xLog(hLog, XLL_INFO, "Logon completed successfully");

Exit:

	if(hEvent)
		CloseHandle(hEvent);

	return(hr);
}			

//==================================================================================
// ReadSearchResults
//----------------------------------------------------------------------------------
//
// Description: Adds attributes from a list to the async task indicated
//
// Arguments:
//	HANDLE				hLog				Handle to logging subsystem
//	XONLINETASK_HANDLE	hSearch				Handle to search task
//	DWORD				dwResultsExpected	Number of results expected
//	BOOL				fMoreResultsOK		Indicates whether an exact number of results is expected, or just a minimum
//
// Returns: TRUE if the search results were returned and formatted correctly, FALSE otherwise
//==================================================================================
BOOL ReadSearchResults(HANDLE hLog, XONLINETASK_HANDLE hSearch, DWORD dwResultsExpected, BOOL fMoreResultsOK)
{
	PXMATCH_SEARCHRESULT *ppSearchResults = NULL;
	HRESULT hr = S_OK;
	DWORD dwNumResults = 0;
	BOOL fPassed = TRUE;

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "Getting search results failed with 0x%08x", hr);
		return FALSE;
	}

	if(fMoreResultsOK)
	{
		if(dwNumResults < dwResultsExpected)
		{
			xLog(hLog, XLL_FAIL, "Received %u results but at least %u were expected",
				dwNumResults, dwResultsExpected);
			return FALSE;
		}
	}
	else
	{
		if(dwNumResults != dwResultsExpected)
		{
			xLog(hLog, XLL_FAIL, "Received %u results but exactly %u were expected",
				dwNumResults, dwResultsExpected);
			return FALSE;
		}
	}

	xLog(hLog, XLL_PASS, "Recieved %u results as expected", dwNumResults, dwResultsExpected);
	return TRUE;
}

//==================================================================================
// AddAttributes
//----------------------------------------------------------------------------------
//
// Description: Adds attributes from a list to the async task indicated
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	PATTRIBUTE			pAttributeArray		Pointer to an array of attributes
//	DWORD				dwAttributeCount	Indicates number of attributes in array
//
// Returns: TRUE if the attributes were added successfully, FALSE otherwise
//==================================================================================
BOOL AddAttributes(XONLINETASK_HANDLE hAsyncHandle, PATTRIBUTE pAttributeArray, DWORD dwAttributeCount)
{
	HRESULT hr = S_OK;
	DWORD dwAttributeIndex = 0;
	BOOL fRet = TRUE;

	if(!pAttributeArray)
	{
		fRet = FALSE;
		goto Exit;
	}

	for (dwAttributeIndex = 0; dwAttributeIndex < dwAttributeCount; ++dwAttributeIndex)
	{
		switch (pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSessionSetInt(hAsyncHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].qwUserID, pAttributeArray[dwAttributeIndex].Value.qwValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding integer to session 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSessionSetString(hAsyncHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].qwUserID, (LPWSTR) pAttributeArray[dwAttributeIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to session 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSessionSetBlob(hAsyncHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].qwUserID, strlen((LPSTR)pAttributeArray[dwAttributeIndex].Value.pvValue),
					pAttributeArray[dwAttributeIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to session 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}
		}
	}

Exit:

	return fRet;
}

//==================================================================================
// AddParameters
//----------------------------------------------------------------------------------
//
// Description: Adds parameters from a list to the async task indicated
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	PPARAMETER			pParameterArray		Pointer to an array of parameters
//	DWORD				dwParameterCount	Indicates number of parameters in array
//
// Returns: TRUE if the attributes were added successfully, FALSE otherwise
//==================================================================================
BOOL AddParameters(XONLINETASK_HANDLE hAsyncHandle, PPARAMETER pParameterArray, DWORD dwParameterCount)
{
	HRESULT hr = S_OK;
	DWORD dwParameterIndex = 0;
	BOOL fRet = TRUE;

	if(!pParameterArray)
	{
		fRet = FALSE;
		goto Exit;
	}

	for (dwParameterIndex = 0; dwParameterIndex < dwParameterCount; ++dwParameterIndex)
	{
		switch (pParameterArray[dwParameterIndex].dwParameterType & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSearchAppendInt(hAsyncHandle, pParameterArray[dwParameterIndex].Value.qwValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding integer to search 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSearchAppendString(hAsyncHandle, (LPWSTR) pParameterArray[dwParameterIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to search 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSearchAppendBlob(hAsyncHandle, strlen((LPSTR)pParameterArray[dwParameterIndex].Value.pvValue),
					pParameterArray[dwParameterIndex].Value.pvValue );
				if (FAILED(hr))
				{
					DbgPrint("Error adding string to search 0x%08x\n", hr);
					fRet = FALSE;
					goto Exit;
				}
				break;
			}
		}
	}

Exit:

	return fRet;
}

//==================================================================================
// PollTaskUntilComplete
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskComplete function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	HANDLE				hWorkToDoEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	DWORD				dwMaxWaitTime		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskDoWork function
//	BOOL				*pfCompleted		Optional boolean passed in to keep track if whether
//											the task completed or not
//  BOOL				fCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//
// Returns: The last result code from XOnlineTaskDoWork is returned.  If a valid pointer
//   is provided for pfCompleted, it is updated to reflect whether the task has completed or not
//==================================================================================
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE hAsyncHandle, HANDLE hWorkToDoEvent, DWORD dwMaxWaitTime, DWORD *pdwPollCounter, BOOL *pfCompleted, BOOL fCloseOnComplete)
{
	HRESULT hr = S_OK;
	DWORD dwLastTime = 0, dwCurrentTime = 0, dwCurrentDuration = 0, dwWaitTimeLeft = dwMaxWaitTime;
	DWORD dwInternalPollCounter = 0;
	BOOL fDone = FALSE;

	if(pfCompleted)
		*pfCompleted = FALSE;

	dwLastTime = GetTickCount();

	do
	{

		if((hWorkToDoEvent != INVALID_HANDLE_VALUE) && (hWorkToDoEvent != NULL))
			WaitForSingleObject(hWorkToDoEvent, dwWaitTimeLeft);

        fDone = XOnlineTaskDoWork(hAsyncHandle, 0);

		// Update the poll-counter
		++dwInternalPollCounter;

        if(fDone)
        {
			if(fCloseOnComplete)
				XOnlineTaskClose(hAsyncHandle);

			if(pfCompleted)
				*pfCompleted = TRUE;

            break;
        }
		
		if(dwMaxWaitTime != INFINITE)
		{
			// See if we have gone beyond the maximum allowed time
			dwCurrentTime = GetTickCount();
			if(dwCurrentTime < dwLastTime)
			{
				dwCurrentDuration = ((MAXDWORD - dwLastTime) + dwCurrentTime);
			}
			else
			{
				dwCurrentDuration = (dwCurrentTime - dwLastTime);
			}
			
			if(dwCurrentDuration >= dwWaitTimeLeft)
			{
				DbgPrint("Async opration didn't complete within %u ms\n", dwMaxWaitTime);
				hr = E_FAIL;
				goto Exit;
			}
			
			dwWaitTimeLeft -= dwCurrentDuration;
			dwLastTime = dwCurrentTime;
		}
	} while(TRUE);

Exit:
	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	return hr;
}

//==================================================================================
// CreateSession
//----------------------------------------------------------------------------------
//
// Description: Creates a session with the specified attributes and returns the session ID 
//
// Arguments:
//	DWORD		dwPublicAvailable	Number of public slots available
//	DWORD		dwPrivateAvailable	Number of private slots available
//	PATTRIBUTE	pAttributeArray		Array of attributes to add to this session
//	DWORD		dwAttributeCount	Number of attributes in the array
//	DWORD		*pdwSessionID		Variable that passes back the creates session's ID
//
// Returns: TRUE if the session was created successfully, FALSE otherwise
//==================================================================================
BOOL CreateSession(ULONGLONG qwPublicAvailable, ULONGLONG qwPrivateAvailable, PATTRIBUTE pAttributeArray, DWORD dwAttributeCount, XNKID *pSessionID)
{
	XONLINETASK_HANDLE hMatch = NULL;
	ULONGLONG qwUserID = 0;
	HRESULT hr = S_OK;
    HANDLE hEvent = NULL;
	DWORD dwAttributeSize = 0, dwAttributeIndex = 0, dwPollCounter = 0;
	XNKID SessionID;
	BOOL fSuccess = FALSE, fCompleted = TRUE;

	if(!pSessionID || (!pAttributeArray && dwAttributeCount)) 
	{
		goto Exit;
	}

	memset(pSessionID, 0, sizeof(XNKID));
	qwUserID = 0;

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
	{
		goto Exit;
	}

	for(dwAttributeIndex = 0;dwAttributeIndex < dwAttributeCount; ++dwAttributeIndex)
	{
		switch(pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
		{
		case X_ATTRIBUTE_DATATYPE_INTEGER:
			dwAttributeSize += sizeof(DWORD) + sizeof(ULONGLONG);
			break;
		case X_ATTRIBUTE_DATATYPE_STRING:
			dwAttributeSize += sizeof(DWORD) + sizeof(WORD) + (wcslen((WCHAR * ) (pAttributeArray[dwAttributeIndex].Value.pvValue)) + 1) * sizeof(WCHAR);
			break;
		case X_ATTRIBUTE_DATATYPE_BLOB:
			dwAttributeSize += sizeof(DWORD) + sizeof(WORD) + strlen((CHAR * ) (pAttributeArray[dwAttributeIndex].Value.pvValue));
			break;
		default:
			goto Exit;
		}

		// Add space for the user ID
// BUGBUG: Removed X_ATTRIBUTE_TYPE_MASK since it's no longer supported
//		if(!(pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_TYPE_MASK))
//		{
			dwAttributeSize += sizeof(ULONGLONG);
//		}
	}

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, dwAttributeCount, dwAttributeSize, hEvent, &hMatch );
	if(FAILED(hr))
	{
		fSuccess = FALSE;
		goto Exit;
	}

	if(dwAttributeCount)
	{
		if(!AddAttributes(hMatch, pAttributeArray, dwAttributeCount))
		{
			fSuccess = FALSE;
			goto Exit;
		}
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE since it's no longer supported
	hr = XOnlineMatchSessionSetInt(hMatch, /*XMATCH_ATTRIBUTE_PUBLIC_AVAILABLE*/ 0, qwUserID, qwPublicAvailable);
	if(FAILED(hr))
	{		
		fSuccess = FALSE;
		goto Exit;
	}

// BUGBUG: Removed XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE since it's no longer supported
	hr = XOnlineMatchSessionSetInt(hMatch, /*XMATCH_ATTRIBUTE_PRIVATE_AVAILABLE*/ 0, qwUserID, qwPrivateAvailable);
	if(FAILED(hr))
	{		
		fSuccess = FALSE;
		goto Exit;
	}

	hr = XOnlineMatchSessionSend(hMatch);
	if (FAILED(hr))
	{
		fSuccess = FALSE;
		goto Exit;
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
	if((hr == S_OK) && fCompleted)
	{
		XOnlineMatchSessionGetID (hMatch, pSessionID);
		
		if(*((ULONGLONG *) pSessionID))
		{
			fSuccess = TRUE;
		}
		
		hMatch = NULL;
	}
	else
	{
		if(fCompleted)
			hMatch = NULL;
		fSuccess = FALSE;
		goto Exit;
	}

Exit:

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskClose(hMatch);
		hMatch = NULL;
	}

	if(hEvent)
		CloseHandle(hEvent);

	return fSuccess;
}


//==================================================================================
// XMatchTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI XMatchTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;
	XNADDR xnaddr;
	DWORD dwElapsedTime = 0, dwStartTime = 0, dwCurrentTime = 0, dwResult = 0;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		
		dwElapsedTime = 0;
		dwStartTime = GetTickCount();
		
		// Wait until stack initialization completes
		do
		{
			dwCurrentTime = GetTickCount();
			
			// Calculate the elapsed time based on whether the time has wrapped around
			if(dwCurrentTime < dwStartTime)
				dwElapsedTime =  MAXDWORD - dwStartTime + dwCurrentTime;
			else
				dwElapsedTime = dwCurrentTime - dwStartTime;
			
			if(dwElapsedTime > 10000)
			{
				OutputDebugString(TEXT("Net stack failed to initialize"));
				return FALSE;
			}
			
			dwResult = XNetGetTitleXnAddr (&xnaddr);		
			
		} while (XNET_GET_XNADDR_PENDING == dwResult);

		WSAStartup(MAKEWORD(2, 2), &WSAData);
		g_hHeap = HeapCreate(0,0,0);
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		DeleteCriticalSection(&g_csSerializeAccess);
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}


//==================================================================================
// XMatchTestStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI XMatchTestStartTest(IN HANDLE  hLog)
{
	XONLINETASK_HANDLE hLogon = NULL;
	HRESULT hr = S_OK;
	HANDLE hPingObject = NULL, hEnumObject = NULL, hClientObject = NULL;
	DWORD dwInitialized = 0, dwServices = 0;
	INT nRet = 0, i;

	DWORD ServicesArray[NUM_SERVICES] =
	{
		XONLINE_MATCHMAKING_SERVICE
	};

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Online(S)", "Matching - Client (S-o)");
	xSetFunctionName(g_hLog, "<none>");

	dwServices = (sizeof(ServicesArray)/sizeof(DWORD));

	hr = XOnlineLogonWrapper(hLog, &hLogon, ServicesArray, dwServices, 30000);
    if (FAILED(hr))
	{
		xLog(g_hLog, XLL_FAIL, "Failed to initialize services");
		goto Exit;
	}

	// Run tests that don't require another machine
	for(i = XMATCHMSG_LOCAL_BASE; i < XMATCHMSG_LOCAL_MAXTEST; i++)
//	for(i = XMATCHMSG_SENDSEARCH; i <= XMATCHMSG_SENDSEARCH; i++)
	{
		xSetFunctionName(g_hLog, g_LocalTestNames[i]);

		g_LocalTestFunctions[i](hLog, hLogon);

		xSetFunctionName(g_hLog, "");
	}

Exit:

	g_hLog = INVALID_HANDLE_VALUE;

	CLEANUP_TASK(hLogon);

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);
}            

//==================================================================================
// XMatchTestEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI XMatchTestEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

} // namespace XMatchTestNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xmatchtest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( xmatchtest )
    EXPORT_TABLE_ENTRY( "StartTest", XMatchTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XMatchTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XMatchTestDllMain )
END_EXPORT_TABLE( xmatchtest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\matchcoretest.h ===
#ifndef __MATCHCORETEST_H__
#define __MATCHCORETEST_H__


//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <netsync.h>
#include <xlog.h>


#include <xonlinep.h>
#include <xnetref.h>

namespace MatchCoreTestNamespace {

//==================================================================================
// Defines
//==================================================================================


#define ALLOWEDPUMPINGTIME              30000


#define NUM_SERVICES 1

extern HANDLE g_hTestLog;
extern XONLINETASK_HANDLE g_hLogonTask;

#if 0
//==================================================================================
// Typedefs
//==================================================================================

//==================================================================================
// Structures
//==================================================================================
typedef struct
{
	ULONGLONG		qwUserID;
	DWORD			dwAttributeID;
	union
	{
		ULONGLONG		qwValue;
		VOID			*pvValue;
	} Value;
} ATTRIBUTE, *PATTRIBUTE;

typedef struct
{
	DWORD			dwParameterType;
	union
	{
		ULONGLONG		qwValue;
		VOID			*pvValue;
	} Value;
} PARAMETER, *PPARAMETER;
#endif

// XMATCH test case IDs
typedef enum _MATCHMSG_LOCAL_TESTTYPES
{
	MATCHMSG_LOCAL_BASE = 0,
	MATCHMSG_CREATESESSION = 0,
#if 0
	MATCHMSG_SETATTRIBUTES,
	MATCHMSG_SENDSESSION,
	MATCHMSG_CREATESEARCH,
	MATCHMSG_APPENDPARAMS,
	MATCHMSG_SENDSEARCH,
	MATCHMSG_SEARCHRESULTS,
	MATCHMSG_ADDREMOVEPLAYERS,
	MATCHMSG_DELETESESSION,
	MATCHMSG_FINDFROMID,
	MATCHMSG_GETSESSIONID,
#endif	
	MATCHMSG_LOCAL_MAXTEST
} MATCHMSG_LOCAL_TESTTYPES, *PMATCHMSG_LOCAL_TESTTYPES;

// XMATCH test function
typedef void (*PMATCH_CORE_TEST_FUNCTION)();

void MatchCoreTest_CreateSession();

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI MatchCoreTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI MatchCoreTestStart(IN HANDLE hLog);
VOID WINAPI MatchCoreTestEnd();

#if 0
// Helper functions
LPVOID MemAlloc(DWORD dwSize);
BOOL MemFree(LPVOID pBuffer);
DWORD GetBufferLenForInt();
DWORD GetBufferLenForString(LPWSTR szString);
DWORD GetBufferLenForBlob(LPSTR szBlob);
DWORD GetBufferLenForUserInt();
DWORD GetBufferLenForUserString(LPWSTR szString);
DWORD GetBufferLenForUserBlob(LPSTR szBlob);
BOOL ReadSearchResults(HANDLE hLog, XONLINETASK_HANDLE hSearch, DWORD dwResultsExpected, BOOL fMoreResultsOK);

BOOL AddAttributes(XONLINETASK_HANDLE, PATTRIBUTE, DWORD);
BOOL AddParameters(XONLINETASK_HANDLE, PPARAMETER, DWORD);
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE, HANDLE, DWORD, DWORD *, BOOL *, BOOL);
BOOL CreateSession(ULONGLONG, ULONGLONG, PATTRIBUTE, DWORD, XNKID *);
#endif
// Local test cases
HRESULT MatchCoreTest_OpenSession(HANDLE hLog, XONLINETASK_HANDLE hLogon);
#if 0
HRESULT MatchCoreTest_SetAttributes(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_SendSession(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_CreateSearch(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_AppendParams(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_SendSearch(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_SearchResults(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_AddRemovePlayers(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_DeleteSession(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_FindSessionFromID(HANDLE hLog, XONLINETASK_HANDLE hLogon);
HRESULT MatchCoreTest_GetSessionID(HANDLE hLog, XONLINETASK_HANDLE hLogon);
#endif

} // namespace MatchCoreTestNamespace

#endif // __XMATCHTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\stress\opensession.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_OpenSession(HANDLE hLog);

//==================================================================================
// XMatchTest_OpenSession
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for creating sessions via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_OpenSession(HANDLE hLog)
{
	PXMATCH_EXTENDED_HANDLE pMatchHandle = NULL;
	XONLINETASK_HANDLE hMatch = NULL;
	ULONGLONG qwSessionID = 0, qwNewSessionID = 0;
	ATTRIBUTE AttributeTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0, dwWorkFlags = 0;
	BOOL fCompleted = FALSE, fRet = FALSE;

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* CAUSES RIP
	// -------------------------------------------
	// Non-zero attrib count, but zero attrib len
	// -------------------------------------------
	xStartVariation(hLog, "Non-zero attrib count, but zero attrib len");

	hr = XOnlineMatchSessionCreate(0, 10, 0, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_PASS, "XOnlineMatchSessionCreate successfully returned 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate returned success but should have failed!");
		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);
*/

/* CAUSES RIP
	// -------------------------------------------
	// Non-zero attrib len, but zero attrib count
	// -------------------------------------------
	xStartVariation(hLog, "Non-zero attrib len, but zero attrib count");

	hr = XOnlineMatchSessionCreate(0, 0, 1000, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_PASS, "XOnlineMatchSessionCreate successfully returned 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate returned success but should have failed!");
		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);
*/

/* CAUSES RIP
	// -------------------------------------------
	// Null phSession parameter
	// -------------------------------------------
	xStartVariation(hLog, "Null phSession parameter");

	hr = XOnlineMatchSessionCreate(0, 10, 1000, hEvent, NULL );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_PASS, "XOnlineMatchSessionCreate successfully returned 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate returned success but should have failed!");
		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);
*/

/* Removed until session creation bug is fixed
	// -------------------------------------------
	// Try to modify a session that doesn't exist
	// -------------------------------------------
	xStartVariation(hLog, "Try to modify a session that doesn't exist");

	hMatch = NULL;
	qwSessionID = 0;
	hr = XOnlineMatchSessionCreate(1, 0, 0, hEvent, &hMatch );
	if(!FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
		
		hr = XOnlineMatchSessionSend(hMatch);
		if (!FAILED(hr))
		{
			hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
			if (FAILED(hr) && fCompleted)
			{
				pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
				qwSessionID = pMatchHandle->qwSessionID;

				if(!qwSessionID)
				{
					xLog(hLog, XLL_PASS, "Session creation failed with 0x%08x after %u polls", hr, dwPollCounter);
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session creation failed with 0x%08x after %u polls, but returned session ID %u", hr, dwPollCounter, qwSessionID);
				}
				
				hMatch = NULL;
			}
			else
			{
				if(fCompleted)
				{
					xLog(hLog, XLL_FAIL, "Session creation returned success, but should have failed");
					hMatch = NULL;
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session creation didn't complete after %u polls", dwPollCounter);
				}
			}
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
			hMatch = NULL;
		}		
	}
	else
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);
*/

	// -------------------------------------------
	// Create a new session with no attributes
	// -------------------------------------------
	xStartVariation(hLog, "Create a new session with no attributes");

	hMatch = NULL;
	qwSessionID = 0;
	hr = XOnlineMatchSessionCreate(0, 0, 0, hEvent, &hMatch );
	if(!FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
		
		hr = XOnlineMatchSessionSend(hMatch);
		if (!FAILED(hr))
		{
			hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
			if (!FAILED(hr) && fCompleted)
			{
				pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
				qwSessionID = pMatchHandle->qwSessionID;

				if(qwSessionID)
				{
					xLog(hLog, XLL_PASS, "Session creation succeeded after %u polls! (ID %u)", dwPollCounter, qwSessionID);
					hMatch = NULL;
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session creation succeeded after %u polls, but no session ID was returned.", dwPollCounter);
					hMatch = NULL;
				}
			}
			else
			{
				xLog(hLog, XLL_FAIL, "Session creation didn't complete successfully (0x%08x, completed %s)",
					hr, fCompleted ? "TRUE" : "FALSE");
				
				if(fCompleted)
					hMatch = NULL;
			}
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
			hMatch = NULL;
		}		
	}
	else
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);


	// -------------------------------------------
	// Modify the session that was just created without adding attribute
	// -------------------------------------------
	xStartVariation(hLog, "Modify the session that was just created without adding attributes");

	hMatch = NULL;
	qwNewSessionID = 0;
	hr = XOnlineMatchSessionCreate(qwSessionID, 0, 0, hEvent, &hMatch );
	if(!FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
		
		hr = XOnlineMatchSessionSend(hMatch);
		if (!FAILED(hr))
		{
			hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
			if (!FAILED(hr) && fCompleted)
			{
				pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
				qwNewSessionID = pMatchHandle->qwSessionID;

				if(qwNewSessionID == qwSessionID)
				{
					xLog(hLog, XLL_PASS, "Session modification succeeded after %u polls! (ID %u)", dwPollCounter, qwSessionID);
					hMatch = NULL;
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session modification succeeded after %u polls, but incorrect session ID was returned %u.",
						dwPollCounter, qwNewSessionID);
					hMatch = NULL;
				}
			}
			else
			{
				xLog(hLog, XLL_FAIL, "Session modification didn't complete successfully (0x%08x, completed %s)",
					hr, fCompleted ? "TRUE" : "FALSE");
				
				if(fCompleted)
					hMatch = NULL;
			}
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
			hMatch = NULL;
		}		
	}
	else
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);

/* Bug 5485
	// -------------------------------------------
	// Use a NULL work event
	// -------------------------------------------
	xStartVariation(hLog, "Use a null work event");

	qwSessionID = 0;
	hr = XOnlineMatchSessionCreate(0, 0, 0, NULL, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
		
		hr = XOnlineMatchSessionSend(hMatch);
		if (!FAILED(hr))
		{
			hr = PollTaskUntilComplete(hMatch, NULL, 30000, &dwPollCounter, &fCompleted, TRUE);
			if (!FAILED(hr) && fCompleted)
			{
				pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
				qwSessionID = pMatchHandle->qwSessionID;

				if(qwSessionID)
				{
					xLog(hLog, XLL_PASS, "Session creation succeeded after %u polls! (ID %u)", dwPollCounter, qwSessionID);
					hMatch = NULL;
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session creation succeeded after %u polls, but no session ID was returned.", dwPollCounter);
					hMatch = NULL;
				}
			}
			else
			{
				xLog(hLog, XLL_FAIL, "Session creation didn't complete successfully after %u polls (0x%08x, completed %s)",
					dwPollCounter, hr, fCompleted ? "TRUE" : "FALSE");
				
				if(fCompleted)
					hMatch = NULL;
			}
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
			hMatch = NULL;
		}
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);
*/

/* No longer relevant now that session ID isn't passed back as an out parameter
	// -------------------------------------------
	// No session ID parameter
	// -------------------------------------------
	xStartVariation(hLog, "No session ID parameter");

	hr = XOnlineMatchSessionCreate(0, 0, 0, hEvent, NULL, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
		
		hr = XOnlineMatchSessionSend(hMatch);
		if (!FAILED(hr))
		{
			hr = PollTaskUntilComplete(hMatch, NULL, 30000, &dwPollCounter, &fCompleted, TRUE);
			if (!FAILED(hr) && fCompleted)
			{
				xLog(hLog, XLL_PASS, "Session creation succeeded after %u polls!", dwPollCounter);
				hMatch = NULL;
			}
			else
			{
				xLog(hLog, XLL_FAIL, "Session creation didn't complete successfully after %u polls (0x%08x, completed %s)",
					dwPollCounter, hr, fCompleted ? "TRUE" : "FALSE");
				
				if(fCompleted)
					hMatch = NULL;
			}
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
			hMatch = NULL;
		}
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);
*/

	// -------------------------------------------
	// Create a new session with one of each attribute type
	// -------------------------------------------
	xStartVariation(hLog, "Create a new session with one of each attribute type");

	qwSessionID = 0;
	hr = XOnlineMatchSessionCreate(0, 3, 1000, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");

		AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
		AttributeTest[0].Value.qwValue = INT1;
		AttributeTest[0].UserID.QuadPart = 0;
		AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
		AttributeTest[1].Value.pvValue = (VOID *) STRING1;
		AttributeTest[1].UserID.QuadPart = 0;
		AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
		AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
		AttributeTest[2].UserID.QuadPart = 0;
		
		fRet = AddAttributes(hMatch, AttributeTest, 3);
		if(fRet)
		{
			hr = XOnlineMatchSessionSend(hMatch);
			if (!FAILED(hr))
			{
				hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
				if (!FAILED(hr) && fCompleted)
				{
					pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
					qwSessionID = pMatchHandle->qwSessionID;

					if(qwSessionID)
					{
						xLog(hLog, XLL_PASS, "Session creation succeeded after %u polls! (ID %u)", dwPollCounter, qwSessionID);
						hMatch = NULL;
					}
					else
					{
						xLog(hLog, XLL_FAIL, "Session creation succeeded after %u polls, but no session ID was returned.", dwPollCounter);
						hMatch = NULL;
					}
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session creation didn't complete successfully after %u polls (0x%08x, completed %s)",
						dwPollCounter, hr, fCompleted ? "TRUE" : "FALSE");
					
					if(fCompleted)
						hMatch = NULL;
				}
			}
			else
			{
				xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
				hMatch = NULL;
			}
		}
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);

	// -------------------------------------------
	// Modify the session that was just created adding attributes of each type
	// -------------------------------------------
	xStartVariation(hLog, "Modify the session that was just created adding attributes of each type");

	qwNewSessionID = 0;
	hr = XOnlineMatchSessionCreate(qwSessionID, 3, 1000, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");

		AttributeTest[0].dwAttributeID = GLOBALINT_ID2;
		AttributeTest[0].Value.qwValue = INT1;
		AttributeTest[0].UserID.QuadPart = 0;
		AttributeTest[1].dwAttributeID = GLOBALSTR_ID2;
		AttributeTest[1].Value.pvValue = (VOID *) STRING1;
		AttributeTest[1].UserID.QuadPart = 0;
		AttributeTest[2].dwAttributeID = GLOBALBLB_ID2;
		AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
		AttributeTest[2].UserID.QuadPart = 0;
		
		fRet = AddAttributes(hMatch, AttributeTest, 3);
		if(fRet)
		{
			hr = XOnlineMatchSessionSend(hMatch);
			if (!FAILED(hr))
			{
				hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
				if (!FAILED(hr) && fCompleted)
				{
					pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
					qwNewSessionID = pMatchHandle->qwSessionID;

					if(qwNewSessionID == qwSessionID)
					{
						xLog(hLog, XLL_PASS, "Session modification succeeded after %u polls! (ID %u)", dwPollCounter, qwSessionID);
						hMatch = NULL;
					}
					else
					{
						xLog(hLog, XLL_FAIL, "Session modification succeeded after %u polls, but incorrect session ID was returned.",
							dwPollCounter, qwNewSessionID);
						hMatch = NULL;
					}
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session modification didn't complete successfully after %u polls (0x%08x, completed %s)",
						dwPollCounter, hr, fCompleted ? "TRUE" : "FALSE");
					
					if(fCompleted)
						hMatch = NULL;
				}
			}
			else
			{
				xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
				hMatch = NULL;
			}
		}
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);

	// -------------------------------------------
	// Modify session and re-add existing attributes
	// -------------------------------------------
	xStartVariation(hLog, "Modify session and re-add existing attributes");

	qwNewSessionID = 0;
	hr = XOnlineMatchSessionCreate(qwSessionID, 3, 1000, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");

		AttributeTest[0].dwAttributeID = GLOBALINT_ID2;
		AttributeTest[0].Value.qwValue = INT1;
		AttributeTest[0].UserID.QuadPart = 0;
		AttributeTest[1].dwAttributeID = GLOBALSTR_ID2;
		AttributeTest[1].Value.pvValue = (VOID *) STRING1;
		AttributeTest[1].UserID.QuadPart = 0;
		AttributeTest[2].dwAttributeID = GLOBALBLB_ID2;
		AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
		AttributeTest[2].UserID.QuadPart = 0;
		
		fRet = AddAttributes(hMatch, AttributeTest, 3);
		if(fRet)
		{
			hr = XOnlineMatchSessionSend(hMatch);
			if (!FAILED(hr))
			{
				hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, TRUE);
				if (!FAILED(hr) && fCompleted)
				{
					pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
					qwNewSessionID = pMatchHandle->qwSessionID;

					if(qwNewSessionID == qwSessionID)
					{
						xLog(hLog, XLL_PASS, "Session modification succeeded after %u polls! (ID %u)", dwPollCounter, qwSessionID);
						hMatch = NULL;
					}
					else
					{
						xLog(hLog, XLL_FAIL, "Session modification succeeded after %u polls, but incorrect session ID was returned.",
							dwPollCounter, qwNewSessionID);
						hMatch = NULL;
					}
				}
				else
				{
					xLog(hLog, XLL_FAIL, "Session modification didn't complete successfully after %u polls (0x%08x, completed %s)",
						dwPollCounter, hr, fCompleted ? "TRUE" : "FALSE");
					
					if(fCompleted)
						hMatch = NULL;
				}
			}
			else
			{
				xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
				hMatch = NULL;
			}
		}
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}

	xEndVariation(hLog);

	// -------------------------------------------
	// Open and close an XMatch request without calling the work pump
	// -------------------------------------------
	xStartVariation(hLog, "Open and close an XMatch request without calling the work pump");

	qwSessionID = 0;
	hr = XOnlineMatchSessionCreate(0, 1, 100, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");

		dwPollCounter = 0;
		XOnlineTaskCancel(hMatch, &dwWorkFlags);
		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);

		hr = XOnlineTaskCloseHandle(hMatch);
		if(FAILED(hr))
		{
			xLog(hLog, XLL_FAIL, "XOnlineTaskCloseHandle failed with 0x%08x", hr);
		}
		else
		{
			pMatchHandle = (PXMATCH_EXTENDED_HANDLE) hMatch;
			qwSessionID = pMatchHandle->qwSessionID;

			if(!qwSessionID)
			{
				xLog(hLog, XLL_PASS, "Task was cancelled and closed successfully.");
			}
			else
			{
				xLog(hLog, XLL_FAIL, "Task was cancelled and closed, but session ID was set to %u", qwSessionID);
			}
			hMatch = NULL;
		}
	}
	

	xEndVariation(hLog);

/* Removed until 6229 is fixed
	// -------------------------------------------
	// Call work pump immediately after creating a session request
	// -------------------------------------------
	xStartVariation(hLog, "Open a session request and immediately call work pump");

	hr = XOnlineMatchSessionCreate(0, 1, 100, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");

		dwPollCounter = 1;
		hr = XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
		if(!FAILED(hr))
		{
			xLog(hLog, XLL_FAIL, "XOnlineTaskContinue should have failed!");
		}
		else
		{
			xLog(hLog, XLL_PASS, "XOnlineTaskContinue successfully returned 0x%08x", hr);
		}

		while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
			++dwPollCounter;
		}
		xLog(hLog, XLL_INFO, "Task completed after %u polls!", dwPollCounter);
		XOnlineTaskCloseHandle(hMatch);
		hMatch = NULL;
	}
	
	xEndVariation(hLog);
*/

	// -------------------------------------------
	// Cancel a session request that has already completed and then close it
	// -------------------------------------------
	xStartVariation(hLog, "Cancel a session request that has already completed and then close it");

	qwSessionID = 0;
	hr = XOnlineMatchSessionCreate(0, 0, 0, hEvent, &hMatch );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "XOnlineMatchSessionCreate failed with 0x%08x", hr);
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned success!");
		
		hr = XOnlineMatchSessionSend(hMatch);
		if (!FAILED(hr))
		{
			do
			{
				XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
				++dwPollCounter;
			}
			while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags));
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineMatchSessionSend failed with 0x%08x", hr);
			hMatch = NULL;
		}
	}

	if(hMatch)
	{
		dwPollCounter = 0;
		hr = XOnlineTaskCancel(hMatch, &dwWorkFlags);
		if(hr == E_ABORT)
		{
			while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
			{
				XOnlineTaskContinue(hMatch, 0, &dwWorkFlags);
				++dwPollCounter;
			}
			xLog(hLog, XLL_INFO, "Task was canceled after %u polls!", dwPollCounter);
			
			hr = XOnlineTaskCloseHandle(hMatch);
			if(!FAILED(hr))
			{
				xLog(hLog, XLL_PASS, "Successfully canceled and closed a completed session handle");
			}
			else
			{
				xLog(hLog, XLL_FAIL, "XOnlineTaskCloseHandle failed with 0x%08x", hr);
			}
		}
		else
		{
			xLog(hLog, XLL_FAIL, "XOnlineTaskCancel didn't return E_ABORT (0x%08x)", hr);

			hr = XOnlineTaskCloseHandle(hMatch);
		}
		
		hMatch = NULL;
	}

	xEndVariation(hLog);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hMatch)
		XOnlineTaskCloseHandle(hMatch);

	return hr;
} // XMatchTest_OpenSession


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\TestCaseAndResult_CreateSession.cpp ===
#include <common.h>
#include "TestCaseAndResult_CreateSession.h"
#include "CTestCase_CreateSession.h"

using namespace MatchCoreTestNamespace;

namespace MatchCoreTestNamespace {

TestCaseAndExpected_CreateSession g_TCAE_CreateSession[]=
{
/*
	{	
		{PubCurr, PubAvail, PriCurr, PriAvail, Attribute, Event, TaskCreate}	For Creation
		{HrExpected, HTaskExpected} For Creation
		UpdateType 
		{PubCurr, PubAvail, PriCurr, PriAvail, Attribute, Event, TaskCreate}	For Update
		{HrExpected, HTaskExpected}	For Update 
	}
*/
	{	
		{DWZero, DWZero, DWZero, DWZero, ZeroNum_Null, NullEvent, ValildTask},
		{SY_FAIL, SY_NULL}, 
		SY_NOUPDATE
	},
	{	
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_SUCCESS, SY_NONNULL}, 
		SY_NOUPDATE
	},
	{	
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_SUCCESS, SY_NONNULL}, 
		SY_VALIDSESSIONID, 
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_SUCCESS, SY_NONNULL}	
	},
	{	
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_SUCCESS, SY_NONNULL},
		SY_INVALIDSESSIONID,
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_FAIL, SY_NULL},
	}
	{	
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_SUCCESS, SY_NONNULL},
		SY_NULLSESSIONID,
		{DWOne, DWOne, DWOne, DWOne, One_Int, NullEvent, ValildTask},
		{SY_FAIL, SY_NULL},
	}
};

int	g_nCase_CreateSession = sizeof g_TCAE_CreateSession / sizeof(TestCaseAndExpected_CreateSession);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core2\TestCaseAndResult_CreateSession.h ===
#ifndef __TESTCASEANDRESULT_CREATESESSION_H__
#define __TESTCASEANDRESULT_CREATESESSION_H__

#include <common.h>

namespace MatchCoreTestNamespace {
typedef struct _TestCase_CreateSession
{
	int		m_nDwordCasePubCurr;
	int		m_nDwordCasePubAvail;
	int		m_nDwordCasePriCurr;
	int		m_nDwordCasePriAvail;
	int		m_nAttributeCase;
	int		m_nEventCase;
	int		m_nTaskCreateCase;
}TestCase_CreateSession;

typedef struct _TestExpected_CreateSession
{
	int m_HrExpected;
	int m_HTaskExpected;
}TestExpected_CreateSession;

#define		SY_NOUPDATE			0
#define		SY_VALIDSESSIONID	1
#define		SY_INVALIDSESSIONID	-1
#define		SY_NULLSESSIONID	-2

typedef struct _TestCaseAndExpected_CreateSession
{
	TestCase_CreateSession m_tc;
	TestExpected_CreateSession m_te;
	Int	m_nUpdate;	//No, Valid SessionID, Invalid SessionID, NULL SessionID
	TestCase_CreateSession m_tcUpdate;
	TestExpected_CreateSession m_teUpdate;
		
}TestCaseAndExpected_CreateSession;

extern TestCaseAndExpected_CreateSession g_TCAE_CreateSession[];
extern	int	g_nCase_CreateSession;

#define XMATCH_SERVER_DLL_W L"xmatchserv.dll"
#define XMATCH_SERVER_MAIN_FUNCTION_A "XMatchServerCallbackFunction"
#define XMATCH_SERVER_START_FUNCTION_A "XMatchServerStartFunction"
#define XMATCH_SERVER_STOP_FUNCTION_A "XMatchServerStopFunction"


#define GLOBALINT_ID1   X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALINT_ID2   X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003
#define GLOBALINT_ID3   X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000004

#define XMATCHUSERINT_ID1  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001

#define GLOBALUSERINT_ID1  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALUSERINT_ID2  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003
#define GLOBALUSERINT_ID3  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000004

#define GLOBALSTR_ID1   X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALSTR_ID2   X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define GLOBALSTR_ID3   X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define GLOBALUSERSTR_ID1  X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALUSERSTR_ID2  X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define GLOBALUSERSTR_ID3  X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define GLOBALBLB_ID1   X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALBLB_ID2   X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define GLOBALBLB_ID3   X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define GLOBALUSERBLB_ID1  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALUSERBLB_ID2  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define GLOBALUSERBLB_ID3  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define TITLEINT_ID1  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define TITLEINT_ID2  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define TITLEINT_ID3  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define TITLEUSERINT_ID1  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define TITLEUSERINT_ID2  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define TITLEUSERINT_ID3  X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define TITLESTR_ID1  X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define TITLESTR_ID2  X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define TITLESTR_ID3  X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define TITLEUSERSTR_ID1  X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define TITLEUSERSTR_ID2  X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define TITLEUSERSTR_ID3  X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define TITLEBLB_ID1  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define TITLEBLB_ID2  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define TITLEBLB_ID3  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define TITLEUSERBLB_ID1  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define TITLEUSERBLB_ID2  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define TITLEUSERBLB_ID3  X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define INT1 0
#define INT2 777888
#define INT3 999
#define INT4 111222333444555666

#define STRING1 L"AAAAABBBBB"
#define STRING2 L"CCCCCDDDDDEEEEE"	// Code expects STRING2 to be longer than STRING1
#define STRING3 L"FFFFF"

#define RESIZESTRING_MID L"1234567890123456789012345678901234567890123456789"
#define RESIZESTRING_MAX L"12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
#define RESIZESTRING_MIN L""

#define BLOB1 "ZZZZZYYYYY"
#define BLOB2 "XXXXXWWWWWVVVVV"		// Code expectes BLOB2 to be longer than BLOB1
#define BLOB3 "UUUUU"

#define RESIZEBLOB_MID "12345678901234567890123456789012345678901234567890"
#define RESIZEBLOB_MAX "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"

#define USER1 0xFFFFFFFF00000001
#define USER2 0xFFFFFFFF00000002
#define USER3 0xFFFFFFFF00000003

#define INVALIDSP_INDEX 0xAAAAAAAA
#define NOPARAM_INDEX 0x00000000
#define INTPARAM_INDEX 0x00000001
#define STRINGPARAM_INDEX 0x00000002
#define BLOBPARAM_INDEX 0x00000003
#define INTSTRBLB_INDEX 0x00000004
#define INTBLBSTR_INDEX 0x00000005
#define STRINTBLB_INDEX 0x00000006
#define BLBINTSTR_INDEX 0x00000007
#define STRBLBINT_INDEX 0x00000008
#define BLBSTRINT_INDEX 0x00000009
#define GETSESSSP_INDEX 0x0000000A
#define GETSESSINT_INDEX 0x0000000B
#define GETSESSSTR_INDEX 0x0000000C
#define GETSESSBLB_INDEX 0x0000000D
#define GETSESSALL_INDEX 0x0000000E
#define GETTITLEALL_INDEX 0x0000000F
#define NOEXECPERM_INDEX 0x00000010

#define MAX_DISPLAY_RESULTS 50
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\stress\xmstress.h ===
#ifndef __XMATCHTEST_H__
#define __XMATCHTEST_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <netsync.h>
#include <xlog.h>

#include <xonlinep.h>
#include <xnetref.h>
#include "asyncrequest.h"
#include "xmclasses.h"

//==================================================================================
// Defines
//==================================================================================
#define DEFAULT_RESULTS_LENGTH 512
#define MAX_SIMULTANEOUS_REQUESTS 5

#define GLOBALINT_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALINT_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003
#define GLOBALINT_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000004

#define GLOBALUSERINT_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define GLOBALUSERINT_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALUSERINT_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define GLOBALSTR_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALSTR_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define GLOBALSTR_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define GLOBALUSERSTR_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALUSERSTR_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define GLOBALUSERSTR_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define GLOBALBLB_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALBLB_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define GLOBALBLB_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define GLOBALUSERBLB_ID1 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALUSERBLB_ID2 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define GLOBALUSERBLB_ID3 X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define TITLEINT_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define TITLEINT_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define TITLEINT_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define TITLEUSERINT_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define TITLEUSERINT_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define TITLEUSERINT_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define TITLESTR_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define TITLESTR_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define TITLESTR_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define TITLEUSERSTR_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define TITLEUSERSTR_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING | 0x00000002
#define TITLEUSERSTR_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING | 0x00000003

#define TITLEBLB_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define TITLEBLB_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define TITLEBLB_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define TITLEUSERBLB_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define TITLEUSERBLB_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002
#define TITLEUSERBLB_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000003

#define INT1 111222333444555666
#define INT2 777888
#define INT3 999

#define STRING1 L"AAAAABBBBB"
#define STRING2 L"CCCCCDDDDDEEEEE"
#define STRING3 L"FFFFF"

#define BLOB1 "ZZZZZYYYYY"
#define BLOB2 "XXXXXWWWWWVVVVV"
#define BLOB3 "UUUUU"

#define USER1 0xFFFFFFFF00000001
#define USER2 0xFFFFFFFF00000002
#define USER3 0xFFFFFFFF00000003

#define INVALIDSP_INDEX 0xAAAAAAAA
#define NOPARAM_INDEX 0x00000000
#define INTPARAM_INDEX 0x00000001
#define STRINGPARAM_INDEX 0x00000002
#define BLOBPARAM_INDEX 0x00000003
#define GETSESSSP_INDEX 0x0000000A
#define GETSESSINT_INDEX 0x0000000B
#define GETSESSSTR_INDEX 0x0000000C
#define GETSESSBLB_INDEX 0x0000000D
#define GETSESSALL_INDEX 0x0000000E
#define GETTITLEALL_INDEX 0x0000000F
#define NOEXECPERM_INDEX 0x00000010

#define MAX_DISPLAY_RESULTS 50

#define NUM_SERVICES 1

namespace XMatchStressNamespace {

typedef enum
{
	CREATE_NO_ATTRIB_REQ,
	CREATE_INTEGER_REQ,
	CREATE_STRING_REQ,
	CREATE_BLOB_REQ,
	SEARCH_NO_PARAM_REQ,
	SEARCH_INTEGER_REQ,
	SEARCH_STRING_REQ,
	SEARCH_BLOB_REQ,
	SEARCH_RETURN_NO_PARAM_REQ,
	SEARCH_RETURN_INT_REQ,
	SEARCH_RETURN_STR_REQ,
	SEARCH_RETURN_BLB_REQ,
	DELETE_REQ,
	INVALID_REQUEST_CATEGORY
} XMATCH_REQUEST_CATEGORY;

typedef struct
{
	DWORD dwCreateNoAttrib;
	DWORD dwCreateIntAttrib;
	DWORD dwCreateStrAttrib;
	DWORD dwCreateBlobAttrib;
	DWORD dwSearchNoParam;
	DWORD dwSearchIntParam;
	DWORD dwSearchStrParam;
	DWORD dwSearchBlobParam;
	DWORD dwSearchNoAttrib;
	DWORD dwSearchIntAttrib;
	DWORD dwSearchStrAttrib;
	DWORD dwSearchBlobAttrib;
} XMATCH_STRESS_STATS, *PXMATCH_STRESS_STATS;

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI XMatchStressDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI XMatchStressStartTest(IN HANDLE hLog);
VOID WINAPI XMatchStressEndTest();
DWORD GetBufferLenForInt();
DWORD GetBufferLenForString(LPWSTR szString);
DWORD GetBufferLenForBlob(LPSTR szBlob);
DWORD GetBufferLenForUserInt();
DWORD GetBufferLenForUserString(LPWSTR szString);
DWORD GetBufferLenForUserBlob(LPSTR szBlob);

// Helper functions
LPVOID MemAlloc(DWORD dwSize);
BOOL MemFree(LPVOID pBuffer);

} // namespace XMatchTestNamespace

#endif // __XMATCHTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\stress\xmstress.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "xmstress.h"

using namespace XMatchStressNamespace;

namespace XMatchStressNamespace {

//==================================================================================
// Globals
//==================================================================================
// Test specific globals
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
HANDLE g_hHeap = NULL;

// Returns the elapsed time given the start and current times
inline DWORD GetElapsedTime(DWORD dwStartTime, DWORD dwCurrentTime)
{
	dwCurrentTime = GetTickCount();
	if(dwStartTime > dwCurrentTime)
		return (MAXDWORD - dwStartTime + dwCurrentTime);
	else
		return (dwCurrentTime - dwStartTime);
}

// Generates a random positive integer between 0 and dwMaxValue
inline DWORD GenerateRandomNumber(DWORD dwMaxValue)
{
	return ((DWORD) rand() % dwMaxValue);
}

template< class T > void ShuffleRemainingArrayItems( T *pStartLocation, DWORD dwItemsToShuffle)
{
   T *pNext = pStartLocation + 1, *pCurrent = pStartLocation;

   while(dwItemsToShuffle--)
   {
	   *pCurrent = *pNext;
	   pCurrent++;
	   pNext++;
   }

   *pCurrent = NULL;
}


//==================================================================================
// MemAlloc
//----------------------------------------------------------------------------------
//
// MemAlloc: Private heap allocation function
//
// Arguments:
//	DWORD		dwSize		Size of buffer to allocate from the private heap
//
// Returns: Valid pointer to newly allocated memory, NULL otherwise
//==================================================================================
LPVOID MemAlloc(DWORD dwSize)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return NULL;
	}

	return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize);
}

DWORD GetBufferLenForInt()
{
	return sizeof(DWORD) + sizeof(ULONGLONG);
}

DWORD GetBufferLenForString(LPWSTR szString)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += (wcslen(szString) + 1) * sizeof(WCHAR);
	return dwSize;
}

DWORD GetBufferLenForBlob(LPSTR szBlob)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += strlen(szBlob) * sizeof(CHAR);
	return dwSize;
}

DWORD GetBufferLenForUserInt()
{
	return (sizeof(ULONGLONG) + GetBufferLenForInt());
}

DWORD GetBufferLenForUserString(LPWSTR szString)
{
	return (sizeof(ULONGLONG) + GetBufferLenForString(szString));
}

DWORD GetBufferLenForUserBlob(LPSTR szBlob)
{
	return (sizeof(ULONGLONG) + GetBufferLenForBlob(szBlob));
}

//==================================================================================
// MemFree
//----------------------------------------------------------------------------------
//
// Description: Private heap deallocation function
//
// Arguments:
//	LPVOID		pBuffer		Pointer to buffer to be released
//
// Returns: TRUE if the buffer was deallocated, FALSE otherwise
//==================================================================================
BOOL MemFree(LPVOID pBuffer)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return FALSE;
	}

	return HeapFree(g_hHeap, 0, pBuffer);
}

//==================================================================================
// XOnlineLogonWrapper
//----------------------------------------------------------------------------------
//
// Description: XOnlineLogon wrapper code stolen from dev tests
//
// Arguments:
//	HANDLE				hLog		Handle to logging subsystem
//	PXONLINE_SERVICE	pServices	Pointer to services for which credentials are desired
//	DWORD				cServices	Number of services
//
// Returns: Passes back async completion result
//==================================================================================
HRESULT XOnlineLogonWrapper(HANDLE hLog, PXONLINE_SERVICE pServices, DWORD cServices)
{
	XONLINETASK_HANDLE	hLogon;
	XONLINE_USER		UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	HRESULT				hr = S_OK;
	HANDLE				hEvent = NULL;
	DWORD				dwWorkFlags = 0, dwNumUsers = 0;
	
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, XONLINE_MAX_STORED_ONLINE_USERS );

	// Get local users
	hr = XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );
	if (FAILED(hr))
        goto Exit;

	// Initialize services
	xLog(hLog, XLL_INFO, "Logging into %u services with %u users", cServices, dwNumUsers);
	hr = XOnlineLogon(UsersArray, pServices, cServices, hEvent, &hLogon);
	if (FAILED(hr))
        goto Exit;

	// Pump until logon returns
	xLog(hLog, XLL_INFO, "Waiting for logon to complete");
	do
	{
		if( WaitForSingleObject( hEvent, 30000 ) == WAIT_OBJECT_0 )
		{
			hr = XOnlineTaskContinue(hLogon, 0, &dwWorkFlags);
		}
		else
		{
			xLog(hLog, XLL_INFO, "Waiting for logon event failed!");
			hr = E_FAIL;
			break;
		}

	} while (!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags));

	if(!FAILED(hr))
		xLog(hLog, XLL_INFO, "Logon completed successfully");
	else
		xLog(hLog, XLL_INFO, "Logon failed with 0x%08x", hr);

Exit:

	if(hEvent)
		CloseHandle(hEvent);

	return(hr);
}			

//==================================================================================
// XMatchStressDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI XMatchStressDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;

	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		WSAStartup(MAKEWORD(2, 2), &WSAData);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}

//==================================================================================
// StartFollowUpXmatchRequest
//----------------------------------------------------------------------------------
//
// Description: Creates a follow up request to a previous session creation.  The
//              follow up request can be either a modfication, a deletion or a search
//
// Arguments:
//	HANDLE					hLog						Handle to logging subsystem
//  XMATCH_REQUEST_CATEGORY	nPreviousRequestCategory	Previous request category which the
//														follow up will be based on
//	XNKID					SessionID					Session ID of the previous request
//
// Returns:
//	A pointer to the created Xmatch request or NULL if one couldn't be created
//==================================================================================
CXOnlineAsyncRequest *StartFollowUpXmatchRequest(HANDLE hLog, XMATCH_REQUEST_CATEGORY nPreviousRequestCategory, XNKID SessionID, DWORD dwPreviousAsyncID)
{
	CXOnlineAsyncRequest *pRequest = NULL;
	CXMatchSessionRequest *pFollowUpSession = NULL;
	CXMatchSearchRequest *pFollowUpSearch = NULL;
	DWORD dwNumAttributes = 0, dwAttributesLen = 0;
	ATTRIBUTE Attribute;
	DWORD dwSearchProcedure = 0, dwNumParameters = 0, dwParametersLen = 0;
	PARAMETER Parameter;

	// The DWORD category variables are used to receive random values and for branching
	// code execution to set up the proper type of test
	DWORD dwRequestCategory = 0, dwRequestSubCategory = 0;

	// The XMATCH_REQUEST_CATEGORY category variable is used to set the specific category type
	// in the CXOnlineAsyncRequest class member
	XMATCH_REQUEST_CATEGORY nFinalRequestCategory = INVALID_REQUEST_CATEGORY;

	dwRequestCategory = GenerateRandomNumber(2);  // Either 0 or 1

	switch(dwRequestCategory)
	{
	// --------------------------------------------
	// Create a session half of the time
	// --------------------------------------------
	case 0:
		dwRequestSubCategory = GenerateRandomNumber(4);
		switch(dwRequestSubCategory)
		{
		// --------------------------------------------
		// Add an integer to an existing session
		case 0:
			dwNumAttributes = 1;
			// Length       = AttributeID   + Size of int att
			dwAttributesLen = GetBufferLenForInt();
			Attribute.dwAttributeID = GLOBALINT_ID1;
			Attribute.UserID = 0;
			Attribute.Value.qwValue = INT1;
			nFinalRequestCategory = CREATE_INTEGER_REQ;
//			xLog(hLog, XLL_INFO, "Adding integer attribute to an existing session");
			break;
		// --------------------------------------------
		// Add a string to an existing session
		case 1:
			dwNumAttributes = 1;
			// Length       = AttributeID   + Len prefix   + Str len         + NULL terminator
			dwAttributesLen = GetBufferLenForString(STRING1);
			Attribute.dwAttributeID = GLOBALSTR_ID1;
			Attribute.UserID = 0;
			Attribute.Value.pvValue = STRING1;
			nFinalRequestCategory = CREATE_STRING_REQ;
//			xLog(hLog, XLL_INFO, "Adding string attribute to an existing session");
			break;
		// --------------------------------------------
		// Add a blob to an existing session
		case 2:
			dwNumAttributes = 1;
			// Length       = AttributeID   + Len prefix    + Blb len
			dwAttributesLen = GetBufferLenForBlob(BLOB1);
			Attribute.dwAttributeID = GLOBALBLB_ID1;
			Attribute.UserID = 0;
			Attribute.Value.pvValue = BLOB1;
			nFinalRequestCategory = CREATE_BLOB_REQ;
//			xLog(hLog, XLL_INFO, "Adding blob attribute to an existing session");
			break;
		// --------------------------------------------
		// Don't add any new attributes to an existing session
		default:
			dwNumAttributes = 0;
			dwAttributesLen = 0;
			nFinalRequestCategory = CREATE_NO_ATTRIB_REQ;
//			xLog(hLog, XLL_INFO, "Updating existing session without adding attributes");
			break;
		}

		// Create the session request with the appropriate attribute buffers
		pFollowUpSession = new CXMatchSessionRequest(SessionID, dwNumAttributes, dwAttributesLen);
		if(!pFollowUpSession)
		{
			xLog(hLog, XLL_WARN, "Not enough memory to allocate new session request");
			return NULL;
		}

		pFollowUpSession->SetAsyncID(GetTickCount());

//		xLog(hLog, XLL_INFO, "Creating follow-up session 0x%08x from 0x%08x", dwPreviousAsyncID, pFollowUpSession->GetAsyncID());

		// Add the attribute if necessary
		if(dwNumAttributes)
		{
			if(!pFollowUpSession->AddAttributes(&Attribute, dwNumAttributes))
			{
				xLog(hLog, XLL_WARN, "Couldn't add attributes to session request");
				delete pFollowUpSession;
				return NULL;
			}
		}

		pFollowUpSession->SetRequestCategory(nFinalRequestCategory);
		if(FAILED(pFollowUpSession->StartRequest()))
		{
			xLog(hLog, XLL_WARN, "Couldn't start request");
			delete pFollowUpSession;
			return NULL;
		}
		pRequest = pFollowUpSession;
		break;

	// --------------------------------------------
	// Create a search the other half of the time
	// --------------------------------------------
	default:
		switch(nPreviousRequestCategory)
		{
		// --------------------------------------------
		// If the previous request was an integer session
		// Then create a search that will return the integer
		case CREATE_INTEGER_REQ:
			nFinalRequestCategory = SEARCH_RETURN_INT_REQ;
			dwSearchProcedure = GETSESSINT_INDEX;
//			xLog(hLog, XLL_INFO, "Searching for session with integer attribute");
			break;
		// --------------------------------------------
		// If the previous request was a string session
		// Then create a search that will return the string
		case CREATE_STRING_REQ:
			nFinalRequestCategory = SEARCH_RETURN_STR_REQ;
			dwSearchProcedure = GETSESSSTR_INDEX;
//			xLog(hLog, XLL_INFO, "Searching for session with string attribute");
			break;
		// --------------------------------------------
		// If the previous request was a blob session
		// Then create a search that will return the blob
		case CREATE_BLOB_REQ:
			nFinalRequestCategory = SEARCH_RETURN_BLB_REQ;
			dwSearchProcedure = GETSESSBLB_INDEX;
//			xLog(hLog, XLL_INFO, "Searching for session with blob attribute");
			break;
		// --------------------------------------------
		// If the previous request was a session without attributes
		// Then create a search that won't return any attributes
		default:
			nFinalRequestCategory = SEARCH_RETURN_NO_PARAM_REQ;
			dwSearchProcedure = GETSESSSP_INDEX;
//			xLog(hLog, XLL_INFO, "Searching for session without any attributes");
			break;
		}

		dwNumParameters = 1;
		// Length       = Param type    + Size of int param
		dwParametersLen = GetBufferLenForInt();
		Parameter.dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
		Parameter.Value.qwValue = *((ULONGLONG *) &SessionID);

		// Create the search request with the appropriate parameter and result buffers
		pFollowUpSearch = new CXMatchSearchRequest(dwSearchProcedure, dwNumParameters, dwParametersLen, DEFAULT_RESULTS_LENGTH);
		if(!pFollowUpSearch)
		{
			xLog(hLog, XLL_WARN, "Not enough memory to allocate new search request");
			return NULL;
		}
		
		pFollowUpSearch->SetAsyncID(GetTickCount());

//		xLog(hLog, XLL_INFO, "Creating follow-up search 0x%08x from 0x%08x", dwPreviousAsyncID, pFollowUpSearch->GetAsyncID());

		// Add the parameter if necessary
		if(dwNumParameters)
		{
			if(!pFollowUpSearch->AddParameters(&Parameter, dwNumParameters))
			{
				xLog(hLog, XLL_WARN, "Couldn't add parameters to search request");
				delete pFollowUpSearch;
				return NULL;
			}
		}
		
		pFollowUpSearch->SetRequestCategory(nFinalRequestCategory);
		if(FAILED(pFollowUpSearch->StartRequest()))
		{
			xLog(hLog, XLL_WARN, "Couldn't start request");
			delete pFollowUpSearch;
			return NULL;
		}
		pRequest = pFollowUpSearch;
		break;
		
		break;
	}
	
	return pRequest;
}

//==================================================================================
// StartNewXmatchRequest
//----------------------------------------------------------------------------------
//
// Description: Creates a new Xmatch request and returns a pointer to it
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	A pointer to the created Xmatch request or NULL if one couldn't be created
//==================================================================================
CXOnlineAsyncRequest *StartNewXmatchRequest(HANDLE hLog)
{
	CXOnlineAsyncRequest *pRequest = NULL;
	CXMatchSessionRequest *pNewSession = NULL;
	CXMatchSearchRequest *pNewSearch = NULL;
	DWORD dwNumAttributes = 0, dwAttributesLen = 0;
	ATTRIBUTE Attribute;
	DWORD dwSearchProcedure = 0, dwNumParameters = 0, dwParametersLen = 0;
	PARAMETER Parameter;
	XNKID SessionID;
	HRESULT hr = S_OK;

	// The DWORD category variables are used to receive random values and for branching
	// code execution to set up the proper type of test
	DWORD dwRequestCategory = 0, dwRequestSubCategory = 0;

	// The XMATCH_REQUEST_CATEGORY category variable is used to set the specific category type
	// in the CXOnlineAsyncRequest class member
	XMATCH_REQUEST_CATEGORY nFinalRequestCategory = INVALID_REQUEST_CATEGORY;

	dwRequestCategory = GenerateRandomNumber(2);  // Either 0 or 1

	switch(dwRequestCategory)
	{
	// --------------------------------------------
	// Create a session half of the time
	// --------------------------------------------
	case 0:
		dwRequestSubCategory = GenerateRandomNumber(4);
		switch(dwRequestSubCategory)
		{
		// --------------------------------------------
		// Create a session with an integer attribute
		case 0:
			dwNumAttributes = 1;
			// Length       = AttributeID   + Size of int att
			dwAttributesLen = GetBufferLenForInt();
			Attribute.dwAttributeID = GLOBALINT_ID1;
			Attribute.UserID = 0;
			Attribute.Value.qwValue = INT1;
			nFinalRequestCategory = CREATE_INTEGER_REQ;
//			xLog(hLog, XLL_INFO, "Started session creation with an int attribute");
			break;
		// --------------------------------------------
		// Create a session with a string attribute
		case 1:
			dwNumAttributes = 1;
			// Length       = AttributeID   + Len prefix   + Str len         + NULL terminator
			dwAttributesLen = GetBufferLenForString(STRING1);
			Attribute.dwAttributeID = GLOBALSTR_ID1;
			Attribute.UserID = 0;
			Attribute.Value.pvValue = STRING1;
			nFinalRequestCategory = CREATE_STRING_REQ;
//			xLog(hLog, XLL_INFO, "Started session creation with a string attribute");
			break;
		// --------------------------------------------
		// Create a session with a blob attribute
		case 2:
			dwNumAttributes = 1;
			// Length       = AttributeID   + Len prefix    + Blb len
			dwAttributesLen = GetBufferLenForBlob(BLOB1);
			Attribute.dwAttributeID = GLOBALBLB_ID1;
			Attribute.UserID = 0;
			Attribute.Value.pvValue = BLOB1;
			nFinalRequestCategory = CREATE_BLOB_REQ;
//			xLog(hLog, XLL_INFO, "Started session creation with a blob attribute");
			break;
		// --------------------------------------------
		// Create a session without any attributes
		default:
			dwNumAttributes = 0;
			dwAttributesLen = 0;
			nFinalRequestCategory = CREATE_NO_ATTRIB_REQ;
//			xLog(hLog, XLL_INFO, "Started session creation without attributes");
			break;
		}

		memset(&SessionID, 0, sizeof(XNKID));

		// Create the session request with the appropriate attribute buffers
		pNewSession = new CXMatchSessionRequest(SessionID, dwNumAttributes, dwAttributesLen);
		if(!pNewSession)
		{
			xLog(hLog, XLL_WARN, "Not enough memory to allocate new session request");
			return NULL;
		}

		pNewSession->SetAsyncID(GetTickCount());

//		xLog(hLog, XLL_INFO, "Creating session 0x%08x", pNewSession->GetAsyncID());

		// Add the attribute if necessary
		if(dwNumAttributes)
		{
			if(!pNewSession->AddAttributes(&Attribute, dwNumAttributes))
			{
				xLog(hLog, XLL_WARN, "Couldn't add attributes to session request");
				delete pNewSession;
				return NULL;
			}
		}

		pNewSession->SetRequestCategory(nFinalRequestCategory);
		if(FAILED(pNewSession->StartRequest()))
		{
			xLog(hLog, XLL_WARN, "Couldn't start request");
			delete pNewSession;
			return NULL;
		}
		pRequest = pNewSession;
		break;

	// --------------------------------------------
	// Create a search the other half of the time
	// --------------------------------------------
	default:
		dwRequestSubCategory = GenerateRandomNumber(4);
		switch(dwRequestSubCategory)
		{
		// --------------------------------------------
		// Create a search with an integer paramter
		case 0:
			dwSearchProcedure = INTPARAM_INDEX;
			dwNumParameters = 1;
			// Length       = Param type    + Size of int param
			dwParametersLen = GetBufferLenForInt();
			Parameter.dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
			Parameter.Value.qwValue = INT1;
			nFinalRequestCategory = SEARCH_INTEGER_REQ;
//			xLog(hLog, XLL_INFO, "Started session search with an integer parameter");
			break;
		// --------------------------------------------
		// Create a search with a string paramter
		case 1:
			dwSearchProcedure = STRINGPARAM_INDEX;
			dwNumParameters = 1;
			// Length       = Param type    + Len prefix   + Str len         + NULL terminator
			dwParametersLen = GetBufferLenForString(STRING1);
			Parameter.dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
			Parameter.Value.pvValue = STRING1;
			nFinalRequestCategory = SEARCH_STRING_REQ;
//			xLog(hLog, XLL_INFO, "Started session search with a string parameter");
			break;
		// --------------------------------------------
		// Create a search with a blob paramter
		case 2:
			dwSearchProcedure = STRINGPARAM_INDEX;
			dwNumParameters = 1;
			// Length       = Param type    + Len prefix    + Blb len
			dwParametersLen = GetBufferLenForBlob(BLOB1);
			Parameter.dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
			Parameter.Value.pvValue = BLOB1;
			nFinalRequestCategory = SEARCH_BLOB_REQ;
//			xLog(hLog, XLL_INFO, "Started session search with a blob parameter");
			break;
		// --------------------------------------------
		// Create a search without any paramters
		default:
			dwSearchProcedure = NOPARAM_INDEX;
			dwNumParameters = 0;
			dwParametersLen = 0;
			nFinalRequestCategory = SEARCH_NO_PARAM_REQ;
//			xLog(hLog, XLL_INFO, "Started session search without any parameters");
			break;
		}

		// Create the search request with the appropriate parameter and result buffers
		pNewSearch = new CXMatchSearchRequest(dwSearchProcedure, dwNumParameters, dwParametersLen, DEFAULT_RESULTS_LENGTH);
		if(!pNewSearch)
		{
			xLog(hLog, XLL_WARN, "Not enough memory to allocate new search request");
			return NULL;
		}
		
		pNewSearch->SetAsyncID(GetTickCount());

//		xLog(hLog, XLL_INFO, "Creating search 0x%08x", pNewSearch->GetAsyncID());

		// Add the parameter if necessary
		if(dwNumParameters)
		{
			if(!pNewSearch->AddParameters(&Parameter, dwNumParameters))
			{
				xLog(hLog, XLL_WARN, "Couldn't add parameters to search request");
				delete pNewSearch;
				return NULL;
			}
		}
		
		pNewSearch->SetRequestCategory(nFinalRequestCategory);
		if(FAILED(pNewSearch->StartRequest()))
		{
			xLog(hLog, XLL_WARN, "Couldn't start request");
			delete pNewSearch;
			return NULL;
		}
		pRequest = pNewSearch;		
		break;
	}
	
	return pRequest;
}

//==================================================================================
// XMatchStressMain
//----------------------------------------------------------------------------------
//
// Description: Function that implements main stress functionality
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID XMatchStressMain(IN HANDLE hLog, DWORD dwTimeToRun)
{
	CXOnlineAsyncRequest *AsyncRequestArray[MAX_SIMULTANEOUS_REQUESTS];
	HRESULT hr = NULL;
	HANDLE AsyncWorkEventArray[MAX_SIMULTANEOUS_REQUESTS];
	DWORD dwRequestsOutstanding = 0, dwWaitResult = 0, dwStartTime = 0, dwElapsedTime = 0, dwRequestBeingProcessed = 0;
	
	// Set up all the initial requests
	while(dwRequestsOutstanding < MAX_SIMULTANEOUS_REQUESTS)
	{
		if(!(AsyncRequestArray[dwRequestsOutstanding] = StartNewXmatchRequest(hLog)))
		{
			goto CloseOutstandingRequests;
		}
		
		AsyncWorkEventArray[dwRequestsOutstanding] = AsyncRequestArray[dwRequestsOutstanding]->GetWorkEvent();
		++dwRequestsOutstanding;
	}
	
	// Start keeping track of elapsed time
	dwStartTime = GetTickCount();
	dwElapsedTime = 0;
	
	// Wait for work events to signal
	dwWaitResult = WaitForMultipleObjects(dwRequestsOutstanding, AsyncWorkEventArray, FALSE, dwTimeToRun);

	while((dwWaitResult >= WAIT_OBJECT_0) &&
		(dwWaitResult <= WAIT_OBJECT_0 + dwRequestsOutstanding) &&
		(dwElapsedTime < dwTimeToRun))
	{
		dwRequestBeingProcessed = dwWaitResult - WAIT_OBJECT_0;
		
		// If this request has completed, then shift down the rest of the requests in the array
		// and create a new request
		hr = AsyncRequestArray[dwRequestBeingProcessed]->DoWork(0);

		if(FAILED(hr))
		{
			// If pending, then the item isn't complete yet
			if(hr != E_PENDING)
			{
				xLog(hLog, XLL_INFO, "DoWork failed with 0x%08x", hr);
			}
		}
		else
		{
			XMATCH_REQUEST_CATEGORY nRequestCategory = INVALID_REQUEST_CATEGORY;
			XNKID SessionID;
			DWORD dwRemainingRequests = MAX_SIMULTANEOUS_REQUESTS - dwRequestBeingProcessed - 1, dwFollowUp = 0;
			DWORD dwPreviousAsyncID = 0;

			memset(&SessionID, 0, sizeof(XNKID));

			// In order to do follow up requsts, we need to get the session ID if it exists
			// for this type of request
			nRequestCategory = (XMATCH_REQUEST_CATEGORY) AsyncRequestArray[dwRequestBeingProcessed]->GetRequestCategory();
			switch(nRequestCategory)
			{
			case CREATE_NO_ATTRIB_REQ:
			case CREATE_INTEGER_REQ:
			case CREATE_STRING_REQ:
			case CREATE_BLOB_REQ:
				((CXMatchSessionRequest *) AsyncRequestArray[dwRequestBeingProcessed])->GetSessionID(&SessionID);
				break;
			default:
				break;
			}
			
			dwPreviousAsyncID = AsyncRequestArray[dwRequestBeingProcessed]->GetAsyncID();

			// Close the old request
			hr = AsyncRequestArray[dwRequestBeingProcessed]->Close();
			if(FAILED(hr))
			{
				xLog(hLog, XLL_WARN, "Close failed with 0x%08x", hr);
				// BUGBUG - handle a failure in a Close call
			}

			delete AsyncRequestArray[dwRequestBeingProcessed];
			
			--dwRequestsOutstanding;
			
			// Shuffle the remaining requests in the list down to occupy the vacant space
			ShuffleRemainingArrayItems(AsyncRequestArray + dwRequestBeingProcessed, dwRemainingRequests);
			ShuffleRemainingArrayItems(AsyncWorkEventArray + dwRequestBeingProcessed, dwRemainingRequests);
			
			// Create a new request which can either be a follow up request to the previous one
			// or can be a completely new request
			
			// Determine if new request or a follow up
			dwFollowUp = GenerateRandomNumber(2);  // Either 0 or 1
			
			// If we decided not to do a follow up request or we don't have a session ID to
			// make a follow up request with, then start a new request
			if(!dwFollowUp || *((ULONGLONG *) &SessionID))
			{
				if(!(AsyncRequestArray[MAX_SIMULTANEOUS_REQUESTS - 1] = StartNewXmatchRequest(hLog)))
				{
					goto CloseOutstandingRequests;
				}
			}
			// Otherwise, we must have decided to make a follow up request and we must have a vaild
			// session ID to make a follow up request with
			else
			{
				if(!(AsyncRequestArray[MAX_SIMULTANEOUS_REQUESTS - 1] =
					StartFollowUpXmatchRequest(hLog, nRequestCategory, SessionID, dwPreviousAsyncID)))
				{
					goto CloseOutstandingRequests;
				}
			}
			
			AsyncWorkEventArray[MAX_SIMULTANEOUS_REQUESTS - 1] = AsyncRequestArray[dwRequestsOutstanding]->GetWorkEvent();
			++dwRequestsOutstanding;
			
			// BUGBUG - Randomly cancel events			
		}

		// Determine the ammount of time that has elapsed
		dwElapsedTime = GetElapsedTime(dwStartTime, GetTickCount());
		if(dwElapsedTime > dwTimeToRun)
			break;
		
		// Wait for work events to signal
		dwWaitResult = WaitForMultipleObjects(dwRequestsOutstanding, AsyncWorkEventArray, FALSE, dwTimeToRun - dwElapsedTime);
	}

CloseOutstandingRequests:

	while(dwRequestsOutstanding > 0)
	{
		--dwRequestsOutstanding;

		// Cancel the task
		hr = AsyncRequestArray[dwRequestsOutstanding]->Cancel();
		if(FAILED(hr))
		{
			xLog(hLog, XLL_WARN, "Couldn't cancel outstanding request");
			AsyncRequestArray[dwRequestsOutstanding]->Close();
			continue;
		}

		// Poll until the task is complete
		while(AsyncRequestArray[dwRequestsOutstanding]->GetCurrentState() != STATE_COMPLETE)
		{
			hr = AsyncRequestArray[dwRequestsOutstanding]->DoWork(0);
			if(FAILED(hr))
			{
				// BUGBUG - Handle errors from DoWork, E_PENDING is acceptable
			}
		}

		// Close the task
		hr = AsyncRequestArray[dwRequestsOutstanding]->Close();
		if(FAILED(hr))
		{
			xLog(hLog, XLL_WARN, "Couldn't close outstanding request");
			continue;
		}

		delete AsyncRequestArray[dwRequestsOutstanding];

		AsyncRequestArray[dwRequestsOutstanding] = NULL;
		AsyncWorkEventArray[dwRequestsOutstanding] = NULL;
	}

}



//==================================================================================
// XMatchStressStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI XMatchStressStartTest(IN HANDLE  hLog)
{
	HRESULT hr = S_OK;
	HANDLE hPingObject = NULL, hEnumObject = NULL, hClientObject = NULL;
	INT nRet = 0, i;

	XONLINE_SERVICE ServicesArray[NUM_SERVICES] =
	{
		{ XONLINE_MATCHMAKING_SERVICE, S_OK, NULL }
	};

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Online(S)", "Matching - Client (S-o)");
	xSetFunctionName(g_hLog, "<none>");

	hr = XOnlineLogonWrapper(hLog, ServicesArray, NUM_SERVICES);
    if (FAILED(hr))
	{
		xLog(g_hLog, XLL_FAIL, "Failed to initialize services");
		return;
	}

	XMatchStressMain(hLog, 1800000000);

	g_hLog = INVALID_HANDLE_VALUE;
}            

//==================================================================================
// XMatchStressEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI XMatchStressEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

} // namespace XMatchStressNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xmstress )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( xmstress )
    EXPORT_TABLE_ENTRY( "StartTest", XMatchStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XMatchStressEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XMatchStressDllMain )
END_EXPORT_TABLE( xmstress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\connection.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONNECTION_H_
#define __CONNECTION_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#define DEFAULTBUFFERSIZE 1024
#define DEFAULTBUFFERS 1

struct WSAOVERLAPPEDEX: public WSAOVERLAPPED {
	bool fPending;
};//endstruct

class BaseConnection{
	
public:

	//Constructor - This form is for establishing a new connection
	BaseConnection(HANDLE hShutdownEvent=NULL, UINT uicWriteBuffers=DEFAULTBUFFERS, INT icWriteBufferSize=DEFAULTBUFFERSIZE, INT icReadBufferSize=-1);

	//Destructor
	~BaseConnection();

	//Wait for all overlapped async buffers to be in non-pending state
	HRESULT WaitForAllPendingBuffersToFlush(DWORD dwTimeout);

protected:

	//Send data down connection
	HRESULT SendTo(const char* rgchBuf, int iLen, BOOL fFlush=TRUE, DWORD dwTimeout=WSA_INFINITE, const struct sockaddr FAR *lpTo=NULL, int iToLen=0);

	//Receive data off the connection
	HRESULT ReceiveFrom(char* rgchBuf, DWORD dwLen, DWORD* pdwLen, DWORD dwTimeout=WSA_INFINITE, struct sockaddr FAR *lpFrom=NULL, int* piFromLen=0);

	//Reset overlapped buffers
	HRESULT BaseConnection::ResetBuffers();

	//Flush buffers to wire
	HRESULT SendToFlush(const struct sockaddr FAR *lpTo=NULL, int iToLen=0);

protected:

	SOCKET m_s; //Overlapped socket
	HANDLE m_hShutdownEvent;  //Shutdown event
	INT m_icReadBufferSize;  //Internal buffer read size

private:

	WSAEVENT m_rghEvents[2]; //Can hold one overlapped event and a shutdown event
	UINT m_uicEvents; //Number of WSA wait event (depends if shutdownevent was provided)

	UINT m_uicWriteBuffers; //Number of write buffers
	INT m_icWriteBufferSize; //Max size of a write buffer
	WSABUF* m_rgWriteBuffer; //Array of WSABUFs
	WSAOVERLAPPEDEX* m_rgWriteOverlapped; //Array of overlapped events
	UINT m_uiWriteIndex; //Current write buffer to write to
};

/////////////////////////////////////////////////////////////////////////////
// Network Connection Wrapper Class
//
// Construct any class with the optional hShutdownEvent parameter so that you 
// can cancel ANY outstanding network operation.  These class methods will
// block until each operation is complete OR the hShutdownEvent has is thrown.
// All blocking methods perform smart sleep states until network action can
// be completed or the hShutdownEvent is thrown.
/////////////////////////////////////////////////////////////////////////////

class TCPClientConnection:public BaseConnection{
	
public:

	//Constructor - This form is for establishing a new connection
	TCPClientConnection(HANDLE hShutdownEvent=NULL, UINT uicWriteBuffers=DEFAULTBUFFERS, INT icWriteBufferSize=DEFAULTBUFFERSIZE, INT icReadBufferSize=0);

	//Destructor
	~TCPClientConnection();

	//Establish connection
	HRESULT Connect(DWORD dwIP, WORD wPortD, DWORD dwTimeout=WSA_INFINITE);

	//Wait for socket disconnect or timeout
	bool WaitForDisconnect(int iTimeout);

	//Close connection
	HRESULT Close(bool fHard=false);
	//Send data down connection

	//Send data down connection
	HRESULT Send(const char* rgchBuf, int iLen, BOOL fFlush=TRUE, DWORD dwTimeout=WSA_INFINITE){
		return SendTo(rgchBuf,iLen,fFlush,dwTimeout);
	}//endmethod

	//Receive data off the connection
	HRESULT Receive(char* rgchBuf, DWORD dwLen, DWORD* pdwLen, DWORD dwTimeout=WSA_INFINITE){
		return ReceiveFrom(rgchBuf,dwLen,pdwLen,dwTimeout);
	}//endmethod

private:

	WSAEVENT m_hCloseEvent; //Close event

};//endclass

/////////////////////////////////////////////////////////////////////////////
// UDPConnection - UDP based connection wrapper class used to send or receive
// data.  Use Bind() method only for establishing a port bind for 
// ReceiveFrom().
/////////////////////////////////////////////////////////////////////////////

class UDPConnection:public BaseConnection{

public:

	//Constructor - use INADDR_ANY for receiving any source on specified port
	UDPConnection(HANDLE hShutdownEvent=NULL, UINT uicWriteBuffers=DEFAULTBUFFERS, INT icWriteBufferSize=DEFAULTBUFFERSIZE, INT icReadBufferSize=0);

	//Destructor
	~UDPConnection();

	//Bind socket to port
	HRESULT Bind(WORD wPort);

	//Send data down connection
	HRESULT SendTo(const char* rgchBuf, int iLen, BOOL fFlush=TRUE, DWORD dwTimeout=WSA_INFINITE, const struct sockaddr FAR *lpTo=NULL, int iToLen=0){
		return BaseConnection::SendTo(rgchBuf,iLen,fFlush,dwTimeout,lpTo,iToLen);
	}//endmethod

	//Receive data off the connection
	HRESULT ReceiveFrom(char* rgchBuf, DWORD dwLen, DWORD* pdwLen, DWORD dwTimeout=WSA_INFINITE, struct sockaddr FAR *lpFrom=NULL, int* piFromLen=0){
		return BaseConnection::ReceiveFrom(rgchBuf,dwLen,pdwLen,dwTimeout,lpFrom,piFromLen);
	}//endmethod

};//endclass

/////////////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////////////////////////////////////////

// InternetAddress - Helper function converting names or ips to DWORD
DWORD InternetAddress(const char* pszHost);

// WinsockUP - Helper function to bring up winsock layer
HRESULT WinsockUP();

// WinsockDOWN - Helper function to bring down winsock layer
HRESULT WinsockDOWN();
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\connection\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	connection.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\threadpool\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	threadpool.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\connection\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__76E58C5B_F85B_4C1D_8661_7BC701958809__INCLUDED_)
#define AFX_STDAFX_H__76E58C5B_F85B_4C1D_8661_7BC701958809__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
#include <winsock2.h>
#endif // !defined(AFX_STDAFX_H__76E58C5B_F85B_4C1D_8661_7BC701958809__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\threadpool.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __THREADPOOL_H_
#define __THREADPOOL_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

typedef DWORD (WINAPI *PTHREAD_SMART_ROUTINE)(LPVOID lpThreadParameter,HANDLE hShutdownEvent);
typedef PTHREAD_SMART_ROUTINE LPTHREAD_SMART_ROUTINE;

enum enumEvents{EVENTS_TRIGGER=0,EVENTS_SHUTDOWN,EVENTS_FINISHED,EVENTS_ENDENUM};

/////////////////////////////////////////////////////////////////////////////
// WorkerThreadPool - Generic thread pool class that can be used to
// distribute work across multiple worker threads.  Construct the object with
// the number of threads that you want and the static worker function that
// you have define. Your static worker function must conform to the
// LPTHREAD_SMART_ROUTINE function type.  Then call DoWork when ever you have
// work that needs to be processed.  As defined by the LPTHREAD_SMART_ROUTINE
// function type, the parameters you pass to your static worker function are
// of type LPVOID.  Since the parameters are of type LPVOID it is the
// responsiblity of this object to delete that data when finished.  So, make
// sure that the parameter you pass can be deleted via delete [] pData.  It
// is suggested that pData be a pointer to a class with an appriopriate
// destructor defined.  If a work function takes time be sure to check the
// hShutdownEvent or use it in combination with any WaitForObject processing.
/////////////////////////////////////////////////////////////////////////////

class WorkerThreadPool{

	public:
		//Constructor
		WorkerThreadPool(unsigned int cThreads, LPTHREAD_SMART_ROUTINE pWorkerFunc, HANDLE hShutdownEvent=NULL);
		//Destructor
		~WorkerThreadPool();
		//Perform work
		HRESULT DoWork(LPVOID);
		//Is class initialized
		bool IsInit(){return m_fInit;}
		//Obtain access to the shutdown event
		HANDLE GetShutdownEvent(){return m_hShutdown;}

	private:
		//Structure used to pass events and parameters to worker thread
		struct ThreadParam{LPTHREAD_SMART_ROUTINE pFunc;LPVOID pData;HANDLE rgEvents[EVENTS_ENDENUM];};

	private: 
		bool m_fInit;  //Instance successfully initialized
		unsigned int m_cThreads;  //Number of worker threads
		HANDLE* m_rghThreads;  //Array of worker threads
		ThreadParam* m_rgThreadParams;  //Array of thread parameters and events
		HANDLE* m_rghFinishedEvents;  //Duplicate finished event array for WaitForMultipleObjects
		HANDLE m_hShutdown;  //Shutdown event
		bool m_fOwnShutdownEvent;  //Was the shutdown event passed in or do we own it?

	private:
		//Internal worker thread function that wraps user function
		static DWORD WINAPI WorkerThread(LPVOID);
		//Initialization routine
		unsigned int Init(unsigned int cThreads, LPTHREAD_SMART_ROUTINE pWorkerFunc, HANDLE hShutdownEvent);

};//endclass

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\connection\connection.cpp ===
///////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"  //Precompiled header
#include "../connection.h"  //Local
#include <crtdbg.h>  //Debugging

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////

BaseConnection::BaseConnection(HANDLE hShutdownEvent/*=NULL*/, UINT uicWriteBuffers/*=DEFAULTBUFFERS*/, INT icWriteBufferSize/*=DEFAULTBUFFERSIZE*/, INT icReadBufferSize/*=-1*/):
m_hShutdownEvent(hShutdownEvent),
m_uicEvents(1),
m_rgWriteBuffer(NULL),
m_rgWriteOverlapped(NULL),
m_uicWriteBuffers(uicWriteBuffers),
m_icWriteBufferSize(icWriteBufferSize),
m_uiWriteIndex(0),
m_icReadBufferSize(icReadBufferSize),
m_s(INVALID_SOCKET)
{
	//Create array of buffers
	m_rgWriteBuffer=new WSABUF[m_uicWriteBuffers];
	_ASSERT(NULL!=m_rgWriteBuffer);

	//Create array of overlapped objects
	m_rgWriteOverlapped=new WSAOVERLAPPEDEX[m_uicWriteBuffers];
	_ASSERT(NULL!=m_rgWriteOverlapped);

	//Populate array of buffers and initialize overlapped objects
	for (UINT ui=0; ui<m_uicWriteBuffers; ui++){

		//Populate array of buffers
		m_rgWriteBuffer[ui].buf=NULL;
		m_rgWriteBuffer[ui].buf=new CHAR[m_icWriteBufferSize];
		m_rgWriteBuffer[ui].len=0;
		_ASSERT(NULL!=m_rgWriteBuffer[ui].buf);

		//Initialize array of overlapped objects
		m_rgWriteOverlapped[ui].hEvent=NULL;
		m_rgWriteOverlapped[ui].hEvent=WSACreateEvent();
		_ASSERT(NULL!=m_rgWriteOverlapped[ui].hEvent);
		m_rgWriteOverlapped[ui].fPending=false;

	}//endfor 

	if (NULL!=m_hShutdownEvent){
		m_uicEvents=2;
		m_rghEvents[1]=m_hShutdownEvent;
	}//endif

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////

BaseConnection::~BaseConnection(){

	//Cleanup array of buffers and overlapped objects
	for (UINT ui=0; ui<m_uicWriteBuffers; ui++){

		//Cleanup array of buffers
		if (NULL!=m_rgWriteBuffer[ui].buf){
			delete [] m_rgWriteBuffer[ui].buf;
			m_rgWriteBuffer[ui].buf=NULL;
		}//endif

		//Cleanup array of overlapped objects
		if (NULL!=m_rgWriteOverlapped[ui].hEvent){
			WSACloseEvent(m_rgWriteOverlapped[ui].hEvent);
			m_rgWriteOverlapped[ui].hEvent=NULL;
		}//endif
	}//endfor

	//Deallocate array of overlapped objects
	if (NULL!=m_rgWriteOverlapped){
		delete [] m_rgWriteOverlapped;
		m_rgWriteOverlapped=NULL;
	}//endif 

	//Deallocate array of buffers
	if (NULL!=m_rgWriteBuffer){
		delete [] m_rgWriteBuffer;
		m_rgWriteBuffer=NULL;
	}//endif

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// ResetBuffers - Reset overlapped buffers
/////////////////////////////////////////////////////////////////////////////

HRESULT BaseConnection::ResetBuffers(){

	//Reset any existing buffers
	for (UINT ui=0; ui<m_uicWriteBuffers; ui++){
		m_rgWriteBuffer[ui].len=0;
		m_rgWriteOverlapped[ui].fPending=false;
		WSAResetEvent(m_rgWriteOverlapped[ui].hEvent);
	}//endfor
	m_uiWriteIndex=0;

	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// SendToFlush - Throw overlapped buffer to winsock
/////////////////////////////////////////////////////////////////////////////

HRESULT BaseConnection::SendToFlush(const struct sockaddr FAR *lpTo/*=NULL*/, int iToLen/*=0*/){

	//Check if connection is established
	if (INVALID_SOCKET==m_s){
		return E_FAIL;
	}//endif

	//Initialize number of bytes sent
	DWORD dwBytesSent=0L;

	//Reset overlapped object's wsa event
	WSAResetEvent(m_rgWriteOverlapped[m_uiWriteIndex].hEvent);

	//Send data
	if (0!=WSASendTo(m_s,&m_rgWriteBuffer[m_uiWriteIndex],1,&dwBytesSent,0,lpTo,iToLen,&m_rgWriteOverlapped[m_uiWriteIndex],NULL)){

		//Pending?
		if (WSA_IO_PENDING!=WSAGetLastError()){
			return E_FAIL;	
		}//endif

		//Mark buffer as submitted
		m_rgWriteOverlapped[m_uiWriteIndex].fPending=true;

		//Set new current buffer
		if (++m_uiWriteIndex>=m_uicWriteBuffers){
			m_uiWriteIndex=0;
		}//endif

	}else{

		//All data sent?
		if (dwBytesSent!=m_rgWriteBuffer[m_uiWriteIndex].len){

			//Should have gone to WSA_IO_PENDING!
			return E_FAIL;

		}//endif

		//Data was sent; set buffer offset back to 0
		m_rgWriteBuffer[m_uiWriteIndex].len=0;

	}//endif

	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// SendToFlush - Send to buffer memory
/////////////////////////////////////////////////////////////////////////////

HRESULT BaseConnection::SendTo(const char* rgchBuf, int iLen, BOOL fFlush/*=TRUE*/, DWORD dwTimeout/*=WSA_INFINITE*/, const struct sockaddr FAR *lpTo/*=NULL*/, int iToLen/*=0*/){

	//Check parameters
	if ((NULL==rgchBuf)||(iLen<=0)||(iLen>m_icWriteBufferSize)){
		return E_INVALIDARG;
	}//endif

	while (TRUE){

		//Was buffer pending?
		if (true==m_rgWriteOverlapped[m_uiWriteIndex].fPending){

			//Populate event array
			m_rghEvents[0]=m_rgWriteOverlapped[m_uiWriteIndex].hEvent;

			//Wait for buffer to unlock or for shutdown event to fire
			DWORD dwErr=WSAWaitForMultipleEvents(m_uicEvents,m_rghEvents,false,dwTimeout,false);
			if ((WSA_WAIT_FAILED==dwErr)||(WSA_WAIT_TIMEOUT==dwErr)||(WSA_WAIT_EVENT_0+1==dwErr)){
				return E_FAIL;
			}//endif

			//Reuse the buffer and set the offset back to 0; data was sent
			m_rgWriteOverlapped[m_uiWriteIndex].fPending=false;
			m_rgWriteBuffer[m_uiWriteIndex].len=0;

		}//endif

		//Can we write to this buffer or do we need to flush/and or get new buffer?
		if ((INT)m_rgWriteBuffer[m_uiWriteIndex].len+iLen>m_icWriteBufferSize){
			if FAILED(SendToFlush(lpTo,iToLen)){
				return E_FAIL;
			}//endif
			continue;  //check buffer now
		}//endif

		//Copy data to memory buffer
		memcpy(m_rgWriteBuffer[m_uiWriteIndex].buf+m_rgWriteBuffer[m_uiWriteIndex].len,rgchBuf,iLen);
		m_rgWriteBuffer[m_uiWriteIndex].len+=iLen;

		//Force a flush? (time critical)
		if (TRUE==fFlush){
			if FAILED(SendToFlush(lpTo,iToLen)){
				return E_FAIL;
			}//endif
		}//endif

		break;  //success

	}//endwhile

	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Receive - Receives data on an open socket
/////////////////////////////////////////////////////////////////////////////

HRESULT BaseConnection::ReceiveFrom(char* rgchBuf, DWORD dwLen, DWORD* pdwLen, DWORD dwTimeout/*=WSA_INFINITE*/,struct sockaddr FAR *lpFrom/*=NULL*/, int* piFromLen/*=0*/){

	//Check parameters
	if ((NULL==rgchBuf)||(dwLen<0)||(NULL==pdwLen)){
		return E_INVALIDARG;  //Invalid parameters
	}//endif

	//check if connection is established
	if (INVALID_SOCKET==m_s){
		return E_FAIL;
	}//endif

	//wrap w/ wsa buffer
	WSABUF Buffer;
	Buffer.buf=(char*)rgchBuf;
	Buffer.len=dwLen;

	//create io completion event
	WSAOVERLAPPED overlapped;
	overlapped.hEvent=WSACreateEvent();
	if (NULL==overlapped.hEvent){
		return E_FAIL;
	}//endif

	//populate event array
	UINT uicEvents=1;
	WSAEVENT rghEvents[2];
	rghEvents[0]=overlapped.hEvent;
	if (NULL!=m_hShutdownEvent){
		uicEvents=2;
		rghEvents[1]=m_hShutdownEvent;
	}//endif

	HRESULT hr=S_OK;
	DWORD dwFlags=0L;

	*pdwLen=0;

	//receive data
	if (0!=WSARecvFrom(m_s,&Buffer,1,pdwLen,&dwFlags,lpFrom,piFromLen,&overlapped,NULL)){

		//blocks
		if (WSA_IO_PENDING==WSAGetLastError()){
				
			//wait for completion event or shutdown
			DWORD dwErr=WSAWaitForMultipleEvents(uicEvents,rghEvents,false,dwTimeout,false);
			if ((WSA_WAIT_FAILED==dwErr)||(1==dwErr)||(WSA_WAIT_TIMEOUT==dwErr)){
				hr=E_FAIL;
			}//endif

			//success?
			if SUCCEEDED(hr){

				//get bytes received
				DWORD dwFlags=0L;
				if (FALSE==WSAGetOverlappedResult(m_s,&overlapped,pdwLen,FALSE,&dwFlags)){
					hr=E_FAIL;
				}//endif

			}//endif

		}else{

			//other error
			hr=E_FAIL;

		}//endif

	}//endif

	//close event
	if (FALSE==WSACloseEvent(overlapped.hEvent)){
		hr=E_FAIL;
	}//endif

	return hr;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT BaseConnection::WaitForAllPendingBuffersToFlush(DWORD dwTimeout){

	//Initiate buffer flush
	if FAILED(SendToFlush()){
		return E_FAIL;
	}//endif

	//Allocate event array
	HANDLE* rghEvents=NULL;
	rghEvents=new HANDLE[m_uicWriteBuffers];
	_ASSERT(NULL!=rghEvents);
	if (NULL==rghEvents){
		return E_FAIL;
	}//endif

	UINT uicEvents=0;
	BOOL fTimeout=FALSE;

	//Count the number of pending buffers
	for (UINT ui=0; ui<m_uicWriteBuffers; ui++){
		if (true==m_rgWriteOverlapped[ui].fPending){
			rghEvents[uicEvents++]=m_rgWriteOverlapped[ui].hEvent;
		}//endif
	}//endfor

	//If we have pending buffers wait for them
	if (uicEvents>0){
		if (WSA_WAIT_TIMEOUT==WSAWaitForMultipleEvents(uicEvents,rghEvents,TRUE,dwTimeout,FALSE)){
			fTimeout=TRUE;
		}//endif
	}//endif

	//Deallocate event array
	if (NULL!=rghEvents){
		delete [] rghEvents;
		rghEvents=NULL;
	}//endif

	//Did we timeout?
	if (TRUE==fTimeout){
		return E_FAIL;
	}//endif

	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Constructor 
/////////////////////////////////////////////////////////////////////////////

TCPClientConnection::TCPClientConnection(HANDLE hShutdownEvent/*=NULL*/, UINT uicWriteBuffers/*=DEFAULTBUFFERS*/, INT icWriteBufferSize/*=DEFAULTBUFFERSIZE*/, INT icReadBufferSize/*=-1*/):
BaseConnection(hShutdownEvent,uicWriteBuffers,icWriteBufferSize,icReadBufferSize){

	//create close event
	m_hCloseEvent=WSACreateEvent();

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////

TCPClientConnection::~TCPClientConnection(){

	//Close socket
	Close();

	//close event
	WSACloseEvent(m_hCloseEvent);

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Connect - Establishes a connection on an out bound socket
/////////////////////////////////////////////////////////////////////////////

HRESULT TCPClientConnection::Connect(DWORD dwIP, WORD wPort, DWORD dwTimeout/*=WSA_INFINITE*/){

	//already connected?
	if (INVALID_SOCKET!=m_s){
		return E_FAIL;
	}//endif

	//create socket
	m_s = WSASocket(AF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED);
	if (INVALID_SOCKET==m_s){
		return E_FAIL;
	}//endif

	//Set the send buffer size to 0; forcing our local buffers to be used preventing any bad-performance copy
	int iBufferSize=0;
	if (0!=setsockopt(m_s,SOL_SOCKET,SO_SNDBUF,(char*)&iBufferSize,sizeof(iBufferSize))){
		return E_FAIL;
	}//endif

	//If user has requested a different receive buffer size, set it
	if (-1!=m_icReadBufferSize){
		iBufferSize=m_icReadBufferSize;
		if (0!=setsockopt(m_s,SOL_SOCKET,SO_RCVBUF,(char*)&iBufferSize,sizeof(iBufferSize))){
			return E_FAIL;
		}//endif
	}//endif 

	//create address
	SOCKADDR_IN sin;
	sin.sin_family = AF_INET;
	sin.sin_port = htons(wPort);
	sin.sin_addr.s_addr = dwIP;

	//create event array
	WSAEVENT rghEvents[2];
	rghEvents[0]=WSACreateEvent();
	if (NULL==rghEvents[0]){
		return E_FAIL;
	}//endif

	//populate event array
	UINT uicEvents=1;
	if (NULL!=m_hShutdownEvent){
		uicEvents=2;
		rghEvents[1]=m_hShutdownEvent;
	}//endif

	//register for network event
	if (SOCKET_ERROR==WSAEventSelect(m_s,rghEvents[0],FD_CONNECT)){
		return E_FAIL;
	}//endif

	//connect
	HRESULT hr=S_OK;
	if (SOCKET_ERROR==WSAConnect(m_s,(const SOCKADDR*) &sin, sizeof(sin),NULL,NULL,NULL,NULL)){

		//blocks
		if (WSAEWOULDBLOCK==WSAGetLastError()){

			//wait for network event or shutdown
			DWORD dwErr=WSAWaitForMultipleEvents(uicEvents,rghEvents,false,dwTimeout,false);
			if ((WSA_WAIT_FAILED==dwErr)||(1==dwErr)||(WSA_WAIT_TIMEOUT==dwErr)){
				hr=E_FAIL;
			}//endif

			//success?
			if SUCCEEDED(hr){

				//get network event
				WSANETWORKEVENTS NetworkEvents;
				if (SOCKET_ERROR==WSAEnumNetworkEvents(m_s,rghEvents[0],&NetworkEvents)){
					hr=E_FAIL;
				}//endif

				//success?
				if SUCCEEDED(hr){

					//check network event error code
					if ((((NetworkEvents.lNetworkEvents&FD_CONNECT)==FD_CONNECT)) && (NetworkEvents.iErrorCode[FD_CONNECT_BIT]!=0))
					{
						hr=E_FAIL;
					}//endif

				}//endif

			}//endif

		}else{

			//error other than blocking occurred
			hr=E_FAIL;

		}//endif

	}//endif

	//unregister for network event
	if (SOCKET_ERROR==WSAEventSelect(m_s,rghEvents[0],0)){
		hr=E_FAIL;
	}//endif

	//close event
	if (FALSE==WSACloseEvent(rghEvents[0])){
		hr=E_FAIL;
	}//endif

	//register for socket close event
	WSAResetEvent(m_hCloseEvent);
	if (SOCKET_ERROR==WSAEventSelect(m_s,m_hCloseEvent,FD_CLOSE)){
		hr=E_FAIL;
	}//endif

	//Reset buffers
	if (FAILED(ResetBuffers())){
		hr=E_FAIL;
	}//endif

	return hr;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// WaitForDisconnect - wait for socket disconnect
/////////////////////////////////////////////////////////////////////////////

bool TCPClientConnection::WaitForDisconnect(int iTimeout){

	//create event array
	UINT uicEvents=1;
	WSAEVENT l_rgEvents[2];	
	l_rgEvents[0]=m_hCloseEvent;
	if (NULL!=m_hShutdownEvent){
		uicEvents=2;
		l_rgEvents[1]=m_hShutdownEvent;
	}//endif

	//wait for event or timeout
	DWORD dwErr=WSAWaitForMultipleEvents(uicEvents,l_rgEvents,false,iTimeout,false);
	if ((WSA_WAIT_TIMEOUT!=dwErr)||(1==dwErr)){
		Close();
	}//endif
	
	//if connection is gone set retval to false
	if (INVALID_SOCKET==m_s){
		return false;
	}//endif

	return true;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Close - Closes an established connection
/////////////////////////////////////////////////////////////////////////////

HRESULT TCPClientConnection::Close(bool fHard/*=false*/){

	//Socket closed?
	if (INVALID_SOCKET==m_s){
		return S_FALSE;  //Already closed
	}//endif

	if (true==fHard){
		//Hard disconnect!
		LINGER linger;
		linger.l_onoff=1;
		linger.l_linger=0;
		setsockopt(m_s,SOL_SOCKET,SO_LINGER,(const char *)&linger,sizeof(linger));
	}else{
		bool f=true;
		setsockopt(m_s,SOL_SOCKET,SO_DONTLINGER,(const char *)&f,sizeof(f));
		SendToFlush();
	}//endif

	//Close socket
	closesocket(m_s);

	//Set internal state
	m_s=INVALID_SOCKET;

	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////

UDPConnection::UDPConnection(HANDLE hShutdownEvent/*=NULL*/, UINT uicWriteBuffers/*=DEFAULTBUFFERS*/, INT icWriteBufferSize/*=DEFAULTBUFFERSIZE*/, INT icReadBufferSize/*=-1*/):
BaseConnection(hShutdownEvent,uicWriteBuffers,icWriteBufferSize,icReadBufferSize)
{
	//Socket setup
	m_s = socket(AF_INET, SOCK_DGRAM, 0);
	if (INVALID_SOCKET == m_s){
		_ASSERT(INVALID_SOCKET!=m_s);
		return;
	}//endif

	//Set the send buffer size to 0; forcing our local buffers to be used preventing any bad-performance copy
	INT iBufferSize=0;
	if (0!=setsockopt(m_s,SOL_SOCKET,SO_SNDBUF,(char*)&iBufferSize,sizeof(iBufferSize))){
		_ASSERT(0);
		return;
	}//endif

	//If user has requested a different receive buffer size, set it
	if (-1==m_icReadBufferSize){
		iBufferSize=m_icReadBufferSize;
		if (0!=setsockopt(m_s,SOL_SOCKET,SO_RCVBUF,(char*)&iBufferSize,sizeof(iBufferSize))){
			_ASSERT(0);
			return;
		}//endif
	}//endif 

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////

UDPConnection::~UDPConnection(){

	//Hard disconnect!
	LINGER linger;
	linger.l_onoff=1;
	linger.l_linger=0;
	setsockopt(m_s,SOL_SOCKET,SO_LINGER,(const char *)&linger,sizeof(linger));
	closesocket(m_s);

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Bind - Bind socket to port
/////////////////////////////////////////////////////////////////////////////

HRESULT UDPConnection::Bind(WORD wPort){

	//Socket address
	SOCKADDR_IN sin;
	sin.sin_family = AF_INET;
	sin.sin_port = htons(wPort);
	sin.sin_addr.s_addr = INADDR_ANY;

	//Bind socket
	if (SOCKET_ERROR==bind(m_s,(struct sockaddr *)&sin,sizeof(sin))){
		return E_FAIL;  //Unable to bind socket
	}//endif
	
	//Success
	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// InternetAddress - Helper function converting names or ips to DWORD
/////////////////////////////////////////////////////////////////////////////

DWORD InternetAddress(const char* pszHost){

	DWORD dwIP=INADDR_NONE;

	//Get IP address
	dwIP = ::inet_addr(pszHost);
	if (dwIP==INADDR_NONE){
		HOSTENT* pHostEnt= ::gethostbyname(pszHost);
		if (NULL!=pHostEnt){
			dwIP = *((LPDWORD) pHostEnt->h_addr);
		}//endif
	}//endif

	return dwIP;  //Return IP address

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// WinsockUP - Helper function to bring up winsock layer
/////////////////////////////////////////////////////////////////////////////

HRESULT WinsockUP(){
	
	WORD wVersionRequested;  //Version of winsock to request
	WSADATA wsaData;  //Version of winsock the system supports
	int err;  //WSAStartup return value
 
	//Sets version
	wVersionRequested=MAKEWORD( 2, 2 );
 
	//WSAStartup
	err=WSAStartup(wVersionRequested, &wsaData);
	if (err!=0){
		return E_FAIL;  //Unable to start winsock
	}//endif
  
	//Check version
	if (LOBYTE(wsaData.wVersion)!=2 ||
		HIBYTE(wsaData.wVersion)!=2){
		WSACleanup();
		return E_FAIL;  //Wrong version of winsock 
	}//endif

	//Success
	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// WinsockDOWN - Helper function to bring down winsock layer
/////////////////////////////////////////////////////////////////////////////

HRESULT WinsockDOWN(){
	
	int err;  //WSACleanup return value

	//WSACleanup
	err=WSACleanup();
	if (err!=0){
		return E_FAIL;  //Unable to bring down winsock
	}//endif

	//Success
	return S_OK;

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\threadpool\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__263169A0_2415_407A_9AC7_F176D6E5CFF2__INCLUDED_)
#define AFX_STDAFX_H__263169A0_2415_407A_9AC7_F176D6E5CFF2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__263169A0_2415_407A_9AC7_F176D6E5CFF2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\common\threadpool\threadpool.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"  //Precompiled header
#include "../threadpool.h"  //Local

/////////////////////////////////////////////////////////////////////////////
// Constructor - Initializes member variables and call initialization
// procedure.
/////////////////////////////////////////////////////////////////////////////

WorkerThreadPool::WorkerThreadPool(unsigned int cThreads, LPTHREAD_SMART_ROUTINE pWorkerFunc, HANDLE hShutdownEvent/*=NULL*/):
m_fInit(false),
m_cThreads(0),
m_rghThreads(NULL),
m_rgThreadParams(NULL),
m_rghFinishedEvents(NULL),
m_hShutdown(hShutdownEvent){
	Init(cThreads, pWorkerFunc, hShutdownEvent);
}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Destructor - signals shutdown event then waits on all threads finished
// events before closing all handles and freeing allocated memory for member
// variables.
/////////////////////////////////////////////////////////////////////////////

WorkerThreadPool::~WorkerThreadPool(){

	//If we are not initialized, no need to cleanup
	if (!m_fInit)
		return;

	//Signal shutdown
	SetEvent(m_hShutdown);

	//Make sure that both events have been thrown, this signifies proper shutdown, not just being "finished"
	for (unsigned int i=0; i<m_cThreads; i++)
		if ((WAIT_TIMEOUT==WaitForSingleObject(m_rgThreadParams[i].rgEvents[EVENTS_FINISHED],1000))||
			(WAIT_TIMEOUT==WaitForSingleObject(m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER],1000)))
			if (NULL!=m_rghThreads[i])
				TerminateThread(m_rghThreads[i],-1);

	//Close thread handles and free thread list
	if (NULL!=m_rghThreads){
		for (unsigned int i=0; i<m_cThreads; i++)
			CloseHandle(m_rghThreads[i]);
		delete [] m_rghThreads;
	}//endif

	//Close trigger and shutdown events, delete thread data and then free parameter structure list
	if (NULL!=m_rgThreadParams){
		for (unsigned int i=0; i<m_cThreads; i++){
			if (NULL!=m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER])
				CloseHandle(m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER]);
			if (NULL!=m_rgThreadParams[i].rgEvents[EVENTS_FINISHED])
				CloseHandle(m_rgThreadParams[i].rgEvents[EVENTS_FINISHED]);
			if (NULL!=m_rgThreadParams[i].pData)
				delete [] m_rgThreadParams[i].pData;
		}//endfor
		delete [] m_rgThreadParams;
	}//endif

	//Free finished events list, no need to close handles since that was done in the parameter structure list; this is a copy
	if (NULL!=m_rghFinishedEvents){
		delete [] m_rghFinishedEvents;
	}//endif

	//Close shutdown event
	if (true==m_fOwnShutdownEvent){
		CloseHandle(m_hShutdown);
	}//endif

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Init - Store how many threads we have, create all events and event lists, 
// and start all threads.
/////////////////////////////////////////////////////////////////////////////

unsigned int WorkerThreadPool::Init(unsigned int cThreads, LPTHREAD_SMART_ROUTINE pWorkerFunc, HANDLE hShutdownEvent){
	
	//Check parameters or whether we have been initialized before somehow
	if ((true==m_fInit) || (NULL==pWorkerFunc) || (0==cThreads))
		return m_cThreads;  //return number of worker threads

	DWORD dwID=0;  //Temp variable for thread ID

	//Store number of threads
	m_cThreads=cThreads;

	//Allocate memory for lists
	m_rghThreads=new HANDLE[m_cThreads];
	m_rgThreadParams=new ThreadParam[m_cThreads];
	m_rghFinishedEvents=new HANDLE[m_cThreads];

	//Create shutdown event
	if (NULL!=m_hShutdown){
		m_fOwnShutdownEvent=false;
	}else{
		m_fOwnShutdownEvent=true;
		m_hShutdown=CreateEvent(NULL,true,false,NULL);
	}//endif

	//Populate lists and start threads
	for (unsigned int i=0; i<m_cThreads; i++){
		m_rgThreadParams[i].rgEvents[EVENTS_FINISHED]=m_rghFinishedEvents[i]=CreateEvent(NULL,true,true,NULL);
		m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER]=CreateEvent(NULL,true,false,NULL);
		m_rgThreadParams[i].rgEvents[EVENTS_SHUTDOWN]=m_hShutdown;
		m_rgThreadParams[i].pFunc=pWorkerFunc;
		m_rgThreadParams[i].pData=NULL;
		m_rghThreads[i]=CreateThread(NULL,0,&WorkerThread,(LPVOID)&m_rgThreadParams[i],0, &dwID);
	}//endfor
	
	//We have successfully initialized	
	m_fInit=true;

	return m_cThreads; //Return number of threads

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// WorkerThread - The worker thread which wraps the user worker function.
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI WorkerThreadPool::WorkerThread(LPVOID pParam){

	//If parameter pointer is NULL then shutdown
	if (NULL==pParam)
		ExitThread(E_FAIL);

	//Cast back the parameters
	HANDLE* rgEvents; 
	rgEvents=((ThreadParam*)pParam)->rgEvents;

	DWORD dwReturn=0; //temp return value from worker function
	DWORD dwObject=0; //signaled object
	while (true){
		//Wait to be triggered or shutdown
		dwObject=WaitForMultipleObjects(2,&rgEvents[0],false,INFINITE);
		if (EVENTS_SHUTDOWN==(dwObject-WAIT_OBJECT_0))
			break;
		//Reset the trigger
		ResetEvent(rgEvents[EVENTS_TRIGGER]);
		//Do work
		dwReturn=((ThreadParam*)pParam)->pFunc(((ThreadParam*)pParam)->pData,rgEvents[EVENTS_SHUTDOWN]);
		//Signal finished
		SetEvent(rgEvents[EVENTS_FINISHED]);
	}//endwhile

	//We are shutting down, trigger both events when done
	SetEvent(rgEvents[EVENTS_FINISHED]);
	SetEvent(rgEvents[EVENTS_TRIGGER]);

	ExitThread(S_OK);
	return S_OK;  //Success

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// DoWork - Assign work to one of the available threads in the thread pool.
// This operation blocks until the task has been assigned to an available 
// thread.  If no thread is available, the task blocks until one is.
/////////////////////////////////////////////////////////////////////////////

HRESULT WorkerThreadPool::DoWork(LPVOID pData){

	//Check if we have been initialized
	if (!m_fInit){
		return E_FAIL;  //Not initialized
	}//endif

	//Wait for any thread to become available
	DWORD dwRet=0;
	unsigned int dIndex=0;
	dwRet=WaitForMultipleObjects(m_cThreads,m_rghFinishedEvents,false,INFINITE);
	dIndex=dwRet-WAIT_OBJECT_0;

	//Shutdown time
	if (WAIT_OBJECT_0==WaitForSingleObject(m_hShutdown,0))
		return S_FALSE;

	//Reset the finished event on this thread so we know when it is done
	ResetEvent(m_rghFinishedEvents[dIndex]);

	//Delete previous data used by this thread
	if (NULL!=m_rgThreadParams[dIndex].pData){
		delete [] m_rgThreadParams[dIndex].pData;
		m_rgThreadParams[dIndex].pData=NULL;
	}//enidf

	//Assign new data for thread to process
	m_rgThreadParams[dIndex].pData=pData;

	//Signal thread to start processing
	SetEvent(m_rgThreadParams[dIndex].rgEvents[EVENTS_TRIGGER]);

	return S_OK;  //Success

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\GeneInfo.cpp ===
//#include <xtl.h>
#include <stdio.h>
#include <xapip.h>
#include <winbasep.h>
#include <rc4.h>
#include <sha.h>
#include <xdbg.h>
#include <xboxp.h>
#include <XbDm.h>
#include "hardware.h"
#include <xapip.h>
#include "xboxvideo.h"
#include "constants.h"

#define BREAK_INTO_DEBUGGER     _asm { int 3 }

int   m_xKeypos;
int   m_yKeypos;
Key   m_keyPad[DISPLAY_NUM_COLS][DISPLAY_NUM_ROWS];           // Keypad
CONST PCHAR SZDATAFILE = "t:\\Genealogy.log";
bool g_bLoop = TRUE;
CXBoxVideo g_x;
WCHAR g_szSerialNumber[120]= L"\0";
INT   g_iSerialNumberIndex = 1;


void GenerateKeypad(void);
HRESULT DrawScreen( void );
HRESULT WriteGenelogyLog( void );



void __cdecl main()
{
   //BREAK_INTO_DEBUGGER;
   g_x.Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
   
   
   do {
      DrawScreen();
      ProcessInput();
   } while ( g_bLoop == TRUE );
   g_x.DeInitialize();
   
   WriteGenelogyLog();

   // Reboot this baby!
   DmReboot(DMBOOT_WARM);
	return;
}



void GenerateKeypad(void) 
{
   // First create numberpad
   int xgrid  = 3;
   int ygrid  = 4;
   int xstart = 210;
   int ystart = KEYPAD_TOPROW_Y1; // 234;
   int width  = 32;
   int height = 32;
   int spacer = 2;

   int currentx = xstart;
   int currenty = ystart;

   for (int y = 0; y < ygrid; y++) {
      for (int x = 0; x < xgrid; x++) {
         m_keyPad[x][y].define( currentx, currenty, width, height, COLOR_YELLOW );
         currentx += width + spacer;
      }
      currentx = xstart;
      currenty += height + spacer;
   }


   // Second generate side larger buttons for OK CANCEL etc.
   int xbase  = xgrid;
   xgrid  = 1;
   ygrid  = 4;
   xstart = 323;
   ystart = KEYPAD_TOPROW_Y1; // 234;
   width  = 103;
   height = 32;
   spacer = 2;

   currentx = xstart;
   currenty = ystart;
   for (y = 0; y < ygrid; y++) {
      for (int x = xbase; x < (xbase + xgrid); x++) {
         m_keyPad[x][y].define( currentx, currenty, width, height, COLOR_LIME_GREEN );
         currentx += width + spacer;

         // clear out placeholder
         if (y == 1) m_keyPad[x][y].setRender(false);
         if (y == 2) m_keyPad[x][y].setRender(false);
         if (y == 3) m_keyPad[x][y].setRender(false);
      }
      currentx = xstart;
      currenty += height + spacer;
   }


   // Set the text of the keys
   m_keyPad[0][0].defineText(L"1");  m_keyPad[1][0].defineText(L"2");  m_keyPad[2][0].defineText(L"3");
   m_keyPad[0][1].defineText(L"4");  m_keyPad[1][1].defineText(L"5");  m_keyPad[2][1].defineText(L"6");
   m_keyPad[0][2].defineText(L"7");  m_keyPad[1][2].defineText(L"8");  m_keyPad[2][2].defineText(L"9");
   m_keyPad[0][3].defineText(L".");  m_keyPad[1][3].defineText(L"0");  m_keyPad[2][3].defineText(L"");
   m_keyPad[3][0].defineText(L"ok");
   m_keyPad[3][1].defineText(L"placeholder");
   m_keyPad[3][2].defineText(L"placeholder");
   m_keyPad[3][3].defineText(L"placeholder");
}


// Draw our screen

HRESULT DrawScreen( void )
{

   
   g_x.ClearScreen( SCREEN_DEFAULT_BACKGROUND_COLOR );
   
   // draw the number we are building on screen
   g_x.DrawText( 150, 
                 70, 
                 SCREEN_DEFAULT_TEXT_FG_COLOR, 
                 COLOR_LIME_GREEN, 
                 L"Enter the serial number please");
   g_x.DrawText( 170, 
                 100, 
                 SCREEN_DEFAULT_TEXT_FG_COLOR, 
                 COLOR_WHITE, 
                 L"%s", g_szSerialNumber);


   // Render outlines of keys	
   float x1, x2;
   float y1, y2;
   GenerateKeypad();
   for (int x = 0; x < KEYPAD_NUM_ROWS; x++) {
      for (int y = 0; y < KEYPAD_NUM_COLS; y++) {
         if (m_keyPad[x][y].getRender()){
            
            x1 = (float)m_keyPad[x][y].xorigin;
            x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);

            y1 = (float)m_keyPad[x][y].yorigin;
            y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);

            g_x.DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );


            // hilight key if currently selected
            DWORD dwCharColor;
            if ((m_xKeypos == x) && (m_yKeypos == y)) {
               // Draw the selector box around the currently highlighted number
               g_x.DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );

               dwCharColor = ITEM_SELECTED_TEXT_COLOR;
            } else {
               dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
            }

            unsigned int decent;
            unsigned int fontHeight;
            g_x.GetFontSize( &fontHeight, &decent );

            float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - g_x.GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
            float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
            g_x.DrawText( textX, textY, dwCharColor, COLOR_WHITE, L"%s", m_keyPad[x][y].resultChar);

         }
      }
   }
   g_x.ShowScreen();
   return S_OK;
}

	

HRESULT WriteGenelogyLog( void )
{


	CHAR szBuffer[ 1024 ];
	CHAR szDiskModelNumber[ 60 ];
	CHAR szDiskSerialNumber[ 60 ];
   HANDLE h;
	DWORD dwNumberOfBytesWritten;
	DWORD dwNumberOfBytesToWrite;
   
   ZeroMemory(szDiskModelNumber,60);
   ZeroMemory(szDiskSerialNumber,60);
   
   h = CreateFile ( SZDATAFILE, 
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_WRITE,
					 NULL,
					 CREATE_ALWAYS,
					 FILE_ATTRIBUTE_NORMAL,
					 NULL);


	IntelCPUID CPUID;
   GetIntelCPUID( &CPUID);
   _snprintf( szDiskModelNumber, HalDiskModelNumber->Length, 
              "%s",
              HalDiskModelNumber->Buffer);

   _snprintf( szDiskSerialNumber, HalDiskSerialNumber->Length, 
              "%s",
              HalDiskSerialNumber->Buffer); 
  
   sprintf(szBuffer, // + strlen(szBuffer),
             "Model  %s\r\nSerial %s\r\nCpuId: %lu %lu %lu \r\nS/N: %S\r\n\0",
             szDiskModelNumber,
             szDiskSerialNumber,
             CPUID.high, CPUID.mid ,CPUID.low,
             g_szSerialNumber); 

   dwNumberOfBytesToWrite = strlen(szBuffer);
   WriteFile( h, 
              szBuffer,
              dwNumberOfBytesToWrite,
              &dwNumberOfBytesWritten, 
              NULL );
   CloseHandle(h);

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\Hardware.h ===
#ifndef _HARDWARE_H
#define _HARDWARE_H

//
// This structure holds the Intel CPU Serial Number
//
typedef struct _IntelCPUID
{
    DWORD low;
    DWORD mid;
    DWORD high;
} IntelCPUID;


void GetIntelCPUID( IntelCPUID* pCPUID );
HRESULT ProcessInput( void );

// Handle the Joystick Input
void 
HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, bool bFirstYPress, bool bFirstXPress );

// Handles input (of the CONTROLS) for the current menu
void 
HandleInput( enum CONTROLS controlPressed, 
             bool bFirstPress );

// Handles input (of the BUTTONS) for the current menu
void 
HandleInput( enum BUTTONS buttonPressed, 
             bool bFirstPress );



#endif  _HARDWARE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>

#define KEYPAD_NUM_ROWS    4
#define KEYPAD_NUM_COLS    4
#define DISPLAY_NUM_ROWS    4
#define DISPLAY_NUM_COLS    4

#define APP_TITLE_NAME_A                        "XShell"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Menubox constants
#define MENUBOX_MAINAREA_X1                     102.0f
#define MENUBOX_MAINAREA_Y1                     135.0f
#define MENUBOX_MAINAREA_X2                     536.0f
#define MENUBOX_MAINAREA_Y2                     367.0f

#define MENUBOX_TITLEBAR_TEXT_XPOS              127.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1 + 5.0f
#define MENUBOX_SELECTBAR_X2                    MENUBOX_MAINAREA_X2 - 5.0f

#define MENUBOX_TEXT_TOP_BORDER                   2.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 9.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 4.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER)
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

// Display Settings Menu constants
#define DISPSETMENU_VIDEOHEADER_YPOS            149.0f      // Also in dispset.mnu file -- must be identical

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FONT_ALIAS_LEVEL                        4

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR
#define SCREEN_DEFAULT_TRANS_COLOR              SCREEN_DEFAULT_BACKGROUND_COLOR

// Settings Menu contants - These should match the numbers in 'settings.mnu'
#define SETTINGSMENU_OPTIONHEADER_COLOR          COLOR_DARK_GREEN2 // COLOR_MEDIUM_GREEN
#define SETTINGSMENU_VIDSET_YPOS                 173.0f
#define SETTINGSMENU_VIDSET_TEXT                 L"Video :"
#define SETTINGSMENU_IPADDR_YPOS                 249.0f
#define SETTINGSMENU_IPADDR_TEXT                 L"IP address :"
#define SETTINGSMENU_SUBNET_YPOS                 277.0f
#define SETTINGSMENU_SUBNET_TEXT                 L"Subnet mask :"
#define SETTINGSMENU_GATEWY_YPOS                 305.0f
#define SETTINGSMENU_GATEWY_TEXT                 L"Gateway :"
#define SETTINGSMENU_MANAME_YPOS                 334.0f
#define SETTINGSMENU_MANAME_TEXT                 L"Machine name :"

static float g_fSettingsItemYPos[] = {
    SETTINGSMENU_VIDSET_YPOS,             // Item 0
    SETTINGSMENU_IPADDR_YPOS,             // Item 1
    SETTINGSMENU_SUBNET_YPOS,             // Item 2
    SETTINGSMENU_GATEWY_YPOS,             // Item 3
    SETTINGSMENU_MANAME_YPOS              // Item 4
};

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              MENUBOX_MAINAREA_Y2 + 20.0f // ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 40.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      18
#define MENU_LAUNCH_MACHINENAME_COLOR           SCREEN_DEFAULT_TEXT_FG_COLOR
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  114     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  126     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                114     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                361     // Bitmaps, use int

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_DARK_GREEN2
#define ITEM_SELECTED_HEADER_COLOR              COLOR_YELLOW
#define ITEM_SELECTED_VALUE_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_SELECTED_TEXT_COLOR                SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_XBELIST_FONT_HEIGHT                17
#define ITEM_FORMATMU_FONT_HEIGHT               17

// MU Format Dlg constants
#define MUFORMATDLG_SCREEN_DIM_VALUE            0x8F000000 // MMX way - 0x00707070
#define MUFORMATDLG_UNAVAIL_MU_COLOR            COLOR_DARK_GREEN2
#define MUFORMATDLG_AVAIL_MU_COLOR              SCREEN_DEFAULT_TEXT_FG_COLOR
#define MUFORMATDLG_SELECTED_MU_COLOR           ITEM_SELECTED_TEXT_COLOR
#define MUFORMATDLG_DELETE_MSG_YPOS             164.0f
#define MUFORMATDLG_DELETE_MSG                  L"All data will be erased from"
#define MUFORMATDLG_FORMATTING_MSG              L"Formatting..."
#define MUFORMATDLG_SUCCESS_MSG                 L"Format Successful!"
#define MUFORMATDLG_FAIL_MSG                    L"Format Failed!"
#define MUFORMATDLG_MSG_PAUSE                   1500

// Error Message Menu constants
#define ERRORMSGMENU_BUTTON1_TEXT               L"ok"
#define ERRORMSGMENU_MSG_FG_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ERRORMSGMENU_MSG_BG_COLOR               SCREEN_DEFAULT_TEXT_BG_COLOR
#define ERRORMSGMENU_MSG_YPOS                   189.0f

// Keypad and Keyboard location information
#define KEYBOARD_LINE_WIDTH                     1.0f
#define KEYPAD_LINE_WIDTH                       1.0f
#define KEYBOARD_TOPROW_Y1                      210
#define KEYPAD_TOPROW_Y1                        210
#define MENU_DISPSET_BUTTON_Y1                  186
#define MUFORMATDLG_BUTTON_Y1                   250
#define MUFORMATDLG_BUTTON_X1                   265
#define ERRORMSGMENU_BUTTON_Y1                  270
#define ERRORMSGMENU_BUTTON_X1                  265
#define KEYBOARD_MACHINENAMEHEADER_XPOS         153.0f                  // Must be identical to data in 'machine.mnu'
#define KEYBOARD_MACHINENAMEHEADER_YPOS         159.0f                  // Must be identical to data in 'machine.mnu'
#define KEYPAD_IPADDRHEADER_TEXT                L"IP address :"         // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_XPOS                191.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_YPOS                159.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'


// File path and location constants
#define FILE_EXECUTABLE_DEVICE_PATH_A           "\\Device\\Harddisk0\\Partition1"
#define FILE_EXECUTABLE_DRIVE_A                 "c:"
#define FILE_EXECUTABLE_PATH_A                  "\\devkit"
#define FILE_EXECUTABLE_DIRECTORY_A             FILE_EXECUTABLE_DRIVE_A FILE_EXECUTABLE_PATH_A
#define FILE_EXECUTABLE_ALIAS_A                 "e:"
#define FILE_EXECUTABLE_EXENSION_A              ".XBE"
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

#define FILE_DATA_SETTINGS_FILENAME_A           "c:\\devkit\\xbdm.ini"
#define FILE_DATA_SETTINGS_SECTION_NAME_A       "[xbdm]"
#define FILE_DATA_SETTINGS_IP_TOKEN_A           "staticip addr="
#define FILE_DATA_SETTINGS_SUBNET_TOKEN_A       "subnetmask addr="
#define FILE_DATA_SETTINGS_GATEWAY_TOKEN_A      "defgateway addr="
#define FILE_DATA_SETTINGS_MACHINENAME_TOKEN_A  "dbgname name="
#define FILE_SPLASHSCREEN_LOCATION_A            FILE_DATA_IMAGE_DIRECTORY_A "\\loading.bmp"

// Data value limits
#define DATAVALUE_IPADDRESS_LENGTH              15
#define DATAVALUE_MACHINENAME_LENGTH            20
#define DATAVALUE_DISPLAYSETTING_TEXT_LENGTH    20

// Screen Saver
#define SCREEN_SAVER_TIMEOUT                    600000  // 10 minutes, 1200000 <-- 20 minutes
#define SCREEN_SAVER_UPDATE_INTERVAL            30000   // 30 seconds
#define SCREEN_SAVER_IMAGE                      FILE_DATA_IMAGE_DIRECTORY_A "\\abutton.bmp"
#define SCREEN_SAVER_BACK_COLOR                 COLOR_BLACK

// Controller and XBox Port and Slot Information
#define NUM_XBOX_PORTS                          4
#define NUM_XBOX_MU_SLOTS                       8
#define NUM_DUKE_BUTTONS                        8
#define NUM_DUKE_CONTROLS                       8
#define NUM_DUKE_SLOTS                          2

// Display Settings
enum XBoxDisplaySettings
{
    DISPLAY_SETTING_NONE        = 0,
    DISPLAY_SETTING_MONITOR     = 1,
    DISPLAY_SETTING_NTSC_M      = 2,
    DISPLAY_SETTING_NTSC_J,
    DISPLAY_SETTING_PAL_M       = 4,
    DISPLAY_SETTING_PAL_A,              // PAL B, D, G, H, I
    DISPLAY_SETTING_PAL_N,
    DISPLAY_SETTING_PAL_NC,
    DISPLAY_SETTING_NTSC_M_COMP = 10,
    DISPLAY_SETTING_PAL_M_COMP  = 12
};

// Joystick and Button Dead Zone and Threshold info
#define JOYSTICK_DEAD_ZONE                      20000       // 0 - 32768
#define BUTTON_THRESHOLD                        50          // 0 - 255

enum DisplaySettings
{
    ENUM_DISPSET_TEXT_MONITOR = 0,
    ENUM_DISPSET_TEXT_NTSC_SV,
    ENUM_DISPSET_TEXT_NTSC_C,
    ENUM_DISPSET_TEXT_PAL_SV,
    ENUM_DISPSET_TEXT_PAL_C    
};

// Memory Unit BitMasks used for detection
static DWORD g_dwMUBitMask[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};

static WCHAR* g_wpszMUPortNames[] = {
    L"Controller 1 - Top Slot",
    L"Controller 1 - Bottom Slot",
    L"Controller 2 - Top Slot",
    L"Controller 2 - Bottom Slot",
    L"Controller 3 - Top Slot",
    L"Controller 3 - Bottom Slot",
    L"Controller 4 - Top Slot",
    L"Controller 4 - Bottom Slot"
};

// Display Settings
static WCHAR* g_wpszDISPLAYSETTINGS[] = {
    L"Monitor",
    L"NTSC (S-Video)",
    L"NTSC (Composite)",
    L"PAL (S-Video)",
    L"PAL (Composite)"
};

// XShell Menu Identifiers
enum XShellMenuIds
{
    ENUM_SHELLMENUID_LAUNCH = 0,
    ENUM_SHELLMENUID_SETTINGS,
    ENUM_SHELLMENUID_MEMORY,
    ENUM_SHELLMENUID_SETTINGS_MACHINENAME,
    ENUM_SHELLMENUID_SETTINGS_GATEWAY,
    ENUM_SHELLMENUID_SETTINGS_IPADDRESS,
    ENUM_SHELLMENUID_SETTINGS_DISPLAY
};

// XShell States (bit mask)
#define SHELLSTATE_NORMAL       0
#define SHELLSTATE_ERROR        1
#define SHELLSTATE_NOCONFIG     2

// XShell Errors
// This list should stay in sync with the "g_wpszERRORCODEMSG" list
#define ERRORCODE_NO_ERROR          0
#define ERRORCODE_INVALID_XBE       1
#define ERRORCODE_UNKNOWN_ERROR     2

// This list should stay in sync with the "ERRORCODE" defines
static WCHAR* g_wpszERRORCODEMSG[] = {
    L"No Error Has Occurred",
    L"An Error Occurred Loading an XBox Executable",
    L"An Unknown Error Has Occurred"
};

// Screen item locations
#define ITEM_MACHINENAME_DATA_X                 ( ( ( MENUBOX_SELECTBAR_X2 - MENUBOX_SELECTBAR_X1 ) / 2.0f ) + MENUBOX_SELECTBAR_X1 - 17.0F )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\Hardware.cpp ===
#include <stdio.h>
#include <xapip.h>
#include <winbasep.h>
#include <rc4.h>
#include <sha.h>
#include <xdbg.h>
#include <xboxp.h>
#include "Hardware.h"
#include "xboxvideo.h"
#include "usbmanager.h"
#include "constants.h"

USBManager Controllers;
extern Key m_keyPad[DISPLAY_NUM_COLS][DISPLAY_NUM_ROWS];
extern int m_xKeypos;
extern int m_yKeypos;
extern WCHAR g_szSerialNumber[120];
extern INT   g_iSerialNumberIndex;
extern bool g_bLoop;


bool m_bDropKeyPress;  
DWORD          m_keyPressDelayTimer;                // Used to temper the speed of holding down the d-pad
DWORD          m_keyPressDelayInterval;             // The current interval to delay before processing a keypress
int            m_nJoystickDeadZone;                 // The dead zone for the joysticks




void GetIntelCPUID( IntelCPUID* pCPUID )
{
    DWORD cpuid_low = 0;
    DWORD cpuid_mid = 0;
    DWORD cpuid_high = 0;

    _asm {
        mov eax, 1
        _asm cpuid
        //_asm _emit 0x0f   //CPUID instruction
        //_asm _emit 0xa2

        mov  cpuid_high, eax
        
        mov eax, 3
        _asm cpuid
        //_asm _emit 0x0f   //CPUID instruction
        //_asm _emit 0xa2

        mov  cpuid_mid, edx
        mov  cpuid_low, ecx
    }

    pCPUID->low = cpuid_low;
    pCPUID->mid = cpuid_mid;
    pCPUID->high = cpuid_high;
}



 // Handle input from the user
HRESULT ProcessInput( void )
{

   bool bButtonPressed;
   bool bFirstPress;
   bool bFirstXPress;
   bool bFirstYPress;
   int  nThumbY = 0;
   int  nThumbX = 0;

   // Update the state of all controllers
   Controllers.ProcessInput();

   // A BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_A, bFirstPress );
   }

   // B BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_B, bFirstPress );
   }

   // X BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_X, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_X, bFirstPress );
   }

   // Y BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_Y, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_Y, bFirstPress );
   }

   // BLACK BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_BLACK, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_BLACK, bFirstPress );
   }

   // WHITE BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_WHITE, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_WHITE, bFirstPress );
   }

   // LEFT TRIGGER BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_LEFT_TRIGGER, bFirstPress );
   }

   // UP DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_UP, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_UP, bFirstPress );
   }

   // DOWN DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_DOWN, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_DOWN, bFirstPress );
   }

   // LEFT DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_LEFT, bFirstPress );
   }

   // RIGHT DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_RIGHT, bFirstPress );
   }

   // LEFT THUMB STICK
   nThumbY = Controllers.GetJoystickY( PORT_ANY, JOYSTICK_LEFT, JOYSTICK_DEAD_ZONE, &bFirstYPress );
   nThumbX = Controllers.GetJoystickX( PORT_ANY, JOYSTICK_LEFT, JOYSTICK_DEAD_ZONE, &bFirstXPress );
   if ( ( nThumbY != 0 ) || ( nThumbX != 0 ) ) {
      HandleInput( JOYSTICK_LEFT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
   }

   // RIGHT THUMB STICK
   nThumbY = Controllers.GetJoystickY( PORT_ANY, JOYSTICK_RIGHT, JOYSTICK_DEAD_ZONE, &bFirstYPress );
   nThumbX = Controllers.GetJoystickX( PORT_ANY, JOYSTICK_RIGHT, JOYSTICK_DEAD_ZONE, &bFirstXPress );
   if ( ( nThumbY != 0 ) || ( nThumbX != 0 ) ) {
      HandleInput( JOYSTICK_RIGHT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
   }
   
   XDBGWRN( APP_TITLE_NAME_A, "Process Input Finished.");

   return S_OK;
}


// Handle the Joystick Input
void 
HandleInput( enum JOYSTICK joystick, 
             int  nThumbY, 
             int  nThumbX, 
             bool bFirstYPress, 
             bool bFirstXPress )
{
   switch ( joystick ) {
   // This is the LEFT Thumb Joystick on the controller
   case JOYSTICK_LEFT:
      {
         // Y
         if ( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) { // Move the left joystick down
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
         } else if ( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) {// Move left joystick up
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_UP, bFirstYPress );
         }

         // X
         if ( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) { // Move the left joystick left
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
         } else if ( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) {// Move the left joystick right
            HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
         }
         break;
      }
      // This is the RIGHT Thumb Joystick on the controller
   case JOYSTICK_RIGHT:
      {
         // Y
         if ( nThumbX < 0 ) { // Move the right joystick to the left
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );

         } else if ( nThumbX > 0 ) { // Move right joystick to the right
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_UP, bFirstYPress );
         }
         // X
         if ( nThumbX < 0 ) { // Move the right joystick left
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
         } else if ( nThumbX > 0 ) { // Move the right joystick right
            HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
         }
         break;
      }
   }
}


// Handles input (of the CONTROLS) for the current menu
void 
HandleInput( enum CONTROLS controlPressed, 
             bool bFirstPress )
{
   if ( bFirstPress ) {
      
      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
   
   } else { // Check to see if the repeat press is within our timer, otherwise bail
      
      // If the interval is too small, bail
      if ( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval ) {
         return;
      }
      
      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
   }


    // Handle Buttons being pressed
    switch( controlPressed )
    {
	case CONTROL_START:
		{
			break;
		}
	case CONTROL_BACK:
		{
			break;
		}
	case CONTROL_LEFT_THUMB:
		{
			break;
		}
	case CONTROL_RIGHT_THUMB:
		{
			break;
		}
    case CONTROL_DPAD_UP:
        {
			if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos--;
			}
			else if( ( m_yKeypos != 0 ) && ( !m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos = m_yKeypos - 2;
			}
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
         if ( ( m_yKeypos != 3 ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) ) {
            m_yKeypos++;
         } else if ( ( m_yKeypos != 3 ) && ( !m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) ) {
            m_yKeypos = m_yKeypos + 2;
         }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
			if( m_xKeypos != 0 )
			{
				m_xKeypos--;
			}
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
			if( ( m_xKeypos != 9 ) && ( m_keyPad[m_xKeypos + 1][m_yKeypos].getRender())) 
			{
				m_xKeypos++;
			}
			else if((m_xKeypos != 9) && (!m_keyPad[m_xKeypos + 1][m_yKeypos].getRender()))
			{
				m_xKeypos++;
				m_yKeypos--;
			}
            break;
        }
	}
}



// Handles input (of the BUTTONS) for the current menu
void 
HandleInput( enum BUTTONS buttonPressed, 
             bool bFirstPress )
{

   if ( bFirstPress ) {
      m_bDropKeyPress = false;

      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
   } else { // Check to see if the repeat press is within our timer, otherwise bail
      // If the interval is too small, bail
      if ( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval ) {
         return;
      }
      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
   }

   if ( m_bDropKeyPress ) {
      return;
   }

   // Handle Buttons being pressed
   g_iSerialNumberIndex = wcslen(g_szSerialNumber) - 1;
   
   switch ( buttonPressed ) {
   case BUTTON_A:
      {
         // Deal with keyboard input
         if (0 == wcscmp(m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"")) {            //backspace
            
            if (4 == g_iSerialNumberIndex ||
                8 == g_iSerialNumberIndex ||
                16 == g_iSerialNumberIndex ) {
               g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
            }
            g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
            XDBGTRC( APP_TITLE_NAME_A, "%s", g_szSerialNumber );
         
         } else if (0 == wcscmp(m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok")) {      //ok
            
            if (22 > g_iSerialNumberIndex) {
               break;
            }
            g_bLoop = FALSE;
            m_xKeypos = m_yKeypos = 0;
            XDBGTRC( APP_TITLE_NAME_A, "CKeyboardMenu::HandleInput():Ok Selected" );
         }else {
            if (4 == g_iSerialNumberIndex ||
                8 == g_iSerialNumberIndex ||
                16 == g_iSerialNumberIndex ) {
               wcscat(g_szSerialNumber, L"-");
            }
            if (21 >= g_iSerialNumberIndex )
               wcscat(g_szSerialNumber, m_keyPad[m_xKeypos][m_yKeypos].resultChar);
         }


         break;
      }
   case BUTTON_B:
      {
         //m_xKeypos = m_yKeypos = 0;
         // erase a character; backup
         if (5 == g_iSerialNumberIndex ||
             9 == g_iSerialNumberIndex ||
             17 == g_iSerialNumberIndex ) {
            g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
         }
         g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
         break;
      }
   case BUTTON_X:
      {
         break;
      }
   case BUTTON_Y:
      {
         break;
      }
   case BUTTON_BLACK:
      {
         break;
      }
   case BUTTON_WHITE:
      {
         break;
      }
   case BUTTON_LEFT_TRIGGER:
      {
         break;
      }
   case BUTTON_RIGHT_TRIGGER:
      {
         break;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\o\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define XFONT_TRUETYPE

#include <ntos.h>
#include <xapip.h>
#include <xtl.h>
#include <xfont.h>
#include <xdbg.h>
#include <stdio.h>

//#include "xboxvideo.h"
//#include "usbmanager.h"
//#include "xitem.h"
//#include "xsettings.h"
//#include "imagefile.h"
#include "constants.h"

// Menus and Commands

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define XFONT_TRUETYPE

#include <ntos.h>
#include <xapip.h>
#include <xtl.h>
#include <xfont.h>
#include <xdbg.h>
#include <stdio.h>

//#include "xboxvideo.h"
//#include "usbmanager.h"
//#include "xitem.h"
//#include "xsettings.h"
//#include "imagefile.h"
#include "constants.h"

// Menus and Commands

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device       = NULL;
    m_BackBuffer   = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth   = FONT_DEFAULT_WIDTH;
    m_FontHeight  = FONT_DEFAULT_HEIGHT;
    m_FontColor   = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth  = SCREEN_WIDTH;      // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
   if ( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) ) {
      
      XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
   
   }
}

// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void 
CXBoxVideo::DrawBitBlt( float fx, 
                        float fy, 
                        ULONG ulWidth, 
                        ULONG ulHeight, 
                        const DWORD* pData )
{
   // Check to make sure we received a valid pointer
   if ( !pData ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

      return;
   }

   // Draw the bitmap on the screen, pixel by pixel
   for ( ULONG y = 0; y < ulHeight; y++ ) {
      for ( ULONG x = 0; x < ulWidth; x++ ) {
         if ( 0 != pData[y * ulWidth + x] ) {
            DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
         }
      }
   }
}


// Draw a box on the screen
void 
CXBoxVideo::DrawBox( float x1, 
                     float y1, 
                     float x2, 
                     float y2, 
                     DWORD color )

{
   MYVERTEX* pb;
   float maxx, minx;
   float maxy, miny;

   CHECK( m_Device->BeginScene() );
   CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );

   if ( IsBadWritePtr( pb, 128 ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

      return;
   }

   if ( x1 < x2 ) {
      minx = x1;
      maxx = x2;
   } else {
      minx = x2;
      maxx = x1;
   }

   if ( y1 < y2 ) {
      miny = y1;
      maxy = y2;
   } else {
      miny = y2;
      maxy = y1;
   }

   if ( x1 == x2 ) {
      maxx++;
   }

   pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
   pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
   pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
   pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

   m_VertexBuffer->Unlock();
   m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
   m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }
    
    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{

    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
   if ( !m_Font ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
      return -1;
   }

   int i;                  // Return Value
   HRESULT hr;             // Return Value for XFONT
   va_list v;              // Argument List
   TCHAR wstr[256];        // Honkin Buffer
   DWORD currentFGColor;   // Current FG Color
   DWORD currentBGColor;   // Current FG Color

   // Set our FONT colors if the user wishes to
   if ( fgcolor || bgcolor ) {
      // Set the foreground color if the user wants to
      if ( fgcolor ) {
         XFONT_SetTextColor( fgcolor );
      }

      // Set the background color if the user wants to
      if ( bgcolor ) {
         XFONT_SetBkColor( bgcolor );
      }
   }

   va_start( v, format );
   i = wvsprintf( wstr, format, v );

   // Print the Text to the backbuffer
   hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );
   // If we have a valid font object, check the HRESULT
   if ( FAILED( hr ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
   }
   va_end( v );
   return i;
}


// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
   // Make sure we have loaded a font
   if ( !m_Font ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

      return;
   }

   // Verify the parameters that were passed in are corred
   if ( ( !pheight ) || ( !pdecent ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

      return;
   }
   XFONT_GetFontMetrics( pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
/*
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop
	}
}
*/
// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
   
   IDirect3D8* pD3D = NULL;
   m_ScreenWidth    = width;
   m_ScreenHeight   = height;

   if ( m_Device == NULL ) {

      // Create D3D 8.
      if ( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) {
         XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
         return;
      }

      // Set the screen mode.
      D3DPRESENT_PARAMETERS d3dpp;
      ZeroMemory( &d3dpp, sizeof( d3dpp ) );

      d3dpp.BackBufferWidth                 = width;
      d3dpp.BackBufferHeight                = height;
      d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
      d3dpp.BackBufferCount                 = 1;

      d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
      d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
      d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
      d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
      d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
      d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

      // Create the m_Device.
      if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                        D3DDEVTYPE_HAL,
                                        NULL,      // Ignored on Xbox
                                        D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                        &d3dpp,
                                        &m_Device ) ) ) {
         XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
         pD3D->Release();

         return;
      }

      // Now we no longer need the D3D interface so let's free it.
      pD3D->Release();
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
   }

   // Create our vertex buffer
   if ( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
   }

   // Set the stream source
   m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

   // Set our initial vertex shader that is compatible with our 2D scene
   if ( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
   }
   
   // Setup matricies
   // Setup our identity matrix
   D3DMATRIX mat;
   mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
   mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
   mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
   mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

   // World Matrix
   // The world matrix controls the position and orientation 
   // of the polygons in world space. We'll use it later to 
   // spin the triangle.
   D3DMATRIX WorldMatrix = mat;

   // Set the transforms for our 3D world
   if ( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
   }

   // View Matrix
   // The view matrix defines the position and orientation of 
   // the camera. Here, we are just moving it back along the z-
   // axis by 10 units.
   D3DMATRIX ViewMatrix = mat;
   ViewMatrix._43 = 10.0f;

   if ( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
   }

   // Projection Matrix
   // The projection matrix defines how the 3-D scene is "projected" 
   // onto the 2-D render target surface. 

   // Set up a very simple projection that scales x and y 
   // by 2, and translates z by -1.0.
   D3DXMATRIX ProjectionMatrix; //  = mat;
   D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

   if ( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
   }

   // Viewport
   D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

   D3DViewport.X      = 0;
   D3DViewport.Y      = 0;
   D3DViewport.Width  = width;  // rect.right - rect.left;
   D3DViewport.Height = height; // rect.bottom - rect.top;
   D3DViewport.MinZ   = 0.0f;
   D3DViewport.MaxZ   = 1.0f;

   // Set our Viewport
   if ( FAILED( m_Device->SetViewport( &D3DViewport ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
   }

   // This is the loaded font... wallyho
   XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );


   if ( m_Font ) {
      if ( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) ) {
         XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
      }

      XFONT_SelectFont( m_Font );
      XFONT_SetDrawingSurface( m_BackBuffer );
      XFONT_SetTextColor( SCREEN_DEFAULT_TEXT_FG_COLOR );
      XFONT_SetBkColor( SCREEN_DEFAULT_TEXT_BG_COLOR );
      XFONT_SetTextHeight( FONT_DEFAULT_HEIGHT );
      XFONT_SetTextAntialiasLevel( FONT_ALIAS_LEVEL );
      XFONT_SetTextStyle( FONT_DEFAULT_STYLE );
   }
}


// Set a D3D Transform
HRESULT 
CXBoxVideo::BeginScene( VOID )
{
    
   return m_Device->BeginScene();

};

HRESULT 
CXBoxVideo::EndScene( VOID )
{
    
   return m_Device->EndScene();

};



// Set a D3D Transform
HRESULT 
CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, 
                          CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};


// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
   if ( m_Device ) {
      m_Device->Present( NULL, NULL, NULL, NULL );
   }
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
   if ( ( !pString ) || ( 0 > ( x2 - x1 ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

      return E_INVALIDARG;
   }

   float maxLen = x2 - x1;

   // If the string is to long, let's knock off characters
   while ( GetStringPixelWidth( pString, -1 ) >= maxLen ) {
      pString[wcslen( pString ) - 1] = L'\0';

      // Ensure we don't end up in an endless loop
      if ( L'\0' == pString[0] ) {
         break;
      }
   }

   return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
   if ( ( !pString ) || ( 0 > ( x2 - x1 ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

      return E_INVALIDARG;
   }

   float maxLen = x2 - x1;

   // If the string is to long, let's knock off characters
   while ( GetStringPixelWidth( pString, -1 ) >= maxLen ) {
      pString[strlen( pString ) - 1] = '\0';

      // Ensure we don't end up in an endless loop
      if ( '\0' == pString[0] ) {
         break;
      }
   }

   return S_OK;
}




// Key Class by Victor Blanco
Key::Key()
{
   xorigin = 0;
   yorigin = 0;
   width = 0;
   height = 0;     
   selectColor =  COLOR_WHITE;//0x00000000;
   render = true;
   resultChar = NULL;
}

Key::~Key()
{
   if ( resultChar ) {
      delete[] resultChar;
      resultChar = NULL;
   }
}

void Key::define(int x, int y, int w, int h, DWORD color)
{
   xorigin = x;
   yorigin = y;
   width = w;
   height = h;     
   selectColor = color;    
}

void Key::defineText(WCHAR* result)
{
   int length = wcslen(result);
   resultChar = new WCHAR[length + 1];
   wcscpy(resultChar, result);
}

void Key::setRender(bool value) {
   render = value;
}

bool Key::getRender(void) {
   return render;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    01-13-2000  Modified   JNH

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "stdafx.h"
#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
   DWORD insertions, insertions2;
   unsigned i, j;
   unsigned port, slot;

   //Initialize core peripheral port support
   XInitDevices(0,NULL);

   pollingParameters.fAutoPoll = 1;
   pollingParameters.fInterruptOut = 0;
   pollingParameters.ReservedMBZ1 = 0;
   pollingParameters.bInputInterval = 8;  
   pollingParameters.bOutputInterval = 8;
   pollingParameters.ReservedMBZ2 = 0;

   // make sure the usb schema has not changed on us
   // ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());
   if ( ARRAYSIZE( XIDMasks ) != XGetPortCount() ) {
      XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager():XIDMasks != XGetPortCount!" );
      XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager():Will break in to debugger in 60 seconds..." );

      Sleep( 60000 );
      BREAK_INTO_DEBUGGER;
   }

   // initialize
   for (i=0; i<XGetPortCount(); i++) {
      for (j=0; j<SLOT_MAX; j++) {
         devices[i][j] = NULL;
         packetNum[i][j] = 1234;
      }
   }

   // look for game pads
   insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
   for (i=0; i<XGetPortCount(); i++) {
      port = i%XGetPortCount();
      if (insertions & XIDMasks[i]) {
         devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
      }
   }
}


USBManager::~USBManager()
{
   unsigned i, j;

   for (i=0; i<XGetPortCount(); i++) {
      for (j=0; j<SLOT_MAX; j++) {
         if (devices[i][j] != NULL) {
            if ( XDEVICE_TYPE_GAMEPAD == devices[i][j]->type ) {
               delete (DeviceDuke*)devices[i][j];
            }

            devices[i][j] = NULL;
         }
      }
   }
}


void USBManager::CheckForHotplugs( void )
{
   DWORD addDuke, removeDuke;
   unsigned slot, port;
   unsigned i, j;

   // check for game controllers (insert & removal)
   XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

   for ( i=0; i < XGetPortCount(); i++ ) {
      port = i % XGetPortCount();

      if ( removeDuke & XIDMasks[i] ) {
         delete (DeviceDuke*)devices[i][0];
         devices[i][0] = NULL;
      }

      if ( addDuke & XIDMasks[i] ) {
         devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );
      }
   }
}

bool USBManager::IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress /*=NULL*/)
{
   // Make sure we have a duke at the current location, otherwise return false
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return false;
      }
   }

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke at the current port, skip over it
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         if ( m_ControllerState.bControlPressed[locPort][control] ) {
            // If the user gave us a valid address let's return
            // whether or not it's the first press of the item
            if ( bFirstPress) {
               // If the previous X value was also greater than the deadZone, return
               // false for bFirstPress
               if ( m_PrevControllerState.bControlPressed[locPort][control] ) {
                  *bFirstPress = false;
               } else { // This must be the first press
                  *bFirstPress = true;
               }
            }

            // Return the value of the control
            // This is always true
            return m_ControllerState.bControlPressed[locPort][control];
         }
      }
   } else { // Only check one port
      if ( m_ControllerState.bControlPressed[port][control] ) {
         // If the user gave us a valid address let's return
         // whether or not it's the first press of the item
         if ( bFirstPress) {
            // If the previous X value was also greater than the deadZone, return
            // false for bFirstPress
            if ( m_PrevControllerState.bControlPressed[port][control] ) {
               *bFirstPress = false;
            } else { // This must be the first press
               *bFirstPress = true;
            }
         }

         // Return the value of the control
         // This is always true
         return m_ControllerState.bControlPressed[port][control];
      }
   }

   // If the button wasn't pressed, let's return false
   return false;
}


// Will return true if any button or thumbstick has changed since last poll
bool USBManager::MovementDetected( int port, int deadZone /*=0*/ )
{
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return false;
      }
   }

   XINPUT_STATE state;
   memset( &state, 0, sizeof( XINPUT_STATE ) );

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x ) {
         if ( devices[x][0] == NULL ) {
            continue;
         }

         // Get the state of the current controller
         XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

         // Check the buttons
         for ( unsigned button = 0; button < BUTTON_MAX; ++button ) {
            if ( IsButtonPressed( x, (enum BUTTONS)button, TRUE_ON_REPEAT ) ) {
               return true;
            }
         }

         // Check the controls
         for ( unsigned control = 0; control < CONTROL_MAX; ++control ) {
            if ( IsControlPressed( x, (enum CONTROLS)control, TRUE_ON_REPEAT ) ) {
               return true;
            }
         }

         // Check the Joysticks
         for ( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick ) {
            if ( 0 != GetJoystickX( x, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
               return true;
            }

            if ( 0 != GetJoystickY( x, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
               return true;
            }
         }
      }
   } else { // Only one port
      // Get the state of the current controller
      XInputGetState( ( (DeviceDuke*)devices[port][0])->duke, &state);

      // Check the buttons
      for ( unsigned button = 0; button < BUTTON_MAX; ++button) {
         if ( IsButtonPressed( port, (enum BUTTONS)button, TRUE_ON_REPEAT ) ) {
            return true;
         }
      }

      // Check the controls
      for ( unsigned control = 0; control < CONTROL_MAX; ++control) {
         if ( IsControlPressed( port, (enum CONTROLS)control, TRUE_ON_REPEAT ) ) {
            return true;
         }
      }

      // Check the Joysticks
      for ( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick ) {
         if ( 0 != GetJoystickX( port, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
            return true;
         }

         if ( 0 != GetJoystickY( port, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
            return true;
         }
      }
   }

   return false;
}


// Will return the X value of the joystick passed in
int USBManager::GetJoystickX( int port, enum JOYSTICK joystick, int deadZone /*=0*/, bool* bFirstPress /*=NULL*/ )
{
   // Make sure we have a duke at the current location, otherwise return 0
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return 0;
      }
   }

   int nReturnVal = 0;

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke in this port, skip to the next port
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         // If the current stick is moved, process the request and return the value!
         if ( abs( m_ControllerState.sThumbX[locPort][joystick] ) > deadZone ) {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if ( bFirstPress) {
               // If the previous Y value was also greater than the deadZone, return
               // false for bFirstPress
               if ( abs( m_PrevControllerState.sThumbX[locPort][joystick] ) > deadZone ) {
                  *bFirstPress = false;
               } else { // This must be the first press
                  *bFirstPress = true;
               }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbX[locPort][joystick];
         }
      }
   } else {    // Check one port only
      // If the current stick is moved, process the request and return the value!
      if ( abs( m_ControllerState.sThumbX[port][joystick] ) > deadZone ) {
         // Determine if the user wishes to know if this is the first time the joystick
         // pressed, or if it's a repeat press
         if ( bFirstPress) {
            // If the previous X value was also greater than the deadZone, return
            // false for bFirstPress
            if ( abs( m_PrevControllerState.sThumbX[port][joystick] ) > deadZone ) {
               *bFirstPress = false;
            } else { // This must be the first press
               *bFirstPress = true;
            }
         }

         // Return the value we got from the joystick
         return m_ControllerState.sThumbX[port][joystick];
      }
   }

   // Return 0 if the joystick was not pushed past the dead zone
   return 0;
}


// Will return the Y value of the joystick passed in
int USBManager::GetJoystickY( int port, enum JOYSTICK joystick, int deadZone /*=0*/, bool* bFirstPress /*=NULL*/ )
{
   // Make sure we have a duke at the current location, otherwise return 0
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return 0;
      }
   }

   int nReturnVal = 0;

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke in this port, skip to the next port
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         // If the current stick is moved, process the request and return the value!
         if ( abs( m_ControllerState.sThumbY[locPort][joystick] ) > deadZone ) {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if ( bFirstPress) {
               // If the previous Y value was also greater than the deadZone, return
               // false for bFirstPress
               if ( abs( m_PrevControllerState.sThumbY[locPort][joystick] ) > deadZone ) {
                  *bFirstPress = false;
               } else { // This must be the first press
                  *bFirstPress = true;
               }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbY[locPort][joystick];
         }
      }
   } else {    // Check one port only
      // If the current stick is moved, process the request and return the value!
      if ( abs( m_ControllerState.sThumbY[port][joystick] ) > deadZone ) {
         // Determine if the user wishes to know if this is the first time the joystick
         // pressed, or if it's a repeat press
         if ( bFirstPress) {
            // If the previous Y value was also greater than the deadZone, return
            // false for bFirstPress
            if ( abs( m_PrevControllerState.sThumbY[port][joystick] ) > deadZone ) {
               *bFirstPress = false;
            } else { // This must be the first press
               *bFirstPress = true;
            }
         }

         // Return the value we got from the joystick
         return m_ControllerState.sThumbY[port][joystick];
      }
   }

   // Return 0 if the joystick was not pushed past the dead zone
   return 0;
}


// Will return TRUE if a button is depressed, or FALSE if it is not
bool USBManager::IsButtonPressed( int port, enum BUTTONS button, int nThreshold /*=0*/, bool* bFirstPress /*=NULL*/ )
{
   // Make sure we have a duke at the current location, otherwise return false
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return false;
      }
   }

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke in this port, skip to the next port
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         // If the button is depressed, determine if the user wishes to know
         // if it's a repeat press
         if ( m_ControllerState.nButtonPress[locPort][button] > nThreshold ) {
            // If the user gave us the address of a boolean variable, we should return to them
            // whether or not this is the first time the button was pressed, or if it's a repeat
            // press
            if ( bFirstPress ) {
               // If in the previous state the button was pressed, return 'false' for bFirstPress
               if ( m_PrevControllerState.nButtonPress[locPort][button] > nThreshold ) {
                  *bFirstPress = false;
               } else { // Otherwise, if the Prev value was false, we need to notify the user it's the first press
                  *bFirstPress = true;
               }
            }

            // Since a button was pressed, return early out of our loop
            return true;
         }
      }
   } else {    // Check one port only
      if ( m_ControllerState.nButtonPress[port][button] > nThreshold ) {
         // If the user gave us the address of a boolean variable, we should return to them
         // whether or not this is the first time the button was pressed, or if it's a repeat
         // press
         if ( bFirstPress ) {
            // If in the previous state the button was pressed, return 'false' for bFirstPress
            if ( m_PrevControllerState.nButtonPress[port][button] > nThreshold ) {
               *bFirstPress = false;
            } else { // Otherwise, if the Prev value was false, we need to notify the user it's the first press
               *bFirstPress = true;
            }
         }
      }

      // Return the value of the button
      // This can be 'true' or 'false'
      return !!m_ControllerState.nButtonPress[port][button];
   }

   // If no button was pressed, let's return false;
   return false;
}

void USBManager::ProcessInput( void )
{
   XINPUT_STATE state;
   memset( &state, 0, sizeof( XINPUT_STATE ) );

   // Store the previous state
   m_PrevControllerState = m_ControllerState;

   // Check to see if any devices were added or removed
   CheckForHotplugs();

   for ( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port ) {
      // Make sure a duke is plugged in
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         continue;
      }

      XInputGetState( ( (DeviceDuke*)devices[port][SLOT_CONTROLLER] )->duke, &state );

      // Packet Number
      m_ControllerState.dwControllerState[port] = state.dwPacketNumber;

      // Check the buttons
      for ( unsigned button = 0; button < BUTTON_MAX; ++button) {
         m_ControllerState.nButtonPress[port][button] = state.Gamepad.bAnalogButtons[button];
      }

      // Check the controls
      for ( unsigned control = 0; control < CONTROL_MAX; ++control) {
         m_ControllerState.bControlPressed[port][control] = !!( state.Gamepad.wButtons & ( 1 << control ) );
      }

      // Check the Joysticks
      for ( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick ) {
         m_ControllerState.sThumbX[port][joystick] = state.Gamepad.sThumbLX;
         m_ControllerState.sThumbY[port][joystick] = state.Gamepad.sThumbLY;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_
#include "constants.h"

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Buttons
enum BUTTONS
{
    BUTTON_MIN = 0,
    BUTTON_A = 0,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LEFT_TRIGGER,
    BUTTON_RIGHT_TRIGGER,

    BUTTON_MAX
};

enum CONTROLS
{
    CONTROL_MIN = 0,
    CONTROL_DPAD_UP = 0,
    CONTROL_DPAD_DOWN,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_BACK,
	CONTROL_LEFT_THUMB,
	CONTROL_RIGHT_THUMB,

    CONTROL_MAX
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_MIN = 0,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4,

    PORT_MAX
};

// Joysticks
enum JOYSTICK
{
    JOYSTICK_ANY = -1,
    JOYSTICK_MIN = 0,
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT,

    JOYSTICK_MAX
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER = 0,
    SLOT_TOP,
    SLOT_BOTTOM,
    
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port )
        {
            for( unsigned int button = 0; button < NUM_DUKE_BUTTONS; ++button )
            {
                nButtonPress[port][button] = 0;
            }

            for( unsigned int control = 0; control < NUM_DUKE_CONTROLS; ++control )
            {
                bControlPressed[port][control] = false;
            }

            for( unsigned int joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                sThumbX[port][joystick] = 0;
                sThumbY[port][joystick] = 0;
            }

            dwControllerState[port] = 0;
        }
    };
    
    ~CControllerState(){};


   // Public Properties
   BYTE nButtonPress[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
   bool bControlPressed[NUM_XBOX_PORTS][CONTROL_MAX];
   SHORT sThumbX[NUM_XBOX_PORTS][JOYSTICK_MAX];
   SHORT sThumbY[NUM_XBOX_PORTS][JOYSTICK_MAX];
   DWORD dwControllerState[NUM_XBOX_PORTS];private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        XInputClose( duke );
        duke = 0;
    }
};


class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    // Calling this will update the controller state objects with the latest info
    void ProcessInput( void );

    // Calling this will check to see if controllers we added or removed
    void CheckForHotplugs( void );

    // This will allow you to determine if a button is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    bool IsButtonPressed( int port, enum BUTTONS button, int nThreshold=0, bool* bFirstPress=NULL );
    
    // This will allow you to determine if a control is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the control
    bool IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress=NULL );

    // This will allow you to get the value of the X or Y axis, adjusting for a "dead zone".
    // If a dead zone is passed in, the call will return '0' unless the value of the X or Y axis
    // is greater than the dead zone value.  If an address to a boolean variable is provided, it
    // will return whether or not it's the 'first' press of the joystick
    int  GetJoystickX( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );
    int  GetJoystickY( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );

    // Calling this will determine if there was movement for any item on a controller
    // Will return true if any button or thumbstick has changed since last poll
    bool MovementDetected( int port, int deadZone=0 );

private:
    CControllerState m_ControllerState;
    CControllerState m_PrevControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_
#include <xfont.h>

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader


    HRESULT  BeginScene( VOID );
    HRESULT  EndScene( VOID );

private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};



class Key
{
public:
	int xorigin, yorigin;		// x,y coordinate of the key's upper left pixel
	int width, height;			// width and height of the key
	DWORD selectColor;			// color to hilight the key with upon selection
	WCHAR* resultChar;			// value attached to the key
	bool render;				// should the key be rendered?

	// Constructors and Destructors
	Key();
	~Key();

	void define(int x, int y, int w, int h, DWORD color);
	void defineText(WCHAR* result);
	void setRender(bool value);
	bool getRender(void);
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\o\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>

#define KEYPAD_NUM_ROWS    4
#define KEYPAD_NUM_COLS    4
#define DISPLAY_NUM_ROWS    4
#define DISPLAY_NUM_COLS    4

#define APP_TITLE_NAME_A                        "XShell"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Menubox constants
#define MENUBOX_MAINAREA_X1                     102.0f
#define MENUBOX_MAINAREA_Y1                     135.0f
#define MENUBOX_MAINAREA_X2                     536.0f
#define MENUBOX_MAINAREA_Y2                     367.0f

#define MENUBOX_TITLEBAR_TEXT_XPOS              127.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1 + 5.0f
#define MENUBOX_SELECTBAR_X2                    MENUBOX_MAINAREA_X2 - 5.0f

#define MENUBOX_TEXT_TOP_BORDER                   2.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 9.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 4.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER)
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

// Display Settings Menu constants
#define DISPSETMENU_VIDEOHEADER_YPOS            149.0f      // Also in dispset.mnu file -- must be identical

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FONT_ALIAS_LEVEL                        4

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR
#define SCREEN_DEFAULT_TRANS_COLOR              SCREEN_DEFAULT_BACKGROUND_COLOR

// Settings Menu contants - These should match the numbers in 'settings.mnu'
#define SETTINGSMENU_OPTIONHEADER_COLOR          COLOR_DARK_GREEN2 // COLOR_MEDIUM_GREEN
#define SETTINGSMENU_VIDSET_YPOS                 173.0f
#define SETTINGSMENU_VIDSET_TEXT                 L"Video :"
#define SETTINGSMENU_IPADDR_YPOS                 249.0f
#define SETTINGSMENU_IPADDR_TEXT                 L"IP address :"
#define SETTINGSMENU_SUBNET_YPOS                 277.0f
#define SETTINGSMENU_SUBNET_TEXT                 L"Subnet mask :"
#define SETTINGSMENU_GATEWY_YPOS                 305.0f
#define SETTINGSMENU_GATEWY_TEXT                 L"Gateway :"
#define SETTINGSMENU_MANAME_YPOS                 334.0f
#define SETTINGSMENU_MANAME_TEXT                 L"Machine name :"

static float g_fSettingsItemYPos[] = {
    SETTINGSMENU_VIDSET_YPOS,             // Item 0
    SETTINGSMENU_IPADDR_YPOS,             // Item 1
    SETTINGSMENU_SUBNET_YPOS,             // Item 2
    SETTINGSMENU_GATEWY_YPOS,             // Item 3
    SETTINGSMENU_MANAME_YPOS              // Item 4
};

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              MENUBOX_MAINAREA_Y2 + 20.0f // ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 40.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      18
#define MENU_LAUNCH_MACHINENAME_COLOR           SCREEN_DEFAULT_TEXT_FG_COLOR
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  114     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  126     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                114     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                361     // Bitmaps, use int

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_DARK_GREEN2
#define ITEM_SELECTED_HEADER_COLOR              COLOR_YELLOW
#define ITEM_SELECTED_VALUE_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_SELECTED_TEXT_COLOR                SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_XBELIST_FONT_HEIGHT                17
#define ITEM_FORMATMU_FONT_HEIGHT               17

// MU Format Dlg constants
#define MUFORMATDLG_SCREEN_DIM_VALUE            0x8F000000 // MMX way - 0x00707070
#define MUFORMATDLG_UNAVAIL_MU_COLOR            COLOR_DARK_GREEN2
#define MUFORMATDLG_AVAIL_MU_COLOR              SCREEN_DEFAULT_TEXT_FG_COLOR
#define MUFORMATDLG_SELECTED_MU_COLOR           ITEM_SELECTED_TEXT_COLOR
#define MUFORMATDLG_DELETE_MSG_YPOS             164.0f
#define MUFORMATDLG_DELETE_MSG                  L"All data will be erased from"
#define MUFORMATDLG_FORMATTING_MSG              L"Formatting..."
#define MUFORMATDLG_SUCCESS_MSG                 L"Format Successful!"
#define MUFORMATDLG_FAIL_MSG                    L"Format Failed!"
#define MUFORMATDLG_MSG_PAUSE                   1500

// Error Message Menu constants
#define ERRORMSGMENU_BUTTON1_TEXT               L"ok"
#define ERRORMSGMENU_MSG_FG_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ERRORMSGMENU_MSG_BG_COLOR               SCREEN_DEFAULT_TEXT_BG_COLOR
#define ERRORMSGMENU_MSG_YPOS                   189.0f

// Keypad and Keyboard location information
#define KEYBOARD_LINE_WIDTH                     1.0f
#define KEYPAD_LINE_WIDTH                       1.0f
#define KEYBOARD_TOPROW_Y1                      210
#define KEYPAD_TOPROW_Y1                        210
#define MENU_DISPSET_BUTTON_Y1                  186
#define MUFORMATDLG_BUTTON_Y1                   250
#define MUFORMATDLG_BUTTON_X1                   265
#define ERRORMSGMENU_BUTTON_Y1                  270
#define ERRORMSGMENU_BUTTON_X1                  265
#define KEYBOARD_MACHINENAMEHEADER_XPOS         153.0f                  // Must be identical to data in 'machine.mnu'
#define KEYBOARD_MACHINENAMEHEADER_YPOS         159.0f                  // Must be identical to data in 'machine.mnu'
#define KEYPAD_IPADDRHEADER_TEXT                L"IP address :"         // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_XPOS                191.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_YPOS                159.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'


// File path and location constants
#define FILE_EXECUTABLE_DEVICE_PATH_A           "\\Device\\Harddisk0\\Partition1"
#define FILE_EXECUTABLE_DRIVE_A                 "c:"
#define FILE_EXECUTABLE_PATH_A                  "\\devkit"
#define FILE_EXECUTABLE_DIRECTORY_A             FILE_EXECUTABLE_DRIVE_A FILE_EXECUTABLE_PATH_A
#define FILE_EXECUTABLE_ALIAS_A                 "e:"
#define FILE_EXECUTABLE_EXENSION_A              ".XBE"
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

#define FILE_DATA_SETTINGS_FILENAME_A           "c:\\devkit\\xbdm.ini"
#define FILE_DATA_SETTINGS_SECTION_NAME_A       "[xbdm]"
#define FILE_DATA_SETTINGS_IP_TOKEN_A           "staticip addr="
#define FILE_DATA_SETTINGS_SUBNET_TOKEN_A       "subnetmask addr="
#define FILE_DATA_SETTINGS_GATEWAY_TOKEN_A      "defgateway addr="
#define FILE_DATA_SETTINGS_MACHINENAME_TOKEN_A  "dbgname name="
#define FILE_SPLASHSCREEN_LOCATION_A            FILE_DATA_IMAGE_DIRECTORY_A "\\loading.bmp"

// Data value limits
#define DATAVALUE_IPADDRESS_LENGTH              15
#define DATAVALUE_MACHINENAME_LENGTH            20
#define DATAVALUE_DISPLAYSETTING_TEXT_LENGTH    20

// Screen Saver
#define SCREEN_SAVER_TIMEOUT                    600000  // 10 minutes, 1200000 <-- 20 minutes
#define SCREEN_SAVER_UPDATE_INTERVAL            30000   // 30 seconds
#define SCREEN_SAVER_IMAGE                      FILE_DATA_IMAGE_DIRECTORY_A "\\abutton.bmp"
#define SCREEN_SAVER_BACK_COLOR                 COLOR_BLACK

// Controller and XBox Port and Slot Information
#define NUM_XBOX_PORTS                          4
#define NUM_XBOX_MU_SLOTS                       8
#define NUM_DUKE_BUTTONS                        8
#define NUM_DUKE_CONTROLS                       8
#define NUM_DUKE_SLOTS                          2

// Display Settings
enum XBoxDisplaySettings
{
    DISPLAY_SETTING_NONE        = 0,
    DISPLAY_SETTING_MONITOR     = 1,
    DISPLAY_SETTING_NTSC_M      = 2,
    DISPLAY_SETTING_NTSC_J,
    DISPLAY_SETTING_PAL_M       = 4,
    DISPLAY_SETTING_PAL_A,              // PAL B, D, G, H, I
    DISPLAY_SETTING_PAL_N,
    DISPLAY_SETTING_PAL_NC,
    DISPLAY_SETTING_NTSC_M_COMP = 10,
    DISPLAY_SETTING_PAL_M_COMP  = 12
};

// Joystick and Button Dead Zone and Threshold info
#define JOYSTICK_DEAD_ZONE                      20000       // 0 - 32768
#define BUTTON_THRESHOLD                        50          // 0 - 255

enum DisplaySettings
{
    ENUM_DISPSET_TEXT_MONITOR = 0,
    ENUM_DISPSET_TEXT_NTSC_SV,
    ENUM_DISPSET_TEXT_NTSC_C,
    ENUM_DISPSET_TEXT_PAL_SV,
    ENUM_DISPSET_TEXT_PAL_C    
};

// Memory Unit BitMasks used for detection
static DWORD g_dwMUBitMask[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};

static WCHAR* g_wpszMUPortNames[] = {
    L"Controller 1 - Top Slot",
    L"Controller 1 - Bottom Slot",
    L"Controller 2 - Top Slot",
    L"Controller 2 - Bottom Slot",
    L"Controller 3 - Top Slot",
    L"Controller 3 - Bottom Slot",
    L"Controller 4 - Top Slot",
    L"Controller 4 - Bottom Slot"
};

// Display Settings
static WCHAR* g_wpszDISPLAYSETTINGS[] = {
    L"Monitor",
    L"NTSC (S-Video)",
    L"NTSC (Composite)",
    L"PAL (S-Video)",
    L"PAL (Composite)"
};

// XShell Menu Identifiers
enum XShellMenuIds
{
    ENUM_SHELLMENUID_LAUNCH = 0,
    ENUM_SHELLMENUID_SETTINGS,
    ENUM_SHELLMENUID_MEMORY,
    ENUM_SHELLMENUID_SETTINGS_MACHINENAME,
    ENUM_SHELLMENUID_SETTINGS_GATEWAY,
    ENUM_SHELLMENUID_SETTINGS_IPADDRESS,
    ENUM_SHELLMENUID_SETTINGS_DISPLAY
};

// XShell States (bit mask)
#define SHELLSTATE_NORMAL       0
#define SHELLSTATE_ERROR        1
#define SHELLSTATE_NOCONFIG     2

// XShell Errors
// This list should stay in sync with the "g_wpszERRORCODEMSG" list
#define ERRORCODE_NO_ERROR          0
#define ERRORCODE_INVALID_XBE       1
#define ERRORCODE_UNKNOWN_ERROR     2

// This list should stay in sync with the "ERRORCODE" defines
static WCHAR* g_wpszERRORCODEMSG[] = {
    L"No Error Has Occurred",
    L"An Error Occurred Loading an XBox Executable",
    L"An Unknown Error Has Occurred"
};

// Screen item locations
#define ITEM_MACHINENAME_DATA_X                 ( ( ( MENUBOX_SELECTBAR_X2 - MENUBOX_SELECTBAR_X1 ) / 2.0f ) + MENUBOX_SELECTBAR_X1 - 17.0F )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\channels.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __CHANNELS_H_
#define __CHANNELS_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#include "qtest.h"

//Channel structure
struct Channel{
	Iengine* pEngine;  //Interface to QTEST engine
	IengineEx* pEngineEx;  //Extended Interface to QTEST engine
	bool fUp;  //Is the channel UP?
};

/////////////////////////////////////////////////////////////////////////////
//  Creates and initialize an array of QTEST Interfaces (Channels)
/////////////////////////////////////////////////////////////////////////////

class Channels{

public:

	//Constructor
	Channels(UINT uicChannels);

	//Constructor Initialized?
	bool IsInit(){return m_fInit;}

	//Destructor
	~Channels();

	//Access to number of channels
	UINT GetNumOfChannels(){return m_uicChannels;}

public:

	Channel* m_rgChannels; //Channels

private:
	UINT m_uicChannels;  //Number of channels
	bool m_fInit;  //Constructor initialized?

};//endclass

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\channels.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "../qtest/qtest_i.c"
#include "channels.h"

#define SENDBUFFERS 20
#define SENDBUFFERSIZE 4096
#define RECEIVEBUFFERSIZE 0

Channels::Channels(UINT uicChannels):
m_uicChannels(uicChannels),
m_rgChannels(NULL),
m_fInit(false)
{

	//Allocate channels
	m_rgChannels=new Channel[uicChannels];
	_ASSERT(NULL!=m_rgChannels);
	if (NULL==m_rgChannels){
		return;
	}//endif

	//Zero array of structures
	ZeroMemory(m_rgChannels,sizeof(Channel)*m_uicChannels);

	HRESULT hr=S_OK;
	IClassFactory* pCF;

	//Create class factory
	hr=CoGetClassObject(CLSID_engine, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pCF); 
	_ASSERT(SUCCEEDED(hr));
	if (FAILED(hr)){
		return;
	}//endif

	//Get Iengine and IengineEx interfaces
	for (UINT ui=0; ui<m_uicChannels; ui++){
		hr = pCF->CreateInstance(NULL, IID_Iengine, (void**)&(m_rgChannels[ui].pEngine));
		_ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)){
			return;
		}//endif
		hr = m_rgChannels[ui].pEngine->QueryInterface(IID_IengineEx,(void**)&(m_rgChannels[ui].pEngineEx));
		_ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)){
			return;
		}//endif

		hr = m_rgChannels[ui].pEngineEx->InitEx(SENDBUFFERS,SENDBUFFERSIZE,RECEIVEBUFFERSIZE);
		_ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)){
			return;
		}//endif

	}//endfor

	//Release class factory
	pCF->Release(); 

	//Initialization success
	m_fInit=true;

}//endmethod

Channels::~Channels(){

	//Deallocate channels
	if (NULL!=m_rgChannels){

		for (UINT ui=0; ui<m_uicChannels; ui++){
			m_rgChannels[ui].pEngineEx->CleanupEx();
			if (NULL!=m_rgChannels[ui].pEngine){
				m_rgChannels[ui].pEngine->Release();
			}//endif
			if (NULL!=m_rgChannels[ui].pEngineEx){
				m_rgChannels[ui].pEngineEx->Release();
			}//endif
		}//endfor

		delete [] m_rgChannels;
		m_rgChannels=NULL;

	}//endif

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\GeneDBTool\o\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_
#include "constants.h"

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Buttons
enum BUTTONS
{
    BUTTON_MIN = 0,
    BUTTON_A = 0,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LEFT_TRIGGER,
    BUTTON_RIGHT_TRIGGER,

    BUTTON_MAX
};

enum CONTROLS
{
    CONTROL_MIN = 0,
    CONTROL_DPAD_UP = 0,
    CONTROL_DPAD_DOWN,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_BACK,
	CONTROL_LEFT_THUMB,
	CONTROL_RIGHT_THUMB,

    CONTROL_MAX
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_MIN = 0,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4,

    PORT_MAX
};

// Joysticks
enum JOYSTICK
{
    JOYSTICK_ANY = -1,
    JOYSTICK_MIN = 0,
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT,

    JOYSTICK_MAX
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER = 0,
    SLOT_TOP,
    SLOT_BOTTOM,
    
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port )
        {
            for( unsigned int button = 0; button < NUM_DUKE_BUTTONS; ++button )
            {
                nButtonPress[port][button] = 0;
            }

            for( unsigned int control = 0; control < NUM_DUKE_CONTROLS; ++control )
            {
                bControlPressed[port][control] = false;
            }

            for( unsigned int joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                sThumbX[port][joystick] = 0;
                sThumbY[port][joystick] = 0;
            }

            dwControllerState[port] = 0;
        }
    };
    
    ~CControllerState(){};


   // Public Properties
   BYTE nButtonPress[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
   bool bControlPressed[NUM_XBOX_PORTS][CONTROL_MAX];
   SHORT sThumbX[NUM_XBOX_PORTS][JOYSTICK_MAX];
   SHORT sThumbY[NUM_XBOX_PORTS][JOYSTICK_MAX];
   DWORD dwControllerState[NUM_XBOX_PORTS];private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        XInputClose( duke );
        duke = 0;
    }
};


class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    // Calling this will update the controller state objects with the latest info
    void ProcessInput( void );

    // Calling this will check to see if controllers we added or removed
    void CheckForHotplugs( void );

    // This will allow you to determine if a button is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    bool IsButtonPressed( int port, enum BUTTONS button, int nThreshold=0, bool* bFirstPress=NULL );
    
    // This will allow you to determine if a control is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the control
    bool IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress=NULL );

    // This will allow you to get the value of the X or Y axis, adjusting for a "dead zone".
    // If a dead zone is passed in, the call will return '0' unless the value of the X or Y axis
    // is greater than the dead zone value.  If an address to a boolean variable is provided, it
    // will return whether or not it's the 'first' press of the joystick
    int  GetJoystickX( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );
    int  GetJoystickY( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );

    // Calling this will determine if there was movement for any item on a controller
    // Will return true if any button or thumbstick has changed since last poll
    bool MovementDetected( int port, int deadZone=0 );

private:
    CControllerState m_ControllerState;
    CControllerState m_PrevControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\control.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "control.h"
#include "time.h"

//Macro for indexing queue information by user index and queue number
#define QUEUEINDEX(UserIndex,QueueIndex) (UserIndex*m_dwcQueuesPerUser+QueueIndex)

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
Control::Control(DWORD dwcUsers, DWORD dwcQueuesPerUser, HANDLE hShutdownEvent):
m_hShutdownEvent(hShutdownEvent),
m_fInit(FALSE),
m_rgMapNodes(NULL),
m_dwcUsers(dwcUsers),
m_dwcQueuesPerUser(dwcQueuesPerUser),
m_rgOpStateInfo(NULL),
m_rgAckInfo(NULL),
m_rgListReplyInfo(NULL),
m_rgTickleInfo(NULL)
{

	printf("Allocating user data...");

	//Allocate operational state information array
	m_rgOpStateInfo=new OpStateInfo[m_dwcUsers];
	ZeroMemory(m_rgOpStateInfo,sizeof(OpStateInfo)*m_dwcUsers);
	_ASSERT(NULL!=m_rgOpStateInfo);
	if (NULL==m_rgOpStateInfo){
		return;
	}//endif

	//Allocate ack information array
	m_rgAckInfo=new AckInfo[m_dwcUsers];
	ZeroMemory(m_rgAckInfo,sizeof(AckInfo)*m_dwcUsers);
	_ASSERT(NULL!=m_rgAckInfo);
	if (NULL==m_rgAckInfo){
		return;
	}//endif
	
	//Allocate tickle information array
	m_rgTickleInfo=new TickleInfo[m_dwcUsers*m_dwcQueuesPerUser];
	ZeroMemory(m_rgTickleInfo,sizeof(TickleInfo)*m_dwcUsers*m_dwcQueuesPerUser);
	_ASSERT(NULL!=m_rgTickleInfo);
	if (NULL==m_rgTickleInfo){
		return;
	}//endif

	//Allocate list reply information array
	m_rgListReplyInfo=new ListReplyInfo[m_dwcUsers*m_dwcQueuesPerUser];
	ZeroMemory(m_rgListReplyInfo,sizeof(ListReplyInfo)*m_dwcUsers*m_dwcQueuesPerUser);
	_ASSERT(NULL!=m_rgListReplyInfo);
	if (NULL==m_rgListReplyInfo){
		return;
	}//endif

	//Create mutexes
	for (DWORD dwi=0; dwi<NUMOBJLOCKS; dwi++){
		m_rgAckLocks[dwi]=CreateMutex(NULL,FALSE,NULL);
		m_rgListReplyLocks[dwi]=CreateMutex(NULL,FALSE,NULL);
		m_rgTickleLocks[dwi]=CreateMutex(NULL,FALSE,NULL);
	}//endfor

	//Create lookup map nodes
	m_rgMapNodes=new UserIdMapNode[m_dwcUsers];
	_ASSERT(NULL!=m_rgMapNodes);
	if (NULL==m_rgMapNodes){
		return;
	}//endif

	//Create lookup map and populate operational state information with userids
	srand( (unsigned)time( NULL ) );
	QWORD qwUserId;
	DWORD dw;
	for (dwi=0; dwi<m_dwcUsers; dwi++){
		do{
			qwUserId=MAKEQWORD(RANDOMDWORD,RANDOMDWORD);
		}while(SUCCEEDED(GetUserIndex(qwUserId,&dw)));
		m_rgOpStateInfo[dwi].qwUserId=qwUserId;
		m_rgMapNodes[dwi].dwHiUserId=HIDWORD(qwUserId);
		m_rgMapNodes[dwi].dwIndex=dwi;
		m_UserIdMap.insert(LOUSERID2INDEX::value_type(LODWORD(qwUserId),&m_rgMapNodes[dwi]));
	}//endfor

	printf ("done!\n");

	//Initialization success
	m_fInit=true;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////

Control::~Control(){

	printf("Deallocating user data...");

	//Close mutexes
	for (DWORD dwi=0; dwi<NUMOBJLOCKS; dwi++){
		CloseHandle(m_rgAckLocks[dwi]);
		CloseHandle(m_rgListReplyLocks[dwi]);
		CloseHandle(m_rgTickleLocks[dwi]);
	}//endfor

	//Deallocate tickle information arrays
	if (NULL!=m_rgTickleInfo){
		delete[] m_rgTickleInfo;
		m_rgTickleInfo=NULL;
	}//endif

	//Deallocate list reply information arrays
	if (NULL!=m_rgListReplyInfo){
		delete[] m_rgListReplyInfo;
		m_rgListReplyInfo=NULL;
	}//endif
 
	//Deallocate ack information arrays
	if (NULL!=m_rgAckInfo){
		delete[] m_rgAckInfo;
		m_rgAckInfo=NULL;
	}//endif

	//Deallocate operational state information arrays
	if (NULL!=m_rgOpStateInfo){
		delete[] m_rgOpStateInfo;
		m_rgOpStateInfo=NULL;
	}//endif

	//Clear lookup map
	m_UserIdMap.clear();

	//Deallocate map nodes
	if (NULL!=m_rgMapNodes){
		delete[] m_rgMapNodes;
		m_rgMapNodes=NULL;
	}//endif

	printf ("done!\n");

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// GetUserIndex
/////////////////////////////////////////////////////////////////////////////

HRESULT Control::GetUserIndex(QWORD qwUserID, DWORD* pdwIndex){
	
	LOUSERID2INDEX::iterator MapIterator;  //Map iterator

	//Do logarithmic time search for userid
    MapIterator = m_UserIdMap.find(LODWORD(qwUserID));
	
	//If there is a match on the low word we have the right bucket; find the node...
	while (MapIterator!=m_UserIdMap.end()){
		UserIdMapNode* pNode=(*MapIterator).second;
		if (pNode->dwHiUserId==HIDWORD(qwUserID)){
			*pdwIndex=pNode->dwIndex;
			return S_OK;
		}//endif
		MapIterator++;
	}//endwhile

	return E_FAIL;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// GetOpStateInfo
/////////////////////////////////////////////////////////////////////////////

OpStateInfo* Control::GetOpStateInfo(DWORD dwUserIndex){

	return &m_rgOpStateInfo[dwUserIndex];

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// GetAckInfo
/////////////////////////////////////////////////////////////////////////////

AckInfo* Control::GetAckInfo(DWORD dwUserIndex, HANDLE* phLock){

	//Lock?
	if (NULL != phLock){
		HANDLE rghEvents[2];
		rghEvents[0]=m_rgAckLocks[dwUserIndex%NUMOBJLOCKS];
		rghEvents[1]=m_hShutdownEvent;
		if (0!=WaitForMultipleObjects(2,rghEvents,false,INFINITE)-WAIT_OBJECT_0){
			return NULL;
		}//endif
		*phLock=m_rgAckLocks[dwUserIndex%NUMOBJLOCKS];
	}//endif

	return &m_rgAckInfo[dwUserIndex];

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// GetListReplyInfo
/////////////////////////////////////////////////////////////////////////////

ListReplyInfo* Control::GetListReplyInfo(DWORD dwUserIndex, DWORD dwQueue, HANDLE* phLock){

	//Lock?
	if (NULL != phLock){
		HANDLE rghEvents[2];
		rghEvents[0]=m_rgListReplyLocks[dwUserIndex%NUMOBJLOCKS];
		rghEvents[1]=m_hShutdownEvent;
		if (0!=WaitForMultipleObjects(2,rghEvents,false,INFINITE)-WAIT_OBJECT_0){
			return NULL;
		}//endif
		*phLock=m_rgListReplyLocks[dwUserIndex%NUMOBJLOCKS];
	}//endif

	return &m_rgListReplyInfo[QUEUEINDEX(dwUserIndex,dwQueue)];

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// GetTickleInfo
/////////////////////////////////////////////////////////////////////////////

TickleInfo* Control::GetTickleInfo(DWORD dwUserIndex, DWORD dwQueue, HANDLE* phLock){

	//Lock?
	if (NULL != phLock){
		HANDLE rghEvents[2];
		rghEvents[0]=m_rgTickleLocks[dwUserIndex%NUMOBJLOCKS];
		rghEvents[1]=m_hShutdownEvent;
		if (0!=WaitForMultipleObjects(2,rghEvents,false,INFINITE)-WAIT_OBJECT_0){
			return NULL;
		}//endif
		*phLock=m_rgTickleLocks[dwUserIndex%NUMOBJLOCKS];
	}//endif

	return &m_rgTickleInfo[QUEUEINDEX(dwUserIndex,dwQueue)];

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\config.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONFIG_H_
#define __CONFIG_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

//Default optional configuration values
const DWORD default_channels = 1;
const DWORD default_users = 10000;
const DWORD default_destinations = 10;
const DWORD default_runtime = 5;
const BOOL default_ticklecontrol = TRUE;
const DWORD default_maxttl = 1800;

/////////////////////////////////////////////////////////////////////////////
// Stores application configuration information
/////////////////////////////////////////////////////////////////////////////

class Configuration{

public:
	Configuration():
		dwChannels(default_channels),
		dwUsers(default_users),
		dwDestinations(default_destinations),
		dwPort(0L),
		dwQueues(0L),
		rgdwMaxSize(NULL),
		rgdwMinSize(NULL),
		rgfDuplicates(NULL),
		dwRuntime(default_runtime),
		fTickleControl(default_ticklecontrol),
		dwMaxLifetime(default_maxttl){

			//Clear server name
			ZeroMemory(pszServerName,sizeof(pszServerName));

			//Clear config file name
			ZeroMemory(pszConfigFile,sizeof(pszConfigFile));
		}//endmethod

	~Configuration(){

		//Deallocate max size array
		if (NULL!=rgdwMaxSize){
			delete [] rgdwMaxSize;
			rgdwMaxSize=NULL;
		}//endif

		//Deallocate min size array
		if (NULL!=rgdwMinSize){
			delete [] rgdwMinSize;
			rgdwMinSize=NULL;
		}//endif

		//Deallocate array of duplicate tags
		if (NULL!=rgfDuplicates){
			delete [] rgfDuplicates;
			rgfDuplicates=NULL;
		}//endif

	}//endmethod

public:
	char pszServerName[256];  //Server name
	char pszConfigFile[256];  //Server config file
	DWORD dwChannels;  //Number of channels
	DWORD dwUsers;  //Number of unique users
	DWORD dwDestinations;  //Max number of destinations a user can add to
	DWORD dwQueues;  //Number of server queues
	DWORD dwPort;  //Server port
	DWORD* rgdwMaxSize;  //Array of max size for a queue
	DWORD* rgdwMinSize;  //Array of min size for a queue
	BOOL* rgfDuplicates;  //Queue allows duplicates?
	DWORD dwRuntime;  //Minutes to run
	DWORD dwMaxLifetime;  //Max seconds a client can live
	BOOL fTickleControl;  //Do tickles control list/del? (vs. internal state)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\receive.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "receive.h"
#include "xqprotocol.h"
#include "connection.h"

#define PROCESSINGBUFFERSIZE 4096

typedef struct ChannelState_struct{
	BYTE rgbData[PROCESSINGBUFFERSIZE];  //Buffer
	DWORD dwGot;  //How many bytes we got this read
	DWORD dwOffset;  //Offset index to write/process in buffer
	DWORD dwLeft;  //Bytes left to process in buffer
	BYTE* pbData;  //Traveling pointer in buffer to write/process
}ChannelState;

/////////////////////////////////////////////////////////////////////////////
// ReceiveThreadFunc
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI ReceiveThreadFunc(LPVOID pData){

	//Counters
	DWORD dwcACKs=0L;
	DWORD dwcLISTREPLYs=0L;

	//Verify parameters
	if (NULL==pData){
		return -1;
	}//endif
	
	//Initializes the COM library for use by the calling thread and sets the thread's concurrency model.
	if FAILED(CoInitializeEx(NULL,COINIT_MULTITHREADED)){
		return -1;
	}//endif

	//Cast thread parameters 
	ReceiveThreadFuncParams* pParams=(ReceiveThreadFuncParams*)pData;
	Channels* pChannels=pParams->pChannels;  //Pointer to channel
	Control* pControl=pParams->pControl;  //Pointer to control object
	HANDLE hStop=pParams->hStop;
	HANDLE hStopped=pParams->hStopped;
	HANDLE hReady=pParams->hReady;
	HANDLE hStart=pParams->hStart;

	//Lock object
	HANDLE hLock=NULL;

	//Pointers to storage objects
	AckInfo* pAckInfo=NULL;  //Pointer to ack info object
	ListReplyInfo* pListReplyInfo=NULL;  //Pointer to list reply object

	//Pointers to view array of bytes as
	BASE_ACK_MSG* pAck=NULL;;  //Pointer to ACK
	Q_LIST_REPLY_MSG* pListReply=NULL;  //Pointer to LIST_REPLY

	DWORD dwUserIndex=0L; //User index

	//Setup channel traversal
	DWORD dwChannelIndex=0L;
	DWORD dwcChannels=pChannels->GetNumOfChannels();
	Channel* pChannel=NULL;

	//Allocate channel states
	ChannelState* rgState = new ChannelState[dwcChannels];
	ZeroMemory(rgState,sizeof(ChannelState)*dwcChannels);
	
	SetEvent(hReady);
	WaitForSingleObject(hStart,INFINITE);

	//While it is not time to shutdown perform actions
	while (WAIT_OBJECT_0!=WaitForSingleObject(hStop,0)){

		if (++dwChannelIndex>=dwcChannels){
			dwChannelIndex=0;
		}//endif
		pChannel=&(pChannels->m_rgChannels[dwChannelIndex]);

		//Try and get some receive data
		rgState[dwChannelIndex].dwGot=0L;
		rgState[dwChannelIndex].pbData=rgState[dwChannelIndex].rgbData+rgState[dwChannelIndex].dwOffset;

		getdata:
		if FAILED(pChannel->pEngineEx->GetResponseData((unsigned char*)(rgState[dwChannelIndex].pbData),PROCESSINGBUFFERSIZE-rgState[dwChannelIndex].dwOffset,&(rgState[dwChannelIndex].dwGot))){

			//Shutdown time?
			if (WAIT_OBJECT_0==WaitForSingleObject(hStop,0)){
				break;
			}//endif

			//Connection might be closed wait a few msecs and try again
			Sleep(100);

			goto getdata;

		}//endif

		rgState[dwChannelIndex].dwGot+=rgState[dwChannelIndex].dwOffset;
	
		//Got some data; time to process
		rgState[dwChannelIndex].dwOffset=0L;
		while (WAIT_OBJECT_0!=WaitForSingleObject(hStop,0)){

			rgState[dwChannelIndex].dwLeft=rgState[dwChannelIndex].dwGot-rgState[dwChannelIndex].dwOffset;
			rgState[dwChannelIndex].pbData=rgState[dwChannelIndex].rgbData+rgState[dwChannelIndex].dwOffset;

			//Do we have the first 2 critical dwords of the message?
			if (rgState[dwChannelIndex].dwLeft>sizeof(DWORD)*2){

				//Do we have the entire message?
				if (rgState[dwChannelIndex].dwLeft>=((BASE_MSG_HEADER*)(rgState[dwChannelIndex].pbData))->dwMsgLen+sizeof(BASE_MSG_HEADER)){

					//What type of command is it?
					switch (((BASE_MSG_HEADER*)(rgState[dwChannelIndex].pbData))->dwMsgType){
					
						/*******************/
						/* QMSG_LIST_REPLY */
						/*******************/

						case QMSG_LIST_REPLY:

							//Cast to list reply
							pListReply=(Q_LIST_REPLY_MSG*)(rgState[dwChannelIndex].pbData);

							//Lookup user index
							if FAILED(pControl->GetUserIndex(pListReply->qwUserID,&dwUserIndex)){
								continue;
							}//endif
							
							//Lock storage object
							pListReplyInfo=pControl->GetListReplyInfo(dwUserIndex,pListReply->dwQType,&hLock);
							if (NULL==pListReplyInfo){
								continue;
							}//endif 
							
							//Store information
							pListReplyInfo->dwNumItems=pListReply->dwNumItems;
							pListReplyInfo->dwQLeft=pListReply->dwQLeft;
							pListReplyInfo->hr=pListReply->hr;
							_ASSERT(S_OK==pListReplyInfo->hr);
							pListReplyInfo->qwCookie=pListReply->qwCookie;
							pListReplyInfo->qwNextQUID=pListReply->qwNextQUID;
							pListReplyInfo->fListReplyReceived=TRUE;

							//Release mutex
							ReleaseMutex(hLock);

							//Increment counter
							dwcLISTREPLYs++;

						break;

						/***************/
						/* MSGTYPE_ACK */
						/***************/

						case MSGTYPE_ACK:

							//Cast to ACK message
							pAck=(BASE_ACK_MSG*)(rgState[dwChannelIndex].pbData);

							//Lookup user index
							if FAILED(pControl->GetUserIndex(pAck->qwAckUserID,&dwUserIndex)){
								continue;
							}//endif

							//Lock storage object
							pAckInfo=pControl->GetAckInfo(dwUserIndex,&hLock);
							if (NULL==pAckInfo){
								continue;
							}//endif

							//Store information
							pAckInfo->fAckReceived=TRUE;

							//Release mutex
							ReleaseMutex(hLock);
							
							//Increment counter
							dwcACKs++;

						break;

						default:
							_ASSERT(0);  //We should never get here!

					}//endswitch

					//Advance to next message
					rgState[dwChannelIndex].dwOffset+=((BASE_MSG_HEADER*)(rgState[dwChannelIndex].pbData))->dwMsgLen+sizeof(BASE_MSG_HEADER);
					continue;

				}//endif
			}//endif
			
			//Partial message; move to front of buffer and reload
			if (rgState[dwChannelIndex].dwLeft!=0){
				memmove(rgState[dwChannelIndex].rgbData,rgState[dwChannelIndex].pbData,rgState[dwChannelIndex].dwLeft);
			}//endif
			rgState[dwChannelIndex].dwOffset=rgState[dwChannelIndex].dwLeft;

			//Exit processing loop to get more data
			break;

		}//endwhile (processing data)

	}//endwhile (while not shutdown)

	//Deallocate channel state
	if (NULL!=rgState){
		delete [] rgState;
		rgState=NULL;
	}//endif

	//Closes the COM library on the current thread.
	CoUninitialize();

	//Output counters
	printf ("ACK: %u\n",dwcACKs);
	printf ("LISTREPY: %u\n",dwcLISTREPLYs);

	SetEvent(hStopped);

	return 0;

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\control.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONTROL_H_
#define __CONTROL_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#include <map>

#define NUMOBJLOCKS 100

//Define map node type
typedef struct UserIdMapNodeStruct{
	DWORD dwHiUserId;  //Hi dword of user id
	DWORD dwIndex;  //Index that this user exists at
}UserIdMapNode;

//Map will key on low dword and store high dword and index
using namespace std;
typedef multimap<DWORD, UserIdMapNode*> LOUSERID2INDEX;

//Operational state information state type enumeration
enum OpStateEnum{
	opstate_do_userinfos=0,
	opstate_do_adds=1,
	opstate_do_lists=2,
	opstate_do_deletes=3,
	opstate_endenum=4
};//endenum

//Operational state information
struct OpStateInfo{
	UINT uiState;  //User opstate
	QWORD qwUserId;  //User identification
	QWORD qwXIP; //XIP address
	DWORD dwSequence;  //Sequence number
	DWORD dwItemsAdded;   //Number of items we just added
	DWORD dwTimeToDie;  //Tick count to kill client after
};//endstruct

//Ack information
struct AckInfo{
	BOOL fAckReceived;  //Did we receive an ACK?
};//endstruct

//List reply information
struct ListReplyInfo{
	BOOL fListReplyReceived;  //Did we receive a LIST REPLY?
	HRESULT hr;  //Q_LIST_REPLY_MSG data
    QWORD qwCookie;  //Q_LIST_REPLY_MSG data
    QWORD qwNextQUID;  //Q_LIST_REPLY_MSG data
    DWORD dwQLeft;  //Q_LIST_REPLY_MSG data
    DWORD dwNumItems;  //Q_LIST_REPLY_MSG data
	QWORD dwLastQUID;  //QLIST_REPLY_MSG data
};//endstruct

//Tickle information
struct TickleInfo{
    DWORD dwQLength;  //Q_TICKLE_MSG data
};//endstruct

/////////////////////////////////////////////////////////////////////////////
// Controls operation of each user and manages each users queues
/////////////////////////////////////////////////////////////////////////////

class Control{

public:

	//Constructor
	Control(DWORD dwcUsers, DWORD dwcQueuesPerUser, HANDLE hShutdownEvent);

	//Constructor Initialized?
	bool IsInit(){return m_fInit;}

	//Destructor
	~Control();

	//Get the user index from the user id
	HRESULT GetUserIndex(QWORD qwUserID, DWORD* pdwIndex);

	//Get Operational State Information (non-thread-safe)
	OpStateInfo* GetOpStateInfo(DWORD dwUserIndex);

	//Get Ack Information (thread-safe through lock)
	AckInfo* GetAckInfo(DWORD dwUserIndex, HANDLE* phLock);

	//Get List Reply Information (thread-safe through lock)
	ListReplyInfo* GetListReplyInfo(DWORD dwUserIndex, DWORD dwQueue, HANDLE* phLock);

	//Get Tickle Information (thread-safe through lock)
	TickleInfo* GetTickleInfo(DWORD dwUserIndex, DWORD dwQueue, HANDLE* phLock);

	//Access to number of users and number of queues per user
	DWORD GetUserCount(){return m_dwcUsers;}
	DWORD GetQueuesPerUserCount(){return m_dwcQueuesPerUser;}
	
private:

	HANDLE m_hShutdownEvent;  //Shutdown event
	bool m_fInit;  //Instance initialized?
	LOUSERID2INDEX m_UserIdMap;  //UserId to index logarithic+1 time map
	UserIdMapNode* m_rgMapNodes;  //Nodes in map
	DWORD m_dwcUsers;  //User count
	DWORD m_dwcQueuesPerUser;  //Number of queues per user count
	OpStateInfo* m_rgOpStateInfo;  //Array of operational state information
	AckInfo* m_rgAckInfo;  //Array of ack information
	ListReplyInfo* m_rgListReplyInfo;  //Array of list reply information
	TickleInfo* m_rgTickleInfo;  //Array of tickle information
	HANDLE m_rgAckLocks[NUMOBJLOCKS];  //Array of ack object locks
	HANDLE m_rgListReplyLocks[NUMOBJLOCKS];  //Array of list reply object locks
	HANDLE m_rgTickleLocks[NUMOBJLOCKS];  //Array of tickle object locks
 
};//endclass

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\qstress.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "threadpool.h"
#include "connection.h"
#include "transmit.h"
#include "receive.h"
#include "tickles.h"
#include "config.h"

enum EVENTENUM{
	EVENTENUM_TRANSMITSTOP=1,
	EVENTENUM_TRANSMITSTOPPED=2,
	EVENTENUM_TRANSMITREADY=3,
	EVENTENUM_TRANSMITSTART=4,
	EVENTENUM_TICKLESTOP=5,
	EVENTENUM_TICKLESTOPPED=6,
	EVENTENUM_TICKLEREADY=7,
	EVENTENUM_TICKLESTART=8,
	EVENTENUM_RECEIVESTOP=9,
	EVENTENUM_RECEIVESTOPPED=10,
	EVENTENUM_RECEIVEREADY=11,
	EVENTENUM_RECEIVESTART=12,
	EVENTENUM_CONTROLLOCKS=13,
	EVENTENUM_ENDENUM=14
};//endenum

/////////////////////////////////////////////////////////////////////////////
// ShowUsage
/////////////////////////////////////////////////////////////////////////////

void ShowUsage(int argc, char *argv[]){
	char* pstr=strrchr(argv[0],'\\');
	if ((NULL==pstr)||('\0'==pstr)){
		pstr=argv[0];
	}else{
		pstr++;
	}//endif
	printf("usage: %s -s servername [-c #] [-u #] [-d #] [-t #] -f configfile\n",pstr);
	printf("  -s servername (server name or ip address) [required]\n");
	printf("  -c # (number of connections to server) [default: %d]\n",default_channels);
	printf("  -u # (number of unique users to simulate >=1000) [default: %d]\n",default_users);
	printf("  -d # (max number of destinations a single add can have) [default: %d]\n",default_destinations);
	printf("  -m # (minutes to execute) [default: %d]\n",default_runtime);
	printf("  -l # (max seconds a client can live) [default: %d]\n",default_maxttl);
	printf("  -t {yes|no} (tickles control actions; not internal state) [default:");
	if (TRUE==default_ticklecontrol){
		printf("yes]\n");
	}else{
		printf("no]\n");
	}//endif
	printf("  -f configfile (server configuration file) [required]\n\n");
	printf("examples:\n");
	printf("%s -s cutthroat -f c:\\xqserver\\xqserver.cfg\n",pstr);
	printf("%s -s chumdinger -c 5 -u 100000 -d 25 -m 2 -l 1800 -t yes -f c:\\xqserver\\xqserver.cfg\n\n",pstr);
}//endmethod

/////////////////////////////////////////////////////////////////////////////
// ParseCommandLine
/////////////////////////////////////////////////////////////////////////////

HRESULT ParseCommandLine(int argc, char *argv[ ], Configuration* pConfig){

	BOOL fRequiredServerName=FALSE;
	BOOL fRequiredConfigFile=FALSE;
	UINT uiCurrIndex=1;

	//Check for minimal set of arguements and that we have pairing
	if ((argc<5)||((argc-1)%2!=0)){
		goto showusage;
	}//endif
	
	//Parse arguement when we still have some left
	while (uiCurrIndex<argc){

		//Is this a valid format for a switch?
		if ((2>strlen(argv[uiCurrIndex])) || ('-' != argv[uiCurrIndex][0])){
			goto showusage;
		}//endif

		//Parse the switch
		switch(argv[uiCurrIndex][1]){
			case 's':
			case 'S':
				uiCurrIndex++;
				strcpy(pConfig->pszServerName,argv[uiCurrIndex]);
				fRequiredServerName=TRUE;
			break;
			case 'f':
			case 'F':
				uiCurrIndex++;
				strcpy(pConfig->pszConfigFile,argv[uiCurrIndex]);
				fRequiredConfigFile=TRUE;
			break;
			case 'c':
			case 'C':
				uiCurrIndex++;
				pConfig->dwChannels=atol(argv[uiCurrIndex]);
			break;
			case 'u':
			case 'U':
				uiCurrIndex++;
				pConfig->dwUsers=atol(argv[uiCurrIndex]);
				if (pConfig->dwUsers<1000){
					printf("Unique users must be >= 1000\n");
					goto showusage;
				}//endif
			break;
			case 'd':
			case 'D':
				uiCurrIndex++;
				pConfig->dwDestinations=atol(argv[uiCurrIndex]);
			break;
			case 'm':
			case 'M':
				uiCurrIndex++;
				pConfig->dwRuntime=atol(argv[uiCurrIndex]);
			break;
			case 'l':
			case 'L':
				uiCurrIndex++;
				pConfig->dwMaxLifetime=atol(argv[uiCurrIndex]);
			break;
			case 't':
			case 'T':
				uiCurrIndex++;
				if (0==_stricmp(argv[uiCurrIndex],"yes")){
					pConfig->fTickleControl=TRUE;
				}else{
					pConfig->fTickleControl=FALSE;
				}//endif
			break;
			default:
				goto showusage;
		}//endswitch
		uiCurrIndex++;

	}//endwhie

	//Do we have required parameters
	if ((FALSE==fRequiredServerName)||(FALSE==fRequiredConfigFile)){
		goto showusage;
	}//endif

	printf("Configuration:\n");
	printf("server: %s\n",pConfig->pszServerName);
	printf("config file: %s\n",pConfig->pszConfigFile);
	printf("unique users: %u\n",pConfig->dwUsers);
	printf("connections: %u\n",pConfig->dwChannels);
	printf("max destinations per add: %u\n",pConfig->dwDestinations);
	printf("runtime (in minutes): %u\n",pConfig->dwRuntime);
	printf("tickles control actions: ");
	if (TRUE==pConfig->fTickleControl){
		printf("yes\n");
	}else{
		printf("no\n");
	}//endif
	printf("client session time to live (in seconds): %u\n",pConfig->dwMaxLifetime);
	printf("\n");

	return S_OK;

showusage:
	ShowUsage(argc,argv);
	return E_INVALIDARG;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// LoadConfigFile
/////////////////////////////////////////////////////////////////////////////

HRESULT LoadConfigFile(Configuration* pConfig){
	const UINT uiSize=256;
	TCHAR rgchBuffer[uiSize];

	//Get the port number
	if (0==GetPrivateProfileString(_TEXT("Global"),_TEXT("PortNum"),_TEXT(""),rgchBuffer,uiSize,pConfig->pszConfigFile)){
		return E_FAIL;
	}//endif

	//Get the number of queues
	pConfig->dwPort=atol(rgchBuffer);
	if (0==GetPrivateProfileString(_TEXT("Global"),_TEXT("NumQueueTypes"),_TEXT(""),rgchBuffer,uiSize,pConfig->pszConfigFile)){
		return E_FAIL;
	}//endif
	pConfig->dwQueues=atol(rgchBuffer);
	if (0>=pConfig->dwQueues){
		return E_FAIL;
	}//endif

	//Read information about each queue type
	pConfig->rgdwMaxSize=new DWORD[pConfig->dwQueues];
	pConfig->rgdwMinSize=new DWORD[pConfig->dwQueues];
	pConfig->rgfDuplicates=new BOOL[pConfig->dwQueues];
	TCHAR rgchSection[50];
	for (DWORD dwi=0; dwi<pConfig->dwQueues; dwi++){
		_stprintf(rgchSection,"Queue Type %u",dwi);
		if (0==GetPrivateProfileString(rgchSection,_TEXT("MinDataSize"),_TEXT(""),rgchBuffer,uiSize,pConfig->pszConfigFile)){
			return E_FAIL;
		}//endif
		pConfig->rgdwMinSize[dwi]=atol(rgchBuffer);
		if (0==GetPrivateProfileString(rgchSection,_TEXT("MaxDataSize"),_TEXT(""),rgchBuffer,uiSize,pConfig->pszConfigFile)){
			return E_FAIL;
		}//endif
		pConfig->rgdwMaxSize[dwi]=atol(rgchBuffer);
		if (0==GetPrivateProfileString(rgchSection,_TEXT("AllowDuplicates"),_TEXT(""),rgchBuffer,uiSize,pConfig->pszConfigFile)){
			return E_FAIL;
		}//endif
		if (0==_tcsicmp(rgchBuffer,"yes")){
			pConfig->rgfDuplicates[dwi]=TRUE;
		}else{
			pConfig->rgfDuplicates[dwi]=FALSE;
		}//endif
	}//endfor

	return S_OK;
}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Entry point
/////////////////////////////////////////////////////////////////////////////

void __cdecl main(int argc, char *argv[ ], char *envp[ ]){

	//Send memory reports to debug window and console
	_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
	_CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
	_CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT);

	//Send asserts to dialog
	_CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_WNDW);

	//Allocate configuration object
	Configuration* pConfig = NULL;
	pConfig=new Configuration();
	_ASSERT(NULL!=pConfig);
	if (NULL==pConfig){
		return;
	}//endif

	//Parse command line parameters
	if FAILED(ParseCommandLine(argc,argv,pConfig)){
		return;
	}//endif

	//Load configuration file parameters
	if FAILED(LoadConfigFile(pConfig)){
		return;
	}//endif

	//Bring winsock up
	WinsockUP();

	//Initializes the COM library for use by the calling thread and sets the thread's concurrency model.
	if FAILED(CoInitializeEx(NULL,COINIT_MULTITHREADED)){
		return;
	}//endif

	//Create synchronization events
	HANDLE rghEvents[EVENTENUM_ENDENUM];
	for (DWORD dwi=0; dwi<EVENTENUM_ENDENUM;dwi++){
		rghEvents[dwi]=CreateEvent(NULL,TRUE,FALSE,NULL);
	}//endfor

	//Allocate control object
	Control* pControl=NULL;
	pControl=new Control(pConfig->dwUsers,pConfig->dwQueues,rghEvents[EVENTENUM_CONTROLLOCKS]);
	_ASSERT(NULL!=pControl);
	if (NULL==pControl){
		return;
	}//endif
	
	//Allocate connection channels
	Channels* pChannels=NULL;
	pChannels=new Channels(pConfig->dwChannels);
	_ASSERT(NULL!=pChannels);
	if (NULL==pChannels){
		return;
	}//endif

	//Allocate transmit thread parameters
	TransmitThreadFuncParams* pTransmitThreadParams;
	pTransmitThreadParams=new TransmitThreadFuncParams;
	pTransmitThreadParams->hStop=rghEvents[EVENTENUM_TRANSMITSTOP];
	pTransmitThreadParams->hStopped=rghEvents[EVENTENUM_TRANSMITSTOPPED];
	pTransmitThreadParams->hReady=rghEvents[EVENTENUM_TRANSMITREADY];
	pTransmitThreadParams->hStart=rghEvents[EVENTENUM_TRANSMITSTART];
	pTransmitThreadParams->pControl=pControl;
	pTransmitThreadParams->pChannels=pChannels;
	pTransmitThreadParams->pConfig=pConfig;

	//Create transmit thread
	DWORD dwTransmitThreadId=0L;
	HANDLE hTransmitThread=NULL;	
	hTransmitThread=CreateThread(NULL,0L,TransmitThreadFunc,pTransmitThreadParams,0L,&dwTransmitThreadId);
	_ASSERT(hTransmitThread!=NULL);
	if (NULL==hTransmitThread){
		return;
	}//endif

	//Allocate tickle thread parameters
	TickleThreadFuncParams* pTickleThreadParams;
	pTickleThreadParams=new TickleThreadFuncParams;
	pTickleThreadParams->hStop=rghEvents[EVENTENUM_TICKLESTOP];
	pTickleThreadParams->hStopped=rghEvents[EVENTENUM_TICKLESTOPPED];
	pTickleThreadParams->hReady=rghEvents[EVENTENUM_TICKLEREADY];
	pTickleThreadParams->hStart=rghEvents[EVENTENUM_TICKLESTART];
	pTickleThreadParams->pControl=pControl;

	//Create tickle processing thread
	DWORD dwTickleThreadId=0L;
	HANDLE hTickleThread=NULL;
	hTickleThread=CreateThread(NULL,0L,TickleThreadFunc,pTickleThreadParams,0L,&dwTickleThreadId);
	_ASSERT(hTickleThread!=NULL);
	if (NULL==hTickleThread){
		return;
	}//endif

	//Allocate receive thread parameters
	ReceiveThreadFuncParams* pReceiveThreadParams;
	pReceiveThreadParams=new ReceiveThreadFuncParams;
	pReceiveThreadParams->hStop=rghEvents[EVENTENUM_RECEIVESTOP];
	pReceiveThreadParams->hStopped=rghEvents[EVENTENUM_RECEIVESTOPPED];
	pReceiveThreadParams->hReady=rghEvents[EVENTENUM_RECEIVEREADY];
	pReceiveThreadParams->hStart=rghEvents[EVENTENUM_RECEIVESTART];
	pReceiveThreadParams->pControl=pControl;
	pReceiveThreadParams->pChannels=pChannels;

	//Create receive processing thread
	DWORD dwReceiveThreadId=0L;
	HANDLE hReceiveThread=NULL;
	hReceiveThread=CreateThread(NULL,0L,ReceiveThreadFunc,pReceiveThreadParams,0L,&dwReceiveThreadId);
	_ASSERT(hReceiveThread!=NULL);
	if (NULL==hReceiveThread){
		return;
	}//endif

	//Wait till threads are running
	HANDLE rghWaitEvents[3];
	rghWaitEvents[0]=rghEvents[EVENTENUM_TICKLEREADY];
	rghWaitEvents[1]=rghEvents[EVENTENUM_TRANSMITREADY];
	rghWaitEvents[2]=rghEvents[EVENTENUM_RECEIVEREADY];
	if (WAIT_TIMEOUT==WaitForMultipleObjects(3,rghWaitEvents,TRUE,10000)){
		return;
	}//endif

	//Unlease the power
	SetEvent(rghEvents[EVENTENUM_TICKLESTART]);
	SetEvent(rghEvents[EVENTENUM_TRANSMITSTART]);
	SetEvent(rghEvents[EVENTENUM_RECEIVESTART]);

	//Run for timeframe
	Sleep(60000*pConfig->dwRuntime);

	//Execute staged shutdown
	SetEvent(rghEvents[EVENTENUM_TRANSMITSTOP]); //Signal transmit thread shutdown
	WaitForSingleObject(rghEvents[EVENTENUM_TRANSMITSTOPPED],5000);  //Wait for send buffers to flush
	Sleep(5000);  //Give extra time to process last few incoming commands
	SetEvent(rghEvents[EVENTENUM_TICKLESTOP]); //Signal tickle thread shutdown
	SetEvent(rghEvents[EVENTENUM_RECEIVESTOP]); //Signal receive thread shutdown
	SetEvent(rghEvents[EVENTENUM_CONTROLLOCKS]);  //Break any bad locks

	//Break any defunct channel connections
	for (UINT ui=0; ui<pConfig->dwChannels; ui++){
		pChannels->m_rgChannels[ui].pEngineEx->SetShutdownEvent();
	}//endfor

	//Reclaim receive thread
	if (WAIT_TIMEOUT==WaitForSingleObject(rghEvents[EVENTENUM_RECEIVESTOPPED],10000)){
		TerminateThread(hReceiveThread,-999);
	}//endfor
	CloseHandle(hReceiveThread);
	hReceiveThread=NULL;

	//Deallocate receive thread parameters
	if (NULL!=pReceiveThreadParams){
		delete pReceiveThreadParams;
		pReceiveThreadParams;
	}//endif

	//Reclaim tickle thread
	if (WAIT_TIMEOUT==WaitForSingleObject(rghEvents[EVENTENUM_TICKLESTOPPED],10000)){
		TerminateThread(hTickleThread,-999);
	}//endfor
	CloseHandle(hTickleThread);
	hTickleThread=NULL;

	//Deallocate tickle thread parameters
	if (NULL!=pTickleThreadParams){
		delete pTickleThreadParams;
		pTickleThreadParams;
	}//endif

	//Reclaim transmit thread
	if (WAIT_TIMEOUT==WaitForSingleObject(rghEvents[EVENTENUM_TRANSMITSTOPPED],10000)){
		TerminateThread(hTransmitThread,-999);
	}//endfor
	CloseHandle(hTransmitThread);
	hTransmitThread=NULL;

	//Deallocate transmit thread parameters
	if (NULL!=pTransmitThreadParams){
		delete pTransmitThreadParams;
		pTransmitThreadParams;
	}//endif

	//Deallocate connection channels
	if (NULL!=pChannels){
		delete pChannels;
		pChannels=NULL;
	}//endif

	//Deallocate control object
	if (NULL!=pControl){
		delete pControl;
		pControl=NULL;
	}//endif

	//Close synchronization events
	for (dwi=0; dwi<EVENTENUM_ENDENUM;dwi++){
		if (NULL!=rghEvents[dwi]){
			CloseHandle(rghEvents[dwi]);
			rghEvents[dwi]=NULL;
		}//endif
	}//endfor

	//Deallocate configuration object
	if (NULL!=pConfig){
		delete pConfig;
		pConfig=NULL;
	}//endif 

	//Closes the COM library on the current thread.
	CoUninitialize();

	//Bring winsock down
	WinsockDOWN();

	//Detect memory leaks
	_CrtDumpMemoryLeaks( );

}//endmain
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#define _WIN32_DCOM
#include "winsock2.h"
#include <windows.h>
#include <stdio.h>
#include <crtdbg.h>
#include <atlbase.h>

//QWORD Macros
#define MAKEULONGLONG(a, b) ((ULONGLONG)(((DWORD)(a)) | ((ULONGLONG)((DWORD)(b))) << 32))
#define MAKEQWORD(a, b)     MAKEULONGLONG((a),(b))
#define LODWORD(l)          ((DWORD)(l))
#define HIDWORD(l)          ((DWORD)(((ULONGLONG)(l) >> 32) & 0xFFFFFFFF))
typedef ULONGLONG           QWORD;
typedef QWORD               *LPQWORD;

//Other Macros & Definitions
#define RANDOMDWORD ((rand()%0xFF<<24)+(rand()%0xFF<<16)+(rand()%0xFF<<8)+rand()%0xFF)
#define TICKLEPORT 1001
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\tickles.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "tickles.h"
#include "connection.h"

/////////////////////////////////////////////////////////////////////////////
// TickleThreadFunc
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI TickleThreadFunc(LPVOID pData){

	//Counter
	DWORD dwcTICKLEs=0L;

	//Verify parameters
	if (NULL==pData){
		return -1;
	}//endif

	//Cast thread parameters 
	TickleThreadFuncParams* pParams=(TickleThreadFuncParams*)pData;
	Control* pControl=pParams->pControl;
	HANDLE hStop=pParams->hStop;
	HANDLE hStopped=pParams->hStopped;
	HANDLE hReady=pParams->hReady;
	HANDLE hStart=pParams->hStart;

	//Create UDP connection
	DWORD dwReceiveBufferSize=pControl->GetUserCount()*sizeof(Q_TICKLE_MSG);
	if (dwReceiveBufferSize>1048576*10){
		dwReceiveBufferSize=1048576*10;
	}//endif
	UDPConnection TickleCon(hStop,1,256,dwReceiveBufferSize);
	TickleCon.Bind(TICKLEPORT);

	//Statically allocate space for tickles
	Q_TICKLE_MSG Tickle;
	ZeroMemory(&Tickle,sizeof(Q_TICKLE_MSG));

	DWORD dwBytesRead=0L;  //Number of bytes read when tickle was retrieved
	DWORD dwUserIndex=0L;  //User index that matches userid
	TickleInfo* pTickle=NULL;  //Pointer to Queue object
	HANDLE hLock=NULL;  //Lock event

	SetEvent(hReady);
	WaitForSingleObject(hStart,INFINITE);

	//While it is not time to shutdown perform actions
	while (WAIT_OBJECT_0!=WaitForSingleObject(hStop,0)){

		//Retrieve a tickle
		dwBytesRead=0L;
		TickleCon.ReceiveFrom((char*)&Tickle,sizeof(Q_TICKLE_MSG),&dwBytesRead);
		if (dwBytesRead<sizeof(Q_TICKLE_MSG)){
			continue;
		}//endif

		//Update tickle information
		pControl->GetUserIndex(Tickle.qwUserID,&dwUserIndex);
		pTickle=pControl->GetTickleInfo(dwUserIndex,Tickle.dwQType,&hLock);
		if (NULL==pTickle){
			continue;
		}//endif
		pTickle->dwQLength=Tickle.dwQLength;
		ReleaseMutex(hLock);

		//Increment counter
		dwcTICKLEs++;

	}//endwhile
	
	//Output counters
	printf("TICKLE: %u\n",dwcTICKLEs);

	SetEvent(hStopped);

	return 0;

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\receive.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __RECEIVE_H_
#define __RECEIVE_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#include "channels.h"
#include "control.h"

//Transmit thread parameters structure
struct ReceiveThreadFuncParams{
	HANDLE hStop;  //Thread stop event
	HANDLE hStopped;  //Thread is stopped event
	HANDLE hReady;  //Thread is ready to execute event
	HANDLE hStart;  //Thread start event
	Control* pControl;  //Pointer to application control
	Channels* pChannels;  //Pointer to connection channels
};//endstruct

/////////////////////////////////////////////////////////////////////////////
// Thread that receives and processes incoming data
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI ReceiveThreadFunc(LPVOID pData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\tickles.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __TICKLES_H_
#define __TICKLES_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#include "xqprotocol.h"
#include "control.h"

//Tickle thread parameters structure
struct TickleThreadFuncParams{
	HANDLE hStop;  //Thread stop event
	HANDLE hStopped;  //Thread is stopped event
	HANDLE hReady;  //Thread is ready event
	HANDLE hStart;  //Thread start event
	Control* pControl;  //Pointer to application control
};//endstruct

/////////////////////////////////////////////////////////////////////////////
// Thread function that receives and processes all tickle notifications
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI TickleThreadFunc(LPVOID pData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\transmit.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __TRANSMIT_H_
#define __TRANSMIT_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#include "channels.h"
#include "control.h"
#include "config.h"

//Transmit thread parameters structure
struct TransmitThreadFuncParams{
	HANDLE hStop;  //Thread stop event
	HANDLE hStopped;  //Thread is stopped event
	HANDLE hReady;  //Thread is ready event
	HANDLE hStart;  //Thread start event
	Control* pControl;  //Pointer to application control
	Channels* pChannels;  //Pointer to connection channels
	Configuration* pConfig;  //Pointer to application configuration
};//endstruct

/////////////////////////////////////////////////////////////////////////////
// Transmit thread that performs actions against XNQ
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI TransmitThreadFunc(LPVOID pData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qstress\transmit.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "transmit.h"
#include <comdef.h>

#define XRGPLACEHOLDER 0
#define XIPPLACEHOLDER 0

/////////////////////////////////////////////////////////////////////////////
// TransmitThreadFunc
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI TransmitThreadFunc(LPVOID pData){

	//Counters
	DWORD dwcADDs=0L;
	DWORD dwcDELETEs=0L;
	DWORD dwcLISTs=0L;
	DWORD dwcUSERINFOs=0L;
	DWORD dwcDEADXIPs=0L;

	//Verify parameters
	if (NULL==pData){
		return -1;
	}//endif

	//Initializes the COM library for use by the calling thread and sets the thread's concurrency model.
	if FAILED(CoInitializeEx(NULL,COINIT_MULTITHREADED)){
		return -1;
	}//endif

	//Cast parameters 
	TransmitThreadFuncParams* pParams=(TransmitThreadFuncParams*)pData;
	Channels* pChannels=pParams->pChannels;
	Control* pControl=pParams->pControl;
	Configuration* pConfig=pParams->pConfig;
	HANDLE hStop=pParams->hStop;
	HANDLE hStopped=pParams->hStopped;
	HANDLE hReady=pParams->hReady;
	HANDLE hStart=pParams->hStart;

	//Get the ip address of the local machine
	DWORD dwLocalIP;
	char pszHostname[256];
	gethostname(pszHostname,sizeof(pszHostname));
	_bstr_t bstrHostname(pszHostname);
	pChannels->m_rgChannels[0].pEngine->InternetAddress(bstrHostname,&dwLocalIP);

	//Store servername
	_bstr_t bstrServerName(pConfig->pszServerName);

	//Allocate space for multiple destinations
	QWORD* rgqwDestUserId=new QWORD[pConfig->dwDestinations];

	//Allocate items for each type of queue
	BYTE** rgrgbData=NULL;
	rgrgbData=new BYTE*[pConfig->dwQueues];
	for (DWORD dwi=0L; dwi<pConfig->dwQueues; dwi++){
		rgrgbData[dwi]=new BYTE[pConfig->rgdwMinSize[dwi]];
		memset(rgrgbData[dwi],0xFF,pConfig->rgdwMinSize[dwi]);
	}//endfor

	//Get number of users and channels
	DWORD dwcUsers=pControl->GetUserCount();
	DWORD dwcQueues=pControl->GetQueuesPerUserCount();
	UINT uicChannels=pChannels->GetNumOfChannels();

	//State pointers
	OpStateInfo* pOpStateInfo=NULL;
	AckInfo* pAckInfo=NULL;
	ListReplyInfo* pListReplyInfo=NULL;
	TickleInfo* pTickleInfo=NULL;

	//Common case
	DWORD dwUserIndex=0L;  //Random user
	UINT uiChannel=0;
	QWORD qwUserId=MAKEQWORD(0L,0L);
	DWORD dwSequence=0L;
	dwi=0L;
	QWORD qwQUID=MAKEQWORD(0L,0L);
	HANDLE hLock=NULL;

	//Add case
	DWORD dwBuddyIndex=0L;
	UINT uicDestinations=0;
	UINT uicActualDestinations=0;
	UINT uiQueue=0;

	//List case
	QWORD qwCookie=MAKEQWORD(0L,0L);
	DWORD dwMaxItems=0L;

	SetEvent(hReady);
	WaitForSingleObject(hStart,INFINITE);

	//While not time to shutdown perform actions
	while (WAIT_OBJECT_0!=WaitForSingleObject(hStop,0)){

		//Pick a random channel
		uiChannel=rand()%uicChannels;

		//Choose a random userid (rand sucks it choses a number between 0 and RAND_MAX=0x7fff)
		dwUserIndex=((rand()%0xff<<24)+(rand()%0xff<<16)+(rand()%0xff<<8)+rand()%0xff)%dwcUsers;

		//Get the operational state
		pOpStateInfo=pControl->GetOpStateInfo(dwUserIndex);
		if (NULL==pOpStateInfo){
			continue;
		}//endif

		//Get user id and sequence number
		qwUserId=pOpStateInfo->qwUserId;
		dwSequence= ++(pOpStateInfo->dwSequence);

		//Hash the connection (channel)
		uiChannel = (UINT)(qwUserId % uicChannels);

		/***********/
		/* CONNECT */
		/***********/

		if (false==pChannels->m_rgChannels[uiChannel].fUp){

			//Connect to server
			if FAILED(pChannels->m_rgChannels[uiChannel].pEngine->Connect(bstrServerName,pConfig->dwPort)){
				//TODO: ADD WARNING
				continue;
			}//endif

			//Send HELLO
			if FAILED(pChannels->m_rgChannels[uiChannel].pEngineEx->MsgHelloEx(false,0L,dwSequence,MAKELONG(9,0),OLESTR("QSTRESS"),7L)){
				//TODO: ADD WARNING
				continue;
			}//endif

			//Mark connection (channel) as up
			pChannels->m_rgChannels[uiChannel].fUp=true;

			continue;

		}//endif CONNECT

		/************/
		/* USERINFO */
		/************/

		//Only send a user info if one has not been sent before
		if (opstate_do_userinfos==pOpStateInfo->uiState){
	
			//Clear ack receipt
			pAckInfo=pControl->GetAckInfo(dwUserIndex,&hLock);
			pAckInfo->fAckReceived=FALSE;
			ReleaseMutex(hLock);

			//Send USERINFO
			pOpStateInfo->qwXIP=MAKEQWORD(RANDOMDWORD,RANDOMDWORD);
			if FAILED(pChannels->m_rgChannels[uiChannel].pEngineEx->MsgUserInfoEx(true,LODWORD(pOpStateInfo->qwXIP),dwSequence,qwUserId,pOpStateInfo->qwXIP,XRGPLACEHOLDER,dwLocalIP,TICKLEPORT)){
				//TODO: ADD WARNING
				continue;
			}//endif

			pOpStateInfo->dwTimeToDie=(RANDOMDWORD%(pConfig->dwMaxLifetime*1000))+GetTickCount();
			pOpStateInfo->uiState=opstate_do_adds;
			
			dwcUSERINFOs++;

			continue;

		}//endif USERINFO

		/***********/
		/* DEADXIP */
		/***********/

		if (GetTickCount()>=pOpStateInfo->dwTimeToDie){
			qwQUID=pOpStateInfo->qwXIP;
			pOpStateInfo->uiState=opstate_do_userinfos;
			for (dwi=0L; dwi<dwcUsers; dwi++){
				pOpStateInfo=pControl->GetOpStateInfo(dwi);
				if (NULL==pOpStateInfo){
					break;
				}//endif
				if (pOpStateInfo->qwXIP==qwQUID){
					if FAILED(pChannels->m_rgChannels[uiChannel].pEngineEx->MsgDeadXIPEx(false,LODWORD(pOpStateInfo->qwXIP),dwSequence,pOpStateInfo->qwXIP)){
						//TODO: ADD WARNING
						continue;
					}//endif
					pOpStateInfo->uiState=opstate_do_userinfos;
					pAckInfo=pControl->GetAckInfo(dwi,&hLock);
					pAckInfo->fAckReceived=FALSE;
					ReleaseMutex(hLock);
					dwcDEADXIPs++;
				}//endif
			}//endfor
			continue;
		}//endif

		/*******/
		/* ADD */
		/*******/

		pAckInfo=pControl->GetAckInfo(dwUserIndex,NULL);
		if ((opstate_do_adds==pOpStateInfo->uiState) && (TRUE==pAckInfo->fAckReceived)){

			//Random parameters
			uicDestinations=(rand()%(pConfig->dwDestinations-1))+1;
			uicActualDestinations=0;
			uiQueue=rand()%pConfig->dwQueues;

			//Populate destination list with users
			for (dwi=0; dwi<uicDestinations; dwi++){

				//Choose a random buddy index
				dwBuddyIndex=((rand()%0xff<<24)+(rand()%0xff<<16)+(rand()%0xff<<8)+rand()%0xff)%dwcUsers;

				//Check if destination has a queue
				pAckInfo=pControl->GetAckInfo(dwBuddyIndex,NULL);
				if (FALSE==pAckInfo->fAckReceived){
					continue;
				}//endif
				
				//Add destination to list
				rgqwDestUserId[uicActualDestinations]=pControl->GetOpStateInfo(dwBuddyIndex)->qwUserId;
				if ((TRUE==pConfig->rgfDuplicates[uiQueue]) || (0==pControl->GetOpStateInfo(dwBuddyIndex)->dwItemsAdded)){
					pControl->GetOpStateInfo(dwBuddyIndex)->dwItemsAdded++;
				}//endif
				uicActualDestinations++;

				//Clear tickle queue size
				pTickleInfo=pControl->GetTickleInfo(dwBuddyIndex,uiQueue,&hLock);
				pTickleInfo->dwQLength=0;
				ReleaseMutex(hLock);

			}//endif

			//Anyone's queue around to add to?
			if (0==uicActualDestinations){
				continue;
			}//endif

			//Perform action
			if (FAILED(pChannels->m_rgChannels[uiChannel].pEngineEx->MsgAddEx(false,LODWORD(pOpStateInfo->qwXIP),dwSequence,rgqwDestUserId,uicActualDestinations,uiQueue,rgrgbData[uiQueue],pConfig->rgdwMinSize[uiQueue]))){
				//TODO: ADD WARNING
				continue;
			}//endif

			pOpStateInfo->uiState=opstate_do_lists;

			dwcADDs++;

			continue;

		}//endif ADD

		/********/
		/* LIST */
		/********/

		if (opstate_do_lists==pOpStateInfo->uiState){

			qwCookie=MAKEQWORD(RANDOMDWORD,RANDOMDWORD);

			for (dwi=0; dwi<dwcQueues;dwi++){
				
				//Tickle controlled or based on internal state?
				if (TRUE==pConfig->fTickleControl){

					//Any thing to list in this queue?
					pTickleInfo=pControl->GetTickleInfo(dwUserIndex,dwi,NULL);
					if (pTickleInfo->dwQLength==0){
						continue;  //continue for loop
					}//endif

					dwMaxItems=rand()%pTickleInfo->dwQLength+1;

				}else{

					//Any thing to list in this queue?
					pOpStateInfo=pControl->GetOpStateInfo(dwUserIndex);
					if (pOpStateInfo->dwItemsAdded==0){
						continue;
					}//endif

					dwMaxItems=rand()%pOpStateInfo->dwItemsAdded+1;

				}//endif

				//Clear list reply acknowledgement
				pListReplyInfo=pControl->GetListReplyInfo(dwUserIndex,dwi,&hLock);
				pListReplyInfo->fListReplyReceived=FALSE;
				qwQUID=pListReplyInfo->qwNextQUID;
				ReleaseMutex(hLock);

				//Perform action
				if FAILED(pChannels->m_rgChannels[uiChannel].pEngineEx->MsgListEx(false,LODWORD(pOpStateInfo->qwXIP),dwSequence,qwUserId,dwi,qwCookie,/*startquid*/qwQUID,dwMaxItems,0xFFFFFFFF)){
					//TODO: ADD WARNING
					continue;
				}//endif

				pOpStateInfo->uiState=opstate_do_deletes;

				dwcLISTs++;

			}//endfor

			continue;

		}//endif LIST

		/**********/
		/* DELETE */
		/**********/

		if (opstate_do_deletes==pOpStateInfo->uiState){

			for (dwi=0; dwi<dwcQueues;dwi++){

				//Do we have a list reply on this queue yet?
				pListReplyInfo=pControl->GetListReplyInfo(dwUserIndex,dwi,NULL);
				if (FALSE==pListReplyInfo->fListReplyReceived){
					continue;
				}//endif

				qwQUID=pListReplyInfo->qwNextQUID;
				if (0==qwQUID){
					qwQUID=MAKEQWORD(0xFFFF,0xFFFF);
				}else{
					qwQUID--;
				}//endif

				//Perform action
				if FAILED(pChannels->m_rgChannels[uiChannel].pEngineEx->MsgDeleteEx(false,LODWORD(pOpStateInfo->qwXIP),dwSequence,uiQueue,qwUserId,MAKEQWORD(0L,0L),qwQUID)){
					//TODO: ADD WARNING
					continue;
				}//endif
	
				pOpStateInfo=pControl->GetOpStateInfo(dwUserIndex);
				pOpStateInfo->dwItemsAdded-=pListReplyInfo->dwNumItems;
				if (pOpStateInfo->dwItemsAdded>0){
					pOpStateInfo->uiState=opstate_do_lists;
				}else{
					pOpStateInfo->uiState=opstate_do_adds;
				}//endif

				dwcDELETEs++;

			}//endfor

			continue;

		}//endif XACTION_DELETE

		continue;

	}//endwhile

	//Deallocate destinations
	if (NULL!=rgqwDestUserId){
		delete [] rgqwDestUserId;
		rgqwDestUserId=NULL;
	}//endif

	//Deallocate queue item data
	for (dwi=0L; dwi<pConfig->dwQueues;dwi++){
		if (NULL!=rgrgbData[dwi]){
			delete [] rgrgbData[dwi];
			rgrgbData[dwi]=0L;
		}//endif
	}//endfor
	if (NULL!=rgrgbData){
		delete [] rgrgbData;
		rgrgbData=NULL;
	}//endif

	//Closes the COM library on the current thread.
	CoUninitialize();

	//Output counters
	printf("ADD: %u\n",dwcADDs);
	printf("DELETE: %u\n",dwcDELETEs);
	printf("LIST: %u\n",dwcLISTs);
	printf("USERINFO: %u\n",dwcUSERINFOs);
	printf("DEADXIP: %u\n",dwcDEADXIPs);

	for (dwi=0; dwi<uicChannels;dwi++){
		pChannels->m_rgChannels[dwi].pEngineEx->Flush(12000);
	}//endfor

	SetEvent(hStopped);

	return 0;

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "qtest_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B002CD32_269B_47AA_8B8E_00D9B3C5396F__INCLUDED_)
#define AFX_DLLDATAX_H__B002CD32_269B_47AA_8B8E_00D9B3C5396F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B002CD32_269B_47AA_8B8E_00D9B3C5396F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\engine.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// engine.h : Declaration of the Cengine

#ifndef __ENGINE_H_
#define __ENGINE_H_

#include "resource.h"       // main symbols
#include "connection.h"		// connection
#include "xqprotocol.h"		// protocol structures

/////////////////////////////////////////////////////////////////////////////
// Cengine
class ATL_NO_VTABLE Cengine : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<Cengine, &CLSID_engine>,
	public ISupportErrorInfo,
	public IengineEx,
	public IDispatchImpl<Iengine, &IID_Iengine, &LIBID_QTESTLib>
{
public:
	Cengine()
	{
	}
	~Cengine()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ENGINE)
DECLARE_NOT_AGGREGATABLE(Cengine)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Cengine)
	COM_INTERFACE_ENTRY(Iengine)
	COM_INTERFACE_ENTRY(IengineEx)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// Iengine
public:
	STDMETHOD(Flush)(/*[in]*/ unsigned long ulTimeout);
	STDMETHOD(CleanupEx)();
	STDMETHOD(Cleanup)();
	STDMETHOD(Init)();
	STDMETHOD(SetShutdownEvent)();
	STDMETHOD(GetResponseData)(/*[in]*/ BYTE* rgbData,/*[in]*/ unsigned long ulDataLen, /*[in,out]*/ unsigned long* pulDataLen);
	STDMETHOD(InitEx)(/*[in]*/ unsigned long ulcSendBuffers, /*[in]*/ unsigned long ulcSendBufferSize, /*[in]*/ long lcReceiveBufferSize);
	STDMETHOD(MsgAddEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG* rgqwUserIds, /*[in]*/ unsigned long ulNumUsers, /*[in]*/ unsigned long ulQType, /*[in]*/ BYTE* rgbData, /*[in]*/ unsigned long ulDataLen);
	STDMETHOD(MsgDeadXIPEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwXIP);
	STDMETHOD(MsgDeadXRGEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwXRG);
	STDMETHOD(MsgDeleteEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulQType, /*[in]*/ ULONGLONG qwUserId, /*[in]*/ ULONGLONG qwFirstQUID, /*[in]*/ ULONGLONG qwLastQUID);
	STDMETHOD(MsgDeleteMatchesEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG* rgqwUserIds, /*[in]*/ unsigned long ulNumUsers, /*[in]*/ unsigned long ulQType, /*[in]*/ unsigned long ulMatchAttrNum, /*[in]*/ BYTE* rgbData, /*[in]*/ unsigned long ulDataLen);
	STDMETHOD(MsgHelloEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulVersion, /*[in]*/ BSTR bstrDescription, /*[in]*/ unsigned int uiLen=0);
	STDMETHOD(MsgListEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwUserId, /*[in]*/ unsigned long ulQType, /*[in]*/ ULONGLONG qwCookie, /*[in]*/ ULONGLONG qwStartQUID, /*[in]*/ unsigned long ulMaxItems, /*[in]*/ unsigned long ulTotalItemDataSize);
	STDMETHOD(MsgUserInfoEx)(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwUserId, /*[in]*/ ULONGLONG qwXIP, /*[in]*/ ULONGLONG qwXRG, /*[in]*/ unsigned long ulTickleIP, /*[in]*/ unsigned short usTicklePort);

	STDMETHOD(Connect)(/*[in]*/ BSTR bstrHost, /*[in]*/ unsigned int uiPort);
	STDMETHOD(Disconnect)();
	STDMETHOD(GetACKElement)(/*[in]*/ BSTR bstrElementName, /*[out,retval]*/ unsigned long *pulElement);
	STDMETHOD(GetListReplyElement)(/*[in]*/BSTR bstrElementName, /*[out,retval]*/ unsigned long *pulElement);
	STDMETHOD(GetListReplyItemElement)(/*[in]*/ unsigned long ulItem, /*[in]*/ BSTR bstrElementName, /*[out,retval]*/ VARIANT* pElement);
	STDMETHOD(GetMessageElement)(/*[in]*/ BSTR bstrElementName, /*[out,retval]*/ unsigned long* pulElement);
	STDMETHOD(GetReplyType)(/*[out, retval]*/ unsigned long* pulMsgReplyType);
	STDMETHOD(GetTickleElement)(/*[in]*/ BSTR bstrElementName, /*[out,retval]*/ unsigned long* pulElement);
	STDMETHOD(InternetAddress)(/*[in]*/ BSTR bstrHost, /*[out,retval]*/ unsigned long* pulIP);
	STDMETHOD(MsgAdd)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ BSTR bstrUsers, /*[in]*/ unsigned long ulNumUsers, /*[in]*/ unsigned long ulQType, /*[in]*/ BSTR bstrData, /*[in]*/ unsigned long ulDataLen);
	STDMETHOD(MsgDelete)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulQType, /*[in]*/ unsigned long ulHiUserId, /*[in]*/ unsigned long ulLoUserId, /*[in]*/ unsigned long ulHiFirstQUID, /*[in]*/ unsigned long ulLoFirstQUID, /*[in]*/ unsigned long ulHiLastQUID, /*[in]*/ unsigned long ulLoLastQUID);
	STDMETHOD(MsgDeleteMatches)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence,  /*[in]*/ BSTR bstrUsers, /*[in]*/ unsigned long ulNumUsers, /*[in]*/ unsigned long ulQType, /*[in]*/ unsigned long ulMatchAttrNum, /*[in]*/ BSTR bstrData, /*[in]*/ unsigned long ulDataLen);
	STDMETHOD(MsgDeadXIP)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulHiXIP, /*[in]*/ unsigned long ulLoXIP);
	STDMETHOD(MsgDeadXRG)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulHiXRG, /*[in]*/ unsigned long ulLoXRG);
	STDMETHOD(MsgHello)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulVersion, /*[in]*/ BSTR bstrDescription, /*[in]*/ unsigned int uiLen=0);
	STDMETHOD(MsgList)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulHiUserId, /*[in]*/ unsigned long ulLoUserId, /*[in]*/ unsigned long ulQType, /*[in]*/ unsigned long ulHiCookie, /*[in]*/ unsigned long ulLoCookie, /*[in]*/ unsigned long ulHiStartQUID, /*[in]*/ unsigned long ulLoStartQUID, /*[in]*/ unsigned long ulMaxItems, /*[in]*/ unsigned long ulTotalItemDataSize);
	STDMETHOD(MsgUserInfo)(/*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulHiUserId, /*[in]*/ unsigned long ulLoUserId, /*[in]*/ unsigned long ulHiXIP, /*[in]*/ unsigned long ulLoXIP, /*[in]*/ unsigned long ulHiXRG, /*[in]*/ unsigned long ulLoXRG, /*[in]*/ unsigned long ulTickleIP, /*[in]*/ unsigned short usTicklePort);
	STDMETHOD(TickleListen)(/*[in]*/ VARIANT_BOOL fOn, /*[in]*/ unsigned short usTicklePort);
	STDMETHOD(WaitForDisconnect)(/*[in]*/int iTimeout, /*[out,retval]*/ VARIANT_BOOL* pfConnected);
	STDMETHOD(WaitForReply)(/*[in]*/ unsigned long ulTimeout, /*[out,retval]*/ VARIANT_BOOL* pfTimeout);
	STDMETHOD(WaitForTickle)(/*[in]*/ unsigned long ulTimeout, /*[out,retval]*/ VARIANT_BOOL* pfTimeout);

private:
	static DWORD WINAPI TickleThreadFunc(LPVOID pData, HANDLE hShutdownEvent);

private:
	bool m_fInit;  //Initialized?
	BYTE m_rgbData[2048];  //Preallocated dump area
	DWORD m_dwDumped;  //Preallocated temp variable
	BYTE m_rgbReply[2048];  //Store 1 list reply
	DWORD m_dwMsgReplyType; //Message reply type

	//Outgoing connection related
	TCPClientConnection* m_pClient;  //TCP communications client
	HANDLE m_hShutdownEvent;  //Shutdown event

	//Tickle processing (Iengine)
	UDPConnection* m_pTickleCon; //UDP connection for receiving tickles
	bool m_fTickle; //Do we have one?

	//Preallocate msg structure for speed improvement (Iengine & IengineEx)
	Q_HELLO_MSG m_qHelloMsg;
	Q_USER_INFO_MSG m_qUserInfoMsg;
	Q_DEAD_XIP_MSG m_qDeadXIPMsg;
	Q_DEAD_XRG_MSG m_qDeadXRGMsg;
	Q_DELETE_MSG m_qDeleteMsg;
	Q_ADD_MSG m_qAddMsg;
	Q_LIST_MSG m_qListMsg;
	Q_DELETE_MATCHES_MSG m_qDeleteMatchesMsg;
	Q_TICKLE_MSG m_qTickle;

};

#endif //__ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\qtest.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// qtest.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for qtest.idl by adding the following 
//      files to the Outputs.
//          qtest_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f qtestps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "qtest.h"
#include "dlldatax.h"

#include "qtest_i.c"
#include "engine.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_engine, Cengine)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_QTESTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__39A8F8C0_E8B4_4F74_8277_A41CB617F914__INCLUDED_)
#define AFX_STDAFX_H__39A8F8C0_E8B4_4F74_8277_A41CB617F914__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
#include "winsock2.h"

#endif // !defined(AFX_STDAFX_H__39A8F8C0_E8B4_4F74_8277_A41CB617F914__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtickle\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by qtickle.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtickle\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "winsock2.h"  //using winsock2
#include <windows.h>  //standard windows includes
#include <stdio.h>  //standard io
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by qtest.rc
//
#define IDS_PROJNAME                    100
#define IDR_ENGINE                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtest\engine.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// engine.cpp : Implementation of Cengine
#include "stdafx.h"
#include "Qtest.h"
#include "engine.h"
#include <comdef.h>

/////////////////////////////////////////////////////////////////////////////
// Helper template functions

template <class T> HRESULT Dump( T* src, BYTE* rgbDest, DWORD dwDestLen, DWORD* pdwDumped){

	DWORD dwT=sizeof(T);

	if ((dwT>dwDestLen) || (NULL==rgbDest) || (NULL==src))
		return E_INVALIDARG;

	((BASE_MSG_HEADER*)src)->dwMsgLen=dwT-sizeof(BASE_MSG_HEADER);
	memcpy((void*)rgbDest,src,dwT);
	*pdwDumped=dwT;

	//success
	return S_OK;

}//endmethod

template <class T> HRESULT Dump( T* src, const BYTE* rgbExtendedData, DWORD dwExtendedDataLen, BYTE* rgbDest, DWORD dwDestLen, DWORD* pdwDumped){

	DWORD dwT=sizeof(T);
	DWORD dwALL=dwT+dwExtendedDataLen;

	if ((dwALL>dwDestLen) || (NULL==rgbDest) || (NULL==src) || (NULL==rgbExtendedData))
		return E_INVALIDARG;

	((BASE_MSG_HEADER*)src)->dwMsgLen=dwALL-sizeof(BASE_MSG_HEADER);
	memcpy((void*)rgbDest,src,dwT);
	memcpy((void*)(rgbDest+dwT),rgbExtendedData,dwExtendedDataLen);
	*pdwDumped=dwALL;

	//success
	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Cengine

STDMETHODIMP Cengine::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_Iengine
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
#ifndef USE_VC7_WINDOWS
		if (::ATL::InlineIsEqualGUID(*arr[i],riid))
#else
		if (InlineIsEqualGUID(*arr[i],riid))
#endif
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP Cengine::Connect(BSTR bstrHost, unsigned int uiPort)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//BSTR wrapper
	_bstr_t l_bstrHost(bstrHost);

	//Convert address
	DWORD dwIP=::InternetAddress(l_bstrHost);

	//Connect to host
	if FAILED(m_pClient->Connect(dwIP,(WORD)uiPort)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::Disconnect()
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	m_pClient->Close(false);

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::GetACKElement(BSTR bstrElementName, unsigned long *pulElement)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Did we receive a reply?
	if (m_dwMsgReplyType!=MSGTYPE_ACK) {
		return E_FAIL;
	}//endif

	BASE_ACK_MSG* pAck;
	pAck=(BASE_ACK_MSG*)m_rgbReply;

	//BSTR wrapper
	_bstr_t l_bstrName(bstrElementName);

	//Return requested element
	if (0==_stricmp(l_bstrName,"ackmsgtype")){
		*pulElement=pAck->dwAckMsgType;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"ackseqnum")){
		*pulElement=pAck->dwAckSeqNum;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"hr")){
		*pulElement=pAck->hrAck;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"louserid")){
		*pulElement=LODWORD(pAck->qwAckUserID);
	}//endif
	if (0==_stricmp(l_bstrName,"hiuserid")){
		*pulElement=HIDWORD(pAck->qwAckUserID);
	}//endif

	//Element not found
	return E_FAIL;

}//endemthod

STDMETHODIMP Cengine::GetListReplyElement(BSTR bstrElementName, unsigned long *pulElement)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Did we receive a reply?
	if (m_dwMsgReplyType!=QMSG_LIST_REPLY) {
		return E_FAIL;
	}//endif

	Q_LIST_REPLY_MSG* pReply;
	pReply=(Q_LIST_REPLY_MSG*)m_rgbReply;

	//BSTR wrapper
	_bstr_t l_bstrName(bstrElementName);

	//Return requested element
	if (0==_stricmp(l_bstrName,"hiuserid")){
		*pulElement=HIDWORD(pReply->qwUserID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"louserid")){
		*pulElement=LODWORD(pReply->qwUserID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"qtype")){
		*pulElement=pReply->dwQType;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"hicookie")){
		*pulElement=HIDWORD(pReply->qwCookie);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"locookie")){
		*pulElement=LODWORD(pReply->qwCookie);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"hinextquid")){
		*pulElement=HIDWORD(pReply->qwNextQUID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"lonextquid")){
		*pulElement=LODWORD(pReply->qwNextQUID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"qleft")){
		*pulElement=pReply->dwQLeft;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"numitems")){
		*pulElement=pReply->dwNumItems;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"hr")){
		*pulElement=pReply->hr;
		return S_OK;
	}//endif

	//Element not found
	return E_FAIL;

}//endmethod

STDMETHODIMP Cengine::GetListReplyItemElement(unsigned long ulItem, BSTR bstrElementName, VARIANT *pElement)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Did we receive a reply?
	if (m_dwMsgReplyType!=QMSG_LIST_REPLY) {
		return E_FAIL;
	}//endif

	Q_LIST_REPLY_MSG* pReply;
	pReply=(Q_LIST_REPLY_MSG*)m_rgbReply;

	//Make sure item index is valid
	if ((pReply->dwNumItems<ulItem-1)||(ulItem<=0)){
		return E_FAIL;
	}//endif

	Q_LIST_ITEM* pItem;
	BYTE* pb=m_rgbReply+sizeof(Q_LIST_REPLY_MSG);
	for (unsigned long ul=0; ul<ulItem; ul++){
		pItem=(Q_LIST_ITEM*)pb;
		pb=((BYTE*)(pItem))+sizeof(Q_LIST_ITEM)+pItem->dwItemLen;
	}//endfor

	//BSTR wrapper
	_bstr_t l_bstrName(bstrElementName);

	if (0==_stricmp(l_bstrName,"hiquid")){
		pElement->vt=VT_I4;
		pElement->lVal=HIDWORD(pItem->qwQUID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"loquid")){
		pElement->vt=VT_I4;
		pElement->lVal=LODWORD(pItem->qwQUID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"qtype")){
		pElement->vt=VT_I4;
		pElement->lVal=pItem->dwItemLen;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"data")){
		pElement->vt=VT_BSTR;
		int iLen=pItem->dwItemLen;
		pb=((BYTE*)(pItem))+sizeof(Q_LIST_ITEM);
	
		//Convert array of lo bytes back to BSTR
		BYTE* rgbPacket;
		rgbPacket=new BYTE[iLen*2];
		for (int i=0; i<iLen; i++){
			rgbPacket[i*2]=pb[i];
			rgbPacket[i*2+1]=0;
		}//endfor
		pElement->bstrVal=SysAllocStringByteLen((char*)rgbPacket,iLen*2);
		delete [] rgbPacket;

		return S_OK;
	}//endif

	//Element not found
	return E_FAIL;

}//endmethod

STDMETHODIMP Cengine::GetMessageElement(BSTR bstrElementName, unsigned long *pulElement)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Did we receive a reply?
	if (QMSG_MAX_REPLY_TYPE+1==m_dwMsgReplyType) {
		return E_FAIL;
	}//endif

	BASE_MSG_HEADER* pMsg;
	pMsg=(BASE_MSG_HEADER*)m_rgbReply;

	//BSTR wrapper
	_bstr_t l_bstrName(bstrElementName);

	//Return requested element
	if (0==_stricmp(l_bstrName,"msglen")){
		*pulElement=pMsg->dwMsgLen;
		return S_OK;
	}//endif

	//Return requested element
	if (0==_stricmp(l_bstrName,"msgtype")){
		*pulElement=pMsg->dwMsgType;
		return S_OK;
	}//endif

	//Return requested element
	if (0==_stricmp(l_bstrName,"seqnum")){
		*pulElement=pMsg->dwSeqNum;
		return S_OK;
	}//endif

	//Return requested element
	if (0==_stricmp(l_bstrName,"sessid")){
		*pulElement=pMsg->dwSessID;
		return S_OK;
	}//endif

	//Element not found
	return E_FAIL;

}//endmethod

STDMETHODIMP Cengine::GetReplyType(unsigned long* pulMsgReplyType)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//No reply yet
	if (QMSG_MAX_REPLY_TYPE+1==m_dwMsgReplyType)
		return E_FAIL;

	*pulMsgReplyType=m_dwMsgReplyType;

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::GetTickleElement(BSTR bstrElementName, unsigned long *pulElement)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	if (false==m_fTickle){
		return E_FAIL;
	}//endif

	//BSTR wrapper
	_bstr_t l_bstrName(bstrElementName);

	//Return requested element
	if (0==_stricmp(l_bstrName,"hiuserid")){
		*pulElement=HIDWORD(m_qTickle.qwUserID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"louserid")){
		*pulElement=LODWORD(m_qTickle.qwUserID);
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"qtype")){
		*pulElement=m_qTickle.dwQType;
		return S_OK;
	}//endif
	if (0==_stricmp(l_bstrName,"qlength")){
		*pulElement=m_qTickle.dwQLength;
		return S_OK;
	}//endif

	//element not found
	return E_FAIL;

}//endmethod

STDMETHODIMP Cengine::InternetAddress(BSTR bstrHost, unsigned long* pulIP)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//BSTR wrapper
	_bstr_t l_bstrHost(bstrHost);

	//Convert
	*pulIP=ntohl(::InternetAddress(l_bstrHost));
	if (INADDR_NONE == *pulIP){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgAdd(unsigned long ulSessionId, unsigned long ulSequence, BSTR bstrUsers, unsigned long ulNumUsers, unsigned long ulQType, BSTR bstrData, unsigned long ulDataLen)
{
	HRESULT hr=S_OK;

	//Convert BSTR to array of lo bytes
	BYTE* rgbUsers;
	rgbUsers=new BYTE[ulNumUsers*sizeof(QWORD)];
	for (unsigned long ul=0;ul<ulNumUsers*sizeof(QWORD);ul++){
		rgbUsers[ul]=LOBYTE(bstrUsers[ul]);
	}//endfor
	
	//Convert users string to QWORDs
	QWORD* rgqwUserIds=new QWORD[ulNumUsers];
	BYTE* pb=rgbUsers;
	for (ul=0;ul<ulNumUsers;ul++){
		rgqwUserIds[ul]=MAKEQWORD(MAKELONG(MAKEWORD(pb[7],pb[6]),MAKEWORD(pb[5],pb[4])),MAKELONG(MAKEWORD(pb[3],pb[2]),MAKEWORD(pb[1],pb[0])));
		pb+=sizeof(QWORD);
	}//endfor

	//Convert BSTR to array of lo bytes
	BYTE* rgbData;
	rgbData=new BYTE[ulDataLen];
	for (ul=0;ul<ulDataLen;ul++){
		rgbData[ul]=LOBYTE(bstrData[ul]);
	}//endfor

	//Call extended method
	hr=MsgAddEx(true, ulSessionId, ulSequence, rgqwUserIds, ulNumUsers, ulQType, rgbData, ulDataLen);
	
	//Cleanup
	delete [] rgbUsers;
	delete [] rgbData;
	delete [] rgqwUserIds;

	return hr;

}//endmethod

STDMETHODIMP Cengine::MsgDeadXIP(unsigned long ulSessionId, unsigned long ulSequence, unsigned long ulHiXIP, unsigned long ulLoXIP)
{
	return MsgDeadXIPEx(true, ulSessionId, ulSequence, MAKEQWORD(ulLoXIP,ulHiXIP));
}//endmethod

STDMETHODIMP Cengine::MsgDeadXRG(unsigned long ulSessionId, unsigned long ulSequence, unsigned long ulHiXRG, unsigned long ulLoXRG)
{
	return MsgDeadXRGEx(true, ulSessionId, ulSequence, MAKEQWORD(ulLoXRG,ulHiXRG));
}//endmethod

STDMETHODIMP Cengine::MsgDelete(unsigned long ulSessionId, unsigned long ulSequence, unsigned long ulQType, unsigned long ulHiUserId, unsigned long ulLoUserId, unsigned long ulHiFirstQUID, unsigned long ulLoFirstQUID, unsigned long ulHiLastQUID, unsigned long ulLoLastQUID)
{
	return MsgDeleteEx(true, ulSessionId, ulSequence, ulQType, MAKEQWORD(ulLoUserId,ulHiUserId), MAKEQWORD(ulLoFirstQUID,ulHiFirstQUID), MAKEQWORD(ulLoLastQUID,ulHiLastQUID));
}//endmethod

STDMETHODIMP Cengine::MsgDeleteMatches(unsigned long ulSessionId, unsigned long ulSequence, BSTR bstrUsers, unsigned long ulNumUsers, unsigned long ulQType, unsigned long ulMatchAttrNum, BSTR bstrData, unsigned long ulDataLen)
{
	HRESULT hr=S_OK;

	//Convert BSTR to array of lo bytes
	BYTE* rgbUsers;
	rgbUsers=new BYTE[ulNumUsers*sizeof(QWORD)];
	for (unsigned long ul=0;ul<ulNumUsers*sizeof(QWORD);ul++){
		rgbUsers[ul]=LOBYTE(bstrUsers[ul]);
	}//endfor
	
	//Convert users string to QWORDs
	QWORD* rgqwUserIds=new QWORD[ulNumUsers];
	BYTE* pb=rgbUsers;
	for (ul=0;ul<ulNumUsers;ul++){
		rgqwUserIds[ul]=MAKEQWORD(MAKELONG(MAKEWORD(pb[7],pb[6]),MAKEWORD(pb[5],pb[4])),MAKELONG(MAKEWORD(pb[3],pb[2]),MAKEWORD(pb[1],pb[0])));
		pb+=sizeof(QWORD);
	}//endfor

	//Convert BSTR to array of lo bytes
	BYTE* rgbData;
	rgbData=new BYTE[ulDataLen];
	for (ul=0;ul<ulDataLen;ul++){
		rgbData[ul]=LOBYTE(bstrData[ul]);
	}//endfor
	
	hr = MsgDeleteMatchesEx(true, ulSessionId, ulSequence, rgqwUserIds, ulNumUsers, ulQType, ulMatchAttrNum, rgbData, ulDataLen);

	delete [] rgbData;
	delete [] rgbUsers;
	delete [] rgqwUserIds;

	return hr;
}//endmethod

STDMETHODIMP Cengine::MsgHello(unsigned long ulSessionId, unsigned long ulSequence, unsigned long ulVersion, BSTR bstrDescription, unsigned int uiLen)
{
	return MsgHelloEx(true,ulSessionId,ulSequence,ulVersion,bstrDescription,uiLen);
}//endmethod

STDMETHODIMP Cengine::MsgList(unsigned long ulSessionId, unsigned long ulSequence, unsigned long ulHiUserId, unsigned long ulLoUserId, unsigned long ulQType, unsigned long ulHiCookie, unsigned long ulLoCookie, unsigned long ulHiStartQUID, unsigned long ulLoStartQUID, unsigned long ulMaxItems, unsigned long ulTotalItemDataSize)
{
	return MsgListEx(true, ulSessionId, ulSequence, MAKEQWORD(ulLoUserId,ulHiUserId), ulQType, MAKEQWORD(ulLoCookie,ulHiCookie), MAKEQWORD(ulLoStartQUID,ulHiStartQUID), ulMaxItems, ulTotalItemDataSize);
}//endmethod

STDMETHODIMP Cengine::MsgUserInfo(unsigned long ulSessionId, unsigned long ulSequence, unsigned long ulHiUserId, unsigned long ulLoUserId, unsigned long ulHiXIP, unsigned long ulLoXIP, unsigned long ulHiXRG, unsigned long ulLoXRG, unsigned long ulTickleIP, unsigned short usTicklePort)
{
	return MsgUserInfoEx(true, ulSessionId, ulSequence, MAKEQWORD(ulLoUserId,ulHiUserId), MAKEQWORD(ulLoXIP,ulHiXIP), MAKEQWORD(ulLoXRG,ulHiXRG), ulTickleIP, usTicklePort);
}//endmethod

STDMETHODIMP Cengine::TickleListen(VARIANT_BOOL fOn, unsigned short usTicklePort)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	if (VARIANT_TRUE==fOn){
		if (NULL==m_pTickleCon){
			m_pTickleCon= new UDPConnection(m_hShutdownEvent);
		}//endif
		m_pTickleCon->Bind(usTicklePort);
	}else{
		if (NULL!=m_pTickleCon){
			delete m_pTickleCon;
			m_pTickleCon=NULL;
		}//endif
	}//endif

	m_fTickle=false;

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::WaitForDisconnect(int iTimeout, VARIANT_BOOL* pfConnected)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	if (true==m_pClient->WaitForDisconnect(iTimeout)){
		*pfConnected=VARIANT_TRUE;
	}else{
		*pfConnected=VARIANT_FALSE;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::WaitForReply(unsigned long ulTimeout, VARIANT_BOOL *pfTimeout)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	*pfTimeout=VARIANT_FALSE;

	DWORD dwRcv=0L;
	DWORD dwTotal=0L;
	while (dwTotal!=sizeof(BASE_MSG_HEADER)){
		dwRcv=0L;
		if (S_OK!=m_pClient->Receive((char*)m_rgbReply+dwTotal,sizeof(BASE_MSG_HEADER)-dwTotal,&dwRcv,ulTimeout)){
			*pfTimeout=VARIANT_TRUE;
			return S_OK;
		}else{
			dwTotal+=dwRcv;
		}//endif
	}//endwhile

	m_dwMsgReplyType=*((DWORD*)m_rgbReply);

	dwRcv=0L;
	dwTotal=0L;
	DWORD dwData= *((DWORD*)(m_rgbReply+sizeof(DWORD)));
	while (dwTotal!=dwData){
		dwRcv=0L;
		if (S_OK!=m_pClient->Receive((char*)m_rgbReply+sizeof(BASE_MSG_HEADER)+dwTotal,dwData-dwTotal,&dwRcv,ulTimeout)){
			*pfTimeout=VARIANT_TRUE;
			return S_OK;
		}else{
			dwTotal+=dwRcv;
		}//endif
	}//endwhile

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::WaitForTickle(unsigned long ulTimeout, VARIANT_BOOL *pfTimeout)
{
	//Did the user bind?
	if (NULL==m_pTickleCon){
		return E_FAIL;
	}//endif

	char rgchBuffer[sizeof(Q_TICKLE_MSG)];  //Wire data
	DWORD dwRead=0; //Bytes read on one receive
	DWORD dwTotal=0;  //Total bytes read

	//Receive tickles until shutdown event is fired
	dwTotal=0;
	while (dwTotal<sizeof(Q_TICKLE_MSG)){
		dwRead=0;
		//Receive part or all of a tickle
		if (FAILED(m_pTickleCon->ReceiveFrom(rgchBuffer,sizeof(rgchBuffer)-dwRead,&dwRead,ulTimeout))){
			return E_FAIL;
		}
		dwTotal+=dwRead;
	}//endwhile

	//Store in tickle structure
	memcpy(&m_qTickle,rgchBuffer,sizeof(Q_TICKLE_MSG));
	m_fTickle=true;

	return S_OK;

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// IengineEx

STDMETHODIMP Cengine::MsgAddEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG* rgqwUserIds, /*[in]*/ unsigned long ulNumUsers, /*[in]*/ unsigned long ulQType, /*[in]*/ BYTE* rgbData, /*[in]*/ unsigned long ulDataLen)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qAddMsg,sizeof(m_qAddMsg));

	//Populate message structure
	m_qAddMsg.dwMsgType=QMSG_ADD;
	m_qAddMsg.dwSeqNum=ulSequence;
	m_qAddMsg.dwQType=ulQType;
	m_qAddMsg.dwUserCount=ulNumUsers;
	m_qAddMsg.dwSessID=ulSessionId;

	BYTE* rgbPacket;
	rgbPacket=new BYTE[ulDataLen+ulNumUsers*sizeof(QWORD)];
	BYTE* pb=rgbPacket;

	//Add userids to blob
	for (unsigned long ul=0;ul<ulNumUsers;ul++){
		*((QWORD*)pb)=rgqwUserIds[ul];
		pb+=sizeof(QWORD);
	}//endfor

	//Add data to blob
	for (ul=0;ul<ulDataLen;ul++){
		pb[ul]=rgbData[ul];
	}//endfor

	//Dump structure to bytes
	if FAILED(Dump(&m_qAddMsg,rgbPacket,ulDataLen+ulNumUsers*sizeof(QWORD),m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		delete [] rgbPacket;
		return E_FAIL;
	}//endif

	delete [] rgbPacket;

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgDeadXIPEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwXIP)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qDeadXIPMsg,sizeof(m_qDeadXIPMsg));

	//Populate message structure
	m_qDeadXIPMsg.dwMsgType=QMSG_DEAD_XIP;
	m_qDeadXIPMsg.dwSeqNum=ulSequence;
	m_qDeadXIPMsg.qwXIP=qwXIP;
	m_qDeadXIPMsg.dwSessID=ulSessionId;

	//Dump structure to bytes
	if FAILED(Dump(&m_qDeadXIPMsg,m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		return E_FAIL;
	}//endif

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgDeadXRGEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwXRG)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qDeadXRGMsg,sizeof(m_qDeadXRGMsg));

	//Populate message structure
	m_qDeadXRGMsg.dwMsgType=QMSG_DEAD_XRG;
	m_qDeadXRGMsg.dwSeqNum=ulSequence;
	m_qDeadXRGMsg.qwXRG=qwXRG;
	m_qDeadXRGMsg.dwSessID=ulSessionId;

	//Dump structure to bytes
	if FAILED(Dump(&m_qDeadXRGMsg,m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		return E_FAIL;
	}//endif

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgDeleteEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulQType, /*[in]*/ ULONGLONG qwUserId, /*[in]*/ ULONGLONG qwFirstQUID, /*[in]*/ ULONGLONG qwLastQUID)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qDeleteMsg,sizeof(m_qDeleteMsg));

	//Populate message structure
	m_qDeleteMsg.dwMsgType=QMSG_DELETE;
	m_qDeleteMsg.dwSeqNum=ulSequence;
	m_qDeleteMsg.dwQType=ulQType;
	m_qDeleteMsg.qwUserID=qwUserId;
	m_qDeleteMsg.qwFirstQUID=qwFirstQUID;
	m_qDeleteMsg.qwLastQUID=qwLastQUID;
	m_qDeleteMsg.dwSessID=ulSessionId;

	//Dump structure to bytes
	if FAILED(Dump(&m_qDeleteMsg,m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		return E_FAIL;
	}//endif

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgDeleteMatchesEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG* rgqwUserIds, /*[in]*/ unsigned long ulNumUsers, /*[in]*/ unsigned long ulQType, /*[in]*/ unsigned long ulMatchAttrNum, /*[in]*/ BYTE* rgbData, /*[in]*/ unsigned long ulDataLen)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qDeleteMatchesMsg,sizeof(m_qDeleteMatchesMsg));

	//Populate message structure
	m_qDeleteMatchesMsg.dwMsgType=QMSG_DELETE_MATCHES;
	m_qDeleteMatchesMsg.dwSeqNum=ulSequence;
	m_qDeleteMatchesMsg.dwQType=ulQType;
	m_qDeleteMatchesMsg.dwSessID=ulSessionId;
	m_qDeleteMatchesMsg.dwUserCount=ulNumUsers;

	BYTE* rgbPacket;
	rgbPacket=new BYTE[ulDataLen+ulNumUsers*sizeof(QWORD)];
	BYTE* pb=rgbPacket;

	//Add userids to blob
	for (unsigned long ul=0;ul<ulNumUsers;ul++){
		*((QWORD*)pb)=rgqwUserIds[ul];
		pb+=sizeof(QWORD);
	}//endfor

	//Add data to blob
	for (ul=0;ul<ulDataLen;ul++){
		pb[ul]=rgbData[ul];
	}//endfor

	//Dump structure to bytes
	if FAILED(Dump(&m_qDeleteMatchesMsg,rgbPacket,ulDataLen+ulNumUsers*sizeof(QWORD),m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		delete [] rgbPacket;
		return E_FAIL;
	}//endif

	delete [] rgbPacket;

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgHelloEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ unsigned long ulVersion, /*[in]*/ BSTR bstrDescription, /*[in]*/ unsigned int uiLen)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qHelloMsg,sizeof(m_qHelloMsg));

	//Populate message structure
	m_qHelloMsg.dwMsgType=QMSG_HELLO;
	m_qHelloMsg.dwSeqNum=ulSequence;
	m_qHelloMsg.dwProtocolVersion=ulVersion;
	m_qHelloMsg.dwSessID=ulSessionId;
	
	//BSTR wrapper
	_bstr_t l_bstrDesc(bstrDescription);

	//Dump structure to bytes
	if (0==uiLen){
		if FAILED(Dump(&m_qHelloMsg,(const BYTE*)(char*)l_bstrDesc,l_bstrDesc.length()+1,m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
			return E_FAIL;
		}//endif
	}else{
		if FAILED(Dump(&m_qHelloMsg,(const BYTE*)(char*)l_bstrDesc,uiLen,m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
			return E_FAIL;
		}//endif
	}//endif

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgListEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwUserId, /*[in]*/ unsigned long ulQType, /*[in]*/ ULONGLONG qwCookie, /*[in]*/ ULONGLONG qwStartQUID, /*[in]*/ unsigned long ulMaxItems, /*[in]*/ unsigned long ulTotalItemDataSize)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qListMsg,sizeof(m_qListMsg));

	//Populate message structure
	m_qListMsg.dwMsgType=QMSG_LIST;
	m_qListMsg.dwSeqNum=ulSequence;
	m_qListMsg.dwQType=ulQType;
	m_qListMsg.qwUserID=qwUserId;
	m_qListMsg.qwCookie=qwCookie;
	m_qListMsg.qwStartQUID=qwStartQUID;
	m_qListMsg.dwMaxItems=ulMaxItems;
	m_qListMsg.dwMaxTotalItemDataSize=ulTotalItemDataSize;
	m_qListMsg.dwSessID=ulSessionId;

	//Dump structure to bytes
	if FAILED(Dump(&m_qListMsg, m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		return E_FAIL;
	}//endif

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::MsgUserInfoEx(/*[in]*/ boolean fFlush, /*[in]*/ unsigned long ulSessionId, /*[in]*/ unsigned long ulSequence, /*[in]*/ ULONGLONG qwUserId, /*[in]*/ ULONGLONG qwXIP, /*[in]*/ ULONGLONG qwXRG, /*[in]*/ unsigned long ulTickleIP, /*[in]*/ unsigned short usTicklePort)
{
	//Check if engine is initialized
	if (!m_fInit) return E_FAIL;

	//Zero message structure
	ZeroMemory(&m_qUserInfoMsg,sizeof(m_qUserInfoMsg));

	//Populate message structure
	m_qUserInfoMsg.dwMsgType=QMSG_USER_INFO;
	m_qUserInfoMsg.dwSeqNum=ulSequence;
	m_qUserInfoMsg.qwUserID=qwUserId;
	m_qUserInfoMsg.qwXIP=qwXIP;
	m_qUserInfoMsg.qwXRG=qwXRG;
	m_qUserInfoMsg.dwTickleIP=ulTickleIP;
	m_qUserInfoMsg.wTicklePort=usTicklePort;
	m_qUserInfoMsg.dwSessID=ulSessionId;

	//Dump structure to bytes
	if FAILED(Dump(&m_qUserInfoMsg,m_rgbData,sizeof(m_rgbData),&m_dwDumped)){
		return E_FAIL;
	}//endif

	//Transmit bytes
	if FAILED(m_pClient->Send((char*)m_rgbData,m_dwDumped,fFlush)){
		return E_FAIL;
	}//endif

	//Success
	return S_OK;

}//endmethod

STDMETHODIMP Cengine::InitEx(unsigned long ulcSendBuffers, unsigned long ulcSendBufferSize, long lcReceiveBufferSize)
{
	Init();
	
	//Delete client connection
	if (NULL!=m_pClient){
		delete m_pClient;
		m_pClient=NULL;
	}//endif

	//Create client connection object
	m_pClient = new TCPClientConnection(m_hShutdownEvent,ulcSendBuffers,ulcSendBufferSize,lcReceiveBufferSize);
	if (NULL==m_pClient){
		m_fInit=false;
		return E_FAIL;
	}//endif

	return S_OK;
}

STDMETHODIMP Cengine::GetResponseData(BYTE *rgbData, unsigned long ulDataLen, unsigned long* pulDataLen)
{
	return m_pClient->Receive((char*)rgbData,ulDataLen,pulDataLen);
}

STDMETHODIMP Cengine::SetShutdownEvent()
{
	SetEvent(m_hShutdownEvent);

	return S_OK;
}

STDMETHODIMP Cengine::Init()
{
	m_fInit=true;
	m_dwDumped=0L;
	m_dwMsgReplyType=QMSG_MAX_REPLY_TYPE+1;
	m_pClient=NULL;
	m_hShutdownEvent=NULL;
	m_pTickleCon=NULL;
	m_fTickle=false;

	//Bring winsock up if not already
	if FAILED(WinsockUP()){
		m_fInit=false;
	}//endif

	//Initialize instance data
	ZeroMemory(m_rgbData,sizeof(m_rgbData));
	ZeroMemory(m_rgbReply,sizeof(m_rgbReply));

	//Create shutdown event
	m_hShutdownEvent=CreateEvent(NULL,true,FALSE,NULL);

	//Create client connection object
	m_pClient = new TCPClientConnection(m_hShutdownEvent,10,1024);
	if (NULL==m_pClient){
		m_fInit=false;
	}//endif

	return S_OK;
}

STDMETHODIMP Cengine::Cleanup()
{
	//Trigger any blocked connection options to abort
	SetEvent(m_hShutdownEvent);
	Sleep(200);

	//Delete client connection
	if (NULL!=m_pTickleCon){
		delete m_pTickleCon;
		m_pTickleCon=NULL;
	}//endif

	//Delete client connection
	if (NULL!=m_pClient){
		delete m_pClient;
		m_pClient=NULL;
	}//endif

	//Delete the shutdown event
	if (NULL!=m_hShutdownEvent){
		CloseHandle(m_hShutdownEvent);
		m_hShutdownEvent=NULL;
	}//endif

	m_fInit=false;
	m_dwDumped=0L;
	m_dwMsgReplyType=QMSG_MAX_REPLY_TYPE+1;
	m_fTickle=false;

	return S_OK;
}

STDMETHODIMP Cengine::CleanupEx()
{
	return Cleanup();
}

STDMETHODIMP Cengine::Flush(unsigned long ulTimeout)
{
	return m_pClient->WaitForAllPendingBuffersToFlush(ulTimeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\HostSocket.h ===
// HostSocket.h: interface for the CHostSocket class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

// Defines the maximum simultaneous incoming client connection requests allowed
#define MAX_CONNECTION_BACKLOG 5 

class CHostSocket  
{
public:
	void UnregisterKey();
	HRESULT AcceptIncomingClient(SOCKET *pSocket, IN_ADDR *pInAddr, XNADDR *pXnAddr, XNKID *pXnKid);
	HRESULT StartListening(WORD wPort);
	HRESULT IsConnectionPending();
	HRESULT RegisterKey(XNKID *pSessionID, XNKEY *pKeyExchangeKey);
	CHostSocket();
	virtual ~CHostSocket();

protected:
	SOCKET m_ListenSocket;
	BOOL m_fListening;
	XNKID *m_pSessionID;
	XNKEY *m_pKeyExchangeKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\client.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       client.cpp
 *  Content:    Code for the client algorithm of the integrated online stress test
 *  History:
 *   Date		By		Reason
 *   ====	==		======
 *  2/18/02	johnblac	Created to hold all code related to the client stress algorithm
 *
 ****************************************************************************/

#include "SGBVT.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;
extern CLogonTask *g_pLogonTask;
extern BOOL g_fExitTest;


/****************************************************************************
 *
 *  CreateClientConnectionToHost
 *
 *  Description:
 *      Creates a connection to the host and sends the local user information
 *
 *  Arguments:
 *      CClientConnection     *pClientConnection  Pointer to a client connection that is to be filled
 *                                                connection information with the host
 *      XNADDR                *pHostAddr          Address of the host
 *      XNKID                 *pSessionID         XNKID to register with the network stack
 *      XNKEY                 *pKeyExchangeKey    XNKEY to register with the network stack
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the socket timed out waiting to connect
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT CreateClientConnectionToHost(SOCKET* pHostSocket, XNADDR *pHostAddr, XNKID *pSessionID)
{
	COnlineTimer ConnectionTimer;
	HRESULT hr = S_OK;
	fd_set writefds, exceptfds;
	TIMEVAL sTimeout = {0, 0}; 
	ULONG uNonBlockParam = TRUE;
	INT nActiveSockets = 0;

	//
	// Create the socket to communicate with the host
	//
	*pHostSocket = socket( AF_INET, SOCK_DGRAM, 0 );
	if(*pHostSocket == INVALID_SOCKET)
	{
		LOGTASKINFO(g_hLog, "Error creating socket");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Set non-blocking IO
	//
	if(SOCKET_ERROR == ioctlsocket(*pHostSocket, FIONBIO, &uNonBlockParam))
	{
		LOGTASKINFO(g_hLog, "Error setting client socket to use non-blocking IO");
		hr = E_FAIL;
		goto Exit;
	}

	hr = S_OK;

Exit:

	if(hr == E_FAIL)
	{
		closesocket(*pHostSocket);
		*pHostSocket = INVALID_SOCKET;
	}

	return hr;
}

/****************************************************************************
 *
 *  VerifySentData
 *
 *  Description:
 *      Waits for a receive packet on the socket passed into it, then compares the buffer
 *	  received with the buffer that was sent.
 *
 *  Arguments:
 *      SOCKET sHostSocket - socket to receive buffer on
 *	  char* pBuffSend	     - buffer to compare
 *
 *  Returns:  
 *      
 *
 ****************************************************************************/
 
HRESULT VerifySentData(SOCKET sHostSocket, char* pBuffSend)
{
	HRESULT hr = S_OK;
	COnlineTimer	ClientWaitTimer;
	fd_set readfds;
	fd_set exceptfds;	
	sockaddr_in	SrcAddress;
	int iBuffSize = 0, iLastError = 0;
	ClientWaitTimer.SetAllowedTime(SGBVT_HOST_WAIT_TIME);
	TIMEVAL sTimeout = {0, 0}; 
	char rgbBuffRecv[LARGEST_PACKET];

	if(!pBuffSend)
		return E_INVALIDARG;

	ZeroMemory(rgbBuffRecv, LARGEST_PACKET);
	
	//
	// The host should send it back
	//
	while(true)
	{
		FD_ZERO(&readfds);
		FD_ZERO(&exceptfds);

		FD_SET(sHostSocket, &readfds);
		FD_SET(sHostSocket, &exceptfds);

		int iRes = select(0, &readfds, NULL, &exceptfds, &sTimeout);
				
		if(iRes == 0)
		{
			// Timeout
		}
		else if (iRes == SOCKET_ERROR )
		{
			iLastError = WSAGetLastError();
		}
		else
		{
			// We have something to receive
			hr = ReadPacket(sHostSocket, rgbBuffRecv, LARGEST_PACKET, NULL, &SrcAddress, &iBuffSize);
			if(FAILED(hr))
			{
				LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
				hr = S_OK;
			}
			else
			{
				// Compare the buffers
				if(memcmp(pBuffSend, rgbBuffRecv, iBuffSize))
				{
					hr = E_BUFFER_MISMATCH;
				}
			}
			break;
		}
		
		// Wait for SGBVT_HOST_WAIT_TIME miliseconds to throttle the speed at which connections and disconnections occur
		ClientWaitTimer.Start();
		while(!ClientWaitTimer.HasTimeExpired())
		{
			PUMPLOGONHANDLE();
			Sleep(0);
		}
	}
Exit:
	return hr;
}


/****************************************************************************
 *
 *  FillData
 *
 *  Description:
 *      Takes a BYTE pointer to a buffer with a given size and maximum length of the buffer.  
 *      The buffer is cleared and filled with 'bogus' data.
 *
 *  Arguments:
 *	BYTE* pBuff - pointer to the buffer to be filled
 *	WORD wSize - Size of data to be created
 *	WORD wBufferLength - Total size of the buffer
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
//-----------------------------------------------------------------------------
//
// FillData
//
// Takes a BYTE pointer to a buffer with a given size and maximum length of the buffer.  The 
// buffer is filled with 'bogus' data.
//
HRESULT FillData(BYTE* pBuff, WORD wSize, WORD wBufferLength)
{
	// Check for a valid buffer pointer and that we're filling the buffer
	// with no more than its maximum size
	if(!pBuff || wSize > wBufferLength)
	{
		return E_FAIL;
	}

	ZeroMemory(pBuff, wBufferLength);
	WORD wCount = 0;
	while(wCount < wSize)
	{
		switch(wCount % 3)
		{
		case 0:
			*pBuff = 0xC0;
			break;
		case 1:
			*pBuff = 0xFF;
			break;
		case 2:
			*pBuff = 0xEE;
			break;
		default:
			return E_UNEXPECTED;
		}
		wCount++;
		pBuff++;
	}

	return S_OK;
}


/****************************************************************************
 *
 *  client_Main
 *
 *  Description:
 *      Master algorithm for the online stress client
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT client_Main(XNADDR *pHostXnAddr, XNKID *pSessionID, XNKEY *pKeyExchangeKey )
{
	HRESULT 	hr = S_OK;
	sockaddr_in	HostAddress;
	IN_ADDR 	ClientInAddr;
	XNADDR		ClientXnAddr;
	SOCKET		sHostSocket;
	BYTE *pBuffSend = NULL;
	BYTE *pBuffRecv = NULL;
	
	// Allocate some buffer space for sending and receiving data
	pBuffSend = new BYTE[LARGEST_PACKET];	
	if(!pBuffSend)
		return E_OUTOFMEMORY;
	
	HostAddress.sin_family = AF_INET;
	HostAddress.sin_port = htons(SGBVT_HOST_PORT);

	//
	// Register the host's key information
	//
	if(XNetRegisterKey(pSessionID, pKeyExchangeKey))
	{
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Get a dummy IP address binding for the host's address
	//
	if(XNetXnAddrToInAddr(pHostXnAddr, pSessionID, &(HostAddress.sin_addr)))
	{
		LOGTASKINFO(g_hLog, "Error getting a private INADDR from host's XNADDR");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Create a socket to connect to the session host
	//
	hr = CreateClientConnectionToHost(&sHostSocket, pHostXnAddr, pSessionID);
	if(hr != S_OK)
		goto Exit;

	// ************* 0 sized Packet Test
	// Clean the buffers and put something in the send buffer
	if(FAILED(FillData(pBuffSend, 0, LARGEST_PACKET)))
		return E_COULDNT_FILL_SEND_BUFFER;
	
	//
	// Send some data to the host
	//
	hr = SendPacket(sHostSocket, (char*)pBuffSend, 4, NULL, &HostAddress);
	if(FAILED(hr))
	{
		LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
		hr = S_OK;
	}

	hr = VerifySentData(sHostSocket, (char*)pBuffSend);
	if(FAILED(hr))
		goto Exit;

	// ************* N sized packet Test	
	// Clean the buffers and put something in the send buffer
	if(FAILED(FillData(pBuffSend, 4, LARGEST_PACKET)))
		return E_COULDNT_FILL_SEND_BUFFER;
	
	//
	// Send some data to the host
	//
	hr = SendPacket(sHostSocket, (char*)pBuffSend, 4, NULL, &HostAddress);
	if(FAILED(hr))
	{
		LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
		hr = S_OK;
	}

	hr = VerifySentData(sHostSocket, (char*)pBuffSend);
	if(FAILED(hr))
		goto Exit;

	// ************* Largest Packet Test
	// Clean the buffers and put something in the send buffer
	if(FAILED(FillData(pBuffSend, LARGEST_PACKET, LARGEST_PACKET)))
		return E_COULDNT_FILL_SEND_BUFFER;
	
	//
	// Send some data to the host
	//
	hr = SendPacket(sHostSocket, (char*)pBuffSend, 4, NULL, &HostAddress);
	if(FAILED(hr))
	{
		LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
		hr = S_OK;
	}

	hr = VerifySentData(sHostSocket, (char*)pBuffSend);
	if(FAILED(hr))
		goto Exit;
	
Exit:
	//
	// Close the listent socket and client connections
	//

	closesocket(sHostSocket);
	
	pBuffSend ? delete [] pBuffSend : 0;
	pBuffRecv ? delete [] pBuffRecv : 0;	
	
	//
	// Return the Hresult
	//
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\qtickle\qtickle.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"  //Precompiled header
#include "stdlib.h"	 //atol
#include "connection.h"  //Network connection wrapper and helper functions
#include "xqprotocol.h"  //Protocol structures

/////////////////////////////////////////////////////////////////////////////
// Usage - Displays the command line usage of this program.
/////////////////////////////////////////////////////////////////////////////

void Usage(char *argv[ ]){
	fprintf(stdout,"usage: %s -m machine [-p #] [-u #] [-q #] [-n #] [-?|h]\n",argv[0]);
	fprintf(stdout,"where:\n");
	fprintf(stdout,"  -m is the name or ip address of the target machine\n");
	fprintf(stdout,"  -p is the port to use\n");
	fprintf(stdout,"  -u # is the userid.\n");
	fprintf(stdout,"  -q # is the qtype.\n");
	fprintf(stdout,"  -n # is the number of items in the queue\n");
	fprintf(stdout,"\nexamples:\n");
	fprintf(stdout,"  %s -m 10.0.0.1 -p 1001 -u 1 -q 0 -n 5\n",argv[0]);
	fprintf(stdout,"  %s -m machinename -p 1001 -u 1 -q 0 -n 5\n",argv[0]);
}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Main block
/////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char *argv[ ]){

	//Local vars
	HRESULT hr=S_OK;
	SOCKADDR_IN sin;
	DWORD dwIP=INADDR_NONE;
	UDPConnection* pUdp;
	bool fPass=false;

	//Parameters
	QWORD qwUserID=MAKEQWORD(0,0);
	WORD wPort=0L;
	DWORD dwQType=0L;
	DWORD dwNumItems=0L;
	char rgchName[1024];

	//Check if there are any command line arguements and whether those arguements are divisible by 2
	int i=1;
	if ((argc<=1) || (((argc-1)%2)!=0) ) goto show_usage;
	
	//Parse the command line arguements
	fPass=false;
	while (i<argc){
		if (argv[i][0]!='-') goto show_usage;
		switch (argv[i++][1]){
		case 'm':
		case 'M':
			strcpy(rgchName,argv[i++]);;
			fPass=true;
			break;
		case 'u':
		case 'U':
			qwUserID=_atoi64(argv[i++]);
			break;
		case 'q':
		case 'Q':
			dwQType=atol(argv[i++]);
			break;
		case 'p':
		case 'P':
			wPort=(unsigned short)atoi(argv[i++]);
			break;
		case 'n':
		case 'N':
			dwNumItems=atol(argv[i++]);
			break;
		default:
			goto show_usage;
		}//endswitch
	}//endwhile

	if (!fPass) return -1;

	//Bring winsock up
	if FAILED(WinsockUP()){
		printf("Winsock won't initialize\n");
		return -1;
	}//endif

	//Resolve machine name
	dwIP=InternetAddress(rgchName);
	if (dwIP==INADDR_NONE){
		printf("Invalid machine name.\n");
		WinsockDOWN();
		return -1;
	}//endif

	//Build tickle
	Q_TICKLE_MSG tickle;
	tickle.qwUserID=qwUserID;
	tickle.dwQType=dwQType;
	tickle.dwQLength=dwNumItems;
	
	//Dump to bytes
	char rgchBuffer[sizeof(Q_TICKLE_MSG)];
	memcpy(rgchBuffer,&tickle,sizeof(Q_TICKLE_MSG));
	
	//Name connection
	sin.sin_family = AF_INET;
	sin.sin_port = htons(wPort);
	sin.sin_addr.s_addr = dwIP;
	
	//Send
	pUdp=new UDPConnection(NULL);
	pUdp->SendTo(rgchBuffer,sizeof(Q_TICKLE_MSG),TRUE,WSA_INFINITE,(const struct sockaddr*)&sin,sizeof(sin));
	delete pUdp;

	//Bring winsock down
	WinsockDOWN();

	printf("operation complete.\n");
	return 0;

show_usage:

	Usage(argv);
	return -1;

}//endmethod
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\clientConnection.h ===
// ClientConnection.h: interface for the CClientConnection class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include <vector>
#include "onlinetimer.h"
#include "sessionuser.h"

#define SGBVT_HEARTBEAT_TIMEOUT 60000
#define SGBVT_HEARTBEAT_XMIT_TIME 30000

#define SGBVT_MIN_CLIENT_SIZE  (sizeof(SGBVT_CLIENT_HEADER))
#define SGBVT_MAX_CLIENT_SIZE  (sizeof(SGBVT_CLIENT_HEADER) + XONLINE_MAX_LOGON_USERS * \
                                   (sizeof(SGBVT_USER_HEADER) + sizeof(XUID) + XONLINE_MAX_NAME_LENGTH + XONLINE_MAX_KINGDOM_LENGTH))

using namespace std;

class CClientConnection;

typedef vector <CClientConnection> SGBVT_CLIENTVECTOR, *PSGBVT_CLIENTVECTOR;
typedef vector <CSessionUser> SGBVT_USERVECTOR, *PSGBVT_USERVECTOR;

#pragma pack(push, 1)

// This structure frames client lists that are sent on the wire
typedef struct
{
	DWORD dwClientListSize;
	DWORD dwClientCount;
} SGBVT_CLIENTLIST_HEADER, *PSGBVT_CLIENTLIST_HEADER;

// This structure frames individual clients that are sent on the wire
typedef struct
{
	DWORD  dwClientSize;
	XNADDR ClientAddr;
	DWORD  dwUserCount;
	BYTE   bOperation;

#define SGBVT_CLIENT_ADD 0x01
#define SGBVT_CLIENT_DELETE 0x02

} SGBVT_CLIENT_HEADER, *PSGBVT_CLIENT_HEADER;

#pragma pack(pop)

class CClientConnection  
{
public:
	BOOL IsOutgoingHeartbeatExpired();
	BOOL IsIncomingHearbeatExpired();
	BOOL IsDisconnected();
	void SetAsDisconnected();
	void ResetOutgoingHeartbeatTimer();
	void ResetIncomingHeartbeatTimer();
	BOOL IsNew();
	void SetAsOld();
	void SetAsNew();
	SOCKET GetSocket();
	void SetSocket(SOCKET Socket);
	void ClearUsers();
	HRESULT AddUser(CSessionUser &);
	HRESULT UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	HRESULT PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	bool operator <(CClientConnection &);
	bool operator ==(CClientConnection &);
	CClientConnection& operator = (const CClientConnection&);
	CClientConnection(const CClientConnection &);
	CClientConnection();
	virtual ~CClientConnection();
	
	XNADDR m_ClientAddr;

protected:
	COnlineTimer m_OutgoingHeartbeatTimer;
	COnlineTimer m_IncomingHeartbeatTimer;
	SOCKET m_ClientSocket;
	BOOL m_fDisconnected;
	BOOL m_fNew;
	SGBVT_USERVECTOR m_UserVector;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\Host.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       host.cpp
 *  Content:    Code for the host algorithm of the integrated online stress test
 *  History:
 *   Date		By		Reason
 *   ====	==		======
 *  01/08/01	tristanj	Created to hold all code related to the client stress algorithm
 *
 ****************************************************************************/

#include "SGBVT.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;
extern CLogonTask *g_pLogonTask;
extern BOOL g_fExitTest;

/****************************************************************************
 *
 *  AdvertiseStressSession
 *
 *  Description:
 *      Sends a session creation/update request with the specified number of current
 *      and available slots.  It then pumps the task handle until completion.
 *
 *  Arguments:
 *      DWORD               dwPublicCurrent     Number of clients currently connected to the session
 *      DWORD               dwPublicAvailable   Number of client spaces still available in the session
 *      XNKID               *pSessionID         If the XNKID pointed to is set to all 0's, this is a
 *                                              session creation, otherwise update the session specified
 *                                              On exit, this will contain the returned XNKID
 *      XNKEY               *pKeyExchangeKey    On exit, this will contain the returned XNKEY
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT AdvertiseStressSession(CMatchSessionCreateTask *pSessionCreateTask, DWORD dwPublicCurrent, DWORD dwPublicAvailable, XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	COnlineTimer Timer;
	HRESULT hr = S_OK;
	DWORD dwStartTick = 0, dwCurrentTick = 0;

	if(!pSessionCreateTask)
	{
		hr = E_FAIL;
		goto Exit;
	}

	pSessionCreateTask->SetAvailableSlots(dwPublicCurrent, dwPublicAvailable, 0, 0);

	// Start match session creation task
	if(!pSessionCreateTask->StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_SESSION_CREATE_TIME);
	Timer.Start();

	// Pump task for MAX_SESSION_CREATE_TIME seconds
	while(!pSessionCreateTask->IsTaskComplete())
	{
		if(Timer.HasTimeExpired())
			break;

		g_pLogonTask->TaskContinue();
		pSessionCreateTask->TaskContinue();
	}

	if(!pSessionCreateTask->IsTaskComplete())
	{
		LOGTASKINFO(g_hLog, "Session creation timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	pSessionCreateTask->GetSessionInfo(pSessionID, pKeyExchangeKey);

	if(*((ULONGLONG *) pSessionID) == 0)
	{
		LOGTASKINFO(g_hLog, "Session ID wasn't set");
		hr = E_FAIL;
		goto Exit;
	}

Exit:

	return hr;
}


/****************************************************************************
 *
 *  host_Main
 *
 *  Description:
 *      Master algorithm for the online stress host
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT host_Main( void )
{
	HRESULT hr = S_OK;
	SGBVT_CLIENTVECTOR ClientVector;
	sockaddr_in ClientAddress;
	XONLINE_ATTRIBUTE AttributesArray[1];
	COnlineTimer HostWaitTimer;
	COnlineTimer TransactionWaitTimer;	
	CMatchSessionCreateTask SessionCreateTask;
	CListenSocket *pListenSocket = NULL;
	DWORD dwPublicCurrent = 0, dwNewPublicCurrent = 0, dwAttributesCount = (sizeof(AttributesArray) / sizeof(XONLINE_ATTRIBUTE));
	XNKID SessionID;
	XNKEY KeyExchangeKey;
	char *pBuff = NULL;
	int iRes = 0, iLastError = 0, iBuffSize = 0;

	pBuff = new char[LARGEST_PACKET];	
	if(!pBuff)
		return E_OUTOFMEMORY;

	ZeroMemory(pBuff, LARGEST_PACKET);

	// These attributes define the match making session
	AttributesArray[0].dwAttributeID = SGBVT_SESSION_PARAM;
	AttributesArray[0].info.integer.qwValue = SGBVT_SESSION_VALUE;
	AttributesArray[0].fChanged = TRUE;
	
	SessionCreateTask.RegisterLogHandle(g_hLog);
	SessionCreateTask.SetAttributes(AttributesArray, dwAttributesCount);

	memset(&ClientAddress, 0, sizeof(sockaddr_in));
	memset(&SessionID, 0, sizeof(XNKID));
	memset(&KeyExchangeKey, 0, sizeof(XNKEY));

	fd_set readfds;
	fd_set exceptfds;	
	
	TIMEVAL sTimeout = {0, 0}; 

	//
	// Create and advertise a new session on the match server
	//
	hr = AdvertiseStressSession(&SessionCreateTask, dwPublicCurrent, DEFAULT_SLOTS_AVAILABLE, &SessionID, &KeyExchangeKey);	
	if(hr != S_OK)
		goto Exit;

	//
	// Register the host's key information
	//
	if(XNetRegisterKey(&SessionID, &KeyExchangeKey))
	{
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Create a socket to listen for incoming clients
	//
	hr = CreateListenSocket(&pListenSocket, &SessionID, &KeyExchangeKey);
	if(hr != S_OK)
		goto Exit;

	HostWaitTimer.SetAllowedTime(SGBVT_HOST_WAIT_TIME);
	TransactionWaitTimer.SetAllowedTime(SGBVT_MAX_CONNECT_TIME);

	while(SUCCEEDED(hr) && !g_fExitTest)
	{
		FD_ZERO(&readfds);
		FD_ZERO(&exceptfds);
		FD_SET(pListenSocket->GetSocket(), &readfds);
		FD_SET(pListenSocket->GetSocket(), &exceptfds);

		iRes = select(0, &readfds, NULL, &exceptfds, &sTimeout);
				
		if(iRes == 0)
		{
			// Timeout
		}
		else if (iRes == SOCKET_ERROR )
		{
			iLastError = WSAGetLastError();
		}
		else
		{
			// We have something to receive
			hr = ReadPacket(pListenSocket->GetSocket(), pBuff, LARGEST_PACKET, &TransactionWaitTimer, &ClientAddress, &iBuffSize);
			if(FAILED(hr))
			{
				LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
				hr = S_OK;
			}
			else
			{
				// Send it back
				hr = SendPacket(pListenSocket->GetSocket(), pBuff, iBuffSize, &TransactionWaitTimer, &ClientAddress);
				if(FAILED(hr))
				{
					LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
					hr = S_OK;
				}
			}
		}
		
		// Wait for SGBVT_HOST_WAIT_TIME miliseconds to throttle the speed at which connections and disconnections occur
		HostWaitTimer.Start();
		while(!HostWaitTimer.HasTimeExpired())
		{
			PUMPLOGONHANDLE();
			Sleep(0);
		}
	}

Exit:

	//
	// Delete stress session
	//
	hr = DeleteStressSession(&SessionID);
	if(hr != S_OK)
	{
		LOGTASKINFO(g_hLog, "Failed to delete session from match server");
	}

	//
	// Close the host socket and client connections
	//
	pListenSocket ? delete pListenSocket : 0;

	pBuff ? delete [] pBuff : 0;
    //
    // Return the Hresult
    //

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\HostSocket.cpp ===
// HostSocket.cpp: implementation of the CHostSocket class.
//
//////////////////////////////////////////////////////////////////////

#include "HostSocket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHostSocket::CHostSocket()
{
	m_fListening = FALSE;
	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
	m_ListenSocket = INVALID_SOCKET;
}

CHostSocket::~CHostSocket()
{
	UnregisterKey();
	
	if(m_fListening)
		closesocket(m_ListenSocket);
}

/****************************************************************************
 *
 *  RegisterKey
 *
 *  Description:
 *      Registers security information with the network stack so that the host
 *      can accept incoming connections from clients that saw the session on
 *      the match server
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if the key was registered successfully
 *      E_FAIL if an error occured registering the key
 *
 ****************************************************************************/
HRESULT CHostSocket::RegisterKey(XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	if(m_pSessionID || m_pKeyExchangeKey)
		return E_FAIL;

	m_pSessionID = pSessionID;
	m_pKeyExchangeKey = pKeyExchangeKey;

	
	if(XNetRegisterKey(pSessionID, pKeyExchangeKey))
		return E_FAIL;

	return S_OK;
}

/****************************************************************************
 *
 *  IsConnectionPending
 *
 *  Description:
 *      Return whether or not there are any pending connections available on
 *      the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if there are incoming connections pending
 *      S_FALSE if there are no incoming connections pending
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CHostSocket::IsConnectionPending()
{
	HRESULT hr = S_FALSE;
	INT nActiveSockets = 0;

    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(m_ListenSocket, &readfds);

    fd_set exceptfds;
    FD_ZERO(&exceptfds);
    FD_SET(m_ListenSocket, &exceptfds);
    
    TIMEVAL sTimeout = {0, 0}; 

	if(!m_fListening)
		return E_FAIL;

    nActiveSockets = select(0, &readfds, NULL, &exceptfds, &sTimeout);

    if(nActiveSockets <= 0)
    {
        hr = S_FALSE;
        goto Exit;
    }
                
    if(FD_ISSET(m_ListenSocket, &exceptfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(!FD_ISSET(m_ListenSocket, &readfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

	hr = S_OK;

Exit:

	return hr;
}

/****************************************************************************
 *
 *  StartListening
 *
 *  Description:
 *      Create a host socket, set it to non-blocking, bind it to a designated port
 *      and begin listening for incoming connections
 *
 *  Arguments:
 *      WORD                wPort               Port to listen for incoming connection
 *                                              requests on
 *
 *  Returns:  
 *      S_OK if the socket was created and is listening
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CHostSocket::StartListening(WORD wPort)
{
	SOCKADDR_IN ListenAddress;
    ULONG uNonBlockParam = TRUE;

	if(m_fListening)
		return TRUE;

	m_ListenSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );

	if(m_ListenSocket == INVALID_SOCKET)
		goto Exit;

	if(SOCKET_ERROR == ioctlsocket(m_ListenSocket, FIONBIO, &uNonBlockParam))
		goto Exit;

	ListenAddress.sin_family = AF_INET;
    ListenAddress.sin_port = htons(wPort);
    ListenAddress.sin_addr.s_addr = INADDR_ANY;

	if(SOCKET_ERROR == bind(m_ListenSocket, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress)))
		goto Exit;

	if(SOCKET_ERROR == listen(m_ListenSocket, MAX_CONNECTION_BACKLOG))
		goto Exit;

	m_fListening = TRUE;

Exit:

	if(!m_fListening)
	{
		if(m_ListenSocket != INVALID_SOCKET)
		{
			closesocket(m_ListenSocket);
			m_ListenSocket = INVALID_SOCKET;
		}
	}

	return m_fListening ? S_OK : E_FAIL;
}

/****************************************************************************
 *
 *  AcceptIncomingClient
 *
 *  Description:
 *      Pulls one client off the host socket backlog
 *
 *  Arguments:
 *      SOCKET              *pSocket            Returns the incoming client socket
 *      IN_ADDR             *pInAddr            Returns the locally bound IP of the incoming socket
 *      XNADDR              *pXnAddr            Returns the actual Xbox Online address of the incoming socket
 *
 *  Returns:  
 *      S_OK if the socket successfully accepted
 *      S_FALSE if the API timed out waiting for an incoming connection
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CHostSocket::AcceptIncomingClient(SOCKET *pSocket, IN_ADDR *pInAddr, XNADDR *pXnAddr, XNKID *pXnKid)
{
	SOCKADDR_IN IncomingSockAddr;
	INT nSockAddrSize = sizeof(SOCKADDR_IN);

	if(!pSocket || !m_fListening)
		return E_FAIL;

	if((*pSocket = accept(m_ListenSocket, (struct sockaddr *) &IncomingSockAddr, &nSockAddrSize)) == INVALID_SOCKET)
	{
		if(WSAGetLastError() == WSAEWOULDBLOCK)
			return S_FALSE;

		return E_FAIL;
	}

	if(pInAddr)
		(*pInAddr).S_un.S_addr = IncomingSockAddr.sin_addr.S_un.S_addr;

	if(pXnAddr && pXnKid)
	{
		if(XNetInAddrToXnAddr(IncomingSockAddr.sin_addr, pXnAddr, pXnKid))
		{
			closesocket(*pSocket);
			return E_FAIL;
		}
	}

	return S_OK;
}

/****************************************************************************
 *
 *  UnregisterKey
 *
 *  Description:
 *      Unregisters the security information used for the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CHostSocket::UnregisterKey()
{
	if(!m_pSessionID)
		return;

	XNetUnregisterKey(m_pSessionID);

	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\clientConnection.cpp ===
// ClientConnection.cpp: implementation of the CClientConnection class.
//
//////////////////////////////////////////////////////////////////////

#include "ClientConnection.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CClientConnection::CClientConnection()
{
	m_fNew = FALSE;
	m_fDisconnected = FALSE;
	m_IncomingHeartbeatTimer.SetAllowedTime(SGBVT_HEARTBEAT_TIMEOUT);
	m_OutgoingHeartbeatTimer.SetAllowedTime(SGBVT_HEARTBEAT_XMIT_TIME);
	m_IncomingHeartbeatTimer.Start();
	m_IncomingHeartbeatTimer.Start();
	m_ClientSocket = INVALID_SOCKET;
	memset(&m_ClientAddr, 0, sizeof(m_ClientAddr));
	m_UserVector.reserve(XONLINE_MAX_LOGON_USERS);
}

CClientConnection::~CClientConnection()
{

}

CClientConnection::CClientConnection(const CClientConnection &ClientConnection)
{
	m_fNew = ClientConnection.m_fNew;
	m_fDisconnected = ClientConnection.m_fDisconnected;
	m_IncomingHeartbeatTimer = ClientConnection.m_IncomingHeartbeatTimer;
	m_OutgoingHeartbeatTimer = ClientConnection.m_OutgoingHeartbeatTimer;
	m_ClientSocket = ClientConnection.m_ClientSocket;
	memcpy(&m_ClientAddr, &(ClientConnection.m_ClientAddr), sizeof(m_ClientAddr));
}

CClientConnection& CClientConnection::operator = (const CClientConnection& ClientConnection)
{
	m_fNew = ClientConnection.m_fNew;
	m_fDisconnected = ClientConnection.m_fDisconnected;
	m_IncomingHeartbeatTimer = ClientConnection.m_IncomingHeartbeatTimer;
	m_OutgoingHeartbeatTimer = ClientConnection.m_OutgoingHeartbeatTimer;
	m_ClientSocket = ClientConnection.m_ClientSocket;
	memcpy(&m_ClientAddr, &(ClientConnection.m_ClientAddr), sizeof(m_ClientAddr));

	return *this;
}

bool CClientConnection::operator ==(CClientConnection &ClientConnection)
{
	if(memcmp(&m_ClientAddr, &(ClientConnection.m_ClientAddr), sizeof(m_ClientAddr)))
		return false;

	return true;
}

bool CClientConnection::operator <(CClientConnection &ClientConnection)
{
	return (m_ClientAddr.inaOnline.S_un.S_addr < ClientConnection.m_ClientAddr.inaOnline.S_un.S_addr);
}

/****************************************************************************
 *
 *  PackIntoBuffer
 *
 *  Description:
 *      Packs all of the CClientConnection information into a buffer for transmission
 *      over the wire to another client
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer to hold the user information.  If this
 *                                              parameter is NULL and a non-NULL pdwBuffSize is
 *                                              provided, then the function will fill pdwBuffSize
 *                                              with the required size necessary
 *      DWORD               *pdwBuffSize        Holds the size of the provided buffer. On output
 *                                              this parameter will contain either the required size
 *                                              (if the provided size was insufficient) or the
 *                                              ammount of space that was actually used
 *
 *  Returns:  
 *      S_OK if the client was succesfully packed into the buffer
 *      S_FALSE if a buffer was supplied but it was too small to hold the data
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CClientConnection::PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PSGBVT_CLIENT_HEADER pClientHeader = (PSGBVT_CLIENT_HEADER) pBuff;
	SGBVT_USERVECTOR::iterator UserCurrent, UserEnd;
	DWORD dwRequiredSize = 0, dwUsedSize = 0, dwUserCount = 0, dwCurrentUserSize = 0;

	if(!pdwBuffSize)
		return E_FAIL;

	dwRequiredSize = sizeof(SGBVT_CLIENT_HEADER);
	
	// Only pack user information if this is a client ADD message
	if(!m_fDisconnected)
	{
		// Loop through all users in the user vector and add to the total required size for the client packet
		for(UserCurrent = m_UserVector.begin(), UserEnd = m_UserVector.end(); UserCurrent != UserEnd; ++UserCurrent)
		{
			dwCurrentUserSize = 0;
			UserCurrent->PackIntoBuffer(NULL, &dwCurrentUserSize);
			dwRequiredSize += dwCurrentUserSize;
			++dwUserCount;
		}
	}
	
	if(*pdwBuffSize < dwRequiredSize)
	{
		*pdwBuffSize = dwRequiredSize;
		return S_FALSE;
	}

	*pdwBuffSize = dwRequiredSize;

	// Fill in the client header
	pClientHeader->dwClientSize = dwRequiredSize;
	memcpy(&(pClientHeader->ClientAddr), &m_ClientAddr, sizeof(XNADDR));
	pClientHeader->dwUserCount = dwUserCount;
	pClientHeader->bOperation = m_fDisconnected ? SGBVT_CLIENT_DELETE : SGBVT_CLIENT_ADD;

	// Only pack user information if this is a client ADD message
	if(!m_fDisconnected)
	{
		dwUsedSize += sizeof(SGBVT_CLIENT_HEADER);
		
		// Loop through all users in the user vector and add each to the client packet
		for(UserCurrent = m_UserVector.begin(), UserEnd = m_UserVector.end(); UserCurrent != UserEnd; ++UserCurrent)
		{
			dwCurrentUserSize = dwRequiredSize - dwUsedSize;
			UserCurrent->PackIntoBuffer(pBuff + dwUsedSize, &dwCurrentUserSize);
			dwUsedSize += dwCurrentUserSize;
		}
	}

	return S_OK;
}

/****************************************************************************
 *
 *  UnpackFromBuffer
 *
 *  Description:
 *      Unpacks a client information packet received over the wire into a new
 *      CClientConnection object
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer containing the received user information packet
 *      DWORD               *pdwBuffSize        On input, indicates the size of the received packet
 *                                              On output, indicates the size used to build the client object
 *
 *  Returns:  
 *      S_OK if the client object was succesfully unpacked from the buffer
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CClientConnection::UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PSGBVT_CLIENT_HEADER pClientHeader = (PSGBVT_CLIENT_HEADER) pBuff;
	CSessionUser *pNewUser = NULL;
	HRESULT hr = S_OK;
	DWORD dwCurrentClient = 0, dwUsedSize = 0, dwUserBufferSize = 0;

	if(m_UserVector.size() != 0)
		ClearUsers();

	if((*pdwBuffSize < sizeof(SGBVT_CLIENT_HEADER)) || !pBuff)
		return E_FAIL;

	if(pClientHeader->dwClientSize > *pdwBuffSize)
		return E_FAIL;

	memcpy(&m_ClientAddr, &(pClientHeader->ClientAddr), sizeof(XNADDR));
	m_fDisconnected = (pClientHeader->bOperation == SGBVT_CLIENT_DELETE);

	// If this is a client disconnect, ignore any user information present
	if(!m_fDisconnected)
	{
		
		if(pClientHeader->dwUserCount > XONLINE_MAX_LOGON_USERS)
			return E_FAIL;
		
		dwUsedSize += sizeof(SGBVT_CLIENT_HEADER);
		
		// Unpack each user from the received packet and add to the user vector
		for(dwCurrentClient = 0;dwCurrentClient < pClientHeader->dwUserCount; ++dwCurrentClient)
		{
			pNewUser = new CSessionUser;
			
			dwUserBufferSize = *pdwBuffSize - dwUsedSize;
			if((hr = pNewUser->UnpackFromBuffer(pBuff + dwUsedSize, &dwUserBufferSize)) != S_OK)
			{
				delete pNewUser;
				goto Exit;
			}
			
			m_UserVector.push_back(*pNewUser);
			delete pNewUser;
			
			dwUsedSize += dwUserBufferSize;
		}
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  AddUser
 *
 *  Description:
 *      Adds a user to the list of users associated with this client
 *
 *  Arguments:
 *      CSessionUser        &SessionUser        Reference to the session user to be associated
 *                                              with this client
 *
 *  Returns:  
 *      S_OK if the user was succesfully associated with the client
 *      S_FALSE if the client already has the maximum number of users
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CClientConnection::AddUser(CSessionUser &SessionUser)
{
	if(m_UserVector.size() == XONLINE_MAX_LOGON_USERS)
		return S_FALSE;

	m_UserVector.push_back(SessionUser);

	return S_OK;
}

/****************************************************************************
 *
 *  ClearUsers
 *
 *  Description:
 *      Erases all existing users from the client connection object
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CClientConnection::ClearUsers()
{
	SGBVT_USERVECTOR::iterator UserBegin, UserEnd;

	UserBegin = m_UserVector.begin();
	UserEnd = m_UserVector.end();

	m_UserVector.erase(UserBegin, UserEnd);
}

void CClientConnection::SetSocket(SOCKET Socket)
{
	m_ClientSocket = Socket;
}

SOCKET CClientConnection::GetSocket()
{
	return m_ClientSocket;
}

void CClientConnection::SetAsNew()
{
	m_fNew = TRUE;
}

void CClientConnection::SetAsOld()
{
	m_fNew = FALSE;
}

BOOL CClientConnection::IsNew()
{
	return m_fNew;
}

void CClientConnection::ResetIncomingHeartbeatTimer()
{
	m_IncomingHeartbeatTimer.Start();
}

void CClientConnection::ResetOutgoingHeartbeatTimer()
{
	m_OutgoingHeartbeatTimer.Start();
}

void CClientConnection::SetAsDisconnected()
{
	m_fDisconnected = TRUE;
	if(m_ClientSocket != INVALID_SOCKET)
	{
		closesocket(m_ClientSocket);
		m_ClientSocket = INVALID_SOCKET;
	}
}

BOOL CClientConnection::IsDisconnected()
{
	return m_fDisconnected;
}

BOOL CClientConnection::IsIncomingHearbeatExpired()
{
	return m_IncomingHeartbeatTimer.HasTimeExpired();
}

BOOL CClientConnection::IsOutgoingHeartbeatExpired()
{
	return m_OutgoingHeartbeatTimer.HasTimeExpired();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\ListenSocket.cpp ===
// ListenSocket.cpp: implementation of the CListenSocket class.
//
//////////////////////////////////////////////////////////////////////

#include "ListenSocket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CListenSocket::CListenSocket()
{
	m_fListening = FALSE;
	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
	m_ListenSocket = INVALID_SOCKET;
}

CListenSocket::~CListenSocket()
{
	UnregisterKey();
	
	if(m_fListening)
		closesocket(m_ListenSocket);
}

/****************************************************************************
 *
 *  IsConnectionPending
 *
 *  Description:
 *      Return whether or not there are any pending connections available on
 *      the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if there are incoming connections pending
 *      S_FALSE if there are no incoming connections pending
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CListenSocket::IsConnectionPending()
{
	HRESULT hr = S_FALSE;
	INT nActiveSockets = 0;

    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(m_ListenSocket, &readfds);

    fd_set exceptfds;
    FD_ZERO(&exceptfds);
    FD_SET(m_ListenSocket, &exceptfds);
    
    TIMEVAL sTimeout = {0, 0}; 

	if(!m_fListening)
		return E_FAIL;

    nActiveSockets = select(0, &readfds, NULL, &exceptfds, &sTimeout);

    if(nActiveSockets <= 0)
    {
        hr = S_FALSE;
        goto Exit;
    }
                
    if(FD_ISSET(m_ListenSocket, &exceptfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(!FD_ISSET(m_ListenSocket, &readfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

	hr = S_OK;

Exit:

	return hr;
}

/****************************************************************************
 *
 *  StartListening
 *
 *  Description:
 *      Create a host socket, set it to non-blocking, bind it to a designated port
 *      and begin listening for incoming connections
 *
 *  Arguments:
 *      WORD                wPort               Port to listen for incoming connection
 *                                              requests on
 *
 *  Returns:  
 *      S_OK if the socket was created and is listening
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CListenSocket::StartListening(WORD wPort)
{
	SOCKADDR_IN ListenAddress;
    ULONG uNonBlockParam = TRUE;

	if(m_fListening)
		return TRUE;

	m_ListenSocket = socket( AF_INET, SOCK_DGRAM, 0 );

	if(m_ListenSocket == INVALID_SOCKET)
		goto Exit;

	if(SOCKET_ERROR == ioctlsocket(m_ListenSocket, FIONBIO, &uNonBlockParam))
		goto Exit;

	ListenAddress.sin_family = AF_INET;
    ListenAddress.sin_port = htons(wPort);
    ListenAddress.sin_addr.s_addr = INADDR_ANY;

	if(SOCKET_ERROR == bind(m_ListenSocket, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress)))
		goto Exit;

	m_fListening = TRUE;

Exit:

	if(!m_fListening)
	{
		if(m_ListenSocket != INVALID_SOCKET)
		{
			closesocket(m_ListenSocket);
			m_ListenSocket = INVALID_SOCKET;
		}
	}

	return m_fListening ? S_OK : E_FAIL;
}

/****************************************************************************
 *
 *  GetSocket
 *
 *  Description:
 *      Returns the socket
 *
 *  Arguments:
 *
 *  Returns:  
 *      The socket member variable
 *
 ****************************************************************************/
SOCKET CListenSocket::GetSocket()
{
	return m_ListenSocket;
}

/****************************************************************************
 *
 *  UnregisterKey
 *
 *  Description:
 *      Unregisters the security information used for the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CListenSocket::UnregisterKey()
{
	if(!m_pSessionID)
		return;

	XNetUnregisterKey(m_pSessionID);

	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\ListenSocket.h ===
// ListenSocket.h: interface for the CListenSocket class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

// Defines the maximum simultaneous incoming client connection requests allowed
#define MAX_CONNECTION_BACKLOG 5 

class CListenSocket  
{
public:
	void UnregisterKey();
	SOCKET GetSocket();
	HRESULT StartListening(WORD wPort);
	HRESULT IsConnectionPending();
	CListenSocket();
	virtual ~CListenSocket();

protected:
	SOCKET m_ListenSocket;
	BOOL m_fListening;
	XNKID *m_pSessionID;
	XNKEY *m_pKeyExchangeKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\ansibstr.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    AnsiBstr.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/

#ifndef _ANSIBSTR_H_
#define _ANSIBSTR_H_

class AnsiBstr
    {
    public:
        PCHAR astr;
        BSTR bstr;

    public:
        AnsiBstr();
        AnsiBstr(BSTR b);
        AnsiBstr(PCHAR a);

        void SetStr(BSTR b);
        void SetStr(PCHAR a);

        operator PCHAR(void) const { return astr; }
        operator BSTR(void) const { return bstr; }


        ~AnsiBstr();
    };

extern PCHAR CreateAnsiFromBstr(BSTR bstr);
extern BSTR CreateBstrFromAnsi(PCHAR pszText);

#endif // _ANSIBSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\SGBVT.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SGBVT.cpp
 *  Content:    SGBVT tests
 *  History:
 *   Date		By		Reason
 *   ====	==		======
 *  2/18/02    johnblac	Ripped from Tristan's onlinestress tool
 *
 ****************************************************************************/

#include "SGBVT.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

HANDLE g_hLog = NULL;
CLogonTask *g_pLogonTask = NULL;
BOOL g_fExitTest = FALSE;

/****************************************************************************
 *
 *  TRACE
 *
 ****************************************************************************/
void WINAPI TRACE(LPCWSTR szFormat, ...) {
	WCHAR szBuffer[1024] = L"";
	va_list pArgs; 
	va_start(pArgs, szFormat);
	
	wvsprintf(szBuffer, szFormat, pArgs);
	
	va_end(pArgs);

	OutputDebugString(szBuffer);
}

/****************************************************************************
 *
 *  SendPacket
 *
 *  Description:
 *      Sends data to the socket until the request completes, or the specified
 *      timer has expired
 *
 *  Arguments:
 *      SOCKET                 Socket              Socket from which to send the packet
 *      CHAR                   *pBuff              Buffer to send the packet from
 *      INT                    nSizeToSend         Ammount of data to send
 *      COnlineTimer           *pTimer             If this object expires, then the send will fail
 *                                                 If NULL, return immediately if send fails
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the socket timed out
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT SendPacket(SOCKET Socket, CHAR *pBuff, INT nSizeToSend, COnlineTimer *pTimer, sockaddr_in* pDestAddr)
{
	HRESULT hr = S_OK;
	INT nSentSize = 0, nRet = 0;

	if(pTimer)
		pTimer->Start();

	do
	{
		nRet = sendto(Socket, pBuff, nSizeToSend, 0, (sockaddr*)pDestAddr, sizeof(sockaddr_in));
		// If a socket error other than WOULDBLOCK occurs, then bail
		if(nRet == SOCKET_ERROR)
		{
			// Keep trying until timeout for a WOULDBLOCK error
			if(WSAGetLastError() == WSAEWOULDBLOCK)
			{
				Sleep(0);
				hr = S_FALSE;
				continue;
			}

			LOGTASKINFO(g_hLog, "Unexpected socket error received from client");
			return E_FAIL;
		}
		
		// If we read the client size, then continue to the next stage
		if(nRet == nSizeToSend)
		{
			hr = S_OK;
			break;
		}
	}
	while(pTimer && (!pTimer->HasTimeExpired()));

	return hr;
}

/****************************************************************************
 *
 *  ReadPacket
 *
 *  Description:
 *      Reads data from the socket until either the amount of data requested
 *      has been received, or the specified timer has expired
 *
 *  Arguments:
 *      SOCKET                 Socket              Socket from which to read the packet
 *      CHAR                   *pBuff              Buffer in which to put the packet
 *      INT                    nSizeToRead         Ammount of data to read
 *      COnlineTimer           *pTimer             If this object expires, then the read will fail
 *                                                 If NULL, return immediately if nothing to read
 *
 *  Returns:  
 *      S_OK all data was 
 *      S_FALSE if the socket timed out
 *      E_FAIL if the there was a system error
 *
 ****************************************************************************/
HRESULT ReadPacket(SOCKET Socket, CHAR *pBuff, INT nSizeOfBuffer, COnlineTimer *pTimer, sockaddr_in* pSrcAddr, int* piBuffSize)
{
	HRESULT hr = S_OK;
	int iSizeOfSock = sizeof(sockaddr_in);

	if(pTimer)
		pTimer->Start();

	do
	{
		*piBuffSize = recvfrom(Socket, pBuff, nSizeOfBuffer, 0, (sockaddr*)pSrcAddr, &iSizeOfSock);
		// If a socket error other than WOULDBLOCK occurs, then bail
		if(*piBuffSize == SOCKET_ERROR)
		{
			// Keep trying until timeout for a WOULDBLOCK error
			if(WSAGetLastError() == WSAEWOULDBLOCK)
			{
				Sleep(0);
				hr = S_FALSE;
				continue;
			}

			LOGTASKINFO(g_hLog, "Unexpected socket error received from client");
			return E_FAIL;
		}
		// If the socket was closed on the other end, then bail
		else if(*piBuffSize == 0)
		{
			LOGTASKINFO(g_hLog, "Client socket closed unexpectedly");
			return E_FAIL;
		}
		else if(*piBuffSize > nSizeOfBuffer)
		{
			// We overflowed, all is lost
			hr = E_OVERFLOW;
			break;
		}
		else
		{
			// We got a valid packet, we're done
			break;
		}
	}
	while(pTimer && (!pTimer->HasTimeExpired()));

	return hr;
}


/****************************************************************************
 *
 *  CreateListenSocket
 *
 *  Description:
 *      Create a host socket and begin listening for incoming connections
 *
 *  Arguments:
 *      CListenSocket         *pListenSocket      The socket that will be created to handle incoming
 *                                                connection requests
 *      XNKID                 pSessionID          XNKID to register with the network stack
 *      XNKEY                 pKeyExchangeKey     XNKEY to register with the network stack
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT CreateListenSocket(CListenSocket **ppListenSocket, XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	HRESULT hr = S_OK;

	if(!ppListenSocket || !pSessionID || !pKeyExchangeKey)
		return E_FAIL;

	*ppListenSocket = new CListenSocket();

	hr = (*ppListenSocket)->StartListening(SGBVT_HOST_PORT);
	if(hr != S_OK)
		goto Exit;

Exit:

	if(hr != S_OK)
	{
		delete *ppListenSocket;
		*ppListenSocket = NULL;
	}

	return hr;
}

/****************************************************************************
 *
 *  SearchForStressSession
 *
 *  Description:
 *      Searches for active stress sessions with available slots
 *
 *  Arguments:
 *      XNADDR                *pHostXnAddr       XNADDR of the host session that was found
 *      XNKID                 *pSessionID         XNKID of the host session that was found
 *      XNKEY                 *pKeyExchangeKey    XNKEY of the host session that was found
 *
 *  Returns:  
 *      S_OK if a stress session with extra space was found
 *      S_FALSE if a stress session wasn't found
 *      E_FAIL if there was some kind of system failure
 *
 ****************************************************************************/
HRESULT SearchForStressSession(XNADDR *pHostXnAddr, XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	XONLINETASK_HANDLE hSearchTask = NULL;
	PXMATCH_SEARCHRESULT *ppSearchResults = NULL;
	COnlineTimer SearchTimer;
	HRESULT hr = S_OK;
	HANDLE hWorkEvent = NULL;
	DWORD dwResultsCount = 0, dwCurrentResult = 0;

	if(!pHostXnAddr || !pSessionID || !pKeyExchangeKey)
	{
		LOGTASKINFO(g_hLog, "Invalid parameters");
		hr = E_FAIL;
		goto Exit;
	}

	// Create an event to be associated with the match search task
	hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hWorkEvent)
	{
		LOGTASKINFO(g_hLog, "Couldn't create event for match search");
		hr = E_FAIL;
		goto Exit;
	}

	// Start the search for an available stress session
	hr = XOnlineMatchSearch(SGBVT_SEARCH_PROC, SGBVT_MAX_RESULTS, 0, NULL, SGBVT_MAX_RESULTS_LEN, hWorkEvent, &hSearchTask);
	if(FAILED(hr))
	{
		LOGTASKINFOHR(g_hLog, "Error starting matchmaking search", hr);
		hr = E_FAIL;
		goto Exit;
	}


	SearchTimer.SetAllowedTime(SGBVT_MAX_MATCH_SEARCH_TIME);
	SearchTimer.Start();

	// Pump the search task until completion
	do
	{
		if(WaitForSingleObject(hWorkEvent, SearchTimer.GetTimeRemaining()) != WAIT_OBJECT_0)
			continue;

		hr = XOnlineTaskContinue(hSearchTask);
		if(XONLINETASK_STATUS_AVAILABLE(hr))
			break;

	} while(!SearchTimer.HasTimeExpired());

	if(SearchTimer.HasTimeExpired())
	{
		LOGTASKINFO(g_hLog, "Timed out searching for host session");
		hr = S_FALSE;
		goto Exit;
	}

	// Get the results of the search for host sessions
	hr = XOnlineMatchSearchGetResults(hSearchTask, &ppSearchResults, &dwResultsCount);
	if(FAILED(hr))
	{
		LOGTASKINFOHR(g_hLog, "Error getting matchmaking search results", hr);
		hr = E_FAIL;
		goto Exit;
	}

	// If no results were found, then exit and indicate this
	if(!dwResultsCount)
	{
		LOGTASKINFO(g_hLog, "No host sessions found");
		hr = S_FALSE;
		goto Exit;
	}

	// Parse through the results and find the first one that has available slots
	for(dwCurrentResult = 0; dwCurrentResult < dwResultsCount; ++dwCurrentResult)
	{
		if((ppSearchResults[dwCurrentResult])->dwPublicAvailable > (ppSearchResults[dwCurrentResult])->dwPublicCurrent)
		{
			LOGTASKINFO(g_hLog, "Found a host session with available slots");
			break;
		}
	}

	// If we looped through the entire search results list and didn't find a session with available slots
	// then indicate this
	if(dwCurrentResult == dwResultsCount)
	{
		LOGTASKINFO(g_hLog, "Host sessions found, but none had available slots");
		hr = S_FALSE;
		goto Exit;
	}

	
	// Return all of the info needed to connect to this session
	memcpy(pHostXnAddr, &((ppSearchResults[dwCurrentResult])->HostAddress), sizeof(XNADDR));
	memcpy(pSessionID, &((ppSearchResults[dwCurrentResult])->SessionID), sizeof(XNKID));
	memcpy(pKeyExchangeKey, &((ppSearchResults[dwCurrentResult])->KeyExchangeKey), sizeof(XNKEY));

Exit:

	if(hSearchTask)
	{
		XOnlineTaskClose(hSearchTask);
		hSearchTask = NULL;
	}

	return hr;
}


/****************************************************************************
 *
 *  SearchForStressSession
 *
 *  Description:
 *      Searches for active stress sessions with available slots
 *
 *  Arguments:
 *      XNKID                 *pSessionID         XNKID of the host session to delete
 *
 *  Returns:  
 *      S_OK if a stress session specified was successfully deleted
 *      S_FALSE if we timed out before the session delete could complete
 *      E_FAIL if there was some kind of system failure
 *
 ****************************************************************************/
HRESULT DeleteStressSession(XNKID *pSessionID)
{
	XONLINETASK_HANDLE hDeleteTask = NULL;
	COnlineTimer DeleteTimer;
	HRESULT hr = S_OK;
	HANDLE hWorkEvent = NULL;

	if(!pSessionID)
	{
		LOGTASKINFO(g_hLog, "Invalid parameters");
		hr = E_FAIL;
		goto Exit;
	}

	// Create an event to be associated with the session delete task
	hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hWorkEvent)
	{
		LOGTASKINFO(g_hLog, "Couldn't create event for session delete");
		hr = E_FAIL;
		goto Exit;
	}

	// Start the delete task for the host session
	hr = XOnlineMatchSessionDelete(*pSessionID, hWorkEvent, &hDeleteTask);
	if(FAILED(hr))
	{
		LOGTASKINFOHR(g_hLog, "Error starting session delete", hr);
		hr = E_FAIL;
		goto Exit;
	}


	DeleteTimer.SetAllowedTime(SGBVT_MAX_SESSION_DELETE_TIME);
	DeleteTimer.Start();

	// Pump the delete task until completion
	do
	{
		if(WaitForSingleObject(hDeleteTask, DeleteTimer.GetTimeRemaining()) != WAIT_OBJECT_0)
			continue;

		hr = XOnlineTaskContinue(hDeleteTask);
		if(XONLINETASK_STATUS_AVAILABLE(hr))
			break;

	} while(!DeleteTimer.HasTimeExpired());

	if(DeleteTimer.HasTimeExpired())
	{
		LOGTASKINFO(g_hLog, "Timed out trying to delete session");
		hr = S_FALSE;
		goto Exit;
	}

Exit:

	if(hDeleteTask)
	{
		XOnlineTaskClose(hDeleteTask);
		hDeleteTask = NULL;
	}

	return hr;
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      The stress test can be compiled in three ways:
 *         1) As a standalone Xbox XBE not running under the harness (i.e. _XBOX and NOLOGGING are defined)
 *         2) As an Xbox harness lib (i.e. _XBOX is defined and NOLOGGING is NOT defined)
 *         3) As a standalone PC app using CXOnline (i.e. _XBOX and NOLOGGING are NOT defined)
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#if defined(_XBOX) && defined(NOLOGGING)
int __cdecl main(int argc, char * argv[])
#else
#if !defined(_XBOX)
#define NOLOGGING
class CStressXOnline : public CXOnline
{
public:
    CStressXOnline(char * pszXbox = NULL) : CXOnline(pszXbox) {}
    int Main(int argc, char * argv[]);
	// BUGBUG - need to add entries for every function 
};

int __cdecl main(int argc, char * argv[])
{
    int result;
    char buffer[128];

    sprintf(buffer, "%s@Nic/0", getenv("COMPUTERNAME") );
    CStressXOnline * pTestXOnline = new CStressXOnline(buffer);
    result = pTestXOnline->Main(argc, argv);
    delete pTestXOnline;
    return(result);
}

int CStressXOnline::Main(int argc, char * argv[])
#endif
#endif

#ifdef NOLOGGING
{
    SGBVT_StartTest( NULL );
    SGBVT_EndTest();
}
#endif // NOLOGGING


/****************************************************************************
 *
 *  SGBVT_Logon
 *
 *  Description:
 *	Calls XOnlineLogon and pumps.  This code is reused freqnetly so it has been seperated
 *	into a sub function for ease of use.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT SGBVT_Logon(CLogonTask* pLogonTask, COnlineTimer* pTimer)
{
	// Start logon async task
	if(!pLogonTask->StartTask())
	{
		return pLogonTask->GetLastResult();
	}

	pTimer->SetAllowedTime(MAX_LOGON_TIME);
	pTimer->Start();

	// Pump task until complete
	while(!pLogonTask->IsConnectionEstablished())
	{
		if(pTimer->HasTimeExpired())
			break;

		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(!pLogonTask->WaitForWork(pTimer->GetTimeRemaining()))
			break;

		pLogonTask->TaskContinue();
	}

	return S_OK;
}


/****************************************************************************
 *
 *  sgbvt_BasicTest
 *
 *  Description:
 *      Basic Test for sgbvt
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT SGBVT( void )
{
	HRESULT	hr = S_OK;
	CLogonTask LogonTask;
	CFriendEnumTask			FriendEnumTask;
	COfferingEnumerateTask	OfferingEnumerateTask;
	CContentInstallTask		*pContentInstallTask = NULL;
	CContentVerifyTask		*pContentVerifyTask = NULL;
	CContentRemoveTask		*pContentRemoveTask = NULL;
	COnlineTimer				Timer;
	XONLINE_FRIEND			*pFriendList = NULL;
	PXONLINEOFFERING_INFO		*rgpEnumInfo;
	XONLINE_USER UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	DWORD					ServicesArray[] =
	{
		XONLINE_MATCHMAKING_SERVICE,
		XONLINE_BILLING_OFFERING_SERVICE
		// TODO - Add content-download here when it is figured out
	};
	DWORD dwServicesCount = sizeof(ServicesArray) / sizeof(DWORD);
	DWORD dwFriendCount = 0, dwResultsCount = 0, dwOfferingCount = 0, dwNumUsers = 0;
	BOOL fPartialResults = FALSE;

	//------------------------
	// LOGON STAGE - 4 users
	//------------------------

	LogonTask.RegisterLogHandle(g_hLog);

	// The logon task will automatically login with as many users as possible

	// Need to add the matchmaking and content services since they aren't included by default
	if(!LogonTask.SetServices(ServicesArray, dwServicesCount))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Fill the users array with all of the users on the HD
	// We created 8 so I can be confident that I got the first 4 back (XONLINE_MAX_LOGON_USERS)
	XOnlineGetUsers(UsersArray, &dwNumUsers);
//	Assert(dwNumUsers == XONLINE_MAX_LOGON_USERS);

	// Set the member users array to match the one we've munged
	if(!LogonTask.SetUsers(UsersArray))
	{
		hr = E_FAIL;
		goto Exit;
	}

	hr = SGBVT_Logon(&LogonTask, &Timer);
	if(FAILED(hr))
	{
		goto Exit;
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon 4 users timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test 4 users: PASSED");

	//------------------------
	// LOGON STAGE - Double Logon
	//------------------------

	// Logon with 4 users
	// Start logon async task
	if(!LogonTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Logon again - should work
	if(!LogonTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_LOGON_TIME);
	Timer.Start();

	// Pump task until complete
	while(!LogonTask.IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;

		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(!LogonTask.WaitForWork(Timer.GetTimeRemaining()))
			break;

		LogonTask.TaskContinue();
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Double logon timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test double Logon: PASSED");

	
	//------------------------
	// LOGON STAGE - 0 users
	//------------------------

	// Empty the Users Array
	memset(UsersArray, 0, 4*sizeof(XONLINE_USER));

	// Set the member users array to match the one we've munged
	if(!LogonTask.SetUsers(UsersArray))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Logon with no users
	hr = SGBVT_Logon(&LogonTask, &Timer);
	if(FAILED(hr))
	{
		goto Exit;
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon 0 users timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test 0 Users: PASSED");

	//------------------------
	// LOGON STAGE - 1 user
	//------------------------

	// Fill the users array with all of the users on the HD
	// We created 8 so I can be confident that I got the first 4 back (XONLINE_MAX_LOGON_USERS)
	XOnlineGetUsers(UsersArray, &dwNumUsers);
//	Assert(dwNumUsers == XONLINE_MAX_LOGON_USERS);

	// Empty the last three Users in the Array
	memset(&(UsersArray[1]), 0, 3*sizeof(XONLINE_USER));	// Users 2-4 deleted

	// Set the member users array to match the one we've munged
	// User 1 logs in
	if(!LogonTask.SetUsers(UsersArray))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Logon with no users
	hr = SGBVT_Logon(&LogonTask, &Timer);
	if(FAILED(hr))
	{
		goto Exit;
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon 1 user timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test 1 User: PASSED");

	//------------------------
	// LOGON STAGE - 2 users
	//------------------------

	// Fill the users array with all of the users on the HD
	// We created 8 so I can be confident that I got the first 4 back (XONLINE_MAX_LOGON_USERS)
	XOnlineGetUsers(UsersArray, &dwNumUsers);
//	Assert(dwNumUsers == XONLINE_MAX_LOGON_USERS);

	// Empty the last two Users in the Array
	memset(&(UsersArray[2]), 0, 2*sizeof(XONLINE_USER));	// Users 2-4 deleted

	// Set the member users array to match the one we've munged
	// User 1 logs in
	if(!LogonTask.SetUsers(UsersArray))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Logon with no users
	hr = SGBVT_Logon(&LogonTask, &Timer);
	if(FAILED(hr))
	{
		goto Exit;
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon 2 users timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test 2 users: PASSED");

	//------------------------
	// LOGON STAGE - 2 different users
	//------------------------

	// Fill the users array with all of the users on the HD
	// We created 8 so I can be confident that I got the first 4 back (XONLINE_MAX_LOGON_USERS)
	XOnlineGetUsers(UsersArray, &dwNumUsers);
//	Assert(dwNumUsers == XONLINE_MAX_LOGON_USERS);

	// Empty the first two users in the array
	memset(&(UsersArray[0]), 0, 2*sizeof(XONLINE_USER));	// First two users deleted

	// Set the member users array to match the one we've munged
	// Users 2 and 4 log in	
	if(!LogonTask.SetUsers(UsersArray))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Logon with no users
	hr = SGBVT_Logon(&LogonTask, &Timer);
	if(FAILED(hr))
	{
		goto Exit;
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon 2 different users timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test 2 different users: PASSED");	

	//------------------------
	// LOGON STAGE - Timeout connection
	//------------------------

	// Fill the users array with all of the users on the HD
	// We created 8 so I can be confident that I got the first 4 back (XONLINE_MAX_LOGON_USERS)
	XOnlineGetUsers(UsersArray, &dwNumUsers);
//	Assert(dwNumUsers == XONLINE_MAX_LOGON_USERS);

	// Set the member users array to match the one we've munged
	// All 4 users log in
	if(!LogonTask.SetUsers(UsersArray))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Logon with 4 users
	// Start logon async task
	if(!LogonTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_LOGON_TIME);
	Timer.Start();

	// Pump task until complete
	while(!LogonTask.IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;

		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(!LogonTask.WaitForWork(Timer.GetTimeRemaining()))
			break;

		LogonTask.TaskContinue();
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Timeout test timed-out early");
		hr = E_FAIL;
		goto Exit;
	}

	// Wait 125 seconds, the time it takes for the SG to time out a client
	Sleep(XBOX_TIMEOUT);
	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "XNet stack didn't maintain pulses");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test timeout: PASSED");

	//------------------------
	// PRESENCE STAGE
	//------------------------

	FriendEnumTask.RegisterLogHandle(g_hLog);

	// The buddy enum task will automatically use the player at index 0

	// Start buddy enum async task
	if(!FriendEnumTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_GAMER_ENUM_TIME);
	Timer.Start();

	// Pump task for MAX_GAMER_ENUM_TIME seconds
	while(!FriendEnumTask.IsFriendListUpToDate())
	{
		if(Timer.HasTimeExpired())
		{
			LOGTASKINFO(g_hLog, "Friend enumeration task timed out");
			break;
		}

		FriendEnumTask.TaskContinue();
	}

	if(!FriendEnumTask.IsFriendListUpToDate())
	{
		LOGTASKINFO(g_hLog, "Friend enumeration task didn't report an up-to-date list");
		hr = E_FAIL;
		goto Exit;
	}

	dwFriendCount = FriendEnumTask.GetLatestFriendList(&pFriendList);

	LOGTASKINFO(g_hLog, "Friend test: PASSED");

	//------------------------
	// OFFERING ENUMERATION STAGE
	//------------------------

	OfferingEnumerateTask.RegisterLogHandle(g_hLog);

	// Start match session creation task
	if(!OfferingEnumerateTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Iterate through offering enumeration until there are no more results
	do
	{
		//	Timer.SetAllowedTime(MAX_ENUMERATION_TIME);
		Timer.SetAllowedTime(100000000);
		Timer.Start();
		
		// Pump task for MAX_ENUMERATION_TIME seconds
		do
		{
			if(Timer.HasTimeExpired())
				break;
			
			LogonTask.TaskContinue();
			OfferingEnumerateTask.TaskContinue();
		}while(!OfferingEnumerateTask.IsTaskComplete());
		
		if(!OfferingEnumerateTask.IsTaskComplete())
		{
			LOGTASKINFO(g_hLog, "Offering enumeration timed-out");
			hr = E_FAIL;
			goto Exit;
		}
		
		dwResultsCount = 0;
		fPartialResults = FALSE;
		hr = OfferingEnumerateTask.GetResults(&rgpEnumInfo, &dwResultsCount, &fPartialResults);
		xLog(g_hLog, XLL_INFO, "%u results returned by offering enumeration");

		if(!dwResultsCount)
		{
			LOGTASKINFO(g_hLog, "Offering enumeration didn't return any results");
			hr = E_FAIL;
			goto Exit;
		}


		do
		{
			pContentInstallTask = new CContentInstallTask;
			pContentVerifyTask = new CContentVerifyTask;
			pContentRemoveTask = new CContentRemoveTask;

			if(!pContentInstallTask || !pContentVerifyTask || !pContentRemoveTask)
			{
				LOGTASKINFO(g_hLog, "Couldn't allocate content tasks");
				hr = E_FAIL;
				goto Exit;
			}

			pContentInstallTask->RegisterLogHandle(g_hLog);
			pContentVerifyTask->RegisterLogHandle(g_hLog);
			pContentRemoveTask->RegisterLogHandle(g_hLog);

		    pContentInstallTask->SetOfferingID((rgpEnumInfo[dwOfferingCount])->OfferingId);
			pContentVerifyTask->SetOfferingID((rgpEnumInfo[dwOfferingCount])->OfferingId);
			pContentRemoveTask->SetOfferingID((rgpEnumInfo[dwOfferingCount])->OfferingId);

			++dwOfferingCount;

			//
			// Start installing the content
			//

			xLog(g_hLog, XLL_INFO, "Installing offering %u", dwOfferingCount);
			if(!pContentInstallTask->StartTask())
			{
				LOGTASKINFO(g_hLog, "Error starting content download");
				hr = E_FAIL;
				goto Exit;
			}

			//	Timer.SetAllowedTime(MAX_INSTALL_TIME);
			Timer.SetAllowedTime(100000000);
			Timer.Start();

			// Pump task for MAX_INSTALL_TIME seconds
			do
			{
				if(Timer.HasTimeExpired())
					break;
				
				LogonTask.TaskContinue();
				pContentInstallTask->TaskContinue();
			}while(!pContentInstallTask->IsTaskComplete());
			
			if(!pContentInstallTask->IsTaskComplete())
			{
				LOGTASKINFO(g_hLog, "Content install timed-out");
				hr = E_FAIL;
				goto Exit;
			}

			if(FAILED(pContentInstallTask->GetLastResult()))
			{
				LOGTASKINFO(g_hLog, "Content install failed");
				hr = E_FAIL;
				goto Exit;
			}

			delete pContentInstallTask;
			pContentInstallTask = NULL;

			xLog(g_hLog, XLL_INFO, "Installed offering %u successfully", dwOfferingCount);

			//
			// Start verifing the content
			//

			xLog(g_hLog, XLL_INFO, "Verifying offering %u", dwOfferingCount);
			if(!pContentVerifyTask->StartTask())
			{
				LOGTASKINFO(g_hLog, "Error starting content verification");
				hr = E_FAIL;
				goto Exit;
			}

			//	Timer.SetAllowedTime(MAX_VERIFICATION_TIME);
			Timer.SetAllowedTime(100000000);
			Timer.Start();

			// Pump task for MAX_VERIFICATION_TIME seconds
			do
			{
				if(Timer.HasTimeExpired())
					break;
				
				LogonTask.TaskContinue();
				pContentVerifyTask->TaskContinue();
			}while(!pContentVerifyTask->IsTaskComplete());
			
			if(!pContentVerifyTask->IsTaskComplete())
			{
				LOGTASKINFO(g_hLog, "Content verification timed-out");
				hr = E_FAIL;
				goto Exit;
			}

			if(FAILED(pContentVerifyTask->GetLastResult()))
			{
				LOGTASKINFO(g_hLog, "Content verification failed");
				hr = E_FAIL;
				goto Exit;
			}

			delete pContentVerifyTask;
			pContentVerifyTask = NULL;

			xLog(g_hLog, XLL_INFO, "Verified offering %u successfully", dwOfferingCount);

			//
			// Start remove the content
			//

			xLog(g_hLog, XLL_INFO, "Removing offering %u", dwOfferingCount);
			if(!pContentRemoveTask->StartTask())
			{
				LOGTASKINFO(g_hLog, "Error starting content removal");
				hr = E_FAIL;
				goto Exit;
			}

			//	Timer.SetAllowedTime(MAX_REMOVAL_TIME);
			Timer.SetAllowedTime(100000000);
			Timer.Start();

			// Pump task for MAX_REMOVAL_TIME seconds
			do
			{
				if(Timer.HasTimeExpired())
					break;
				
				LogonTask.TaskContinue();
				pContentRemoveTask->TaskContinue();
			}while(!pContentRemoveTask->IsTaskComplete());
			
			if(!pContentRemoveTask->IsTaskComplete())
			{
				LOGTASKINFO(g_hLog, "Content removal timed-out");
				hr = E_FAIL;
				goto Exit;
			}

			if(FAILED(pContentRemoveTask->GetLastResult()))
			{
				LOGTASKINFO(g_hLog, "Content removal failed");
				hr = E_FAIL;
				goto Exit;
			}

			delete pContentRemoveTask;
			pContentRemoveTask = NULL;

			xLog(g_hLog, XLL_INFO, "Removed offering %u successfully", dwOfferingCount);

		} while(--dwResultsCount);


	} while(!FAILED(hr) && fPartialResults);

	if(FAILED(hr))
	{
		LOGTASKINFOHR(g_hLog, "Offering enumeration failed", hr);
		hr = E_FAIL;
		goto Exit;
	}

	//------------------------
	// MAINTAIN LOGON
	//------------------------
	
	//	Stay online for another minute
	Timer.SetAllowedTime(60000);
	Timer.Start();

	while(LogonTask.IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;

		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(LogonTask.WaitForWork(30000))
			LogonTask.TaskContinue();
	}

Exit:

	pContentInstallTask ? delete pContentInstallTask : 0;
	pContentVerifyTask ? delete pContentVerifyTask : 0;
	pContentRemoveTask ? delete pContentRemoveTask : 0;

	//
	// Return the Hresult
	//

	if(FAILED(hr))
		xLog(g_hLog, XLL_FAIL, "Test failed");
	else
		xLog(g_hLog, XLL_PASS, "Test passed");

	return hr;
}


/****************************************************************************
 *
 *  SGBVT_BasicTest
 *
 *  Description:
 *      Basic Test for SGBVT
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT SGBVT_BasicTest( void )
{

	CLogonTask*		pLogonTask;
	COnlineTimer		Timer;
	HRESULT			hr              = S_OK;
	DWORD					ServicesArray[] =
	{
		XONLINE_USER_ACCOUNT_SERVICE,
		XONLINE_MATCHMAKING_SERVICE
	};

	pLogonTask = new CLogonTask;
	if(!pLogonTask)
	{
		return E_OUTOFMEMORY;
	}
	
	DWORD                   dwServicesCount = sizeof(ServicesArray) / sizeof(DWORD), dwRandTime = 0, dwOnlineStatus = 0;
	XNADDR HostXnAddr;
	XNKID SessionID;
	XNKEY KeyExchangeKey;

	memset(&HostXnAddr, 0, sizeof(HostXnAddr));
	memset(&SessionID, 0, sizeof(SessionID));
	memset(&KeyExchangeKey, 0, sizeof(KeyExchangeKey));
	
	// Set the global logon task
	g_pLogonTask = pLogonTask;
	
	// Populate users accounts from user account creation service
	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD(NULL, 8);
	if(hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Populating user accounts failed.");
		goto Exit;
	}
	
	pLogonTask->RegisterLogHandle(g_hLog);
	
	// The logon task will automatically login with as many users as possible
	
	// Add any requested services
	if(!pLogonTask->SetServices(ServicesArray, dwServicesCount))
	{
		hr = E_FAIL;
		goto Exit;
	}
	
	// Start logon async task
	if(!pLogonTask->StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}
	
	Timer.SetAllowedTime(MAX_LOGON_TIME);
	Timer.Start();
	
	// Pump task until complete
	while(!pLogonTask->IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;
		
		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(!pLogonTask->WaitForWork(Timer.GetTimeRemaining()))
		{
			LOGTASKINFO(g_hLog, "Logon task wasn't signalled");
			break;
		}
		
		pLogonTask->TaskContinue();
	}
	
	if(!pLogonTask->IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon timed-out");
		hr = E_FAIL;
		goto Exit;
	}
	
	// See if we can find a stress session to join
	hr = SearchForStressSession(&HostXnAddr, &SessionID, &KeyExchangeKey);

	// If a stress session was found with space left, then connect as a client
	if(hr == S_OK)
	{
		xLog(g_hLog, XLL_INFO, "Connecting to Match making session on %02x-%02x-%02x-%02x-%02x-%02x",
			HostXnAddr.abEnet[0],
			HostXnAddr.abEnet[1],
			HostXnAddr.abEnet[2],
			HostXnAddr.abEnet[3],
			HostXnAddr.abEnet[4],
			HostXnAddr.abEnet[5]);

		hr = client_Main(&HostXnAddr, &SessionID, &KeyExchangeKey);
	}
	// If a stress session wasn't found, then create one
	else if(hr == S_FALSE)
	{
		dwOnlineStatus = XNetGetTitleXnAddr(&HostXnAddr);
		if(!(dwOnlineStatus | XNET_GET_XNADDR_ONLINE))
		{
			LOGTASKINFO(g_hLog, "Error retrieving title XNADDR");
			hr = E_FAIL;
			goto Exit;
		}

		xLog(g_hLog, XLL_INFO, "Hosting stress session on %02x-%02x-%02x-%02x-%02x-%02x",
			HostXnAddr.abEnet[0],
			HostXnAddr.abEnet[1],
			HostXnAddr.abEnet[2],
			HostXnAddr.abEnet[3],
			HostXnAddr.abEnet[4],
			HostXnAddr.abEnet[5]);

		hr = host_Main();
	}
	// If some other error occurred, then exit
	else
	{
		LOGTASKINFOHR(g_hLog, "Error searching for stress session", hr);
		hr = E_FAIL;
		goto Exit;
	}

	if(pLogonTask)
	{
		delete pLogonTask;
		pLogonTask = NULL;
	}

	// Now that we're done with tests that require another server, run basic tests
	hr = SGBVT();

Exit:

	if(pLogonTask)
	{
		delete pLogonTask;
		pLogonTask = NULL;
	}

	if(FAILED(hr))
		TRACE(L"SGBVT FAILED: 0x%08x\n", hr);
	else
		TRACE(L"SGBVT SUCCEEDED\n");

    return hr;
}

/****************************************************************************
 *
 *  SGBVT_StartTest
 *
 *  Description:
 *      The Harness Entry into the SGBVT tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI SGBVT_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;
    XDEVICE_PREALLOC_TYPE deviceTypes[] = {
               {XDEVICE_TYPE_GAMEPAD, 4},
               {XDEVICE_TYPE_MEMORY_UNIT, 8}
    };

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

	g_hLog = LogHandle;

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);

	XNetAddRef();

	//	Sleep(1000);
		
	hr = XOnlineStartup(NULL);
		
	//
	// Test SGBVT in the mannor it was meant to be called
	//
		
	if ( SHOULDRUNTEST( "SGBVT", "Basic" ) )
	{
		SETLOG( LogHandle, "johnblac", "Online", "SGBVT", "Basic" );
		EXECUTE( SGBVT_BasicTest() );
	}
		
	g_hLog = NULL;
		
	hr = XOnlineCleanup();
		
	XNetRelease();
	
}

/****************************************************************************
 *
 *  SGBVT_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI SGBVT_EndTest( VOID )
{
	g_fExitTest = TRUE;
}

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( SGBVT )
#pragma data_seg()

BEGIN_EXPORT_TABLE( SGBVT )
    EXPORT_TABLE_ENTRY( "StartTest", SGBVT_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SGBVT_EndTest )
END_EXPORT_TABLE( SGBVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\SGBVT.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SGBVT.h
 *  Content:    SGBVT utility interface
 *  History:
 *   Date       	By       	Reason
 *   ====      ==		======
 *  2/18/02   johnblac	Ripped from TristanJs onlinestress
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xtestlib.h>
#include <xnetref.h>
#include "OnlineAccounts.h"
#include "FriendEnumTask.h"
#include "OfferingEnumerateTask.h"
#include "ContentInstallTask.h"
#include "ContentVerifyTask.h"
#include "ContentRemoveTask.h"
#include "logontask.h"
#include "matchsessioncreatetask.h"
#include "onlinetimer.h"
#include "clientconnection.h"
#include "sessionuser.h"
#include "listensocket.h"

#define SGBVT_HOST_PORT 1001
#define MAX_NEW_CLIENT_INFO_TIME 5000
#define MAX_SESSION_CREATE_TIME 5000
#define DEFAULT_SLOTS_AVAILABLE 10
#define MAX_LOGON_TIME 30000
#define SGBVT_HOST_WAIT_TIME 5000
#define SGBVT_MAX_CONNECT_TIME 10000
#define SGBVT_MAX_CLIENT_READ_TIME 1000
#define SGBVT_MAX_MATCH_SEARCH_TIME 30000
#define SGBVT_MAX_SESSION_DELETE_TIME 10000
#define LARGEST_PACKET 1430

#define SGBVT_SEARCH_PROC 129
#define SGBVT_SESSION_PARAM (X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0xAAAA)
#define SGBVT_SESSION_VALUE 67890
#define SGBVT_MAX_RESULTS 20
#define SGBVT_MAX_RESULTS_LEN (SGBVT_MAX_RESULTS * sizeof(XMATCH_SEARCHRESULT))

#define XBOX_TIMEOUT				125000
#define MAX_GAMER_ENUM_TIME      	10000
#define MAX_SESSION_FIND_TIME		10000

const HRESULT E_FAILED_KEY_REGISTER 	= 0x80007100;
const HRESULT E_LOGON_TIMED_OUT		= 0x80007101;
const HRESULT E_OVERFLOW				= 0x80007102;
const HRESULT E_BUFFER_MISMATCH		= 0x80007103;
const HRESULT E_COULDNT_FILL_SEND_BUFFER = 0x80007104;

#define PUMPLOGONHANDLE() if(FAILED(hr = WaitAndPump(0, g_pLogonTask))) \
{ \
	LOGTASKINFOHR(g_hLog, "Online task handle failed", hr); \
	goto Exit; \
}

HRESULT SendPacket(SOCKET Socket, CHAR *pBuff, INT nSizeToSend, COnlineTimer *pTimer, sockaddr_in* pDestAddr);
HRESULT ReadPacket(SOCKET Socket, CHAR *pBuff, INT nSizeOfBuffer, COnlineTimer *pTimer, sockaddr_in* pSrcAddr, int* piBuffSize);
HRESULT CreateListenSocket(CListenSocket **ppListenSocket, XNKID *pSessionID, XNKEY *pKeyExchangeKey);
HRESULT DeleteStressSession(XNKID *pSessionID);

HRESULT client_Main(XNADDR *pHostAddress, XNKID *pSessionID, XNKEY *pKeyExchangeKey);
HRESULT host_Main(void);

VOID WINAPI SGBVT_StartTest( HANDLE LogHandle );
VOID WINAPI SGBVT_EndTest( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\parsertools.cpp ===
#include "stdafx.h"
#include "ParserTools.h"

Variable::Variable()
    {
    value = NULL;
    nameLen = valueLen = 0;
    }

Variable::Variable(char *n, char *v)
    {
    nameLen = strlen(n) + 1;
    valueLen = strlen(v) + 1;
    value = new char[valueLen];
    if(value) strcpy(value, v);
    }

Variable::~Variable()
    {
    if(value) delete[] value;
    value = NULL;
    }

// Called by the HashTable to clean up the variables
// As per "variables.SetCleanupFunct(DestroyVariable);"
void DestroyVariable(void *p)
    {
    if(!p) return;
    Variable *v = *(Variable**)p;
    delete v;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\ansibstr.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    AnsiBstr.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/
#include "stdafx.h"
#include "ansibstr.h"

/*++

Routine Description:

    AnsiBstr::AnsiBstr
    Default Constructor

Arguments:

    none

Return Value:

    none

Notes:

--*/
AnsiBstr::AnsiBstr()
    {
    astr = NULL;
    bstr = NULL;
    }

/*++

Routine Description:

    AnsiBstr::AnsiBstr
    Constructor with a BSTR input

Arguments:

    BSTR b - pointer to a null terminated wide char string

Return Value:

    none

Notes:

--*/
AnsiBstr::AnsiBstr(BSTR b)
    {
    astr = CreateAnsiFromBstr(b);
    bstr = CreateBstrFromAnsi(astr);
    }

/*++

Routine Description:

    AnsiBstr::AnsiBstr
    Constructor with a char* input

Arguments:

    PCHAR a - pointer to a null terminated char string

Return Value:

    none

Notes:

--*/
AnsiBstr::AnsiBstr(PCHAR a)
    {
    bstr = CreateBstrFromAnsi(a);
    astr = CreateAnsiFromBstr(bstr);
    }

/*++

Routine Description:

    AnsiBstr::~AnsiBstr
    Destructor

Arguments:

    none

Return Value:

    none

Notes:

--*/
AnsiBstr::~AnsiBstr()
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    }

/*++

Routine Description:

    AnsiBstr::SetStr
    Changes the values of the strings (deletes old ones if necessary)

Arguments:

    BSTR b - pointer to a null terminated wide char string

Return Value:

    none

Notes:

--*/
void AnsiBstr::SetStr(BSTR b)
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    astr = CreateAnsiFromBstr(b);
    bstr = CreateBstrFromAnsi(astr);
    }

/*++

Routine Description:

    AnsiBstr::SetStr
    Changes the values of the strings (deletes old ones if necessary)

Arguments:

    PCHAR a - pointer to a null terminated char string

Return Value:

    none

Notes:

--*/
void AnsiBstr::SetStr(PCHAR a)
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    bstr = CreateBstrFromAnsi(a);
    astr = CreateAnsiFromBstr(bstr);
    }


/*++

Routine Description:

    CreateAnsiFromBstr
    Allocates memory and converts from a BSTR

Arguments:

    BSTR bstr - pointer to a null terminated wide char string

Return Value:

    PCHAR - pointer to the newly allocated string

Notes:

--*/
PCHAR CreateAnsiFromBstr(BSTR bstr)
    {
    if(!bstr) return NULL;

    UINT bstrLen, pszLen;
    PCHAR psz = NULL;

    bstrLen = wcslen(bstr);
    pszLen = bstrLen * sizeof(CHAR);

    psz = (PCHAR)LocalAlloc(LPTR, pszLen + sizeof(CHAR));

    if(!psz) return NULL;

    WideCharToMultiByte(CP_ACP, 0, bstr, bstrLen, psz, pszLen + sizeof(CHAR), NULL, NULL);

    return psz;
    }

/*++

Routine Description:

    CreateBstrFromAnsi
    Allocates memory and converts from a PCHAR

Arguments:

    PCHAR pszText - pointer to a null terminated char string

Return Value:

    BSTR - return pointer to the new string

Notes:

--*/
BSTR CreateBstrFromAnsi(PCHAR pszText)
    {
    if(!pszText) return NULL;

    int TextLen, pszTextLen;

    pszTextLen = strlen(pszText);
    TextLen = pszTextLen * sizeof(WCHAR);

    BSTR pbstr = SysAllocStringByteLen(NULL, TextLen);

    if(!pbstr) return NULL;

    MultiByteToWideChar(CP_ACP, 0, pszText, pszTextLen, pbstr, TextLen + sizeof(WCHAR));

    return pbstr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\createobject.h ===
#ifndef _CREATEOBJECT_H_
#define _CREATEOBJECT_H_

template <class T> T* CreateObject(const CLSID &classid, const IID &iid)
    {
    IUnknown* pUnk = NULL;
    HRESULT hRes;
    T* obj = NULL;

    hRes = CoCreateInstance(classid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnk);
    if(FAILED(hRes))
        {
        return NULL;
        }
    hRes = pUnk->QueryInterface(iid, (LPVOID*)&obj);
    pUnk->Release();
    if(FAILED(hRes))
        {
        return NULL;
        }
    obj->AddRef();
    return obj;
    }

template <class T> T* CreateServer(const CLSID &classid, const IID &iid, BSTR computerName=NULL, BSTR username=NULL, BSTR domain=NULL, BSTR pw=NULL)
    {
    HRESULT hRes;
    T* obj = NULL;

    COAUTHIDENTITY ident = { username, wcslen(username), domain, wcslen(domain), pw, wcslen(pw), SEC_WINNT_AUTH_IDENTITY_UNICODE };
    COAUTHINFO auth = { RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, &ident, EOAC_NONE };
    COSERVERINFO server = { 0, computerName, username?&auth:NULL, 0 };
    MULTI_QI info = { &iid, 0, 0 };
    DWORD location = CLSCTX_LOCAL_SERVER;

    if(computerName) location = CLSCTX_REMOTE_SERVER;

    hRes = CoCreateInstanceEx(classid, NULL, location, &server, 1, &info);
    if(FAILED(hRes))
        {
        char msg[1024];
        sprintf(msg, "CoCreateInstanceEx returned 0x%X\n", hRes);
        OutputDebugString(msg);
        return NULL;
        }
    obj = (T*)info.pItf;
    obj->AddRef();
    return obj;
    }

template <class T> void DestroyObject(T* obj)
    {
    if(obj) obj->Release();
    }

template <class T> T* CopyObject(const IID &iid, IDispatch *original)
    {
    T *obj = NULL;
    if(!original) return NULL;
    original->QueryInterface(iid, (LPVOID*)&obj);
    if(obj) obj->AddRef();
    return obj;
    }

#endif // _CREATEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\SessionUser.h ===
// SessionUser.h: interface for the CSessionUser class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

#pragma pack(push, 1)

// This structure frames individual users that are sent on the wire
typedef struct
{
	DWORD dwUserSize;
	DWORD dwNameSize;
	DWORD dwKingdomSize;
} SGBVT_USER_HEADER, *PSGBVT_USER_HEADER;


#pragma pack(pop)

class CSessionUser  
{
public:
	CSessionUser& operator = (const CSessionUser&);
	bool operator ==(CSessionUser &);
	bool operator <(CSessionUser &);
	HRESULT UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	HRESULT PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	void GetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom);
	void SetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom);
	CSessionUser(const CSessionUser &SessionUser);
	CSessionUser();
	virtual ~CSessionUser();

protected:
	XUID m_UserID;
	CHAR m_szUserName[XONLINE_NAME_SIZE];
	CHAR m_szUserKingdom[XONLINE_KINGDOM_SIZE];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\SGBVT\SessionUser.cpp ===
// SessionUser.cpp: implementation of the CSessionUser class.
//
//////////////////////////////////////////////////////////////////////

#include "SessionUser.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSessionUser::CSessionUser()
{
	memset(&m_UserID, 0, sizeof(m_UserID));
	memset(m_szUserName, 0, sizeof(m_szUserName));
	memset(m_szUserKingdom, 0, sizeof(m_szUserKingdom));
}

CSessionUser::~CSessionUser()
{

}

CSessionUser::CSessionUser(const CSessionUser &SessionUser)
{
	memcpy(&m_UserID, &(SessionUser.m_UserID), sizeof(m_UserID));
	memcpy(m_szUserName, SessionUser.m_szUserName, sizeof(m_szUserName));
	memcpy(m_szUserKingdom, SessionUser.m_szUserKingdom, sizeof(m_szUserKingdom));
}

CSessionUser& CSessionUser::operator =(const CSessionUser& SessionUser)
{
	memcpy(&m_UserID, &(SessionUser.m_UserID), sizeof(m_UserID));
	memcpy(m_szUserName, SessionUser.m_szUserName, sizeof(m_szUserName));
	memcpy(m_szUserKingdom, SessionUser.m_szUserKingdom, sizeof(m_szUserKingdom));

	return *this;
}

bool CSessionUser::operator ==(CSessionUser &SessionUser)
{
	if(memcmp(&m_UserID, &(SessionUser.m_UserID), sizeof(m_UserID)))
		return false;

	if(strcmp(m_szUserName, SessionUser.m_szUserName))
		return false;

	if(strcmp(m_szUserKingdom, SessionUser.m_szUserKingdom))
		return false;

	return true;
}

bool CSessionUser::operator <(CSessionUser &SessionUser)
{
	return (m_UserID.qwUserID < SessionUser.m_UserID.qwUserID);
}

/****************************************************************************
 *
 *  SetUserInfo
 *
 *  Description:
 *      Sets all of the user information
 *
 *  Arguments:
 *      XUID                *pUserID            XUID to set for the user
 *      CHAR                *szUserName         Name to set for the user
 *      CHAR                *szUserKingdom      Kingdom to set for the user
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CSessionUser::SetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom)
{
	if(pUserID)
		memcpy(&m_UserID, pUserID, sizeof(m_UserID));

	if(szUserName && (strlen(szUserName) < XONLINE_NAME_SIZE))
		strcpy(m_szUserName, szUserName);

	if(szUserKingdom && (strlen(szUserKingdom) < XONLINE_KINGDOM_SIZE))
		strcpy(m_szUserKingdom, szUserKingdom);
}

/****************************************************************************
 *
 *  GetUserInfo
 *
 *  Description:
 *      Retrieves all of the user information
 *
 *  Arguments:
 *      XUID                *pUserID            XUID to get for the user
 *      CHAR                *szUserName         Name to get for the user
 *      CHAR                *szUserKingdom      Kingdom to get for the user
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CSessionUser::GetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom)
{
	if(pUserID)
		memcpy(pUserID, &m_UserID, sizeof(m_UserID));

	if(szUserName)
		strcpy(szUserName, m_szUserName);

	if(szUserKingdom)
		strcpy(szUserKingdom, m_szUserKingdom);
}

/****************************************************************************
 *
 *  PackIntoBuffer
 *
 *  Description:
 *      Packs all of the CSessionUser information into a buffer for transmission
 *      over the wire to another client
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer to hold the user information.  If this
 *                                              parameter is NULL and a non-NULL pdwBuffSize is
 *                                              provided, then the function will fill pdwBuffSize
 *                                              with the required size necessary
 *      DWORD               *pdwBuffSize        Holds the size of the provided buffer. On output
 *                                              this parameter will contain either the required size
 *                                              (if the provided size was insufficient) or the
 *                                              ammount of space that was actually used
 *
 *  Returns:  
 *      S_OK if the user was succesfully packed into the buffer
 *      S_FALSE if a buffer was supplied but it was too small to hold the data
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CSessionUser::PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PSGBVT_USER_HEADER pUserHeader = (PSGBVT_USER_HEADER) pBuff;
	DWORD dwRequiredSize = 0;

	if(!pdwBuffSize)
		return E_FAIL;

	dwRequiredSize = sizeof(SGBVT_USER_HEADER) + sizeof(m_UserID) + strlen(m_szUserName) + strlen(m_szUserKingdom);

	if(*pdwBuffSize < dwRequiredSize)
	{
		*pdwBuffSize = dwRequiredSize;
		return S_FALSE;
	}

	*pdwBuffSize = dwRequiredSize;

	pUserHeader->dwUserSize = dwRequiredSize;
	pUserHeader->dwNameSize = strlen(m_szUserName);
	pUserHeader->dwKingdomSize = strlen(m_szUserKingdom);
	
	memcpy(pBuff += sizeof(SGBVT_USER_HEADER), &m_UserID, sizeof(m_UserID));
	memcpy(pBuff += sizeof(m_UserID), m_szUserName, pUserHeader->dwNameSize);
	memcpy(pBuff += pUserHeader->dwNameSize, m_szUserKingdom, pUserHeader->dwKingdomSize);

	return S_OK;
}

/****************************************************************************
 *
 *  UnpackFromBuffer
 *
 *  Description:
 *      Unpacks a user information packet received over the wire into a new
 *      CSessionUser object
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer containing the received user information packet
 *      DWORD               *pdwBuffSize        On input, indicates the size of the received packet
 *                                              On output, indicates the size used to build the user object
 *
 *  Returns:  
 *      S_OK if the user object was succesfully unpacked from the buffer
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CSessionUser::UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PSGBVT_USER_HEADER pUserHeader = (PSGBVT_USER_HEADER) pBuff;

	if(*pdwBuffSize < (sizeof(SGBVT_USER_HEADER) + sizeof(m_UserID)) || !pBuff)
		return E_FAIL;

	if(pUserHeader->dwUserSize > *pdwBuffSize)
		return E_FAIL;

	if((pUserHeader->dwNameSize + pUserHeader->dwKingdomSize + sizeof(SGBVT_USER_HEADER) + sizeof(m_UserID)) != pUserHeader->dwUserSize)
		return E_FAIL;

	*pdwBuffSize = pUserHeader->dwUserSize;

	memcpy(&m_UserID, pBuff += sizeof(SGBVT_USER_HEADER), sizeof(m_UserID));
	memset(m_szUserName, 0, sizeof(m_szUserName));
	memcpy(m_szUserName, pBuff += sizeof(m_UserID), pUserHeader->dwNameSize);
	memset(m_szUserName, 0, sizeof(m_szUserName));
	memcpy(m_szUserKingdom, pBuff += pUserHeader->dwNameSize, pUserHeader->dwKingdomSize);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

#define BUFFER_FILL_ALPHA 0x01
#define BUFFER_FILL_NUM   0x02
#define BUFFER_FILL_PUNCT 0x04
#define BUFFER_FILL_ASCII 0x08
#define BUFFER_FILL_NULL  0x10

extern char* NewRandomBuffer(size_t minSize, size_t maxSize, unsigned char fill, size_t &outLen, unsigned int &seed);
extern void Trace(LPCTSTR lpszFormat, ...);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HttpClient.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\afxres.h ===
#include "windows.h"
#include "commctrl.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\httpclient.cpp ===
/*

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    HttpClient.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

NOTE: Include files with error codes:
    SSL       <winerror.h> 
    Sockets   <winsock2.h>
    HTTP      <wininet.h>

*/

#include "stdafx.h"
#include <time.h>

#include "SecureSocketLayer.h"
#include "HttpClient.h"
#include <mswsock.h>

// timeout in seconds + msec
#define RECV_TIMEOUT_S  2
#define RECV_TIMEOUT_US 0

#define DEFAULT_PORT 80
#define DEFAULT_PROXY_PORT DEFAULT_PORT
#define DEFAULT_SSL_PORT 443

extern int followDomainRules;

#ifdef _DEBUG
    #define DEBUGLOG "HttpClient.log"
    // NOTE: There is no critical section around the logging.
    //       Keep this in mind when viewing the log from a
    //       multithreaded app.
    // NOTE: You can #define _DEBUG_RAW_DUMP to dump raw information
    //       to the log file. (Hex output is default).

    void Report(LPCTSTR lpszFormat, ...);
    void PrintHexDump(const char * buffer, DWORD length);
#endif

/*/////////////////////////////////////////////////////////////////////////////
Routine Description:


Arguments:


Return value:

*/
CHttpClient::CHttpClient()
    {
    // windows socket initialization
    sock = INVALID_SOCKET;
    nextsock = INVALID_SOCKET;

    wPort = DEFAULT_PORT;
    dataLen = 0;
    dest.sin_family = PF_INET;

    // Proxy
    wProxyPort = DEFAULT_PROXY_PORT;
    bUseProxy = FALSE;
    szProxyServerName[0] = '\0';

    // SSL
    SSL = NULL;

    // timeouts
    timeout.tv_sec = RECV_TIMEOUT_S;
    timeout.tv_usec = RECV_TIMEOUT_US;

    // timers
    sendTime = 0;
    ttfbTime = 0;
    ttlbTime = 0;
    }

CHttpClient::~CHttpClient()
    {
    if(sock != INVALID_SOCKET) Disconnect();
    if(nextsock != INVALID_SOCKET)
        {
        closesocket(nextsock);
        nextsock = INVALID_SOCKET;
        }

    if(SSL) delete SSL;
    }

long CHttpClient::Open(void)
    {
    #ifdef _DEBUG
    Report("Sock Opened\n");
    #endif

    wPort = DEFAULT_PORT;
    dest.sin_family = PF_INET;

    // Proxy
    wProxyPort = DEFAULT_PROXY_PORT;
    bUseProxy = FALSE;

    // SSL
    if(SSL) 
        {
        delete SSL;
        SSL = NULL;
        }

    if(nextsock != INVALID_SOCKET)
        {
        sock = nextsock;
        nextsock = INVALID_SOCKET;
        }
    else
        {
        sock = socket(PF_INET, SOCK_STREAM, 0);
        if(sock == INVALID_SOCKET) return (long)WSAGetLastError();
        }

    return 0;
    }

int CHttpClient::GetHTTPStatus(void)
{
    char *beginning = strstr(data, "HTTP/");
    if(!beginning) return 0;
    beginning += 9;
    int res = atoi(beginning);
    // if first HTTP status found is 100, look if there is another one
    // IIS 5 sends HTTP 100 and then actual data
    if (res == 100) 
    {
        char *nextcode = strstr(beginning, "HTTP/");
        if (nextcode) 
        {
            nextcode += 9;
            res = atoi(nextcode);
        }
    }
    return res;
}

char* CHttpClient::GetBody(void)
    {
    char *body = strstr(data, "\r\n\r\n");
    if(!body) return NULL;
    return body + 4;
    }

inline char* CHttpClient::GetData(void)
    {
    return data;
    }

inline int CHttpClient::GetDataLen(void)
    {
    return dataLen;
    }

long CHttpClient::Connect(IN_ADDR server, const char *serverName)
    {
    // NOTE: if connecting through a proxy, 'server' must be the address of 
    //       the proxy, and 'serverName' the final destination
    if(!serverName) return WSAHOST_NOT_FOUND;

    dest.sin_port = htons( (bUseProxy ? wProxyPort : wPort) );
    dest.sin_addr.s_addr = server.s_addr;

    if(connect(sock, (SOCKADDR*)&dest, sizeof(SOCKADDR)) == SOCKET_ERROR)
        {
        return (long)WSAGetLastError();
        }

    if(bUseProxy)
        {
        // Build message for proxy server
        dataLen = sprintf(data, "CONNECT %s:%u %s", serverName, wPort, "HTTP/1.0\r\nUser-Agent: CHttpClient\r\n\r\n");
        if(send(sock, data, dataLen, 0) == SOCKET_ERROR)
            {
            return (long)WSAGetLastError();
            }
        do
            {
            if((dataLen = recv(sock, data, DATA_SIZE, 0)) == SOCKET_ERROR)
                {
                data[dataLen = 0] = '\0';
                return (long)WSAGetLastError();
                }
            data[dataLen] = '\0';
            } while(strstr(data, "\r\n\r\n") == NULL);
        }

    if(SSL)
        {
        long status = SSL->Connect(sock, serverName);
        return status;
        }

    return 0;
    }

long CHttpClient::Connect(const char *serverName)
    {
    if(!serverName) return WSAHOST_NOT_FOUND;

    #ifdef _DEBUG
    Report("Connect %s:%u\n", serverName, wPort);
    #endif

    IN_ADDR address;

    // try to treat serverName as a dotted decimal
    if(bUseProxy) address.s_addr = inet_addr(szProxyServerName);
    else address.s_addr = inet_addr(serverName);

    if(address.s_addr == INADDR_NONE)
        {
        // not dotted decimal, so try to get an ip for it
        HOSTENT *hosts;
        if(bUseProxy) hosts = gethostbyname(szProxyServerName);
        else hosts = gethostbyname(serverName);
        if(!hosts) return (long)WSAGetLastError();

        // take the first address found
        address.s_addr = **(LPDWORD*)&hosts->h_addr_list[0];
        }

    return Connect(address, serverName);
    }

long CHttpClient::Disconnect(void)
    {
    #ifdef _DEBUG
    Report("Disconnect\n");
    #endif

    if(sock == INVALID_SOCKET) return 0;

    // SSL clean up
    if(SSL)
        {
        SSL->Disconnect(sock);
        }

    int err;
    shutdown(sock, SD_BOTH);

    /* NOTE: Based on the "polite" way to close a connection, we
             should call recv untill no more data is available
             (timeout), but due to performance reasons, we will 
             not do this (or we leave it up to the application).
             On the above line, set the SD_BOTH to SD_SEND, if 
             you wish to use the below code.

    // clean out the receive buffer
    char tempdata[DATA_SIZE+1];
    for(int i=0; i<100; i++) // just quit after a while
        {
        if(!IsDataAvailable()) break;
        err = recv(sock, tempdata, DATA_SIZE, 0);
        if(err == 0 || err == SOCKET_ERROR) break;
        }
    */

    err = closesocket(sock);
    sock = INVALID_SOCKET;

    if(err) return (long)WSAGetLastError();
    return 0;
    }

long CHttpClient::HardDisconnect(void)
    {
    #ifdef _DEBUG
    Report("HardDisconnect\n");
    #endif

    if(sock == INVALID_SOCKET) return 0;

    // SSL clean up
    if(SSL)
        {
        SSL->Disconnect(sock);
        }

    int err = closesocket(sock);
    sock = INVALID_SOCKET;

    if(err) return (long)WSAGetLastError();
    return 0;
    }

long CHttpClient::Send(const char *senddata, int len)
    {
    int err;

    // Set our timers back to 0
    sendTime = 0;
    ttfbTime = 0;
    ttlbTime = 0;

    #ifdef _DEBUG
    Report("Send\n");
    #ifdef _DEBUG_DUMP
    PrintHexDump(senddata, len);
    #endif
    #endif

    if(len <= 0) return WSAEMSGSIZE;
    if(!senddata) return WSAEFAULT;

    if(SSL)
        {
        long status;
        memcpy(data, senddata, len);
        DWORD dLen = len;
        status = SSL->Encrypt(data, dLen, DATA_SIZE);
        dataLen = (int)dLen;
        if(FAILED(status))
            {
            return status;
            }
        err = send(sock, data, dataLen, 0);
        }
    else
        {
        err = send(sock, senddata, len, 0);
        }

    if(err == SOCKET_ERROR)
        {
        return (long)WSAGetLastError();
        }

    sendTime = time(NULL);
    return 0;
    }

long CHttpClient::Send(void)
    {
    int err;

   // Set our timers back to 0
    sendTime = 0;
    ttfbTime = 0;
    ttlbTime = 0;

    #ifdef _DEBUG
    Report("Send\n");
    #ifdef _DEBUG_DUMP
    PrintHexDump(data, dataLen);
    #endif
    #endif

    if(dataLen <= 0) return WSAEMSGSIZE;

    if(SSL)
        {
        long status;
        DWORD dLen = dataLen;
        status = SSL->Encrypt(data, dLen, DATA_SIZE);
        dataLen = (int)dLen;
        if(FAILED(status))
            {
            return status;
            }
        err = send(sock, data, dataLen, 0);
        }
    else
        {
        err = send(sock, data, dataLen, 0);
        }

    if(err == SOCKET_ERROR)
        {
        return (long)WSAGetLastError();
        }

    sendTime = time(NULL);

    return 0;
    }

long CHttpClient::Receive(BOOL readAll/*=FALSE*/)
    {
    long err=0;
    DWORD dLen;
    dataLen = 0;
    //DWORD contentLength = 0; // length of data according to the received header
    //DWORD headerSize = 0;

    #ifdef _DEBUG
    Report("Receive:\n");
    #endif

    DWORD count = 0;
    const DWORD maxCount = 500;
    
    data[0] = '\0';
    dataLen = 0;

    receive:
    do
        {
        if(++count >= maxCount)
            {
            err = WSAECONNABORTED;
            break;
            }

        // check for available data
	    if(!IsDataAvailable())
            {
            data[dataLen] = '\0';
            err = WSAETIMEDOUT;
            break;
            }

        // retreive the data
        if((dLen = recv(sock, data+dataLen, DATA_SIZE-dataLen, 0)) == SOCKET_ERROR)
            {
            data[dataLen] = '\0';
            err = WSAGetLastError();
            break;
            }
        
        if (!ttfbTime)
            {
            ttfbTime = time(NULL);
            }

        if(dLen == 0) break; // no more data

        /*  This code is commented out because we would want to do this
            but because we un SSL after we get everything it wont work.

        if(contentLength == 0)
            {
            char *t = strstr(data, "Content-Length:");
            if(t)
                {
                contentLength = atol(t + strlen("Content-Length:"));
                //FILE *f = fopen("c:\\test.txt", "a+");
                //fprintf(f, "content length = %d\n", contentLength);
                //fclose(f);

                t = strstr(t, "\r\n\r\n");
                headerSize = (t+4) - data;
                }
            }
            */

        dataLen += dLen;
        data[dataLen] = '\0';

        /*  See above note 

        // reached end of body
        if(contentLength && dataLen-headerSize >= contentLength)
            {
                //FILE *f = fopen("c:\\test.txt", "a+");
                //fprintf(f, "reached end of body\n", contentLength);
                //fclose(f);
            break;
            }
            */

        } while(readAll);

    if(SSL)
    {
        dLen = (DWORD)dataLen;
        // antonpav - add dLen check
        // in case recv() returns zero length
        // Decrypt() with zero len data results in 
        // SEC_E_INCOMPLETE_MESSAGE, and loops to receive label
        if (dLen != 0)
        {
            long status = SSL->Decrypt(data, dLen, DATA_SIZE);
            if(status == SEC_I_RENEGOTIATE)
                {
                status = SSL->ClientHandshakeLoop(sock, FALSE);
                err = status;
                }
            else if(status == SEC_E_INCOMPLETE_MESSAGE)
                {
                // We need to read more from the server before we can decrypt
                if(count < maxCount) goto receive;
                }
            if(FAILED(status))
                {
                err = status;
                }
            dataLen = (int)dLen;
        }
    }

    data[dataLen] = '\0';
    
    if (!ttfbTime)
        {
        sendTime = 0;
        }
    else
        {
        ttlbTime = time(NULL);
        }

    #ifdef _DEBUG_DUMP
    PrintHexDump(data, dataLen);
    #endif

    return err;
    }

BOOL CHttpClient::IsDataAvailable(void)
    {
    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = sock;

    // do some work for the next connection before waiting
    if(nextsock == INVALID_SOCKET)
        {
        nextsock = socket(PF_INET, SOCK_STREAM, 0);
        }

    int err = select(0, &bucket, NULL, NULL, &timeout);
    if(err == 0 || err == SOCKET_ERROR)
        {
        return FALSE;
        }

    return TRUE;
    }

BOOL CHttpClient::IsSendAvailable(void)
    {
    TIMEVAL timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 20;

    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = sock;

    if(select(0, NULL, &bucket, NULL, &timeout) == 1)
        {
        return TRUE;
        }

    return FALSE;
    }

long CHttpClient::SetLinger(BOOL linger, WORD timeout)
    {
    LINGER ling;
    int size = sizeof(LINGER);

    #ifdef _DEBUG
    Report("Linger Enabled\n");
    #endif

    ling.l_onoff = (WORD)linger;
    ling.l_linger = timeout;
    int err;
    if((err = setsockopt(sock, SOL_SOCKET, SO_LINGER, (char*)&ling, size)) == SOCKET_ERROR)
        {
        return (long)WSAGetLastError();
        }

    return 0;
    }

long CHttpClient::SetKeepAlive(BOOL keepalive)
    {
    int err;
    int val = keepalive;

    #ifdef _DEBUG
    Report("KeepAlive Enabled\n");
    #endif

    if((err = setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char*)&val, sizeof(int))) == SOCKET_ERROR)
        {
        return (long)WSAGetLastError();
        }

    return 0;
    }

long CHttpClient::SetSSL(LPSTR pszUserName /* =NULL */, DWORD dwProtocol /* =SP_PROT_SSL2 */, ALG_ID  aiKeyExch /* =CALG_RSA_KEYX */)
    {
    #ifdef _DEBUG
    Report("SSL Enabled\n");
    #endif

    wPort = DEFAULT_SSL_PORT;

    // available encryption type values
    //    dwProtocol = SP_PROT_PCT1;
    //    dwProtocol = SP_PROT_SSL2;
    //    dwProtocol = SP_PROT_SSL3;
    //    dwProtocol = SP_PROT_TLS1;
    //    aiKeyExch = CALG_RSA_KEYX;
    //    aiKeyExch = CALG_DH_EPHEM;

    if(!SSL) SSL = new CSecureSocketLayer(pszUserName, dwProtocol, aiKeyExch);
    if(!SSL) return SEC_E_INSUFFICIENT_MEMORY;

    return 0;
    }

long CHttpClient::SetProxy(const char *serverName, WORD port)
    {
    #ifdef _DEBUG
    Report("Proxy Enabled\n");
    #endif

    bUseProxy = TRUE;
    strcpy(szProxyServerName, serverName);
    wProxyPort = port;

    return 0;
    }

void CHttpClient::SetRecvTimeout(UINT sec, UINT usec)
    {
    timeout.tv_sec = sec;
    timeout.tv_usec = usec;
    }

void CHttpClient::SetDefaultPort(WORD newPort)
    {
    wPort = newPort;
    }

int CHttpClient::ParseURL(const char *url, char *server, char *site, BOOL* ssl)
    {
    // TODO try to recover on malformed urls
    if(!url || !server || !site || !ssl) return 0;

    // Check for SSL
    url += 4;
    if(*url == 's' || *url == 'S')
        {
        *ssl = 1;
        url += 4;
        }
    else if(*url == ':')
        {
        *ssl = 0;
        url += 3;
        }
    else return 0;

    // copy the server portion
    while(*url != '/')
        {
        if(!(*url))
            {
            // no site, so we tack on an ending /
            *server = '\0';
            site[0] = '/';
            site[1] = '\0';
            return 0;
            }
        *server++ = *url++;
        }

    // copy the path/page portion
    *server = '\0';
    strcpy(site, url);

    return 1;
    }

int CHttpClient::GrabCookies(Cookie *jar, char *source, char *domain /*=NULL*/)
    {
    if(!jar || !source) return 0;

    int numFound = 0;
    char *cookiestart;

    cookiestart = (char*)source;

    // antonpav
    // should search through the entire response as 
    // we may have multiple replies in one buffer
//    char *body = strstr(data, "\r\n\r\n");
//    if(body) body[0] = '\0'; // just so we dont search through the entire response

    while((cookiestart = strstr(cookiestart, "Set-Cookie:")) != NULL)
        {
        cookiestart += sizeof("Set-Cookie:");
        jar->Add(cookiestart, domain);

        ++numFound;
        }

//    if(body) body[0] = '\r';

    return numFound;
    }

int CHttpClient::GetCookieRules(void)
    {
    return followDomainRules;
    }

void CHttpClient::SetCookieRules(int i)
    {
    followDomainRules = i;
    }

int CHttpClient::POSTEncode(char *dest, const char *source)
    {
    if(dest == source) return 0;

    // NOTE: the restricted characters are defined in the URI RFC 
    //       (current ver: 2396) in section 2.

    char *restricted = ";/?:@&=+$,\"#%%<>\\~";
    char buff[10];

    int i;

    for(i=0; *source; source++, i++)
        {
        if(strchr(restricted, *source) != NULL)
            {
            sprintf(buff, "%02X", (unsigned)(*source));
            dest[i] = (char)'%%';    ++i;
            dest[i] = buff[0]; ++i;
            dest[i] = buff[1]; 
            }
        else if(*source == ' ')
            {
            dest[i] = '+';
            }
        else
            {
            dest[i] = *source;
            }
        }

    dest[i] = '\0';
    return i;
    }

int ctox(char c)
    {
    if(c >= '0' && c <= '9') return c - '0';
    else if(c >= 'A' && c <= 'F') return c - 'A' + 10;
    else if(c >= 'a' && c <= 'f') return c - 'a' + 10;
    else return 0;
    }

int CHttpClient::URLDecode(char *dest, const char *source)
    {
    if(dest == source) return 0;

    // NOTE: the restricted characters are defined in the URI RFC 
    //       (current ver: 2396) in section 2.

    int i;

    for(i=0; *source; source++, i++)
        {
        if(*source == '%')
            {
            ++source;
            dest[i] = (char)ctox(*source)*16;
            ++source;
            dest[i] += (char)ctox(*source);
            }
        else
            {
            dest[i] = *source;
            }
        }

    dest[i] = '\0';
    return i;
    }

int CHttpClient::URLEncode(char *dest, const char *source)
    {
    if(dest == source) return 0;

    // NOTE: the restricted characters are defined in the URI RFC 
    //       (current ver: 2396) in section 2.

    char *restricted = ";/?:@&=+$,\"#%%<>\\~ ";
    char buff[10];

    int i;

    for(i=0; *source; source++, i++)
        {
        if(strchr(restricted, *source) != NULL)
            {
            sprintf(buff, "%02X", (unsigned)(*source));
            dest[i] = (char)'%%';    ++i;
            dest[i] = buff[0]; ++i;
            dest[i] = buff[1]; 
            }
        else
            {
            dest[i] = *source;
            }
        }

    dest[i] = '\0';
    return i;
    }

BOOL CHttpClient::DNSLookup(char *address, char *output, size_t bufferlen)
    {
    if(!address || !output || bufferlen==0) return FALSE;

    HOSTENT *hosts;
    hosts = gethostbyname(address);
    if(!hosts) return FALSE;

    size_t length = 0;

    // get the entries
    for(unsigned i=0; hosts->h_addr_list[i]; i++)
        {
        if(bufferlen <= length+16) break;
        length =+ sprintf(output+length, "%u.%u.%u.%u", (unsigned char)hosts->h_addr_list[i][0], (unsigned char)hosts->h_addr_list[i][1], (unsigned char)hosts->h_addr_list[i][2], (unsigned char)hosts->h_addr_list[i][3]);
        if(hosts->h_addr_list[i+1]) length += sprintf(output+length, ", ");
        }

    return TRUE;
    }

// 0 = TTFB
// 1 = TTLB
time_t CHttpClient::GetTime(unsigned char timeToReturn)
    {
    switch (timeToReturn)
        {
        case 0:
            return ttfbTime - sendTime;
        case 1:
            return ttlbTime - sendTime;
        }

    return 0;
    }

#ifdef _DEBUG    // enabled only in debug mode
static void Report(LPCTSTR lpszFormat, ...)
    {
    va_list args;
    va_start(args, lpszFormat);

    char szBuffer[512];
    char szFormat[512];

    char dbuffer[9];
    char tbuffer[9];
    _strdate(dbuffer);
    _strtime(tbuffer);

    sprintf(szFormat, "%s, %s, %s", tbuffer, dbuffer, lpszFormat);
    vsprintf(szBuffer, szFormat, args);

    FILE *f = fopen(DEBUGLOG, "a+");
    if(f)
        {
        fprintf(f, "%s", szBuffer);
        fclose(f);
        }
    else
        printf("%s", szBuffer);

    va_end(args);
    }

static void PrintHexDump(const char * buffer, DWORD length)
    {
    FILE *f = fopen(DEBUGLOG, "a+");

#ifdef _DEBUG_RAW_DUMP
    if(f)
        {
        fprintf(f, "%s", buffer);
        fprintf(f, "\n");
        fclose(f);
        }
    else
        {
        printf("%s", buffer);
        printf("\n");
        }
    return;
#endif

    DWORD i,count,index;
    CHAR rgbDigits[]="0123456789ABCDEF";
    CHAR rgbLine[100];
    char cbLine;


    for(index = 0; length; length -= count, buffer += count, index += count)
        {
        count = (length > 16) ? 16:length;

        sprintf(rgbLine, "%4.4x  ",index);
        cbLine = 6;

        for(i=0;i<count;i++)
            {
            rgbLine[cbLine++] = rgbDigits[buffer[i] >> 4];
            rgbLine[cbLine++] = rgbDigits[buffer[i] & 0x0f];
            if(i == 7)
                {
                rgbLine[cbLine++] = ' ';
                }
            else
                {
                rgbLine[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            }

        rgbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buffer[i] < 32 || buffer[i] > 126)
                {
                rgbLine[cbLine++] = '.';
                }
            else
                {
                rgbLine[cbLine++] = buffer[i];
                }
            }

        rgbLine[cbLine++] = 0;
        if(f) fprintf(f, "%s\n", rgbLine);
        else printf("%s\n", rgbLine);
        }

    if(f) fclose(f);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\parsertools.h ===
#ifndef _PARSERTOOLS_H_
#define _PARSERTOOLS_H_

typedef void (*HASHOBJ_FUNC)(void*);

/*++

Class Description:



Arguments:



Return Value:



Notes:



--*/
template <class T> class HashEntry
    {
    public:
        char *key;
        T obj;
        HashEntry <T> *next;

    public:
        HashEntry();
        HashEntry(char *k, T o);
        ~HashEntry();
    };

/*++

Class Description:



Arguments:



Return Value:



Notes:



--*/
template <class T, size_t SIZE> class HashTable
    {
    public:
        HashTable();
        ~HashTable();

        HASHOBJ_FUNC clean;
        size_t m_size;

    public:
        HashEntry<T> *table[SIZE];
    
        BOOL Get(char *key, T& out);
        BOOL Add(char *key, T o);
        BOOL ForAll(HASHOBJ_FUNC fn);
        void SetCleanupFunct(HASHOBJ_FUNC c) { clean = c; }
    };

class Variable
    {
    public:
        char *value;
        size_t nameLen;  // size of the buffer
        size_t valueLen; // size of the buffer

    public:
        Variable();
        Variable(char *n, char *v);
        ~Variable();
    };

extern void DestroyVariable(void *p);

/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T>
HashEntry<T>::HashEntry()
    {
    clean = NULL;
    key = NULL;
    next = NULL;
    }


/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T>
HashEntry<T>::HashEntry(char *k, T o)
    {
    key = new char[strlen(k)+1];
    strcpy(key, k);
    obj = o;
    next = NULL;
    }

/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T>
HashEntry<T>::~HashEntry()
    {
    if(key) delete[] key;
    if(next) delete next;
    }

/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T, size_t SIZE>
HashTable<T, SIZE>::HashTable()
    {
    m_size = SIZE;
    clean = NULL;
    for(size_t i=0; i<SIZE; i++)
        {
        table[i] = NULL;
        }
    }


/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T, size_t SIZE>
HashTable<T, SIZE>::~HashTable()
    {
    if(clean) ForAll(clean);
    for(size_t i=0; i<SIZE; i++)
        {
        if(table[i]) delete table[i];
        }
    }

/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::Get(char *key, T& out)
    {
    if(!key) return FALSE;

    size_t i = (key[0] + key[1]) % SIZE;

    if(!table[i]) return FALSE;

    for(HashEntry<T> *h = table[i]; h; h=h->next)
        {
        if(strcmp(h->key, key) == 0)
            {
            out = h->obj;
            return TRUE;
            }
        }

    return FALSE;
    }

/*++

Routine Description:

    Add the key and the associated object. Add the new HashEntry at the end 
    of the list to give precedence to items added first.

Arguments:



Return Value:



Notes:



--*/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::Add(char *key, T o)
    {
    if(!key) return FALSE;
    size_t i = (key[0] + key[1]) % SIZE;
    
    if(!table[i])
        {
        table[i] = new HashEntry<T>(key, o);
        }
    else
        {
        HashEntry<T> *h = table[i];
        do
            {
            // replace entry with the same key
            if(strcmp(h->key, key) == 0)
                {
                if(clean) clean(&(h->obj));
                h->obj = o;
                return TRUE;
                }
            if(h->next) h=h->next;
            } while(h->next);

        // otherwise add it to the end
        h->next = new HashEntry<T>(key, o);
        }

    return TRUE;
    }

/*++

Routine Description:



Arguments:



Return Value:



Notes:



--*/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::ForAll(HASHOBJ_FUNC fn)
    {
    for(size_t i=0; i<SIZE; i++)
        {
        if(table[i]) 
            {
            for(HashEntry<T> *h = table[i]; h; h=h->next)
                {
                fn(&(h->obj));
                }
            }
        }
    return TRUE;
    }

#endif // _PARSERTOOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\common\utils.cpp ===
#include "stdafx.h"
#include "utils.h"

/*++

Routine Description:



Arguments:



Return Value:

    pointer to newly allocated and filled buffer
    NULL on error


Notes:

    the last char will always be '\0' (so if minSize == maxSize == 1) then the 
     string will only contain the null char.

    you always have to delete[] the return value (except on error)

--*/
char* NewRandomBuffer(size_t minSize, size_t maxSize, unsigned char fill, size_t &outLen, unsigned int &seed)
    {
    char *buffer = NULL;
    outLen = 0;

    if(minSize > maxSize) maxSize = minSize;
    if(minSize == 0 || maxSize == 0) return NULL;

    // initialize random number generator
    if(!seed)
        {
        LARGE_INTEGER liPerf;
        QueryPerformanceCounter(&liPerf);
        seed = liPerf.LowPart & 0xFFFF;
        srand(seed);
        }

    // get size of buffer & allocate
    if(maxSize == minSize) outLen = maxSize;
    else outLen = (rand() % (maxSize-minSize)) + minSize;

    buffer = new char[outLen];
    if(!buffer)
        {
        outLen = 0;
        return NULL;
        }

    if(fill == BUFFER_FILL_NULL)
        {
        memset(buffer, '\0', outLen);
        return buffer;
        }

    // fill in the buffer
    int randval;
    for(size_t i=0; i<outLen-1; i++)
        {
        randval = rand();
        switch(fill)
            {
            case BUFFER_FILL_ALPHA:
                buffer[i] = (char)((randval % 26) + 'a');
                break;
            case BUFFER_FILL_NUM:
                buffer[i] = (char)((randval % 10) + '0');
                break;
            case BUFFER_FILL_PUNCT:
                buffer[i] = (char)((randval % 16) + ' ');
                break;
            case BUFFER_FILL_ASCII:
                buffer[i] = (char)randval;
                break;

            default: // BUFFER_FILL_ALPHA
                buffer[i] = (char)((randval % 26) + 'a');
                break;
            }
        }

    // set the terminating char
    buffer[outLen - 1] = '\0';

    return buffer;
    }

/*++

Routine Description:

    Trace
    diagnostic debug output

Arguments:

    LPCTSTR lpszFormat  - pointer to vsprintf format string
    ...                 - list of args to vsprintf

Return Value:

    none

Notes:

    don't exceed 512 bytes of data in the output
    may want to dynamically allocate szBuffer if output exceeds the current setting


--*/
void Trace(LPCTSTR lpszFormat, ...)
    {
    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    char szBuffer[512];

    nBuf = vsprintf(szBuffer, lpszFormat, args);
    OutputDebugString(szBuffer);

    va_end(args);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\httpclient.h ===
/*

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    HttpClient.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/
#ifndef _HTTPCLIENT_H_
#define _HTTPCLIENT_H_

// NOTE: Be sure to call WSAStartup() and WSACleanup() in the parent 
//       application.
//
//       Example:
//      
//       WSADATA wsaData;
//       WSAStartup(0x0101, &wsaData);
//        ... // your program code here
//       WSACleanup();
//
// NOTE: If you plan on using SSL you may wish to load the dlls in your main 
//       program, this will keep CHttpClient from loading and unloading all
//       the security libraries.
//
//       Example:
//
//       HINSTANCE hSecuritydll = LoadLibrary("security.dll");
//        ... // your program code here
//       FreeLibrary(hSecuritydll);
//
// NOTE: The debug version of this dll (#define _DEBUG) will dump log 
//       information to the file specified by DEBUGLOG. An extensive
//       amount of data is written to this file.
//
// NOTE: Include files with error codes
//       SSL       <issperr.h> 
//       Sockets   <winsock2.h>
//       HTTP      <wininet.h>
//

#include <winsock2.h>
#include <time.h>

#include "SecureSocketLayer.h"

#define DATA_SIZE 65536

class __declspec( dllexport ) Cookie
    {
    public:
        char *name;
        char *value;
        char *domain;
        char *path;

        Cookie *next;

        char *localname;
        char *localvalue;
        size_t localnameLen;
        size_t localvalueLen;

    public:
        Cookie();
        Cookie(char *n, char *v=NULL, char *d=NULL);
        ~Cookie();

    public:
        Cookie* Find(char *n, char *d=NULL);
        Cookie* Add(char *n, char *v, char *d);
        Cookie* Add(char *setcookie, char *d);
        BOOL Remove(char *n, char *d=NULL);

        void Eval(char *dest, char *d=NULL);
    };

class CHttpClient
    {
    private:
        SOCKET sock;
        SOCKET nextsock;
        SOCKADDR_IN dest;

        WORD wPort;

        // Proxy Settings
        BOOL bUseProxy;
        WORD wProxyPort;
        char szProxyServerName[1024];

        // SSL stuffs
        CSecureSocketLayer *SSL;

        // timeouts
        TIMEVAL timeout;

		// timers
        time_t sendTime;
        time_t ttfbTime;        // Time to First Byte
        time_t ttlbTime;        // Time to Last Byte

    public: // send and receive buffer
        char data[DATA_SIZE+1];
        int dataLen;

    public:
        __declspec( dllexport ) int GetHTTPStatus(void);
        __declspec( dllexport ) char* GetBody(void);
        __declspec( dllexport ) char* GetData(void);
        __declspec( dllexport ) int GetDataLen(void);

    public:
        __declspec( dllexport ) int ParseURL(const char *url, char *server, char *site, BOOL* ssl);
        __declspec( dllexport ) int GrabCookies(Cookie *jar, char *source, char *domain=NULL);
        __declspec( dllexport ) int GetCookieRules(void);
        __declspec( dllexport ) void SetCookieRules(int i);
        __declspec( dllexport ) int URLEncode(char *dest, const char *source);
        __declspec( dllexport ) int URLDecode(char *dest, const char *source);
        __declspec( dllexport ) int POSTEncode(char *dest, const char *source);

    public:
        __declspec( dllexport ) long Open(void);
        __declspec( dllexport ) long Connect(IN_ADDR server, const char *serverName);
        __declspec( dllexport ) long Connect(const char *serverName);
        __declspec( dllexport ) long Disconnect(void);
        __declspec( dllexport ) long HardDisconnect(void);

        __declspec( dllexport ) long Send(const char *senddata, int len);
        __declspec( dllexport ) long Send(void); // send what is already in the 'data' buffer
        __declspec( dllexport ) long Receive(BOOL readAll=FALSE);

        __declspec( dllexport ) BOOL IsDataAvailable(void);
        __declspec( dllexport ) BOOL IsSendAvailable(void);

    public: // socket / connection options
        __declspec( dllexport ) long SetLinger(BOOL linger, WORD timeout);
        __declspec( dllexport ) long SetKeepAlive(BOOL keepalive);
        __declspec( dllexport ) long SetSSL(LPSTR pszUserName=NULL, DWORD dwProtocol=SP_PROT_SSL2, ALG_ID aiKeyExch=CALG_RSA_KEYX);
        __declspec( dllexport ) long SetProxy(const char *serverName, WORD port);
        __declspec( dllexport ) void SetRecvTimeout(UINT sec, UINT msec);
        __declspec( dllexport ) void SetDefaultPort(WORD newPort);

    public: // information
        __declspec( dllexport ) BOOL DNSLookup(char *address, char *output, size_t bufferlen);
        __declspec( dllexport ) time_t GetTime(unsigned char timeToReturn);

    public: // constructor / destructor
        __declspec( dllexport ) CHttpClient();
        __declspec( dllexport ) ~CHttpClient();
    };

#endif // _HTTPCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\cookie.cpp ===
/*

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    Cookie.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/
#include "stdafx.h"
#include "HttpClient.h"

int followDomainRules = 0;
int CompareDomain(char *full, char *gen);
int StrictCompareDomain(char *full, char *gen);

Cookie::Cookie()
    {
    name = NULL;
    value = NULL;
    domain = NULL;
    next = NULL;
    path = NULL;
    localvalue = NULL;
    localvalueLen = 0;
    }

Cookie::Cookie(char *n, char *v /*=NULL*/, char *d /*=NULL*/)
    {
    //__asm int 3;
    name = NULL;
    value = NULL;
    domain = NULL;
    path = NULL;
    localvalue = NULL;
    localvalueLen = 0;
    if(n)
        {
        name = new char[strlen(n)+1];
        if(name) strcpy(name, n);
        }
    if(v)
        {
        value = new char[strlen(v)+1];
        if(value) strcpy(value, v);
        }
    if(d)
        {
        domain = new char[strlen(d)+1];
        if(domain) strcpy(domain, d);
        }

    next = NULL;
    }

Cookie::~Cookie()
    {
    if(name)  delete[] name;
    if(value) delete[] value;
    if(domain) delete[] domain;
    if(localvalue) delete[] localvalue;
    if(next)  delete next;
    if(path) delete[] path;
    }

Cookie* Cookie::Find(char *n, char *d/*=NULL*/)
    {
    if(!n) return NULL;
    if(name && strcmp(name, n) == 0 && StrictCompareDomain(domain, d)) return this;
    if(!next) return NULL;
    else return next->Find(n);
    }

Cookie* Cookie::Add(char *n, char *v, char *d)
    {
    //__asm int 3;
    /*
        NOTES: We allow a server to set a cookie in a different domain
    */
    if(!n) return NULL;
    if(!v) v = "";

    if(!name)
        {
        if(next)
            {
            return next->Add(n, v, d);
            }
        next = new Cookie(n, v, d);
        return next;
        }
    else if(followDomainRules && strcmp(name, n)==0 && StrictCompareDomain(domain, d)>=0)
        {
        if(value) delete[] value;
        value = new char[strlen(v)+1];
        strcpy(value, v);
        return this;
        }
    else if(!followDomainRules && strcmp(name, n) == 0)
        {
        if(value) delete[] value;
        if(domain) delete[] domain;
        domain = NULL;

        value = new char[strlen(v)+1];
        strcpy(value, v);

        if(d)
            {
            domain = new char[strlen(d)+1];
            strcpy(domain, d);
            }
        return this;
        }
    else if(!next)
        {
        next = new Cookie(n, v, d);
        return next;
        }
    else return next->Add(n, v, d);
    }

Cookie* Cookie::Add(char *setcookie, char *d)
    {
    //__asm int 3;
    if(!setcookie) return NULL;

    size_t line = strcspn(setcookie, "\r\n");
    char end = setcookie[line];
    setcookie[line] = '\0';
    size_t len = strcspn(setcookie, "=");

    size_t localnameLen = 0;
    char *localname = NULL;
    char *cookiestart = setcookie;
    char *nameend = cookiestart+len;
    char *valueend = nameend + strcspn(nameend, "; ");

    if((unsigned)(nameend - cookiestart + 1) > localnameLen || !localname)
        {
        localnameLen = nameend - cookiestart + 1;
        if(localname) delete[] localname;
        localname = new char[localnameLen];
        if(!localname)
            {
            setcookie[line] = end;
            return NULL;
            }
        }
    if((unsigned)(valueend - (nameend+1) + 1) > localvalueLen || !localvalue)
        {
        localvalueLen = valueend - (nameend+1) + 1;
        if(localvalue) delete[] localvalue;
        localvalue = new char[localvalueLen];
        if(!localvalue)
            {
            setcookie[line] = end;
            return NULL;
            }
        }

    char *domainend = NULL;
    char *newdomain = strstr(setcookie, "; domain=");
    char domainterm = '\0';
    if(newdomain)
        {
        newdomain += 9;
        domainend = newdomain + strcspn(newdomain, "; ");
        if(domainend != newdomain)
            {
            domainterm = *domainend;
            *domainend = '\0';
            d = newdomain;
            }
        else domainend = NULL;
        }

    strncpy(localname, cookiestart, nameend - cookiestart);
    localname[nameend - cookiestart] = '\0';

    if(*nameend)
        {
        strncpy(localvalue, nameend+1, valueend - (nameend+1));
        localvalue[valueend - (nameend+1)] = '\0';
        }

    Cookie *c = Add(localname, localvalue, d);

    delete[] localname;

    setcookie[line] = end;
    if(domainend) *domainend = domainterm;

    return c;
    }

void Cookie::Eval(char *dest, char *d/*=NULL*/)
    {
    int bytes = 0;

    if(name && value)
        {
        if(followDomainRules && d && domain)
            {
            if(CompareDomain(d, domain) >= 0)
                {
                if(next) bytes = sprintf(dest, "%s=%s; ", name, value);
                else sprintf(dest, "%s=%s", name, value);
                }
            }
        else
            {
            if(next) bytes = sprintf(dest, "%s=%s; ", name, value);
            else sprintf(dest, "%s=%s", name, value);
            }
        }

    if(next) next->Eval(dest + bytes, d);
    }

BOOL Cookie::Remove(char *n, char *d/*=NULL*/)
    {
    //__asm int 3;
    if(!n) return FALSE;

    BOOL ret = FALSE;

    Cookie *p = NULL;

    for(Cookie*c = this; c; c=c->next)
        {
        if(c->name)
            {
            if(strcmp(c->name, n) == 0 && StrictCompareDomain(c->domain, d)>=0)
                {
                if(p)
                    {
                    p->next = c->next;
                    c->next = NULL;
                    delete c;
                    ret = TRUE;
                    c = p; // cause we dont change p in this case
                    }
                else
                    {
                    delete[] c->name;
                    c->name = NULL;
                    if(c->value) delete[] c->value;
                    if(c->domain) delete[] c->domain;
                    ret = TRUE;
                    }
                }
            }
        p = c;
        }

    return ret;
    }

/*
    returns
    - if they dont match
    0 if they are ==
    + if the generalized domain matches the full domain

    TODO: different algo needed if domain is actually an IP

*/
int CompareDomain(char *full, char *gen)
    {
    if(!gen) return 1;
    if(!full) return 1;

    size_t fullLen = strlen(full);
    size_t genLen = strlen(gen);

    if(genLen > fullLen) return -1;
    if(genLen == fullLen) return -(!!_stricmp(full, gen));

    full += fullLen-genLen;

    if(full[0] != '.' && full[-1] != '.') return -3;

    if(_stricmp(full, gen) == 0) return 1;
    return -4;
    }

int StrictCompareDomain(char *full, char *gen)
    {
    if(!gen) return 1;
    if(!full) return 1;

    if(_stricmp(full, gen) == 0) return 1;
    return -1;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	socktest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\buildhack.cpp ===
#include "stdafx.h"

#include "../common/AnsiBstr.cpp"
#include "../common/ParserTools.cpp"
#include "../common/utils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\securesocketlayer.cpp ===
/*

Copyright (C) 1999 Microsoft Corporation

Module Name:

    SecureSocketLayer.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/
#include "stdafx.h"
#include "SecureSocketLayer.h"

#define SSL_RECV_TIMEOUT 4 // recv timeout in sec

#ifdef _DEBUG
void _cdecl TraceDbg(LPCTSTR lpszFormat, ...)
    {
    int nBuf;
    char szBuffer[1024];

    va_list args;
    va_start(args, lpszFormat);

    nBuf = vsprintf(szBuffer, lpszFormat, args);
    OutputDebugString(szBuffer);

    va_end(args);
    }
#endif

CSecureSocketLayer::CSecureSocketLayer(LPSTR pszUserName /* =NULL */, DWORD dwProtocol /* =SP_PROT_SSL2 */, ALG_ID  aiKeyExch /* =CALG_RSA_KEYX */ )
    {
    try 
        {
        hSecuritydll = NULL;
        bConnected = FALSE;
        SecInvalidateHandle(&hClientCreds); // set dwUpper & dwLower to -1
        SecInvalidateHandle(&hContext);
        ZeroMemory(&SchannelCred, sizeof(SchannelCred));
        hMyCertStore = NULL;

        LoadSecurityLibrary();

        InitializeClient(pszUserName, dwProtocol, aiKeyExch);
        }
    catch(...)
        {
        SecInvalidateHandle(&hClientCreds); // set dwUpper & dwLower to -1
        SecInvalidateHandle(&hContext);
        #ifdef _DEBUG
        TraceDbg("CSecureSocketLayer::CSecureSocketLayer Execption Caught!");
        #endif
        }
    }


CSecureSocketLayer::~CSecureSocketLayer()
    {
    try 
        {
        // hClientCred and hMyCertStore are created in InitializeClient()
        if(hClientCreds.dwLower != -1 && hClientCreds.dwUpper != -1)
            {
            SecurityFunc.FreeCredentialsHandle(&hClientCreds);
            }
        CertCloseStore(hMyCertStore, 0);
        }
    catch(...)
        {
        #ifdef _DEBUG
        TraceDbg("CSecureSocketLayer::~CSecureSocketLayer Execption Caught!");
        #endif
        }
    UnloadSecurityLibrary();
    }

SECURITY_STATUS CSecureSocketLayer::Connect(SOCKET sock, const char *server)
    {
    if(!server) return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS scRet = SEC_E_OK;
    try 
        {
        // Client-Server Handshake
        scRet = PerformClientHandshake(sock, server);
        if(scRet == SEC_E_OK)
            {
            bConnected = TRUE;

            // Check Cert
            // TODO
            //scRet = SecurityFunc.QueryContextAttributes(&hContext, SECPKG_ATTR_REMOTE_CERT_CONTEXT, (PVOID)&pRemoteCertContext);
            //if(!FAILED(scRet)) scRet = VerifyServerCertificate(pRemoteCertContext, server, 0);
            }
        else
            {
            bConnected = FALSE;
            }
        }
    catch(...)
        {
        bConnected = FALSE;
        SecInvalidateHandle(&hContext);
        #ifdef _DEBUG
        TraceDbg("CSecureSocketLayer::Connect Execption Caught!");
        #endif
        scRet = SEC_E_INTERNAL_ERROR;
        }

    return scRet;
    }

SECURITY_STATUS CSecureSocketLayer::Encrypt(char *data, DWORD &dataLen, DWORD bufferLen)
    {
    // dataLen gets modified to the new length
    SECURITY_STATUS scRet = SEC_E_OK;

    try 
        {
        SecPkgContext_StreamSizes Sizes;
        SecBufferDesc   Message;
        SecBuffer       Buffers[4];

        // Mapping of information in the buffer:
        //   data[0]                         start of the SSL header
        //   data[Sizes.cbHeader]            start of the actual message
        //   data[Sizes.cbHeader + dataLen]  start of the SSL trailer

        scRet = SecurityFunc.QueryContextAttributes(&hContext, SECPKG_ATTR_STREAM_SIZES, &Sizes);
        if(FAILED(scRet))
            {
            dataLen = 0;
            }

        // encryption will be done inplace
        else if(Sizes.cbHeader + dataLen + Sizes.cbTrailer >= bufferLen)
            {
            // this message would make data overflow
            dataLen = 0;
            scRet = SEC_E_BUFFER_TOO_SMALL;
            }
        else
            {
            // NOTE: The plaintext sent to EncryptMessage
            //       should never be more than 'Sizes.cbMaximumMessage'

            // Header
            int dataBuff = 0;
            unsigned long dataSize = 0;
            if(Sizes.cbHeader != 0)
                {
                Buffers[dataBuff].pvBuffer = data;
                Buffers[dataBuff].cbBuffer = Sizes.cbHeader;
                Buffers[dataBuff].BufferType = SECBUFFER_STREAM_HEADER;
                dataSize += Buffers[dataBuff].cbBuffer;
                ++dataBuff;
                }

            // Data
            memmove(data + Sizes.cbHeader, data, dataLen);
            Buffers[dataBuff].pvBuffer = data + Sizes.cbHeader;
            Buffers[dataBuff].cbBuffer = dataLen;
            Buffers[dataBuff].BufferType = SECBUFFER_DATA;
            dataSize += Buffers[dataBuff].cbBuffer;
            ++dataBuff;

            // Trailer
            if(Sizes.cbTrailer != 0)
                {
                Buffers[dataBuff].pvBuffer = data + Sizes.cbHeader + dataLen;
                Buffers[dataBuff].cbBuffer = Sizes.cbTrailer;
                Buffers[dataBuff].BufferType = SECBUFFER_STREAM_TRAILER;
                dataSize += Buffers[dataBuff].cbBuffer;
                ++dataBuff;
                }

            // Ending
            Buffers[dataBuff].BufferType = SECBUFFER_EMPTY;
            ++dataBuff;

            Message.ulVersion = SECBUFFER_VERSION;
            Message.cBuffers = dataBuff;
            Message.pBuffers = Buffers;

            dataLen = Sizes.cbHeader + dataLen + Sizes.cbTrailer;

            // Reserved3 == EncryptMessage
            scRet = SecurityFunc.Reserved3(&hContext, 0, &Message, 0);
            }
        }
    catch(...)
        {
        #ifdef _DEBUG
        TraceDbg("CSecureSocketLayer::Encrypt Execption Caught!");
        #endif
        scRet = SEC_E_INTERNAL_ERROR;
        }

    return scRet;
    }

SECURITY_STATUS CSecureSocketLayer::Decrypt(char *data, DWORD &dataLen, DWORD bufferLen)
    {
    // dataLen gets modified to the new length
    SECURITY_STATUS scRet = SEC_E_OK;

    try 
        {
        SecBufferDesc   Message;
        SecBuffer       Buffers[4];

        Buffers[0].pvBuffer     = data;
        Buffers[0].cbBuffer     = dataLen;
        Buffers[0].BufferType   = SECBUFFER_DATA;

        Buffers[1].BufferType   = SECBUFFER_EMPTY;
        Buffers[2].BufferType   = SECBUFFER_EMPTY;
        Buffers[3].BufferType   = SECBUFFER_EMPTY;

        Message.ulVersion       = SECBUFFER_VERSION;
        Message.cBuffers        = 4;
        Message.pBuffers        = Buffers;

        // Reserved4 == DecryptMessage
        scRet = SecurityFunc.Reserved4(&hContext, &Message, 0, NULL);
        if(!FAILED(scRet))
            {
            // This loop moves the data around and decrypts extra data if needed
            for(unsigned long i=0, offset=0; i<Message.cBuffers; i++)
                {
                if(Buffers[i].BufferType == SECBUFFER_STREAM_HEADER)
                    {
                    offset += Buffers[i].cbBuffer;
                    }

                // Here is the data that actually got decrypted
                else if(Buffers[i].BufferType == SECBUFFER_DATA)
                    {
                    memmove(data, data+offset, Buffers[i].cbBuffer);
                    data[Buffers[i].cbBuffer] = '\0';
                    dataLen = Buffers[i].cbBuffer;
                    offset = Buffers[i].cbBuffer;
                    }

                // Here is the data that still needs to be decrypted
                else if(Buffers[i].BufferType == SECBUFFER_EXTRA)
                    {
                    DWORD len = Buffers[i].cbBuffer;
                    Decrypt((char*)Buffers[i].pvBuffer, len, bufferLen-dataLen);
                    memmove(data+offset, Buffers[i].pvBuffer, len);
                    dataLen += len;
                    }
                }
            }
        else
            {
            dataLen = 0;
            }
        }
    catch(...)
        {
        #ifdef _DEBUG
        TraceDbg("CSecureSocketLayer::Decrypt Execption Caught!");
        #endif
        scRet = SEC_E_INTERNAL_ERROR;
        }

    return scRet;
    }

SECURITY_STATUS CSecureSocketLayer::Disconnect(SOCKET sock)
    {
    SECURITY_STATUS scRet = SEC_E_OK;

    try 
        {
        if(bConnected)
            {
            scRet = DisconnectFromServer(sock);
            }
        if(hContext.dwLower != -1 || hContext.dwUpper != -1)
            {
            // hContext is created in PerformClientHandshake() on success
            SecurityFunc.DeleteSecurityContext(&hContext);
            }
        }
    catch(...)
        {
        #ifdef _DEBUG
        TraceDbg("CSecureSocketLayer::Disconnect Execption Caught!");
        #endif
        scRet = SEC_E_INTERNAL_ERROR;
        }

    return scRet;
    }


/*****************************************************************************/
BOOL CSecureSocketLayer::LoadSecurityLibrary(void)
    {
    PSecurityFunctionTable  pSecurityFunc;
    INIT_SECURITY_INTERFACE pInitSecurityInterface;

    hSecuritydll = LoadLibrary("security.dll");
    if(hSecuritydll == NULL)
        {
        #ifdef _DEBUG
        TraceDbg("Error 0x%x loading security.dll.\n", GetLastError());
        #endif
        return FALSE;
        }

    pInitSecurityInterface = (INIT_SECURITY_INTERFACE)GetProcAddress(hSecuritydll, "InitSecurityInterfaceA");
    
    if(pInitSecurityInterface == NULL)
        {
        #ifdef _DEBUG
        TraceDbg("Error 0x%x reading InitSecurityInterface entry point.\n", GetLastError());
        #endif
        return FALSE;
        }

    pSecurityFunc = pInitSecurityInterface();

    if(pSecurityFunc == NULL)
        {
        #ifdef _DEBUG
        TraceDbg("Error 0x%x reading security interface.\n", GetLastError());
        #endif
        return FALSE;
        }

    CopyMemory(&SecurityFunc, pSecurityFunc, sizeof(SecurityFunc));

    return TRUE;
    }

/*****************************************************************************/
void CSecureSocketLayer::UnloadSecurityLibrary(void)
    {
    FreeLibrary(hSecuritydll);
    hSecuritydll = NULL;
    }

/*****************************************************************************/
SECURITY_STATUS CSecureSocketLayer::InitializeClient(
    LPSTR pszUserName,
    DWORD dwProtocol,
    ALG_ID  aiKeyExch)
    {
    TimeStamp       tsExpiry;
    SECURITY_STATUS status;

    DWORD           cSupportedAlgs = 0;
    ALG_ID          rgbSupportedAlgs[16];

    PCCERT_CONTEXT  pCertContext = NULL;


    // Open the "MY" certificate store, which is where Internet Explorer
    // stores its client certificates.
    if(hMyCertStore == NULL)
        {
        hMyCertStore = CertOpenSystemStore(0, "MY");

        if(!hMyCertStore)
            {
            #ifdef _DEBUG
            TraceDbg("**** Error 0x%x returned by CertOpenSystemStore\n", GetLastError());
            #endif
            return SEC_E_NO_CREDENTIALS;
            }
        }

    // If a user name is specified, then attempt to find a client
    // certificate. Otherwise, just create a NULL credential.
    if(pszUserName)
        {
        // Find client certificate. Note that this sample just searchs for a 
        // certificate that contains the user name somewhere in the subject name.
        // A real application should be a bit less casual.
        pCertContext = CertFindCertificateInStore(hMyCertStore, 
                                                  X509_ASN_ENCODING, 
                                                  0,
                                                  CERT_FIND_SUBJECT_STR_A,
                                                  pszUserName,
                                                  NULL);
        if(pCertContext == NULL)
            {
            #ifdef _DEBUG
            TraceDbg("**** Error 0x%x returned by CertFindCertificateInStore\n", GetLastError());
            #endif
            return SEC_E_NO_CREDENTIALS;
            }
        }


    // Build Schannel credential structure. Currently, this sample only
    // specifies the protocol to be used (and optionally the certificate, 
    // of course). Real applications may wish to specify other parameters 
    // as well.
    SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
    if(pCertContext)
        {
        SchannelCred.cCreds = 1;
        SchannelCred.paCred = &pCertContext;
        }

    SchannelCred.grbitEnabledProtocols = dwProtocol;

    if(aiKeyExch)
        {
        rgbSupportedAlgs[cSupportedAlgs++] = aiKeyExch;
        }

    if(cSupportedAlgs)
        {
        SchannelCred.cSupportedAlgs    = cSupportedAlgs;
        SchannelCred.palgSupportedAlgs = rgbSupportedAlgs;
        }

    SchannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
    SchannelCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;

    // Create an SSPI credential.
    status = SecurityFunc.AcquireCredentialsHandleA(
                        NULL,                   // Name of principal    
                        UNISP_NAME_A,           // Name of package
                        SECPKG_CRED_OUTBOUND,   // Flags indicating use
                        NULL,                   // Pointer to logon ID
                        &SchannelCred,          // Package specific data
                        NULL,                   // Pointer to GetKey() func
                        NULL,                   // Value to pass to GetKey()
                        &hClientCreds,          // (out) Cred Handle
                        &tsExpiry);             // (out) Lifetime (optional)

    if(pCertContext) CertFreeCertificateContext(pCertContext);

    if(FAILED(status))
        {
        #ifdef _DEBUG
        TraceDbg("**** Error 0x%x returned by AcquireCredentialsHandle\n", status);
        #endif
        }
    return status;
    }

/*****************************************************************************/
SECURITY_STATUS CSecureSocketLayer::PerformClientHandshake(
    SOCKET          Socket,
    const char*     pszServerName)
    {
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS scRet;
    int           cbData;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    // Initiate a ClientHello message and generate a token.
    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    // build a unique identifier
    char *target;
    unsigned length = strlen(pszServerName);
    target = new char[length + 10];
    strcpy(target, pszServerName);
    for(int i=0; i<9; i++)
        {
        target[length+i] = (rand() % 26) + 'A';
        }
    target[length + 9] = '\0';

    scRet = SecurityFunc.InitializeSecurityContextA(
                    &hClientCreds,
                    NULL,
                    target, // use a unique value to avoid caching of creds (char*)pszServerName,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    &hContext,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);
    delete[] target;

    if(scRet != SEC_I_CONTINUE_NEEDED)
        {
        #ifdef _DEBUG
        TraceDbg("**** Error %Lu returned by InitializeSecurityContext (1)\n", scRet);
        #endif
        SecInvalidateHandle(&hClientCreds); // set dwUpper & dwLower to -1
        SecInvalidateHandle(&hContext); // set dwUpper & dwLower to -1
        if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
            {
            SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
            }
        return scRet;
        }

    // Send response to server if there is one
    if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
        {
        cbData = send(Socket, (char*)OutBuffers[0].pvBuffer, OutBuffers[0].cbBuffer, 0);

        // Free output buffer.
        SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;

        if(cbData == SOCKET_ERROR || cbData == 0)
            {
            scRet = WSAGetLastError();
            #ifdef _DEBUG
            TraceDbg("**** Error %d sending data to server (1)\n", (int)scRet);
            #endif
            return scRet;
            }

        }

    scRet = ClientHandshakeLoop(Socket, TRUE);

    return scRet;
    }

/*****************************************************************************/
SECURITY_STATUS CSecureSocketLayer::ClientHandshakeLoop(
    SOCKET          Socket,
    BOOL            fDoRead)
    {
    SECURITY_STATUS scRet;
    SecBufferDesc   InBuffer;
    SecBuffer       InBuffers[2];
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    int             cbData;

    ExtraData.pvBuffer   = NULL;
    ExtraData.cbBuffer   = 0;
    ExtraData.BufferType = SECBUFFER_EMPTY;


    char           IoBuffer[IO_BUFFER_SIZE*2];
    DWORD           cbIoBuffer;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    cbIoBuffer = 0;


    scRet = SEC_I_CONTINUE_NEEDED; // this comes from the initial call in PerformClientHandshake

    // loop control
    UINT count = 0;

    // Loop until the handshake is finished or an error occurs.
    while(scRet == SEC_I_CONTINUE_NEEDED || scRet == SEC_E_INCOMPLETE_MESSAGE || scRet == SEC_I_INCOMPLETE_CREDENTIALS) 
	    {
        if(++count == 100)
            {
            break; // bail after a while (returns the previous scRet error)
            }

        // Read data from server.
        if(0 == cbIoBuffer || scRet == SEC_E_INCOMPLETE_MESSAGE)
            {
            if(fDoRead)
                {
                TIMEVAL timeout;
                timeout.tv_sec = SSL_RECV_TIMEOUT;
                timeout.tv_usec = 0;

                FD_SET bucket;
                bucket.fd_count = 1;
                bucket.fd_array[0] = Socket;

                // wait 5 seconds for data to come
                int err = select(0, &bucket, NULL, NULL, &timeout);
                if(err == 0 || err == SOCKET_ERROR)
                    {
                    scRet = WSAETIMEDOUT;
                    break;
                    }

                cbData = recv(Socket, IoBuffer + cbIoBuffer, IO_BUFFER_SIZE - cbIoBuffer, 0);
                if(cbData == SOCKET_ERROR)
                    {
                    scRet = WSAGetLastError();
                    #ifdef _DEBUG
                    TraceDbg("**** Error %d reading data from server\n", (int)scRet);
                    #endif
                    break;
                    }

                cbIoBuffer += cbData;
                }
            else
                {
                fDoRead = TRUE;
                }
            }


        // Set up the input buffers. Buffer 0 is used to pass in data
        // received from the server. Schannel will consume some or all
        // of this. Leftover data (if any) will be placed in buffer 1 and
        // given a buffer type of SECBUFFER_EXTRA.
        InBuffers[0].pvBuffer   = IoBuffer;
        InBuffers[0].cbBuffer   = cbIoBuffer;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        InBuffer.cBuffers       = 2;
        InBuffer.pBuffers       = InBuffers;
        InBuffer.ulVersion      = SECBUFFER_VERSION;

        // Set up the output buffers. These are initialized to NULL
        // so as to make it less likely we'll attempt to free random
        // garbage later.
        OutBuffers[0].pvBuffer  = NULL;
        OutBuffers[0].BufferType= SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer  = 0;

        OutBuffer.cBuffers      = 1;
        OutBuffer.pBuffers      = OutBuffers;
        OutBuffer.ulVersion     = SECBUFFER_VERSION;



        // Call InitializeSecurityContext.
        scRet = SecurityFunc.InitializeSecurityContextA(&hClientCreds,
                                          &hContext,
                                          NULL,
                                          dwSSPIFlags,
                                          0,
                                          SECURITY_NATIVE_DREP,
                                          &InBuffer,
                                          0,
                                          NULL,
                                          &OutBuffer,
                                          &dwSSPIOutFlags,
                                          &tsExpiry);


        // If InitializeSecurityContext was successful (or if the error was 
        // one of the special extended ones), send the contends of the output
        // buffer to the server.
        if(scRet == SEC_E_OK || scRet == SEC_I_CONTINUE_NEEDED || (FAILED(scRet) && (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR)))
            {
            if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
                {
                cbData = send(Socket, (char*)OutBuffers[0].pvBuffer, OutBuffers[0].cbBuffer, 0);

                // Free output buffer.
                SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
                OutBuffers[0].pvBuffer = NULL;

                if(cbData == SOCKET_ERROR || cbData == 0)
                    {
                    scRet = WSAGetLastError();
                    #ifdef _DEBUG
                    TraceDbg("**** Error %d sending data to server (2)\n", (int)scRet);
                    #endif
                    break;
                    }

                }
            }


        // If InitializeSecurityContext returned SEC_E_INCOMPLETE_MESSAGE,
        // then we need to read more data from the server and try again.
        if(scRet == SEC_E_INCOMPLETE_MESSAGE)
            {
            continue;
            }

        // If InitializeSecurityContext returned SEC_E_OK, then the 
        // handshake completed successfully.
        if(scRet == SEC_E_OK)
            {
            // If the "extra" buffer contains data, this is encrypted application
            // protocol layer stuff. It needs to be saved. The application layer
            // will later decrypt it with DecryptMessage.

            ExtraData.pvBuffer   = NULL;
            ExtraData.cbBuffer   = 0;
            ExtraData.BufferType = SECBUFFER_EMPTY;

            // This is commented out since our application layer 
            // (CHttpClient) doesnt care about it
            /*
            if(InBuffers[1].BufferType == SECBUFFER_EXTRA)
                {
                ExtraData.pvBuffer = LocalAlloc(LMEM_FIXED, InBuffers[1].cbBuffer);
                if(ExtraData.pvBuffer == NULL)
                    {
                    return SEC_E_INSUFFICIENT_MEMORY;
                    }
                MoveMemory(ExtraData.pvBuffer, IoBuffer + (cbIoBuffer - InBuffers[1].cbBuffer), InBuffers[1].cbBuffer);
                ExtraData.cbBuffer   = InBuffers[1].cbBuffer;
                ExtraData.BufferType = SECBUFFER_TOKEN;
                }
            */

            // we are done with handshake
            break;
            }

        // Check for fatal error.
        if(FAILED(scRet))
            {
            #ifdef _DEBUG
            TraceDbg("**** Error 0x%x returned by InitializeSecurityContext (2)\n", scRet);
            #endif
            break;
            }


        // If InitializeSecurityContext returned SEC_I_INCOMPLETE_CREDENTIALS,
        // then the server just requested client authentication. 
        if(scRet == SEC_I_INCOMPLETE_CREDENTIALS)
            {
            // Display trusted issuers info. 
            GetNewClientCredentials(&hClientCreds, &hContext);

            // Now would be a good time perhaps to prompt the user to select
            // a client certificate and obtain a new credential handle, 
            // but I don't have the energy nor inclination.
            //
            // As this is currently written, Schannel will send a "no 
            // certificate" alert to the server in place of a certificate. 
            // The server might be cool with this, or it might drop the 
            // connection.

            // Go around again.
            fDoRead = FALSE;
            scRet = SEC_I_CONTINUE_NEEDED;
            continue;
            }


        // Copy any leftover data from the "extra" buffer, and go around again.
        if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
            {
            MoveMemory(IoBuffer,
                       IoBuffer + (cbIoBuffer - InBuffers[1].cbBuffer),
                       InBuffers[1].cbBuffer);

            cbIoBuffer = InBuffers[1].cbBuffer;
            }
        else
            {
            cbIoBuffer = 0;
            }
        }

    // Uncomment this if we actually use the ExtraData.pvBuffer (see above)
    //if(ExtraData.pvBuffer) LocalFree(ExtraData.pvBuffer);

    return scRet;
    }

/*****************************************************************************/
void CSecureSocketLayer::GetNewClientCredentials(
    CredHandle *phCreds,
    CtxtHandle *phContext)
    {
    CredHandle hCreds;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    PCCERT_CONTEXT  pCertContext;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;

    // Read list of trusted issuers from schannel.
    Status = SecurityFunc.QueryContextAttributes(phContext,
                                    SECPKG_ATTR_ISSUER_LIST_EX,
                                    (PVOID)&IssuerListInfo);
    if(Status != SEC_E_OK)
        {
        #ifdef _DEBUG
        TraceDbg("Error 0x%x querying issuer list info\n", Status);
        #endif
        return;
        }

    // Enumerate the client certificates.
    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    UINT count = 0;

    while(TRUE)
        {
        if(++count >= 100)
            {
            break;
            }

        // Find a certificate chain.
        pChainContext = CertFindChainInStore(hMyCertStore,
                                             X509_ASN_ENCODING,
                                             0,
                                             CERT_CHAIN_FIND_BY_ISSUER,
                                             &FindByIssuerPara,
                                             pChainContext);
        if(pChainContext == NULL)
            {
            #ifdef _DEBUG
            TraceDbg("Error 0x%x finding cert chain\n", GetLastError());
            #endif
            break;
            }

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // Create schannel credential.
        SchannelCred.cCreds = 1;
        SchannelCred.paCred = &pCertContext;

        Status = SecurityFunc.AcquireCredentialsHandleA(
                            NULL,                   // Name of principal
                            UNISP_NAME_A,           // Name of package
                            SECPKG_CRED_OUTBOUND,   // Flags indicating use
                            NULL,                   // Pointer to logon ID
                            &SchannelCred,          // Package specific data
                            NULL,                   // Pointer to GetKey() func
                            NULL,                   // Value to pass to GetKey()
                            &hCreds,                // (out) Cred Handle
                            &tsExpiry);             // (out) Lifetime (optional)
        if(Status != SEC_E_OK)
            {
            #ifdef _DEBUG
            TraceDbg("**** Error 0x%x returned by AcquireCredentialsHandle\n", Status);
            #endif
            continue;
            }

        // Destroy the old credentials.
        SecurityFunc.FreeCredentialsHandle(phCreds);
        SecInvalidateHandle(&hClientCreds);

        *phCreds = hCreds;

        break;
        }
    }

/*****************************************************************************/
long CSecureSocketLayer::VerifyServerCertificate(
    PCCERT_CONTEXT  pServerCert,
    const char*     pszServerName,
    DWORD           dwCertFlags)
    {
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;

    long   Status;
    PWSTR   pwszServerName;
    DWORD   cchServerName;

    if(pServerCert == NULL)
        {
        return SEC_E_WRONG_PRINCIPAL;
        }


    // Convert server name to unicode.
    if(pszServerName == NULL || strlen(pszServerName) == 0)
        {
        return SEC_E_WRONG_PRINCIPAL;
        }

    cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, NULL, 0);
    pwszServerName = (unsigned short*)LocalAlloc(LMEM_FIXED, cchServerName * sizeof(WCHAR));
    if(pwszServerName == NULL)
        {
        return SEC_E_INSUFFICIENT_MEMORY;
        }
    cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, pwszServerName, cchServerName);
    if(cchServerName == 0)
        {
        LocalFree(pwszServerName);
        return SEC_E_WRONG_PRINCIPAL;
        }


    // Build certificate chain.
    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    if(!CertGetCertificateChain(
                            NULL,
                            pServerCert,
                            NULL,
                            pServerCert->hCertStore,
                            &ChainPara,
                            0,
                            NULL,
                            &pChainContext))
        {
        Status = GetLastError();
        #ifdef _DEBUG
        TraceDbg("Error 0x%x returned by CertGetCertificateChain!\n", Status);
        #endif
        goto cleanup;
        }


    // Validate certificate chain.
    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = dwCertFlags;
    polHttps.pwszServerName     = pwszServerName;

    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize            = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &polHttps;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus);

    /* Error Values for PolicyStatus.dwError
    0
        Ok
    TRUST_E_CERT_SIGNATURE 
        The signature of the certificate cannot be verified. 
    CERT_E_UNTRUSTEDROOT 
        A certification chain was processed correctly but terminated in a root certificate that is not trusted by the trust provider. 
    CERT_E_UNTRUSTEDTESTROOT 
        The root certificate is a testing certificate and the policy settings disallow test certificates. 
    CERT_E_CHAINING 
        A chain of certificates was not correctly created. 
    CERT_E_WRONG_USAGE 
        The certificate is not valid for the requested usage. 
    CERT_E_EXPIRED 
        A required certificate is not within its validity period. 
    CERT_E_VALIDITYPERIODNESTING 
        The validity periods of the certification chain do not nest correctly. 
    CERT_E_PURPOSE 
        A certificate is being used for a purpose other than that for which it is permitted. 
    TRUST_E_BASIC_CONSTRAINTS 
        The certificate's basic constraints are invalid or missing. 
    CERT_E_ROLE 
        A certificate that can only be used as an end-entity is being used as a CA or visa versa. 
    CERT_E_CN_NO_MATCH 
        The certificate's CN name does not match the passed value. 
    CRYPT_E_REVOKED 
        The certificate or signature has been revoked. 
    CRYPT_E_REVOCATION_OFFLINE 
        The revocation server was offline because the called function wasn't able to complete the revocation check. 
    CERT_E_REVOKED 
        A certificate in the chain was explicitly revoked by its issuer. 
    CERT_E_REVOCATION_FAILURE 
        The revocation process could not continue. The certificates could not be checked. 
    */

    if(PolicyStatus.dwError)
        {
        Status = SEC_E_UNTRUSTED_ROOT;
        goto cleanup;
        }

    Status = SEC_E_OK;

cleanup:


    if(pwszServerName) LocalFree(pwszServerName);

    if(pChainContext)
        {
        CertFreeCertificateChain(pChainContext);
        }

    return Status;
    }

/*****************************************************************************/
long CSecureSocketLayer::DisconnectFromServer(
    SOCKET          Socket)
    {
    DWORD           dwType;
    char*           pbMessage;
    DWORD           cbMessage;
    int             cbData;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    long            status;

    //
    // Notify schannel that we are about to close the connection.
    //
    dwType = SCHANNEL_SHUTDOWN;

    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    status = SecurityFunc.ApplyControlToken(&hContext, &OutBuffer);

    if(FAILED(status)) 
        {
        #ifdef _DEBUG
        TraceDbg("**** Error 0x%x returned by ApplyControlToken\n", status);
        #endif
        return status;
        }

    // Build an SSL close notify message.
    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    status = SecurityFunc.InitializeSecurityContextA(
                    &hClientCreds,
                    &hContext,
                    NULL,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    &hContext,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);

    if(FAILED(status))
        {
        #ifdef _DEBUG
        TraceDbg("**** Error 0x%x returned by InitializeSecurityContext\n", status);
        #endif
        return status;
        }

    pbMessage = (char*)OutBuffers[0].pvBuffer;
    cbMessage = OutBuffers[0].cbBuffer;


    // Send the close notify message to the server.
    if(pbMessage != NULL && cbMessage != 0)
        {
        cbData = send(Socket, pbMessage, cbMessage, 0);
        if(cbData == SOCKET_ERROR || cbData == 0)
            {
            status = WSAGetLastError();
            #ifdef _DEBUG
            TraceDbg("**** Error %d sending close notify\n", status);
            #endif
            }

        // Free output buffer.
        SecurityFunc.FreeContextBuffer(pbMessage);
        }

    return status;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\browser.h ===
#ifndef _BROWSER_H_
#define _BROWSER_H_

#define MAX_HEADERS 50 // approx# based from HTTP 1.1 rfc

typedef struct
    {
    char *header;
    char *value;
    size_t headerLen;
    size_t valueLen;
    } HTTP_HEADER;

class Browser
    {
    public:
        HTTP_HEADER headers[MAX_HEADERS];
        char version[32];
        size_t versionLen;

        int length;

    public:
        Browser();
        Browser(char *filename);
        ~Browser();

        size_t EvalHeader(char *action, char *site, char *output);
        void AddHeader(char *header, char *value, size_t len=0);
        int Translate(char *h);
		bool IsHeaderSet(char *szHeaderName);
    };

#endif //_BROWSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\securesocketlayer.h ===
/*

Copyright (C) 1999 Microsoft Corporation

Module Name:

    SecureSocketLayer.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/
#ifndef _SECURESOCKETLAYER_H_
#define _SECURESOCKETLAYER_H_

// NOTE: Include files with error codes
//       SSL       <issperr.h> 
//       Sockets   <winsock2.h>
//       HTTP      <wininet.h>
//


// support non NT build environments that do not set this,
// 0x0400 is minimum required for security headers
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define SECURITY_WIN32
#include <wincrypt.h>
#include <schannel.h>
#include <security.h>
#include <softpub.h>

#define IO_BUFFER_SIZE  0x10000

// This table duplicates the current security table but it has
// the proper types associated with the Reserved3 and 4 functions
typedef struct _MYSECURITY_FUNCTION_TABLE_A {
    unsigned long                       dwVersion;
    ENUMERATE_SECURITY_PACKAGES_FN_A    EnumerateSecurityPackagesA;
    QUERY_CREDENTIALS_ATTRIBUTES_FN_A   QueryCredentialsAttributesA;
    ACQUIRE_CREDENTIALS_HANDLE_FN_A     AcquireCredentialsHandleA;
    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialHandle;
    #ifndef WIN32_CHICAGO
        void SEC_FAR *                  Reserved2;
    #else
        SSPI_LOGON_USER_FN              SspiLogonUserA;
    #endif
    INITIALIZE_SECURITY_CONTEXT_FN_A    InitializeSecurityContextA;
    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext;
    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken;
    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext;
    APPLY_CONTROL_TOKEN_FN              ApplyControlToken;
    QUERY_CONTEXT_ATTRIBUTES_FN_A       QueryContextAttributesA;
    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext;
    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext;
    MAKE_SIGNATURE_FN                   MakeSignature;
    VERIFY_SIGNATURE_FN                 VerifySignature;
    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer;
    QUERY_SECURITY_PACKAGE_INFO_FN_A    QuerySecurityPackageInfoA;
    ENCRYPT_MESSAGE_FN                  Reserved3;
    DECRYPT_MESSAGE_FN                  Reserved4;
    EXPORT_SECURITY_CONTEXT_FN          ExportSecurityContext;
    IMPORT_SECURITY_CONTEXT_FN_A        ImportSecurityContextA;
    void SEC_FAR *                      Reserved7;
    void SEC_FAR *                      Reserved8;
    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken;
    ENCRYPT_MESSAGE_FN                  EncryptMessage;
    DECRYPT_MESSAGE_FN                  DecryptMessage;
} MySecurityFunctionTable, SEC_FAR* PMySecurityFunctionTable;

class CSecureSocketLayer
    {
    private:
        HMODULE hSecuritydll;
        MySecurityFunctionTable SecurityFunc;

        // vars used by security.dll
        CredHandle hClientCreds;
        CtxtHandle hContext;
        HCERTSTORE      hMyCertStore;
        SCHANNEL_CRED   SchannelCred;
        SecBuffer  ExtraData;
        PCCERT_CONTEXT pRemoteCertContext;
        BOOL bConnected;

    public:
        CSecureSocketLayer(LPSTR pszUserName=NULL, DWORD dwProtocol = SP_PROT_SSL2, ALG_ID aiKeyExch = CALG_RSA_KEYX);
        ~CSecureSocketLayer();

    public:
        SECURITY_STATUS Connect(SOCKET sock, const char *server);
        SECURITY_STATUS Encrypt(char *data, DWORD &dataLen, DWORD bufferLen);
        SECURITY_STATUS Decrypt(char *data, DWORD &dataLen, DWORD bufferLen);
        SECURITY_STATUS Disconnect(SOCKET sock);

        SECURITY_STATUS ClientHandshakeLoop(SOCKET Socket, BOOL fDoRead);

    private: // internal helper functions
        BOOL LoadSecurityLibrary(void);
        void UnloadSecurityLibrary(void);
        SECURITY_STATUS InitializeClient(LPSTR pszUserName, DWORD dwProtocol, ALG_ID aiKeyExch);
        SECURITY_STATUS PerformClientHandshake(SOCKET Socket, const char* pszServerName);
        void GetNewClientCredentials(CredHandle *phCreds, CtxtHandle *phContext);
        long VerifyServerCertificate(PCCERT_CONTEXT  pServerCert, const char* pszServerName, DWORD dwCertFlags);
        long DisconnectFromServer(SOCKET Socket);

    };

#endif // _SECURESOCKETLAYER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\httpclient\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _STDAFX_H_
#define _STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <winsock2.h>
#include <windows.h> 
#include <stdio.h>
#include <stdlib.h>

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\csurgeengine.cpp ===
// CSurgeEngine.cpp : Implementation of CSurgeEngine

/*
TODO
    
*/

#include "stdafx.h"
#include "SurgeEngine.h"
#include "CSurgeEngine.h"
#include "../common/AnsiBstr.h"
#include "../common/utils.h"

extern int GetUserFromDB(FastProfDB *db, BOOL randomUsers, BOOL bad, char *username, char *domain, char *pw);

ServerStats::ServerStats()
{
	dwCount = 0;
	dwStatus = 0;
	next = NULL;
	dwInternalState = 0;
	dwRetryCountdown = 0;
}

ServerStats::~ServerStats()
{
	if(next)
    {
		delete next;
		next = NULL;
	}
}

// Called by the HashTable to clean up the stats
// As per "SetCleanupFunct();"
void DestroyServerStats(void *p)
{
	if(!p) 
	{
		return;
	}
	ServerStats *v = *(ServerStats**)p;
	delete v;
}


///////////////////////////////////////////////////////////////////////////////
// Constructor
// Uses Init() to initialize any variables that may need to be cleared when
// Reset() is called.
///////////////////////////////////////////////////////////////////////////////
CSurgeEngine::CSurgeEngine()
{
	Init();

	srvStats.SetCleanupFunct(DestroyServerStats);

    // socket/security intialization
    hSecuritydll = NULL; // loaded only if we need ssl
    WSADATA wsaData;
    unsigned short version = MAKEWORD(2, 2);
    WSAStartup(version, &wsaData);
}


///////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////
CSurgeEngine::~CSurgeEngine()
{
    if(hSecuritydll) FreeLibrary(hSecuritydll);
    WSACleanup();
}


///////////////////////////////////////////////////////////////////////////////
// CSurgeEngine::Init
// Set all resettable internal variables to a well-known state.
///////////////////////////////////////////////////////////////////////////////
void CSurgeEngine::Init()
{
    // network settings
    port = 80;
    sslProtocol = SP_PROT_SSL3;
    cookieJar = new Cookie;
    useHead = FALSE;
    httpHeader = new Browser;
	m_fIsHostHeaderOverridden = false;
    ssl = FALSE;
    cookie[0] = '\0';
    followRedirects = FALSE;
    foundCookies = 0;
    getFullPage = FALSE;
    numRedirects = 5;

    seed=0;
    lastError = 0;
    httpStatus = 0;
    server[0] = site[0] = '\0';

    // logging
    loggingFlags = LOGGING_CLEAN;
    messageWindow = NULL;
    resultsLinePos = 0;

    userdb = NULL;

    useServerBlacklist = TRUE;
	timers = NULL;
}


///////////////////////////////////////////////////////////////////////////////
// CSurgeEngine::Shutdown
// Clear out any allocated resources on desturction or a call to Reset()
///////////////////////////////////////////////////////////////////////////////
void CSurgeEngine::Shutdown()
{
	if(httpHeader) 
	{
		delete httpHeader;
		httpHeader = NULL;
	}
    if(cookieJar)
	{
		delete cookieJar;
		cookieJar = NULL;
	}
    if(userdb) 
	{
		delete userdb;
		userdb = NULL;
	}
	if(timers) 
	{
		delete timers;
		timers = NULL;
	}
}


///////////////////////////////////////////////////////////////////////////////
// CSurgeEngine::Reset
// Called to put the component in a well-known "default" state.  Caller will
// have to re-add any custom headers by hand.
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSurgeEngine::Reset()
{	
	Shutdown();
	ResetResults();
	Init();
	return S_OK;
}




/*

Routine Description:



Arguments:



Return Value:



Notes:



*/
int GetUserFromDB(FastProfDB *db, BOOL randomUsers, BOOL bad, char *username, char *domain, char *pw)
    {
    LPSTR lpstrSearchResult;

    // get a user from a user profile db
    if(!db)
        {
        strcpy(username, "jpoley");
        strcpy(domain, "passport.com");
        strcpy(pw, "jpoley");
        return FALSE;
        }

    lpstrSearchResult = (randomUsers ? db->GetRandUser() : db->GetNextUser() );

    db->GetNamePW(lpstrSearchResult, username, domain, pw, BUFSIZE);
    if(bad)
        {
        username[0] = 'S'; // modify the username
        pw[0] = (char)(pw[0] + 1); // modify the password
        }

    return TRUE;
    }

/*

Routine Description:



Arguments:



Return Value:



Notes:



*/
void CSurgeEngine::ReportError(long error, char* lpszFormat, ...)
    {
    if(loggingFlags == LOGGING_OUT_NONE) return;

    va_list args;
    va_start(args, lpszFormat);

    char dbuffer[10];
    char tbuffer[10];
    _strdate(dbuffer);
    _strtime(tbuffer);

    char *szBuffer = new char[65536];
    if(!szBuffer) return;
    char *szFormat = new char[strlen(lpszFormat) + 128]; // + 128 for timestamp and error values
    if(!szFormat)
        {
        delete[] szBuffer;
        return;
        }

    sprintf(szFormat, "%s, %s, %Ld, 0x%LX, %s\n", tbuffer, dbuffer, error, error, lpszFormat);
    vsprintf(szBuffer, szFormat, args);

    if(loggingFlags & LOGGING_OUT_FILE)
        {
        FILE *f = fopen(SURGE_ERROR_FILENAME, "a+");
        if(f)
            {
            fprintf(f, "%s", szBuffer);
            fclose(f);
            }
        }

    if(loggingFlags & LOGGING_OUT_DEBUG)
        {
        OutputDebugString(szBuffer);
        }

    if((loggingFlags & LOGGING_OUT_MESSAGE) && messageWindow)
        {
        COPYDATASTRUCT cpdata;
        cpdata.cbData = MAXBUF;
        cpdata.lpData = szBuffer;
        cpdata.dwData = error;
        SendMessage(messageWindow, WM_COPYDATA, error, (LPARAM)&cpdata);
        }

    va_end(args);
    delete[] szBuffer;
    delete[] szFormat;
    }

/*

Routine Description:



Arguments:



Return Value:



Notes:



*/
void CSurgeEngine::ReportDump(const char *title, int isRaw, const char * buffer, DWORD length)
    {
    if(loggingFlags == LOGGING_OUT_NONE) return;

    char dbuffer[10];
    char tbuffer[10];
    _strdate(dbuffer);
    _strtime(tbuffer);

    FILE *f = fopen(SURGE_ERROR_FILENAME, "a+b");
    if(f) fprintf(f, "%s, %s, %s\r\n", tbuffer, dbuffer, title);

    //
    // Raw Dump
    //
    if(isRaw)
        {
        if((loggingFlags & LOGGING_OUT_FILE) && f)
            {
            fwrite(buffer, length, 1, f);
            fprintf(f, "\r\n");
            }

        if(f) fclose(f);
        return;
        }

    //
    // Hex Dump
    //
    DWORD i,count,index;
    CHAR rgbDigits[]="0123456789ABCDEF";
    CHAR rgbLine[100];
    char cbLine;

    for(index = 0; length; length -= count, buffer += count, index += count)
        {
        count = (length > 16) ? 16:length;

        sprintf(rgbLine, "%4.4x  ",index);
        cbLine = 6;

        for(i=0;i<count;i++)
            {
            rgbLine[cbLine++] = rgbDigits[buffer[i] >> 4];
            rgbLine[cbLine++] = rgbDigits[buffer[i] & 0x0f];
            if(i == 7)
                {
                rgbLine[cbLine++] = ' ';
                }
            else
                {
                rgbLine[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            }

        rgbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buffer[i] < 32 || buffer[i] > 126)
                {
                rgbLine[cbLine++] = '.';
                }
            else
                {
                rgbLine[cbLine++] = buffer[i];
                }
            }

        rgbLine[cbLine++] = 0;
        if(f) fprintf(f, "%s\r\n", rgbLine);
        else printf("%s\r\n", rgbLine);
        }

    if(f) fclose(f);
    }

/*

Routine Description:

    CSurgeThread::ConnectBatch
    This function just does the common CHttpClient connection calls
    
Arguments:

    CHttpClient &client - 
    ReportStat &stats   -
    char *server        -
    BOOL ssl            -
    int action          -

Return Value:

    long - 

Notes:

*/
long CSurgeEngine::ConnectBatch(const char *server, BOOL ssl, DWORD &latency)
    {
    if(ssl && !hSecuritydll) hSecuritydll = LoadLibrary("security.dll");

    DWORD time = GetTickCount();

    lastError = client.Open();
    client.SetDefaultPort(port);

    // client.SetProxy("itgproxy", 80);

    if(ssl)
        {
        lastError = client.SetSSL(NULL, sslProtocol);
        if(lastError)
            {
            latency = GetTickCount() - time;
            ReportError(lastError, "CHttpClient.SetSSL, %s%s", server, site);
            client.Disconnect();
            return lastError;
            }
        }

    lastError = client.Connect(server);

    latency = GetTickCount() - time;

    if(lastError && lastError != SEC_E_UNTRUSTED_ROOT)
        {
        ReportError(lastError, "CHttpClient.Connect, %s%s", server, site);
        client.Disconnect();
        return lastError;
        }

    return lastError = 0;
    }

/*

Routine Description:

    CSurgeThread::SendReceiveBatch
    This function just does the common CHttpClient communication calls
    
Arguments:



Return Value:



Notes:



*/
long CSurgeEngine::SendReceiveBatch(DWORD &latency, char *server)
    {
    DWORD time = GetTickCount();

    foundCookies = 0;

    // client.data and client.dataLen MUST be prepopulated with the data to send

    if(loggingFlags & LOGGING_HTTPDUMPHEX)
        {
        ReportDump("Sent:", false, client.GetData(), client.GetDataLen());
        }
    else if(loggingFlags & LOGGING_HTTPDUMPRAW)
        {
        ReportDump("Sent:", true, client.GetData(), client.GetDataLen());
        }

    lastError = client.Send();
    if(lastError)
        {
        latency = GetTickCount() - time;
        ReportError(lastError, "CHttpClient.Send, %s%s", server, site);
        client.Disconnect();
        return lastError;
        }

    do
        {
        lastError = client.Receive(getFullPage);
        if(loggingFlags & LOGGING_HTTPDUMPHEX)
            {
            ReportDump("Received:", false, client.GetData(), client.GetDataLen());
            }
        else if(loggingFlags & LOGGING_HTTPDUMPRAW)
            {
            ReportDump("Received:", true, client.GetData(), client.GetDataLen());
            }

        httpStatus = client.GetHTTPStatus();

        if(lastError != 0)
            {
            ReportError(lastError, "CHttpClient.Receive, %s%s", server, site);
            break;
            }

        lastError = httpStatus;

        } while(httpStatus == HTTP_STATUS_CONTINUE && !getFullPage);
        
    latency = GetTickCount() - time;

    if(httpStatus == HTTP_STATUS_CONTINUE && (strncmp(client.GetBody(), "HTTP", 4)==0))
        {
        size_t size = client.dataLen - (client.GetData()-client.GetBody());
        memmove(client.GetData(), client.GetBody(), size);
        lastError = httpStatus = client.GetHTTPStatus();
        }

    if(httpStatus && (httpStatus >= ((loggingFlags&LOGGING_HTTPMASK)>>4)*100))
        {
        ReportError(httpStatus, "%s%s, %s", server, site, ErrorNo(ERRCLASS_HTTP, httpStatus));
        }

    foundCookies = client.GrabCookies(cookieJar, client.GetData(), server);

    client.Disconnect();
    return (long)httpStatus;
    }

/*

Routine Description:

    CSurgeThread::GetPage
    
Arguments:



Return Value:



Notes:



*/
long CSurgeEngine::GetPage(char *url, char *postdata/*=NULL*/)
    {
    DWORD sentSize = 0;
    DWORD connectLatency = 0;
    DWORD transactionLatency = 0;
    long error;
    char datasize[32];
    size_t len;
    size_t postLen=0;
    ServerStats *s;
    char keyUrl[4096];
    httpStatus = 0;
    char placeholder;
    int redirects = 0;

    // strip off the query string for the key
    len = strcspn(url, "?");
    strncpy(keyUrl, url, len);
    keyUrl[len] = '\0';

    if(followRedirects) redirects = numRedirects;

    client.ParseURL(url, server, site, &ssl);
    do
        {
        if(postdata)
            {
            postLen = strlen(postdata);
            sprintf(datasize, "%u", postLen);
            // NOTE: The below line was commented out to provide necessary POST custimization
            //httpHeader->AddHeader("Content-Type", "application/x-www-form-urlencoded");
            httpHeader->AddHeader("Content-Length", datasize);
            }
        else
            {
            httpHeader->AddHeader("Content-Type", NULL);
            httpHeader->AddHeader("Content-Length", NULL);
            }

        s = NULL;
        srvStats.Get(keyUrl, s);
        if(s)
            {
            if(useServerBlacklist && s->dwInternalState)
                {
                if(--s->dwRetryCountdown == 0)
                    {
                    // retry, and if failed continue the countdown
                    s->dwRetryCountdown = s->dwInternalState *= 2;
                    }
                else
                    {
                    // skip this request cause the server isnt responding
                    // TODO return a blacklist error code
                    return lastError=WSAETIMEDOUT;
                    }
                }
            }

        cookieJar->Eval(cookie, server);
        httpHeader->AddHeader("Cookie", cookie);

		// if the user has not set the Host header variable, make
		// sure we have something in there
        if ( !httpHeader->IsHeaderSet("Host") || !m_fIsHostHeaderOverridden)
		{
			httpHeader->AddHeader("Host", server);
		}
        client.dataLen = httpHeader->EvalHeader((useHead ? "HEAD" : (postdata ? "POST" : "GET")), site, client.GetData());
        if(postdata)
            {
            strcpy(&client.data[client.dataLen], postdata);
            client.dataLen += postLen;
            }
        sentSize = client.dataLen;

        if((error=ConnectBatch(server, ssl, connectLatency)) != 0)
            {
            s = InsertResult(s, keyUrl, error, connectLatency);
            // TODO blacklist on ANY connect error?
            if(error == WSAETIMEDOUT)
                {
                if(!s->dwInternalState) s->dwInternalState = 4;
                s->dwRetryCountdown = s->dwInternalState;
                ReportError(WSAETIMEDOUT, "Connect Error, %s will be skipped (retry in %Lu attempts)", keyUrl, s->dwRetryCountdown);
                }
            break;
            }

        // Send & Read the response
        error=SendReceiveBatch(transactionLatency, server);

        // Update stats
        s = InsertResult(s, keyUrl, lastError, connectLatency, transactionLatency, sentSize, client.dataLen);
        s->dwInternalState = 0; // reset blacklist

        // check for redirects
        if(followRedirects && (error == 300 || error == 301 || error == 302 || error == 303))
            {
            postdata = NULL;
            char *l = strstr(client.data, "Location: ");
            if(l)
                {
                //__asm int 3;
                --redirects;

                // get rid of any query string
                len = strcspn(site, "?");
                if(len) site[len] = '\0';

                // find where we need to go
                l += strlen("Location: ");
                len = strcspn(l, "\r\n");
                placeholder = l[len];
                l[len] = '\0';

                // munge it into the site and server variables
                if(_strnicmp(l, "http", 4) == 0) client.ParseURL(l, server, site, &ssl);
                else if(l[0] == '\\' || l[0] == '/') strcpy(site, l);
                else
                    {
                    char *t = strrchr(site, '\\');
                    if(!t) t = strrchr(site, '/');
                    if(!t) strcpy(site+1, l);
                    else strcpy(t+1, l);
                    }
                l[len] = placeholder;

                // strip off any new query string for the key
                len = strcspn(site, "?");
                placeholder = site[len];
                site[len] = '\0';
                sprintf(keyUrl, "http%s://%s%s", (ssl?"s":""), server, site);
                site[len] = placeholder;
                continue;
                }
            }
        else break;

        } while(redirects);

    if(postdata)
        {
        httpHeader->AddHeader("Content-Type", NULL);
        httpHeader->AddHeader("Content-Length", NULL);
        }

    return error;
    }

ServerStats* CSurgeEngine::InsertResult(ServerStats *base, char *key, long status, DWORD clat /*=(DWORD)~0*/, DWORD tlat /*= (DWORD)~0*/, DWORD bytesSent /*=(DWORD)0*/, DWORD bytesReceived /*= (DWORD)0*/)
    {
    ServerStats *s;
    if(!base)
        {
        base = s = new ServerStats;
        if(!s) return NULL;
        srvStats.Add(key, s);
        s->dwStatus = status;
        }
    else
        {
        for(s = base; s; s=s->next)
            {
            if(s->dwStatus == (DWORD)status) break;
            if(!s->next)
                {
                s = s->next = new ServerStats;
                if(!s) return NULL;
                s->dwStatus = status;
                break;
                }
            }
        }

    ++s->dwCount;
    if(clat != (DWORD)~0) s->avgConnect.Insert(clat);
    if(tlat != (DWORD)~0) s->avgTransaction.Insert(tlat);
    if(bytesSent != (DWORD)0) s->avgBytesSent.Insert(bytesSent);
    if(bytesReceived != (DWORD)0) s->avgBytesReceived.Insert(bytesReceived);

    return base;
    }

/////////////////////////////////////////////////////////////////////////////
// CSurgeEngine

STDMETHODIMP CSurgeEngine::About()
    {
    MessageBox(NULL, "Surge Core Engine\n\nCopyright (C) 1999-2000 Microsoft", "Surge.Engine About", MB_OK);
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_messageWindow(long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

	*pVal = (long)messageWindow;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_messageWindow(long newVal)
    {
	messageWindow = (HWND)newVal;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GET(BSTR url)
    {
    USES_CONVERSION;
    if(!url) return E_INVALIDARG;

    char *aurl = W2A(url);
    if(strncmp(aurl, "http", 4) != 0) return E_INVALIDARG;

    GetPage(aurl);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::POST(BSTR url, BSTR data)
    {
    USES_CONVERSION;
    if(!url || !data) return E_INVALIDARG;

    char *aurl = W2A(url);
    if(strncmp(aurl, "http", 4) != 0) return E_INVALIDARG;

    GetPage(aurl, W2A(data));

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_httpStatus(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (short)httpStatus;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetUser(VARIANT_BOOL sequential, BSTR *username, BSTR *domain, BSTR *password)
    {
    // TODO watch for overflows
    if(!username || !domain || !password) return E_INVALIDARG;
    char u[MAXBUF];
    char d[MAXBUF];
    char p[MAXBUF];

    GetUserFromDB(userdb, !sequential, FALSE, u, d, p);

    *username = CreateBstrFromAnsi(u);
    *domain = CreateBstrFromAnsi(d);
    *password = CreateBstrFromAnsi(p);
    
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_usersFile(BSTR newVal)
    {
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;
    if(newVal[0] == '\0') return E_INVALIDARG;

    if(userdb) delete userdb;
    userdb = new FastProfDB(W2A(newVal));

    return S_OK;
    }


// ASSUMPTION: Host header set by browser definition file is not considered
// user over-ridden.
STDMETHODIMP CSurgeEngine::AddHeader(BSTR header, BSTR value)
{
    USES_CONVERSION;
    if( NULL == header ) 
	{
		return E_INVALIDARG;
	}

    char *aHeader = W2A(header);

	// If user overrides the Host header, we will not default to the
	// requested server name
    if ( (NULL == value) || ('\0' == value[0]) )
    {
		if( 0 == strcmp(aHeader, "Host") )
		{
			m_fIsHostHeaderOverridden = false;
		}
		httpHeader->AddHeader(aHeader, NULL);
    }
    else
    {
		if( 0 == strcmp(aHeader, "Host") )
		{
			m_fIsHostHeaderOverridden = true;
		}
		char *aValue = W2A(value);
		httpHeader->AddHeader(aHeader, aValue);
    }

    return S_OK;
}

STDMETHODIMP CSurgeEngine::put_browser(BSTR newVal)
    {
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;
    if(newVal[0] == '\0') return E_INVALIDARG;

    char *filename = W2A(newVal);

    FILE *f=fopen(filename, "r");
    if(!f)
        {
        ReportError(0, "Could not open Browser file: %s", filename);
        return S_OK;
        }
    fclose(f);

    if(httpHeader) delete httpHeader;
    httpHeader = new Browser(filename);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_sslProtocol(long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (long)sslProtocol;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_sslProtocol(long newVal)
    {
    sslProtocol = (DWORD)newVal;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_tcpPort(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (short)port;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_tcpPort(short newVal)
    {
    port = (WORD)newVal;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_followRedirects(VARIANT_BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (VARIANT_BOOL)followRedirects;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_followRedirects(VARIANT_BOOL newVal)
    {
    followRedirects = (BOOL)newVal;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::MD5Hash(BSTR input, BSTR *hash)
    {
    USES_CONVERSION;
    if(!hash) return E_INVALIDARG;
    if(!input)
        {
        *hash = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char h[36];
    ::MD5Hash(W2A(input), h);

    *hash = CreateBstrFromAnsi(h);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::DigestHash(BSTR algo, BSTR user, BSTR realm, BSTR password, BSTR nonce, BSTR noncecount, BSTR cnonce, BSTR qop, BSTR method, BSTR uri, BSTR entity, BSTR *hash)
    {
    USES_CONVERSION;
	if(!algo || !user || !realm || !password || !nonce || !method || !uri || !hash)
        {
        if(hash) *hash = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char session[129]; session[0] = '\0';
    char pwHash[129]; pwHash[0] = '\0';

    DigestFromCreds(W2A(algo), W2A(user), W2A(realm), W2A(password), W2A(nonce), W2A(noncecount), W2A(cnonce), W2A(qop), W2A(method), W2A(uri), W2A(entity), session, pwHash);

    *hash = CreateBstrFromAnsi(pwHash);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::URLEncode(BSTR url, BSTR *encoded)
    {
    USES_CONVERSION;
    if(!encoded) return E_INVALIDARG;
	if(!url)
        {
        *encoded = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char *p = W2A(url);
    char *result = new char[(strlen(p)+1)*3];
    if(!result)
        {
        *encoded = CreateBstrFromAnsi("");
        return E_OUTOFMEMORY;
        }

    client.URLEncode(result, p);

    *encoded = CreateBstrFromAnsi(result);
    delete[] result;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::URLDecode(BSTR url, BSTR *decoded)
    {
    USES_CONVERSION;
    if(!decoded) return E_INVALIDARG;
	if(!url)
        {
        *decoded = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char *p = W2A(url);
    char *result = new char[(strlen(p)+1)];
    if(!result)
        {
        *decoded = CreateBstrFromAnsi("");
        return E_OUTOFMEMORY;
        }

    client.URLDecode(result, p);

    *decoded = CreateBstrFromAnsi(result);
    delete[] result;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::POSTEncode(BSTR post, BSTR *encoded)
    {
    USES_CONVERSION;
    if(!encoded) return E_INVALIDARG;
	if(!post)
        {
        *encoded = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char *p = W2A(post);    
    char *result = new char[(strlen(p)+1)*3];
    if(!result)
        {
        *encoded = CreateBstrFromAnsi("");
        return E_OUTOFMEMORY;
        }

    client.POSTEncode(result, p);

    *encoded = CreateBstrFromAnsi(result);
    delete[] result;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_useHead(VARIANT_BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (VARIANT_BOOL)useHead;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_useHead(VARIANT_BOOL newVal)
    {
    useHead = (BOOL)newVal;
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetBody(BSTR *body)
    {
    if(!body)
        {
        return E_INVALIDARG;
        }

    *body = CreateBstrFromAnsi(client.GetBody());

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetHeader(BSTR *header)
    {
    if(!header)
        {
        return E_INVALIDARG;
        }

    char t='\0';
    char *temp = client.GetBody();
    if(temp)
        {
        t = temp[0];
        temp[0] = '\0';
        }

    *header = CreateBstrFromAnsi(client.GetData());

    if(temp) temp[0] = t;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::Log(long dwData, BSTR message)
    {
    USES_CONVERSION;

    ReportError(dwData, "User Message, %s", W2A(message));

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_loggingFlags(long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = loggingFlags;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_loggingFlags(long newVal)
    {
    loggingFlags = newVal;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GenerateRandom(short maxLength, short contents, BSTR *random)
    {
    if(!random)
        {
        return E_INVALIDARG;
        }

    size_t len=maxLength+1;
    if(len < 2) len = 2;

    char *str = NewRandomBuffer(2, len, (unsigned char)contents, len, seed);

    *random = CreateBstrFromAnsi(str);
    if(str) delete[] str;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetResultsHeader(BSTR *output)
    {
    if(!output)
        {
        return E_INVALIDARG;
        }

    *output = CreateBstrFromAnsi("URL, Error, Count, Connect Average, Connect Max, Connect Min, Transaction Avg, Transaction Max, Transaction Min, Bytes Out Avg, Bytes Out Max, Bytes Out Min, Bytes In Avg, Bytes In Max, Bytes In Min\r\n");
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetResults(BSTR *output)
    {
    if(!output)
        {
        return E_INVALIDARG;
        }

	char *buffer = new char[(srvStats.m_size+1) * 4096];
    char *ptr = buffer;

    if(!buffer)
        {
        return E_OUTOFMEMORY;
        }

    // Place header information in to the results, and advance the point by the number of bytes added (minus the NULL)
    ptr += sprintf(ptr, "URL, Error, Count, Connect Average, Connect Max, Connect Min, Transaction Avg, Transaction Max, Transaction Min, Bytes Out Avg, Bytes Out Max, Bytes Out Min, Bytes In Avg, Bytes In Max, Bytes In Min\r\n");

    for(size_t i=0; i<srvStats.m_size; i++)
        {
        if(srvStats.table[i])
            {
            for(HashEntry<ServerStats*> *h = srvStats.table[i]; h; h=h->next)
                {
                for(ServerStats *s = h->obj; s; s=s->next)
                    {
                    ptr += sprintf(ptr, "%s", h->key);
                    ptr += sprintf(ptr, ", %lu, %lu", s->dwStatus, s->dwCount);
                    if(s->avgConnect.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgConnect.Eval(), s->avgConnect.dwMax, s->avgConnect.dwMin);
                    else ptr += sprintf(ptr, ", NA, NA, NA");
                    if(s->avgTransaction.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgTransaction.Eval(), s->avgTransaction.dwMax, s->avgTransaction.dwMin);
                    else ptr += sprintf(ptr, ", NA, NA, NA");
                    if(s->avgBytesSent.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgBytesSent.Eval(), s->avgBytesSent.dwMax, s->avgBytesSent.dwMin);
                    else ptr += sprintf(ptr, ", 0, 0, 0");
                    if(s->avgBytesReceived.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgBytesReceived.Eval(), s->avgBytesReceived.dwMax, s->avgBytesReceived.dwMin);
                    else ptr += sprintf(ptr, ", 0, 0, 0");
                    ptr += sprintf(ptr, "\r\n");
                    }
                }
            }
        }

    if(i == 0) sprintf(ptr, "(no results yet)\r\n");

    *output = CreateBstrFromAnsi(buffer);
    delete[] buffer;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetResultsFor(BSTR key, BSTR *output)
    {
    USES_CONVERSION;
    if(!output) return E_INVALIDARG;
    if(!key)
        {
        *output = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char* aKey = W2A(key);

	char *buffer = new char[2 * 4096];
    char *ptr = buffer;
    if(!buffer)
        {
        return E_OUTOFMEMORY;
        }

    ServerStats *h=NULL;
    srvStats.Get(aKey, h);

    ptr += sprintf(ptr, "URL, Error, Count, Connect Average, Connect Max, Connect Min, Transaction Avg, Transaction Max, Transaction Min, Bytes Out Avg, Bytes Out Max, Bytes Out Min, Bytes In Avg, Bytes In Max, Bytes In Min\r\n");
    if(h)
        {
        for(ServerStats *s = h; s; s=s->next)
            {
            ptr += sprintf(ptr, "%s", aKey);
            ptr += sprintf(ptr, ", %lu, %lu", s->dwStatus, s->dwCount);
            if(s->avgConnect.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgConnect.Eval(), s->avgConnect.dwMax, s->avgConnect.dwMin);
            else ptr += sprintf(ptr, ", NA, NA, NA");
            if(s->avgTransaction.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgTransaction.Eval(), s->avgTransaction.dwMax, s->avgTransaction.dwMin);
            else ptr += sprintf(ptr, ", NA, NA, NA");
            if(s->avgBytesSent.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgBytesSent.Eval(), s->avgBytesSent.dwMax, s->avgBytesSent.dwMin);
            else ptr += sprintf(ptr, ", 0, 0, 0");
            if(s->avgBytesReceived.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgBytesReceived.Eval(), s->avgBytesReceived.dwMax, s->avgBytesReceived.dwMin);
            else ptr += sprintf(ptr, ", 0, 0, 0");
            ptr += sprintf(ptr, "\r\n");
            }
        }
    else sprintf(ptr, "(no results yet)\r\n");

    *output = CreateBstrFromAnsi(buffer);
    delete[] buffer;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetResultsLine(BSTR *output)
    {
    *output = NULL;
    if(!output)
        {
        return E_INVALIDARG;
        }

	char *buffer = new char[4096];
    char *ptr = buffer;
    if(!buffer)
        {
        return E_OUTOFMEMORY;
        }


    ++resultsLinePos;
    unsigned count = 0;

    for(size_t i=0; i<srvStats.m_size; i++)
        {
        if(srvStats.table[i])
            {
            for(HashEntry<ServerStats*> *h = srvStats.table[i]; h; h=h->next)
                {
                for(ServerStats *s = h->obj; s; s=s->next)
                    {
                    ++count;
                    if(count == resultsLinePos)
                        {
                        ptr += sprintf(ptr, "%s", h->key);
                        ptr += sprintf(ptr, ", %lu, %lu", s->dwStatus, s->dwCount);
                        if(s->avgConnect.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgConnect.Eval(), s->avgConnect.dwMax, s->avgConnect.dwMin);
                        else ptr += sprintf(ptr, ", NA, NA, NA");
                        if(s->avgTransaction.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgTransaction.Eval(), s->avgTransaction.dwMax, s->avgTransaction.dwMin);
                        else ptr += sprintf(ptr, ", NA, NA, NA");
                        if(s->avgBytesSent.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgBytesSent.Eval(), s->avgBytesSent.dwMax, s->avgBytesSent.dwMin);
                        else ptr += sprintf(ptr, ", 0, 0, 0");
                        if(s->avgBytesReceived.dwCount) ptr += sprintf(ptr, ", %lu, %lu, %lu", s->avgBytesReceived.Eval(), s->avgBytesReceived.dwMax, s->avgBytesReceived.dwMin);
                        else ptr += sprintf(ptr, ", 0, 0, 0");
                        ptr += sprintf(ptr, "\r\n");

                        *output = CreateBstrFromAnsi(buffer);
                        delete[] buffer;
                        return S_OK;
                        }
                    }
                }
            }
        }

    *output = NULL;

    delete[] buffer;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::ResetResults(void)
    {
    resultsLinePos = 0;

    for(size_t i=0; i<srvStats.m_size; i++)
        {
        if(srvStats.table[i])
            {
            for(HashEntry<ServerStats*> *h = srvStats.table[i]; h; h=h->next)
                {
                ServerStats *s = h->obj;
                delete s;
                h->obj = NULL;
                }
            delete srvStats.table[i];
            srvStats.table[i] = NULL;
            }
        }
	
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_cookieString(BSTR *pVal)
    {
    if(!pVal)
        {
        return E_INVALIDARG;
        }

    *pVal = CreateBstrFromAnsi(cookie);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_cookieString(BSTR newVal)
    {
    newVal = newVal; // just to stop the compiler from whining

    /*
    This function is obsolete since the cookie string will be overwritten 
    on the next call to POST or GET.
    */

    return E_NOTIMPL;

    /*
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;

    char *in = W2A(newVal);
    
    int followDomainRules = cookieJar->followDomainRules;
    if(cookieJar) delete cookieJar;
    cookieJar = new Cookie;
    cookieJar->followDomainRules = followDomainRules;
    cookieJar->Add(in, NULL);
    strcpy(cookie, in);
    httpHeader->AddHeader("Cookie", cookie);

    return S_OK;
    */
    }

STDMETHODIMP CSurgeEngine::SetReceiveTimeout(SHORT sec, SHORT msec)
    {
    client.SetRecvTimeout((UINT)sec, (UINT)msec);
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_randomSeed(long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (long)seed;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_randomSeed(long newVal)
    {
	seed = (unsigned) newVal;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_useServerBlacklist(VARIANT_BOOL *pVal)
    {
	if(!pVal) return E_INVALIDARG;

    *pVal = (VARIANT_BOOL)useServerBlacklist;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_useServerBlacklist(VARIANT_BOOL newVal)
    {
	useServerBlacklist = (BOOL)newVal;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::StartTimer(BSTR name)
    {
    USES_CONVERSION;
    if(!name) return E_INVALIDARG;

    char *aName = W2A(name);

    StressTimer *start;
    if(!timers) start = timers = new StressTimer(aName);
    else start = timers->Add(aName);

    if(start) start->Start();
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::StopTimer(BSTR name, long *ms)
    {
    USES_CONVERSION;
    if(!name || !ms) return E_INVALIDARG;

    *ms = 0;

    if(!timers) return S_OK;

    StressTimer *stop = timers->Find(W2A(name));
    if(stop)
        {
        *ms = (long)stop->Stop();
        }
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetTimer(BSTR name, long *ms)
    {
    USES_CONVERSION;
    if(!name || !ms) return E_INVALIDARG;

    *ms = 0;

    if(!timers) return S_OK;

    StressTimer *time = timers->Find(W2A(name));
    if(time)
        {
        *ms = (long)time->GetTime();
        }
    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetTimerAvg(BSTR name, long *ms)
    {
    USES_CONVERSION;
    if(!name || !ms) return E_INVALIDARG;

    *ms = 0;

    if(!timers) return S_OK;

    StressTimer *t = timers->Find(W2A(name));
    if(t && t->avg.dwCount)
        {
        *ms = (long)t->avg.dwSum/t->avg.dwCount;
        }

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetTimerCount(BSTR name, long *ms)
    {
    USES_CONVERSION;
    if(!name || !ms) return E_INVALIDARG;

    *ms = 0;

    if(!timers) return S_OK;

    StressTimer *t = timers->Find(W2A(name));
    if(t && t->avg.dwCount)
        {
        *ms = (long)t->avg.dwCount;
        }

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetTimerMax(BSTR name, long *ms)
    {
    USES_CONVERSION;
    if(!name || !ms) return E_INVALIDARG;

    *ms = 0;

    if(!timers) return S_OK;

    StressTimer *t = timers->Find(W2A(name));
    if(t && t->avg.dwCount)
        {
        *ms = (long)t->avg.dwMax;
        }

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetTimerMin(BSTR name, long *ms)
    {
    USES_CONVERSION;
    if(!name || !ms) return E_INVALIDARG;

    *ms = 0;

    if(!timers) return S_OK;

    StressTimer *t = timers->Find(W2A(name));
    if(t && t->avg.dwCount)
        {
        *ms = (long)t->avg.dwMin;
        }

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetLastError(long *pError)
    {
    if(!pError) return E_INVALIDARG;

    *pError = lastError;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_Cookies(BSTR name, /*[in, optional]*/ BSTR domain, BSTR *pVal)
    {
    USES_CONVERSION;
    if(!pVal) return E_INVALIDARG;
    if(!name || !cookieJar)
        {
        *pVal = CreateBstrFromAnsi("");
        return E_INVALIDARG;
        }

    char *aName = W2A(name);
    char *aDomain = W2A(domain);
    if(!*aDomain) aDomain = NULL;

    Cookie *c = cookieJar->Find(aName, aDomain);

    if(!c || !c->value)
        {
        *pVal = CreateBstrFromAnsi("");
        return S_OK;
        }

    *pVal = CreateBstrFromAnsi(c->value);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_Cookies(BSTR name, /*[in, optional]*/ BSTR domain, BSTR newVal)
    {
    USES_CONVERSION;
    if(!name) return E_INVALIDARG;

    char *aName = W2A(name);
    char *aValue = W2A(newVal);
    char *aDomain = W2A(domain);
    if(!*aDomain) aDomain = NULL;

    if(!cookieJar) cookieJar = new Cookie;
    if(!cookieJar) return E_OUTOFMEMORY;

    if(!newVal || aValue[0] == '\0')
        {
        cookieJar->Remove(aName, aDomain);
        }
    else
        {
        cookieJar->Add(aName, aValue, aDomain);
        }

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_cookiesSet(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (short)foundCookies;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_getFullPage(VARIANT_BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (VARIANT_BOOL)getFullPage;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_getFullPage(VARIANT_BOOL newVal)
    {
    getFullPage = (BOOL)newVal;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::GetCTime(long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = time(NULL);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::DNSLookup(BSTR address, BSTR *pVal)
    {
    USES_CONVERSION;
    if(!address || !pVal) return E_INVALIDARG;

    char output[1024];

    BOOL err = client.DNSLookup(W2A(address), output, 1024);

    if(err == FALSE)
        {
        *pVal = NULL;
        return S_OK;
        }

    *pVal = CreateBstrFromAnsi(output);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_cookieRules(long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = client.GetCookieRules();

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_cookieRules(long newVal)
    {
    client.SetCookieRules(newVal);

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::get_numRedirects(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = (short)numRedirects;

    return S_OK;
    }

STDMETHODIMP CSurgeEngine::put_numRedirects(short newVal)
    {
    if(newVal <= 0) numRedirects = 1;
    else numRedirects = newVal;

    return S_OK;
    }


// "ttfb = Time to First Byte"
// "ttlb = Time to Last Byte"
STDMETHODIMP CSurgeEngine::GetStats(BSTR strStatName, long *pVal)
    {
    // __asm int 3;
    USES_CONVERSION;
    if ((!strStatName) || (!pVal)) return E_INVALIDARG;

    char *aStatName = W2A(strStatName);
    
    if (lstrcmpi("ttfb", aStatName) == 0)
        {
        *pVal = client.GetTime(0);
        }
    else if (lstrcmpi("ttlb", aStatName) == 0)
        {
        *pVal = client.GetTime(1);
        }
    else
        {
        *pVal = 0;
        return E_INVALIDARG;
        }
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\browser.cpp ===
#include "stdafx.h"

#include "browser.h"

Browser::Browser()
{
    length = 0;
    for(int i=0; i<MAX_HEADERS; i++)
	{
        headers[i].header = NULL;
        headers[i].value = NULL;
	}
    versionLen = sprintf(version, "HTTP/1.0");
	
    char *surgeheader[] = 
	{
        "Accept",
		"User-Agent",
		"Connection",
		"Content-Length",
		"Content-Type",
		"Authorization",
		"Cookie"
	};
    char *surgevalues[] =
	{
        "*/*",
		"Surge (Default Browser)",
		"Close",
		NULL,
		NULL,
		NULL,
		NULL
	};
	
    length = sizeof(surgeheader)/sizeof(surgeheader[0]);
    for(i=0; i<length; i++)
	{
        headers[i].headerLen = strlen(surgeheader[i]) + 1;
        headers[i].header = new char[headers[i].headerLen];
        memcpy(headers[i].header, surgeheader[i], headers[i].headerLen);
        if(surgevalues[i])
		{
            headers[i].valueLen = strlen(surgevalues[i]) + 1;
            headers[i].value = new char[headers[i].valueLen];
            memcpy(headers[i].value, surgevalues[i], headers[i].valueLen);
		}
		else
		{
			headers[i].valueLen = 0;
		}
	}
}

Browser::Browser(char *filename)
{
    length = 0;
    for(int i=0; i<MAX_HEADERS; i++)
	{
        headers[i].header = NULL;
        headers[i].value = NULL;
		headers[i].headerLen = 0;
		headers[i].valueLen = 0;
		
	}
    versionLen = sprintf(version, "HTTP/1.0");
	
    char h[1024];
    char v[4096];
    char blank[1024];
    FILE *f = fopen(filename, "r");
    if(!f) 
	{
		return;
	}
	
    // get the version
    fscanf(f, "%s\n", version);
    versionLen = strlen(version);
	
    char string[4096];
	
    // get the rest of the header
    for(int line=0; line<MAX_HEADERS; line++)
	{
        h[0] = v[0] = '\0';
        if(!fgets(string, 2048, f)) 
		{
			break;
		}
        sscanf(string, "%[^:\0\r\n\t]%[: \t]%[^\0\r\n]\n", h, blank, v);
        if(h[0])
		{
            headers[line].headerLen = strlen(h) + 1;
            headers[line].header = new char[headers[line].headerLen];
            memcpy(headers[line].header, h, headers[line].headerLen);
            if(v[0])
			{
                headers[line].valueLen = strlen(v) + 1;
                headers[line].value = new char[headers[line].valueLen];
                memcpy(headers[line].value, v, headers[line].valueLen);
			}
		}
	}
	
    // size of the header
    length = line;
	
    fclose(f);
}

Browser::~Browser()
{
    for(int i=0; i<length; i++)
	{
        if(headers[i].header) 
		{
			delete[] headers[i].header;
		}
        if(headers[i].value) 
		{
			delete[] headers[i].value;
		}
	}
}

size_t Browser::EvalHeader(char *action, char *site, char *output)
{
    size_t offset=0;
    size_t l;
    l = sprintf(output, "%s %s %s\r\n", action, site, version);
    output += l;
    offset += l;
	
    for(int i=0; i<length; i++)
	{
        if(headers[i].value)
		{
            memcpy(output, headers[i].header, headers[i].headerLen-1);
            output += headers[i].headerLen-1;
            offset += headers[i].headerLen-1;
			
            output[0] = ':';
            output[1] = ' ';
            output += 2;
            offset += 2;
			
            memcpy(output, headers[i].value, headers[i].valueLen-1);
            output += headers[i].valueLen-1;
            offset += headers[i].valueLen-1;
			
            output[0] = '\r';
            output[1] = '\n';
            output[2] = '\0';
            output += 2;
            offset += 2;
		}
	}
	
    output[0] = '\r';
    output[1] = '\n';
    output[2] = '\0';
    offset += 2;
	
    return offset;
}

int Browser::Translate(char *h)
{
    for(int i=0; i<length; i++)
	{
        if(_stricmp(h, headers[i].header)==0)
		{
            return i;
		}
	}
	
    if(length==MAX_HEADERS) 
	{
		return -1;
	}
	
    headers[length].headerLen = strlen(h) + 1;
    headers[length].header = new char[headers[length].headerLen];
    strcpy(headers[length].header, h);
	
    return length++;
}

void Browser::AddHeader(char *h, char *v, size_t len/*=0*/)
{
    if(!h) return;
	
    int index = Translate(h);
    if(index == -1) return;
	
    if(!v)
	{
        if(headers[index].value) 
		{
			delete[] headers[index].value;
		}
        headers[index].value = NULL;
		headers[index].valueLen = 0;
        return;
	}
	
    if(!len) 
	{
		len = strlen(v);
	}
    ++len; // include terminating null char
    if(len <= 1) 
	{
		return;
	}
	
    if(len > headers[index].valueLen)
	{
        if(headers[index].value) 
		{
			delete[] headers[index].value;
		}
        headers[index].value = NULL;
	}
	
    headers[index].valueLen = len;
    if(!headers[index].value) 
	{
		headers[index].value = new char[len];
	}
	
    memcpy(headers[index].value, v, len);
}


///////////////////////////////////////////////////////////////////////////////
// Browser::IsHeaderSet
//
// Returns whether or not the header named in szHeaderName has already been
// set to some value.
///////////////////////////////////////////////////////////////////////////////
bool Browser::IsHeaderSet(char *szHeaderName)
{
    if(!szHeaderName) 
	{
		return false;
	}
	
    for(int index = 0; index < length; ++index)
    {
		if ( 0 == _stricmp(szHeaderName, headers[index].header) )
        {
			if ( 0 == headers[index].valueLen )
			{
				return false;
			}

			return true;
        }
    }

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\csurgeengine.h ===
// CSurgeEngine.h : Declaration of the CSurgeEngine

#ifndef __SURGEENGINE_H_
#define __SURGEENGINE_H_

#include "resource.h"       // main symbols
#include "reporting.h"
#include "stresstimer.h"
#include "../HttpClient/HttpClient.h"
#include "FastProfDB.h"
#include "digest.h"
#include "browser.h"
#include "../common/ParserTools.h"
#include "SurgeEngine.h"

#define MAXBUF 2048
#define BUFSIZE MAXBUF

/*
Logging Flags

ddhhhoooo

dd   bits 78    - dump raw or hex http communications
hhh  bits 654   - display http status message where http status >= hhh * 100d
oooo bits 3210  - error output location
*/
#define LOGGING_OUT_NONE        0x0000 // 0
#define LOGGING_OUT_FILE        0x0001 // 1
#define LOGGING_OUT_DEBUG       0x0002 // 2
#define LOGGING_OUT_MESSAGE     0x0004 // 4
#define LOGGING_HTTPALL         0x0000 // 0
#define LOGGING_HTTP100         0x0010 // 16
#define LOGGING_HTTP200         0x0020 // 32
#define LOGGING_HTTP300         0x0030 // 48
#define LOGGING_HTTP400         0x0040 // 64
#define LOGGING_HTTP500         0x0050 // 80
#define LOGGING_HTTPNONE        0x0070 // 112
#define LOGGING_HTTPMASK        0x0070 // 112
#define LOGGING_HTTPDUMPHEX     0x0080 // 128
#define LOGGING_HTTPDUMPRAW     0x0100 // 256
#define LOGGING_ALL             0xFFFF
#define LOGGING_CLEAN           LOGGING_OUT_NONE | LOGGING_HTTPNONE

class ServerStats
    {
    public:
        DWORD dwStatus;
        DWORD dwCount;
        Average avgConnect;
        Average avgTransaction;
        Average avgBytesSent;
        Average avgBytesReceived;

        // Blacklist state members (only used on the head of the list)
        DWORD dwInternalState;
        DWORD dwRetryCountdown;

    public:
        ServerStats *next;

    public:
        ServerStats();
        ~ServerStats();
    };

/////////////////////////////////////////////////////////////////////////////
// CSurgeEngine
class ATL_NO_VTABLE CSurgeEngine : public CComObjectRootEx<CComSingleThreadModel>, public CComCoClass<CSurgeEngine, &CLSID_SurgeEngine>, public IDispatchImpl<ISurgeEngine, &IID_ISurgeEngine, &LIBID_SURGEENGINELib>
    {
    private:
        HINSTANCE hSecuritydll;

        // network items
        WORD port;
        DWORD sslProtocol;
        Cookie *cookieJar;
        char cookie[4096];
        char server[MAXBUF];
        char site[MAXBUF];
        BOOL ssl;
        CHttpClient client;
        Browser *httpHeader;
        int foundCookies;
        BOOL useHead;
        BOOL followRedirects;
        BOOL getFullPage;
        int numRedirects;
		BOOL m_fIsHostHeaderOverridden;

        // stats
        HashTable<ServerStats*, 13> srvStats;
        unsigned resultsLinePos;
        int httpStatus;
        long lastError;

        // settings
        unsigned seed;
        BOOL useServerBlacklist;

        // user stuff
        FastProfDB *userdb;

        // logging
        long loggingFlags;
        HWND messageWindow;
        StressTimer *timers;

        // optimizations

	private:
		void Init();
		void Shutdown();

    public:
	    CSurgeEngine();
        ~CSurgeEngine();

    public:
        long ConnectBatch(const char *server, BOOL ssl, DWORD &latency);
        long SendReceiveBatch(DWORD &latency, char *server);
        long GetPage(char *url, char *postdata=NULL);

        void ReportError(long error, char* lpszFormat, ...);
        void ReportDump(const char *title, int isRaw, const char * buffer, DWORD length);
        ServerStats* InsertResult(ServerStats *base, char *key, long status, DWORD clat = (DWORD)~0, DWORD tlat = (DWORD)~0, DWORD bytesSent =(DWORD)0, DWORD bytesReceived = (DWORD)0);

    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_SURGEENGINE)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CSurgeEngine)
	        COM_INTERFACE_ENTRY(ISurgeEngine)
	        COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()

    // ISurgeEngine
    public:
	    STDMETHOD(GetStats)(BSTR strStatName, /*[out, retval]*/ long *pVal);
	    STDMETHOD(GetResultsHeader)(/*[out, retval]*/ BSTR *output);
	    STDMETHOD(GetResultsLine)(/*[out, retval]*/ BSTR *output);
	    STDMETHOD(get_numRedirects)(/*[out, retval]*/ short *pVal);
	    STDMETHOD(put_numRedirects)(/*[in]*/ short newVal);
	    STDMETHOD(get_cookieRules)(/*[out, retval]*/ long *pVal);
	    STDMETHOD(put_cookieRules)(/*[in]*/ long newVal);
	    STDMETHOD(GetTimerMin)(/*[in]*/ BSTR name, /*[out, retval]*/ long *ms);
	    STDMETHOD(GetTimerMax)(/*[in]*/ BSTR name, /*[out, retval]*/ long *ms);
	    STDMETHOD(GetTimerCount)(/*[in]*/ BSTR name, /*[out, retval]*/ long *ms);
	    STDMETHOD(GetTimer)(/*[in]*/ BSTR name, /*[out, retval]*/ long *ms);
	    STDMETHOD(DNSLookup)(/*[in]*/ BSTR address, /*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(GetCTime)(/*[out, retval]*/ long *pVal);
	    STDMETHOD(About)();
	    STDMETHOD(AddHeader)(BSTR header, BSTR value);
	    STDMETHOD(DigestHash)(BSTR algo, BSTR user, BSTR realm, BSTR password, BSTR nonce, BSTR noncecount, BSTR cnonce, BSTR qop, BSTR method, BSTR uri, BSTR entity, /*[out]*/ BSTR *hash);
	    STDMETHOD(GenerateRandom)(short maxLength, short contents, /*[out, retval]*/ BSTR *random);
	    STDMETHOD(GET)(BSTR url);
	    STDMETHOD(get_Cookies)(BSTR name, /*[in, optional]*/ BSTR domain, /*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(get_cookiesSet)(/*[out, retval]*/ short *pVal);
	    STDMETHOD(get_cookieString)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(get_followRedirects)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	    STDMETHOD(get_getFullPage)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	    STDMETHOD(get_httpStatus)(/*[out, retval]*/ short *pVal);
	    STDMETHOD(get_loggingFlags)(/*[out, retval]*/ long *pVal);
	    STDMETHOD(get_messageWindow)(/*[out, retval]*/ long *pVal);
	    STDMETHOD(get_randomSeed)(/*[out, retval]*/ long *pVal);
	    STDMETHOD(get_sslProtocol)(/*[out, retval]*/ long *pVal);
	    STDMETHOD(get_tcpPort)(/*[out, retval]*/ short *pVal);
	    STDMETHOD(get_useHead)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	    STDMETHOD(get_useServerBlacklist)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	    STDMETHOD(GetBody)(/*[out, retval]*/ BSTR *body);
	    STDMETHOD(GetHeader)(/*[out, retval]*/ BSTR *header);
	    STDMETHOD(GetLastError)(/*[out, retval]*/ long *pError);
	    STDMETHOD(GetResults)(/*[out, retval]*/ BSTR *output);
	    STDMETHOD(GetResultsFor)(BSTR key, /*[out, retval]*/ BSTR *output);
	    STDMETHOD(GetTimerAvg)(BSTR name, /*[out, retval]*/ long *ms);
	    STDMETHOD(GetUser)(/*[in]*/ VARIANT_BOOL sequential, /*[out]*/ BSTR *username, /*[out]*/ BSTR *domain, /*[out]*/ BSTR *password);
	    STDMETHOD(Log)(long dwData, BSTR message);
	    STDMETHOD(MD5Hash)(BSTR input, /*[out, retval]*/ BSTR *hash);
	    STDMETHOD(POST)(BSTR url, BSTR data);
	    STDMETHOD(POSTEncode)(BSTR post, /*[out, retval]*/ BSTR *encoded);
	    STDMETHOD(put_browser)(/*[in]*/ BSTR newVal);
	    STDMETHOD(put_Cookies)(BSTR name, /*[in, optional]*/ BSTR domain, /*[in]*/ BSTR newVal);
	    STDMETHOD(put_cookieString)(/*[in]*/ BSTR newVal);
	    STDMETHOD(put_followRedirects)(/*[in]*/ VARIANT_BOOL newVal);
	    STDMETHOD(put_getFullPage)(/*[in]*/ VARIANT_BOOL newVal);
	    STDMETHOD(put_loggingFlags)(/*[in]*/ long newVal);
	    STDMETHOD(put_messageWindow)(/*[in]*/ long newVal);
	    STDMETHOD(put_randomSeed)(/*[in]*/ long newVal);
	    STDMETHOD(put_sslProtocol)(/*[in]*/ long newVal);
	    STDMETHOD(put_tcpPort)(/*[in]*/ short newVal);
	    STDMETHOD(put_useHead)(/*[in]*/ VARIANT_BOOL newVal);
	    STDMETHOD(put_usersFile)(/*[in]*/ BSTR newVal);
	    STDMETHOD(put_useServerBlacklist)(/*[in]*/ VARIANT_BOOL newVal);
	    STDMETHOD(ResetResults)(void);
	    STDMETHOD(SetReceiveTimeout)(short sec, short msec);
	    STDMETHOD(StartTimer)(BSTR name);
	    STDMETHOD(StopTimer)(BSTR name, /*[out, retval]*/ long *ms);
	    STDMETHOD(URLEncode)(BSTR url, /*[out, retval]*/ BSTR *encoded);
	    STDMETHOD(URLDecode)(/*[in]*/ BSTR url, /*[out, retval]*/ BSTR *decoded);
		STDMETHOD(Reset)();
    };

#endif //__SURGEENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\fastprofdb.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    FastProfDB.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/

#ifndef _FASTPROFDB_H_
#define _FASTPROFDB_H_

#include <io.h>

#define _FASTPROFDB

enum
    {
    PROFDB_USERNAME,
    PROFDB_DOMAIN,
    PROFDB_PASSWORD
    };

/*++

Class Description:

    FastProfDB

Methods:



Data:



NOTE: 
    

--*/
class FastProfDB
    {
    private:
        FILE *f;
        unsigned long len;
        char buff[1024];
        LARGE_INTEGER liPerf;

    public:
        FastProfDB(char *filename);
        ~FastProfDB();

        void GetNamePW(char *dbline, char *username, char *domain, char *pw, int size);

    public:
        char* GetRandUser(void);
        char* GetNextUser(void);
    };

#endif // _FASTPROFDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\digest.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        CDigestAuth.h

    Abstract:

        This class performs digest authentication MD5 calculations.

    Author:

        Darren L. Anderson (darrenan) 5-Aug-1998

    Revision History:

        5-Aug-1998 darrenan

            Created.

--*/

#ifndef __DIGESTAUTH_H
#define __DIGESTAUTH_H

#define DIGESTBUF_LEN  33

enum DIGEST_AUTH_NAMES
{
    DIGEST_AUTH_USERNAME=0,
    DIGEST_AUTH_REALM,
    DIGEST_AUTH_NONCE,
    DIGEST_AUTH_URI,
    DIGEST_AUTH_RESPONSE,
    DIGEST_AUTH_DIGEST,
    DIGEST_AUTH_ALGORITHM,
    DIGEST_AUTH_OPAQUE,
    DIGEST_AUTH_CNONCE,
    DIGEST_AUTH_QOP,
    DIGEST_AUTH_NC,
    DIGEST_AUTH_LAST
};

#ifdef __cplusplus
extern "C" {
#endif

VOID WINAPI
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    );
    
HRESULT WINAPI
DigestFromCreds(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszUsername,
    IN  LPCSTR  pszRealm,
    IN  LPCSTR  pszPassword,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszSessionKey,
    OUT LPSTR   pszResult
    );

HRESULT WINAPI
DigestFromKey(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszSessionKey,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszResult
    );

HRESULT WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

HRESULT WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst
    );

BOOL
ParseAuthorizationHeader(
    LPSTR pszHeader, 
    LPSTR pValueTable[DIGEST_AUTH_LAST]
    );

#ifdef __cplusplus
}
#endif

#endif // __DIGESTAUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\fastprofdb.cpp ===
#include "stdafx.h"
#include "FastProfdb.h"

FastProfDB::FastProfDB(char *filename)
    {
    f = fopen(filename, "r");
    if(f) len = _filelength(_fileno(f));
    else len = 1;
    if(!len) len = 1;
    }

FastProfDB::~FastProfDB()
    {
    if(!f) return;
    fclose(f);
    }

char* FastProfDB::GetRandUser(void)
    {
    if(!f) return NULL;
    QueryPerformanceCounter(&liPerf);

    DWORD dwNewLowPart =  liPerf.LowPart & 0xFF000000;
    dwNewLowPart =  dwNewLowPart | ( (liPerf.LowPart & 0x00FF0000) >> 16);
    dwNewLowPart =  dwNewLowPart | ( (liPerf.LowPart & 0x0000FF00) << 8 );
    dwNewLowPart =  dwNewLowPart | ( (liPerf.LowPart & 0x000000FF) << 8);

    fseek(f, dwNewLowPart%len, SEEK_SET);

    fgets(buff, 1024, f);
    if(fgets(buff, 1024, f) == NULL)
        {
        fseek(f, 0, SEEK_SET);
        fgets(buff, 1024, f);
        }
    return buff;
    }

char* FastProfDB::GetNextUser(void)
    {
    if(!f) return NULL;
    if(fgets(buff, 1024, f) == NULL)
        {
        fseek(f, 0, SEEK_SET);
        fgets(buff, 1024, f);
        }
    return buff;
    }

// Parse out the username and password from a profDB line 
void FastProfDB::GetNamePW(char *dbline, char *username, char *domain, char *pw, int size)
    {
    if(!dbline)
        {
        strcpy(username, "jpoley");
        strcpy(domain, "moonport.com");
        strcpy(pw, "jpoley");
        return;
        }

    int i, j;

    // grab username
    for(i=0; i<size; i++)
        {
        if((username[i] = dbline[i]) == '@')
            {
            username[i] = '\0';
            break;
            }
        else if(username[i] == '|')
            {
            username[i] = '\0';
            break;
            }
        }

    ++i;
    // grab domain
    for(j=0; j<size; j++, i++)
        {
        if((domain[j] = dbline[i]) == '|')
            {
            domain[j] = '\0';
            break;
            }
        }

    // skip a column
    while(dbline[++i] != '|')
        {
        if(i > size*2)
            {
            strcpy(pw, "profDBerror");
            return;
            }
        }

    ++i;
    // grab password
    for(j=0; j<size; j++, i++)
        {
        if((pw[j] = dbline[i]) == '|')
            {
            pw[j] = '\0';
            break;
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\digest.cpp ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        DigestAuth.cpp

    Abstract:

        Performs digest authentication MD5 calculations.
        MD5.cpp is an external dependency.

    Author:

        Darren L. Anderson (darrenan) 5-Aug-1998

    Revision History:

        5-Aug-1998 darrenan

            Created.

--*/
#include "stdafx.h"
#include "md5.h"
#include "digest.h"


typedef enum { ALGO_MD5, ALGO_MD5_SESS } DIGEST_ALGORITHM;
typedef enum { QOP_NONE, QOP_AUTH, QOP_AUTH_INT } DIGEST_QOP;

static DIGEST_ALGORITHM WINAPI
AlgorithmFromString(
    LPCSTR  pszAlgorithm
    )
{
    DIGEST_ALGORITHM Algorithm;

    if(pszAlgorithm == NULL)
        Algorithm = ALGO_MD5;
    else if(_stricmp("MD5-sess", pszAlgorithm) == 0)
        Algorithm = ALGO_MD5_SESS;
    else if(_stricmp("MD5", pszAlgorithm) == 0)
        Algorithm = ALGO_MD5;
    else
        Algorithm = ALGO_MD5;

    return Algorithm;
}

static DIGEST_QOP WINAPI
QopFromString(
    LPCSTR  pszQOP
    )
{
    DIGEST_QOP  Qop;

    if(pszQOP == NULL)
        Qop = QOP_NONE;
    else if(strcmp("auth", pszQOP) == 0)
        Qop = QOP_AUTH;
    else if(strcmp("auth-int", pszQOP) == 0)
        Qop = QOP_AUTH_INT;
    else
        Qop = QOP_NONE;

    return Qop;
}

VOID WINAPI
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )

/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/

{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = (char)TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = (char)TOHEX( v );
    }
    pDst[y] = '\0';
}


HRESULT WINAPI
DigestFromCreds(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszUsername,
    IN  LPCSTR  pszRealm,
    IN  LPCSTR  pszPassword,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszSessionKey,
    OUT LPSTR   pszResult
    )

/*++

Routine Description:

    DigestFromCreds         Produces a hexadecimally encoded string containing the
                            Digest response given the arguments below.

Arguments:

    pszAlgorithm            The algorithm being used to calculate the response.
                            If NULL or "", assume "MD5".  Possible values are
                            "MD5" and "MD5-Sess".

    pszUsername             Member's passport ID.

    pszRealm                Realm, should be constant.
    
    pszPassword             Member's password.

    pszNonce                Nonce.    
    
    pszNonceCount           The Nonce Count.  MUST be NULL if pszQOP is NULL or "".
                            Otherwise, Nonce Count is REQUIRED.

    pszCNonce               The Client nonce.  May be NULL or "".
    
    pszQOP                  The Quality of Privacy.  May be NULL, "", "auth" or 
                            "auth-int".  If it's NULL or "" then RFC 2069 style
                            digest is being performed.

    pszMethod               HTTP method used in the request.  REQUIRED.

    pszURI                  Resource being requested.  REQUIRED.

    pszEntityDigest         Entity Digest.  May be NULL if qop="auth" or nothing.
                            REQUIRED if qop="auth-int".

    pszSessionKey           Session key returned to caller.  Session key is MD5(A1).

    pszResult               Destination buffer for result.  Should point to a buffer
                            of at least MIN_OUTPUT_BUF_LEN characters.
    
Return Value:

    S_OK                    Call was successful.


--*/

{
    HRESULT             hr;
    DIGEST_ALGORITHM    Algorithm;
    DIGEST_QOP          Qop;
    CHAR                achWork     [32768];
    UCHAR               achDigest   [ 16];
    CHAR                achHashOfA1 [DIGESTBUF_LEN];

    if(!pszUsername) pszUsername = "";
    if(!pszRealm) pszRealm = "";
    if(!pszPassword) pszPassword = "";
    if(!pszNonce) pszNonce = "";
    if(!pszCNonce) pszCNonce = "";
    if(!pszAlgorithm) pszAlgorithm = "";
    if(!pszNonceCount) pszNonceCount = "";
    if(!pszQOP) pszQOP = "";
    if(!pszMethod) pszMethod = "";
    if(!pszURI) pszURI = "";
    if(!pszEntityDigest) pszEntityDigest = "";

    //
    //  Detect the algorithm and QOP.
    //
    Algorithm = AlgorithmFromString(pszAlgorithm);
    Qop       = QopFromString(pszQOP);

    //  Compute the digest.

    //
    //  Build A1.
    //  For MD5 this is username@domain:realm:password
    //  For MD5-Sess this is MD5(username@domain:realm:password):nonce:cnonce
    //
    strcpy(achWork, pszUsername);
    strcat(achWork, ":");
    strcat(achWork, pszRealm);
    strcat(achWork, ":");
    strcat(achWork, pszPassword);

    if(Algorithm == ALGO_MD5_SESS)
    {
        //  Hash it.
        MD5((UCHAR*)achWork, strlen(achWork), achDigest);
        ToHex(achDigest, 16, achHashOfA1);

        strcpy(achWork, achHashOfA1);
        strcat(achWork, ":");
        strcat(achWork, pszNonce);
        strcat(achWork, ":");
        strcat(achWork, pszCNonce);
    }

    //  Hash it.
    MD5((UCHAR*)achWork, strlen(achWork), achDigest);
    ToHex(achDigest, 16, achHashOfA1);
    
    hr = DigestFromKey(
                pszAlgorithm,
                achHashOfA1,
                pszNonce,
                pszNonceCount,
                pszCNonce,
                pszQOP,
                pszMethod,
                pszURI,
                pszEntityDigest,
                pszResult
                );

    if(hr != S_OK)
        goto Cleanup;

    strcpy(pszSessionKey, achHashOfA1);

Cleanup:
    return hr;
}


HRESULT WINAPI
DigestFromKey(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszSessionKey,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszResult
    )

/*++

Routine Description:

    DigestFromCreds         Produces a hexadecimally encoded string containing the
                            Digest response given the arguments below.

Arguments:

    pszAlgorithm            The algorithm being used to calculate the response.
                            If NULL or "", assume "MD5".  Possible values are
                            "MD5" and "MD5-Sess".

    pszSessionKey           Pre-computed MD5(A1).

    pszNonce                Nonce.    
    
    pszNonceCount           The Nonce Count.  MUST be NULL if pszQOP is NULL or "".
                            Otherwise, Nonce Count is REQUIRED.

    pszCNonce               The Client nonce.  May be NULL or "".
    
    pszQOP                  The Quality of Privacy.  May be NULL, "", "auth" or 
                            "auth-int".  If it's NULL or "" then RFC 2069 style
                            digest is being performed.

    pszMethod               HTTP method used in the request.  REQUIRED.

    pszURI                  Resource being requested.  REQUIRED.

    pszEntityDigest         Entity Digest.  May be NULL if qop="auth" or nothing.
                            REQUIRED if qop="auth-int".

    pszResult               Destination buffer for result.  Should point to a buffer
                            of at least MIN_OUTPUT_BUF_LEN characters.
    
Return Value:

    S_OK                    Call was successful.
    E_POINTER               A required parameter was NULL.

--*/

{
    HRESULT             hr;
    DIGEST_ALGORITHM    Algorithm;
    DIGEST_QOP          Qop;
    CHAR                achWork     [32768];
    UCHAR               achDigest   [ 16];
    CHAR                achHashOut  [ 36];

    //
    //  Detect the algorithm and QOP.
    //

    Algorithm = AlgorithmFromString(pszAlgorithm);
    Qop       = QopFromString(pszQOP);

    //  Compute the digest.

    //
    //  Build A2
    //  For qop="auth" this is method:uri
    //  For qop="auth-int" this is method:uri:entitydigest
    //

    strcpy(achWork, pszMethod);
    strcat(achWork, ":");
    strcat(achWork, pszURI);

    if(Qop == QOP_AUTH_INT)
    {
        strcat(achWork, ":");
        strcat(achWork, pszEntityDigest);
    }

    //  Hash it.
    MD5((UCHAR*)achWork, strlen(achWork), achDigest);
    ToHex(achDigest, 16, achHashOut);

    //
    //  Compute final chunk.
    //  For qop="" this is MD5(key:nonce:MD5(A2))
    //  For qop="auth" or qop="auth-int" this is 
    //      MD5(key:nonce:nc:cnonce:qop:MD5(A2))
    //

    strcpy(achWork, pszSessionKey);
    strcat(achWork, ":");
    strcat(achWork, pszNonce);
    strcat(achWork, ":");

    if(Qop != QOP_NONE)
    {
        strcat(achWork, pszNonceCount);
        strcat(achWork, ":");
        strcat(achWork, pszCNonce);
        strcat(achWork, ":");
        strcat(achWork, pszQOP);
        strcat(achWork, ":");
    }
     
    strcat(achWork, achHashOut);
    
    //  Hash it.
    MD5((UCHAR*)achWork, strlen(achWork), achDigest);
    ToHex(achDigest, 16, pszResult);

    hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\logdefines.h ===
/*
Logging Flags

ddhhhoooo

dd   bits 78    - dump raw or hex http communications
hhh  bits 654   - display http status message where http status >= hhh * 100d
oooo bits 3210  - error output location
*/
#define LOGGING_OUT_NONE        0x0000 // 0
#define LOGGING_OUT_FILE        0x0001 // 1
#define LOGGING_OUT_DEBUG       0x0002 // 2
#define LOGGING_OUT_MESSAGE     0x0004 // 4
#define LOGGING_HTTPALL         0x0000 // 0
#define LOGGING_HTTP100         0x0010 // 16
#define LOGGING_HTTP200         0x0020 // 32
#define LOGGING_HTTP300         0x0030 // 48
#define LOGGING_HTTP400         0x0040 // 64
#define LOGGING_HTTP500         0x0050 // 80
#define LOGGING_HTTPNONE        0x0070 // 112
#define LOGGING_HTTPMASK        0x0070 // 112
#define LOGGING_HTTPDUMPHEX     0x0080 // 128
#define LOGGING_HTTPDUMPRAW     0x0100 // 256
#define LOGGING_ALL             0xFFFF
#define LOGGING_CLEAN           LOGGING_OUT_NONE | LOGGING_HTTPNONE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\md5.h ===
/* MD5.H - header file for MD5C.C
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#ifndef __MD5_H
#define __MD5_H

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* MD5 context. */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
  unsigned char digest[16];
} MD5_CTX;

static void MD5Init (MD5_CTX *);
static void MD5Update (MD5_CTX *, unsigned char *, unsigned int);
static void MD5Final (MD5_CTX *);

LONG MD5(UCHAR*, UINT, UCHAR*);

#endif // __MD5_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SurgeEngine.rc
//
#define IDS_PROJNAME                    100
#define IDR_SURGEENGINE                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\md5.cpp ===
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#include "stdafx.h"
#include "digest.h"
#include "md5.h"

/* Constants for MD5Transform routine.
 */

#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform (UINT4 [4], unsigned char [64]);
static void Encode (unsigned char *, UINT4 *, unsigned int);
static void Decode (UINT4 *, unsigned char *, unsigned int);

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
static void MD5Init (MD5_CTX *context)
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
static void MD5Update (MD5_CTX *context, unsigned char *input, unsigned int inputLen)
{
    unsigned int i, index, partLen;

    /* Compute number of bytes mod 64 */
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    /* Update number of bits */
    if ((context->count[0] += ((UINT4)inputLen << 3)) < ((UINT4)inputLen << 3))
        context->count[1]++;

    context->count[1] += ((UINT4)inputLen >> 29);

    partLen = 64 - index;

    /* Transform as many times as possible.
    */
    if (inputLen >= partLen) {
        memcpy((POINTER)&context->buffer[index], (POINTER)input, partLen);
        MD5Transform (context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
            MD5Transform (context->state, &input[i]);

        index = 0;
    }
    else
        i = 0;

    /* Buffer remaining input */
    memcpy((POINTER)&context->buffer[index], (POINTER)&input[i], inputLen-i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
static void MD5Final (MD5_CTX *context)
{
    unsigned char bits[8];
    unsigned int index, padLen;

    /* Save number of bits */
    Encode (bits, context->count, 8);

    /* Pad out to 56 mod 64. */
    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD5Update (context, PADDING, padLen);

    /* Append length (before padding) */
    MD5Update (context, bits, 8);
    /* Store state in digest */
    Encode (context->digest, context->state, 16);
}

/* MD5 basic transformation. Transforms state based on block. */
static void MD5Transform (UINT4 *state, unsigned char *block)
{
    UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

    Decode (x, block, 64);

    /* Round 1 */
    FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
    FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
    FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
    FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
    FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
    FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
    FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
    FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
    FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
    FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
    FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
    FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
    FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
    FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
    FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
    FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

    /* Round 2 */
    GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
    GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
    GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
    GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
    GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
    GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
    GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
    GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
    GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
    GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
    GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
    GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

    /* Round 3 */
    HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
    HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
    HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
    HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
    HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
    HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
    HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
    HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
    HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
    HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
    HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

    /* Round 4 */
    II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
    II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
    II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
    II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
    II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
    II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
    II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
    II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
    II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
    II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
    II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
    II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
    II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
    II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
    II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
    II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;

    /* Zeroize sensitive information. */
    memset ((POINTER)x, 0, sizeof (x));
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (unsigned char *output, UINT4 *input, unsigned int len)
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) 
    {
        output[j]   = (unsigned char)(input[i] & 0xff);
        output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

/* Decodes input (unsigned char) into output (UINT4). Assumes len is
  a multiple of 4.
 */
static void Decode (UINT4 *output, unsigned char *input, unsigned int len)
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
        output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
                    (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
}

LONG MD5(UCHAR* pBuf, UINT nBuf, UCHAR* digest)
{
    MD5_CTX context;

    if(pBuf==NULL || IsBadReadPtr((CONST VOID*)pBuf, (UINT)nBuf))
    {
        return ERROR_INVALID_PARAMETER;
    }

    MD5Init (&context);
    MD5Update (&context, pBuf, nBuf);
    MD5Final (&context);

    memcpy(digest, context.digest, 16);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__12310FD2_2279_11D3_944E_00C04F7986A3__INCLUDED_)
#define AFX_STDAFX_H__12310FD2_2279_11D3_944E_00C04F7986A3__INCLUDED_

// disable unicode
#undef UNICODE
#undef _UNICODE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <stdio.h>
#include <windows.h>
#include <winsock2.h>
#include <time.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#ifdef _DEBUG
    #include <crtdbg.h>
#endif

#define CLIENTNAME_LEN (MAX_COMPUTERNAME_LENGTH + 1)
extern void _cdecl Trace(LPCTSTR lpszFormat, ...);
extern void AddWindowText(HWND window, char *text);
extern char* GetToken(char *str, char **tokenStart, size_t *tokenLen, char **nextToken);
extern char* MD5Hash(char *inSource, char *outStr);


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__12310FD2_2279_11D3_944E_00C04F7986A3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\stresstimer.h ===
#ifndef _STRESSTIMER_H_
#define _STRESSTIMER_H_

#include "reporting.h"

class StressTimer
    {
    #define STRESS_TIMER_NAME_LEN 1024
    public:
        char name[STRESS_TIMER_NAME_LEN];
        DWORD dwTime;
        StressTimer *next;
        Average avg;

    public:
        StressTimer* Add(char *n);
        StressTimer* Find(char *n);

    public:
        StressTimer();
        StressTimer(char *n);
        ~StressTimer();

    public:
        DWORD Start(void);
        DWORD Stop(void);
        DWORD GetTime(void);
    };

#endif // _STRESSTIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\surgeengine.cpp ===
// SurgeEngine.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SurgeEngineps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SurgeEngine.h"
#include "md5.h"

#include "SurgeEngine_i.c"
#include "CSurgeEngine.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SurgeEngine, CSurgeEngine)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
    {
    if (dwReason == DLL_PROCESS_ATTACH)
        {
        _Module.Init(ObjectMap, hInstance, &LIBID_SURGEENGINELib);
        DisableThreadLibraryCalls(hInstance);
        }
    else if (dwReason == DLL_PROCESS_DETACH)
        {
        _Module.Term();
        }
    return TRUE;    // ok
    }

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
    {
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
    return _Module.GetClassObject(rclsid, riid, ppv);
    }

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
    {
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
    }

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
    {
    return _Module.UnregisterServer(TRUE);
    }

/////////////////////////////////////////////////////////////////////////////
// main
int __cdecl main(int, char **)
    {
    DllRegisterServer();
    return 0;
    }


/*++

Routine Description:

    GetToken
    returns the location of the first and second tokens and the length of the first token
    
Arguments:

    char *str           - [in] string buffer
    char **tokenStart   - [out] start of the first token
    size_t *tokenLen    - [out] length of the first token
    char **nextToken    - [out] start of the next token

Return Value:

    char * - same as tokenStart

Notes:

    Example:
        GetToken("\t    abc  def ghij", &tokenStart, &tokenLen, &nextToken);

        printf(tokenStart) -> "abc  def ghij"
        printf(nextToken)  -> "def ghij"
        tokenLen == 3

--*/
char* GetToken(char *str, char **tokenStart, size_t *tokenLen, char **nextToken)
    {
    size_t leadingBlank = strspn(str, " \t\n");
    str += leadingBlank;
    size_t len = strcspn(str, " \t\n");
    size_t trailingBlank = strspn(str + len, " \t\n");

    *tokenStart = str;
    *tokenLen = len;
    *nextToken = str+len+trailingBlank;

    return str;
    }

char* MD5Hash(char *inSource, char *outStr)
    {
    long lResult;
    unsigned char achDigest[20];
    
    lResult = MD5((unsigned char*)inSource, strlen(inSource), (unsigned char*)achDigest);
    if(lResult != ERROR_SUCCESS)
        {
        return NULL;
        }

    ToHex(achDigest, 16, outStr);

    return outStr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\reporting.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    Reporting.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/
#ifndef _REPORTING_H_
#define _REPORTING_H_

// filename for extra error reporting
#define SURGE_ERROR_FILENAME "SURGEerrors.txt"

extern char* ErrorNo(int errorClass, long error);

/*++

Class Description:

    Average

Methods:



Data:



NOTE: 
    


--*/
class Average
    {
    public:
        DWORD dwSum;
        DWORD dwCount;
        DWORD dwMin;
        DWORD dwMax;

    public:
        Average() { dwSum = dwMax = dwCount = 0L; dwMin = (DWORD)~0L; }
        void Insert(DWORD value) { dwSum += value; ++dwCount; if(value<dwMin) dwMin=value; if(value>dwMax) dwMax=value; }
        void Insert(Average &a) { dwSum += a.dwSum; dwCount += a.dwCount; if(a.dwMin<dwMin) dwMin=a.dwMin; if(a.dwMax>dwMax) dwMax=a.dwMax; }
        DWORD Eval(void) { if(!dwCount) return 0; return dwSum / dwCount; }
        void Reset(void) { dwSum = dwMax = dwCount = 0L; dwMin = (DWORD)~0L; }
        void Remove(DWORD value) { dwSum -= value; --dwCount; }
        void Remove(Average &a) { dwSum -= a.dwSum; dwCount -= a.dwCount; }
        void Set(Average &a) { dwSum = a.dwSum; dwCount = a.dwCount; dwMin = a.dwMin; dwMax = a.dwMax; }
    };


struct ErrorDescription
    {
    long dwError;
    char *name;
    char *description;
    };

enum _ERRORCLASSES
    {
    ERRCLASS_SOCK = 1,
    ERRCLASS_HTTP = 2,
    ERRCLASS_SURGE = 3
    };

enum _SURGE_ERRORS
    {
    SURGE_NOCOOKIE = 1,
    SURGE_UX_LOGON,
    SURGE_UX_LOGOFF,
    SURGE_UX_NAV,
    SURGE_UX_PROFILE,
    SURGE_UX_PASSWORD,
    SURGE_UX_REGISTER,
    SURGE_UX_UNREGISTER
    };

// cut from wininet.h
#define HTTP_STATUS_CONTINUE            100 // OK to continue with request
#define HTTP_STATUS_SWITCH_PROTOCOLS    101 // server has switched protocols in upgrade header

#define HTTP_STATUS_OK                  200 // request completed
#define HTTP_STATUS_CREATED             201 // object created, reason = new URI
#define HTTP_STATUS_ACCEPTED            202 // async completion (TBS)
#define HTTP_STATUS_PARTIAL             203 // partial completion
#define HTTP_STATUS_NO_CONTENT          204 // no info to return
#define HTTP_STATUS_RESET_CONTENT       205 // request completed, but clear form
#define HTTP_STATUS_PARTIAL_CONTENT     206 // partial GET furfilled

#define HTTP_STATUS_AMBIGUOUS           300 // server couldn't decide what to return
#define HTTP_STATUS_MOVED               301 // object permanently moved
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_STATUS_REDIRECT_METHOD     303 // redirection w/ new access method
#define HTTP_STATUS_NOT_MODIFIED        304 // if-modified-since was not modified
#define HTTP_STATUS_USE_PROXY           305 // redirection to proxy, location header specifies proxy to use
#define HTTP_STATUS_REDIRECT_KEEP_VERB  307 // HTTP/1.1: keep same verb

#define HTTP_STATUS_BAD_REQUEST         400 // invalid syntax
#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_PAYMENT_REQ         402 // payment required
#define HTTP_STATUS_FORBIDDEN           403 // request forbidden
#define HTTP_STATUS_NOT_FOUND           404 // object not found
#define HTTP_STATUS_BAD_METHOD          405 // method is not allowed
#define HTTP_STATUS_NONE_ACCEPTABLE     406 // no response acceptable to client found
#define HTTP_STATUS_PROXY_AUTH_REQ      407 // proxy authentication required
#define HTTP_STATUS_REQUEST_TIMEOUT     408 // server timed out waiting for request
#define HTTP_STATUS_CONFLICT            409 // user should resubmit with more info
#define HTTP_STATUS_GONE                410 // the resource is no longer available
#define HTTP_STATUS_LENGTH_REQUIRED     411 // the server refused to accept request w/o a length
#define HTTP_STATUS_PRECOND_FAILED      412 // precondition given in request failed
#define HTTP_STATUS_REQUEST_TOO_LARGE   413 // request entity was too large
#define HTTP_STATUS_URI_TOO_LONG        414 // request URI too long
#define HTTP_STATUS_UNSUPPORTED_MEDIA   415 // unsupported media type

#define HTTP_STATUS_SERVER_ERROR        500 // internal server error
#define HTTP_STATUS_NOT_SUPPORTED       501 // required not supported
#define HTTP_STATUS_BAD_GATEWAY         502 // error response received from gateway
#define HTTP_STATUS_SERVICE_UNAVAIL     503 // temporarily overloaded
#define HTTP_STATUS_GATEWAY_TIMEOUT     504 // timed out waiting for gateway
#define HTTP_STATUS_VERSION_NOT_SUP     505 // HTTP version not supported

#endif // _REPORTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\stresstimer.cpp ===
#include "stdafx.h"
#include "stresstimer.h"

StressTimer::StressTimer()
    {
    next = NULL;
    name[0] = '\0';
    dwTime = 0;
    }

StressTimer::StressTimer(char *n)
    {
    // NOTE: any name over 1K will be truncated!
    next = NULL;
    name[0] = '\0';
    dwTime = 0;
    if(n)
        {
        strncpy(name, n, STRESS_TIMER_NAME_LEN);
        name[STRESS_TIMER_NAME_LEN-1] = '\0';
        }
    }

StressTimer::~StressTimer()
    {
    if(next) delete next;
    }

StressTimer* StressTimer::Add(char *n)
    {
    if(!n) return NULL;
    if(strcmp(name, n) == 0) return this;
    if(!next)
        {
        next = new StressTimer(n);
        return next;
        }
    return next->Add(n);
    }

StressTimer* StressTimer::Find(char *n)
    {
    if(!n) return NULL;
    if(strcmp(name, n) == 0) return this;
    if(next) return next->Find(n);
    return NULL;
    }

DWORD StressTimer::Start(void)
    {
    return dwTime = GetTickCount();
    }

DWORD StressTimer::Stop(void)
    {
    DWORD curTime = GetTickCount();
    DWORD t =  curTime - dwTime;
    avg.Insert(t);

    return t;
    }

DWORD StressTimer::GetTime(void)
    {
    DWORD curTime = GetTickCount();
    DWORD t =  curTime - dwTime;

    return t;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\surge\surgeengine\reporting.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    Reporting.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/

#include "StdAfx.h"
#include "Reporting.h"
#include "../HttpClient/HttpClient.h"

// NOTE: due to limitations in HTTP POST, these strings cannot contain 
//       commas (,) ampersands (&) percents (%) or equal signs (=)
//       also, plus symbols (+) will be turned into spaces
static const ErrorDescription HttpErrors[] = 
    {
    { HTTP_STATUS_CONTINUE,             "HTTP 100", "HTTP 100 CONTINUE - Ok to continue with request."},
    { HTTP_STATUS_SWITCH_PROTOCOLS,     "HTTP 101", "HTTP 101 SWITCH PROTOCOLS - The server has switched protocols in upgrade header."},
    { HTTP_STATUS_OK,                   "HTTP 200", "HTTP 200 OK - The request completed successfully."},
    { HTTP_STATUS_CREATED,              "HTTP 201", "HTTP 201 CREATED - The request has been fulfilled and resulted in the creation of a new resource."},
    { HTTP_STATUS_ACCEPTED,             "HTTP 202", "HTTP 202 ACCEPTED - The request has been accepted for processing but the processing has not been completed."},
    { HTTP_STATUS_PARTIAL,              "HTTP 203", "HTTP 203 PARTIAL - The returned meta information in the entity-header is not the definitive set available from the origin server."},
    { HTTP_STATUS_NO_CONTENT,           "HTTP 204", "HTTP 204 NO CONTENT - The server has fulfilled the request but there is no new information to send back."},
    { HTTP_STATUS_RESET_CONTENT,        "HTTP 205", "HTTP 205 RESET CONTENT - The request has been completed and the client program should reset the document view that caused the request to be sent to allow the user to easily initiate another input action."},
    { HTTP_STATUS_PARTIAL_CONTENT,      "HTTP 206", "HTTP 206 PARTIAL CONTENT - The server has fulfilled the partial GET request for the resource."},
    { HTTP_STATUS_AMBIGUOUS,            "HTTP 300", "HTTP 300 AMBIGUOUS - The server couldn't decide what to return."},
    { HTTP_STATUS_MOVED,                "HTTP 301", "HTTP 301 MOVED - The requested resource has been assigned to a new permanent URI and any future references to this resource should be done using one of the returned URIs."},
    { HTTP_STATUS_REDIRECT,             "HTTP 302", "HTTP 302 REDIRECT - The requested resource resides temporarily under a different URI."},
    { HTTP_STATUS_REDIRECT_METHOD,      "HTTP 303", "HTTP 303 REDIRECT METHOD - The response to the request can be found under a different URI and should be retrieved using a GET method on that resource."},
    { HTTP_STATUS_NOT_MODIFIED,         "HTTP 304", "HTTP 304 NOT MODIFIED - The requested resource has not been modified."},
    { HTTP_STATUS_USE_PROXY,            "HTTP 305", "HTTP 305 USE PROXY - The requested resource must be accessed through the proxy given by the location field."},
    { HTTP_STATUS_REDIRECT_KEEP_VERB,   "HTTP 307", "HTTP 307 REDIRECT KEEP VERB - The redirected request keeps the same verb. HTTP/1.1 behavior."},
    { HTTP_STATUS_BAD_REQUEST,          "HTTP 400", "HTTP 400 BAD REQUEST- The request could not be processed by the server due to invalid syntax."},
    { HTTP_STATUS_DENIED,               "HTTP 401", "HTTP 401 DENIED -The requested resource requires user authentication."},
    { HTTP_STATUS_PAYMENT_REQ,          "HTTP 402", "HTTP 402 PAYMENT REQ - Not currently implemented in the HTTP protocol."},
    { HTTP_STATUS_FORBIDDEN,            "HTTP 403", "HTTP 403 FORBIDDEN - The server understood the request but is refusing to fulfill it."},
    { HTTP_STATUS_NOT_FOUND,            "HTTP 404", "HTTP 404 NOT FOUND - The server has not found anything matching the requested URI."},
    { HTTP_STATUS_BAD_METHOD,           "HTTP 405", "HTTP 405 BAD METHOD - The method used is not allowed."},
    { HTTP_STATUS_NONE_ACCEPTABLE,      "HTTP 406", "HTTP 406 NONE ACCEPTABLE - No responses acceptable to the client were found."},
    { HTTP_STATUS_PROXY_AUTH_REQ,       "HTTP 407", "HTTP 407 PROXY AUTH REQ - Proxy authentication required."},
    { HTTP_STATUS_REQUEST_TIMEOUT,      "HTTP 408", "HTTP 408 REQUEST TIMEOUT - The server timed out waiting for the request."},
    { HTTP_STATUS_CONFLICT,             "HTTP 409", "HTTP 409 CONFLICT - The request could not be completed due to a conflict with the current state of the resource. The user should resubmit with more information."},
    { HTTP_STATUS_GONE,                 "HTTP 410", "HTTP 410 GONE - The requested resource is no longer available at the server and no forwarding address is known."},
    { HTTP_STATUS_LENGTH_REQUIRED,      "HTTP 411", "HTTP 411 LENGTH REQUIRED - The server refuses to accept the request without a defined content length."},
    { HTTP_STATUS_PRECOND_FAILED,       "HTTP 412", "HTTP 412 PRECONDITION FAILED -The precondition given in one or more of the request header fields evaluted to false when it was tested on the server."},
    { HTTP_STATUS_REQUEST_TOO_LARGE,    "HTTP 413", "HTTP 413 REQUEST TOO LARGE - The server is refusing to process a request because the request entity is larger than the server is willing or able to process."},
    { HTTP_STATUS_URI_TOO_LONG,         "HTTP 414", "HTTP 414 URI TOO LONG - The server is refusing to service the request because the request URI is longer than the server is willing to interpret."},
    { HTTP_STATUS_UNSUPPORTED_MEDIA,    "HTTP 415", "HTTP 415 UNSUPPORTED MEDIA - The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method."},
    { HTTP_STATUS_SERVER_ERROR,         "HTTP 500", "HTTP 500 SERVER ERROR - The server encountered an unexpected condition that prevented it from fulfilling the request."},
    { HTTP_STATUS_NOT_SUPPORTED,        "HTTP 501", "HTTP 501 NOT SUPPORTED - The server does not support the functionality required to fulfill the request."},
    { HTTP_STATUS_BAD_GATEWAY,          "HTTP 502", "HTTP 502 BAD GATEWAY - The server while acting as a gateway or proxy received an invalid response from the upstream server it accessed in attempting to fulfill the request."},
    { HTTP_STATUS_SERVICE_UNAVAIL,      "HTTP 503", "HTTP 503 SERVICE UNAVAILABLE - The service is temporarily overloaded."},
    { HTTP_STATUS_GATEWAY_TIMEOUT,      "HTTP 504", "HTTP 504 GATEWAY TIMEOUT - The request was timed out waiting for a gateway."},
    { HTTP_STATUS_VERSION_NOT_SUP,      "HTTP 505", "HTTP 505 VERSION NOT SUPPORTED - The server does not support or refuses to support the HTTP protocol version that was used in the request message."},
    { 0, NULL, NULL}
    };

static const ErrorDescription SockErrors[] = 
    {
    { WSAEINTR,                "Interrupted function call", "WSAEINTR - A blocking operation was interrupted by a call to WSACancelBlockingCall."},
    { WSAEBADF,                "WSAEBADF", "WSAEBADF"},
    { WSAEACCES,               "Permission denied", "WSAEACCES - An attempt was made to access a socket in a way forbidden by its access permissions."},
    { WSAEFAULT,               "Bad address", "WSAEFAULT - The system detected an invalid pointer address in attempting to use a pointer argument of a call."},
    { WSAEINVAL,               "Invalid argument", "WSAEINVAL - Some invalid argument was supplied."},
    { WSAEMFILE,               "Too many open files", "WSAEMFILE - Too many open sockets. Each implementation may have a maximum number of socket handles available either globally per process or per thread."},
    { WSAEWOULDBLOCK,          "Resource temporarily unavailable", "WSAEWOULDBLOCK - This error is returned from operations on non-blocking sockets that cannot be completed immediately."},
    { WSAEINPROGRESS,          "Operation now in progress", "WSAEINPROGRESS - A blocking operation is currently executing."},
    { WSAEALREADY,             "Operation already in progress", "WSAEALREADY - An operation was attempted on a non-blocking socket that already had an operation in progress."},
    { WSAENOTSOCK,             "Socket operation on non-socket", "WSAENOTSOCK - An operation was attempted on something that is not a socket."},
    { WSAEDESTADDRREQ,         "Destination address required", "WSAEDESTADDRREQ - A required address was omitted from an operation on a socket."},
    { WSAEMSGSIZE,             "Message too long", "WSAEMSGSIZE - A message sent on a datagram socket was larger than the internal message buffer or some other network limit or the buffer used to receive a datagram into was smaller than the datagram itself."},
    { WSAEPROTOTYPE,           "Protocol wrong type for socket", "WSAEPROTOTYPE - A protocol was specified in the socket function call that does not support the semantics of the socket type requested."},
    { WSAENOPROTOOPT,          "Bad protocol option", "WSAENOPROTOOPT - An unknown invalid or unsupported option or level was specified in a getsockopt or setsockopt call."},
    { WSAEPROTONOSUPPORT,      "Protocol not supported", "WSAEPROTONOSUPPORT - The requested protocol has not been configured into the system or no implementation for it exists."},
    { WSAESOCKTNOSUPPORT,      "Socket type not supported", "WSAESOCKTNOSUPPORT - The support for the specified socket type does not exist in this address family."},
    { WSAEOPNOTSUPP,           "Operation not supported", "WSAEOPNOTSUPP - The attempted operation is not supported for the type of object referenced."},
    { WSAEPFNOSUPPORT,         "Protocol family not supported", "WSAEPFNOSUPPORT - The protocol family has not been configured into the system or no implementation for it exists."},
    { WSAEAFNOSUPPORT,         "Address family not supported by protocol family", "WSAEAFNOSUPPORT - An address incompatible with the requested protocol was used. All sockets are created with an associated address family (i.e. AF_INET for Internet Protocols) and a generic protocol type (i.e. SOCK_STREAM)."},
    { WSAEADDRINUSE,           "Address already in use", "WSAEADDRINUSE - Only one usage of each socket address (protocol/IP address/port) is normally permitted."},
    { WSAEADDRNOTAVAIL,        "Cannot assign requested address", "WSAEADDRNOTAVAIL - The requested address is not valid in its context. Normally results from an attempt to bind to an address that is not valid for the local machine or connect/sendto an address or port that is not valid for a remote machine."},
    { WSAENETDOWN,             "Network is down", "WSAENETDOWN - A socket operation encountered a dead network. This could indicate a serious failure of the network system (i.e. the protocol stack that the WinSock DLL runs over) the network interface or the local network itself."},
    { WSAENETUNREACH,          "Network is unreachable", "WSAENETUNREACH - A socket operation was attempted to an unreachable network. This usually means the local software knows no route to reach the remote host."},
    { WSAENETRESET,            "Network dropped connection on reset", "WSAENETRESET - The host you were connected to crashed and rebooted. May also be returned by setsockopt if an attempt is made to set SO_KEEPALIVE on a connection that has already failed."},
    { WSAECONNABORTED,         "Software caused connection abort", "WSAECONNABORTED - An established connection was aborted by the software in your host machine possibly due to a data transmission timeout or protocol error."},
    { WSAECONNRESET,           "Connection reset by peer", "WSAECONNRESET - A existing connection was forcibly closed by the remote host."},
    { WSAENOBUFS,              "No buffer space available", "WSAENOBUFS - An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full."},
    { WSAEISCONN,              "Socket is already connected", "WSAEISCONN - A connect request was made on an already connected socket."},
    { WSAENOTCONN,             "Socket is not connected", "WSAENOTCONN - A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using sendto) no address was supplied. Any other type of operation might also return this error."},
    { WSAESHUTDOWN,            "Cannot send after socket shutdown", "WSAESHUTDOWN - A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call."},
    { WSAETOOMANYREFS,         "WSAETOOMANYREFS", "WSAETOOMANYREFS"},
    { WSAETIMEDOUT,            "Connection timed out", "WSAETIMEDOUT - A connection attempt failed because the connected party did not properly respond after a period of time or established connection failed because connected host has failed to respond."},
    { WSAECONNREFUSED,         "Connection refused", "WSAECONNREFUSED - No connection could be made because the target machine actively refused it."},
    { WSAELOOP,                "WSAELOOP", "WSAELOOP"},
    { WSAENAMETOOLONG,         "WSAENAMETOOLONG", "WSAENAMETOOLONG"},
    { WSAEHOSTDOWN,            "Host is down", "WSAEHOSTDOWN - A socket operation failed because the destination host was down. A socket operation encountered a dead host. Networking activity on the local host has not been initiated."},
    { WSAEHOSTUNREACH,         "No route to host", "WSAEHOSTUNREACH - A socket operation was attempted to an unreachable host. See WSAENETUNREACH."},
    { WSAENOTEMPTY,            "WSAENOTEMPTY", "WSAENOTEMPTY"},
    { WSAEPROCLIM,             "Too many processes", "WSAEPROCLIM - A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously."},
    { WSAEUSERS,               "WSAEUSERS", "WSAEUSERS"},
    { WSAEDQUOT,               "WSAEDQUOT", "WSAEDQUOT"},
    { WSAESTALE,               "WSAESTALE", "WSAESTALE"},
    { WSASYSNOTREADY,          "Network subsystem is unavailable", "WSASYSNOTREADY - This error is returned by WSAStartup if the Windows Sockets implementation cannot function at this time because the underlying system it uses to provide network services is currently unavailable."},
    { WSAVERNOTSUPPORTED,      "WINSOCK.DLL version out of range", "WSAVERNOTSUPPORTED - The current Windows Sockets implementation does not support the Windows Sockets specification version requested by the application."},
    { WSANOTINITIALISED,       "Successful WSAStartup not yet performed", "WSANOTINITIALISED - Either the application hasnt called WSAStartup or WSAStartup failed."},
    { WSAEDISCON,              "Graceful shutdown in progress", "WSAEDISCON - Returned by recv WSARecv to indicate the remote party has initiated a graceful shutdown sequence."},
    { WSAENOMORE,              "WSAENOMORE", "WSAENOMORE"},
    { WSAECANCELLED,           "WSAECANCELLED", "WSAECANCELLED"},
    { WSAEINVALIDPROCTABLE,    "Invalid procedure table from service provider", "WSAEINVALIDPROCTABLE - A service provider returned a bogus proc table to WS2_32.DLL."},
    { WSAEINVALIDPROVIDER,     "Invalid service provider version number", "WSAEINVALIDPROVIDER - A service provider returned a version number other than 2.0."},
    { WSAEPROVIDERFAILEDINIT,  "Unable to initialize a service provider", "WSAEPROVIDERFAILEDINIT - Either a service provider's DLL could not be loaded (LoadLibrary failed) or the provider's WSPStartup/NSPStartup function failed."},
    { WSASYSCALLFAILURE,       "System call failure", "WSASYSCALLFAILURE - Returned when a system call that should never fail does."},
    { WSASERVICE_NOT_FOUND,    "WSASERVICE_NOT_FOUND", "WSASERVICE_NOT_FOUND"},
    { WSATYPE_NOT_FOUND,       "WSATYPE_NOT_FOUND", "WSATYPE_NOT_FOUND"},
    { WSA_E_NO_MORE,           "WSA_E_NO_MORE", "WSA_E_NO_MORE"},
    { WSA_E_CANCELLED,         "WSA_E_CANCELLED", "WSA_E_CANCELLED"},
    { WSAEREFUSED,             "WSAEREFUSED", "WSAEREFUSED"},
    { WSAHOST_NOT_FOUND,       "Host not found", "WSAHOST_NOT_FOUND - No such host is known. The name is not an official hostname or alias or it cannot be found in the database(s) being queried."},
    { WSATRY_AGAIN,            "Non-authoritative host not found", "WSATRY_AGAIN - This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. A retry at some time later may be successful."},
    { WSANO_RECOVERY,          "This is a non-recoverable error", "WSANO_RECOVERY - This indicates some sort of non-recoverable error occurred during a database lookup."},
    { WSANO_DATA,              "Valid name no data record of requested type", "WSANO_DATA - The requested name is valid and was found in the database but it does not have the correct associated data being resolved for."},
    { WSANO_ADDRESS,           "WSANO_ADDRESS", "WSANO_ADDRESS"},
//    { WSA_INVALID_HANDLE,      "Specified event object handle is invalid", "WSA_INVALID_HANDLE - An application attempts to use an event object but the specified handle is not valid."},
//    { WSA_INVALID_PARAMETER,   "One or more parameters are invalid", "WSA_INVALID_PARAMETER - An application used a Windows Sockets function which directly maps to a Win32 function. The Win32 function is indicating a problem with one or more parameters."},
//    { WSA_IO_PENDING,          "Overlapped operations will complete later", "WSA_IO_PENDING - The application has initiated an overlapped operation which cannot be completed immediately."},
//    { WSA_IO_INCOMPLETE,       "Overlapped I/O event object not in signaled state", "WSA_IO_INCOMPLETE - The application has tried to determine the status of an overlapped operation which is not yet completed."},
//    { WSA_NOT_ENOUGH_MEMORY,   "Insufficient memory available", "WSA_NOT_ENOUGH_MEMORY - An application used a Windows Sockets function which directly maps to a Win32 function. The Win32 function is indicating a lack of required memory resources."},
//    { WSA_OPERATION_ABORTED,   "Overlapped operation aborted", "WSA_OPERATION_ABORTED - An overlapped operation was canceled due to the closure of the socket or the execution of the SIO_FLUSH command in WSAIoctl."},
    { SEC_E_INSUFFICIENT_MEMORY,    "SEC_E_INSUFFICIENT_MEMORY", "SEC_E_INSUFFICIENT_MEMORY - Not enough memory is available to complete this request."},
    { SEC_E_INVALID_HANDLE,         "SEC_E_INVALID_HANDLE", "SEC_E_INVALID_HANDLE - The handle specified is invalid."},
    { SEC_E_UNSUPPORTED_FUNCTION,   "SEC_E_UNSUPPORTED_FUNCTION", "SEC_E_UNSUPPORTED_FUNCTION - The function requested is not supported."},
    { SEC_E_TARGET_UNKNOWN,         "SEC_E_TARGET_UNKNOWN", "SEC_E_TARGET_UNKNOWN - The specified target is unknown or unreachable."},
    { SEC_E_INTERNAL_ERROR,         "SEC_E_INTERNAL_ERROR", "SEC_E_INTERNAL_ERROR - The Local Security Authority cannot be contacted or an exception occured."},
    { SEC_E_SECPKG_NOT_FOUND,       "SEC_E_SECPKG_NOT_FOUND", "SEC_E_SECPKG_NOT_FOUND - The requested security package does not exist."},
    { SEC_E_NOT_OWNER,              "SEC_E_NOT_OWNER", "SEC_E_NOT_OWNER - The caller is not the owner of the desired credentials."},
    { SEC_E_CANNOT_INSTALL,         "SEC_E_CANNOT_INSTALL", "SEC_E_CANNOT_INSTALL - The security package failed to initialize and cannot be installed."},
    { SEC_E_INVALID_TOKEN,          "SEC_E_INVALID_TOKEN", "SEC_E_INVALID_TOKEN - The token supplied to the function is invalid."},
    { SEC_E_CANNOT_PACK,            "SEC_E_CANNOT_PACK", "SEC_E_CANNOT_PACK - The security package is not able to marshall the logon buffer so the logon attempt has failed."},
    { SEC_E_QOP_NOT_SUPPORTED,      "SEC_E_QOP_NOT_SUPPORTED", "SEC_E_QOP_NOT_SUPPORTED - The per-message Quality of Protection is not supported by the security package."},
    { SEC_E_NO_IMPERSONATION,       "SEC_E_NO_IMPERSONATION", "SEC_E_NO_IMPERSONATION - The security context does not allow impersonation of the client."},
    { SEC_E_LOGON_DENIED,           "SEC_E_LOGON_DENIED", "SEC_E_LOGON_DENIED - The logon attempt failed."},
    { SEC_E_UNKNOWN_CREDENTIALS,    "SEC_E_UNKNOWN_CREDENTIALS", "SEC_E_UNKNOWN_CREDENTIALS - The credentials supplied to the package were not recognized."},
    { SEC_E_NO_CREDENTIALS,         "SEC_E_NO_CREDENTIALS", "SEC_E_NO_CREDENTIALS - No credentials are available in the security package."},
    { SEC_E_MESSAGE_ALTERED,        "SEC_E_MESSAGE_ALTERED", "SEC_E_MESSAGE_ALTERED - The message or signature supplied for verification has been altered."},
    { SEC_E_OUT_OF_SEQUENCE,        "SEC_E_OUT_OF_SEQUENCE", "SEC_E_OUT_OF_SEQUENCE - The message supplied for verification is out of sequence."},
    { SEC_E_NO_AUTHENTICATING_AUTHORITY,    "SEC_E_NO_AUTHENTICATING_AUTHORITY", "SEC_E_NO_AUTHENTICATING_AUTHORITY - No authority could be contacted for authentication."},
    { SEC_I_CONTINUE_NEEDED,        "SEC_I_CONTINUE_NEEDED", "SEC_I_CONTINUE_NEEDED - The function completed successfully but must be called again to complete the context."},
    { SEC_I_COMPLETE_NEEDED,        "SEC_I_COMPLETE_NEEDED", "SEC_I_COMPLETE_NEEDED - The function completed successfully but CompleteToken must be called."},
    { SEC_I_COMPLETE_AND_CONTINUE,  "SEC_I_COMPLETE_AND_CONTINUE", "SEC_I_COMPLETE_AND_CONTINUE - The function completed successfully but both CompleteToken and this function must be called to complete the context."},
    { SEC_I_LOCAL_LOGON,            "SEC_I_LOCAL_LOGON", "SEC_I_LOCAL_LOGON - The logon was completed but no network authority was available.  The logon was made using locally known information."},
    { SEC_E_BAD_PKGID,              "SEC_E_BAD_PKGID", "SEC_E_BAD_PKGID - The requested security package does not exist."},
    { SEC_E_CONTEXT_EXPIRED,        "SEC_E_CONTEXT_EXPIRED", "SEC_E_CONTEXT_EXPIRED - The context has expired and can no longer be used."},
    { SEC_E_INCOMPLETE_MESSAGE,     "SEC_E_INCOMPLETE_MESSAGE", "SEC_E_INCOMPLETE_MESSAGE - The supplied message is incomplete.  The signature was not verified."},
    { SEC_E_INCOMPLETE_CREDENTIALS, "SEC_E_INCOMPLETE_CREDENTIALS", "SEC_E_INCOMPLETE_CREDENTIALS - The credentials supplied were not complete and could not be verified.  The context could not be initialized."},
    { SEC_E_BUFFER_TOO_SMALL,       "SEC_E_BUFFER_TOO_SMALL", "SEC_E_BUFFER_TOO_SMALL - The buffers supplied to a function was too small."},
    { SEC_I_INCOMPLETE_CREDENTIALS, "SEC_I_INCOMPLETE_CREDENTIALS", "SEC_I_INCOMPLETE_CREDENTIALS - The credentials supplied were not complete and could not be verified. Additional information can be returned from the context."},
    { SEC_I_RENEGOTIATE,            "SEC_I_RENEGOTIATE", "SEC_I_RENEGOTIATE - The context data must be renegotiated with the peer."},
    { SEC_E_WRONG_PRINCIPAL,        "SEC_E_WRONG_PRINCIPAL", "SEC_E_WRONG_PRINCIPAL - The target principal name is incorrect."},
    { SEC_I_NO_LSA_CONTEXT,         "SEC_I_NO_LSA_CONTEXT", "SEC_I_NO_LSA_CONTEXT - There is no LSA mode context associated with this context."},
    { SEC_E_TIME_SKEW,              "SEC_E_TIME_SKEW", "SEC_E_TIME_SKEW - The clocks on the client and server machines are skewed."},
    { SEC_E_UNTRUSTED_ROOT,         "SEC_E_UNTRUSTED_ROOT", "SEC_E_UNTRUSTED_ROOT - The certificate received from the remote computer was issued by an untrusted authority."},
//    { SEC_E_CERTIFICATE_REVOKED,    "SEC_E_CERTIFICATE_REVOKED", "SEC_E_CERTIFICATE_REVOKED - The certificate received from the remote computer has been revoked."},
    { SEC_E_CERT_UNKNOWN,           "SEC_E_CERT_UNKNOWN", "SEC_E_CERT_UNKNOWN - The certificate received from the remote computer is unacceptable."},
    { SEC_E_CERT_EXPIRED,           "SEC_E_CERT_EXPIRED", "SEC_E_CERT_EXPIRED - The certificate received from the remote computer has expired or is not currently valid."},
    { 0, NULL, NULL}
    };

static const ErrorDescription SurgeErrors[] = 
    {
    { SURGE_NOCOOKIE,         "No Cookie",              "SURGE_NOCOOKIE - No cookie or not enough cookies were found in the HTTP Response."},
    { SURGE_UX_LOGON,         "Unexpected Logon",       "SURGE_UX_LOGON - A user was logged on when a failure was expected."},
    { SURGE_UX_LOGOFF,        "Unexpected Logoff",      "SURGE_UX_LOGOFF - A user was logged off when a failure was expected."},
    { SURGE_UX_NAV,           "Unexpected Auth",        "SURGE_UX_NAV - A user was authenticated when a failure was expected."},
    { SURGE_UX_PROFILE,       "Unexpected Profile",     "SURGE_UX_PROFILE - A user's profile was modified when a failure was expected."},
    { SURGE_UX_PASSWORD,      "Unexpected Password",    "SURGE_UX_PASSWORD - A user's password was modified when a failure was expected."},
    { SURGE_UX_REGISTER,      "Unexpected Register",    "SURGE_UX_REGISTER - A user was registered when a failure was expected."},
    { SURGE_UX_UNREGISTER,    "Unexpected Unregister",  "SURGE_UX_UNREGISTER - A user was unregisterd when a failure was expected."},
    { 0, NULL, NULL}
    };


/*++

Routine Description:

    ErrorNo
    returns a pointer to the static error description string
    
Arguments:

    int errorClass  -
    long error      -

Return Value:

    char *

Notes:

    pointer to error description string or NULL

--*/
char* ErrorNo(int errorClass, long error)
    {
    if(errorClass == ERRCLASS_SOCK)
        {
        for(unsigned i=0; SockErrors[i].dwError != 0; i++)
            {
            if(SockErrors[i].dwError == error) return SockErrors[i].description;
            }
        }
    else if(errorClass == ERRCLASS_HTTP)
        {
        for(unsigned i=0; HttpErrors[i].dwError != 0; i++)
            {
            if(HttpErrors[i].dwError == error) return HttpErrors[i].description;
            }
        }
    else if(errorClass == ERRCLASS_SURGE)
        {
        for(unsigned i=0; SurgeErrors[i].dwError != 0; i++)
            {
            if(SurgeErrors[i].dwError == error) return SurgeErrors[i].description;
            }
        }

    return NULL;
    }

/*++

Routine Description:

    AddWindowText
    Inserts a string at the end of an edit box or rich edit

Arguments:

    HWND window - handle to the edit box or rich edit to send the text to
    char *text - the string to insert

Return Value:

    NONE

Notes:

--*/
void AddWindowText(HWND window, char *text)
    {
    #define MAX_EDITBOX_LINES 500

    if(!window || !text) return;

    // check to see if the box is full
    if(SendMessage(window, EM_GETLINECOUNT, 0, 0) >= MAX_EDITBOX_LINES)
        {
        long len = SendMessage(window, EM_LINELENGTH, (WPARAM)1, 0) + 2;
        SendMessage(window, EM_SETSEL, 0, len);
        SendMessage(window, EM_REPLACESEL, FALSE, (LPARAM)"");
        }

    // move the caret to the end
    SendMessage(window, EM_SETSEL, (((unsigned long)~0)/2-1), (((unsigned long)~0)/2-1));

    // insert the text
    SendMessage(window, EM_REPLACESEL, FALSE, (LPARAM)text);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\Connection.h ===
// Connection.h: interface for the CConnection class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(CONNECTION_H)
#define CONNECTION_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

class CConnection  
{
friend VOID CALLBACK ConnCallback(HINTERNET, DWORD *, DWORD, LPVOID, DWORD);
friend class CHttpRequest;

public:
	Release();
	AddRef();
	BOOL WaitForResponse(DWORD dwWaitTime);
	BOOL WaitForConnect(DWORD dwWaitTime);
	SetAsync(BOOL fAsync);
	SetService(DWORD dwService);
	BOOL EstablishConnection(LPTSTR szAgentName, LPTSTR szServer, INTERNET_PORT nPort);
	CConnection();
	virtual ~CConnection();

private:
	BOOL m_fConnectInitiated;
	HANDLE m_hResponseEvent;
	HANDLE m_hConnectEvent;
	DWORD m_dwService;
	DWORD m_dwRefCount;
	HINTERNET m_hConnection;
	HINTERNET m_hInternet;
	BOOL m_fAsync;
};

#endif // !defined(CONNECTION_H)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\connection.cpp ===
// Connection.cpp: implementation of the CConnection class.
//
//////////////////////////////////////////////////////////////////////

#include "Connection.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

VOID CALLBACK ConnCallback(HINTERNET hInternet, DWORD *pContext, DWORD dwStatus, LPVOID lpvStatusInfo, DWORD dwStatusInfoLen)
{
	CConnection *pConnection = (CConnection *) pContext;

	switch(dwStatus)
	{
//	case INTERNET_STATUS_RESOLVING_NAME:
//	case INTERNET_STATUS_NAME_RESOLVED:
//	case INTERNET_STATUS_CONNECTING_TO_SERVER:
	case INTERNET_STATUS_CONNECTED_TO_SERVER:
		pConnection->m_hConnectEvent ? SetEvent(pConnection->m_hConnectEvent) : 0;
		break;

//	case INTERNET_STATUS_SENDING_REQUEST:
//	case INTERNET_STATUS_REQUEST_SENT:
//	case INTERNET_STATUS_RECEIVING_RESPONSE:
	case INTERNET_STATUS_RESPONSE_RECEIVED:
		pConnection->m_hResponseEvent ? SetEvent(pConnection->m_hResponseEvent) : 0;
		break;
//	case INTERNET_STATUS_CTL_RESPONSE_RECEIVED:
//	case INTERNET_STATUS_PREFETCH:
//	case INTERNET_STATUS_CLOSING_CONNECTION:
//	case INTERNET_STATUS_CONNECTION_CLOSED:
//	case INTERNET_STATUS_HANDLE_CREATED:
//	case INTERNET_STATUS_HANDLE_CLOSING:
//	case INTERNET_STATUS_DETECTING_PROXY:
//	case INTERNET_STATUS_REQUEST_COMPLETE:
//	case INTERNET_STATUS_REDIRECT:
//	case INTERNET_STATUS_INTERMEDIATE_RESPONSE:
//	case INTERNET_STATUS_USER_INPUT_REQUIRED:
//	case INTERNET_STATUS_STATE_CHANGE:
	default:
		break;
	}
}

CConnection::CConnection()
{
	m_hInternet = NULL;
	m_hConnection = NULL;
	m_dwService = INTERNET_SERVICE_HTTP;
	m_fAsync = FALSE;
	m_hConnectEvent = NULL;
	m_hResponseEvent = NULL;
}

CConnection::~CConnection()
{
	if(m_hConnection)
		InternetCloseHandle(m_hConnection);

	if(m_hInternet)
		InternetCloseHandle(m_hInternet);

	if(m_hConnectEvent)
		CloseHandle(m_hConnectEvent);

	if(m_hResponseEvent)
		CloseHandle(m_hResponseEvent);
}

BOOL CConnection::EstablishConnection(LPTSTR szAgentName, LPTSTR szServer, INTERNET_PORT nPort)
{
	DWORD dwFlags = m_fAsync ? INTERNET_FLAG_ASYNC : 0;

	m_hInternet = InternetOpen(szAgentName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, dwFlags | INTERNET_FLAG_DONT_CACHE);
	if(!m_hInternet)
		return FALSE;
	
	if(m_fAsync)
	{
		if(InternetSetStatusCallback(m_hInternet, (INTERNET_STATUS_CALLBACK) ConnCallback) == INTERNET_INVALID_STATUS_CALLBACK)
			return FALSE;

		m_hConnectEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!m_hConnectEvent)
			return FALSE;

		m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!m_hResponseEvent)
			return FALSE;
	}

	m_hConnection = InternetConnect(m_hInternet, szServer, nPort, NULL, NULL, m_dwService, 0, m_fAsync ? (DWORD) this : 0);
	if(!m_hConnection)
		return FALSE;

	m_fConnectInitiated = TRUE;

	return TRUE;
}

CConnection::SetService(DWORD dwService)
{
	m_dwService = dwService;
}

CConnection::SetAsync(BOOL fAsync)
{
	m_fAsync = fAsync;
}

BOOL CConnection::WaitForConnect(DWORD dwWaitTime)
{
	DWORD dwWaitResult = WAIT_TIMEOUT;
	BOOL fConnected = FALSE;

	if(!m_hConnectEvent)
		return FALSE;

	dwWaitResult = WaitForSingleObject(m_hConnectEvent, dwWaitTime);
	switch(dwWaitResult)
	{
	case WAIT_TIMEOUT:
		fConnected = FALSE;
	case WAIT_OBJECT_0:
		fConnected = TRUE;
	default:
		fConnected = FALSE;
	}

	return fConnected;
}

BOOL CConnection::WaitForResponse(DWORD dwWaitTime)
{
	DWORD dwWaitResult = WAIT_TIMEOUT;
	BOOL fResponseReceived = FALSE;

	if(!m_hResponseEvent)
		return FALSE;

	dwWaitResult = WaitForSingleObject(m_hResponseEvent, dwWaitTime);
	switch(dwWaitResult)
	{
	case WAIT_TIMEOUT:
		fResponseReceived = FALSE;
	case WAIT_OBJECT_0:
		fResponseReceived = TRUE;
	default:
		fResponseReceived = FALSE;
	}

	return fResponseReceived;
}

CConnection::AddRef()
{
	++m_dwRefCount;
}

CConnection::Release()
{
	--m_dwRefCount;
	if(!m_dwRefCount)
	{
		delete this;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\HttpRequest.h ===
// HttpRequest.h: interface for the CHttpRequest class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(HTTPREQUEST_H)
#define HTTPREQUEST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "connection.h"

class CHttpRequest  
{
public:
	BOOL GetStatusCode(LPDWORD pdwStatusCode);
	BOOL DownloadDataToBuffer(LPBYTE pBuffer, LPDWORD pdwActualSize);
	BOOL GetRequestHeaders(LPVOID pBuffer, LPDWORD pdwBufferLen);
	BOOL GetContentLength(DWORD *pdwContentLength);
	BOOL ReadData(LPVOID pBuffer, DWORD dwBytesToRead, LPDWORD pdwBytesRead);
	BOOL QueryDataAvailable(LPDWORD pdwDataAvailable);
	BOOL GetResponseHeaders(LPVOID pBuffer, LPDWORD pdwBufferLen);
	BOOL WaitForResponse(DWORD dwWaitTime);
	BOOL SendRequest(LPVOID pData, DWORD dwDataSize);
	BOOL AddHeaders(LPSTR szHeaders);
	BOOL Initialize(LPTSTR szVerb, LPTSTR szObjectName);
	CHttpRequest(CConnection *pConnection);
	virtual ~CHttpRequest();

private:
	HINTERNET m_hHttpRequest;
	CConnection * m_pConnection;
};

#endif // !defined(HTTPREQUEST_H)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\mmcommon.h ===
// mmcommon.h : Defines various global defaults for the mmcommon program
//
#define MMTEST_AGENT_NAME		TEXT("XboxMMTest")
#define CONTENT_LENGTH_HEADER	TEXT("Content-Length:")

#define SAMPLE_ATTRIB1_ID		0xAAAA
#define SAMPLE_ATTRIB1_STRING	"Attrib string"
#define SAMPLE_ATTRIB1_INT		12345

#define SAMPLE_PARAM1_STRING	"Parameter string 1.."

#define SAMPLE_PUID1			0x0000000000000001
#define SAMPLE_PUID2			0x0000000000000002
#define SAMPLE_PUID3			0x0000000000000003
#define SAMPLE_PUID4			0x0000000000000004

typedef struct _ATTRIB_LIST
{
	BYTE				*pAttribBuffer;
	DWORD				dwAttribLen;
	struct _ATTRIB_LIST	*pNext;
} ATTRIB_LIST, *PATTRIB_LIST;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\HttpRequest.cpp ===
// HttpRequest.cpp: implementation of the CHttpRequest class.
//
//////////////////////////////////////////////////////////////////////

#include "HttpRequest.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHttpRequest::CHttpRequest(CConnection *pConnection)
{
	m_pConnection = pConnection;
	m_pConnection->AddRef();
	m_hHttpRequest = NULL;

}

CHttpRequest::~CHttpRequest()
{
	m_pConnection->Release();
	m_pConnection = NULL;

	if(m_hHttpRequest)
		InternetCloseHandle(m_hHttpRequest);
}

BOOL CHttpRequest::AddHeaders(LPSTR szHeaders)
{

	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;


	return HttpAddRequestHeaders(m_hHttpRequest, szHeaders, -1L, 0);
}

BOOL CHttpRequest::Initialize(LPTSTR szVerb, LPTSTR szObjectName)
{
	if(!m_pConnection->m_hConnection)
		return FALSE;

	if(m_hHttpRequest)
	{
		InternetCloseHandle(m_hHttpRequest);
		m_hHttpRequest = NULL;
	}

	m_hHttpRequest = HttpOpenRequest(m_pConnection->m_hConnection, szVerb, szObjectName, NULL, NULL, NULL, 0, (DWORD) m_pConnection);
	if(!m_hHttpRequest)
		return FALSE;

	return TRUE;
}

BOOL CHttpRequest::SendRequest(LPVOID pData, DWORD dwDataSize)
{
	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	return HttpSendRequest(m_hHttpRequest, NULL, 0, pData, dwDataSize);
}

BOOL CHttpRequest::WaitForResponse(DWORD dwWaitTime)
{
	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	return m_pConnection->WaitForResponse(dwWaitTime);
}

BOOL CHttpRequest::GetResponseHeaders(LPVOID pBuffer, LPDWORD pdwBufferLen)
{
	DWORD dwHeaderIndex = 0;

	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	return HttpQueryInfo(m_hHttpRequest, HTTP_QUERY_RAW_HEADERS, pBuffer, pdwBufferLen, &dwHeaderIndex);
}

BOOL CHttpRequest::QueryDataAvailable(LPDWORD pdwDataAvailable)
{
	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	return InternetQueryDataAvailable(m_hHttpRequest, pdwDataAvailable, 0, 0);
}

BOOL CHttpRequest::ReadData(LPVOID pBuffer, DWORD dwBytesToRead, LPDWORD pdwBytesRead)
{
	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	return InternetReadFile(m_hHttpRequest, pBuffer, dwBytesToRead, pdwBytesRead);
}

BOOL CHttpRequest::GetContentLength(DWORD *pdwContentLength)
{
	LPTSTR pBuf = NULL;
	DWORD dwBufferSize = 0;
	BOOL fRet = TRUE;
	INT n = 0;

	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	HttpQueryInfo(m_hHttpRequest, HTTP_QUERY_CONTENT_LENGTH, NULL, &dwBufferSize, 0);
	
	if(!dwBufferSize)
		return FALSE;
	
	pBuf = new TCHAR[dwBufferSize];
	HttpQueryInfo(m_hHttpRequest, HTTP_QUERY_CONTENT_LENGTH, pBuf, &dwBufferSize, 0);
	
	n = _ttoi(pBuf);
	
	*pdwContentLength = (DWORD) n;
	
	delete [] pBuf;
	
	return TRUE;
}

BOOL CHttpRequest::GetRequestHeaders(LPVOID pBuffer, LPDWORD pdwBufferLen)
{
	DWORD dwHeaderIndex = 0;

	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	return HttpQueryInfo(m_hHttpRequest, HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_RAW_HEADERS, pBuffer, pdwBufferLen, &dwHeaderIndex);
}

BOOL CHttpRequest::DownloadDataToBuffer(LPBYTE pBuffer, LPDWORD pdwActualSize)
{
	LPBYTE pReadBuffer = pBuffer, pTempBuffer = NULL;
	DWORD dwBytesAvailable = 0, dwBytesRead = 0, dwTotalBytesRead = 0;
	BOOL fOverflowing = FALSE, fRet = TRUE;

	if(!InternetQueryDataAvailable(m_hHttpRequest, &dwBytesAvailable, 0, 0))
	{
		_tprintf(TEXT("QueryData returned unexpected error %u\n"), GetLastError());
		fRet = FALSE;
		goto Exit;
	}
	
	while(dwBytesAvailable)
	{	
		if(!fOverflowing)
		{
			if(dwTotalBytesRead + dwBytesAvailable > *pdwActualSize)
			{
				// If there's just a small bit of data left, read that last part to our buffer
				if(*pdwActualSize > dwTotalBytesRead)
				{
					dwBytesAvailable = *pdwActualSize - dwTotalBytesRead;

//					_tprintf(TEXT("Reading last %u bytes that will fit into buffer\n"), dwBytesAvailable);

					if(!InternetReadFile(m_hHttpRequest, pReadBuffer, dwBytesAvailable, &dwBytesRead))
					{
						_tprintf(TEXT("QueryData returned unexpected error %u\n"), GetLastError());
						fRet = FALSE;
						goto Exit;
					}

					dwBytesAvailable = 0;
					if(!InternetQueryDataAvailable(m_hHttpRequest, &dwBytesAvailable, 0, 0))
					{
						_tprintf(TEXT("QueryData returned unexpected error %u\n"), GetLastError());
						fRet = FALSE;
						goto Exit;
					}

					continue;
				}
				// If we alrady exhausted our input buffer, then start reading from the
				else
				{
					fOverflowing = TRUE;
					pTempBuffer = new BYTE[dwBytesAvailable]; 
					pReadBuffer = pTempBuffer;
				}
			}
		}
		else
		{
			pTempBuffer = new BYTE[dwBytesAvailable]; 
			pReadBuffer = pTempBuffer;
		}

		dwBytesRead = 0;

		if(!InternetReadFile(m_hHttpRequest, pReadBuffer, dwBytesAvailable, &dwBytesRead))
		{
			_tprintf(TEXT("QueryData returned unexpected error %u\n"), GetLastError());
			fRet = FALSE;
			goto Exit;
		}
		
//		_tprintf(TEXT("Read %u bytes\n"), dwBytesRead);

		dwTotalBytesRead += dwBytesRead;

		// If we're already overflowing, then release the buffer that was used for this read
		if(fOverflowing)
		{
			delete [] pTempBuffer;
			pTempBuffer = NULL;
		}
		// Otherwise, move the buffer pointer to point to the location for the next read
		else
		{
			pReadBuffer += dwBytesRead;
		}

		dwBytesAvailable = 0;
		if(!InternetQueryDataAvailable(m_hHttpRequest, &dwBytesAvailable, 0, 0))
		{
			_tprintf(TEXT("QueryData returned unexpected error %u\n"), GetLastError());
			fRet = FALSE;
			goto Exit;
		}
	}

Exit:

//	_tprintf(TEXT("Read %u bytes total\n"), dwTotalBytesRead);

	pTempBuffer ? delete [] pTempBuffer : 0;
	*pdwActualSize = dwTotalBytesRead;
	return fRet;
}

BOOL CHttpRequest::GetStatusCode(LPDWORD pdwStatusCode)
{
	LPTSTR pBuf = NULL;
	DWORD dwBufferSize = 0;
	BOOL fRet = TRUE;
	INT n = 0;

	if((!m_pConnection->m_hConnection) && (!m_hHttpRequest))
		return FALSE;

	HttpQueryInfo(m_hHttpRequest, HTTP_QUERY_STATUS_CODE, NULL, &dwBufferSize, 0);

	pBuf = new TCHAR[dwBufferSize];
	HttpQueryInfo(m_hHttpRequest, HTTP_QUERY_STATUS_CODE, pBuf, &dwBufferSize, 0);

	n = _ttoi(pBuf);

	*pdwStatusCode = (DWORD) n;

	delete [] pBuf;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmping\mmping.h ===
// mmping.h : Defines various global defaults for the mmping program
//
#define MMPING_AGENT_NAME		TEXT("XboxMMPing")
#define CONTENT_LENGTH_HEADER	TEXT("Content-Length:")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\SessionCreation.h ===
// SessionCreation.h: interface for the CSessionCreation class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(SESSIONCREATION_H)
#define SESSIONCREATION_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "xmatchp.h"
#include "connection.h"
#include "httprequest.h"
#include "mmcommon.h"

DWORD CreateDeleteModifySession(LPTSTR, LPTSTR, XMATCH_SESSION *, DWORD);

class CSessionCreation  
{
public:
	BOOL SetHostAddress(LPBYTE pHostAddress);
	DWORD m_dwBufferLen;
	BOOL AddAttribute(DWORD dwAttribID, DWORD dwAttribLen, LPBYTE pBuffer);
	BOOL AddPlayerAttribute(DWORD dwAttribID, LONGLONG qwPlayerID, DWORD dwAttribLen, LPBYTE pBuffer);
	DWORD SendRequest(LPTSTR szServer, LPTSTR szObject);
	DWORD SendRawRequest(LPTSTR szServer, LPTSTR szObject);
	BOOL SetNumAttributes(DWORD dwNumAttributes);
	BOOL SetPrivateAvailable(DWORD dwPrivateAvailable);
	BOOL SetPublicAvailable(DWORD dwPublicAvailable);
	BOOL SetSessionID(DWORD dwSessionID);
	BOOL SetTitleID(DWORD dwTitleID);
	BOOL SetMessageLength(DWORD dwMessageLength);
	BOOL SetProtocolVersion(DWORD dwProtocolVersion);
	BOOL Initialize(DWORD dwBufferLen);
	LPBYTE m_pBuffer;
	CSessionCreation();
	virtual ~CSessionCreation();

private:
	PATTRIB_LIST m_pAttribList;
	DWORD m_dwTotalAttribs;
	DWORD m_dwTotalAttribLen;
	BOOL m_fNumAttribOverride;
	BOOL m_fMsgLenOverride;
};

#endif // !defined(AFX_SESSIONCREATION_H__0DB786AB_F69D_4CD6_BC61_C671A234C602__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmping\mmping.cpp ===
// mmping.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "connection.h"
#include "httprequest.h"

void PrintRequestHeaders(CHttpRequest *pHttpRequest)
{
	LPTSTR pBuf = NULL;
	DWORD dwBufLen = 0;

	pHttpRequest->GetRequestHeaders(NULL, &dwBufLen);
	
	if(dwBufLen)
	{
		DWORD dwCurrentIndex = 0;
		INT	n = 0;

		pBuf = new TCHAR[dwBufLen];
		pHttpRequest->GetRequestHeaders(pBuf, &dwBufLen);
		_tprintf(TEXT("Request headers...\n"), dwBufLen);

		for(dwCurrentIndex = 0; dwCurrentIndex < dwBufLen; ++dwCurrentIndex)
		{
			_tprintf(TEXT("   %s\n"), pBuf + dwCurrentIndex);
			dwCurrentIndex += _tcslen(pBuf + dwCurrentIndex);
		}
	}

	pBuf ? delete [] pBuf : 0;
}

void PrintResponseHeaders(CHttpRequest *pHttpRequest)
{
	LPTSTR pBuf = NULL;
	DWORD dwBufLen = 0;

	pHttpRequest->GetResponseHeaders(NULL, &dwBufLen);
	
	if(dwBufLen)
	{
		DWORD dwCurrentIndex = 0;
		INT	n = 0;

		pBuf = new TCHAR[dwBufLen];
		pHttpRequest->GetResponseHeaders(pBuf, &dwBufLen);
		_tprintf(TEXT("Response headers...\n"), dwBufLen);

		for(dwCurrentIndex = 0; dwCurrentIndex < dwBufLen; ++dwCurrentIndex)
		{
			_tprintf(TEXT("   %s\n"), pBuf + dwCurrentIndex);
			dwCurrentIndex += _tcslen(pBuf + dwCurrentIndex);
		}
	}

	pBuf ? delete [] pBuf : 0;
}

int main(int argc, char* argv[])
{
	CConnection *pConnection;
	CHttpRequest *pHttpRequest;
	XMATCH_SESSION SessionInfo;
	DWORD dwExpectedSize = 0, dwActualSize = 0, dwOriginalID = 0, dwModifiedID = 0;
	BYTE *pRetrievedData = NULL;

	pConnection = new CConnection;
	pConnection->AddRef();
	pConnection->EstablishConnection(MMPING_AGENT_NAME, TEXT("darrenan3"), INTERNET_DEFAULT_HTTP_PORT);
	_tprintf(TEXT("Established connection...\n"));

	pHttpRequest = new CHttpRequest(pConnection);
	pHttpRequest->Initialize(TEXT("POST"), TEXT("/xmatch/xmatchhost.srf"));
	_tprintf(TEXT("Initialized request...\n"));

	if(!pHttpRequest->AddHeaders("Content-Type: application/xmatch\r\n"))
	{
		_tprintf(TEXT("AddHeaders failed with %u...\n"), GetLastError());
	}
	else
	{
		_tprintf(TEXT("AddHeaders succeeded...\n"));
	}

	SessionInfo.dwMessageLength = sizeof(XMATCH_SESSION);
	SessionInfo.dwProtocolVersion = 1;
	SessionInfo.dwTitleID = 12345;
	SessionInfo.dwSessionID = 0;
	SessionInfo.dwPublicAvailable = 10;
	SessionInfo.dwPrivateAvailable = 0;
	SessionInfo.dwNumAttributes = 0;

	pHttpRequest->SendRequest(&SessionInfo, sizeof(XMATCH_SESSION));
	_tprintf(TEXT("Sent request...\n"));

	PrintRequestHeaders(pHttpRequest);
	PrintResponseHeaders(pHttpRequest);

	pHttpRequest->GetContentLength(&dwExpectedSize);

	_tprintf(TEXT("Retrieved content length as %u\n"), dwExpectedSize);

	dwActualSize = dwExpectedSize;

	pRetrievedData = new BYTE[dwExpectedSize];
	pHttpRequest->DownloadDataToBuffer(pRetrievedData, &dwActualSize);

	if(dwActualSize == sizeof(DWORD))
	{
		_tprintf(TEXT("Retrieved data:\n"));
		dwOriginalID = *((DWORD *) pRetrievedData);
		_tprintf(TEXT("   SessionID: %u\n"), dwOriginalID);
	}
	else
	{
		_tprintf(TEXT("Retrieved data was too large (%u bytes)\n"), dwActualSize);
		goto Exit;
	}

	delete [] pRetrievedData;

// 888888888888

	delete pHttpRequest;

	pHttpRequest = new CHttpRequest(pConnection);
	pHttpRequest->Initialize(TEXT("POST"), TEXT("/xmatch/docroot/xmatchhost.srf"));
	_tprintf(TEXT("Initialized request...\n"));

	if(!pHttpRequest->AddHeaders("Content-Type: application/xmatch\r\n"))
	{
		_tprintf(TEXT("AddHeaders failed with %u...\n"), GetLastError());
	}
	else
	{
		_tprintf(TEXT("AddHeaders succeeded...\n"));
	}

	SessionInfo.dwMessageLength = sizeof(XMATCH_SESSION);
	SessionInfo.dwProtocolVersion = 1;
	SessionInfo.dwTitleID = 12345;
	SessionInfo.dwSessionID = dwOriginalID;
	SessionInfo.dwPublicAvailable = 11;
	SessionInfo.dwPrivateAvailable = 0;
	SessionInfo.dwNumAttributes = 0;

	pHttpRequest->SendRequest(&SessionInfo, sizeof(XMATCH_SESSION));
	_tprintf(TEXT("Sent request...\n"));

	PrintRequestHeaders(pHttpRequest);
	PrintResponseHeaders(pHttpRequest);

	pHttpRequest->GetContentLength(&dwExpectedSize);

	_tprintf(TEXT("Retrieved content length as %u\n"), dwExpectedSize);

	dwActualSize = dwExpectedSize;

	pRetrievedData = new BYTE[dwExpectedSize];
	pHttpRequest->DownloadDataToBuffer(pRetrievedData, &dwActualSize);

	if(dwActualSize == sizeof(DWORD))
	{
		_tprintf(TEXT("Retrieved data:\n"));
		dwModifiedID = *((DWORD *) pRetrievedData);
		_tprintf(TEXT("   SessionID: %u\n"), dwModifiedID);
	}
	else
	{
		_tprintf(TEXT("Retrieved data was too large (%u bytes)\n"), dwActualSize);
		goto Exit;
	}

	delete [] pRetrievedData;


	// Determine call type...
	// 1) Game host
	// 2) Game search

	// Determine options...
	// 1) Destination address
	// 2) Destination port (optional)
	// 3) Protocol version
	// 4) Title id

	// Game host options...
	// 5) Host address (required for game host, ignored for game search)
	// 6) Open public slots
	// 7) Open private slots
	// 8) Attributes (maybe this will allow you to point to a file that will contain the binary data)

	// Game search options...
	// 9) Query id (optional)
	// 10) Search procedure index
	// 11) Parameters (maybe this will allow you to point to a file that will contain the binary data)

Exit:
	pRetrievedData ? delete [] pRetrievedData : 0;
	pHttpRequest ? delete pHttpRequest : 0;
	pConnection ? delete pConnection : 0;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmping\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mmping.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmping\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__83988D06_8082_4632_A771_8030819B5263__INCLUDED_)
#define AFX_STDAFX_H__83988D06_8082_4632_A771_8030819B5263__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include "xmatchp.h"
#include "mmping.h"

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__83988D06_8082_4632_A771_8030819B5263__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\common\SessionCreation.cpp ===
// SessionCreation.cpp: implementation of the CSessionCreation class.
//
//////////////////////////////////////////////////////////////////////

#include "SessionCreation.h"

//////////////////////////////////////////////////////////////////////
// Helper function
//////////////////////////////////////////////////////////////////////

DWORD CreateDeleteModifySession(LPTSTR szServer, LPTSTR szObject, XMATCH_SESSION *pSessionInfo, DWORD dwInfoSize)
{
	CConnection *pConnection;
	CHttpRequest *pHttpRequest;
	DWORD dwExpectedSize = 0, dwActualSize = 0, dwSessionID = 0, dwStatusCode = 0;
	BYTE *pRetrievedData = NULL;
	BOOL fFailed = FALSE;

	pConnection = new CConnection;
	pConnection->AddRef();
	pConnection->EstablishConnection(MMTEST_AGENT_NAME, szServer, INTERNET_DEFAULT_HTTP_PORT);

	pHttpRequest = new CHttpRequest(pConnection);
	pHttpRequest->Initialize(TEXT("POST"), szObject);
	pHttpRequest->AddHeaders("Content-Type: application/xmatch\r\n");
	pHttpRequest->SendRequest(pSessionInfo, dwInfoSize);
	pHttpRequest->GetStatusCode(&dwStatusCode);

	if(dwStatusCode != 200)
	{
		_tprintf(TEXT("Session creation returned failure (status %u)\n"), dwStatusCode);
		fFailed = TRUE;
	}

	pHttpRequest->GetContentLength(&dwExpectedSize);

	dwActualSize = dwExpectedSize;

	if(dwExpectedSize)
	{
		
		pRetrievedData = new BYTE[dwExpectedSize];
		pHttpRequest->DownloadDataToBuffer(pRetrievedData, &dwActualSize);
		
		// If this is an error return code, display it
		if(fFailed)
		{
			if((dwActualSize != 4) && (dwActualSize != 8))
			{
				_tprintf(TEXT("Received unexpected error message of size %u\n"), dwActualSize);
			}
			else
			{
				switch(*((DWORD *) pRetrievedData))
				{
				case X_REQ_ERROR_INVALID_SESSION_ID:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_SESSION_ID returned\n"));
					break;
				case X_REQ_ERROR_INVALID_TITLE_ID:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_TITLE_ID returned\n"));
					break;
				case X_REQ_ERROR_INVALID_DATA_TYPE:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_DATA_TYPE returned\n"));
					break;
				case X_REQ_ERROR_REQUEST_TOO_SMALL:
					_tprintf(TEXT("X_REQ_ERROR_REQUEST_TOO_SMALL returned\n"));
					break;
				case X_REQ_ERROR_REQUEST_TRUNCATED:
					_tprintf(TEXT("X_REQ_ERROR_REQUEST_TRUNCATED returned\n"));
					break;
				case X_REQ_ERROR_INVALID_SEARCH_REQ:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_SEARCH_REQ returned\n"));
					break;
				case X_REQ_ERROR_INVALID_OFFSET:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_OFFSET returned\n"));
					break;
				case X_REQ_ERROR_INVALID_ATTR_TYPE:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_ATTR_TYPE returned\n"));
					break;
				case X_REQ_ERROR_INVALID_VERSION:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_VERSION returned\n"));
					break;
				case X_REQ_ERROR_OVERFLOW:
					_tprintf(TEXT("X_REQ_ERROR_OVERFLOW returned\n"));
					break;
				case X_REQ_ERROR_INVALID_RESULT_COL:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_RESULT_COL returned\n"));
					break;
				case X_REQ_ERROR_INVALID_STRING:
					_tprintf(TEXT("X_REQ_ERROR_INVALID_STRING returned\n"));
					break;
				default:
					_tprintf(TEXT("Unknown error returned\n"));
					break;
				}
			}
		}
		// If this was a session modification or deletion, then we aren't expecting a new session ID to be returned
		else if((dwInfoSize >= sizeof(XMATCH_SESSION)) && (pSessionInfo->dwSessionID))
		{
			_tprintf(TEXT("Retrieved data was of unexpected size (%u bytes)\n"), dwActualSize);
			if(dwActualSize < 100)
				_tprintf(TEXT("   %s\n"), pRetrievedData);
		}
		// If this was a new session creation, then we're expecting a new session ID
		else
		{
			
			if(dwActualSize == sizeof(DWORD))
			{
				_tprintf(TEXT("Retrieved data:\n"));
				dwSessionID = *((DWORD *) pRetrievedData);
				_tprintf(TEXT("   SessionID: %u\n"), dwSessionID);
				
			}
			else
			{
				_tprintf(TEXT("Retrieved data was of unexpected size (%u bytes)\n"), dwActualSize);
				if(dwActualSize < 100)
					_tprintf(TEXT("   %s\n"), pRetrievedData);
			}
		}
		
		pRetrievedData ? delete [] pRetrievedData : 0;
		pRetrievedData = NULL;
	}

	pRetrievedData ? delete [] pRetrievedData : 0;
	pHttpRequest ? delete pHttpRequest : 0;
	pConnection ? delete pConnection : 0;

	return dwSessionID;

}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSessionCreation::CSessionCreation()
{
	m_fMsgLenOverride = FALSE;
	m_fNumAttribOverride = FALSE;
	m_pBuffer = NULL;
	m_dwBufferLen = 0;
	m_dwTotalAttribs = 0;
	m_dwTotalAttribLen = 0;
	m_pAttribList = NULL;
}

CSessionCreation::~CSessionCreation()
{
	PATTRIB_LIST pCurr = m_pAttribList, pTemp = NULL;

	// Release the attributes list
	while(pCurr)
	{
		pTemp = pCurr;
		pCurr = pTemp->pNext;

		pTemp->pAttribBuffer ? delete [] pTemp->pAttribBuffer : 0;
		delete pTemp;
	}

	// Release the request buffer
	m_pBuffer ? delete [] m_pBuffer : 0;
}

BOOL CSessionCreation::Initialize(DWORD dwBufferLen)
{
	PATTRIB_LIST pCurr = m_pAttribList, pTemp = NULL;

	// Release the attributes list
	while(pCurr)
	{
		pTemp = pCurr;
		pCurr = pTemp->pNext;

		pTemp->pAttribBuffer ? delete [] pTemp->pAttribBuffer : 0;
		delete pTemp;
	}

	// Reset the attribute tracking variables
	m_dwTotalAttribs = 0;
	m_dwTotalAttribLen = 0;
	m_pAttribList = NULL;

	// Reset the override variables
	m_fMsgLenOverride = FALSE;
	m_fNumAttribOverride = FALSE;

	// Release the request buffer and allocate a new one
	m_pBuffer ? delete [] m_pBuffer : 0;

	if(!dwBufferLen)
	{
		m_dwBufferLen = 0;
		return TRUE;
	}

	m_pBuffer = new BYTE[dwBufferLen];
	if(!m_pBuffer)
		return FALSE;

	m_dwBufferLen = dwBufferLen;

	// Set default values only if the session request is of valid size
	if(dwBufferLen >= sizeof(XMATCH_SESSION))
	{
		((XMATCH_SESSION *) m_pBuffer)->dwMessageLength = sizeof(XMATCH_SESSION);
		((XMATCH_SESSION *) m_pBuffer)->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
		((XMATCH_SESSION *) m_pBuffer)->dwTitleID = 1;
		((XMATCH_SESSION *) m_pBuffer)->dwSessionID = 0;
		memset(((XMATCH_SESSION *) m_pBuffer)->bHostAddress, 0xAA, 32 * sizeof(BYTE));
		((XMATCH_SESSION *) m_pBuffer)->dwPublicAvailable = 10;
		((XMATCH_SESSION *) m_pBuffer)->dwPrivateAvailable = 0;
		((XMATCH_SESSION *) m_pBuffer)->dwNumAttributes = 0;
	}

	return TRUE;
}
    
BOOL CSessionCreation::SetProtocolVersion(DWORD dwProtocolVersion)
{
	if(!m_pBuffer || m_dwBufferLen < (2 * sizeof(DWORD)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwProtocolVersion = dwProtocolVersion;

	return TRUE;
}

BOOL CSessionCreation::SetMessageLength(DWORD dwMessageLength)
{
	if(!m_pBuffer || m_dwBufferLen < (1 * sizeof(DWORD)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwMessageLength = dwMessageLength;
	m_fMsgLenOverride = TRUE;

	return TRUE;
}

BOOL CSessionCreation::SetTitleID(DWORD dwTitleID)
{
	if(!m_pBuffer || m_dwBufferLen < (3 * sizeof(DWORD)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwTitleID = dwTitleID;

	return TRUE;
}

BOOL CSessionCreation::SetSessionID(DWORD dwSessionID)
{
	if(!m_pBuffer || m_dwBufferLen < (4 * sizeof(DWORD)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwSessionID = dwSessionID;

	return TRUE;
}

BOOL CSessionCreation::SetPublicAvailable(DWORD dwPublicAvailable)
{
	if(!m_pBuffer || m_dwBufferLen < (5 * sizeof(DWORD) + 32 * sizeof(BYTE)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwPublicAvailable = dwPublicAvailable;

	return TRUE;

}

BOOL CSessionCreation::SetPrivateAvailable(DWORD dwPrivateAvailable)
{
	if(!m_pBuffer || m_dwBufferLen < (6 * sizeof(DWORD) + 32 * sizeof(BYTE)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwPrivateAvailable = dwPrivateAvailable;

	return TRUE;
}

BOOL CSessionCreation::SetNumAttributes(DWORD dwNumAttributes)
{
	if(!m_pBuffer || m_dwBufferLen < (7 * sizeof(DWORD) + 32 * sizeof(BYTE)))
		return FALSE;

	((XMATCH_SESSION *) m_pBuffer)->dwNumAttributes = dwNumAttributes;
	m_fNumAttribOverride = TRUE;

	return TRUE;
}

DWORD CSessionCreation::SendRequest(LPTSTR szServer, LPTSTR szObject)
{
	PATTRIB_LIST pCurrentAttrib = NULL;
	PBYTE pAttribIndex = NULL;
	DWORD dwCopiedAttribLen = 0, dwCurrentOffset = 0;

	// Update the header values unless they were overridden
	if(m_dwBufferLen >= sizeof(XMATCH_SESSION))
	{
		if(!m_fNumAttribOverride)
		{
			((XMATCH_SESSION *) m_pBuffer)->dwNumAttributes = m_dwTotalAttribs;
		}

		if(!m_fMsgLenOverride)
		{
			m_dwBufferLen = sizeof(XMATCH_SESSION) + m_dwTotalAttribs * sizeof(DWORD) + m_dwTotalAttribLen;
			((XMATCH_SESSION *) m_pBuffer)->dwMessageLength = m_dwBufferLen;
		}
	}

	// Add each attribute to the final buffer;
	pCurrentAttrib = m_pAttribList;
	for(DWORD i = 0; i < m_dwTotalAttribs; ++i)
	{
		pAttribIndex = m_pBuffer + sizeof(XMATCH_SESSION) + i * sizeof(DWORD);

		dwCurrentOffset = sizeof(XMATCH_SESSION) + m_dwTotalAttribs * sizeof(DWORD) + dwCopiedAttribLen;
		*((DWORD *) pAttribIndex) = dwCurrentOffset;

		memcpy(m_pBuffer + dwCurrentOffset, pCurrentAttrib->pAttribBuffer, pCurrentAttrib->dwAttribLen);
		dwCopiedAttribLen += pCurrentAttrib->dwAttribLen;
		pCurrentAttrib = pCurrentAttrib->pNext;
	}

	return CreateDeleteModifySession(szServer, szObject, (XMATCH_SESSION *) m_pBuffer, m_dwBufferLen);
}

DWORD CSessionCreation::SendRawRequest(LPTSTR szServer, LPTSTR szObject)
{
	return CreateDeleteModifySession(szServer, szObject, (XMATCH_SESSION *) m_pBuffer, m_dwBufferLen);
}

BOOL CSessionCreation::AddAttribute(DWORD dwAttribID, DWORD dwAttribLen, LPBYTE pBuffer)
{
	PATTRIB_LIST pAttribList = NULL;
	PBYTE pAttribIndex = NULL;
	DWORD dwNewHeaderAndOffsetLen = 0, dwNewTotalAttribLen = 0;
	
	if(!m_pBuffer || m_dwBufferLen < sizeof(XMATCH_SESSION))
		return FALSE;

	// Add the size of the length-prefix
	if(dwAttribID & X_ATTRIBUTE_DATATYPE_STRING)
	{
		if(dwAttribLen > MAXWORD)
			return FALSE;
		
		dwNewTotalAttribLen += sizeof(WORD);
	}
	else if(dwAttribID & X_ATTRIBUTE_DATATYPE_BLOB)
	{
		dwNewTotalAttribLen += sizeof(DWORD);
	}
	
	// Add the size of attributes and their attribute ID's
	dwNewTotalAttribLen += m_dwTotalAttribLen + sizeof(DWORD) + dwAttribLen;
	
	// Add the size of the attribute offsets required
	dwNewHeaderAndOffsetLen += sizeof(XMATCH_SESSION) + ((m_dwTotalAttribs + 1) * sizeof(DWORD));
	
	// Verify there is enough room to accomodate the new attribute
	if(dwNewHeaderAndOffsetLen + dwNewTotalAttribLen > m_dwBufferLen)
		return FALSE;
	
	// Allocate a new attribute and copies the attribute data into it
	pAttribList = new ATTRIB_LIST;
	
	// Insertion varies depending on type
	if(dwAttribID & X_ATTRIBUTE_DATATYPE_STRING)
	{
		pAttribList->dwAttribLen = dwAttribLen + 1 * sizeof(DWORD) + 1 * sizeof(WORD);
		pAttribList->pAttribBuffer = new BYTE[pAttribList->dwAttribLen];
		pAttribIndex = pAttribList->pAttribBuffer;
		
		// Copy the attribute ID
		*((DWORD *) pAttribIndex) = dwAttribID;
		pAttribIndex += sizeof(DWORD);
		
		// Copy the string length prefix
		*((WORD *) pAttribIndex) = (WORD) (0x0000FFFF & dwAttribLen);
		pAttribIndex += sizeof(WORD);
		
		// Copy the string value
		memcpy(pAttribIndex, pBuffer, dwAttribLen);
	}
	else if(dwAttribID & X_ATTRIBUTE_DATATYPE_BLOB)
	{
		pAttribList->dwAttribLen = dwAttribLen + 2 * sizeof(DWORD);
		pAttribList->pAttribBuffer = new BYTE[pAttribList->dwAttribLen];
		pAttribIndex = pAttribList->pAttribBuffer;
		
		// Copy the attribute ID
		*((DWORD *) pAttribIndex) = dwAttribID;
		pAttribIndex += sizeof(DWORD);
		
		// Copy the string length prefix
		*((DWORD *) pAttribIndex) = dwAttribLen;
		pAttribIndex += sizeof(DWORD);
		
		// Copy the string value
		memcpy(pAttribIndex, pBuffer, dwAttribLen);
	}
	else
	{
		pAttribList->dwAttribLen = dwAttribLen + 1 * sizeof(DWORD);
		pAttribList->pAttribBuffer = new BYTE[pAttribList->dwAttribLen];
		pAttribIndex = pAttribList->pAttribBuffer;
		
		// Copy the attribute ID
		*((DWORD *) pAttribIndex) = dwAttribID;
		pAttribIndex += sizeof(DWORD);
		
		// Copy the integer value
		memcpy(pAttribIndex, pBuffer, dwAttribLen);
	}
	
	// Insert the attribute entry into the list
	pAttribList->pNext = m_pAttribList;
	m_pAttribList = pAttribList;
	
	// Increment the length tracking variables
	++m_dwTotalAttribs;
	m_dwTotalAttribLen = dwNewTotalAttribLen;
	
	return TRUE;
}

BOOL CSessionCreation::AddPlayerAttribute(DWORD dwAttribID, LONGLONG qwPlayerID, DWORD dwAttribLen, LPBYTE pBuffer)
{
	PATTRIB_LIST pAttribList = NULL;
	PBYTE pAttribIndex = NULL;
	DWORD dwNewHeaderAndOffsetLen = 0, dwNewTotalAttribLen = 0;

	if(!m_pBuffer || m_dwBufferLen < sizeof(XMATCH_SESSION))
		return FALSE;

	// Add the size of the length-prefix
	if(dwAttribID & X_ATTRIBUTE_DATATYPE_STRING)
	{
		if(dwAttribLen > MAXWORD)
			return FALSE;
		
		dwNewTotalAttribLen += sizeof(WORD);
	}
	else if(dwAttribID & X_ATTRIBUTE_DATATYPE_BLOB)
	{
		dwNewTotalAttribLen += sizeof(DWORD);
	}
	
	// Add the size of attributes and their attribute ID's
	dwNewTotalAttribLen += m_dwTotalAttribLen + sizeof(DWORD) + dwAttribLen + sizeof(LONGLONG);
	
	// Add the size of the attribute offsets required
	dwNewHeaderAndOffsetLen += sizeof(XMATCH_SESSION) + ((m_dwTotalAttribs + 1) * sizeof(DWORD));
	
	// Verify there is enough room to accomodate the new attribute
	if(dwNewHeaderAndOffsetLen + dwNewTotalAttribLen > m_dwBufferLen)
		return FALSE;
	
	// Allocate a new attribute and copies the attribute data into it
	pAttribList = new ATTRIB_LIST;
	
	// Insertion varies depending on type
	if(dwAttribID & X_ATTRIBUTE_DATATYPE_STRING)
	{
		pAttribList->dwAttribLen = dwAttribLen + 1 * sizeof(DWORD) + 1 * sizeof(WORD) + sizeof(LONGLONG);
		pAttribList->pAttribBuffer = new BYTE[pAttribList->dwAttribLen];
		pAttribIndex = pAttribList->pAttribBuffer;
		
		// Copy the attribute ID
		*((DWORD *) pAttribIndex) = dwAttribID;
		pAttribIndex += sizeof(DWORD);

		// Copy the player ID
		*((LONGLONG *) pAttribIndex) = qwPlayerID;
		pAttribIndex += sizeof(LONGLONG);

		// Copy the string length prefix
		*((WORD *) pAttribIndex) = (WORD) (0x0000FFFF & dwAttribLen);
		pAttribIndex += sizeof(WORD);
		
		// Copy the string value
		memcpy(pAttribIndex, pBuffer, dwAttribLen);
	}
	else if(dwAttribID & X_ATTRIBUTE_DATATYPE_BLOB)
	{
		pAttribList->dwAttribLen = dwAttribLen + 2 * sizeof(DWORD) + sizeof(LONGLONG);
		pAttribList->pAttribBuffer = new BYTE[pAttribList->dwAttribLen];
		pAttribIndex = pAttribList->pAttribBuffer;
		
		// Copy the attribute ID
		*((DWORD *) pAttribIndex) = dwAttribID;
		pAttribIndex += sizeof(DWORD);
		
		// Copy the player ID
		*((LONGLONG *) pAttribIndex) = qwPlayerID;
		pAttribIndex += sizeof(LONGLONG);

		// Copy the string length prefix
		*((DWORD *) pAttribIndex) = dwAttribLen;
		pAttribIndex += sizeof(DWORD);
		
		// Copy the string value
		memcpy(pAttribIndex, pBuffer, dwAttribLen);
	}
	else
	{
		pAttribList->dwAttribLen = dwAttribLen + 1 * sizeof(DWORD) + sizeof(LONGLONG);
		pAttribList->pAttribBuffer = new BYTE[pAttribList->dwAttribLen];
		pAttribIndex = pAttribList->pAttribBuffer;
		
		// Copy the attribute ID
		*((DWORD *) pAttribIndex) = dwAttribID;
		pAttribIndex += sizeof(DWORD);

		// Copy the player ID
		*((LONGLONG *) pAttribIndex) = qwPlayerID;
		pAttribIndex += sizeof(LONGLONG);

		// Copy the integer value
		memcpy(pAttribIndex, pBuffer, dwAttribLen);
	}
	
	// Insert the attribute entry into the list
	pAttribList->pNext = m_pAttribList;
	m_pAttribList = pAttribList;
	
	// Increment the length tracking variables
	++m_dwTotalAttribs;
	m_dwTotalAttribLen = dwNewTotalAttribLen;
	
	return TRUE;	
}

BOOL CSessionCreation::SetHostAddress(LPBYTE pHostAddress)
{
	if(!m_pBuffer || m_dwBufferLen < (4 * sizeof(DWORD) + 32 * sizeof(BYTE)))
		return FALSE;
	
	memcpy(((XMATCH_SESSION *) m_pBuffer)->bHostAddress, pHostAddress, 32 * sizeof(BYTE));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmtest\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mmtest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmtest\mmtest.h ===
// mmtest.h : Defines various global defaults for the mmtest program
//
#define DEFAULT_SERVER			TEXT("darrenan3")
#define CREATESESSION_OBJECT	TEXT("/xmatch/xmatchhost.srf")
#define DELETESESSION_OBJECT	TEXT("/xmatch/xmatchhost.srf?d=1")
#define QUERYSESSION_OBJECT		TEXT("/xmatch/xmatchclient.srf")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatchparse\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xtpparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmtest\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__66C80881_2A13_479A_845F_189F3E638A5C__INCLUDED_)
#define AFX_STDAFX_H__66C80881_2A13_479A_845F_189F3E638A5C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "xmatchp.h"
#include "mmtest.h"

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__66C80881_2A13_479A_845F_189F3E638A5C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatchparse\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__26CD47E5_A4BD_46EF_A809_C0A208E5CCBC__INCLUDED_)
#define AFX_STDAFX_H__26CD47E5_A4BD_46EF_A809_C0A208E5CCBC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <stdio.h>
#include <winsock.h>
#include <netmon.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__26CD47E5_A4BD_46EF_A809_C0A208E5CCBC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatch\mmtest\mmtest.cpp ===
// mmtest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "connection.h"
#include "httprequest.h"
#include "sessioncreation.h"

void PrintRequestHeaders(CHttpRequest *pHttpRequest)
{
	LPTSTR pBuf = NULL;
	DWORD dwBufLen = 0;

	pHttpRequest->GetRequestHeaders(NULL, &dwBufLen);
	
	if(dwBufLen)
	{
		DWORD dwCurrentIndex = 0;
		INT	n = 0;

		pBuf = new TCHAR[dwBufLen];
		pHttpRequest->GetRequestHeaders(pBuf, &dwBufLen);
		_tprintf(TEXT("Request headers...\n"), dwBufLen);

		for(dwCurrentIndex = 0; dwCurrentIndex < dwBufLen; ++dwCurrentIndex)
		{
			_tprintf(TEXT("   %s\n"), pBuf + dwCurrentIndex);
			dwCurrentIndex += _tcslen(pBuf + dwCurrentIndex);
		}
	}

	pBuf ? delete [] pBuf : 0;
}

void PrintResponseHeaders(CHttpRequest *pHttpRequest)
{
	LPTSTR pBuf = NULL;
	DWORD dwBufLen = 0;

	pHttpRequest->GetResponseHeaders(NULL, &dwBufLen);
	
	if(dwBufLen)
	{
		DWORD dwCurrentIndex = 0;
		INT	n = 0;

		pBuf = new TCHAR[dwBufLen];
		pHttpRequest->GetResponseHeaders(pBuf, &dwBufLen);
		_tprintf(TEXT("Response headers...\n"), dwBufLen);

		for(dwCurrentIndex = 0; dwCurrentIndex < dwBufLen; ++dwCurrentIndex)
		{
			_tprintf(TEXT("   %s\n"), pBuf + dwCurrentIndex);
			dwCurrentIndex += _tcslen(pBuf + dwCurrentIndex);
		}
	}

	pBuf ? delete [] pBuf : 0;
}

BOOL ParseSearchResults(BYTE *pBuffer, DWORD dwBufferSize)
{
	XMATCH_SEARCHRESULT *pCurrentResult = NULL;
	DWORD dwResultCounter = 1, dwRemainingBuffer = dwBufferSize, dwCurrentResultLength = 0;
	BYTE *pResultsIndex = pBuffer;
	BOOL fRet = TRUE;

	_tprintf(TEXT("Results:\n"));
	_tprintf(TEXT("  TotalSize %u\n"), dwBufferSize);

	while(dwRemainingBuffer >= sizeof(XMATCH_SEARCHRESULT))
	{
		_tprintf(TEXT("   Search result %u\n"), dwResultCounter);

		pCurrentResult = (XMATCH_SEARCHRESULT *) pResultsIndex;
		dwCurrentResultLength = pCurrentResult->dwResultLength;
		_tprintf(TEXT("      Result length: %u\n"), dwCurrentResultLength);
		_tprintf(TEXT("      Session ID: %u\n"), pCurrentResult->dwSessionID);
		_tprintf(TEXT("      HostAddress1: 0x%08x%08x\n"),
			*((DWORD *) &(pCurrentResult->bHostAddress[0])),
			*((DWORD *) &(pCurrentResult->bHostAddress[4])));
		_tprintf(TEXT("      HostAddress2: 0x%08x%08x\n"),
			*((DWORD *) &(pCurrentResult->bHostAddress[8])),
			*((DWORD *) &(pCurrentResult->bHostAddress[12])));
		_tprintf(TEXT("      HostAddress3: 0x%08x%08x\n"),
			*((DWORD *) &(pCurrentResult->bHostAddress[16])),
			*((DWORD *) &(pCurrentResult->bHostAddress[20])));
		_tprintf(TEXT("      HostAddress4: 0x%08x%08x\n"),
			*((DWORD *) &(pCurrentResult->bHostAddress[24])),
			*((DWORD *) &(pCurrentResult->bHostAddress[28])));
		_tprintf(TEXT("      Public Available: %u\n"), pCurrentResult->dwPublicAvailable);
		_tprintf(TEXT("      Private Available: %u\n"), pCurrentResult->dwPrivateAvailable);
		_tprintf(TEXT("      Num Attributes: %u\n"), pCurrentResult->dwNumAttributes);

		++dwResultCounter;
		if(pCurrentResult->dwResultLength > dwRemainingBuffer)
		{
			_tprintf(TEXT("Current result is larger than available data!\n"));
			dwRemainingBuffer = 0;
			break;
		}
		dwRemainingBuffer -= pCurrentResult->dwResultLength;
	}

	if(dwRemainingBuffer)
	{
		_tprintf(TEXT("%u bytes of unused data present at end of results list!\n"), dwRemainingBuffer);
		fRet = FALSE;
	}

	return fRet;
}


DWORD QuerySession(LPTSTR szServer, LPTSTR szObject, XMATCH_SEARCH *pSearchInfo, DWORD dwInfoSize, BYTE **ppBuffer)
{
	CConnection *pConnection;
	CHttpRequest *pHttpRequest;
	DWORD dwExpectedSize = 0, dwActualSize = 0, dwStatusCode = 0;
	BOOL fFailed = FALSE;

	pConnection = new CConnection;
	pConnection->AddRef();
	pConnection->EstablishConnection(MMTEST_AGENT_NAME, szServer, INTERNET_DEFAULT_HTTP_PORT);

	pHttpRequest = new CHttpRequest(pConnection);
	pHttpRequest->Initialize(TEXT("POST"), szObject);
	pHttpRequest->AddHeaders("Content-Type: application/xmatch\r\n");
	pHttpRequest->SendRequest(pSearchInfo, dwInfoSize);
	pHttpRequest->GetStatusCode(&dwStatusCode);

	if(dwStatusCode != 200)
	{
		_tprintf(TEXT("Query returned failure (status %u)\n"), dwStatusCode);
		dwActualSize = 0;
		fFailed = TRUE;
	}

	pHttpRequest->GetContentLength(&dwExpectedSize);

	if(dwExpectedSize)
	{
		// We received a content length, header so use that
		_tprintf(TEXT("Retrieved content length as %u\n"), dwExpectedSize);
		dwActualSize = dwExpectedSize;
		*ppBuffer = new BYTE[dwExpectedSize];
	}
	else
	{
		// If we didn't get a content length, then just return the first 10 results
		_tprintf(TEXT("Server didn't return a content length.  Will only allow 10 results.\n"));
		dwActualSize = sizeof(XMATCH_SEARCHRESULT) * 10;
	    *ppBuffer = new BYTE[sizeof(XMATCH_SEARCHRESULT) * 10];
	}


	pHttpRequest->DownloadDataToBuffer(*ppBuffer, &dwActualSize);
		
	if(fFailed)
	{
		if((dwActualSize != 4) && (dwActualSize != 8))
		{
			_tprintf(TEXT("Received unexpected error message of size %u\n"), dwActualSize);
		}
		else
		{
			switch(*((DWORD *) *ppBuffer))
			{
			case X_REQ_ERROR_INVALID_SESSION_ID:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_SESSION_ID returned\n"));
				break;
			case X_REQ_ERROR_INVALID_TITLE_ID:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_TITLE_ID returned\n"));
				break;
			case X_REQ_ERROR_INVALID_DATA_TYPE:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_DATA_TYPE returned\n"));
				break;
			case X_REQ_ERROR_REQUEST_TOO_SMALL:
				_tprintf(TEXT("X_REQ_ERROR_REQUEST_TOO_SMALL returned\n"));
				break;
			case X_REQ_ERROR_REQUEST_TRUNCATED:
				_tprintf(TEXT("X_REQ_ERROR_REQUEST_TRUNCATED returned\n"));
				break;
			case X_REQ_ERROR_INVALID_SEARCH_REQ:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_SEARCH_REQ returned\n"));
				break;
			case X_REQ_ERROR_INVALID_OFFSET:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_OFFSET returned\n"));
				break;
			case X_REQ_ERROR_INVALID_ATTR_TYPE:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_ATTR_TYPE returned\n"));
				break;
			case X_REQ_ERROR_INVALID_VERSION:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_VERSION returned\n"));
				break;
			case X_REQ_ERROR_OVERFLOW:
				_tprintf(TEXT("X_REQ_ERROR_OVERFLOW returned\n"));
				break;
			case X_REQ_ERROR_INVALID_RESULT_COL:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_RESULT_COL returned\n"));
				break;
			case X_REQ_ERROR_INVALID_STRING:
				_tprintf(TEXT("X_REQ_ERROR_INVALID_STRING returned\n"));
				break;
			default:
				_tprintf(TEXT("Unknown error returned\n"));
				break;
			}
		}
	}
	
	else if(dwExpectedSize && (dwActualSize != dwExpectedSize))
	{
		_tprintf(TEXT("Unexpected data size returned (%u != %u)\n"), dwActualSize, dwExpectedSize);
		if(dwActualSize > dwExpectedSize)
		{
			dwActualSize = dwExpectedSize;
		}
	}
	
	pHttpRequest ? delete pHttpRequest : 0;
	pConnection ? delete pConnection : 0;

	return dwActualSize;
}

void RunSessionCreationTests(LPTSTR szServerName)
{
	BYTE Buffer[sizeof(XMATCH_SESSION) + 500], Blob[100], *pResults = NULL;
	XMATCH_SESSION *pSessionInfo = (XMATCH_SESSION *) Buffer;
	XMATCH_SEARCH *pSearchInfo = (XMATCH_SEARCH *) Buffer;
	BYTE *pAttribPointer = NULL, *pParamPointer = NULL, *pLargeBuffer = NULL;
	DWORD dwSessionID = 0, dwResultsSize = 0;
	INT nIntAttribute = 0;

	memset(Blob, 'z', 100 * sizeof(BYTE));

	CSessionCreation *pCreateRequest = NULL;

/*
	// ------------------------------------------
	// Message length longer than available bytes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Message length longer than available bytes\n"));

	pCreateRequest = new CSessionCreation();
	pCreateRequest->Initialize(sizeof(XMATCH_SESSION));

	((XMATCH_SESSION *) pCreateRequest->m_pBuffer)->dwMessageLength = sizeof(XMATCH_SESSION) + 10;
	
	pCreateRequest->SendRawRequest(szServerName, CREATESESSION_OBJECT);
	delete pCreateRequest;
	pCreateRequest = NULL;

	// ------------------------------------------
	// Message length only one byte
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Message length only one byte\n"));

	Buffer[0] = 255;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, (XMATCH_SESSION *) Buffer, 1);

	// ------------------------------------------
	// Title ID unknown
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Title ID unknown\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 0xAAAAAAAA;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Max title ID
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Max title ID\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 0xFFFFFFFF;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Message length shorter than sizeof(XMATCH_SESSION)
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Message length shorter than sizeof(XMATCH_SESSION)\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Unknown protocol version
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Unknown protocol version\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION + 1;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// No public or private slots available
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("No public or private slots available\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 0;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Use attib offset inside session header
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Use attib offset inside session header\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Use attib offset beyond available
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Use attib offset beyond available\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = 10000;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Use attrib offset equal to current offset
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Use attrib offset equal to current offset\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION);

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Indicate more attributes than available
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Indicate more attributes than available\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Create session with no attributes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with no attributes\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search where returned session will have no attributes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have no attributes\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 5;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with no attributes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with no attributes\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with no attributes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with no attributes\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 5;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Create session with a global session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global session integer attribute\n"));

	pCreateRequest = new CSessionCreation();
	pCreateRequest->Initialize(500);

	nIntAttribute = SAMPLE_ATTRIB1_INT;
	pCreateRequest->AddAttribute(X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID) ,sizeof(DWORD), (BYTE *) &nIntAttribute);
	
	dwSessionID = pCreateRequest->SendRequest(szServerName, CREATESESSION_OBJECT);
	_tprintf(TEXT("Session %u created\n"), dwSessionID);
	delete pCreateRequest;
	pCreateRequest = NULL;

  
	// ------------------------------------------
	// Search where returned session will have a global session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have a global session integer attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 7;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with global session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with global session integer attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with global session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with global session integer attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 7;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Create session with a global session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global session string attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD) + strlen(SAMPLE_ATTRIB1_STRING) + 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((WORD *) pAttribPointer) = strlen(SAMPLE_ATTRIB1_STRING) + 1;

	pAttribPointer += sizeof(WORD);
	strcpy((char *) pAttribPointer, SAMPLE_ATTRIB1_STRING);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Search where returned session will have a global session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have a global session string attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 8;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with global session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with global session string attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with global session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with global session string attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 8;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;

	
	// ------------------------------------------
	// Create session with a global session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global session blob attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + 100;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = 100;

	pAttribPointer += sizeof(DWORD);
	memcpy((char *) pAttribPointer, Blob, 100);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Search where returned session will have a global session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have a global session blob attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 9;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with global session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with global session blob attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with global session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with global session blob attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 9;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Create session with a title-specific session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a title-specific session integer attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = SAMPLE_ATTRIB1_INT;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Search where returned session will have a title-specific session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have a title-specific session integer attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 7;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with title-specific session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with title-specific session integer attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with title-specific session integer attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with title-specific session integer attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 7;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Create session with a title-specific session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a title-specific session string attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD) + strlen(SAMPLE_ATTRIB1_STRING) + 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((WORD *) pAttribPointer) = strlen(SAMPLE_ATTRIB1_STRING) + 1;

	pAttribPointer += sizeof(WORD);
	strcpy((char *) pAttribPointer, SAMPLE_ATTRIB1_STRING);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Search where returned session will have a title-specific session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have a title-specific session string attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 8;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with title-specific session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with title-specific session string attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with title-specific session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with title-specific session string attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 8;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Create session with a title-specific session blob attribute attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a title-specific session blob attribute attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + 100;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = 100;

	pAttribPointer += sizeof(DWORD);
	memcpy((char *) pAttribPointer, Blob, 100);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Search where returned session will have a title-specific session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search where returned session will have a title-specific session blob attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 9;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
		ParseSearchResults(pResults, dwResultsSize);
	else
		_tprintf(TEXT("FAIL:  Search didn't return expected session!\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Delete session with title-specific session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Delete session with title-specific session blob attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));


	// ------------------------------------------
	// Search for deleted session with title-specific session blob attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search for deleted session with title-specific session blob attribute\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 9;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = dwSessionID;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		_tprintf(TEXT("FAIL:  Search returned deleted session!\n"));
		ParseSearchResults(pResults, dwResultsSize);
	}
	else
		_tprintf(TEXT("Search didn't report deleted session\n"));

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Create session with a global user integer attribute without PUID
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global user integer attribute without PUID\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = SAMPLE_ATTRIB1_INT;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Create session with a global user integer attribute for non-existent user
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global user integer attribute for non-existent user\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + 1 * sizeof(LONGLONG);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((LONGLONG *) pAttribPointer) = SAMPLE_PUID1;

	pAttribPointer += sizeof(LONGLONG);
	*((DWORD *) pAttribPointer) = SAMPLE_ATTRIB1_INT;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Create session with a global user string attribute for non-existent user
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global user string attribute for non-existent user\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + 1 * sizeof(LONGLONG) + sizeof(WORD) + strlen(SAMPLE_ATTRIB1_STRING) + 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((LONGLONG *) pAttribPointer) = SAMPLE_PUID1;

	pAttribPointer += sizeof(LONGLONG);
	*((WORD *) pAttribPointer) = strlen(SAMPLE_ATTRIB1_STRING) + 1;

	pAttribPointer += sizeof(WORD);
	strcpy((char *) pAttribPointer, SAMPLE_ATTRIB1_STRING);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Create session with a global user blob attribute attribute for non-existent user
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global user blob attribute attribute for non-existent user\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + 1 * sizeof(LONGLONG) + 100;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((LONGLONG *) pAttribPointer) = SAMPLE_PUID1;

	pAttribPointer += sizeof(LONGLONG);
	*((DWORD *) pAttribPointer) = 100;

	pAttribPointer += sizeof(DWORD);
	memcpy((char *) pAttribPointer, Blob, 100);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Create session with a title-specific user integer attribute for non-existent user
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a title-specific user integer attribute for non-existent user\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + 1 * sizeof(LONGLONG);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_INTEGER |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((LONGLONG *) pAttribPointer) = SAMPLE_PUID1;

	pAttribPointer += sizeof(LONGLONG);
	*((DWORD *) pAttribPointer) = SAMPLE_ATTRIB1_INT;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Create session with a title-specific user string attribute for non-existent user
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a title-specific user string attribute for non-existent user\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + 1 * sizeof(LONGLONG) + sizeof(WORD) + strlen(SAMPLE_ATTRIB1_STRING) + 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((LONGLONG *) pAttribPointer) = SAMPLE_PUID1;

	pAttribPointer += sizeof(LONGLONG);
	*((WORD *) pAttribPointer) = strlen(SAMPLE_ATTRIB1_STRING) + 1;

	pAttribPointer += sizeof(WORD);
	strcpy((char *) pAttribPointer, SAMPLE_ATTRIB1_STRING);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	// ------------------------------------------
	// Create session with a title-specific user blob attribute attribute for non-existent user
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a title-specific user blob attribute attribute for non-existent user\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + 1 * sizeof(LONGLONG) + 100;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_USER | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((LONGLONG *) pAttribPointer) = SAMPLE_PUID1;

	pAttribPointer += sizeof(LONGLONG);
	*((DWORD *) pAttribPointer) = 100;

	pAttribPointer += sizeof(DWORD);
	memcpy((char *) pAttribPointer, Blob, 100);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Create session with an empty global session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with an empty global session string attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD) + 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((WORD *) pAttribPointer) = 1;

	pAttribPointer += sizeof(WORD);
	*((BYTE *) pAttribPointer) = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Create session with a zero-length global session string attribute
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a zero-length global session string attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((WORD *) pAttribPointer) = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Create session with a zero-length global session blob attribute 
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a zero-length global session blob attribute\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Create session with a string attribute whose length goes beyond the number of bytes available
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a string attribute whose length goes beyond the number of bytes available\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((WORD *) pAttribPointer) = 0xFFFF;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);
*/
	// ------------------------------------------
	// Create session with a blob attribute whose length goes beyond the number of bytes available
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a blob attribute whose length goes beyond the number of bytes available\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = Buffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = 0xFFFFFFFF;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);
/*
	// ------------------------------------------
	// Create session with a global session string attribute of maximum size
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global session string attribute of maximum size\n"));

	pLargeBuffer = new BYTE[sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD) + MAXWORD];
	pSessionInfo = (XMATCH_SESSION *) pLargeBuffer;

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 2 * sizeof(DWORD) + sizeof(WORD) + MAXWORD;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = pLargeBuffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((WORD *) pAttribPointer) = MAXWORD;

	// Build a string of all a's
	pAttribPointer += sizeof(WORD);
	memset((char *) pAttribPointer, 'a', MAXWORD - 1);
	pAttribPointer[MAXWORD - 1] = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	pSessionInfo = (XMATCH_SESSION *) Buffer;
	pLargeBuffer ? delete [] pLargeBuffer : 0;

	// ------------------------------------------
	// Create session with a global session blob attribute of larger than MAXWORD size
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with a global session blob attribute of larger than MAXWORD size\n"));

	pLargeBuffer = new BYTE[sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + MAXWORD + 1];
	pSessionInfo = (XMATCH_SESSION *) pLargeBuffer;

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength =
		sizeof(XMATCH_SESSION) + 3 * sizeof(DWORD) + MAXWORD + 1;
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 1;

	pAttribPointer = pLargeBuffer + sizeof(XMATCH_SESSION);
	*((DWORD *) pAttribPointer) = sizeof(XMATCH_SESSION) + sizeof(DWORD);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) =
		X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB |
		(X_ATTRIBUTE_ID_MASK & SAMPLE_ATTRIB1_ID);

	pAttribPointer += sizeof(DWORD);
	*((DWORD *) pAttribPointer) = MAXWORD;

	// Build a blob with all 0xAA's
	pAttribPointer += sizeof(DWORD);
	memset((char *) pAttribPointer, 0xAA, MAXWORD + 1);

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);

	pSessionInfo = (XMATCH_SESSION *) Buffer;
	pLargeBuffer ? delete [] pLargeBuffer : 0;
*/
}

void RunSessionDeletionTests(LPTSTR szServerName)
{
	BYTE Buffer[sizeof(XMATCH_SESSION) + 500];
	XMATCH_SESSION *pSessionInfo = (XMATCH_SESSION *) Buffer;
	DWORD dwSessionID = 0;

	// ------------------------------------------
	// Try to delete an invalid session
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Try to delete an invalid session\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 1;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Create session with no attibutes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with no attibutes\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Try to delete a valid session
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Try to delete a valid session\n"));

	memset(pSessionInfo->bHostAddress, 0xAA, 32);
	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, DELETESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Try to modify a deleted session
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Try to modify a deleted session\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 0;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	if(CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength))
	{
		_tprintf(TEXT("Shouldn't have received a new session ID!\n"));
	}

}

void RunSessionModificationTests(LPTSTR szServerName)
{
	BYTE Buffer[sizeof(XMATCH_SESSION) + 500], *pAttribPointer = NULL;;
	XMATCH_SESSION *pSessionInfo = (XMATCH_SESSION *) Buffer;
	DWORD dwSessionID = 0;

	memset(pSessionInfo->bHostAddress, 0xAA, 32);


	// ------------------------------------------
	// Try to modify a session that doesn't exist
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Try to modify a session that doesn't exist\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0x55555555;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));

	// ------------------------------------------
	// Create session with no attibutes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with no attibutes\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Modify session to decrease the number of public players to 0
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Modify session to decrease the number of public players to 0\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 0;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	if(CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength))
	{
		_tprintf(TEXT("Shouldn't have received a new session ID!\n"));
	}


	// ------------------------------------------
	// Modify session to increase the number of public players above 0
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Modify session to increase the number of public players above 0\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 1;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	if(CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength))
	{
		_tprintf(TEXT("Shouldn't have received a new session ID!\n"));
	}


	// ------------------------------------------
	// Create session with no attibutes
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Create session with no attibutes\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 0;
	pSessionInfo->dwPrivateAvailable = 10;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength);


	// ------------------------------------------
	// Modify session to decrease the number of private players to 0
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Modify session to decrease the number of private players to 0\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 0;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	if(CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength))
	{
		_tprintf(TEXT("Shouldn't have received a new session ID!\n"));
	}


	// ------------------------------------------
	// Modify session to increase the number of private players above 0
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Modify session to increase the number of private players above 0\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = dwSessionID;
	pSessionInfo->dwPublicAvailable = 0;
	pSessionInfo->dwPrivateAvailable = 1;
	pSessionInfo->dwNumAttributes = 0;

	if(CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, pSessionInfo->dwMessageLength))
	{
		_tprintf(TEXT("Shouldn't have received a new session ID!\n"));
	}

	return;
}

void RunSessionSearchTests(LPTSTR szServerName)
{
	BYTE Buffer[sizeof(XMATCH_SEARCH) + 500], *pParamPointer = NULL, Blob[100];
	BYTE *pResults = NULL;
	XMATCH_SEARCH *pSearchInfo = (XMATCH_SEARCH *) Buffer;
	DWORD dwResultsSize = 0, dwSessionID = 0;

	memset(Blob, 0x0F, 100 * sizeof(BYTE));

	XMATCH_SESSION *pSessionInfo = (XMATCH_SESSION *) Buffer;

	memset(pSessionInfo->bHostAddress, 0xAA, 32);


	// ------------------------------------------
	// Basic session creation for title 1
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Basic session creation for title 1\n"));

	pSessionInfo->dwMessageLength = sizeof(XMATCH_SESSION);
	pSessionInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSessionInfo->dwTitleID = 1;
	pSessionInfo->dwSessionID = 0;
	pSessionInfo->dwPublicAvailable = 10;
	pSessionInfo->dwPrivateAvailable = 0;
	pSessionInfo->dwNumAttributes = 0;

	dwSessionID = CreateDeleteModifySession(szServerName, CREATESESSION_OBJECT, pSessionInfo, sizeof(XMATCH_SESSION));

	// ------------------------------------------
	// Search with invalid session ID as parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with invalid session ID as parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 5;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = 0;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;

	// ------------------------------------------
	// Search with 0 parameters using a stored procedure that doesn't exist
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with 0 parameters using a stored procedure that doesn't exist\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 1000;
	pSearchInfo->dwNumParameters = 0;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;

	// ------------------------------------------
	// Search with 0 parameters
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with 0 parameters\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 0;
	pSearchInfo->dwNumParameters = 0;

	_tprintf(TEXT("Calling QuerySession\n"));
	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);
	_tprintf(TEXT("Returned from QuerySession\n"));

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;

	// ------------------------------------------
	// Search with 1 integer parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with 1 integer parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 1;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 12345;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with 1 string parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with 1 string parameter\n"));

	pSearchInfo->dwMessageLength =
		sizeof(XMATCH_SEARCH) + 2 * sizeof(DWORD) + 1 * sizeof(WORD) + strlen(SAMPLE_PARAM1_STRING) + 1;
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 2;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_STRING;

	pParamPointer += sizeof(DWORD);
	*((WORD *) pParamPointer) = strlen(SAMPLE_PARAM1_STRING) + 1;

	pParamPointer += sizeof(WORD);
	strcpy((char *) pParamPointer, SAMPLE_PARAM1_STRING);

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with 1 blob parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with 1 blob parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD) + 100 * sizeof(BYTE);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 3;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_BLOB;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 100;

	pParamPointer += sizeof(DWORD);
	memcpy((char *) pParamPointer, Blob, 100 * sizeof(BYTE));

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with integer stored proc and string parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with integer stored proc and string parameter\n"));

	pSearchInfo->dwMessageLength =
		sizeof(XMATCH_SEARCH) + 2 * sizeof(DWORD) + 1 * sizeof(WORD) + strlen(SAMPLE_PARAM1_STRING) + 1;
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 1;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_STRING;

	pParamPointer += sizeof(DWORD);
	*((WORD *) pParamPointer) = strlen(SAMPLE_PARAM1_STRING) + 1;

	pParamPointer += sizeof(WORD);
	strcpy((char *) pParamPointer, SAMPLE_PARAM1_STRING);

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with integer stored proc and blob parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with integer stored proc and blob parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD) + 100 * sizeof(BYTE);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 1;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_BLOB;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 100;

	pParamPointer += sizeof(WORD);
	memcpy((char *) pParamPointer, Blob, 100 * sizeof(BYTE));

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with string stored proc and integer parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with string stored proc and integer parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 2;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 12345;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with string stored proc and blob parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with string stored proc and blob parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD) + 100 * sizeof(BYTE);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 2;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_BLOB;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 100;

	pParamPointer += sizeof(DWORD);
	memcpy((char *) pParamPointer, Blob, 100 * sizeof(BYTE));

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with blob stored proc and integer parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with blob stored proc and integer parameter\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 3;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_INTEGER;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 12345;

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;


	// ------------------------------------------
	// Search with blob stored proc and string parameter
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Search with blob stored proc and string parameter\n"));

	pSearchInfo->dwMessageLength =
		sizeof(XMATCH_SEARCH) + 2 * sizeof(DWORD) + 1 * sizeof(WORD) + strlen(SAMPLE_PARAM1_STRING) + 1;
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 3;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_STRING;

	pParamPointer += sizeof(DWORD);
	*((WORD *) pParamPointer) = strlen(SAMPLE_PARAM1_STRING) + 1;

	pParamPointer += sizeof(WORD);
	strcpy((char *) pParamPointer, SAMPLE_PARAM1_STRING);

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;

	// ------------------------------------------
	// Repro case for 5008
	// ------------------------------------------
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Repro case for 5008\n"));

	pSearchInfo->dwMessageLength = sizeof(XMATCH_SEARCH) + 3 * sizeof(DWORD) + 100 * sizeof(BYTE);
	pSearchInfo->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
	pSearchInfo->dwTitleID = 1;
	pSearchInfo->dwQueryID = 1;
	pSearchInfo->dwProcedureIndex = 1;
	pSearchInfo->dwNumParameters = 1;

	pParamPointer = Buffer + sizeof(XMATCH_SEARCH);
	*((DWORD *) pParamPointer) = sizeof(XMATCH_SEARCH) + sizeof(DWORD);

	pParamPointer += sizeof(DWORD);
	*((DWORD *) pParamPointer) = X_ATTRIBUTE_DATATYPE_BLOB;

	pParamPointer += sizeof(DWORD);
	*((INT *) pParamPointer) = 100;

	pParamPointer += sizeof(WORD);
	memcpy((char *) pParamPointer, Blob, 100 * sizeof(BYTE));

	dwResultsSize = QuerySession(szServerName, QUERYSESSION_OBJECT, pSearchInfo, pSearchInfo->dwMessageLength, &pResults);

	if(dwResultsSize && pResults)
	{
		ParseSearchResults(pResults, dwResultsSize);
	}

	pResults ? delete [] pResults : 0;
	pResults = NULL;
}

int main(int argc, char* argv[])
{
	TCHAR szServerName[50] = DEFAULT_SERVER;

	if(argc > 1)
	{
#ifdef UNICODE
		mbstowcs(szServerName, argv[1], strlen(argv[1]) + 1);
#else
		strcpy(szServerName, argv[1]);
#endif
	}

	RunSessionCreationTests(szServerName);

//	RunSessionDeletionTests(szServerName);

//	RunSessionModificationTests(szServerName);

//	RunSessionSearchTests(szServerName);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xnqparse\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4DA50113_F9D5_4C25_AD42_1549803D7330__INCLUDED_)
#define AFX_STDAFX_H__4DA50113_F9D5_4C25_AD42_1549803D7330__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <netmon.h>
#include <stdio.h>
#include <winsock2.h>
#include "xqprotocol.h"

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4DA50113_F9D5_4C25_AD42_1549803D7330__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xnqparse\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xnqparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xmatchparse\xtpparse.cpp ===
//============================================================================
//  FILE: xtpparse.c
//
//  Description: Xbox Authenticated Tunneling Protocol (XTP) Parser
//============================================================================

#include "stdafx.h"

//==================================================================================
// Defines
//==================================================================================
// Values for IP protocols recognized by Netmon
#define PROTO_ICMP_VALUE	1
#define PROTO_IGMP_VALUE	2
#define PROTO_IP_VALUE		4
#define PROTO_TCP_VALUE		6
#define PROTO_UDP_VALUE		17
#define PROTO_IP6_VALUE		41
#define PROTO_RSVP_VALUE	46
#define PROTO_GRE_VALUE		47
#define PROTO_ESP_VALUE		50
#define PROTO_AH_VALUE		51
#define PROTO_OSPF_VALUE	89

#define PROTO_NAME_MAX		8

// Friendly strings for IP protocols recognized by Netmon
#define PROTO_ICMP_NAME		"ICMP"
#define PROTO_IGMP_NAME		"IGMP"
#define PROTO_IP_NAME		"IP"
#define PROTO_TCP_NAME		"TCP"
#define PROTO_UDP_NAME		"UDP"
#define PROTO_IP6_NAME		"IPv6"
#define PROTO_RSVP_NAME		"RSVP"
#define PROTO_GRE_NAME		"GRE"
#define PROTO_ESP_NAME		"ESP"
#define PROTO_AH_NAME		"AH"
#define PROTO_OSPF_NAME		"OSPF"
#define PROTO_UNKNOWN_NAME	"Unknown"

//==================================================================================
// Globals
//==================================================================================
HPROTOCOL hXTP = NULL;
DWORD     Attached = 0;

// structure for decoding the header -----------------------------------------
typedef struct _XTPHEADER 
{
    DWORD		AuthData[3];
	DWORD		SourceAddr;
	DWORD		DestAddr;
	union
	{
		struct _GENFIELD {
			DWORD		Reserved1	: 4;
			DWORD		IHL			: 4;
			DWORD		Protocol	: 8;
			DWORD		Reserved2	: 16;
		} GenField;

		struct _UDPFIELD {
			WORD		SourcePort;
			WORD		DestPort;
		} UdpField;
	} VariableField;
	DWORD		SequenceNum	: 31;
	DWORD		UdpFlag		: 1;

} XTPHEADER, *PXTPHEADER;

//==================================================================================
// Functions
//==================================================================================
extern PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo();
extern VOID   WINAPI XTP_Register( HPROTOCOL hXTP);
extern VOID   WINAPI XTP_Deregister( HPROTOCOL hXTP);
extern LPBYTE WINAPI XTP_RecognizeFrame( HFRAME hFrame, 
                                              LPBYTE pMacFrame, 
                                              LPBYTE pXTPFrame, 
                                              DWORD MacType, 
                                              DWORD BytesLeft, 
                                              HPROTOCOL hPrevProtocol, 
                                              DWORD nPrevProtOffset,
                                              LPDWORD pProtocolStatus,
                                              LPHPROTOCOL phNextProtocol, 
                                              LPDWORD InstData);
extern LPBYTE WINAPI XTP_AttachProperties( HFRAME hFrame, 
                                                LPBYTE pMacFrame, 
                                                LPBYTE pXTPFrame, 
                                                DWORD MacType, 
                                                DWORD BytesLeft, 
                                                HPROTOCOL hPrevProtocol, 
                                                DWORD nPrevProtOffset,
                                                DWORD InstData);
extern DWORD  WINAPI XTP_FormatProperties( HFRAME hFrame, 
                                                LPBYTE pMacFrame, 
                                                LPBYTE pXTPFrame, 
                                                DWORD nPropertyInsts, 
                                                LPPROPERTYINST p);

VOID WINAPIV XTP_FormatSummary( LPPROPERTYINST pPropertyInst);

// Define the entry points that we will pass back at dll entry time ----------
ENTRYPOINTS XTPEntryPoints =
{
    // XTP Entry Points
    XTP_Register,
    XTP_Deregister,
    XTP_RecognizeFrame,
    XTP_AttachProperties,
    XTP_FormatProperties
};


//==================================================================================
// Property labels
//==================================================================================
LABELED_BIT XTPUDPFlag[] =
{
    // bit 7 = Is this the UDP special case
    {   7,
	    "UDP special case",
	    "Generic IP case",
    }
};
SET XTPUdpFlagSET = {sizeof(XTPUDPFlag)/sizeof(LABELED_BIT), XTPUDPFlag};



//==================================================================================
// Properties
//==================================================================================
typedef enum
{
    XTP_SUMMARY = 0,
    XTP_AUTHDATA,
	XTP_ORIGSOURCEADDR,
	XTP_ORIGDESTADDR,
	XTP_ORIGSOURCEPORT,
	XTP_ORIGDESTPORT,
	XTP_RESERVED1,
	XTP_ORIGIHL,
	XTP_ORIGPROTO,
	XTP_RESERVED2,
	XTP_SEQNUM,
	XTP_UDPFLAG,
};

PROPERTYINFO  XTPPropertyTable[] = 
{
    // XTP_SUMMARY
    { 0, 0,
      "Summary",
      "Summary of the XTP Packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,
      XTP_FormatSummary
    },

    // XTP_AUTHDATA
    { 0, 0,
      "Auth data",
      "Authentication data",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGSOURCEADDR
    { 0, 0,
      "Source IP",
      "Source address of original IP packet",
      PROP_TYPE_IP_ADDRESS,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGDESTADDR
    { 0, 0,
      "Destination IP",
      "Destination address of original IP packet",
      PROP_TYPE_IP_ADDRESS,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGSOURCEPORT
    { 0, 0,
      "Source port",
      "Source port of original UDP packet",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGDESTPORT
    { 0, 0,
      "Destination port",
      "Destination port of original UDP packet",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_RESERVED1
    { 0, 0,
      "Reserved",
      "Reserved for future use",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGIHL
    { 0, 0,
      "IHL",
      "Internet header length of original IP packet",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGPROTO
    { 0, 0,
      "Protocol",
      "Protcol type of original IP packet",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance	// BUGBUG - Probably want a new format for this to show the protocol name
    },

    // XTP_RESERVED2
    { 0, 0,
      "Reserved",
      "Reserved for future use",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_SEQNUM
    { 0, 0,
      "Sequence number",
      "Authentication sequence number",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_UDPFLAG
    { 0, 0,
      "UDP flag",
      "Flag that specifies if this is a UDP packet special case",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &XTPUdpFlagSET,
      80,
      FormatPropertyInstance
    }

};

DWORD nNumXTPProps = (sizeof(XTPPropertyTable)/sizeof(PROPERTYINFO));

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: (Called by the OS) Tell the kernel about our entry points.
//
// Returns: Always returns TRUE
//==================================================================================
BOOL WINAPI DllMain( HANDLE hInstance, ULONG Command, LPVOID Reserved)
{

    // what type of call is this
    switch( Command )
    {
        case DLL_PROCESS_ATTACH:
            // are we loading for the first time?
            if( Attached == 0 )
            {
                // the first time in we need to tell the kernel 
                // about ourselves
                hXTP = CreateProtocol( "XTP", 
                                            &XTPEntryPoints, 
                                            ENTRYPOINTS_SIZE);
            }
            Attached++;
            break;

        case DLL_PROCESS_DETACH:
            // are we detaching our last instance?
            Attached--;
            if( Attached == 0 )
            {
                // last guy out needs to clean up
                DestroyProtocol( hXTP);
            }
            break;
    }

    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Function called by Netmon to automatically install the parser
//
// Arguments: none
//
// Returns: On success, returns a pointer to a PF_PARSERDLLINFO structure containing
//	information on the parsers in this DLL.  Otherwise, returns NULL
//==================================================================================
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD dwNumProtocols;

    PPF_HANDOFFSET    pIncomingHandoff;
    PPF_HANDOFFENTRY  pHandoffEntry;
    DWORD dwIncomingHandoffs;
    // BUGBUG - later, the hand-off set for this protocol will need to be fleshed out
    /*
    PPF_HANDOFFSET    pOutgoingHandoff;
    DWORD dwNumOutgoingHandoffs;
    */

    // Base structure ========================================================

    // Allocate memory for parser info:
    dwNumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc( GetProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof( PF_PARSERDLLINFO ) +
                                                   dwNumProtocols * sizeof( PF_PARSERINFO) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }       
    
    // Fill in the parser DLL info
    pParserDllInfo->nParsers = dwNumProtocols;

    // Fill in the individual parser infos...

    // Enter XTP information
    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    sprintf( pParserInfo->szProtocolName, "XTP" );
    sprintf( pParserInfo->szComment,      "Xbox Authenticated Tunneling Protocol" );
    sprintf( pParserInfo->szHelpFile,     "");

    // the incoming handoff set ----------------------------------------------
    // allocate
    dwIncomingHandoffs = 1;
    pIncomingHandoff = (PPF_HANDOFFSET)HeapAlloc( GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             sizeof( PF_HANDOFFSET ) +
                                             dwIncomingHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pIncomingHandoff == NULL )
    {
        return pParserDllInfo;
    }

    // Fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pIncomingHandoff;
    pIncomingHandoff->nEntries = dwIncomingHandoffs;

    // UDP PORT 500
    pHandoffEntry = &(pIncomingHandoff->Entry[0]);
    sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    sprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
    sprintf( pHandoffEntry->szProtocol,   "XTP" );
	// BUGBUG - Use 500 for now, but this conflicts with ISAKMP
    pHandoffEntry->dwHandOffValue =        500;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    

    // BUGBUG - Later, the outgoing hand-off set for this protocol will need to be
	// updated to include most major protocols (is there a way to piggy back off of TCP/IP?)

    return pParserDllInfo;
}

//==================================================================================
// XTP_Register
//----------------------------------------------------------------------------------
//
// Description: Creates the property database for XTP
//
// Arguments:
//	HPROTOCOL		hXTP			Handle to the XTP protocol
//
// Returns: void
//==================================================================================
void WINAPI XTP_Register( HPROTOCOL hXTP)
{
    WORD  i;

    // Tell Netmon to make reserve some space for our property table
    CreatePropertyDatabase( hXTP, nNumXTPProps);

    // Add our properties to the Netmon's database
    for( i = 0; i < nNumXTPProps; i++)
    {
        AddProperty( hXTP, &XTPPropertyTable[i]);
    }
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Removes the property database for XTP
//
// Arguments:
//	HPROTOCOL		hXTP			Handle to the XTP protocol
//
// Returns: void
//==================================================================================
VOID WINAPI XTP_Deregister(HPROTOCOL hXTP)
{
    // Tell the Netmon that it may now free our database
    DestroyPropertyDatabase( hXTP);
}

//==================================================================================
// XTP_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XTP
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that contains the data.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame. The pointer 
//									provides a way to view data that other parsers recognize.
//	LPBYTE			pXTPFrame		Pointer to the start of the unclaimed data. Typically,
//									the unclaimed data is located in the middle of a frame
//									because a previous parser has claimed data before this
//									parser. The parser must test the unclaimed data first. 
//	DWORD			MacType			MAC value of the first protocol in a frame. Typically,
//									the MacType value is used when the parser must identify
//									the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes from a location in a frame
//									to the end of the frame. 
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol. 
//	DWORD			nPrevProtOffset	Offset of the previous protocol - beginning of the frame.
//	LPDWORD			pProtocolStatus	Protocol status indicator.
//	LPHPROTOCOL		phNextProtocol	Pointer to the handle of the next protocol. This
//									parameter is set when a protocol identifies the protocol
//									that follows a protocol. To obtain the handle of the next
//									protocol, call the GetProtocolFromTable function. 
//	LPDWORD			InstData		On input, a pointer to the instance data from the
//									previous protocol. On output, a pointer to the instance
//									data for the current protocol. 
//
// Returns: When XTP protocol is recognized, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When XTP protocol isn't recognized, returns the original pXTPFrame value to submit
//			the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XTP_RecognizeFrame(HFRAME      hFrame,         
								LPBYTE      pMacFrame,      
								LPBYTE      pXTPFrame, 
								DWORD       MacType,        
								DWORD       BytesLeft,      
								HPROTOCOL   hPrevProtocol,  
								DWORD       nPrevProtOffset,
								LPDWORD     pProtocolStatus,
								LPHPROTOCOL phNextProtocol,
								LPDWORD     InstData)       
{
	PXTPHEADER pXTPHeader = (PXTPHEADER) pXTPFrame;
	DWORD dwOptionsLen = 0;

	// If this is the general case, determine the size of the encapsulated IP header
	if(!(pXTPHeader->UdpFlag))
	{
		// If the IP header is too small, discard the packet without recognizing it
		if(pXTPHeader->VariableField.GenField.IHL < 5)
		{
			*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
			return pXTPFrame;
		}

		// The options len is the total header len minus the standard header len (5*4=20)
		dwOptionsLen = (pXTPHeader->VariableField.GenField.IHL - 5) * 4;
	}

	// If this frame isn't large enough to be an XTP frame, indicate that its not recognized
	if(BytesLeft < (sizeof(XTPHEADER) + dwOptionsLen))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return pXTPFrame;
	}

	// BUGBUG - in the future, verify that the passed in frame is actually an XTP frame
	// For now, just assume that since we're being called, it must be
    *pProtocolStatus = PROTOCOL_STATUS_CLAIMED;

	// BUGBUG - in the future, find out what the next protocol is.  Then, set the phNextProtocol
	// and the return point accordingly to indicate if we are followed by a parsable protocol
	pXTPFrame += (sizeof(XTPHEADER) + dwOptionsLen);
    return pXTPFrame;
}

//==================================================================================
// XTP_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XTP
//
// Arguments:
//	HFRAME			hFrame			Handle of the frame that is being parsed. 
//	LPBYTE			lpFrame			Pointer to the first byte in a frame.
//	LPBYTE			pXTPFrame		Pointer to the start of the recognized data.
//	DWORD			MacType			MAC value of the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes in a frame, starting
//									at the beginning of the recognized data.
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol.
//	DWORD			nPrevProtOffset	Offset of the previous protocol, starting at the
//									beginning of the frame.
//	DWORD			InstData		Pointer to the instance data from the previous protocol.
//
// Returns: When the function is successful, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When the function isn't successful, returns the original pXTPFrame value to
//			submit the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XTP_AttachProperties(	HFRAME      hFrame,         
									LPBYTE      pMacFrame,     
									LPBYTE      pXTPFrame,   
									DWORD       MacType,        
									DWORD       BytesLeft,      
									HPROTOCOL   hPrevProtocol,  
									DWORD       nPrevProtOffset,
									DWORD       InstData)       

{
    // Apply the header overlay in order to decode the protocol
    PXTPHEADER	pXTPHeader = (PXTPHEADER) pXTPFrame;
	DWORD		dwOptionsLen = 0, dwSequenceNum = 0;
	BYTE		bUdpFlag = 0;

	// If this is the general case, determine the size of the encapsulated IP header
	if(!(pXTPHeader->UdpFlag))
	{
		// If the IP header is too small, discard the frame
		if(pXTPHeader->VariableField.GenField.IHL < 5)
		{
			goto Exit;
		}

		// The options len is the total header len minus the standard header len (5*4=20)
		dwOptionsLen = (pXTPHeader->VariableField.GenField.IHL - 5) * 4;
	}

	// If this frame isn't large enough to be an XTP frame, discard it
	if(BytesLeft < (sizeof(XTPHEADER) + dwOptionsLen))
	{
		goto Exit;
	}

    //
    // Attach Properties...
    //

    // XTP summary
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_SUMMARY].hProperty, (WORD)BytesLeft,
		(LPBYTE)pXTPFrame, 0, 0, 0))
	{
		goto Exit;
	}

    // Authentication data
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_AUTHDATA].hProperty, sizeof(pXTPHeader->AuthData),
		(LPBYTE) pXTPHeader->AuthData, 0, 1, 0))
	{
		goto Exit;
	}

    // Original source IP address
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGSOURCEADDR].hProperty, sizeof(pXTPHeader->SourceAddr),
		(LPBYTE) &(pXTPHeader->SourceAddr), 0, 1, 0))
	{
		goto Exit;
	}

    // Original destination IP address
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGDESTADDR].hProperty, sizeof(pXTPHeader->DestAddr),
		(LPBYTE) &(pXTPHeader->DestAddr), 0, 1, 0))
	{
		goto Exit;
	}

	// For the UDP special case, interpret the next DWORD as a source and destination port
	if(pXTPHeader->UdpFlag)
	{
		// Original source UDP port
		if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGSOURCEPORT].hProperty,
			sizeof(pXTPHeader->VariableField.UdpField.SourcePort),
			(LPBYTE) &(pXTPHeader->VariableField.UdpField.SourcePort), 0, 1, 0))
		{
			goto Exit;
		}
		
		// Original destination UDP port
		if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGDESTPORT].hProperty,
			sizeof(pXTPHeader->VariableField.UdpField.DestPort),
			(LPBYTE) &(pXTPHeader->VariableField.UdpField.DestPort), 0, 1, 0))
		{
			goto Exit;
		}
	}
	// For the generic case, interpret the next DWORD as the IHL and protocol of the encapsulated IP packet
	else
	{
		BYTE bReserved1 = 0, bIHL = 0, bProtocol = 0;
		WORD wReserved2 = 0;

		// Many of the fields in the general case header will wind up overlapping since they are
		// less than the size of a byte and Netmon only allows properties of a byte or larger
		// AttachPropertyInstanceEx is used to accurately display the values of overlapped fields

		// Go ahead and retrieve the correct values before mucking with the frame
		bReserved1 = (BYTE) pXTPHeader->VariableField.GenField.Reserved1;
		bIHL = (BYTE) pXTPHeader->VariableField.GenField.IHL;
		bProtocol = (BYTE) pXTPHeader->VariableField.GenField.Protocol;
		wReserved2 = (WORD) pXTPHeader->VariableField.GenField.Reserved2;

		// Reserved half-byte
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_RESERVED1].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD), sizeof(BYTE), &bReserved1, 0, 1, 0))
		{
			goto Exit;
		}

		// Original IHL
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_ORIGIHL].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD), sizeof(BYTE), &bIHL, 0, 1, 0))
		{
			goto Exit;
		}

		// Original protocol
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_ORIGPROTO].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD) + 1 * sizeof(BYTE), sizeof(BYTE), &bProtocol, 0, 1, 0))
		{
			goto Exit;
		}

		// Reserved word
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_RESERVED2].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD) + 2 * sizeof(BYTE), sizeof(WORD), &wReserved2, 0, 1, 0))
		{
			goto Exit;
		}
	}

	// Finally, handle the sequence number and the UDP/general-case flag
	dwSequenceNum = (DWORD) pXTPHeader->SequenceNum;
	bUdpFlag = (BYTE) pXTPHeader->UdpFlag;

	// Authentication sequence number
	if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_SEQNUM].hProperty,
		sizeof(DWORD), pXTPFrame + 6 * sizeof(DWORD), sizeof(DWORD), &dwSequenceNum, 0, 1, 0))
	{
		goto Exit;
	}

	// UDP or general case flag
	if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_UDPFLAG].hProperty,
		sizeof(BYTE), pXTPFrame + 6 * sizeof(DWORD) + 3 * sizeof(BYTE), sizeof(BYTE), &bUdpFlag, 0, 1, 0))
	{
		goto Exit;
	}

	// BUGBUG - For now, just pass on the data beyond the XTP header
	pXTPFrame += (sizeof(XTPHEADER) + dwOptionsLen);

Exit:

	return pXTPFrame;
}

//==================================================================================
// XTP_GetProtocolName
//----------------------------------------------------------------------------------
//
// Description: Helper function for protocol parsing.  Returns friendly string for an
//	IP protocol
//
// Arguments:
//	BYTE				bProtocol			Byte containing protocol value from packet
//	LPSTR				szProtocolName		String that is filled with the friendly name
//											of the protocol
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
BOOL WINAPI XTP_GetProtocolName(BYTE bProtocol, LPSTR szProtocolName)
{
	// Make sure we have a valid protocol string holder
	if(!szProtocolName || IsBadWritePtr(szProtocolName, PROTO_NAME_MAX))
		return FALSE;

	// Not sure what alot of these protocols are, but Netmon has them listed
	// in TCPIP.INI so since we can hand them off, we should probably print
	// a friendly name for each of them
	switch(bProtocol)
	{
	case PROTO_ICMP_VALUE:
		strcpy(szProtocolName, PROTO_ICMP_NAME);
		break;
	case PROTO_IGMP_VALUE:
		strcpy(szProtocolName, PROTO_IGMP_NAME);
		break;
	case PROTO_IP_VALUE:
		strcpy(szProtocolName, PROTO_IP_NAME);
		break;
	case PROTO_TCP_VALUE:
		strcpy(szProtocolName, PROTO_TCP_NAME);
		break;
	case PROTO_UDP_VALUE:
		strcpy(szProtocolName, PROTO_UDP_NAME);
		break;
	case PROTO_IP6_VALUE:
		strcpy(szProtocolName, PROTO_IP6_NAME);
		break;
	case PROTO_RSVP_VALUE:
		strcpy(szProtocolName, PROTO_RSVP_NAME);
		break;
	case PROTO_GRE_VALUE:
		strcpy(szProtocolName, PROTO_GRE_NAME);
		break;
	case PROTO_ESP_VALUE:
		strcpy(szProtocolName, PROTO_ESP_NAME);
		break;
	case PROTO_AH_VALUE:
		strcpy(szProtocolName, PROTO_AH_NAME);
		break;
	case PROTO_OSPF_VALUE:
		strcpy(szProtocolName, PROTO_OSPF_NAME);
		break;
	default:
		strcpy(szProtocolName, PROTO_ICMP_NAME);
		break;
	}

	return TRUE;
}

//==================================================================================
// XTP_FormatProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to format each property that was attached by
//	XTP_AttachProperties
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that is being parsed.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame.
//	LPBYTE			pXTPFrame		Pointer to the beginning of the protocol data in a frame.
//	DWORD			nPropertyInsts	Number of PROPERTYINST structures provided by lpPropInst. 
//	LPPROPERTYINST	p				Pointer to an array of PROPERTYINST structures. 
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
DWORD WINAPI XTP_FormatProperties(	HFRAME          hFrame,
									LPBYTE          pMacFrame,
									LPBYTE          pXTPFrame,
									DWORD           nPropertyInsts,
									LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }

    return NMERR_SUCCESS;
}

//============================================================================
//  Function: XTP_FormatSummary
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  Your Name Here      01/01/70    Created
//============================================================================
VOID WINAPIV XTP_FormatSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR		pReturnedString = pPropertyInst->szPropertyText;
    PXTPHEADER	pXTPHeader = (PXTPHEADER)(pPropertyInst->lpData);
	IN_ADDR		SourceAddr, DestAddr;

	SourceAddr.S_un.S_addr = pXTPHeader->SourceAddr;
	DestAddr.S_un.S_addr = pXTPHeader->DestAddr;

	if(pXTPHeader->UdpFlag)
	{
	    // Print "UDP-case, Source: <SourceIP>:<DestPort>, Dest: <DestIP>:<DestPort>"
		 sprintf( pReturnedString, "UDP-case, Source %s:%u, Dest: %s:%u",
			 inet_ntoa(SourceAddr), pXTPHeader->VariableField.UdpField.SourcePort,
			 inet_ntoa(DestAddr), pXTPHeader->VariableField.UdpField.DestPort);
	}
	else
	{
		CHAR	szProtocolName[PROTO_NAME_MAX];

		XTP_GetProtocolName((BYTE) pXTPHeader->VariableField.GenField.Protocol, szProtocolName);

		// Print "General-case, Source: <SourceIP>, Dest: <DestIP>, Protocol: %s"
		sprintf(pReturnedString, "General-case, Source %s, Dest: %s, Protocol: %s",
			inet_ntoa(SourceAddr), inet_ntoa(DestAddr), szProtocolName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xtpparse\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xtpparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xtpparse\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__26CD47E5_A4BD_46EF_A809_C0A208E5CCBC__INCLUDED_)
#define AFX_STDAFX_H__26CD47E5_A4BD_46EF_A809_C0A208E5CCBC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <stdio.h>
#include <winsock.h>
#include <netmon.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__26CD47E5_A4BD_46EF_A809_C0A208E5CCBC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xnqparse\xnqparse.cpp ===
//============================================================================
//  FILE: xqparse.c
//
//  Description: Xbox Notification Queue (XNQ) Parser
//============================================================================

#include "stdafx.h"

//==================================================================================
// Globals
//==================================================================================
HPROTOCOL hXNQ = NULL;
DWORD     Attached = 0;

typedef struct BASE_MSG_HEADER BASE_HEADER, *PBASE_HEADER;
typedef struct Q_HELLO_MSG QHELLO_MSG, *PQHELLO_MSG;
typedef struct Q_USER_INFO_MSG QUSERINFO_MSG, *PQUSERINFO_MSG;
typedef struct Q_ADD_MSG QADD_MSG, *PQADD_MSG;
typedef struct Q_DELETE_MSG QDELETE_MSG, *PQDELETE_MSG;
typedef struct Q_DELETE_MATCHES_MSG QDELETEMATCHES_MSG, *PQDELETEMATCHES_MSG;
typedef struct Q_DEAD_XIP_MSG QDEADXIP_MSG, *PQDEADXIP_MSG;
typedef struct Q_DEAD_XRG_MSG QDEADXRG_MSG, *PQDEADXRG_MSG;
typedef struct Q_LIST_MSG QLIST_MSG, *PQLIST_MSG;
typedef struct Q_LIST_REPLY_MSG QLISTREPLY_MSG, *PQLISTREPLY_MSG;
typedef struct Q_TICKLE_MSG QTICKLE_MSG, *PQTICKLE_MSG;
typedef struct BASE_ACK_MSG BASEACK_MSG, *PBASEACK_MSG;

//==================================================================================
// Functions
//==================================================================================
extern PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo();
extern VOID   WINAPI XNQ_Register(HPROTOCOL hXNQ);
extern VOID   WINAPI XNQ_Deregister(HPROTOCOL hXNQ);
extern LPBYTE WINAPI XNQ_RecognizeFrame(HFRAME hFrame, 
                                        LPBYTE pMacFrame, 
                                        LPBYTE pXNQFrame, 
                                        DWORD MacType, 
                                        DWORD BytesLeft, 
                                        HPROTOCOL hPrevProtocol, 
                                        DWORD nPrevProtOffset,
                                        LPDWORD pProtocolStatus,
                                        LPHPROTOCOL phNextProtocol, 
                                        LPDWORD InstData);
extern LPBYTE WINAPI XNQ_AttachProperties(HFRAME hFrame, 
                                          LPBYTE pMacFrame, 
                                          LPBYTE pXNQFrame, 
                                          DWORD MacType, 
                                          DWORD BytesLeft, 
                                          HPROTOCOL hPrevProtocol, 
                                          DWORD nPrevProtOffset,
                                          DWORD InstData);
extern DWORD  WINAPI XNQ_FormatProperties(HFRAME hFrame, 
                                          LPBYTE pMacFrame, 
                                          LPBYTE pXNQFrame, 
                                          DWORD nPropertyInsts, 
                                          LPPROPERTYINST p);

VOID WINAPIV XNQ_FormatSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XNQ_FormatQueueID( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XNQ_FormatUserCookie( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XNQ_FormatUserID( LPPROPERTYINST pPropertyInst);

// Define the entry points that we will pass back at dll entry time ----------
ENTRYPOINTS XNQEntryPoints =
{
    // XNQ Entry Points
    XNQ_Register,
    XNQ_Deregister,
    XNQ_RecognizeFrame,
    XNQ_AttachProperties,
    XNQ_FormatProperties
};

//==================================================================================
// Properties
//==================================================================================
typedef enum
{
    XNQ_SUMMARY = 0,
    XNQ_MESSAGE_TYPE,
    XNQ_MESSAGE_LENGTH,
	XNQ_SEQUENCE_NUM,
	XNQ_SESSION_ID,
	XNQ_VERSION,
	XNQ_VERSION_DESC,
	XNQ_USERID,
	XNQ_XIP,
	XNQ_XRG,
	XNQ_TICKLE_IP,
	XNQ_TICKLE_PORT,
	XNQ_QUEUE_TYPE,
	XNQ_USER_COUNT,
	XNQ_COOKIE,
	XNQ_START_QUID,
	XNQ_MAX_ITEMS,
	XNQ_MAX_DATASIZE,
	XNQ_NEXT_QUID,
	XNQ_QUEUE_LEFT,
	XNQ_ITEMS_RETURNED,
	XNQ_RETURNED_DATASIZE,
	XNQ_FIRST_QUID,
	XNQ_LAST_QUID,
	XNQ_ATTRIB_ID,
	XNQ_ATTRIB_DATA,
	XNQ_RESULT,
	XNQ_ADDED_DATA,
	XNQ_RETURNED_DATA
};

PROPERTYINFO  XNQPropertyTable[] = 
{
    // XNQ_SUMMARY
    { 0, 0,
      "Summary",
      "Summary of the queue tickle",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatSummary
    },

    // XNQ_MESSAGE_TYPE
    { 0, 0,
      "Msg type",
      "Message type",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_MESSAGE_LENGTH
    { 0, 0,
      "Msg len",
      "Message length",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_SEQUENCE_NUM
    { 0, 0,
      "Seq num",
      "Sequence number",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_SESSION_ID
    { 0, 0,
      "Sess ID",
      "Session ID",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_VERSION
    { 0, 0,
      "Ver",
      "Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_VERSION_DESC
    { 0, 0,
      "Ver desc",
      "Version description",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_USERID
    { 0, 0,
      "User ID",
      "User ID",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatUserID
    },

    // XNQ_XIP

    { 0, 0,
      "XIP",
      "Xbox Address",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_XRG
    { 0, 0,
      "XRG",
      "XRG Address",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_TICKLE_IP
    { 0, 0,
      "Tickle IP",
      "Tickle IP for Xbox",
      PROP_TYPE_IP_ADDRESS,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_TICKLE_PORT
    { 0, 0,
      "Tickle Port",
      "Tickle Port for Xbox",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_QUEUE_TYPE
    { 0, 0,
      "Queue Type",
      "Queue Type",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_USER_COUNT
    { 0, 0,
      "User count",
      "User count",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_COOKIE
    { 0, 0,
      "Cookie",
      "Client request cookie",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatUserCookie
    },

    // XNQ_START_QUID
    { 0, 0,
      "Start QUID",
      "ID of first queue item to return",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatQueueID
    },

    // XNQ_MAX_ITEMS
    { 0, 0,
      "Max items",
      "Max queue items to return",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_MAX_DATASIZE
    { 0, 0,
      "Max data",
      "Max queue data to return",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_NEXT_QUID
    { 0, 0,
      "Next QUID",
      "ID of next unreturned item in queue",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatQueueID
    },

    // XNQ_QUEUE_LEFT
    { 0, 0,
      "Queue left",
      "Number of items left in queue",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_ITEMS_RETURNED
    { 0, 0,
      "Num items",
      "Number of items being returned",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_RETURNED_DATASIZE
    { 0, 0,
      "Item size",
      "Total size of items being returned",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_FIRST_QUID
    { 0, 0,
      "First QUID",
      "ID of first QUID to delete",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatQueueID
    },

    // XNQ_LAST_QUID
    { 0, 0,
      "Last QUID",
      "ID of last QUID to delete",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      XNQ_FormatQueueID
    },

    // XNQ_ATTRIB_ID
    { 0, 0,
      "Attrib ID",
      "Attribute ID",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_ATTRIB_DATA
    { 0, 0,
      "Attrib data",
      "Attribute data",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_RESULT
    { 0, 0,
      "Result code",
      "Result code from ACK'd operation",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_ADDED_DATA
    { 0, 0,
      "Added data",
      "Data being added to queue",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XNQ_RETURNED_DATA
    { 0, 0,
      "Returned data",
      "Data being returned from queue",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    }
};


DWORD nNumXNQProps = (sizeof(XNQPropertyTable)/sizeof(PROPERTYINFO));

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: (Called by the OS) Tell the kernel about our entry points.
//
// Returns: Always returns TRUE
//==================================================================================
BOOL WINAPI DllMain( HANDLE hInstance, ULONG Command, LPVOID Reserved)
{

    // what type of call is this
    switch( Command )
    {
        case DLL_PROCESS_ATTACH:
            // are we loading for the first time?
            if( Attached == 0 )
            {
                // Create the queue tickle protocol
                hXNQ = CreateProtocol("XNQ", 
                                      &XNQEntryPoints, 
                                      ENTRYPOINTS_SIZE);
            }
            Attached++;
            break;

        case DLL_PROCESS_DETACH:
            // are we detaching our last instance?
            Attached--;
            if( Attached == 0 )
            {
                // Clean up the queue tickle protocol
                DestroyProtocol(hXNQ);
            }
            break;
    }

    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Function called by Netmon to automatically install the parser
//
// Arguments: none
//
// Returns: On success, returns a pointer to a PF_PARSERDLLINFO structure containing
//	information on the parsers in this DLL.  Otherwise, returns NULL
//==================================================================================
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD dwNumProtocols;

    PPF_HANDOFFSET    pIncomingHandoff;
    PPF_HANDOFFENTRY  pHandoffEntry;
    DWORD dwIncomingHandoffs;

    PPF_FOLLOWSET    pOutgoingFollow;
    PPF_FOLLOWENTRY  pFollowEntry;
    DWORD dwOutgoingFollows;

    // Base structure ========================================================

    // Allocate memory for parser info:
    dwNumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc(GetProcessHeap(),
                                                  HEAP_ZERO_MEMORY,
                                                  sizeof( PF_PARSERDLLINFO ) +
                                                  dwNumProtocols * sizeof( PF_PARSERINFO) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }       
    
    // Fill in the parser DLL info
    pParserDllInfo->nParsers = dwNumProtocols;

    // Fill in the individual parser infos...

    // Enter XNQ information
    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    sprintf( pParserInfo->szProtocolName, "XNQ" );
    sprintf( pParserInfo->szComment,      "Xbox Notification Queue Protocol" );
    sprintf( pParserInfo->szHelpFile,     "");

    // the incoming handoff set ----------------------------------------------
    // allocate
    dwIncomingHandoffs = 1;
    pIncomingHandoff = (PPF_HANDOFFSET)HeapAlloc(GetProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 sizeof( PF_HANDOFFSET ) +
                                                 dwIncomingHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pIncomingHandoff == NULL )
    {
        return pParserDllInfo;
    }

    // Fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pIncomingHandoff;
    pIncomingHandoff->nEntries = dwIncomingHandoffs;

    // TCP port 3000
    pHandoffEntry = &(pIncomingHandoff->Entry[0]);
    sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    sprintf( pHandoffEntry->szIniSection, "TCP_HandoffSet" );
    sprintf( pHandoffEntry->szProtocol,   "XNQ" );
    pHandoffEntry->dwHandOffValue =        3000;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    

    // the outgoing follow set ----------------------------------------------
    // allocate
    dwOutgoingFollows = 1;
    pOutgoingFollow = (PPF_FOLLOWSET)HeapAlloc(GetProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 sizeof( PF_FOLLOWSET ) +
                                                 dwOutgoingFollows * sizeof( PF_FOLLOWENTRY) );
    if( pOutgoingFollow == NULL )
    {
        return pParserDllInfo;
    }

    // Fill in the incoming handoff set
    pParserInfo->pWhoCanFollowMe = pOutgoingFollow;
    pOutgoingFollow->nEntries = dwOutgoingFollows;

    // XNQ can follow XNQ
    pFollowEntry = &(pOutgoingFollow->Entry[0]);
    sprintf( pFollowEntry->szProtocol,   "XNQ" );

    return pParserDllInfo;
}

//==================================================================================
// XNQ_Register
//----------------------------------------------------------------------------------
//
// Description: Creates the property database for XNQ
//
// Arguments:
//	HPROTOCOL		hXNQ			Handle to the XNQ protocol
//
// Returns: void
//==================================================================================
void WINAPI XNQ_Register( HPROTOCOL hXNQ)
{
    WORD  i;

    // Tell Netmon to make reserve some space for our property table
    CreatePropertyDatabase( hXNQ, nNumXNQProps);

    // Add our properties to the Netmon's database
    for( i = 0; i < nNumXNQProps; i++)
    {
        AddProperty( hXNQ, &XNQPropertyTable[i]);
    }
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Removes the property database for XNQ
//
// Arguments:
//	HPROTOCOL		hXNQ			Handle to the XNQ protocol
//
// Returns: void
//==================================================================================
VOID WINAPI XNQ_Deregister(HPROTOCOL hXNQ)
{
    // Tell the Netmon that it may now free our database
    DestroyPropertyDatabase( hXNQ);
}

//==================================================================================
// XNQ_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XNQ
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that contains the data.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame. The pointer 
//									provides a way to view data that other parsers recognize.
//	LPBYTE			pXNQFrame		Pointer to the start of the unclaimed data. Typically,
//									the unclaimed data is located in the middle of a frame
//									because a previous parser has claimed data before this
//									parser. The parser must test the unclaimed data first. 
//	DWORD			MacType			MAC value of the first protocol in a frame. Typically,
//									the MacType value is used when the parser must identify
//									the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes from a location in a frame
//									to the end of the frame. 
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol. 
//	DWORD			nPrevProtOffset	Offset of the previous protocol - beginning of the frame.
//	LPDWORD			pProtocolStatus	Protocol status indicator.
//	LPHPROTOCOL		phNextProtocol	Pointer to the handle of the next protocol. This
//									parameter is set when a protocol identifies the protocol
//									that follows a protocol. To obtain the handle of the next
//									protocol, call the GetProtocolFromTable function. 
//	LPDWORD			InstData		On input, a pointer to the instance data from the
//									previous protocol. On output, a pointer to the instance
//									data for the current protocol. 
//
// Returns: When XNQ protocol is recognized, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When XNQ protocol isn't recognized, returns the original pXNQFrame value to submit
//			the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XNQ_RecognizeFrame(HFRAME      hFrame,         
								LPBYTE      pMacFrame,      
								LPBYTE      pXNQFrame, 
								DWORD       MacType,        
								DWORD       BytesLeft,      
								HPROTOCOL   hPrevProtocol,  
								DWORD       nPrevProtOffset,
								LPDWORD     pProtocolStatus,
								LPHPROTOCOL phNextProtocol,
								LPDWORD     InstData)       
{
	PBASE_HEADER pXNQHeader = (PBASE_HEADER) pXNQFrame;
	DWORD dwOptionsLen = 0, dwCurrentPacketLen = 0;

	// Make sure there's enough room to parse the protocol
	if(BytesLeft < sizeof(BASE_HEADER))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return pXNQFrame;
	}

	// If the message is of an unknown type then we can't parse it
	if((pXNQHeader->dwMsgType > QMSG_MAX_REPLY_TYPE) && (pXNQHeader->dwMsgType != MSGTYPE_ACK))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return pXNQFrame;
	}

	// If we can tell that there's room at the end of this packet then we know it must be XNQ
	// Otherwise, we just claim the rest of the packet
	dwCurrentPacketLen = pXNQHeader->dwMsgLen + sizeof(BASE_HEADER);
	if(dwCurrentPacketLen > BytesLeft)
	{
		*pProtocolStatus = PROTOCOL_STATUS_CLAIMED;
		pXNQFrame = NULL;
		goto Exit;
	}

    *pProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;
	*phNextProtocol = GetProtocolFromName("XNQ");
	pXNQFrame += dwCurrentPacketLen;

Exit:
	return pXNQFrame;
}

//==================================================================================
// XNQ_AttachProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XNQ
//
// Arguments:
//	HFRAME			hFrame			Handle of the frame that is being parsed. 
//	LPBYTE			lpFrame			Pointer to the first byte in a frame.
//	LPBYTE			pXNQFrame		Pointer to the start of the recognized data.
//	DWORD			MacType			MAC value of the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes in a frame, starting
//									at the beginning of the recognized data.
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol.
//	DWORD			nPrevProtOffset	Offset of the previous protocol, starting at the
//									beginning of the frame.
//	DWORD			InstData		Pointer to the instance data from the previous protocol.
//
// Returns: When the function is successful, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When the function isn't successful, returns the original pXNQFrame value to
//			submit the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XNQ_AttachProperties(	HFRAME      hFrame,         
								   LPBYTE      pMacFrame,     
								   LPBYTE      pXNQFrame,   
								   DWORD       MacType,        
								   DWORD       BytesLeft,      
								   HPROTOCOL   hPrevProtocol,  
								   DWORD       nPrevProtOffset,
								   DWORD       InstData)       
								   
{	
	DWORD dwPacketIndex = 0, dwItemCounter = 0;
	DWORD dwCurrentPacketLen = 0, dwTempAddr = 0;
	
	// Apply the header overlay in order to decode the protocol
	PBASE_HEADER pXNQHeader = (PBASE_HEADER) pXNQFrame;
	
	// Go ahead and apply all packet overlays (easier to read than casting repeatedly)
	PQHELLO_MSG pQHelloMsg = (PQHELLO_MSG) pXNQHeader;
	PQUSERINFO_MSG pQUserInfoMsg = (PQUSERINFO_MSG) pXNQHeader;
	PQADD_MSG pQAddMsg = (PQADD_MSG) pXNQHeader;
	PQDELETE_MSG pQDeleteMsg = (PQDELETE_MSG) pXNQHeader;
	PQDELETEMATCHES_MSG pQDeleteMatchesMsg = (PQDELETEMATCHES_MSG) pXNQHeader;
	PQDEADXIP_MSG pQDeadXipMsg = (PQDEADXIP_MSG) pXNQHeader;
	PQDEADXRG_MSG pQDeadXrgMsg = (PQDEADXRG_MSG) pXNQHeader;
	PQLIST_MSG pQListMsg = (PQLIST_MSG) pXNQHeader;
	PQLISTREPLY_MSG pQListReplyMsg = (PQLISTREPLY_MSG) pXNQHeader;
	PBASEACK_MSG pBaseAckMsg = (PBASEACK_MSG) pXNQHeader;

	// Verify there is enough data for a basic header
	if(BytesLeft < sizeof(BASE_HEADER))
	{
		pXNQFrame = NULL;
		goto Exit;
	}

	// Determine the size of this packet and verify that there is enough data left to parse it
	dwCurrentPacketLen = pXNQHeader->dwMsgLen + sizeof(BASE_HEADER);
	if(dwCurrentPacketLen > BytesLeft)
	{
		pXNQFrame = NULL;
		goto Exit;
	}
	
	//
	// Attach the header information...
	//
	
	if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_SUMMARY].hProperty, dwCurrentPacketLen, (LPBYTE)pXNQFrame, 0, 0, 0))
	{
		goto SkipToNextPacket;
	}
	
	if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_MESSAGE_TYPE].hProperty, sizeof(pXNQHeader->dwMsgType),
		(LPBYTE) &(pXNQHeader->dwMsgType), 0, 1, 0))
	{
		goto SkipToNextPacket;
	}
	
	if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_MESSAGE_LENGTH].hProperty, sizeof(pXNQHeader->dwMsgLen),
		(LPBYTE) &(pXNQHeader->dwMsgLen), 0, 1, 0))
	{
		goto SkipToNextPacket;
	}
	
	if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_SEQUENCE_NUM].hProperty, sizeof(pXNQHeader->dwSeqNum),
		(LPBYTE) &(pXNQHeader->dwSeqNum), 0, 1, 0))
	{
		goto SkipToNextPacket;
	}
	
	if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_SESSION_ID].hProperty, sizeof(pXNQHeader->dwSessID),
		(LPBYTE) &(pXNQHeader->dwSessID), 0, 1, 0))
	{
		goto SkipToNextPacket;
	}
	
	//
	// Attach the packet-specific information...
	//
	switch(pXNQHeader->dwMsgType)
	{
	case QMSG_HELLO:
		if(dwCurrentPacketLen < sizeof(QHELLO_MSG))
		{
			break;
		}
		
		// Attach the version number
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_VERSION].hProperty, sizeof(pQHelloMsg->dwProtocolVersion),
			(LPBYTE) &(pQHelloMsg->dwProtocolVersion), 0, 1, 0))
		{
			break;
		}
		
		// If there are no more bytes for the version description then exit
		if(dwCurrentPacketLen <= sizeof(QHELLO_MSG))
		{
			break;
			
		}
		
		for(dwPacketIndex = sizeof(QHELLO_MSG); dwPacketIndex < dwCurrentPacketLen; ++dwPacketIndex)
		{
			if(!pXNQFrame[dwPacketIndex])
				goto SkipToNextPacket;
		}
		
		// If the string was longer than 0, then display it to Netmon
		if(dwPacketIndex - sizeof(QHELLO_MSG))
		{
			
			if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_VERSION_DESC].hProperty, dwPacketIndex - sizeof(QHELLO_MSG),
				(LPBYTE) pXNQFrame + sizeof(QHELLO_MSG), 0, 1, 0))
			{
				break;
			}
		}
		
		break;
		
	case QMSG_USER_INFO:
		if(dwCurrentPacketLen < sizeof(QUSERINFO_MSG))
		{
			break;
		}
		
		// Attach the user ID
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(pQUserInfoMsg->qwUserID),
			(LPBYTE) &(pQUserInfoMsg->qwUserID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the Xbox IP
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_XIP].hProperty, sizeof(pQUserInfoMsg->qwXIP),
			(LPBYTE) &(pQUserInfoMsg->qwXIP), 0, 1, 0))
		{
			break;
		}
		
		// Attach the XRG address
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_XRG].hProperty, sizeof(pQUserInfoMsg->qwXRG),
			(LPBYTE) &(pQUserInfoMsg->qwXRG), 0, 1, 0))
		{
			break;
		}
		
		dwTempAddr = ntohl(pQUserInfoMsg->dwTickleIP);

		// Attach the tickle IP
		if(!AttachPropertyInstanceEx(hFrame, XNQPropertyTable[XNQ_TICKLE_IP].hProperty, sizeof(pQUserInfoMsg->dwTickleIP),
			(LPBYTE) &(pQUserInfoMsg->dwTickleIP), sizeof(DWORD), &dwTempAddr, 0, 1, 0))
		{
			break;
		}
		
		// Attach the tickle port
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_TICKLE_PORT].hProperty, sizeof(pQUserInfoMsg->wTicklePort),
			(LPBYTE) &(pQUserInfoMsg->wTicklePort), 0, 1, 0))
		{
			break;
		}
		
		break;
		
	case QMSG_ADD:
		if(dwCurrentPacketLen < sizeof(QADD_MSG))
		{
			break;
		}
		
		// Attach the queue type
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_QUEUE_TYPE].hProperty, sizeof(pQAddMsg->dwQType),
			(LPBYTE) &(pQAddMsg->dwQType), 0, 1, 0))
		{
			break;
		}
		
		// Attach the user count
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USER_COUNT].hProperty, sizeof(pQAddMsg->dwUserCount),
			(LPBYTE) &(pQAddMsg->dwUserCount), 0, 1, 0))
		{
			break;
		}
		
		// If we don't have room for the user ID's then move on to the next packet
		if((sizeof(QADD_MSG) + pQAddMsg->dwUserCount * sizeof(QWORD)) > dwCurrentPacketLen)
		{
			break;
		}
		
		for(dwItemCounter = 0; dwItemCounter < pQAddMsg->dwUserCount; ++dwItemCounter)
		{
			dwPacketIndex = sizeof(QADD_MSG) + dwItemCounter * sizeof(QWORD);
			
			// Attach the user IDs
			if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(QWORD),
				(LPBYTE) pXNQFrame + dwPacketIndex, 0, 1, 0))
			{
				goto SkipToNextPacket;
			}
		}
		
		// If we don't have room for the add data then move on to the next packet
		if((sizeof(QADD_MSG) + pQAddMsg->dwUserCount * sizeof(QWORD)) == dwCurrentPacketLen)
		{
			break;
		}
		
		dwPacketIndex = sizeof(QADD_MSG) + pQAddMsg->dwUserCount * sizeof(QWORD);
		
		// Attached the added data
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_ADDED_DATA].hProperty, dwCurrentPacketLen - dwPacketIndex,
			(LPBYTE) pXNQFrame + dwPacketIndex, 0, 1, 0))
		{
			break;
		}
		
		break;
		
	case QMSG_DELETE:
		if(dwCurrentPacketLen < sizeof(QDELETE_MSG))
		{
			break;
		}
		
		// Attach the user ID
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(pQDeleteMsg->qwUserID),
			(LPBYTE) &(pQDeleteMsg->qwUserID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the queue type
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_QUEUE_TYPE].hProperty, sizeof(pQDeleteMsg->dwQType),
			(LPBYTE) &(pQDeleteMsg->dwQType), 0, 1, 0))
		{
			break;
		}
		
		// Attach the ID for the first element to delete
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_FIRST_QUID].hProperty, sizeof(pQDeleteMsg->qwFirstQUID),
			(LPBYTE) &(pQDeleteMsg->qwFirstQUID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the ID for the last element to delete
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_LAST_QUID].hProperty, sizeof(pQDeleteMsg->qwLastQUID),
			(LPBYTE) &(pQDeleteMsg->qwLastQUID), 0, 1, 0))
		{
			break;
		}
		
		break;
		
	case QMSG_DELETE_MATCHES:
		if(dwCurrentPacketLen < sizeof(QDELETEMATCHES_MSG))
		{
			break;
		}
				
		// Attach the queue type
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_QUEUE_TYPE].hProperty, sizeof(pQDeleteMatchesMsg->dwQType),
			(LPBYTE) &(pQDeleteMatchesMsg->dwQType), 0, 1, 0))
		{
			break;
		}
		
		// Attach the attrib ID
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_ATTRIB_ID].hProperty, sizeof(pQDeleteMatchesMsg->dwMatchAttrNum),
			(LPBYTE) &(pQDeleteMatchesMsg->dwMatchAttrNum), 0, 1, 0))
		{
			break;
		}
		
		// Attach the user count
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USER_COUNT].hProperty, sizeof(pQDeleteMatchesMsg->dwUserCount),
			(LPBYTE) &(pQDeleteMatchesMsg->dwUserCount), 0, 1, 0))
		{
			break;
		}
		
		// If we don't have room for the user ID's then move on to the next packet
		if((sizeof(QDELETEMATCHES_MSG) + pQDeleteMatchesMsg->dwUserCount * sizeof(QWORD)) > dwCurrentPacketLen)
		{
			break;
		}
		
		for(dwItemCounter = 0; dwItemCounter < pQDeleteMatchesMsg->dwUserCount; ++dwItemCounter)
		{
			dwPacketIndex = sizeof(QDELETEMATCHES_MSG) + dwItemCounter * sizeof(QWORD);
			
			// Attach the user IDs
			if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(QWORD),
				(LPBYTE) pXNQFrame + dwPacketIndex, 0, 1, 0))
			{
				goto SkipToNextPacket;
			}
		}

		// If we don't have room for the attribute data then move on to the next packet
		if((sizeof(QDELETEMATCHES_MSG) + pQDeleteMatchesMsg->dwUserCount * sizeof(QWORD)) == dwCurrentPacketLen)
		{
			break;
		}
		
		dwPacketIndex = sizeof(QDELETEMATCHES_MSG) + pQDeleteMatchesMsg->dwUserCount * sizeof(QWORD);
		
		// Attached the deleted data
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_ATTRIB_DATA].hProperty, dwCurrentPacketLen - dwPacketIndex,
			(LPBYTE) pXNQFrame + dwPacketIndex, 0, 1, 0))
		{
			break;
		}
		
		break;
		
	case QMSG_DEAD_XIP:
		if(dwCurrentPacketLen < sizeof(QDEADXIP_MSG))
		{
			break;
		}
		
		// Attach the Xbox IP
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_XIP].hProperty, sizeof(pQDeadXipMsg->qwXIP),
			(LPBYTE) &(pQDeadXipMsg->qwXIP), 0, 1, 0))
		{
			break;
		}
		
		break;
	case QMSG_DEAD_XRG:
		if(dwCurrentPacketLen < sizeof(QDEADXRG_MSG))
		{
			break;
		}
		
		// Attach the XRG IP
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_XRG].hProperty, sizeof(pQDeadXrgMsg->qwXRG),
			(LPBYTE) &(pQDeadXrgMsg->qwXRG), 0, 1, 0))
		{
			break;
		}
		
		break;
		
	case QMSG_LIST:
		if(dwCurrentPacketLen < sizeof(QLIST_MSG))
		{
			break;
		}
		
		// Attach the user ID
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(pQListMsg->qwUserID),
			(LPBYTE) &(pQListMsg->qwUserID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the queue type
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_QUEUE_TYPE].hProperty, sizeof(pQListMsg->dwQType),
			(LPBYTE) &(pQListMsg->dwQType), 0, 1, 0))
		{
			break;
		}
		
		// Attach the cookie
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_COOKIE].hProperty, sizeof(pQListMsg->qwCookie),
			(LPBYTE) &(pQListMsg->qwCookie), 0, 1, 0))
		{
			break;
		}
		
		// Attach the ID of the first queue item to return
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_START_QUID].hProperty, sizeof(pQListMsg->qwStartQUID),
			(LPBYTE) &(pQListMsg->qwStartQUID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the max number of items to return
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_MAX_DATASIZE].hProperty, sizeof(pQListMsg->dwMaxTotalItemDataSize),
			(LPBYTE) &(pQListMsg->dwMaxTotalItemDataSize), 0, 1, 0))
		{
			break;
		}
		
		// Attach the max number of items to return
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_MAX_ITEMS].hProperty, sizeof(pQListMsg->dwMaxItems),
			(LPBYTE) &(pQListMsg->dwMaxItems), 0, 1, 0))
		{
			break;
		}
		
		break;
		
	case QMSG_LIST_REPLY:
		if(dwCurrentPacketLen < sizeof(QLISTREPLY_MSG))
		{
			break;
		}
		
		// Attach the user ID
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(pQListReplyMsg->qwUserID),
			(LPBYTE) &(pQListReplyMsg->qwUserID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the queue type
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_QUEUE_TYPE].hProperty, sizeof(pQListReplyMsg->dwQType),
			(LPBYTE) &(pQListReplyMsg->dwQType), 0, 1, 0))
		{
			break;
		}
		
		// Attach the reply result
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_RESULT].hProperty, sizeof(pQListReplyMsg->hr),
			(LPBYTE) &(pQListReplyMsg->hr), 0, 1, 0))
		{
			break;
		}
		
		// Attach the cookie
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_COOKIE].hProperty, sizeof(pQListReplyMsg->qwCookie),
			(LPBYTE) &(pQListReplyMsg->qwCookie), 0, 1, 0))
		{
			break;
		}
		
		// Attach the ID of the next unreturned item in the queue
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_NEXT_QUID].hProperty, sizeof(pQListReplyMsg->qwNextQUID),
			(LPBYTE) &(pQListReplyMsg->qwNextQUID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the number of items left in the queue
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_QUEUE_LEFT].hProperty, sizeof(pQListReplyMsg->dwQLeft),
			(LPBYTE) &(pQListReplyMsg->dwQLeft), 0, 1, 0))
		{
			break;
		}
		
		// Attach the number of items being returned
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_ITEMS_RETURNED].hProperty, sizeof(pQListReplyMsg->dwNumItems),
			(LPBYTE) &(pQListReplyMsg->dwNumItems), 0, 1, 0))
		{
			break;
		}
		
		// Attach the total size of all queue items being returned
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_RETURNED_DATASIZE].hProperty, sizeof(pQListReplyMsg->dwTotalItemDataSize),
			(LPBYTE) &(pQListReplyMsg->dwTotalItemDataSize), 0, 1, 0))
		{
			break;
		}
		
		if(dwCurrentPacketLen == sizeof(QLISTREPLY_MSG))
		{
			break;
		}
		
		dwPacketIndex = sizeof(QLISTREPLY_MSG);
		
		// Attached the returned data
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_RETURNED_DATA].hProperty, dwCurrentPacketLen - dwPacketIndex,
			(LPBYTE) pXNQFrame + dwPacketIndex, 0, 1, 0))
		{
			break;
		}
		
		
		break;
		
	case MSGTYPE_ACK:
		if(dwCurrentPacketLen < sizeof(BASEACK_MSG))
		{
			break;
		}
		
		// Attach the acked message type
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_MESSAGE_TYPE].hProperty, sizeof(pBaseAckMsg->dwAckMsgType),
			(LPBYTE) &(pBaseAckMsg->dwAckMsgType), 0, 1, 0))
		{
			break;
		}
		
		// Attach the acked sequence number
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_SEQUENCE_NUM].hProperty, sizeof(pBaseAckMsg->dwAckSeqNum),
			(LPBYTE) &(pBaseAckMsg->dwAckSeqNum), 0, 1, 0))
		{
			break;
		}
		
		// Attach the user ID
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_USERID].hProperty, sizeof(pBaseAckMsg->qwAckUserID),
			(LPBYTE) &(pBaseAckMsg->qwAckUserID), 0, 1, 0))
		{
			break;
		}
		
		// Attach the acked result
		if(!AttachPropertyInstance(hFrame, XNQPropertyTable[XNQ_RESULT].hProperty, sizeof(pBaseAckMsg->hrAck),
			(LPBYTE) &(pBaseAckMsg->hrAck), 0, 1, 0))
		{
			break;
		}
		
		break;
		// We should never get here since we already scanned for this in RecognizeFrame.
		// Don't claim any data, just exit
	default:
		break;
	}

SkipToNextPacket:
	pXNQFrame += dwCurrentPacketLen;

Exit:
	return pXNQFrame;
}

//==================================================================================
// XNQ_FormatProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to format each property that was attached by
//	XNQ_AttachProperties
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that is being parsed.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame.
//	LPBYTE			pXNQFrame		Pointer to the beginning of the protocol data in a frame.
//	DWORD			nPropertyInsts	Number of PROPERTYINST structures provided by lpPropInst. 
//	LPPROPERTYINST	p				Pointer to an array of PROPERTYINST structures. 
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
DWORD WINAPI XNQ_FormatProperties(	HFRAME          hFrame,
									LPBYTE          pMacFrame,
									LPBYTE          pXNQFrame,
									DWORD           nPropertyInsts,
									LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }

    return NMERR_SUCCESS;
}

//============================================================================
//  Function: XNQ_FormatSummary
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  Your Name Here      01/01/70    Created
//============================================================================
VOID WINAPIV XNQ_FormatSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;

//     Print "XQueue Message"
	 sprintf( pReturnedString, "XQueue Message");
}


//============================================================================
//  Function: XNQ_FormatQueueID
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  Your Name Here      01/01/70    Created
//============================================================================
VOID WINAPIV XNQ_FormatQueueID( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	PBYTE pByteIndex = (PBYTE) (pPropertyInst->lpData);

	if(pPropertyInst->DataLength < sizeof(QWORD))
	{
		sprintf( pReturnedString, "QueueID: <not enough data to parse>");
	}
	else
	{
		sprintf( pReturnedString, "QueueID: 0x%02X%02X%02X%02X%02X%02X%02X%02X",
			pByteIndex[7], pByteIndex[6], pByteIndex[5], pByteIndex[4], pByteIndex[3], pByteIndex[2], pByteIndex[1], pByteIndex[0]);
	}
}


//============================================================================
//  Function: XNQ_FormatUserCookie
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  Your Name Here      01/01/70    Created
//============================================================================
VOID WINAPIV XNQ_FormatUserCookie( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	PBYTE pByteIndex = (PBYTE) (pPropertyInst->lpData);

	if(pPropertyInst->DataLength < sizeof(QWORD))
	{
		sprintf( pReturnedString, "User cookie: <not enough data to parse>");
	}
	else
	{
		sprintf( pReturnedString, "User cookie: 0x%02X%02X%02X%02X%02X%02X%02X%02X",
			pByteIndex[7], pByteIndex[6], pByteIndex[5], pByteIndex[4], pByteIndex[3], pByteIndex[2], pByteIndex[1], pByteIndex[0]);
	}
}


//============================================================================
//  Function: XNQ_FormatUserID
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  Your Name Here      01/01/70    Created
//============================================================================
VOID WINAPIV XNQ_FormatUserID( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	PBYTE pByteIndex = (PBYTE) (pPropertyInst->lpData);

	if(pPropertyInst->DataLength < sizeof(QWORD))
	{
		sprintf( pReturnedString, "UserID: <not enough data to parse>");
	}
	else
	{
		sprintf( pReturnedString, "UserID: 0x%02X%02X%02X%02X%02X%02X%02X%02X",
			pByteIndex[7], pByteIndex[6], pByteIndex[5], pByteIndex[4], pByteIndex[3], pByteIndex[2], pByteIndex[1], pByteIndex[0]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\XSGtest\StdAfx.h ===
//------------------------------------------------------------------------------
// XBox Online
//
// File: 		StdAfx.h
//
// Copyright:	Copyright (c) 2001 Microsoft Corporation.
//
// Contents:	include file for standard system include files,
//  			or project specific include files that are used frequently, but
//      		are changed infrequently
//
// History:	01/15/2001	JohnBlac	Created
//
//------------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__62E4D979_49B6_11D2_8A7B_00C04F8ECE95__INCLUDED_)
#define AFX_STDAFX_H__62E4D979_49B6_11D2_8A7B_00C04F8ECE95__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#pragma warning(push)
#pragma warning(disable : 4995)

#pragma warning(pop)

#include <windows.h>
#include <xbox.h>
#include <winsockx.h>
#include <winsockp.h>
#include <xonlinep.h>

#include <stdlib.h>
#include <time.h>
#include <vlan.h>

#include <stdio.h>
#include <winsock2.h>
#include <oledb.h>		// Needed for SafeArrays and TLDB lib
#include "Iphlpapi.h"

#define NUMELEM(p1) (sizeof(p1) / sizeof(*p1))
#ifdef _DEBUG
#define ASSERT(x) if(!x){DebugBreak();}
#else
#define ASSERT(x) 1
#endif 

#define Assert(exp) _ASSERTE(exp)
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__62E4D979_49B6_11D2_8A7B_00C04F8ECE95__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\XSGtest\XSGTest.h ===
//------------------------------------------------------------------------------
// XBox Online
//
// File:		XSGTest.h
//
// Copyright:	Copyright (c) 2001 Microsoft Corporation
//
// Contents:	Declarations for XSGTest.cpp.
//
// History:	01/02/2002	johnblac created
//
//------------------------------------------------------------------------------

#ifndef XSGTEST_H
#define XSGTEST_H

#include "StdAfx.h"

struct IP_HEADER
{
	BYTE bVersion;
	BYTE bTypeOfService;
	WORD wLength;			// IPheader + UDP header + data
	WORD wIdentification;
	WORD wFlagsAndOffset;	// first 3 bits are flags, 13-bits for frag offset
	BYTE bTTL;				// Time to Live
	BYTE bProtocol;
	WORD wChecksum;
	DWORD dwSrcAddress;
	DWORD dwDestAddress;	
};

struct ENET_HEADER
{
	BYTE rgbDestMAC[6];
	BYTE rgbSrcMAC[6];
	WORD wEnetType;
};

struct UDP_HEADER
{
	WORD wSrcPort;
	WORD wDestPort;
	WORD wLength;		// UDP header + data
	WORD wChecksum;
};

BOOL atoh(BYTE* pDestHex, WCHAR* pSrcChar, UINT uiLen);
void CopyHeaders(BYTE* prgbFrameBuffer, ENET_HEADER* pEnetHdr, UINT uiEnetSize, IP_HEADER* pIPHdr, UINT uiIPSize, UDP_HEADER* pUDPHdr, UINT uiUDPSize);void E(HRESULT hr);
bool GetLocalMachineAddress();
void InitGlobalArray();
HRESULT InitializeNetworkUDP(SOCKET* ps1, SOCKADDR_IN* psXCSAddress);
HRESULT InitializeNetworkTCP(SOCKET* ps1, SOCKADDR_IN* psXCSAddress, u_short uPort);
HRESULT ReceiveFromCS(SOCKET sSocket, BYTE* pBuffer, DWORD dwLength, DWORD* pdwBytesRecvd);
void SetNetworkHeaders(ENET_HEADER* pEnetHdr, IP_HEADER* pIPHdr, UDP_HEADER* pUDPHdr, WORD wDataLen);
HRESULT RunTestCases(SOCKET* ps1, SOCKADDR_IN* psXCSAddress);
HRESULT SendToCS(SOCKET	sSocket,	SOCKADDR_IN sAddr, const BYTE* pBuffer, DWORD cchBuffer);
void SetKeysToValidState(CKeyExHdr* pFirstKeyExHdr, CKeyExHdr* pSecondKeyExHdr, CKeyExHdr* pThirdKeyExHdr);
HRESULT SGEncryption(SOCKET* pSocket, SOCKADDR_IN* psXSGAddress, int nTestNum);
HRESULT SGKeyOrder(SOCKET* pSocket, SOCKADDR_IN* psXSGAddress, int nTestNum);
HRESULT SGRouting(SOCKET* pSocket, SOCKADDR_IN* psXSGAddress, int nTestNum);
HRESULT SGTicketValidity(SOCKET* pSocket, SOCKADDR_IN* psXSGAddress, int nTestNum);
HRESULT SGValidity(SOCKET* pSocket, SOCKADDR_IN* psXSGAddress, int nTestNum);
HRESULT WriteBadFrame(BYTE* pBuff, char* pbHexString, DWORD wHexStringSize, WORD wBufferLength);

const UINT k_uiNumHeartBeats = 3;
const DWORD k_dw2048const = 2048;
const DWORD k_dwDHKeySize = 96;
const WORD k_w2048const = 2048;
const WORD k_w1522const = 1522;
const DWORD k_dw5secTimeout = 5000;
const DWORD k_dw60secTimeout = 60000;
const DWORD k_dwXBoxHeartbeat = 10000;
const DWORD k_dwCSHeartbeat = 20000;
const DWORD k_dwClientTimeout = 600000;
const long k_lMSTimeout = 65;
const UINT k_uiSocketTimeout = 5000;
const UINT k_uiMSRetryMax = 5;

HRESULT E_NOTHING_RECEIVED =9600;

#endif // XSGTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\2kIdMaster.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _2KIDMASTER_H_
#define _2KIDMASTER_H_

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "2kId_Tests.h"
#include "2kId_Utils.h"
   
CONST DWORD DO_LOCALHOST = 0x01;

class C2kIdMaster : C2kIdTests { //, C2kIdUtils( m_dwLoop ) {

public:
   
   VOID ValidateArgs(int argc, char **argv);
   VOID PrintHelp( VOID );


   C2kIdMaster(){ m_dwLoop=0; 
                  m_szXboxName[0] ='\0';}
   ~C2kIdMaster(){}

   
private:
   //Globals
   CHAR  m_szXboxName[MAX_PATH];
   DWORD m_dwLoop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\XSGtest\XSGTest.cpp ===
//------------------------------------------------------------------------------
// XBox Online
//
// File:		XSGTest.cpp
//
// Copyright:	Copyright (c) 2001 Microsoft Corporation
//
// Contents:	Functional test cases for the security gateway
//
// History:	01/02/2002	johnblac		Created
//
//------------------------------------------------------------------------------

#include "StdAfx.h"
#include "XSGTest.h"
#include "messages.h"

// Globals
DWORD g_dwSrcAddress = 0;
DWORD g_dwDestAddress = 0;
UINT g_uiFailedCases = 0;
UINT g_uiPassedCases = 0;
UINT g_nLogResults = 0;

BYTE g_rgbSrcMAC[6];
BYTE g_rgbDestMAC[6];
BYTE g_rgbHexTable[103];
FILE *g_pOutput;

// s1 is a UDP socket descriptor
SOCKET               g_sUDP1 = INVALID_SOCKET;
// sTCPMS is a TCP socket descriptor for the monitoring server
SOCKET               g_sTCP1 = INVALID_SOCKET;

WCHAR g_wszSG_IP[16];		// String version of SG IP address
WCHAR g_wszTester[25];		// Tester Name
WCHAR g_wszBuild[12];		// Build name
IN_ADDR g_ipSGIP;			// SG IP address
u_short g_usPort = 3074;		// SG Port
WCHAR g_wszSep[] = L".";		// IP address seperator
int g_nMilestone = -1;		// Milestone
int g_nMachineType = 2;		// Type of machine running the test


//-----------------------------------------------------------------------------
//
// atoh
//
// Converts and even length WCHAR string to hex.  The hex value is placed in the destination
// buffer.  The caller is responsible for making the destination buffer long enough.
//
BOOL atoh(BYTE* pDestHex, WCHAR* pSrcChar, UINT uiLen)
{
	if(!pDestHex || !pSrcChar || (uiLen %2 != 0))
	{
		return FALSE;
	}

	BYTE bTempVal = 0;
	
	for(UINT i = 0; i < uiLen/2; i++)
	{
		bTempVal = 16*g_rgbHexTable[*pSrcChar];
		pSrcChar++;
		bTempVal += g_rgbHexTable[*pSrcChar];
		*pDestHex = bTempVal;
		pSrcChar++;
		pDestHex++;
	}

	return TRUE;
}


//-----------------------------------------------------------------------------
//
// E
//
// Checks the error code and increments the appropriate counter.
//
void E(HRESULT hr) 
{ 
	if (FAILED(hr)) 
	{ 
		g_uiFailedCases++; 
	}
	else
	{
		g_uiPassedCases++;
	}
}


WCHAR* FindOneOf
//-----------------------------------------------------------------------------
//
// FindOneOf
//
// Modified version of ATL code that looks for an instance of string p1 in string p2 using only\
// WCHARs.
//
( 
	WCHAR* p1, 
	WCHAR* p2
)
{
    while (p1 != NULL && *p1 != NULL)
    {
        WCHAR* p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


//-----------------------------------------------------------------------------
//
// FillData
//
// Takes a BYTE pointer to a buffer with a given size and maximum length of the buffer.  The 
// buffer is filled with 'bogus' data.
//
HRESULT FillData(BYTE* pBuff, DWORD wSize, WORD wBufferLength)
{
	if(!pBuff || wSize > wBufferLength)
	{
		return E_FAIL;
	}

	ZeroMemory(pBuff, wBufferLength);
	WORD wCount = 0;
	while(wCount < wSize)
	{
		switch(wCount % 3)
		{
		case 0:
			*pBuff = 0xC0;
			break;
		case 1:
			*pBuff = 0xFF;
			break;
		case 2:
			*pBuff = 0xEE;
			break;
		default:
			return E_UNEXPECTED;
		}
		wCount++;
		pBuff++;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
//
// FillData
//
// Takes a BYTE pointer to a buffer with a given size and maximum length of the buffer.  The 
// buffer is filled with 'bogus' data.
//
HRESULT WriteBadFrame
(
	// [in/out] Destination buffer to contain the hex values of the input string
	BYTE* pBuff,
	//[in] Character string of hex values to be translated into memory
	char* pbHexString,
	// [in] Size of pbHexString
	DWORD wHexStringSize, 
	// [in] size of buffer pBuff points to
	WORD wBufferLength
)
{
	if(!pBuff || wHexStringSize > wBufferLength)
	{
		return E_FAIL;
	}

	ZeroMemory(pBuff, wBufferLength);
	WORD wCount = 0;
	BYTE bTempVal = 0;
	
	while(wCount < wHexStringSize)
	{
		bTempVal = 16*g_rgbHexTable[*pbHexString];
		pbHexString++;
		bTempVal += g_rgbHexTable[*pbHexString];
		*pBuff = bTempVal;
		pBuff++;
		pbHexString++;
		wCount++;
	}

	return S_OK;
}


//-----------------------------------------------------------------------------
//
// GetChecksum
//
// Takes a pointer to an IP header cast to a WORD* type and calculates a checksum value for 
// that header.  This checksum is returned.
//
WORD GetChecksum(WORD * pBuff, UINT uiSize)
{
	WORD wChecksum = 0;
	WORD wPrevChecksum = 0;
	WORD wOverflow = 0;

	for(UINT ui = 0; ui < uiSize; ui++)
	{
		wChecksum += htons(*pBuff);
		pBuff++;
		
		if(wChecksum < wPrevChecksum)
			wOverflow++;

		wPrevChecksum = wChecksum;
	}

	return htons((~wChecksum)-wOverflow);
}

/*
///////////////////////////////////////
//    GetLocalMachineAddresses
//
bool GetLocalMachineAddress()
{ 
	XNADDR xThisXbox;
	static struct in_addr myaddr;

	// Get host name or token
	XNetGetTitleXnAddr(&xThisXbox);
	memcpy(&myaddr, &xThisXbox.ina, sizeof(myaddr));

	char szHostName[ k_dw2048const ];
	if( gethostname( szHostName, k_dw2048const ) != 0 )
	{
		printf( "gethostname failed! Error = %d\n", WSAGetLastError() );
		return( false );
	}
 
	// Get list of host addresses
	HOSTENT* pHostEnt = gethostbyname( szHostName );
	if( NULL == pHostEnt )
	{
		printf( "gethostbyname failed! Error = %d\n", WSAGetLastError() );
		return( false );
	}
	else
	{
		g_dwSrcAddress = htonl(*(DWORD*)(*(DWORD*)pHostEnt->h_addr_list));
	}

	return( true );
}
*/

//-----------------------------------------------------------------------------
//
// GetNewNounce
//
// This assignes the current tick count to the first 4 bytes of the array and a rand to the last 4 
// bytes.  It is a vein attempt to generate a semi-random number.
//
void GetNewNounce(
	// [in/out] Array to contain the random bits
	BYTE rgbNonce[8]
)
{
	*(DWORD*)(rgbNonce) = GetTickCount();
	*(DWORD*)(rgbNonce + sizeof(DWORD)) = (DWORD)rand();
	// TODO: replace this hack by a real random nounce
}


//-----------------------------------------------------------------------------
//
// Initialize Network
//
// This function initializes winsock and creates a socket for UDP communications.
//
HRESULT InitializeNetworkUDP(
	// [in/out] socket for communications
	SOCKET* ps1, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress
)
{
	HRESULT hr = S_OK;
	// iLastError is the last error code
	int                  iLastError = ERROR_SUCCESS;	
	// nBytes is the number of bytes sent or received on the socket
	int                  nBytes;

	ZeroMemory(psXSGAddress, sizeof(*psXSGAddress)); // BUGBUG
	
	// Create a UDP socket
	*ps1 = socket(AF_INET, SOCK_DGRAM, 0);
	if (INVALID_SOCKET == *ps1) 
	{
		// Get the last error code
		iLastError = GetLastError();
		hr = E_FAIL;
		goto FunctionExit1;
	}

	u_long ulNonblock;
	ulNonblock = 1;
	iLastError = ioctlsocket(*ps1, FIONBIO, &ulNonblock);
	if(SOCKET_ERROR == iLastError)
	{
		printf("ioctlsocket failed for s1\n");
		hr = E_FAIL;
		goto FunctionExit1;
	}

	// Set the receive timeout value to 5 sec
	if (SOCKET_ERROR == setsockopt(*ps1, SOL_SOCKET, SO_RCVTIMEO, (char *) &k_uiSocketTimeout, sizeof(k_uiSocketTimeout))) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
		hr = E_FAIL;
		goto FunctionExit1;
	}

	// Set the send timeout value to 5 sec
	if (SOCKET_ERROR == setsockopt(*ps1, SOL_SOCKET, SO_SNDTIMEO, (char *) &k_uiSocketTimeout, sizeof(k_uiSocketTimeout))) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
		hr = E_FAIL;
		goto FunctionExit1;
	}

	// Assign the port and IP
	psXSGAddress->sin_port = htons(g_usPort);
	psXSGAddress->sin_family = AF_INET;
	psXSGAddress->sin_addr.S_un.S_un_b.s_b1 = g_ipSGIP.S_un.S_un_b.s_b1;
	psXSGAddress->sin_addr.S_un.S_un_b.s_b2 = g_ipSGIP.S_un.S_un_b.s_b2;
	psXSGAddress->sin_addr.S_un.S_un_b.s_b3 = g_ipSGIP.S_un.S_un_b.s_b3;
	psXSGAddress->sin_addr.S_un.S_un_b.s_b4 = g_ipSGIP.S_un.S_un_b.s_b4;

FunctionExit1:
	return hr;
}


//-----------------------------------------------------------------------------
//
// InitGlobalArray
//
// This fills out a global array used for converting ASCII to hex.
//
void InitGlobalArray()
{
	ZeroMemory(g_rgbHexTable, sizeof(g_rgbHexTable));
	g_rgbHexTable[48] = 0x0;
	g_rgbHexTable[49] = 0x1;
	g_rgbHexTable[50] = 0x2;
	g_rgbHexTable[51] = 0x3;
	g_rgbHexTable[52] = 0x4;
	g_rgbHexTable[53] = 0x5;
	g_rgbHexTable[54] = 0x6;
	g_rgbHexTable[55] = 0x7;
	g_rgbHexTable[56] = 0x8;
	g_rgbHexTable[57] = 0x9;	
	g_rgbHexTable[65] = 0xA;
	g_rgbHexTable[66] = 0xB;
	g_rgbHexTable[67] = 0xC;
	g_rgbHexTable[68] = 0xD;
	g_rgbHexTable[69] = 0xE;
	g_rgbHexTable[70] = 0xF;
	g_rgbHexTable[97] = 0xA;
	g_rgbHexTable[98] = 0xB;
	g_rgbHexTable[99] = 0xC;
	g_rgbHexTable[100] = 0xD;
	g_rgbHexTable[101] = 0xE;
	g_rgbHexTable[102] = 0xF;
}


//-----------------------------------------------------------------------------
//
// Initialize NetworkTCP
//
// This function initializes winsock and creates a socket for UDP communications.
//
HRESULT InitializeNetworkTCP(
	// [in/out] socket for TCP communications
	SOCKET* ps1, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress,
	// [in] Port to open this socket on
	u_short uPort
)
{
	// iLastError is the last error code
	int                  iLastError = ERROR_SUCCESS;
	// iResult is the result of a function
	int                  iResult = 0;
    
	// LowPort is the low bound of the netsync port range
	u_short              LowPort = 0;
	// HighPort is the high bound of the netsync port range
	u_short              HighPort = 0;

	// readfds is the set of sockets to check for a pending connection
	fd_set               readfds;
	// iTimeout is the send and receive timeout value for the socket
	int                  iTimeout;
	// portname is the local address associated with a socket
	SOCKADDR_IN          portname = { AF_INET, 0, 0, {'\0'} };
	// toname is the recipient address information structure
	SOCKADDR_IN          toname = { AF_INET, 0, 0, {'\0'} };
	// ReceiveBuffer is the receive buffer
	char                 ReceiveBuffer[k_dw2048const];
	// nBytes is the number of bytes sent or received on the socket
	int                  nBytes;
	// Number of backlog requests we accept
	int			iBackLog = 8;
	// No delay flag
	bool bNoDelay = TRUE;
	
	char BVTBuffer[k_dw2048const] = "C0FFEEC0FFEE";
	
	// Create a TCP socket
	*ps1 = socket(AF_INET, SOCK_STREAM, 0);
	if (INVALID_SOCKET == *ps1) 
	{
		// Get the last error code
		iLastError = GetLastError();
		goto FunctionExit4;
	}

	// Set the receive timeout value to 5 sec
	iTimeout = 5000;
	if (SOCKET_ERROR == setsockopt(*ps1, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
		goto FunctionExit4;
	}

	// Set the send timeout value to 5 sec
	iTimeout = 5000;
	if (SOCKET_ERROR == setsockopt(*ps1, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
		goto FunctionExit4;
	}

	if (SOCKET_ERROR == setsockopt(*ps1, IPPROTO_TCP, TCP_NODELAY, (char *)&bNoDelay, sizeof(bNoDelay))) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
		goto FunctionExit4;
	}

	// Bind TCP socket 1
	portname.sin_port = htons(uPort);
	if (SOCKET_ERROR == bind(*ps1, (SOCKADDR *) &portname, sizeof(portname))) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
		goto FunctionExit4;
	}

	// Initialize connect
	toname.sin_port = htons(uPort);
	toname.sin_addr.S_un.S_un_b = psXSGAddress->sin_addr.S_un.S_un_b;

	// Listen on TCP socket 1
	if (SOCKET_ERROR == listen(*ps1, iBackLog) )
	{
		// Get the last error code
		iLastError = WSAGetLastError();
	}

FunctionExit4:
/*	// Close the TCP socket
	if (0 != closesocket(*ps1)) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
	}
*/

	return (ERROR_SUCCESS == iLastError);
}


DWORD ReadIni
//-----------------------------------------------------------------------------
//
// ReadIni
// 
// This reads the data source information from the ini file provided on the 
// command line.  The key names are the same as what DLP uses, so you should
// be able to simply cut and paste datasources from any of your own config.ini 
// files to the ini file used for this program.
//
(
	WCHAR* ThisIniFile
	// [in] ThisIniFile - argument string pointing to the ini file
)
{
	WCHAR* pwszSrc;
	WCHAR wszDigit[4];
	WCHAR wszMAC[13];
	ZeroMemory(wszDigit, sizeof(wszDigit));
	ZeroMemory(wszMAC, sizeof(wszMAC));	
	WCHAR* pwszDest = wszDigit;

	// Loads each test cases parameters
	g_usPort = (u_short)GetPrivateProfileInt(L"TestParameters", L"SGPort", 3074, ThisIniFile);
	g_nMachineType = GetPrivateProfileInt(L"TestParameters", L"LabOrPersonalSG", 2, ThisIniFile);
	g_nMilestone = GetPrivateProfileInt(L"TestParameters", L"Milestone", 10, ThisIniFile);
	g_nLogResults = GetPrivateProfileInt(L"TestParameters", L"LogResults", 0, ThisIniFile);
	DWORD dwReturn = GetPrivateProfileString(L"TestParameters", L"SGIP", L"127.0.0.1", &g_wszSG_IP[0], NUMELEM(g_wszSG_IP), ThisIniFile);
	dwReturn = GetPrivateProfileString(L"TestParameters", L"Tester", L"Lester", &g_wszTester[0], NUMELEM(g_wszTester), ThisIniFile);
	dwReturn = GetPrivateProfileString(L"TestParameters", L"Build", L"4033.000000", &g_wszBuild[0], NUMELEM(g_wszBuild), ThisIniFile);
	dwReturn = GetPrivateProfileString(L"TestParameters", L"DestinationMAC", L"000000000000", &wszMAC[0], NUMELEM(wszMAC), ThisIniFile);
	atoh(g_rgbDestMAC, wszMAC, 12);	
	pwszSrc = g_wszSG_IP;
	pwszDest = wcstok(pwszSrc, g_wszSep);
	g_ipSGIP.S_un.S_un_b.s_b1 = (unsigned char)_wtoi( pwszDest );
	pwszDest = wcstok(NULL, g_wszSep);	
	g_ipSGIP.S_un.S_un_b.s_b2 = (unsigned char)_wtoi( pwszDest );
	pwszDest = wcstok(NULL, g_wszSep);		
	g_ipSGIP.S_un.S_un_b.s_b3 = (unsigned char)_wtoi( pwszDest );
	pwszDest = wcstok(NULL, g_wszSep);		
	g_ipSGIP.S_un.S_un_b.s_b4 = (unsigned char)_wtoi( pwszDest );

	// restores the global variable
	dwReturn = GetPrivateProfileString(L"TestParameters", L"SGIP", L"127.0.0.1", &g_wszSG_IP[0], NUMELEM(g_wszSG_IP), ThisIniFile);

	// Set the destination address
	g_dwDestAddress = g_ipSGIP.S_un.S_un_b.s_b1*16777216 +
					  g_ipSGIP.S_un.S_un_b.s_b2*65536 +
					  g_ipSGIP.S_un.S_un_b.s_b3*256 +
					  g_ipSGIP.S_un.S_un_b.s_b4;

	return dwReturn;
}


//-----------------------------------------------------------------------------
//
// ReceiveFromCS
//
// This function listens for incomming UDP packets
//
HRESULT ReceiveFromCS(
	// [in] socket to listen on
	SOCKET sSocket,
	// [out] buffer to store incomming data (from the CS) in
	BYTE* pBuffer,
	// [in] Length of above buffer
	DWORD dwLength,
	// [out] number of bytes received.
	DWORD* pdwBytesRecvd
)
{
    HRESULT hr = S_OK;

    // Prepare to probe the inbound socket for readability
    
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(sSocket, &readfds);

    fd_set exceptfds;
    FD_ZERO(&exceptfds);
    FD_SET(sSocket, &exceptfds);
    
    TIMEVAL sTimeout = {0, 0}; 
	int iLastError = 0;

    // Probe the inbound socket. We don't want it to block so
    // timeout is set to zero.
    
    int iRes = select(0, &readfds, NULL, &exceptfds, &sTimeout);

    if(iRes > 0)
    {
        // One or more sockets were flagged. Let's check
        // the sets. Check for exceptions first.
                
        if(FD_ISSET(sSocket, &exceptfds))
        {
            printf("socket (recv) has exception\n");
            hr = E_FAIL;
        }
        else
        {
            // Socket is ready for reading

            ASSERT(FD_ISSET(sSocket, &readfds));
            
            // Read data from CS

            sockaddr_in sSourceAddr;
            int iSizeSourceAddr = sizeof(sSourceAddr);
                        
            int iBytesRecvd = recvfrom(sSocket, (char*) pBuffer, 
                dwLength, 0, (sockaddr*) &sSourceAddr, &iSizeSourceAddr);

            if(iBytesRecvd != SOCKET_ERROR)
            {
				iLastError = WSAGetLastError();
                if(pdwBytesRecvd)
                {
                    *pdwBytesRecvd = (DWORD) iBytesRecvd;
                }
            }
            else
            {
                iLastError = WSAGetLastError();
                hr = E_FAIL;
            }
        }
    }
    else
    {
        // No data
        hr = S_FALSE;
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
// RunTestCases
//
// All of the test cases are run from here
//
HRESULT RunTestCases(
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress
)
{
	HRESULT hr = S_OK;

	// SG Validity Tests
	printf("...Starting SG tests...\n");
	SGValidity(&g_sUDP1, psXSGAddress, 532);

	// SG Encryption Tests
	SGEncryption(&g_sUDP1, psXSGAddress, 500);
	
	// SG Routing tests
	SGRouting(&g_sUDP1, psXSGAddress, 435);
	
	//SG Key Order tests
	SGKeyOrder(&g_sUDP1, psXSGAddress, 477);

	//SG Ticket validity tests
	SGTicketValidity(&g_sUDP1, psXSGAddress, 478);
	
	return hr;
}


//-----------------------------------------------------------------------------
//
// SendToCS
//
// This function sends data in the buffer argument to the CS via a UDP packet or packets.
//
HRESULT SendToCS(
	// [in] socket to communicate on
	SOCKET	sSocket,
	// [in] address of CS to talk to
	SOCKADDR_IN sAddr,
	// [in] buffer of data to send
	const BYTE* pBuffer,
	// [in] number of bytes in above buffer
	DWORD cchBuffer
)
{
    HRESULT hr = S_OK;
    
    // Prepare to probe socket for writeability
    
    fd_set writefds;
    FD_ZERO(&writefds);
    FD_SET(sSocket, &writefds);

    fd_set exceptfds;
    FD_ZERO(&exceptfds);
    FD_SET(sSocket, &exceptfds);
    
    TIMEVAL sTimeout = {0, 0}; 

    // Probe the outbound socket. We don't want it to block so
    // timeout is set to zero.
    
    int iRes = select(0, NULL, &writefds, &exceptfds, &sTimeout);

    if(iRes > 0)
    {
        // One or more sockets were flagged. Let's check
        // the sets. Check for exceptions first.
                
        if(FD_ISSET(sSocket, &exceptfds))
        {
            printf("socket has exception\n");
            hr = E_FAIL;
        }
        else
        {
            // Socket is ready for writting

            ASSERT(FD_ISSET(sSocket, &writefds));
            
            // Send data to CS
            
            int iBytesSent = sendto(sSocket, (const char*) pBuffer, 
                cchBuffer, 0, (const sockaddr*) &sAddr, sizeof(sAddr));

            if(SOCKET_ERROR == iBytesSent)
            {
                printf("sendto failed to send %d bytes, error=%d\n", iBytesSent, WSAGetLastError());
                hr = E_FAIL;
            }
        }
    }
    else
    {
        // Socket is not ready
        hr = E_FAIL;
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
// SGEncryption
//
// Runs the test cases that check for well encrypted packets
//
HRESULT SGEncryption(
	// [in/out] socket for communications
	SOCKET* pSocket, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress,
	// [in] Test Number
	int nTestNum
)
{
	return S_OK;
}


//-----------------------------------------------------------------------------
//
// SGKeyOrder
//
// Runs the test cases that check for proper key order and polite failure for 
// improper key order
//
HRESULT SGKeyOrder(
	// [in/out] socket for communications
	SOCKET* pSocket, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress,
	// [in] Test Number
	int nTestNum
)
{
	ENET_HEADER sEnetHdr;
	IP_HEADER sIPHdr;
	UDP_HEADER sUDPHdr;
	CKeyExXbToSgInit XBtoSGInit;	// First header
	CKeyExHdr DHKeyExHdr;	// Second header
	CKeyExKerbApReq KerbApReq;	// Third header
	WORD wSizeOfHeaders = sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr);
	BYTE* rgbFrameBuffer = new BYTE[k_w1522const];
	BYTE* rgbDataBuffer = new BYTE[k_w1522const-wSizeOfHeaders];	
	WORD wDataLen = 0;
	DWORD dwSPI = 0;

	// Set up a valid Init Structure
	XBtoSGInit._dwSpiInit = 0x99887766;
	GetNewNounce(XBtoSGInit._abNonceInit);

	// Set up a valid KerbApReq structure
//	KerbApReq._ab

	// SG_VALID_KEY_ORDER
	SetKeysToValidState(&XBtoSGInit, &DHKeyExHdr, &KerbApReq);
	// Copy the SPI
	memcpy(rgbDataBuffer, &dwSPI, sizeof(dwSPI));
	// Copy the first KeyEx Header - a XBtoSGInit
	wDataLen += sizeof(dwSPI);
	memcpy(rgbDataBuffer+wDataLen, (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	// Copy the second KeyEx Header
	wDataLen += sizeof(XBtoSGInit);
	memcpy(rgbDataBuffer+wDataLen, (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));
	// Create a 96 byte key
	wDataLen += sizeof(DHKeyExHdr);	
	FillData(rgbDataBuffer+wDataLen, k_dwDHKeySize, k_w1522const-wSizeOfHeaders);
	// Copy the third KeyEx Header
	wDataLen +=	k_dwDHKeySize;
	memcpy(rgbDataBuffer+wDataLen, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	// Copy the third matching structure
	wDataLen += sizeof(KerbApReq);
	// Copy the whole canoly to the frame buffer
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
	CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_VALID_KEY_ORDER\n");
	}

	// SG_SEND_MULTIPLE_KEYEX
	// Even a DH key of all 0's is still valid
	ZeroMemory(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr), k_dwDHKeySize);
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_SEND_MULTIPLE_SEQ_NUM\n");
	}	

//--------------------------
// BEGIN 1ST KEY TESTS
//--------------------------

	// SG_INVALID_1ST_1
	XBtoSGInit._wType = KEYEX_TYPE_XBTOXB_INIT;	// NULL case
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_1\n");
	}
	
	// SG_INVALID_1ST_2
	XBtoSGInit._wType = KEYEX_TYPE_XBTOXB_RESP;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_2\n");
	}

	// SG_INVALID_1ST_3
	XBtoSGInit._wType = KEYEX_TYPE_SGTOXB_RESP;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_3\n");
	}

	// SG_INVALID_1ST_4
	XBtoSGInit._wType = KEYEX_TYPE_DH_GX;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_4\n");
	}

	// SG_INVALID_1ST_5
	XBtoSGInit._wType = KEYEX_TYPE_HMAC_SHA;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_5\n");
	}

	// SG_INVALID_1ST_6
	XBtoSGInit._wType = KEYEX_TYPE_KERB_APREQ;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_6\n");
	}

	// SG_INVALID_1ST_7
	XBtoSGInit._wType = KEYEX_TYPE_KERB_APREP;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_7\n");
	}

	// SG_INVALID_1ST_8
	XBtoSGInit._wType = KEYEX_TYPE_NULL_APREQ;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_8\n");
	}

	// SG_INVALID_1ST_9
	XBtoSGInit._wType = KEYEX_TYPE_NULL_APREP;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_9\n");
	}

	// SG_INVALID_1ST_10
	XBtoSGInit._wType = 10;		// Not in range
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1ST_10\n");
	}

	// SG_INVALID_1STKEY_LARGE
	XBtoSGInit._wType = KEYEX_TYPE_XBTOSG_INIT;
	XBtoSGInit._cbEnt = sizeof(CKeyExXbToSgInit)+1;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1STKEY_LARGE\n");
	}
	
	// SG_INVALID_1STKEY_SMALL
	XBtoSGInit._cbEnt = sizeof(CKeyExXbToSgInit)-1;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1STKEY_SMALL\n");
	}
	
	// SG_INVALID_1STKEY_ZERO
	XBtoSGInit._cbEnt = 0;
	memcpy(rgbDataBuffer+sizeof(dwSPI), (BYTE*)&XBtoSGInit, sizeof(XBtoSGInit));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_1STKEY_ZERO\n");
	}
	
//--------------------------
// BEGIN 2ND KEY TESTS
//--------------------------

	// SG_INVALID_2NDKEY_1
	SetKeysToValidState(&XBtoSGInit, &DHKeyExHdr, &KerbApReq);
	DHKeyExHdr._wType = KEYEX_TYPE_XBTOXB_INIT;	// NULL case
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_1\n");
	}

	// SG_INVALID_2NDKEY_2
	DHKeyExHdr._wType = KEYEX_TYPE_XBTOXB_RESP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_2\n");
	}

	// SG_INVALID_2NDKEY_3
	DHKeyExHdr._wType = KEYEX_TYPE_XBTOSG_INIT;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_3\n");
	}

	// SG_INVALID_2NDKEY_4
	DHKeyExHdr._wType = KEYEX_TYPE_SGTOXB_RESP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_4\n");
	}

	// SG_INVALID_2NDKEY_5
	DHKeyExHdr._wType = KEYEX_TYPE_HMAC_SHA;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_5\n");
	}

	// SG_INVALID_2NDKEY_6
	DHKeyExHdr._wType = KEYEX_TYPE_KERB_APREQ;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_6\n");
	}

	// SG_INVALID_2NDKEY_7
	DHKeyExHdr._wType = KEYEX_TYPE_KERB_APREP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_7\n");
	}

	// SG_INVALID_2NDKEY_8
	DHKeyExHdr._wType = KEYEX_TYPE_NULL_APREQ;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_8\n");
	}

	// SG_INVALID_2NDKEY_9
	DHKeyExHdr._wType = KEYEX_TYPE_NULL_APREP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_9\n");
	}

	// SG_INVALID_2NDKEY_10
	DHKeyExHdr._wType = 10;		// Not in range
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_10\n");
	}

	// SG_INVALID_2NDKEY_LARGE
	DHKeyExHdr._wType = KEYEX_TYPE_DH_GX;
	DHKeyExHdr._cbEnt = k_dwDHKeySize+1;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_LARGE\n");
	}
	
	// SG_INVALID_2NDKEY_SMALL
	DHKeyExHdr._cbEnt = k_dwDHKeySize-1;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));	
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_SMALL\n");
	}
	
	// SG_INVALID_2NDKEY_ZERO
	DHKeyExHdr._cbEnt = 0;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit), (BYTE*)&DHKeyExHdr, sizeof(DHKeyExHdr));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

//--------------------------
// BEGIN 3RD KEY TESTS
//--------------------------

	// SG_INVALID_3RDKEY_TYPE
	SetKeysToValidState(&XBtoSGInit, &DHKeyExHdr, &KerbApReq);
	KerbApReq._wType = KEYEX_TYPE_XBTOXB_INIT;	// NULL case
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	KerbApReq._wType = KEYEX_TYPE_XBTOXB_RESP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	KerbApReq._wType = KEYEX_TYPE_XBTOSG_INIT;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

	KerbApReq._wType = KEYEX_TYPE_SGTOXB_RESP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

	KerbApReq._wType = KEYEX_TYPE_DH_GX;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	KerbApReq._wType = KEYEX_TYPE_HMAC_SHA;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	KerbApReq._wType = KEYEX_TYPE_KERB_APREP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	KerbApReq._wType = KEYEX_TYPE_NULL_APREQ;	// Should fail in secure mode
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	KerbApReq._wType = KEYEX_TYPE_NULL_APREP;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

	KerbApReq._wType = 10;		// Not in range
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

	// SG_INVALID_3RDKEY_LARGE
	KerbApReq._wType = KEYEX_TYPE_KERB_APREQ;
	KerbApReq._cbEnt = sizeof(CKeyExKerbApReq)+1;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

	// SG_INVALID_3RDKEY_SMALL
	KerbApReq._cbEnt = sizeof(CKeyExKerbApReq)-1;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}
	
	// SG_INVALID_3RDKEY_ZERO
	KerbApReq._cbEnt = 0;
	memcpy(rgbDataBuffer+sizeof(dwSPI)+sizeof(XBtoSGInit)+sizeof(DHKeyExHdr)+k_dwDHKeySize, (BYTE*)&KerbApReq, sizeof(KerbApReq));
	memcpy(rgbFrameBuffer+wSizeOfHeaders, rgbDataBuffer, wDataLen);
	if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
	{
		printf("VLanXmit failed SG_INVALID_2NDKEY_ZERO\n");
	}

	return S_OK;
}


//-----------------------------------------------------------------------------
//
// SetKeysToValidState
//
// Sets the key exchange headers to a defualt successful configuration in the correct order.
//
void SetKeysToValidState(CKeyExHdr* pXBtoSGInit, CKeyExHdr* pDHKeyExHdr, CKeyExHdr* pKerbApReq)
{
	pXBtoSGInit->_wType = KEYEX_TYPE_XBTOSG_INIT;
	pXBtoSGInit->_cbEnt = sizeof(CKeyExXbToSgInit);
	pDHKeyExHdr->_wType = KEYEX_TYPE_DH_GX;
	pDHKeyExHdr->_cbEnt = 96;	// DH key is 96 bytes
	pKerbApReq->_wType = KEYEX_TYPE_KERB_APREQ;
	pKerbApReq->_cbEnt = sizeof(CKeyExKerbApReq);
}


//-----------------------------------------------------------------------------
//
// SGRouting
//
// Runs the test cases that check for well routed packets
//
HRESULT SGRouting(
	// [in/out] socket for communications
	SOCKET* pSocket, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress,
	// [in] Test Number
	int nTestNum
)
{
	return S_OK;
}


//-----------------------------------------------------------------------------
//
// SGTicketValidity
//
// Runs the test cases that check for valid tickets coming back from the SG and no tickets
// for invalid keys.
//
HRESULT SGTicketValidity(
	// [in/out] socket for communications
	SOCKET* pSocket, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress,
	// [in] Test Number
	int nTestNum
)
{
	return S_OK;
}


//-----------------------------------------------------------------------------
//
// SGValidity
//
// Runs the test cases that check packet validity and data integrity
//
HRESULT SGValidity(
	// [in/out] socket for communications
	SOCKET* pSocket, 
	// [in/out] Socket Address for which machine to connect to
	SOCKADDR_IN* psXSGAddress,
	// [in] Test Number
	int nTestNum
)
{
	ENET_HEADER sEnetHdr;
	IP_HEADER sIPHdr;
	UDP_HEADER sUDPHdr;
	WORD wSizeOfHeaders = sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr);
	BYTE* rgbFrameBuffer = new BYTE[k_w1522const];
	BYTE* rgbFrameBuffer2 = new BYTE[1618];
	BYTE* rgbDataBuffer = new BYTE[k_w1522const-wSizeOfHeaders];	
	WORD wDataLen = 0;
	void * pvArg = NULL;
	
	// One time call - sets the Virtual MAC address for using VLan functions
	VLanAttach("Client@Nic/0:001122334455", g_rgbSrcMAC, pvArg);

	//WriteBadFrame(rgbFrameBuffer2, "0002B34DA7040030F2715CC508004500031B77B700003D11417C9D380D79C0A856450C020C0203077CC5000000000200180000000000002D3900631E320423FDB0550000000004006400D8F446716D0234DB182CE1300BCC850D11CFB9984EE659FB331788B5E6D3CC2098B5E551FE4A48C2939D238ED6A78655E1C1D28D8535495C3B008B61504C5C2DC721E9E2A470D8DC3426954858DB6212B9E01ADA93EF4C8344E06637AF34870F06007F026E82027730820273A003020105A10302010EA20703050020000000A38201B2618201AE308201AAA003020105A10A1B0878626F782E636F6DA2163014A003020102A10D300B1B0273671B057369746531A382017D30820179A003020117A28201700482016CBECC1D3C9C35D2B37D854A0DF06AEB2917533B34C8E239BD1E7E51A3978C6879C0BE398C7E6CD441918CBD522A08C354F54589DD9CC5DED52E1DD1E62E8EC83533CF946C41D3589CB1705C0A2500D1466AE71FE30489538C9FCC3799E5B558A6EAB083A9D66429935AA62A21661D98C102F727E90D7BDE3B7A23AA129CF87F147230CA12727C68E80ACCF3451952C1CCBD4DB3902958187B6ACB610B30E0F06486F6762841D7C173FCED4D3FBD71DB0117165BC6A08D1D3B281745364EA011471C37AF0012255D33CD0E6C477A7A11D4880DCE3CF58DCFA1DC2136C5B16276FD630F2FA2A16A365F8F02C54C750C959C88D32F6A0AB91CB5A4313EEFFDF73A5F80C4C5EE143949D95D36728720B7B08A19E7D74A4C3A4C57AA87CE6E1929458E2201CA7D6BCD9EFF491B97681FFE874FBAE83E01684985105CF5DCF24B2DBAEC77B517F90CF195E7457FE3B29DA2A631A9F8CBF5F6712A2DFCE79C6B81E2F80D09DE0414A2B14E665636A946A481A73081A4A003020117A2819C048199BA64DAA2A9833C95C57F7F92AB484D30D5CDB43F9D719F96FDD91050A92E984E9A3B736A447FBCAC88BD379F15A9CCC1D7792A4780CE384BE3126F78E939E36AD942F57E6EF431B86342A1FAFC2F093F71147DE5CE4AFC8042596ADAA108F2ABF469FC36EFA79EEFCCF212BAB7F10394844B60EFA418BB3FC1EED221F5FF501AE724AE75D8BA320000CCFFB4DA3FA1B62CB21B6CA9046CAF68", 1618, 1618);
	WriteBadFrame(rgbFrameBuffer2, "0002B34DA70400112233445508004500031B77B700003D11417C9D380D79C0A856450C020C0203077CC5000000000200180000000000002D3900631E320423FDB0550000000004006400D8F446716D0234DB182CE1300BCC850D11CFB9984EE659FB331788B5E6D3CC2098B5E551FE4A48C2939D238ED6A78655E1C1D28D8535495C3B008B61504C5C2DC721E9E2A470D8DC3426954858DB6212B9E01ADA93EF4C8344E06637AF34870F06007F026E82027730820273A003020105A10302010EA20703050020000000A38201B2618201AE308201AAA003020105A10A1B0878626F782E636F6DA2163014A003020102A10D300B1B0273671B057369746531A382017D30820179A003020117A28201700482016CBECC1D3C9C35D2B37D854A0DF06AEB2917533B34C8E239BD1E7E51A3978C6879C0BE398C7E6CD441918CBD522A08C354F54589DD9CC5DED52E1DD1E62E8EC83533CF946C41D3589CB1705C0A2500D1466AE71FE30489538C9FCC3799E5B558A6EAB083A9D66429935AA62A21661D98C102F727E90D7BDE3B7A23AA129CF87F147230CA12727C68E80ACCF3451952C1CCBD4DB3902958187B6ACB610B30E0F06486F6762841D7C173FCED4D3FBD71DB0117165BC6A08D1D3B281745364EA011471C37AF0012255D33CD0E6C477A7A11D4880DCE3CF58DCFA1DC2136C5B16276FD630F2FA2A16A365F8F02C54C750C959C88D32F6A0AB91CB5A4313EEFFDF73A5F80C4C5EE143949D95D36728720B7B08A19E7D74A4C3A4C57AA87CE6E1929458E2201CA7D6BCD9EFF491B97681FFE874FBAE83E01684985105CF5DCF24B2DBAEC77B517F90CF195E7457FE3B29DA2A631A9F8CBF5F6712A2DFCE79C6B81E2F80D09DE0414A2B14E665636A946A481A73081A4A003020117A2819C048199BA64DAA2A9833C95C57F7F92AB484D30D5CDB43F9D719F96FDD91050A92E984E9A3B736A447FBCAC88BD379F15A9CCC1D7792A4780CE384BE3126F78E939E36AD942F57E6EF431B86342A1FAFC2F093F71147DE5CE4AFC8042596ADAA108F2ABF469FC36EFA79EEFCCF212BAB7F10394844B60EFA418BB3FC1EED221F5FF501AE724AE75D8BA320000CCFFB4DA3FA1B62CB21B6CA9046CAF68", 1618, 1618);
	if (!VLanXmit((BYTE *)rgbFrameBuffer2, 809))
	{
		printf("VLanXmit failed SG_MORE_THAN_ONE\n");
	}
		
	// SG_MORE_THAN_ONE
	// SG_BUFFER_OVERFLOW	
		wDataLen = 1480;	// 1472 is MAX UDP buffer size
		FillData(rgbDataBuffer, wDataLen, k_w1522const-wSizeOfHeaders);
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));	
		memcpy(rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr), rgbDataBuffer, wDataLen);
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
		{
			printf("VLanXmit failed SG_MORE_THAN_ONE\n");
		}

	// SG_BUFFER_MAX
		wDataLen = 1472;	// 1472 is MAX UDP buffer size
		FillData(rgbDataBuffer, wDataLen, k_w1522const-wSizeOfHeaders);
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));	
		memcpy(rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr), rgbDataBuffer, wDataLen);	
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
		{
			printf("VLanXmit failed SG_BUFFER_MAX\n");
		}
		
	// SG_EMPTY
		wDataLen = 0;
		FillData(rgbDataBuffer, wDataLen, k_w1522const-wSizeOfHeaders);
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);		
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
		{
			printf("VLanXmit failed on SG_EMPTY\n");
		}

	// SG_SMALL_FRAME
		wDataLen = 12;
		FillData(rgbDataBuffer, wDataLen, k_w1522const-wSizeOfHeaders);
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr)-1, &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)-1+sizeof(sIPHdr)+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);		
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen-1))
		{
			printf("VLanXmit failed on SG_SMALL_FRAME\n");
		}

	// SG_LARGE_FRAME
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr)+1, &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+1+sizeof(sIPHdr)+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);		
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen+1))
		{
			printf("VLanXmit failed on SG_LARGE_FRAME\n");
		}

	// SG_IP_HEADER_TOO_SMALL
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr)-1, &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)-1+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);		
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen-1))
		{
			printf("VLanXmit failed on SG_IP_HEADER_TOO_SMALL\n");
		}

	// SG_IP_HEADER_TOO_LARGE
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr)+1, &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+1+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen+1))
		{
			printf("VLanXmit failed on SG_IP_HEADER_TOO_LARGE\n");
		}

	// SG_IP_SIZE_GT_IP_PACKET_SIZE  *ADDME
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		sIPHdr.wLength++;
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr)+1, &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+1+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
		{
			printf("VLanXmit failed on SG_IP_SIZE_GT_IP_PACKET_SIZE\n");
		}

	// SG_IP_SIZE_GT_FRAME_SIZE
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		sIPHdr.wLength += sizeof(sEnetHdr)+1;
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr)+1, &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+1+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen+1))
		{
			printf("VLanXmit failed on SG_IP_SIZE_GT_FRAME_SIZE\n");
		}

	// SG_IGNORE_IP_HEADER_OPTIONS
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		sIPHdr.bVersion = 0x46;	// This translates into version 4, header length 24 (6 32-bit words = 6*4 bytes = 24)
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr)+1, &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+1+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen+1))
		{
			printf("VLanXmit failed on SG_IGNORE_IP_HEADER_OPTIONS\n");
		}

	// SG_IGNORE_SMALL_IP_FRAME *ADDME
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		sIPHdr.bVersion = 0x44;	// This translates into version 4, header length 16 (4 32-bit words = 4*4 bytes = 16)
		CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr)+1, &sUDPHdr, sizeof(sUDPHdr));
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+1+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen+1))
		{
			printf("VLanXmit failed on SG_IGNORE_SMALL_IP_FRAME\n");
		}		

	// SG_IGNORE_BROADCAST - sets the Ethernet destination MAC to all FF -> Broadcast
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		for(int i = 0; i < sizeof(sEnetHdr.rgbDestMAC); i++)
		{
			sEnetHdr.rgbDestMAC[i] = 0xFF;
		}
		for(WORD wFrameType = 0x0; wFrameType < 0xFF00; wFrameType++)
		{
			if(wFrameType != 0x0806)	// Only 0x0806 is ARP, everything else should be ignored
			{
				sEnetHdr.wEnetType = htons(wFrameType);
				CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
				if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
				{
					printf("VLanXmit failed on SG_IGNORE_BROADCAST - %d", wFrameType);
				}
			}
		}	

	// SG_IP_VERSION_NOT_4
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		for(BYTE bVer = 0x0; bVer < 7; bVer++)
		{
			if(bVer != 4)	// Only 0x0800 is IP, everything else should be ignored
			{
				sIPHdr.bVersion = bVer*16;		// The x16 shifts the bits 4 places to the left - see the IP frame header for details
											// Only the 4 high order bits determine the version
				CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
				if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
				{
					printf("VLanXmit failed on SG_IP_VERSION_NOT_4 - %d", bVer);
				}
			}
		}		

	// SG_BAD_FRAME
	// SG_IGNORE_UNICAST
		SetNetworkHeaders(&sEnetHdr, &sIPHdr, &sUDPHdr, wDataLen);
		memcpy((BYTE *)(&rgbFrameBuffer+sizeof(sEnetHdr)+sizeof(sIPHdr)+sizeof(sUDPHdr)), (BYTE *)&rgbDataBuffer, wDataLen);
		for(wFrameType = 0x0; wFrameType < 0xFF00; wFrameType++)
		{
			if(wFrameType != 0x0800)	// Only 0x0800 is IP, everything else should be ignored
			{
				sEnetHdr.wEnetType = htons(wFrameType);
				CopyHeaders(rgbFrameBuffer, &sEnetHdr, sizeof(sEnetHdr), &sIPHdr, sizeof(sIPHdr), &sUDPHdr, sizeof(sUDPHdr));
				if (!VLanXmit((BYTE *)rgbFrameBuffer, wSizeOfHeaders+wDataLen))
				{
					printf("VLanXmit failed on SG_BAD_FRAME - %d", wFrameType);
				}
			}
		}

	delete [] rgbFrameBuffer;
	delete [] rgbFrameBuffer2;
	delete [] rgbDataBuffer;
		
	return S_OK;
}


//-----------------------------------------------------------------------------
//
// CopyHeaders
//
//  This copies all of the headers into the prgbFrameBuffer in order with the given sizes for each
//  header.
//
void CopyHeaders(BYTE* prgbFrameBuffer, ENET_HEADER* pEnetHdr, UINT uiEnetSize, IP_HEADER* pIPHdr, UINT uiIPSize, UDP_HEADER* pUDPHdr, UINT uiUDPSize)
{
	memcpy(prgbFrameBuffer, (BYTE *)pEnetHdr, uiEnetSize);
	memcpy((prgbFrameBuffer+uiEnetSize), pIPHdr, uiIPSize);
	memcpy((prgbFrameBuffer+uiEnetSize+uiIPSize), pUDPHdr, uiUDPSize);
}

//-----------------------------------------------------------------------------
//
// SetNetworkHeaders
//
// This sets all of the Ethernet, IP, and UDP headers to a preset constant before fiddling with
// their contents before a test.
//
void SetNetworkHeaders(ENET_HEADER* pEnetHdr, IP_HEADER* pIPHdr, UDP_HEADER* pUDPHdr, WORD wDataLen)
{
	// Set Ethernet header
	memcpy(pEnetHdr->rgbDestMAC, g_rgbDestMAC, sizeof(g_rgbDestMAC));
	memcpy(pEnetHdr->rgbSrcMAC, g_rgbSrcMAC, sizeof(g_rgbSrcMAC));
	pEnetHdr->wEnetType = htons(0x0800);

	// Set IP header
	pIPHdr->bVersion = 0x45;
	pIPHdr->bTypeOfService = 0x00;
	// WARNING: Could overflow
	pIPHdr->wLength = htons(sizeof(IP_HEADER) + sizeof(UDP_HEADER) + wDataLen);
	pIPHdr->wIdentification = htons(0xBEEF);
	pIPHdr->wFlagsAndOffset = 0;
	pIPHdr->bTTL = 2;
	pIPHdr->bProtocol = 0x11;	// UDP
	pIPHdr->wChecksum = 0;
	pIPHdr->dwSrcAddress = htonl(g_dwSrcAddress);
	pIPHdr->dwDestAddress = htonl(g_dwDestAddress);
	pIPHdr->wChecksum = GetChecksum((WORD *)pIPHdr, sizeof(IP_HEADER)/2);

	// Set UDP header
	pUDPHdr->wSrcPort = htons(g_usPort);
	pUDPHdr->wDestPort = htons(g_usPort);
	pUDPHdr->wChecksum = 0;	// The SG ignores UDP checksums
	pUDPHdr->wLength = htons(sizeof(UDP_HEADER) + wDataLen);
}

//-----------------------------------------------------------------------------
//
// VLanRecv
//
// This is overridden just to get it to compile for using the VLan functions
//
void VLanRecv(unsigned char *,unsigned int,void *){}

void Usage()
//-----------------------------------------------------------------------------
//
// Usage
//
// Simply outputs the command line useage for this program.
//
{
	printf("XSGTest Help\n\n" );
	printf("XSGTest is a stand alone exe that runs a set of test cases against the the\n" );
	printf("security gateway specified in the ini file.\n" );
	printf("Usage: XSGTest ini_file\n" );
}


int __cdecl main(int argc, char * argv[])
//-----------------------------------------------------------------------------
//
// WinMain
//
// Initilizes global caches and pointers, waits until the test is done, cleans memory and quits.
//
{
	// Return code
	int iReturn = 0;
	HRESULT hr = S_OK;
	// sXSGAddress is the local address associated with a socket
	SOCKADDR_IN          sXSGAddress = { AF_INET, 0, 0, {'\0'} };
	WCHAR* pwszCmdLine = GetCommandLine();
	WCHAR wszTokens[] = L"-/";
	WCHAR* pwszToken = FindOneOf(pwszCmdLine, wszTokens);
	WCHAR wszProgramPath[MAX_PATH +1];
	WCHAR wszIniFile[MAX_PATH+1];
	WCHAR wszFile[MAX_PATH+1];
	WCHAR* pwch;

	// WSAData is the details of the Winsock implementation
	WSADATA              WSAData;
	// Integer for storing error codes
	int iLastError = 0;

	// Initialize Winsock
	iLastError = WSAStartup(MAKEWORD(2, 2), &WSAData);
	if (ERROR_SUCCESS != iLastError) 
	{
		goto Cleanup;
	}

	// Check the Winsock version
	if( LOBYTE(WSAData.wVersion) != 2 ||
        LOBYTE(WSAData.wVersion) != 2 )
	{
		hr = E_FAIL;
		goto Cleanup;
	}

	// Set up some global memory
	InitGlobalArray();

	// Open a file for logging errors
	if( (g_pOutput = fopen( "xsgtest.log", "w+" )) == NULL )
	{
		printf("Cannot open 'xsgtest.log' for output\n");
		goto Cleanup;
	}

	// Get wszFile to contain the first argument
	pwch = wcschr(pwszCmdLine, L' ');
	if(pwch != 0)
	{
		pwch++;
		wsprintf(wszFile, L"%s", pwch);
	}	
	else
	{
		Usage();
		return iReturn;
	}
	
	// Save executable path
	GetModuleFileName(NULL, wszProgramPath, MAX_PATH);
	// Strip the Spammer.exe
	pwch = wcsrchr(wszProgramPath, L'\\');
	if(pwch != 0)
	{
		pwch++;
		*pwch = L'\0';
	}

	// Put the ini file name argument on the end of the program path and store in wszIniFile
	wsprintf(wszIniFile, L"%s%s", wszProgramPath, wszFile);

	// Read INI file
	if(FAILED(ReadIni(wszIniFile)))
	{
		return iReturn;
	}

	// Initialize the VLan stuff
	if (!VLanInit())
	{
		printf("VLanInit failed\n");
		return(1);
	}
	
	// Set up network communications
	if(FAILED(InitializeNetworkUDP(&g_sUDP1, &sXSGAddress)))
	{
		return WSAGetLastError();
	}

	// TCP socket for Monitoring Server communications
	if(FAILED(InitializeNetworkTCP(&g_sTCP1, &sXSGAddress, 4002)))
	{
		return WSAGetLastError();
	}

	// Get the local machine address
//	GetLocalMachineAddress();

	RunTestCases(&sXSGAddress);

	printf("\nTotal succeeded test cases: %d\n", g_uiPassedCases);
	printf("Total failed test cases: %d\n", g_uiFailedCases);

Cleanup:

	VLanTerm();

	// Terminate Winsock
	if (0 != WSACleanup()) 
	{
		// Get the last error code
		iLastError = WSAGetLastError();
	}
	
	if( fclose( g_pOutput ) )
		printf( "The file 'data' was not closed\n" );

	return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\2kIdMaster.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "2kIdMaster.h"


extern "C"  
int _cdecl
main( int argc,
      char** argv )
{

   C2kIdMaster* cm = new C2kIdMaster;


   if (argc == 1) {
      cm->PrintHelp();
      return 1;
   }
   cm->ValidateArgs(argc, argv);
   delete cm;
   return 0;
}



VOID 
C2kIdMaster::
ValidateArgs(int argc, char **argv)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
       Parse up the command line aruguments and react accordingly. 
    Arguments:
       Typical arguments to main.
    Return Value:
      None.

--*/

{
   int i;
   char szCommand[5];
   char * p;
   BOOL bFlag = FALSE;


   for (i = 1; i < argc; i++) {
      if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
         p = argv[i];
         strcpy(szCommand, ++p);
         CharLower( szCommand );
         if (0 != strstr(szCommand,"remote")) {
            bFlag = TRUE;
         }
      }
   }
   if (bFlag == TRUE) {
      SetDoRemote ( TRUE );
   }else{
      SetDoRemote ( FALSE );
   }




   for (i = 1; i < argc; i++) {
      if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
         p = argv[i];
         strcpy(szCommand, ++p);
         CharLower( szCommand );
         if (0 == strcmp(szCommand,"1")) {
            SetLoop(m_dwLoop); 
            SetName(m_szXboxName);
            TestMemLeakage();
         } else
            if (0 == strcmp(szCommand,"2")) {
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestMACAddress();
         } else
            if (0 == strcmp(szCommand,"3")) {
            m_dwLoop = atol(argv[i + 1]);
            sprintf(m_szXboxName,"%s",argv[i + 2]);
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestXClient( NULL );
         } else
            if (0 == strcmp(szCommand,"4")) {
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestMACAddress();
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestXClient( DO_LOCALHOST );
         } else
            if (0 == strcmp(szCommand,"5")) {
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestParametersGenPerBoxData( );
         } else
            if (0 == strcmp(szCommand,"6")) {
            m_dwLoop = atol(argv[i + 1]);
            // Set the utils Class
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestRemoteDecrypt( 0 );
         } else
            if (0 == strcmp(szCommand,"7")) {
            m_dwLoop = atol(argv[i + 1]);
            sprintf(m_szXboxName,"%s",argv[i + 2]);
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            ReadRemotesEEPROM(0);
         } else
            if (0 == strcmp(szCommand,"8")) {
            sprintf(m_szXboxName,"%s",argv[i + 2]);
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestLockHardDrive(atol(argv[i + 1]));
         } else
            if (0 == strcmp(szCommand,"9")) {
            //sprintf(m_szXboxName,"%s",argv[i + 2]);
            SetLoop(m_dwLoop);
            SetName(m_szXboxName);
            TestDirectoryOfTonyChensEEPROMS(argv[i + 1], NULL);
            //TestDirectoryOfEEPROMS( argv[i + 1], NULL );
         } else
            if (0 == strcmp(szCommand,"10")) {
            SetLoop(m_dwLoop); 
            SetName(m_szXboxName);
            TestDirectoryOfTonyChensEEPROMS( argv[i + 1], argv[i + 2]);
            //TestDirectoryOfEEPROMS( argv[i + 1], argv[i + 2]);
         } else
            if (0 == strcmp(szCommand,"11")) {
            SetLoop(m_dwLoop); 
            SetName(m_szXboxName);
            TestRemoteDecodingOfOnlineKey( argv[i + 1]);
         }
         // Set the utils Class
         SetLoop(m_dwLoop); 
         SetName(m_szXboxName);
      }
   }
}



VOID
C2kIdMaster::
PrintHelp( VOID )
{

   PCCH XeName = "2kIMaster";
   
   printf("Usage: \n");
   printf("General Help and Usage\n",     XeName);
   printf("Memory Leak test   : %s /1 \n",XeName);
   printf("MAC Address test   : %s /2 \n",XeName);
   printf("Full x test        : %s /3 1<loop> wallyhox<xboxname> \n",XeName);
   printf("Parameter Test     : %s /5\n",       XeName);
   printf("Test Rmt Decrypt   : %s /6 <loop>\n",XeName);
   printf("Rmt EEPROM Read    : %s /7 <loop> wallyhox<xboxname> \n",XeName);
   printf("HardDrive Un/Lock  : %s /8 <0|1> wallyhox<xboxname> \n", XeName);
   printf("Crack a dir of EEPROMS data : %s /9  <directory> \n",XeName);
   printf("Load and cmp EEPROMS online key : %s /10  <directory> <OnlineKey Database File>\n",XeName);
   printf("  eg:%s /10 c:\\ eeproms c:\\eeproms\\sst...tbs \n",             XeName);
   printf("Decode a Key       : %s /11 <OnlineKey>\n",XeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include <windows.h>
#include <assert.h>
#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\server\xtpparse\xtpparse.cpp ===
//============================================================================
//  FILE: xtpparse.c
//
//  Description: Xbox Authenticated Tunneling Protocol (XTP) Parser
//============================================================================

#include "stdafx.h"

//==================================================================================
// Defines
//==================================================================================
// Values for IP protocols recognized by Netmon
#define PROTO_ICMP_VALUE	1
#define PROTO_IGMP_VALUE	2
#define PROTO_IP_VALUE		4
#define PROTO_TCP_VALUE		6
#define PROTO_UDP_VALUE		17
#define PROTO_IP6_VALUE		41
#define PROTO_RSVP_VALUE	46
#define PROTO_GRE_VALUE		47
#define PROTO_ESP_VALUE		50
#define PROTO_AH_VALUE		51
#define PROTO_OSPF_VALUE	89

#define PROTO_NAME_MAX		8

// Friendly strings for IP protocols recognized by Netmon
#define PROTO_ICMP_NAME		"ICMP"
#define PROTO_IGMP_NAME		"IGMP"
#define PROTO_IP_NAME		"IP"
#define PROTO_TCP_NAME		"TCP"
#define PROTO_UDP_NAME		"UDP"
#define PROTO_IP6_NAME		"IPv6"
#define PROTO_RSVP_NAME		"RSVP"
#define PROTO_GRE_NAME		"GRE"
#define PROTO_ESP_NAME		"ESP"
#define PROTO_AH_NAME		"AH"
#define PROTO_OSPF_NAME		"OSPF"
#define PROTO_UNKNOWN_NAME	"Unknown"

//==================================================================================
// Globals
//==================================================================================
HPROTOCOL hXTP = NULL;
DWORD     Attached = 0;

// structure for decoding the header -----------------------------------------
typedef struct _XTPHEADER 
{
    DWORD		AuthData[3];
	DWORD		SourceAddr;
	DWORD		DestAddr;
	union
	{
		struct _GENFIELD {
			DWORD		Reserved1	: 4;
			DWORD		IHL			: 4;
			DWORD		Protocol	: 8;
			DWORD		Reserved2	: 16;
		} GenField;

		struct _UDPFIELD {
			WORD		SourcePort;
			WORD		DestPort;
		} UdpField;
	} VariableField;
	DWORD		SequenceNum	: 31;
	DWORD		UdpFlag		: 1;

} XTPHEADER, *PXTPHEADER;

//==================================================================================
// Functions
//==================================================================================
extern PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo();
extern VOID   WINAPI XTP_Register( HPROTOCOL hXTP);
extern VOID   WINAPI XTP_Deregister( HPROTOCOL hXTP);
extern LPBYTE WINAPI XTP_RecognizeFrame( HFRAME hFrame, 
                                              LPBYTE pMacFrame, 
                                              LPBYTE pXTPFrame, 
                                              DWORD MacType, 
                                              DWORD BytesLeft, 
                                              HPROTOCOL hPrevProtocol, 
                                              DWORD nPrevProtOffset,
                                              LPDWORD pProtocolStatus,
                                              LPHPROTOCOL phNextProtocol, 
                                              LPDWORD InstData);
extern LPBYTE WINAPI XTP_AttachProperties( HFRAME hFrame, 
                                                LPBYTE pMacFrame, 
                                                LPBYTE pXTPFrame, 
                                                DWORD MacType, 
                                                DWORD BytesLeft, 
                                                HPROTOCOL hPrevProtocol, 
                                                DWORD nPrevProtOffset,
                                                DWORD InstData);
extern DWORD  WINAPI XTP_FormatProperties( HFRAME hFrame, 
                                                LPBYTE pMacFrame, 
                                                LPBYTE pXTPFrame, 
                                                DWORD nPropertyInsts, 
                                                LPPROPERTYINST p);

VOID WINAPIV XTP_FormatSummary( LPPROPERTYINST pPropertyInst);

// Define the entry points that we will pass back at dll entry time ----------
ENTRYPOINTS XTPEntryPoints =
{
    // XTP Entry Points
    XTP_Register,
    XTP_Deregister,
    XTP_RecognizeFrame,
    XTP_AttachProperties,
    XTP_FormatProperties
};


//==================================================================================
// Property labels
//==================================================================================
LABELED_BIT XTPUDPFlag[] =
{
    // bit 7 = Is this the UDP special case
    {   7,
	    "UDP special case",
	    "Generic IP case",
    }
};
SET XTPUdpFlagSET = {sizeof(XTPUDPFlag)/sizeof(LABELED_BIT), XTPUDPFlag};



//==================================================================================
// Properties
//==================================================================================
typedef enum
{
    XTP_SUMMARY = 0,
    XTP_AUTHDATA,
	XTP_ORIGSOURCEADDR,
	XTP_ORIGDESTADDR,
	XTP_ORIGSOURCEPORT,
	XTP_ORIGDESTPORT,
	XTP_RESERVED1,
	XTP_ORIGIHL,
	XTP_ORIGPROTO,
	XTP_RESERVED2,
	XTP_SEQNUM,
	XTP_UDPFLAG,
};

PROPERTYINFO  XTPPropertyTable[] = 
{
    // XTP_SUMMARY
    { 0, 0,
      "Summary",
      "Summary of the XTP Packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,
      XTP_FormatSummary
    },

    // XTP_AUTHDATA
    { 0, 0,
      "Auth data",
      "Authentication data",
      PROP_TYPE_RAW_DATA,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGSOURCEADDR
    { 0, 0,
      "Source IP",
      "Source address of original IP packet",
      PROP_TYPE_IP_ADDRESS,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGDESTADDR
    { 0, 0,
      "Destination IP",
      "Destination address of original IP packet",
      PROP_TYPE_IP_ADDRESS,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGSOURCEPORT
    { 0, 0,
      "Source port",
      "Source port of original UDP packet",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGDESTPORT
    { 0, 0,
      "Destination port",
      "Destination port of original UDP packet",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_RESERVED1
    { 0, 0,
      "Reserved",
      "Reserved for future use",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGIHL
    { 0, 0,
      "IHL",
      "Internet header length of original IP packet",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_ORIGPROTO
    { 0, 0,
      "Protocol",
      "Protcol type of original IP packet",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance	// BUGBUG - Probably want a new format for this to show the protocol name
    },

    // XTP_RESERVED2
    { 0, 0,
      "Reserved",
      "Reserved for future use",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_SEQNUM
    { 0, 0,
      "Sequence number",
      "Authentication sequence number",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // XTP_UDPFLAG
    { 0, 0,
      "UDP flag",
      "Flag that specifies if this is a UDP packet special case",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &XTPUdpFlagSET,
      80,
      FormatPropertyInstance
    }

};

DWORD nNumXTPProps = (sizeof(XTPPropertyTable)/sizeof(PROPERTYINFO));

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: (Called by the OS) Tell the kernel about our entry points.
//
// Returns: Always returns TRUE
//==================================================================================
BOOL WINAPI DllMain( HANDLE hInstance, ULONG Command, LPVOID Reserved)
{

    // what type of call is this
    switch( Command )
    {
        case DLL_PROCESS_ATTACH:
            // are we loading for the first time?
            if( Attached == 0 )
            {
                // the first time in we need to tell the kernel 
                // about ourselves
                hXTP = CreateProtocol( "XTP", 
                                            &XTPEntryPoints, 
                                            ENTRYPOINTS_SIZE);
            }
            Attached++;
            break;

        case DLL_PROCESS_DETACH:
            // are we detaching our last instance?
            Attached--;
            if( Attached == 0 )
            {
                // last guy out needs to clean up
                DestroyProtocol( hXTP);
            }
            break;
    }

    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Function called by Netmon to automatically install the parser
//
// Arguments: none
//
// Returns: On success, returns a pointer to a PF_PARSERDLLINFO structure containing
//	information on the parsers in this DLL.  Otherwise, returns NULL
//==================================================================================
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD dwNumProtocols;

    PPF_HANDOFFSET    pIncomingHandoff;
    PPF_HANDOFFENTRY  pHandoffEntry;
    DWORD dwIncomingHandoffs;
    // BUGBUG - later, the hand-off set for this protocol will need to be fleshed out
    /*
    PPF_HANDOFFSET    pOutgoingHandoff;
    DWORD dwNumOutgoingHandoffs;
    */

    // Base structure ========================================================

    // Allocate memory for parser info:
    dwNumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc( GetProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof( PF_PARSERDLLINFO ) +
                                                   dwNumProtocols * sizeof( PF_PARSERINFO) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }       
    
    // Fill in the parser DLL info
    pParserDllInfo->nParsers = dwNumProtocols;

    // Fill in the individual parser infos...

    // Enter XTP information
    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    sprintf( pParserInfo->szProtocolName, "XTP" );
    sprintf( pParserInfo->szComment,      "Xbox Authenticated Tunneling Protocol" );
    sprintf( pParserInfo->szHelpFile,     "");

    // the incoming handoff set ----------------------------------------------
    // allocate
    dwIncomingHandoffs = 1;
    pIncomingHandoff = (PPF_HANDOFFSET)HeapAlloc( GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             sizeof( PF_HANDOFFSET ) +
                                             dwIncomingHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pIncomingHandoff == NULL )
    {
        return pParserDllInfo;
    }

    // Fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pIncomingHandoff;
    pIncomingHandoff->nEntries = dwIncomingHandoffs;

    // UDP PORT 500
    pHandoffEntry = &(pIncomingHandoff->Entry[0]);
    sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    sprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
    sprintf( pHandoffEntry->szProtocol,   "XTP" );
	// BUGBUG - Use 500 for now, but this conflicts with ISAKMP
    pHandoffEntry->dwHandOffValue =        500;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    

    // BUGBUG - Later, the outgoing hand-off set for this protocol will need to be
	// updated to include most major protocols (is there a way to piggy back off of TCP/IP?)

    return pParserDllInfo;
}

//==================================================================================
// XTP_Register
//----------------------------------------------------------------------------------
//
// Description: Creates the property database for XTP
//
// Arguments:
//	HPROTOCOL		hXTP			Handle to the XTP protocol
//
// Returns: void
//==================================================================================
void WINAPI XTP_Register( HPROTOCOL hXTP)
{
    WORD  i;

    // Tell Netmon to make reserve some space for our property table
    CreatePropertyDatabase( hXTP, nNumXTPProps);

    // Add our properties to the Netmon's database
    for( i = 0; i < nNumXTPProps; i++)
    {
        AddProperty( hXTP, &XTPPropertyTable[i]);
    }
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Removes the property database for XTP
//
// Arguments:
//	HPROTOCOL		hXTP			Handle to the XTP protocol
//
// Returns: void
//==================================================================================
VOID WINAPI XTP_Deregister(HPROTOCOL hXTP)
{
    // Tell the Netmon that it may now free our database
    DestroyPropertyDatabase( hXTP);
}

//==================================================================================
// XTP_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XTP
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that contains the data.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame. The pointer 
//									provides a way to view data that other parsers recognize.
//	LPBYTE			pXTPFrame		Pointer to the start of the unclaimed data. Typically,
//									the unclaimed data is located in the middle of a frame
//									because a previous parser has claimed data before this
//									parser. The parser must test the unclaimed data first. 
//	DWORD			MacType			MAC value of the first protocol in a frame. Typically,
//									the MacType value is used when the parser must identify
//									the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes from a location in a frame
//									to the end of the frame. 
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol. 
//	DWORD			nPrevProtOffset	Offset of the previous protocol - beginning of the frame.
//	LPDWORD			pProtocolStatus	Protocol status indicator.
//	LPHPROTOCOL		phNextProtocol	Pointer to the handle of the next protocol. This
//									parameter is set when a protocol identifies the protocol
//									that follows a protocol. To obtain the handle of the next
//									protocol, call the GetProtocolFromTable function. 
//	LPDWORD			InstData		On input, a pointer to the instance data from the
//									previous protocol. On output, a pointer to the instance
//									data for the current protocol. 
//
// Returns: When XTP protocol is recognized, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When XTP protocol isn't recognized, returns the original pXTPFrame value to submit
//			the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XTP_RecognizeFrame(HFRAME      hFrame,         
								LPBYTE      pMacFrame,      
								LPBYTE      pXTPFrame, 
								DWORD       MacType,        
								DWORD       BytesLeft,      
								HPROTOCOL   hPrevProtocol,  
								DWORD       nPrevProtOffset,
								LPDWORD     pProtocolStatus,
								LPHPROTOCOL phNextProtocol,
								LPDWORD     InstData)       
{
	PXTPHEADER pXTPHeader = (PXTPHEADER) pXTPFrame;
	DWORD dwOptionsLen = 0;

	// If this is the general case, determine the size of the encapsulated IP header
	if(!(pXTPHeader->UdpFlag))
	{
		// If the IP header is too small, discard the packet without recognizing it
		if(pXTPHeader->VariableField.GenField.IHL < 5)
		{
			*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
			return pXTPFrame;
		}

		// The options len is the total header len minus the standard header len (5*4=20)
		dwOptionsLen = (pXTPHeader->VariableField.GenField.IHL - 5) * 4;
	}

	// If this frame isn't large enough to be an XTP frame, indicate that its not recognized
	if(BytesLeft < (sizeof(XTPHEADER) + dwOptionsLen))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return pXTPFrame;
	}

	// BUGBUG - in the future, verify that the passed in frame is actually an XTP frame
	// For now, just assume that since we're being called, it must be
    *pProtocolStatus = PROTOCOL_STATUS_CLAIMED;

	// BUGBUG - in the future, find out what the next protocol is.  Then, set the phNextProtocol
	// and the return point accordingly to indicate if we are followed by a parsable protocol
	pXTPFrame += (sizeof(XTPHEADER) + dwOptionsLen);
    return pXTPFrame;
}

//==================================================================================
// XTP_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XTP
//
// Arguments:
//	HFRAME			hFrame			Handle of the frame that is being parsed. 
//	LPBYTE			lpFrame			Pointer to the first byte in a frame.
//	LPBYTE			pXTPFrame		Pointer to the start of the recognized data.
//	DWORD			MacType			MAC value of the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes in a frame, starting
//									at the beginning of the recognized data.
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol.
//	DWORD			nPrevProtOffset	Offset of the previous protocol, starting at the
//									beginning of the frame.
//	DWORD			InstData		Pointer to the instance data from the previous protocol.
//
// Returns: When the function is successful, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When the function isn't successful, returns the original pXTPFrame value to
//			submit the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XTP_AttachProperties(	HFRAME      hFrame,         
									LPBYTE      pMacFrame,     
									LPBYTE      pXTPFrame,   
									DWORD       MacType,        
									DWORD       BytesLeft,      
									HPROTOCOL   hPrevProtocol,  
									DWORD       nPrevProtOffset,
									DWORD       InstData)       

{
    // Apply the header overlay in order to decode the protocol
    PXTPHEADER	pXTPHeader = (PXTPHEADER) pXTPFrame;
	DWORD		dwOptionsLen = 0, dwSequenceNum = 0;
	BYTE		bUdpFlag = 0;

	// If this is the general case, determine the size of the encapsulated IP header
	if(!(pXTPHeader->UdpFlag))
	{
		// If the IP header is too small, discard the frame
		if(pXTPHeader->VariableField.GenField.IHL < 5)
		{
			goto Exit;
		}

		// The options len is the total header len minus the standard header len (5*4=20)
		dwOptionsLen = (pXTPHeader->VariableField.GenField.IHL - 5) * 4;
	}

	// If this frame isn't large enough to be an XTP frame, discard it
	if(BytesLeft < (sizeof(XTPHEADER) + dwOptionsLen))
	{
		goto Exit;
	}

    //
    // Attach Properties...
    //

    // XTP summary
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_SUMMARY].hProperty, (WORD)BytesLeft,
		(LPBYTE)pXTPFrame, 0, 0, 0))
	{
		goto Exit;
	}

    // Authentication data
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_AUTHDATA].hProperty, sizeof(pXTPHeader->AuthData),
		(LPBYTE) pXTPHeader->AuthData, 0, 1, 0))
	{
		goto Exit;
	}

    // Original source IP address
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGSOURCEADDR].hProperty, sizeof(pXTPHeader->SourceAddr),
		(LPBYTE) &(pXTPHeader->SourceAddr), 0, 1, 0))
	{
		goto Exit;
	}

    // Original destination IP address
    if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGDESTADDR].hProperty, sizeof(pXTPHeader->DestAddr),
		(LPBYTE) &(pXTPHeader->DestAddr), 0, 1, 0))
	{
		goto Exit;
	}

	// For the UDP special case, interpret the next DWORD as a source and destination port
	if(pXTPHeader->UdpFlag)
	{
		// Original source UDP port
		if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGSOURCEPORT].hProperty,
			sizeof(pXTPHeader->VariableField.UdpField.SourcePort),
			(LPBYTE) &(pXTPHeader->VariableField.UdpField.SourcePort), 0, 1, 0))
		{
			goto Exit;
		}
		
		// Original destination UDP port
		if(!AttachPropertyInstance(hFrame, XTPPropertyTable[XTP_ORIGDESTPORT].hProperty,
			sizeof(pXTPHeader->VariableField.UdpField.DestPort),
			(LPBYTE) &(pXTPHeader->VariableField.UdpField.DestPort), 0, 1, 0))
		{
			goto Exit;
		}
	}
	// For the generic case, interpret the next DWORD as the IHL and protocol of the encapsulated IP packet
	else
	{
		BYTE bReserved1 = 0, bIHL = 0, bProtocol = 0;
		WORD wReserved2 = 0;

		// Many of the fields in the general case header will wind up overlapping since they are
		// less than the size of a byte and Netmon only allows properties of a byte or larger
		// AttachPropertyInstanceEx is used to accurately display the values of overlapped fields

		// Go ahead and retrieve the correct values before mucking with the frame
		bReserved1 = (BYTE) pXTPHeader->VariableField.GenField.Reserved1;
		bIHL = (BYTE) pXTPHeader->VariableField.GenField.IHL;
		bProtocol = (BYTE) pXTPHeader->VariableField.GenField.Protocol;
		wReserved2 = (WORD) pXTPHeader->VariableField.GenField.Reserved2;

		// Reserved half-byte
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_RESERVED1].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD), sizeof(BYTE), &bReserved1, 0, 1, 0))
		{
			goto Exit;
		}

		// Original IHL
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_ORIGIHL].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD), sizeof(BYTE), &bIHL, 0, 1, 0))
		{
			goto Exit;
		}

		// Original protocol
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_ORIGPROTO].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD) + 1 * sizeof(BYTE), sizeof(BYTE), &bProtocol, 0, 1, 0))
		{
			goto Exit;
		}

		// Reserved word
		if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_RESERVED2].hProperty,
			sizeof(BYTE), pXTPFrame + 5 * sizeof(DWORD) + 2 * sizeof(BYTE), sizeof(WORD), &wReserved2, 0, 1, 0))
		{
			goto Exit;
		}
	}

	// Finally, handle the sequence number and the UDP/general-case flag
	dwSequenceNum = (DWORD) pXTPHeader->SequenceNum;
	bUdpFlag = (BYTE) pXTPHeader->UdpFlag;

	// Authentication sequence number
	if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_SEQNUM].hProperty,
		sizeof(DWORD), pXTPFrame + 6 * sizeof(DWORD), sizeof(DWORD), &dwSequenceNum, 0, 1, 0))
	{
		goto Exit;
	}

	// UDP or general case flag
	if(!AttachPropertyInstanceEx(hFrame, XTPPropertyTable[XTP_UDPFLAG].hProperty,
		sizeof(BYTE), pXTPFrame + 6 * sizeof(DWORD) + 3 * sizeof(BYTE), sizeof(BYTE), &bUdpFlag, 0, 1, 0))
	{
		goto Exit;
	}

	// BUGBUG - For now, just pass on the data beyond the XTP header
	pXTPFrame += (sizeof(XTPHEADER) + dwOptionsLen);

Exit:

	return pXTPFrame;
}

//==================================================================================
// XTP_GetProtocolName
//----------------------------------------------------------------------------------
//
// Description: Helper function for protocol parsing.  Returns friendly string for an
//	IP protocol
//
// Arguments:
//	BYTE				bProtocol			Byte containing protocol value from packet
//	LPSTR				szProtocolName		String that is filled with the friendly name
//											of the protocol
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
BOOL WINAPI XTP_GetProtocolName(BYTE bProtocol, LPSTR szProtocolName)
{
	// Make sure we have a valid protocol string holder
	if(!szProtocolName || IsBadWritePtr(szProtocolName, PROTO_NAME_MAX))
		return FALSE;

	// Not sure what alot of these protocols are, but Netmon has them listed
	// in TCPIP.INI so since we can hand them off, we should probably print
	// a friendly name for each of them
	switch(bProtocol)
	{
	case PROTO_ICMP_VALUE:
		strcpy(szProtocolName, PROTO_ICMP_NAME);
		break;
	case PROTO_IGMP_VALUE:
		strcpy(szProtocolName, PROTO_IGMP_NAME);
		break;
	case PROTO_IP_VALUE:
		strcpy(szProtocolName, PROTO_IP_NAME);
		break;
	case PROTO_TCP_VALUE:
		strcpy(szProtocolName, PROTO_TCP_NAME);
		break;
	case PROTO_UDP_VALUE:
		strcpy(szProtocolName, PROTO_UDP_NAME);
		break;
	case PROTO_IP6_VALUE:
		strcpy(szProtocolName, PROTO_IP6_NAME);
		break;
	case PROTO_RSVP_VALUE:
		strcpy(szProtocolName, PROTO_RSVP_NAME);
		break;
	case PROTO_GRE_VALUE:
		strcpy(szProtocolName, PROTO_GRE_NAME);
		break;
	case PROTO_ESP_VALUE:
		strcpy(szProtocolName, PROTO_ESP_NAME);
		break;
	case PROTO_AH_VALUE:
		strcpy(szProtocolName, PROTO_AH_NAME);
		break;
	case PROTO_OSPF_VALUE:
		strcpy(szProtocolName, PROTO_OSPF_NAME);
		break;
	default:
		strcpy(szProtocolName, PROTO_ICMP_NAME);
		break;
	}

	return TRUE;
}

//==================================================================================
// XTP_FormatProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to format each property that was attached by
//	XTP_AttachProperties
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that is being parsed.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame.
//	LPBYTE			pXTPFrame		Pointer to the beginning of the protocol data in a frame.
//	DWORD			nPropertyInsts	Number of PROPERTYINST structures provided by lpPropInst. 
//	LPPROPERTYINST	p				Pointer to an array of PROPERTYINST structures. 
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
DWORD WINAPI XTP_FormatProperties(	HFRAME          hFrame,
									LPBYTE          pMacFrame,
									LPBYTE          pXTPFrame,
									DWORD           nPropertyInsts,
									LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }

    return NMERR_SUCCESS;
}

//============================================================================
//  Function: XTP_FormatSummary
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  Your Name Here      01/01/70    Created
//============================================================================
VOID WINAPIV XTP_FormatSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR		pReturnedString = pPropertyInst->szPropertyText;
    PXTPHEADER	pXTPHeader = (PXTPHEADER)(pPropertyInst->lpData);
	IN_ADDR		SourceAddr, DestAddr;

	SourceAddr.S_un.S_addr = pXTPHeader->SourceAddr;
	DestAddr.S_un.S_addr = pXTPHeader->DestAddr;

	if(pXTPHeader->UdpFlag)
	{
	    // Print "UDP-case, Source: <SourceIP>:<DestPort>, Dest: <DestIP>:<DestPort>"
		 sprintf( pReturnedString, "UDP-case, Source %s:%u, Dest: %s:%u",
			 inet_ntoa(SourceAddr), pXTPHeader->VariableField.UdpField.SourcePort,
			 inet_ntoa(DestAddr), pXTPHeader->VariableField.UdpField.DestPort);
	}
	else
	{
		CHAR	szProtocolName[PROTO_NAME_MAX];

		XTP_GetProtocolName((BYTE) pXTPHeader->VariableField.GenField.Protocol, szProtocolName);

		// Print "General-case, Source: <SourceIP>, Dest: <DestIP>, Protocol: %s"
		sprintf(pReturnedString, "General-case, Source %s, Dest: %s, Protocol: %s",
			inet_ntoa(SourceAddr), inet_ntoa(DestAddr), szProtocolName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\2kId_Tests.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _2KIDTESTS_H_
#define _2KIDTESTS_H_

#include <windows.h>
#include "2kId_Utils.h"
#include "CCrypto.h"
#include <xbox.h>
#include <xboxp.h>
#include <assert.h>
#include <PerBoxData.h>


class C2kIdTests: CCrypto, C2kIdUtils {

public:

   BOOL TestMemLeakage( VOID );
   BOOL TestMACAddress( VOID );
   BOOL TestXClient ( IN DWORD dwFlag );
   BOOL TestParametersGenPerBoxData( VOID );
   BOOL TestRemoteDecrypt( IN DWORD dwFlag );
   BOOL ReadRemotesEEPROM( IN DWORD dwFlag );
   BOOL TestLockHardDrive( IN DWORD dwControl );
   BOOL TestVerifyCheckSum( IN DWORD dwFlag );
   BOOL TestDirectoryOfEEPROMS( IN PCHAR szDirectory, 
                                IN PCHAR szDataBaseFile );
   
   BOOL TestDirectoryOfTonyChensEEPROMS( IN PCHAR szDirectory,
                                         IN PCHAR szDataBaseFile); 
   BOOL TestRemoteDecodingOfOnlineKey( IN PCHAR OnlineKeyEncryptedBase64Encoded );
   VOID SetLoop(IN DWORD dw ){ m_dwTestLoop = dw;}
   VOID SetName(IN PCHAR s ) { strcpy(m_szXboxName,s);}
   VOID SetDoRemote(IN BOOL b );
   
   C2kIdTests(){m_dwTestLoop = 0; m_szXboxName[0]='\0';}
   
   C2kIdTests(IN DWORD dw ){ m_dwTestLoop = dw; m_bDoRemote = FALSE;}
   ~C2kIdTests(){}

private:
   DWORD m_dwTestLoop;
   CHAR  m_szXboxName[MAX_PATH];
   BOOL  m_bDoRemote;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\2kId_Utils.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "2kId_Utils.h"
#include "..\\include\\fileformat.h"
#include "..\\include\\DataPacket.h"
#include <PerBoxData.h>
#include <stdlib.h>
#include <stdio.h>


VOID
C2kIdUtils::
WriteFileFromMemory(
                   LPCSTR lpFileName,
                   LPVOID pvFileContents,
                   DWORD dwFileSize
                   )
{

   HANDLE hFile;
   DWORD dwBytesWrote;

   hFile = CreateFile(lpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, "Error: unable to open %s\n", lpFileName);
      return;
   }

   if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) ||
       (dwBytesWrote != dwFileSize)) {
      fprintf(stderr, "Error: cannot write to %s\n", lpFileName);
      return;
   }
   CloseHandle(hFile);
}


VOID
C2kIdUtils::
FileToDrive( LPCSTR lpFileName,
             LPVOID pvFileContents,
             DWORD dwFileSize,
             DWORD dwWriteFlags )
{

   HANDLE hFile;
   DWORD dwBytesWrote;
   DWORD dwPos;
   DWORD dwFileStyle;
   CHAR  szOperation[30];
   DWORD dwFilePosition;

   switch (dwWriteFlags) {
      case APPEND_FILE:
         dwFileStyle = OPEN_ALWAYS;
         sprintf(szOperation,"%s","Appending File");
         dwFilePosition = FILE_END;
         break;
      case NEW_FILE:
         dwFileStyle = CREATE_ALWAYS;
         sprintf(szOperation,"%s","New File");
         dwFilePosition = FILE_BEGIN;
         break;
      default:
         dwFileStyle = 0;
         dwFilePosition = FILE_BEGIN;
         break; 
      }
   hFile = CreateFile(lpFileName, 
                      GENERIC_WRITE, 
                      FILE_SHARE_READ, 
                      NULL,
                      dwFileStyle, 
                      FILE_ATTRIBUTE_NORMAL, 
                      NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      printf("%s:unable to open %s, error %X\n", szOperation,lpFileName, GetLastError());
      return;
   }

   dwPos = SetFilePointer( hFile, 0, NULL, dwFilePosition );
   if ( dwPos == INVALID_SET_FILE_POINTER ) {
      printf("%s: unable to seek %s, error %X\n", szOperation, lpFileName, GetLastError());
      return;        
   }

   if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) || (dwBytesWrote != dwFileSize)) {
      printf("%s: cannot write to %s, error %X\n", szOperation, lpFileName, GetLastError() );
      return;
   }
   CloseHandle(hFile);
}



BOOL
C2kIdUtils::
ByteCmp(IN LPBYTE First, 
        IN LPBYTE Second, 
        IN DWORD  dwSize)
{

   BOOL b = TRUE;
   for (DWORD i =0; i < dwSize; i++) {
      if (First[i] != Second[i]) {
         b = FALSE;
      }
   }
   return b;
}

BOOL
C2kIdUtils::
DumpBytesHex(IN LPBYTE lpbID,
             IN UINT   uiSize)
{
   
   for ( UINT i = 0; i < uiSize; i++ ) {
      printf("%02X", lpbID[i]);
   }
   printf("\n");
   return TRUE;
}

BOOL
C2kIdUtils::
DumpBytesChar(IN LPBYTE lpbID,
              IN UINT   uiSize)
{
   
   for ( UINT i = 0; i < uiSize; i++ ) {
      printf("%C", lpbID[i]);
   }
   printf("\n");
   return TRUE;
}



VOID
C2kIdUtils::
ResetVariables( IN LPGENPERBOXDATA_INFO x)
{

   INT i;

   x->hr = 0;
   RtlZeroMemory(x->byteData, sizeof(x->byteData));
   x->GameRegion = XC_GAME_REGION_NA;
   x->AVRegion   = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
   RtlZeroMemory(x->MACAddress, sizeof(x->MACAddress));
   for (i =0; i < 6; i++) x->MACAddress[i] = 0x66;
     
   RtlZeroMemory(x->MACAddressSmall, sizeof(x->MACAddressSmall));
   for (i =0; i < 2; i++) x->MACAddressSmall[i] = 0x66;

   RtlZeroMemory(x->XboxSerialNumber, sizeof(x->XboxSerialNumber));
   for (i =0; i < 12; i++) x->XboxSerialNumber[i] = (CHAR)(65 + i);
   RtlZeroMemory(x->RecoveryKey, sizeof(x->RecoveryKey));
   x->dwOnlineKeyVersion = 0;

   RtlZeroMemory(x->OnlineKeyEncryptedBase64Encoded, sizeof(x->OnlineKeyEncryptedBase64Encoded));
   RtlZeroMemory(x->HardDriveKeyBase64Encoded, sizeof(x->HardDriveKeyBase64Encoded));

   RtlZeroMemory(x->OnlineKeyDataBaseInfo, sizeof(x->OnlineKeyDataBaseInfo));
   x->dwOutBufferSize = PACKET_DATA_SIZE;

   RtlZeroMemory(x->OnlineKeyEncrypted, sizeof(x->OnlineKeyEncrypted));
   RtlZeroMemory(x->OnlineKey, sizeof(x->OnlineKey));
   x->ulOnlineKey = 0;
}

PCHAR
C2kIdUtils::
AvRegionBitTest( IN DWORD dwBitMask)
{

   static CHAR sz[ 260 ] = "";

   ZeroMemory(sz, 260);
   if (AV_STANDARD_NTSC_M == (dwBitMask & AV_STANDARD_NTSC_M) ) 
      strcat(sz,"NTSC ");
   if (AV_STANDARD_NTSC_J == (dwBitMask & AV_STANDARD_NTSC_J) ) 
      strcat(sz,"Japanese NTSC ");
   if (AV_STANDARD_PAL_I == (dwBitMask & AV_STANDARD_PAL_I) ) 
      strcat(sz,"PAL I ");
   if (AV_STANDARD_PAL_M == (dwBitMask & AV_STANDARD_PAL_M)  ) 
      strcat(sz,"PAL M ");
   
   if ( dwBitMask & AV_FLAGS_60Hz  ) 
      strcat(sz,"60Hz ");
   if ( dwBitMask & AV_FLAGS_50Hz  ) 
      strcat(sz,"50Hz ");

   return sz;
}


HRESULT
C2kIdUtils::
GenerateID ( LPBYTE lpbData, DWORD dwSize )
{

   // from xboxp.h
   //#define XC_GAME_REGION_NA           1
   //#define XC_GAME_REGION_JAPAN        2
   //#define XC_GAME_REGION_RESTOFWORLD  4
   
   DWORD GameRegion = XC_GAME_REGION_NA;
   DWORD AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
   BYTE MACAddress[ETHERNET_MAC_ADDR_LEN] = { 0x66,0x66,0x66,0x66,0x66,0x66};
   char XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN ] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'};
   char HardDriveKey[HARD_DRIVE_KEY_LEN];
   char RecoveryKey[RECOVERY_KEY_LEN];
   DWORD dwOnlineKeyVersion = 0;
   char OnlineKey[173];

   DWORD dwOutBufferSize;
   dwOutBufferSize = dwSize;
   return  GeneratePerBoxData ( GameRegion,
                                AVRegion,
                                MACAddress,
                                XboxSerialNumber,
                                HardDriveKey,
                                RecoveryKey,
                                &dwOnlineKeyVersion,
                                OnlineKey,
                                lpbData,
                                &dwOutBufferSize );

}


HRESULT
C2kIdUtils::
ReadFileIntoBuffer (IN char* szFileName, 
                    IN BYTE* bFile,
                    IN DWORD dwSizeOfBuffer)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/27/2001

    Routine Description:
        This routine will read the contents of a file into bFile
    Arguments:
        The name of the file to read and a buffer to put it in.
        Size of buffer to writeinto.
    Return Value:
      True for success; False for failure.
--*/
{

   HANDLE h;

   DWORD dwNumberOfBytesToRead = dwSizeOfBuffer;
   DWORD dwNumberOfBytesRead;
   h = CreateFile ( szFileName, 
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,// | FILE_FLAG_NO_BUFFERING,
                    NULL);

   if ( h == INVALID_HANDLE_VALUE ) {
      printf("CreatFile Failed\n" );
      return FALSE;
   }
   
   ReadFile( h, 
             bFile,
             dwNumberOfBytesToRead,
             &dwNumberOfBytesRead, 
             NULL );
   CloseHandle(h);

   return TRUE;
}



BOOL
C2kIdUtils::
ScanInformation( IN PCHAR szDirectory, 
                 IN PCHAR inSerialNumber,
                 IN PCHAR inOnlineKey )
{
   
   CHAR szLine[300];
   CHAR szLineTest[50];
   CHAR szOnlineKeyGuess[5][200];
   CHAR szOnlineKey[200];
   
   
   CHAR szSerialNumber[40];
   CHAR szSerialNumberGuess[5][40];
   
   CHAR szDontCare[40][30];

   FILE *read;
   BOOL bReturn = FALSE;
   

   ZeroMemory(szSerialNumber,40);
   ZeroMemory(szOnlineKeyGuess,200*5);
   ZeroMemory(szSerialNumberGuess,40*5);

   read = fopen( szDirectory, "r");
   if (read == NULL)
      printf( "Null fead\n" );
   while ( !feof( read ) ) {
      
      if ( fgets( szLine, 300, read ) == NULL) {
         break;
      }
      sscanf( szLine,"%s", szLineTest );

      if (0 != strstr(szLineTest, "OBJ")) {
         //Find SerialNumber
         sscanf( szLine,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s", 
                 szDontCare[0],
                 szDontCare[1],
                 szDontCare[2],
                 szDontCare[3],
                 szDontCare[4],
                 szDontCare[5],
                 szDontCare[6],
                 szDontCare[7],
                 szDontCare[8],
                 szDontCare[9],
                 szDontCare[10],
                 szDontCare[11],
                 szDontCare[12],
                 szSerialNumberGuess[0], 
                 szSerialNumberGuess[1], 
                 szSerialNumberGuess[2], 
                 szSerialNumberGuess[3], 
                 szSerialNumberGuess[4] 
                 );


         // This will grab the Serial Number key even if it moves 5 positions.
         if (0 == strcmp (szSerialNumberGuess[0],inSerialNumber)) {
            strcpy (szSerialNumber, szSerialNumberGuess[0]);
         }else 
         if (0 == strcmp (szSerialNumberGuess[1],inSerialNumber)) {
            strcpy (szSerialNumber, szSerialNumberGuess[1]);
         }else
         if (0 == strcmp (szSerialNumberGuess[2],inSerialNumber)) {
            strcpy (szSerialNumber,szSerialNumberGuess[2]);
         }else
         if (0 == strcmp (szSerialNumberGuess[3],inSerialNumber)) {
            strcpy (szSerialNumber,szSerialNumberGuess[3]);
         }else
         if (0 == strcmp (szSerialNumberGuess[4],inSerialNumber)) {
            strcpy (szSerialNumber,szSerialNumberGuess[4]);
         }


         //for (int o = 0; o < 16; o++) {
         //   printf( "Token: %s \n", szDontCare[o] );
         //}
         
         //printf( "SerialNumber:: %s | %s\n", szSerialNumber, inSerialNumber );
         // Match SerialNumber we want.
         if(0 == strcmp(szSerialNumber,inSerialNumber)){
            printf( "SerialNumber:: FOUND  %s\n", szSerialNumber );
            // Find the Online Key. Its Next Line
            if ( fgets( szLine, 300, read ) == NULL) {
               printf( "fgets error\n" );
               break;
            }
            sscanf( szLine,"%s%s%s%s%s%s%s%s%s%s%s", 
                    szDontCare[0],
                    szDontCare[1],
                    szDontCare[2],
                    szDontCare[3],
                    szDontCare[4],
                    szDontCare[5],
                    szDontCare[6],
                    szOnlineKeyGuess[0],
                    szOnlineKeyGuess[1],
                    szOnlineKeyGuess[2] );
                                        
            // This will grab the Online key even if it moves 3 positions.
            if (0 != strstr (szOnlineKeyGuess[0],"=")) {
               strcpy (szOnlineKey, szOnlineKeyGuess[0]);
            }else 
            if (0 != strstr (szOnlineKeyGuess[1],"=")) {
               strcpy (szOnlineKey, szOnlineKeyGuess[1]);
            }else
            if (0 != strstr (szOnlineKeyGuess[2],"=")) {
               strcpy (szOnlineKey, szOnlineKeyGuess[2]);
            }
            
            //for (int o = 0; o < 8; o++) {
            //   printf( "Token: %s \n", szDontCare[o] );
            //}
            //printf( "DB:=>%s\n\n", szOnlineKey );
            RtlCopyMemory( inOnlineKey, szOnlineKey, 172 );
            bReturn = TRUE;
            goto c0;
         }
      }
   }
   c0:
   fclose( read );
   return bReturn;
}


BOOL
C2kIdUtils::
ScanInformationXLS( IN PCHAR szDirectory, 
                    IN PCHAR inSerialNumber,
                    IN PCHAR inOnlineKey )
{
   
   CHAR szLine[300];
   CHAR szLineTest[50];
   CHAR szOnlineKeyGuess[5][200];
   CHAR szOnlineKey[200];
   
   
   CHAR szSerialNumber[40];
   CHAR szSerialNumberGuess[5][40];
   
   CHAR szDontCare[40][30];

   FILE *read;
   BOOL bReturn = FALSE;
   

   ZeroMemory(szSerialNumber,40);
   ZeroMemory(szOnlineKeyGuess,200*5);
   ZeroMemory(szSerialNumberGuess,40*5);

   read = fopen( szDirectory, "r");
   if (read == NULL)
      printf( "Null fead\n" );
   while ( !feof( read ) ) {

      if ( fgets( szLine, 300, read ) == NULL) {
         break;
      }
      sscanf( szLine,"%s", szLineTest );
      if (0 != strstr(szLineTest, "-")) {
         //Find SerialNumber
         sscanf( szLine,"%s%s%s%s%s%s%s%s", 
                 szDontCare[0],
                 szDontCare[1],
                 szSerialNumberGuess[0], 
                 szDontCare[3],
                 szDontCare[4],
                 szDontCare[5],
                 szDontCare[6],
                 szOnlineKeyGuess[0]
               );

         strcpy (szSerialNumber, szSerialNumberGuess[0]);
         if (0 == strcmp(szSerialNumber,inSerialNumber)) {
            printf( "SerialNumber:: FOUND  %s\n", szSerialNumber );
            strcpy (szOnlineKey, szOnlineKeyGuess[0]);
            RtlCopyMemory( inOnlineKey, szOnlineKey, 172 );
            bReturn = TRUE;
            goto c0;
         }
      }
   }
   c0:
   fclose( read );
   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\2kId_Tests.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "2kIdMaster.h"
#include "2kId_Tests.h"
#include "tchar.h"
#include "CNetwork.h"
#include "..\\include\\fileformat.h"


VOID 
C2kIdTests::
SetDoRemote(IN BOOL b ) 
{
   m_bDoRemote = b; 

   if (FALSE == m_bDoRemote) {
      printf ("Local Provider Initializing.\n");
      //Start up the local crypto.
      InitializeProvider();
   } else {
      printf ("Remoting to NCipher chosen.\n");
   }
}
 
BOOL
C2kIdTests::
TestMACAddress( VOID )
{

   HRESULT hr;
   DWORD GameRegion = XC_GAME_REGION_NA;
   DWORD AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
   BYTE MACAddress[ETHERNET_MAC_ADDR_LEN] = { 0x66,0x66,0x66,0x66,0x66,0x66};
   char XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'};
   char HardDriveKey[HARD_DRIVE_KEY_LEN];
   char RecoveryKey[RECOVERY_KEY_LEN];
   DWORD dwOnlineKeyVersion = 0;
   char OnlineKey[ONLINE_KEY_PKENC_SIZE];
   BYTE buffer[512];
   DWORD dwBufferSize = sizeof(buffer);
   INT j;
   
   system("cls");
   printf ("\t++++++++++++++++++++++++++++++\n");
   printf ("\t+    MAC Address Loop        +\n");
   printf ("\t++++++++++++++++++++++++++++++\n\n");

   for (j = 1; j < 1000; j++) {

      MACAddress[0] = (BYTE)(j % 0xff);
      MACAddress[1] = (BYTE)(j % 0xff);
      MACAddress[2] = (BYTE)(j % 0xff);
      MACAddress[3] = (BYTE)(j % 0xff);
      MACAddress[4] = (BYTE)(j % 0xff);
      MACAddress[5] = (BYTE)(j % 0xff);


      dwBufferSize = sizeof(buffer);
      hr = GeneratePerBoxData (
                              GameRegion,
                              AVRegion,
                              MACAddress,
                              XboxSerialNumber,
                              HardDriveKey,
                              RecoveryKey,
                              &dwOnlineKeyVersion,
                              OnlineKey,
                              buffer,
                              &dwBufferSize );

      if ( FAILED( hr ) ) {
         printf("Failed GeneratePerBoxData - [%x]\n", hr);
         return FALSE;
      }
      printf("\r");
   }
   return TRUE;
}



BOOL
C2kIdTests::
TestMemLeakage( )
{

   HRESULT hr;
   BYTE buffer[100];
   DWORDLONG j;
   MEMORYSTATUSEX ms;
   BOOL b;

   // Get initial memory.
   ms.dwLength = sizeof (ms);
   GlobalMemoryStatusEx( &ms );
   DWORDLONG dwlInitialMemory = ms.ullAvailPhys/1024; // in KBytes
   DWORDLONG dwlInitialCommittedMemoryCharge = (ms.ullTotalPageFile -  ms.ullAvailPageFile)/1024; // in KBytes.
   DWORDLONG dwlCommittedMemoryCharge;

   system("cls");
   printf ("\t\t++++++++++++++++++++++++++++++\n");
   printf ("\t\t+ Memory Leak Detection Test +\n");
   printf ("\t\t++++++++++++++++++++++++++++++\n\n");
   printf ("            Committed Charge   Free Physical  Loop   \n" );
   printf ("            ----------------   -------------  -------\n" );
   printf ("INITIALLY:  %*I64d %sB         %*I64d %sB      0      \n", 
           7, dwlInitialCommittedMemoryCharge, "K",
           7, dwlInitialMemory, "K");


   for (j = 0; j < 100000000; j++) {


      hr = GenerateID( buffer,sizeof(buffer)  );
      if ( FAILED( hr ) ) {
         printf("Failed GeneratePerBoxData - [%x]\n", hr);
         return FALSE;
      }

      ms.dwLength = sizeof (ms);
      b = GlobalMemoryStatusEx( &ms );
      if ( !b ) return FALSE;

      // Calculate the committed charge. 
      dwlCommittedMemoryCharge = (ms.ullTotalPageFile -  ms.ullAvailPageFile)/1024; // in KBytes.

      printf ("CURRENTLY:  %*I64d %sB         %*I64d %sB      %I64d  ", 
              7, dwlCommittedMemoryCharge, "K",
              7,  ms.ullAvailPhys/1024, "K", j);


      if ( dwlCommittedMemoryCharge  >  dwlInitialCommittedMemoryCharge + 10000) {
         // if memory is above dwlInitialCommittedMemoryCharge by 10000 Kbytes then fail it as leaking.
         printf ("\n\nThere is a cumulative leak of over 10000 bytes in this loop. FAILED\n");
         return FALSE;
      }
      printf("\r");
   }
   return TRUE;
}




BOOL
C2kIdTests::
TestXClient( DWORD dwFlag )
{

   DWORD j;
   INT   ret;
   DATA_PACKET  SendData;
   DATA_PACKET  RecvData;
   char  szIp[20] = "";
   BOOL bResult;
   HRESULT hr;
   
   UNREFERENCED_PARAMETER(dwFlag);

   if (m_dwTestLoop == 0) m_dwTestLoop = 1;

   for (j = 0; j < m_dwTestLoop; j++) {
      
      szIp[0] = 0;
      printf("Do Xbox\n");

      printf("\n-------------------START SESSION %lu----------------\n",j);
      printf("[STATUS]\t\t[Description of Action]\n");

      CNetWork cn( szIp, m_szXboxName, COMMUNICATION_PORT );
      
      ZeroMemory( (PDATA_PACKET)&SendData, sizeof( SendData )); 
      ZeroMemory( (PDATA_PACKET)&RecvData, sizeof( RecvData )); 
      
      DWORD GameRegion = XC_GAME_REGION_NA;

      DWORD AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
      BYTE MACAddress[ETHERNET_MAC_ADDR_LEN] = { 0x1A,0x2A,0x3A,0x4A,0x5A,0x6A};
      char XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'};
      char RecoveryKey[RECOVERY_KEY_LEN];
      DWORD dwOnlineKeyVersion = 0;
      
      char OnlineKeyEncryptedBase64Encoded[173];
      BYTE OnlineKeyEncrypted             [131];
      BYTE OnlineKey                      [17];
      ULONG ulOnlineKey = 0;
      char HardDriveKeyBase64Encoded      [25];
      BYTE HardDriveKey                   [20];
      ULONG ulHardDriveKey = 0;

      ZeroMemory(OnlineKeyEncryptedBase64Encoded, 173);
      ZeroMemory(OnlineKeyEncrypted, 131);
      ZeroMemory(HardDriveKeyBase64Encoded, 25);
      ZeroMemory(HardDriveKey, 20);
      ZeroMemory(OnlineKey, 17);


      if (j % 2) {
        GameRegion = XC_GAME_REGION_JAPAN;
      } else
        GameRegion = XC_GAME_REGION_NA;


      DWORD dwOutBufferSize;
      dwOutBufferSize = PACKET_DATA_SIZE; 
      
      printf("  OK\t\t\tGenerating Data\n");
      hr = GeneratePerBoxData ( GameRegion,
                                AVRegion,
                                MACAddress,
                                XboxSerialNumber,
                                HardDriveKeyBase64Encoded,
                                RecoveryKey,
                                &dwOnlineKeyVersion,
                                OnlineKeyEncryptedBase64Encoded,
                                SendData.byteData,
                                &dwOutBufferSize );
      if ( FAILED( hr ) ) {
         if ( hr == E_INVALIDARG )
            printf("  NOT_OK\t\tFailed GeneratePerBoxData - [%x]\n", E_INVALIDARG);
         else
            printf("  NOT_OK\t\tFailed GeneratePerBoxData - [%x]\n", hr);
         return FALSE;
      }
     /*
      FileToDrive( "c:\\w.dat",  
             OnlineKeyEncryptedBase64Encoded, 
             172,
             NEW_FILE );

      FileToDrive( "c:\\wireEEPROM.dat",  
                   SendData.byteData, 
                   EEPROM_TOTAL_MEMORY_SIZE, // from xconfig.h = 256,
                   NEW_FILE );
     */
      
      //-------- ONLINE KEY RECOVERY  -------------------------------------      
      // Base64 decode to shave off the 172 bytes down to 128 bytes.
      bResult = Base64Decode( OnlineKeyEncryptedBase64Encoded,
                              172,
                              OnlineKeyEncrypted,
                              &ulOnlineKey );
      assert(bResult == TRUE);
      assert( ulOnlineKey == 128 );
      if ( !bResult ) {
         printf("  NOT_OK\t\t\tOnlineKey base64Decoding failed.\n");
         return FALSE;
      }
      if (TRUE == m_bDoRemote) {
         RemoteNCipherDecryptKeys( OnlineKeyEncrypted, OnlineKey, sizeof(OnlineKey) ); 
      } else {
         DecryptOnlineKey( OnlineKeyEncrypted, OnlineKey, sizeof(OnlineKey));
      }
      //-------- HARDDRIVE KEY RECOVERY ------------------------------------      
      // Base64 decode to shave off the 24 bytes down to 16 bytes.
      bResult = Base64Decode( HardDriveKeyBase64Encoded,
                              24,
                              HardDriveKey, // This must be at least BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) ((((ulSrcSize) / 4) * 3) + 1)
                              &ulHardDriveKey );
      assert( ulHardDriveKey == 16 );
      if ( !bResult ) {
         printf("  NOT_OK\t\t\tHardDriveKey Base64Decoding failed.\n");
         return FALSE;
      }
      
      //-------- START TRANSPORT DATA -------------------------------------      
      // Send the Command Block 
      sprintf( SendData.szMessage,"Command Block");
      SendData.dwCommand = DO_VERIFY_WRITEPERBOXDATA;
      if (SOCKET_ERROR == (ret = cn.SendData( &SendData, sizeof(SendData)))){
         return FALSE;
      }

      // Send the data 
      sprintf( SendData.szMessage,"Generated BINARY ID");
      SendData.ulDataSize = dwOutBufferSize; 
      if (SOCKET_ERROR == (ret = cn.SendData( &SendData, sizeof(SendData)))){
         return FALSE;
      }


      // Wait for acknowledgement of EEPROM from the XBE
      if (SOCKET_ERROR == ( ret = cn.RecvData(&RecvData, sizeof(RecvData)))) {
         printf("  NOT_OK\t\t\tReceiving EEPROM Written file failed\n");
         return FALSE;
      } else {
         printf("  OK\t\t\tReceiving EEPROM Written file.\n");
      }


      // Dump the EEPROMs data to a file.
      //WriteFileOut( "EEPROM.dat",  RecvData.byteData, EEPROM_TOTAL_MEMORY_SIZE /* from xconfig.h = 256*/ );


      // Carve up the returned memory into the layout we believe is there.
      // First copy it so its persistent over next connection.
      BYTE bEEPROMData[EEPROM_TOTAL_MEMORY_SIZE];

      RtlCopyMemory(bEEPROMData,RecvData.byteData,EEPROM_TOTAL_MEMORY_SIZE);
      EEPROM_LAYOUT* pEEPROM = (EEPROM_LAYOUT*)bEEPROMData;
      
      XBOX_FACTORY_SETTINGS* pxfs = ( XBOX_FACTORY_SETTINGS* )pEEPROM->FactorySection; 
      XBOX_USER_SETTINGS*    pxus = ( XBOX_USER_SETTINGS* )pEEPROM->UserConfigSection;
      // Currently not encrypted on a dev kit. We will unmorph the Onlinekey on the 
      // XBE server end before getting back here. Sinces the MorphFunction is an
      // XBE library. The rom *isn't* totally the same one as directly read off the 256byte
      // EEPROM.
      PXBOX_ENCRYPTED_EEPROM_DATA pxeed = ( PXBOX_ENCRYPTED_EEPROM_DATA )pEEPROM->EncryptedSection;
      // Comparisons of EEPROM datas
      //-------- COMPARISON of EEPROM DATA --------------------------------      
      
      // XboxOnlineKey
      // ONLINE_KEY_LEN  16
      printf("\t[  *  IMPORTANT  *  ]\n");
      printf("\t[Checking Encrypted Base64 Encoded Online Key matches EEPROMS]\n");
      
      // The catch if the machine is a dev kit.
      if (TRUE == RecvData.bDevKit) {
         RtlZeroMemory(HardDriveKey,HARD_DRIVE_KEY_LEN);
      }

      
      if (TRUE == RtlEqualMemory(pxfs->OnlineKey,
                                   OnlineKey, ONLINE_KEY_LEN)) {
         printf("  OK\t\t\tOnline Key\n");
      } else {
         printf("  NOT_OK\t\t\tOnline Key\n");
         printf("  Dumping Online Key returned for storage from GenPerBoxData\n     ");
         DumpBytesHex(OnlineKey, ONLINE_KEY_LEN );
         printf("\n");
         printf("  Dumping EEPROMS Online Key\n     ");
         DumpBytesHex(pxfs->OnlineKey, ONLINE_KEY_LEN );
         printf("\n");
      }
      
      // HardDriveKey
      // HARD_DRIVE_KEY_LEN  16
      if (TRUE == RtlEqualMemory(pxeed->HardDriveKey,
                                 HardDriveKey, HARD_DRIVE_KEY_LEN)) {
         printf("  OK\t\t\tHardDrive Key\n");
      } else {
         printf("  NOT_OK\t\t\tHardDrive Key\n");
         printf("  Dumping HardDrive Key\n");
         DumpBytesHex(HardDriveKey, HARD_DRIVE_KEY_LEN );
         printf("\n");
         printf("  Dumping EEPROM HardDrive Key\n\n");
         DumpBytesHex(pxeed->HardDriveKey, HARD_DRIVE_KEY_LEN );
         printf("\n");
      }
      // This is what was sent to WritePerBoxData. It use to come back decrypted.
      // and that isn't a good thing. This has been bugged.
      if (SOCKET_ERROR == ( ret = cn.RecvData(&RecvData, sizeof(RecvData))))
         return FALSE;
      //-------- END   TRANSPORT DATA -------------------------------------      
     
 
      // This is returning what we sent over.
      PXBOX_ENCRYPTED_PER_BOX_DATA pxRecvData =  (PXBOX_ENCRYPTED_PER_BOX_DATA)
                                             (RecvData.byteData + sizeof(RC4_SHA1_HEADER));
      // This is a pointer to what is sent.
      PXBOX_ENCRYPTED_PER_BOX_DATA pxSendData =  (PXBOX_ENCRYPTED_PER_BOX_DATA)
                                             (SendData.byteData + sizeof(RC4_SHA1_HEADER));

      // Do comparision and decoding of the information returned.
      // Decrypt the data blob from the GeneratePerBoxId and compare.
      bResult = Decrypt(SendData.byteData, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA));
      assert( bResult == TRUE );
      if ( !bResult ) {
         printf("  NOT_OK\t\t\tDecrypting the sent data ID failed\n");
         return FALSE;
      }else
         printf("  OK\t\t\tDecrypting the sent data ID from GeneratePerBoxData\n");

      // Decrypt the returned data blob from the WritePerBoxData.
      bResult = Decrypt(RecvData.byteData, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA));
      assert( bResult == TRUE );
      if ( !bResult ) {
         printf("  NOT_OK\t\t\tDecrypting the recv data ID failed\n");
         return FALSE;
      }else
         printf("  OK\t\t\tDecrypting the sent recv ID from GeneratePerBoxData\n");


      // We'll compare the sent buffer to the returned buffer to make sure that 
      // the code does not decrypted the sent buffer. It used to.
      if (TRUE == RtlEqualMemory(pxRecvData,
                                 pxSendData, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA))) {
         printf("  OK\t\t\tSent Buffer NOT decrypted by WritePerBoxData\n");
      } else {
         printf("  NOT_OK\t\t\tSent Buffer IS decrypted by WritePerBoxData\n");
      }

      // Testing what we have on this end to what is on the EEPROM.
      // MAC Address
      if (TRUE == RtlEqualMemory(pxSendData->MACAddress,
                                 pxfs->EthernetAddr, sizeof(pxSendData->MACAddress))) {
         printf("  OK\t\t\tMAC Address\n");
         printf("  \t\t\tOriginal MACAddress: %02X:%02X:%02X:%02X:%02X:%02X\n", 
                                    pxSendData->MACAddress[0],
                                    pxSendData->MACAddress[1],
                                    pxSendData->MACAddress[2],
                                    pxSendData->MACAddress[3],
                                    pxSendData->MACAddress[4],
                                    pxSendData->MACAddress[5] );
         printf("  \t\t\tEEPROM   MACAddress: %02X:%02X:%02X:%02X:%02X:%02X\n", 
                                    pxfs->EthernetAddr[0],
                                    pxfs->EthernetAddr[1],
                                    pxfs->EthernetAddr[2],
                                    pxfs->EthernetAddr[3],
                                    pxfs->EthernetAddr[4],
                                    pxfs->EthernetAddr[5] );
      }else{
         printf("  NOT_OK\t\t\tMAC Address\n");
         printf("  \t\t\tOriginal MACAddress: %02X:%02X:%02X:%02X:%02X:%02X\n", 
                                    pxSendData->MACAddress[0],
                                    pxSendData->MACAddress[1],
                                    pxSendData->MACAddress[2],
                                    pxSendData->MACAddress[3],
                                    pxSendData->MACAddress[4],
                                    pxSendData->MACAddress[5] );
         printf("  \t\t\tEEPROM   MACAddress: %02X:%02X:%02X:%02X:%02X:%02X\n", 
                                    pxfs->EthernetAddr[0],
                                    pxfs->EthernetAddr[1],
                                    pxfs->EthernetAddr[2],
                                    pxfs->EthernetAddr[3],
                                    pxfs->EthernetAddr[4],
                                    pxfs->EthernetAddr[5] );
      }
      
      // Clear the Highbit.
      pxeed->GameRegion ^= XC_GAME_REGION_MANUFACTURING;
      if (TRUE == RtlEqualMemory(&pxSendData->GameRegion,
                                 &pxeed->GameRegion, sizeof(pxeed->GameRegion))) {
         printf("  OK\t\t\tGameRegion\n");
         printf("\t\tGameRegion SEND: %lu\n", pxSendData->GameRegion );
         printf("\t\tGameRegion EEPM: %lu\n", pxeed->GameRegion );
      
      }else{
         printf("  NOT_OK\t\tGameRegion\n");
         printf("GameRegion SEND: %lu\n", pxSendData->GameRegion );
         printf("GameRegion EEPM: %lu\n", pxeed->GameRegion );
      }


      // Language settings must match for Japanese etc.
      // Everywhere else its English.
      if ( GameRegion == XC_GAME_REGION_JAPAN) {
         if (pxus->Language == XC_LANGUAGE_JAPANESE) {
            printf("  OK\t\t\tLanguage Settings Japanese\n");
            printf("  \t\t\tJapanese Language for Japanese GameRegion: %lu\n", 
                   pxus->Language, pxeed->GameRegion  );
         } else {
            printf("  NOT_OK\t\tLanguageSettings\n");
            printf("  \t\t\tJapanese Language not set Japanese GameRegion: %lu\n", 
                   pxus->Language, pxeed->GameRegion );
         }

      }else{
         if (pxus->Language == 0 ){ // default is ZERO no english XC_LANGUAGE_ENGLISH) {
            printf("  OK\t\t\tLanguage Settings NO language set\n");
         } else {
            printf("  NOT_OK\t\tLanguageSettings has a language set FAILED.\n");
         }
         printf("  \t\t\tNO Language set : GameRegion: %lu\n", 
                pxeed->GameRegion );
      }
      
      printf("\n-------------------END   SESSION--------------------\n");
      Sleep(500);
   }
   return TRUE;
}



BOOL
C2kIdTests::
TestLockHardDrive( IN DWORD dwControl )
{
   
   
   DATA_PACKET  SendData = {0};
   DATA_PACKET  RecvData = {0};
   char  szIp[20] = "";
   SOCKET ret;

   if (dwControl == 1) {
      SendData.dwCommand = DO_LOCK_HARDDRIVE;
   } else {
      SendData.dwCommand = DO_UNLOCK_HARDDRIVE;
   }

   CNetWork cn( szIp, m_szXboxName, COMMUNICATION_PORT );
   printf("\n-------------------START SESSION--------------------\n");
   printf("[STATUS]\t\t[Description of Action]\n" );

   //-------- START TRANSPORT DATA -------------------------------------      
   // Send the Command Block 
   sprintf( SendData.szMessage,"Command Block");
   if (SOCKET_ERROR == (ret = cn.SendData( &SendData, sizeof(SendData)))) {
      return FALSE;
   }

   // Receive the Message
   if (SOCKET_ERROR == ( ret = cn.RecvData(&RecvData, sizeof(RecvData))))
      return FALSE;

   printf("\n-------------------END   SESSION--------------------\n");
   Sleep(500);

   return TRUE;
}



BOOL
C2kIdTests::
ReadRemotesEEPROM( DWORD dwFlag )
{

   UNREFERENCED_PARAMETER(dwFlag);
   DWORD j;
   DATA_PACKET  SendData;
   DATA_PACKET  RecvData;
   char  szIp[20] = "";
   char  szFileName[260]= "";
   SOCKET ret;

   if (m_dwTestLoop == 0) 
      m_dwTestLoop =1;

   for (j = 0; j < m_dwTestLoop; j++) {
      szIp[0] = NULL;
      CNetWork cn( szIp, m_szXboxName, COMMUNICATION_PORT );


      printf("\n-------------------START SESSION--------------------\n");
      printf("[STATUS]\t\t[Description of Action]\n");

      ZeroMemory( (PDATA_PACKET)&SendData, sizeof( SendData )); 
      ZeroMemory( (PDATA_PACKET)&RecvData, sizeof( RecvData )); 
      
      char OnlineKeyEncryptedBase64Encoded[173];
      BYTE OnlineKeyEncrypted             [131];
      BYTE OnlineKey                      [17];
      // ULONG ulOnlineKey = 0;
      char HardDriveKeyBase64Encoded[25];
      BYTE HardDriveKey                   [20];

      ZeroMemory(OnlineKeyEncryptedBase64Encoded, 173);
      ZeroMemory(OnlineKeyEncrypted, 131);
      ZeroMemory(HardDriveKeyBase64Encoded, 25);
      ZeroMemory(HardDriveKey, 20);
      ZeroMemory(OnlineKey, 17);

      //-------- START TRANSPORT DATA -------------------------------------      
      // Send the Command Block 
      sprintf( SendData.szMessage,"Command Block");
      SendData.dwCommand = DO_SENDBACK_EEPROM;
      if (SOCKET_ERROR == (ret = cn.SendData( &SendData, sizeof(SendData)))){
         return FALSE;
      }

      // Receive the EEPROM
      if (SOCKET_ERROR == ( ret = cn.RecvData(&RecvData, sizeof(RecvData))))
         return FALSE;
      sprintf( szFileName,"EEPROM%s.dat", szIp);
      
      EEPROM_LAYOUT* eeprom = (EEPROM_LAYOUT*) RecvData.byteData;
      //XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
      XBOX_USER_SETTINGS* userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
      PXBOX_ENCRYPTED_EEPROM_DATA  pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;
      printf("Language is %lu\n", userSettings->Language);
      if (pEncryptedEEPROMData->GameRegion & XC_GAME_REGION_MANUFACTURING ) {
         // Clear out the GameRegion Bit.
         pEncryptedEEPROMData->GameRegion ^= XC_GAME_REGION_MANUFACTURING;
      }
      printf("GameRegion is %lu\n", pEncryptedEEPROMData->GameRegion);

      FileToDrive(szFileName, RecvData.byteData, 256 , NEW_FILE );
      // Read Info from File and compare.
      printf("\n-------------------END   SESSION--------------------\n");
      Sleep(500);
   }
   
   return TRUE;
}

BOOL
C2kIdTests::
TestDirectoryOfEEPROMS( IN PCHAR szDirectory,
                        IN PCHAR szDataBaseFile )
{

   //Read in the file.
   WIN32_FIND_DATA   ffd;
   HANDLE            hFind;
   TCHAR             szFindFiles  [ MAX_PATH ];

   BYTE bTotalDatFile[512];
   PCRITICAL_KEY_PAIR pckp;

   BYTE bEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT*  eeprom                 = (EEPROM_LAYOUT*)bEEPROMMemory;
   XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*)    &eeprom->FactorySection;
   XBOX_USER_SETTINGS* userSettings       = (XBOX_USER_SETTINGS*)       &eeprom->UserConfigSection;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA)&eeprom->EncryptedSection;

   BOOL bResult;
   BYTE OnlineKeyEncryptedBase64Encoded[172];
   BYTE OnlineKeyEncrypted             [131];
   BYTE OnlineKey                      [17];
   ULONG ulOnlineKey = 0;

   ZeroMemory(OnlineKeyEncrypted, 131);
   ZeroMemory(OnlineKey, 17);
   CHAR szSerialNumber[12];


   _stprintf(szFindFiles,TEXT("%s\\*.dat"),szDirectory);
   if ( (hFind = FindFirstFile(szFindFiles, &ffd) ) == INVALID_HANDLE_VALUE) {
      _tprintf(TEXT("Could not find any files in %s!!\n"), szDirectory );
      return FALSE;
   }
   // else found files.

   do {
      if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
         _tprintf(TEXT("%s\\%s\n"),szDirectory,ffd.cFileName);
         // Perform task.
         _stprintf(szFindFiles,TEXT("%s\\%s"),szDirectory,ffd.cFileName);
         ZeroMemory( eeprom, EEPROM_TOTAL_MEMORY_SIZE);

         ReadFileIntoBuffer( szFindFiles, (BYTE*)&bTotalDatFile,  400 );
         RtlCopyMemory( eeprom, bTotalDatFile, EEPROM_TOTAL_MEMORY_SIZE );
         
         LPBYTE pEcryptedCriticalPair = bTotalDatFile + EEPROM_TOTAL_MEMORY_SIZE; 
         bResult=
         rc4HmacDecrypt( (LPBYTE)DAT_ENCRYPTION_KEY, 
                         DAT_ENCRYPTION_KEY_LEN,
                         (LPBYTE)(pEcryptedCriticalPair + sizeof(RC4_SHA1_HEADER)),
                         sizeof(CRITICAL_KEY_PAIR),
                         pEcryptedCriticalPair);

         if (FALSE == bResult) {
            _tprintf("Error Decrypting.\n");
         }
         pckp = (PCRITICAL_KEY_PAIR)(pEcryptedCriticalPair + sizeof(RC4_SHA1_HEADER)); 
         
         _tprintf( "HardDriveKey ");
         DumpBytesHex( pckp->HardDriveKey, 16 );
         if (pEncryptedEEPROMData->GameRegion & XC_GAME_REGION_MANUFACTURING ) {
            // Clear out the GameRegion Bit.
            pEncryptedEEPROMData->GameRegion ^= XC_GAME_REGION_MANUFACTURING;
         }
         _tprintf( "GameRegion %lu\n",pEncryptedEEPROMData->GameRegion);
         _tprintf( "SerialNumber ");
         DumpBytesChar( factorySettings->SerialNumber, 12);
         sprintf(szSerialNumber,"%0.12s", factorySettings->SerialNumber);

         if (szDataBaseFile != NULL) {
            // Get Serial From Database
            BOOL b = ScanInformation( szDataBaseFile, 
                                      szSerialNumber,
                                      (char*)OnlineKeyEncryptedBase64Encoded );
            ZeroMemory(OnlineKey,16);
            if (b == TRUE) {
               // Base64 decode to shave off the 172 bytes down to 128 bytes.
               bResult = Base64Decode( (char*)OnlineKeyEncryptedBase64Encoded,
                                       172,
                                       OnlineKeyEncrypted,
                                       &ulOnlineKey );
               assert(bResult == TRUE);
               assert( ulOnlineKey == 128 );
               if ( !bResult ) {
                  printf("  NOT_OK\t\tOnlineKey base64Decoding failed %lu .\n", ulOnlineKey);
                  return FALSE;
               }

               if (TRUE == m_bDoRemote) {
                  RemoteNCipherDecryptKeys( OnlineKeyEncrypted,
                                            OnlineKey, sizeof(OnlineKey) ); 
               } else {
                  DecryptOnlineKey( OnlineKeyEncrypted, OnlineKey, sizeof(OnlineKey));
               }
            }

            _tprintf( "EthernetAddress ");
            DumpBytesHex( factorySettings->EthernetAddr, 6);
            _tprintf( "Online Key ");
            //DumpBytesHex( factorySettings->OnlineKey, 16);
            if (TRUE == RtlEqualMemory(pckp->OnlineKey, OnlineKey, 16 )) {
               printf("  OK\t\t\tOnline Keys Match\n");
            } else {
               printf("  NOT_OK\t\t\tOnline Keys Do Not Match\n");
            }
            _tprintf( "DATABASE:\n");
            DumpBytesHex( OnlineKey, 16);
         }
         _tprintf( "EEPROM:\n");
         DumpBytesHex( pckp->OnlineKey, 16);
         _tprintf( "AVRegion is %s\n", AvRegionBitTest (factorySettings->AVRegion));
         _tprintf( "Language %lu\n\n\n",userSettings->Language );
      }

   }while ( FindNextFile(hFind, &ffd));
    FindClose(hFind);
   return TRUE;
}


BOOL
C2kIdTests::
TestDirectoryOfTonyChensEEPROMS( 
   IN PCHAR szDirectory,
   IN PCHAR szDataBaseFile 
)
{

   //Read in the file.
   WIN32_FIND_DATA   ffd;
   HANDLE            hFind;
   TCHAR             szFindFiles  [ MAX_PATH ];

   BYTE bTotalDatFile[300];
   //PCRITICAL_KEY_PAIR pckp;

   BYTE bEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT*  eeprom                 = (EEPROM_LAYOUT*)bEEPROMMemory;
   XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*)    &eeprom->FactorySection;
   //XBOX_USER_SETTINGS* userSettings       = (XBOX_USER_SETTINGS*)       &eeprom->UserConfigSection;
   //PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA)&eeprom->EncryptedSection;

   BOOL bResult;
   BYTE OnlineKeyEncryptedBase64Encoded[172];
   BYTE OnlineKeyEncrypted             [131];
   BYTE OnlineKey                      [16];
   ULONG ulOnlineKey = 0;

   ZeroMemory(OnlineKeyEncrypted, 131);
   ZeroMemory(OnlineKey, 17);
   CHAR szSerialNumber[12];

   _stprintf(szFindFiles,TEXT("%s\\*.dat"),szDirectory);
   if ( (hFind = FindFirstFile(szFindFiles, &ffd) ) == INVALID_HANDLE_VALUE) {
      _tprintf(TEXT("Could not find any files in %s!!\n"), szDirectory );
      return FALSE;
   }
   // else found files.

   do {
      if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
         _tprintf(TEXT("%s\\%s\n"),szDirectory,ffd.cFileName);
         // Perform task.
         _stprintf(szFindFiles,TEXT("%s\\%s"),szDirectory,ffd.cFileName);
         ZeroMemory( eeprom, EEPROM_TOTAL_MEMORY_SIZE);
         ReadFileIntoBuffer( szFindFiles, (BYTE*)&bTotalDatFile,  300 );
         RtlCopyMemory( eeprom, bTotalDatFile, EEPROM_TOTAL_MEMORY_SIZE );
         
         _tprintf( "SerialNumber ");
         DumpBytesChar( factorySettings->SerialNumber, 12);
         sprintf(szSerialNumber,"%0.12s", factorySettings->SerialNumber);

         if (szDataBaseFile != NULL) {
            // Get Serial From Database
            BOOL b = ScanInformationXLS( szDataBaseFile, 
                                         szSerialNumber,
                                         (char*)OnlineKeyEncryptedBase64Encoded );

            /*
            BOOL b = ScanInformation( szDataBaseFile, 
                                      szSerialNumber,
                                      (char*)OnlineKeyEncryptedBase64Encoded );
            */
            ZeroMemory(OnlineKey,16);
            // means its found in the database.
            if (b == TRUE) {
               // Base64 decode to shave off the 172 bytes down to 128 bytes.
               bResult = Base64Decode( (char*)OnlineKeyEncryptedBase64Encoded,
                                       172,
                                       OnlineKeyEncrypted,
                                       &ulOnlineKey );
               assert(bResult == TRUE);
               assert( ulOnlineKey == 128 );
               if ( !bResult ) {
                  printf("  NOT_OK\t\tOnlineKey base64Decoding failed %lu .\n", ulOnlineKey);
                  return FALSE;
               }
               if (TRUE == m_bDoRemote) {
                  RemoteNCipherDecryptKeys( OnlineKeyEncrypted,
                                            OnlineKey, sizeof(OnlineKey) ); 
               } else {
                  DecryptOnlineKey( OnlineKeyEncrypted, OnlineKey, sizeof(OnlineKey));
               }

               
               // try to decrypt the data package.
               LPBYTE pEcryptedCriticalData = bTotalDatFile + EEPROM_TOTAL_MEMORY_SIZE; 

               //#define DAT "\x3F\x5B\xF1\xA4\xDF\xD7\xEF\x49\x93\xB0\x8F\x87\x86\xC8\x70\xB5"
               bResult=
               rc4HmacDecrypt( (LPBYTE)OnlineKey, 
                               sizeof(OnlineKey),
                               (LPBYTE)(pEcryptedCriticalData + sizeof(RC4_SHA1_HEADER)),
                               16,
                               pEcryptedCriticalData);
               if (TRUE == bResult )
                  printf("  OK\t\t\tOnline Key\n");
               else
                  printf("  NOT_OK\t\t\tOnline Key\n");

            } else {
               printf("  NOT_OK\t\tOnline key is not in the database.\n");
               // Not  found in Database file.
            }

            ZeroMemory(OnlineKey,sizeof(OnlineKey));
            //_tprintf( "DATABASE: Onlinekey\n");
            //DumpBytesHex( OnlineKey, 16);
         }


      }
   
   }while ( FindNextFile(hFind, &ffd));
    FindClose(hFind);
   return TRUE;
}



BOOL
C2kIdTests::
TestRemoteDecrypt( DWORD dwFlag )
{
   DWORD j;
   DATA_PACKET  SendData;
   DATA_PACKET  RecvData;
   BYTE bWireStructure[PACKET_DATA_SIZE];
   
   char  szIp[20] ="";
   BOOL bResult;
   HRESULT hr;
   if (m_dwTestLoop == 0) 
      m_dwTestLoop =1;

   for (j = 0; j < m_dwTestLoop; j++) {
      if ( dwFlag & DO_LOCALHOST ) {
         strcpy ( szIp, "157.56.13.95" );
         m_szXboxName[0] = NULL;
         printf("Do localhost\n");
      } else {
         szIp[0] = 0;
         printf("Do Xbox\n");
      }

      printf("\n-------------------START SESSION--------------------\n");
      printf("[STATUS]\t\t[Description of Action]\n");
      ZeroMemory( (PDATA_PACKET)&SendData, sizeof( SendData )); 
      ZeroMemory( (PDATA_PACKET)&RecvData, sizeof( RecvData )); 
      
      DWORD GameRegion = XC_GAME_REGION_NA;
      DWORD AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
      BYTE  MACAddress[ETHERNET_MAC_ADDR_LEN] = { 0x66,0x66,0x66,0x66,0x66,0x66};
      char  XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'};
      char  RecoveryKey[RECOVERY_KEY_LEN];
      DWORD dwOnlineKeyVersion = 0;
      
      char OnlineKeyEncryptedBase64Encoded[173];
      BYTE OnlineKeyEncrypted             [131];
      BYTE OnlineKey                      [17];
      ULONG ulOnlineKey = 0;
      char HardDriveKeyBase64Encoded[25];
      BYTE HardDriveKey                   [20];


      ZeroMemory(OnlineKeyEncryptedBase64Encoded, 173);
      ZeroMemory(OnlineKeyEncrypted, 131);
      ZeroMemory(HardDriveKeyBase64Encoded, 25);
      ZeroMemory(HardDriveKey, 20);
      ZeroMemory(OnlineKey, 17);

      DWORD dwOutBufferSize;
      dwOutBufferSize = PACKET_DATA_SIZE; 
      
      printf("  OK\t\t\tGenerating Data\n");

      hr = GeneratePerBoxData ( GameRegion,
                                AVRegion,
                                MACAddress,
                                XboxSerialNumber,
                                HardDriveKeyBase64Encoded,
                                RecoveryKey,
                                &dwOnlineKeyVersion,
                                OnlineKeyEncryptedBase64Encoded,
                                bWireStructure,
                                &dwOutBufferSize );
      if ( FAILED( hr ) ) {
         if ( hr == E_INVALIDARG )
            printf("  NOT_OK\t\tFailed GeneratePerBoxData - [%x]\n", E_INVALIDARG);
         else
            printf("  NOT_OK\t\tFailed GeneratePerBoxData - [%x]\n", hr);
         return FALSE;
      }

      //-------- ONLINE KEY RECOVERY  -------------------------------------      
      // Base64 decode to shave off the 172 bytes down to 128 bytes.
      bResult = Base64Decode( OnlineKeyEncryptedBase64Encoded,
                              172,
                              OnlineKeyEncrypted,
                              &ulOnlineKey );
      assert(bResult == TRUE);
      assert( ulOnlineKey == 128 );
      if ( !bResult ) {
         printf("  NOT_OK\t\t\tOnlineKey base64Decoding failed.\n");
         return FALSE;
      }


      if (TRUE == m_bDoRemote) {
         RemoteNCipherDecryptKeys( OnlineKeyEncrypted, OnlineKey, sizeof(OnlineKey) ); 
      } else {
         DecryptOnlineKey( OnlineKeyEncrypted, OnlineKey, sizeof(OnlineKey));
      }


      // Carve up the returned memory into the layout we believe is there.
      // First copy it so its persistent over next connection.
      XBOX_ENCRYPTED_PER_BOX_DATA xepbd;
      Decrypt(bWireStructure, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA));
      
      RtlCopyMemory(&xepbd, bWireStructure + sizeof(RC4_SHA1_HEADER), 
                    sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) );
      

      // XboxOnlineKey
      // ONLINE_KEY_LEN  16
      printf("\t[  *  IMPORTANT  *  ]\n");
      printf("\t[Checking Encrypted Base64 Encoded Online Key matches EEPROMS]\n");
      if (TRUE == RtlEqualMemory(xepbd.OnlineKey,
                                   OnlineKey, ONLINE_KEY_LEN)) {
         printf("  OK\t\t\tOnline Key\n");
         printf("  Dumping Online Key remotely decrypted.\n");
         DumpBytesHex(OnlineKey, ONLINE_KEY_LEN );
         printf("\n");
         printf("  Dumping WireBuffer's Online Key\n");
         DumpBytesHex(xepbd.OnlineKey, ONLINE_KEY_LEN );
         printf("\n");
      } else {
         printf("  NOT_OK\t\t\tOnline Key\n");
         printf("  Dumping Online Key remotely decrypted.\n");
         DumpBytesHex(OnlineKey, ONLINE_KEY_LEN );
         printf("\n");
         printf("  Dumping WireBuffer's Online Key\n");
         DumpBytesHex(xepbd.OnlineKey, ONLINE_KEY_LEN );
         printf("\n");
      }
      printf("\n-------------------END   SESSION--------------------\n");
      Sleep(500);
   }
   
   return TRUE;
}


BOOL
C2kIdTests::
TestRemoteDecodingOfOnlineKey( IN PCHAR OnlineKeyEncryptedBase64Encoded )
{
   
   DATA_PACKET  SendData;
   DATA_PACKET  RecvData;
   BYTE bWireStructure[PACKET_DATA_SIZE];
   XBOX_ENCRYPTED_ONLINE_DATA xeod = {0};



   printf("\n-------------------START SESSION--------------------\n");
   printf("[STATUS]\t\t[Description of Action]\n");
   ZeroMemory( (PDATA_PACKET)&SendData, sizeof( SendData )); 
   ZeroMemory( (PDATA_PACKET)&RecvData, sizeof( RecvData )); 

   BYTE OnlineKeyEncrypted             [131];
   BYTE OnlineKey                      [17];
   ULONG ulOnlineKey = 0;
   ZeroMemory(OnlineKeyEncrypted, 131);
   ZeroMemory(OnlineKey, 17);


   //-------- ONLINE KEY RECOVERY  -------------------------------------      
   // Base64 decode to shave off the 172 bytes down to 128 bytes.
   BOOL 
   bResult = Base64Decode( OnlineKeyEncryptedBase64Encoded,
                           172,
                           OnlineKeyEncrypted,
                           &ulOnlineKey );

   assert(bResult == TRUE);
   assert( ulOnlineKey == 128 );
   if ( !bResult ) {
      printf("  NOT_OK\t\t\tOnlineKey base64Decoding failed.\n");
      return FALSE;
   }
   if (TRUE == m_bDoRemote) {
      RemoteNCipherDecryptKeys( OnlineKeyEncrypted, (LPBYTE)&xeod, sizeof(xeod) ); 
   } else {
      DecryptOnlineKey( OnlineKeyEncrypted, (LPBYTE)&xeod, sizeof(xeod));
   }

   // Carve up the returned memory into the layout we believe is there.
   // First copy it so its persistent over next connection.
   XBOX_ENCRYPTED_PER_BOX_DATA xepbd;
   Decrypt(bWireStructure, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA));
   RtlCopyMemory(&xepbd, bWireStructure + sizeof(RC4_SHA1_HEADER), 
                 sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) );

   printf("  Encrypted Key in CHAR\n");
   DumpBytesChar((LPBYTE)OnlineKeyEncryptedBase64Encoded, 172 );
   printf("\n");
   printf("  Base64 Decoded Key in HEX\n");
   DumpBytesHex(OnlineKeyEncrypted, 128 );
   printf("\n");
   printf("  PlainText Key in Hex\n");
   DumpBytesHex(xeod.OnlineKey, sizeof(xeod.OnlineKey));
   printf("  XboxSerialNumber\n");
   DumpBytesChar((UCHAR*)xeod.XboxSerialNumber, 12 );
   printf("  XboxHardDrive in Hex\n");
   DumpBytesHex(xeod.HardDriveKey, sizeof(xeod.HardDriveKey));
   
   printf("\n-------------------END   SESSION--------------------\n");
   return TRUE;
}


BOOL
C2kIdTests::
TestVerifyCheckSum( DWORD dwFlag )
{

   dwFlag =0;

   return TRUE;
}




BOOL
C2kIdTests::
TestParametersGenPerBoxData( )
{
   
   INT i;
   GENPERBOXDATA_INFO x;

   printf("\n-------------------START SESSION--------------------\n");
   printf("[STATUS]\t\t[Description of Action]\n");

   // Test OutBufferSize is too small.
   ResetVariables(&x);
   x.dwOutBufferSize = 0; 
   x.hr = GeneratePerBoxData ( x.GameRegion,
                             x.AVRegion,
                             x.MACAddress,
                             x.XboxSerialNumber,
                             x.HardDriveKeyBase64Encoded,
                             x.RecoveryKey,
                             &x.dwOnlineKeyVersion,
                             x.OnlineKeyEncryptedBase64Encoded,
                             x.byteData,
                             &x.dwOutBufferSize );
   if ( x.hr == E_INVALIDARG )
      printf("  OK\t\t\tSmall buffer correct failure E_INVALIDARG.\n");
   else
      printf("  NOT_OK\t\t\tSmall buffer incorrect failure.\n");

//--------------------------------------------------------------------------------------

   // Test pcOutputBuffer is null OutputBufferSize returns necessary size.
   ResetVariables(&x);
   x.dwOutBufferSize = 0;
   x.hr = GeneratePerBoxData ( x.GameRegion,
                             x.AVRegion,
                             x.MACAddress,
                             x.XboxSerialNumber,
                             x.HardDriveKeyBase64Encoded,
                             x.RecoveryKey,
                             &x.dwOnlineKeyVersion,
                             x.OnlineKeyEncryptedBase64Encoded,
                             NULL,
                             &x.dwOutBufferSize );
   

   if ( SUCCEEDED(x.hr) ) {
      if ( x.dwOutBufferSize == 88 )
         printf("  OK\t\t\tNULL OutputBuffer, NULL OutBufferSize does return 88.\n");
      else
         printf("  NOT_OK\t\tNULL OutputBuffer, NULL OutBufferSize does not  return 88.\n");
   } else {
      printf("  NOT_OK\t\tNULL OutputBuffer does not return correct S_OK.\n");
   }
//--------------------------------------------------------------------------------------
   // Test MAC address being over 6 bytes. Expect only 6 copied
   for (i =0; i < 3; i++) {
      x.MACAddress[i] = 0x66;
   }
   for (i =3; i < 10; i++) {
      x.MACAddress[i] = 0x77;
   }
   // MAC address should look like { 0x66,0x66,0x66,0x66,0x66,0x66,0x77,0x77,0x77,0x77 };
   ResetVariables(&x);
   x.dwOutBufferSize = 88;
   x.hr = GeneratePerBoxData ( x.GameRegion,
                             x.AVRegion,
                             x.MACAddress,
                             x.XboxSerialNumber,
                             x.HardDriveKeyBase64Encoded,
                             x.RecoveryKey,
                             &x.dwOnlineKeyVersion,
                             x.OnlineKeyEncryptedBase64Encoded,
                             x.byteData,
                             &x.dwOutBufferSize );
   if ( SUCCEEDED(x.hr) ) {

      BOOL bResult; 
      // Decrypt the send buffer.
      bResult =  rc4HmacDecrypt( (LPBYTE)FACTORY_RAND_KEY, 
                                  FACTORY_RAND_KEY_LEN,
                                  x.byteData + sizeof(RC4_SHA1_HEADER),
                                  sizeof(XBOX_ENCRYPTED_PER_BOX_DATA),
                                  x.byteData);
      assert( bResult == TRUE );
      
      // Decode the Online Key Buffer.
      // Base64 decode to shave off the 172 bytes down to 128 bytes.
      bResult = Base64Decode( (LPCSTR)x.OnlineKeyEncryptedBase64Encoded,
                              172,
                              (LPBYTE)x.OnlineKeyEncrypted,
                              &x.ulOnlineKey );
      assert( x.ulOnlineKey == 128 );
      
      if (TRUE == m_bDoRemote) {
         RemoteNCipherDecryptKeys( x.OnlineKeyEncrypted, x.OnlineKey, sizeof(x.OnlineKey) ); 
      } else {
         DecryptOnlineKey( x.OnlineKeyEncrypted, x.OnlineKey, sizeof(x.OnlineKey));
      }

      // This is a pointer to the wire data.
      PXBOX_ENCRYPTED_PER_BOX_DATA pxWireData =  (PXBOX_ENCRYPTED_PER_BOX_DATA)
                                             (x.byteData + sizeof(RC4_SHA1_HEADER));

      // Check only the 6 bytes.. If the match then we really don't care about the next bytes
      // as long as the 6 bytes stored are correct
      if (TRUE == RtlEqualMemory(pxWireData->MACAddress,
                                 x.MACAddress,
                                 sizeof(pxWireData->MACAddress))) {
         printf("  OK\t\t\tMAC Address\n");
      } else {
         printf("  NOT_OK\t\t\tMAC Address\n");
         printf("  MACAddress: %02X:%02X:%02X:%02X:%02X:%02X\n", 
                pxWireData->MACAddress[0],
                pxWireData->MACAddress[1],
                pxWireData->MACAddress[2],
                pxWireData->MACAddress[3],
                pxWireData->MACAddress[4],
                pxWireData->MACAddress[5] );
         printf("  MACAddress: %02X:%02X:%02X:%02X:%02X:%02X\n", 
                x.MACAddress[0],
                x.MACAddress[1],
                x.MACAddress[2],
                x.MACAddress[3],
                x.MACAddress[4],
                x.MACAddress[5] );
      }
   }else
      printf("  NOT_OK\t\tMAC Address did not return S_OK\n");
   
//--------------------------------------------------------------------------------------
   // Test with a 13 byte Serial Number only 12 should be copied.
   ResetVariables(&x);
   char sz13ByteSerialNum[13] = {'A','B','C','D','E','F','G','H','I','J','K','L','M'};
   x.hr = GeneratePerBoxData ( x.GameRegion,
                             x.AVRegion,
                             x.MACAddress,
                             sz13ByteSerialNum,
                             x.HardDriveKeyBase64Encoded,
                             x.RecoveryKey,
                             &x.dwOnlineKeyVersion,
                             x.OnlineKeyEncryptedBase64Encoded,
                             x.byteData,
                             &x.dwOutBufferSize );

   if ( SUCCEEDED(x.hr) ) {

      BOOL bResult; 
      // Decrypt the send buffer.
      bResult =  rc4HmacDecrypt( (LPBYTE)FACTORY_RAND_KEY, 
                                    FACTORY_RAND_KEY_LEN,
                                    x.byteData + sizeof(RC4_SHA1_HEADER),
                                    sizeof(XBOX_ENCRYPTED_PER_BOX_DATA),
                                    x.byteData);
      assert( bResult == TRUE );

      // Decode the Online Key Buffer.
      // Base64 decode to shave off the 172 bytes down to 128 bytes.
      bResult = Base64Decode( (LPCSTR)x.OnlineKeyEncryptedBase64Encoded,
                              172,
                              (LPBYTE)x.OnlineKeyEncrypted,
                              &x.ulOnlineKey );
      assert( x.ulOnlineKey == 128 );
      if (TRUE == m_bDoRemote) {
         RemoteNCipherDecryptKeys( x.OnlineKeyEncrypted, x.OnlineKey, sizeof(x.OnlineKey) ); 
      } else {
         DecryptOnlineKey( x.OnlineKeyEncrypted, x.OnlineKey, sizeof(x.OnlineKey));
      }

      // Noting that the OnlineKey is also the entire structure.
      // make sure that the Serial Number is correct
      PXBOX_ENCRYPTED_ONLINE_DATA pOnline = 
         (PXBOX_ENCRYPTED_ONLINE_DATA)x.OnlineKeyDataBaseInfo;

      // This is a pointer to the wire data.
      PXBOX_ENCRYPTED_PER_BOX_DATA pxWireData =  (PXBOX_ENCRYPTED_PER_BOX_DATA)
                                                 (x.byteData + sizeof(RC4_SHA1_HEADER));

      if (FALSE == ByteCmp((LPBYTE)pxWireData->XboxSerialNumber, (LPBYTE)sz13ByteSerialNum, 12)) {
         printf("  NOT_OK\t\tSerNum wire data 13 bytes not 12 long.\n");
      }else {
         //printf("  %s %s\n",pxWireData->XboxSerialNumber,sz13ByteSerialNum);
         printf("  OK\t\t\tSerNum, wire data 12 bytes, truncated from 13.\n");
      }
      if (FALSE == ByteCmp((LPBYTE)pOnline->XboxSerialNumber,(LPBYTE)sz13ByteSerialNum, 12)) {
         printf("  NOT_OK\t\tSerNum Online Buffer 13 bytes  not 12 long.\n");
      }else{
         printf("  OK\t\t\tSerNum Online Buffer 12 bytes, truncated from 13.\n");
      }
   }else{
      printf("  NOT_OK\t\tSerial Number did not return S_OK\n");
   }

   

//--------------------------------------------------------------------------------------
   // Test with a non alpha numberic characters.
   /*
   ResetVariables(&x);
   char sz13ByteSerialNum[13] = {'A','B','C','D','E','F','G','H','I','J','K','L','M'};
   x.hr = GeneratePerBoxData ( x.GameRegion,
                             x.AVRegion,
                             x.MACAddress,
                             sz13ByteSerialNum,
                             x.HardDriveKeyBase64Encoded,
                             x.RecoveryKey,
                             &x.dwOnlineKeyVersion,
                             x.OnlineKeyEncryptedBase64Encoded,
                             x.byteData,
                             &x.dwOutBufferSize );

   if ( SUCCEEDED(x.hr) ) {

      BOOL bResult; 
      // Decrypt the send buffer.
      bResult =  rc4HmacDecrypt( (LPBYTE)FACTORY_RAND_KEY, 
                                    FACTORY_RAND_KEY_LEN,
                                    x.byteData + sizeof(RC4_SHA1_HEADER),
                                    sizeof(XBOX_ENCRYPTED_PER_BOX_DATA),
                                    x.byteData);
      assert( bResult == TRUE );

      // Decode the Online Key Buffer.
      // Base64 decode to shave off the 172 bytes down to 128 bytes.
      bResult = Base64Decode( (LPCSTR)x.OnlineKeyEncryptedBase64Encoded,
                              172,
                              (LPBYTE)x.OnlineKeyEncrypted,
                              &x.ulOnlineKey );
      assert( x.ulOnlineKey == 128 );
      hr = DecryptOnlineKey((LPBYTE)x.OnlineKeyEncrypted, 
                               (LPBYTE)x.OnlineKeyDataBaseInfo, 
                               sizeof(x.OnlineKeyDataBaseInfo));
      assert( hr == S_OK );

      // Noting that the OnlineKey is also the entire structure.
      // make sure that the Serial Number is correct
      PXBOX_ENCRYPTED_ONLINE_DATA pOnline = 
         (PXBOX_ENCRYPTED_ONLINE_DATA)x.OnlineKeyDataBaseInfo;


      // This is a pointer to the wire data.
      PXBOX_ENCRYPTED_PER_BOX_DATA pxWireData =  (PXBOX_ENCRYPTED_PER_BOX_DATA)
                                                 (x.byteData + sizeof(RC4_SHA1_HEADER));

      if (FALSE == ByteCmp((LPBYTE)pxWireData->XboxSerialNumber, (LPBYTE)sz13ByteSerialNum, 12)) {
         printf("  NOT_OK\t\tSerNum wire data 13 bytes not 12 long.\n");
      }else {
         printf("  %s %s\n",pxWireData->XboxSerialNumber,sz13ByteSerialNum);
         printf("  OK\t\t\tSerNum, wire data 12 bytes, truncated from 13.\n");
      }
      if (FALSE == ByteCmp((LPBYTE)pOnline->XboxSerialNumber,(LPBYTE)sz13ByteSerialNum, 12)) {
         printf("  NOT_OK\t\tSerNum Online Buffer 13 bytes  not 12 long.\n");
      }else{
         printf("  OK\t\t\tSerNum Online Buffer 12 bytes, truncated from 13.\n");
      }
   }else{
      printf("  NOT_OK\t\tSerial Number did not return S_OK\n");
   }
     */
//--------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\CCrypto.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "CCrypto.h"
#include "..\\include\\fileformat.h"
 

void
CCrypto::
shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{


#define HMAC_K_PADSIZE              64
    
   BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


BOOL
CCrypto::
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{

   PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
   RC4_SHA1_HEADER TempHeader;
   BYTE LocalKey[A_SHA_DIGEST_LEN];
   RC4_KEYSTRUCT Rc4KeyStruct;

   RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

   //
   // HMAC the checksum into the key
   //
   shaHmac( pbKey, cbKey,
            CryptHeader->Checksum, A_SHA_DIGEST_LEN,
            NULL, 0,
            LocalKey );
   //
   // Use the generated key as the RC4 encryption key
   //
   rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

   //
   // Decrypt confounder and data
   //
   rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
   rc4( &Rc4KeyStruct, cbInput, pbInput );


   //
   // Now verify the checksum.
   //
   shaHmac( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

   //
   // Decrypt is successful only if checksum matches
   //
   return( RtlEqualMemory(
                         TempHeader.Checksum,
                         CryptHeader->Checksum,
                         A_SHA_DIGEST_LEN) );
}


BOOL 
CCrypto::
Decrypt ( IN OUT LPBYTE pbInputBuffer,
          IN DWORD dwInputBufferSize )
{
   
   return rc4HmacDecrypt( (LPBYTE)FACTORY_RAND_KEY, 
                           FACTORY_RAND_KEY_LEN,
                           pbInputBuffer + sizeof(RC4_SHA1_HEADER),
                           dwInputBufferSize,
                           pbInputBuffer );
                           
}


   
CCrypto::
CCrypto( )
{ 
   m_hProv   = 0; 
   m_hPrvKey = 0; 
}


HRESULT
CCrypto::
InitializeProvider()
{
   
   HRESULT   hr = S_OK;
   BOOL bResult;
   
   #define PROVIDER "nCipher Enhanced Cryptographic Provider"
   CryptAcquireContext( &m_hProv,
                        "XboxOnlineKeyV1",
                        PROVIDER,
                        PROV_RSA_FULL,
                        CRYPT_DELETEKEYSET);
   m_hProv = 0;

   // open crypto context with the private key
   bResult = CryptAcquireContext(&m_hProv,
                                 "XboxOnlineKeyV1",
                                 PROVIDER,
                                 PROV_RSA_FULL,
                                 CRYPT_MACHINE_KEYSET);
   if (!bResult) {
      hr = GetLastError();
      printf("CryptAcquireContext failed with %x\n", hr);
      if (NTE_KEYSET_NOT_DEF == hr ) {
         printf("This machine probably doesn't have a the regkey installed\n");
         printf("OR the NCipher is not on this machine\n");
      }
      m_hProv = 0;
      exit(1);
   }

   bResult = CryptGetUserKey( m_hProv, AT_KEYEXCHANGE, &m_hPrvKey );
   if (!bResult) {
      hr = GetLastError();
      printf("CryptGetUserKey failed with %x\n", hr);
      exit(1);
   }
   return hr;
}




HRESULT
CCrypto::
DecryptOnlineKey( IN  LPBYTE pbEncrypted_128_Data, 
                  OUT LPBYTE pbUnencrypted_16_Data,
                  IN  DWORD  dwSizeOfOutBuffer )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    

    Routine Description:
        Decrypts a 128 bit NCipher encrypted buffer
    Arguments:
        Encrypted buffer
        Output buffer.
        Size if none put defaults to 16 byte output buffer if sized then copies that many
        bytes to the output buffer.
    Return Value:

--*/

{

   BOOL bResult;
   HRESULT hr;
   DWORD dwDataLen;

   // Decrypt the online key with the private key.
   BYTE buffer[ONLINE_KEY_PKENC_SIZE];

   RtlCopyMemory( buffer, pbEncrypted_128_Data, ONLINE_KEY_PKENC_SIZE );
   
   dwDataLen = ONLINE_KEY_PKENC_SIZE;
   bResult = CryptDecrypt( m_hPrvKey, NULL, TRUE, 0, buffer, &dwDataLen );
   if (!bResult) {
      hr = GetLastError();
      printf("Error %x during CryptDecrypt! Bytes output:%lu\n", hr, dwDataLen);
      goto error;
   }

   // Reverse the bytes for now.
   BYTE *s,*e, t;
   s = &buffer[0];
   e = &buffer[dwDataLen - 1];

   while (s < e) {
      t = *s;
      *s++ = *e;
      *e-- = t;
   }

  if ( 0 == dwSizeOfOutBuffer){
     ZeroMemory (pbUnencrypted_16_Data, dwSizeOfOutBuffer);
     RtlCopyMemory( pbUnencrypted_16_Data, buffer, dwSizeOfOutBuffer );
  }else{
     ZeroMemory (pbUnencrypted_16_Data, dwSizeOfOutBuffer );
     RtlCopyMemory( pbUnencrypted_16_Data, buffer, dwSizeOfOutBuffer );
  }

   hr = S_OK;
   
error:
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\CNetwork.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    6/26/2001

    Description:
        This is the cpp file for the Network class.

--*/
#include "CNetwork.h"


BOOL
RemoteNCipherDecryptKeys( IN  LPBYTE lpbEncryptedKey,
                          OUT LPBYTE lpbDecryptedKey,
                          IN  DWORD  dwSizeDecryptedKey)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    6/26/2001

    Routine Description:
        This routines calls our remoting function to decrypt using the NCipher box.
    Arguments:
        encrypted key and then decrypted key.
    Return Value:
      TRUE upon success.
      FALSE upon failure.

--*/

{
   
   CNetWork* n1 = new CNetWork("wallyho-ts", NULL , COMMUNICATION_SERVICE_PORT );
   DATA_PACKET In;
   DATA_PACKET Out;
   RtlCopyMemory(Out.byteData, lpbEncryptedKey, ONLINE_KEY_PKENC_SIZE);
   sprintf(Out.szMessage,"%s","Encrypted Key");
   n1->SendData(&Out,sizeof(Out));
   // Decrypted key.
   n1->RecvData( &In, sizeof(In));
   CopyMemory(lpbDecryptedKey, In.byteData, dwSizeDecryptedKey);
   delete n1;
   return TRUE;
}





BOOL
CNetWork::
IpAdvertise( VOID )
{

   SOCKET sBroadCast;
   BOOL   bBroadCast = TRUE;
   SOCKADDER_IN sddrFrom;
   char       szInBuffer[20];
   INT        iFromLen;
   WSADATA    wsd;
   
   printf("Waiting for broadcast to send IP\n" );
   if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
      printf("Failed to load Winsock library!\n");
      // return FALSE;
   }

   // Do a recvfrom so we then broadcast out our IP
   // Create a broadcast socket.
   sBroadCast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   if (sBroadCast == SOCKET_ERROR) {
      printf("broadcast socket() failed: %d\n", WSAGetLastError());
   }

   // Set this to a broadcast socket.
   setsockopt(sBroadCast,SOL_SOCKET, SO_BROADCAST,(char *)&bBroadCast, sizeof(bBroadCast));
   
   sddrFrom.sin_family = AF_INET;
   sddrFrom.sin_addr.s_addr = htonl(INADDR_ANY) ;
   sddrFrom.sin_port = htons(5159);

   printf( "Waiting for broadcast to send IP\n" );

   if ( SOCKET_ERROR == bind(sBroadCast, (SOCKADDR *)&sddrFrom, sizeof(sddrFrom))){
      printf("bind() failed: %d\n", WSAGetLastError());
   }
   printf("3\n" );
   
   iFromLen =  sizeof(sddrFrom);
   recvfrom( sBroadCast,
             szInBuffer,
             20,
             0,
             (SOCKADDR *)&sddrFrom,
             &iFromLen);
   printf("Address where broadcast came from %s\n",  inet_ntoa(sddrFrom.sin_addr) );
   printf("Message %s", szInBuffer );
   
   closesocket(sBroadCast);
   WSACleanup();

   return TRUE;
}

 
BOOL
CNetWork::
GetXboxIpFromName ( IN CHAR* szXboxName, OUT CHAR* szIp)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/26/2001

    Routine Description:
        This will get the Ip address of the Xbox specified.
    Arguments:
        The name. szIp will be the buffer containing the Ip.
        Buffer should be 16 bytes or larger. to contain aaa.bbb.ccc.ddd\0
    Return Value:
      True for success False for failure.

--*/
{

   BOOL bStatus = TRUE;
   szXboxName =0;
   SOCKET sBroadCast;
   BOOL   bBroadCast;
   SOCKADDER_IN sinCast;
   SOCKADDER_IN sddrFrom;
   SOCKADDER_IN sddrAccept;
   SOCKET sRead;
   INT iAddrLen;

   WSADATA       wsd;
   char *szInBuffer = "Give me your IP";
   BYTE  byteIP[15] = "";
   IN_ADDR* inaddr = (IN_ADDR *)byteIP;


   if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
      printf("Failed to load Winsock library!\n");
      exit(1);
   }
   // Create a broadcast socket.
   sBroadCast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   
   if (sBroadCast == SOCKET_ERROR) {
      printf("broadcast socket() failed: %d", WSAGetLastError());
   }
   // Set this to a broadcast socket.
   bBroadCast = TRUE;
   setsockopt(sBroadCast,SOL_SOCKET, SO_BROADCAST,
              (char *)&bBroadCast, sizeof(bBroadCast));

   sinCast.sin_family = AF_INET;
   sinCast.sin_addr.s_addr = INADDR_BROADCAST;
   sinCast.sin_port = htons(ADVERTISE_PORT);
   
   if ( SOCKET_ERROR == sendto( sBroadCast,
                                szInBuffer,
                                strlen(szInBuffer),
                                0,
                                (SOCKADDR*)&sinCast,
                                sizeof(sinCast))) {
      printf("  OK\t\t\tBroadcast failed %d\n", WSAGetLastError());
   }else
      printf("  OK\t\t\tBroadcasting\n");

   closesocket(sBroadCast);

   // Do a recvfrom so we then broadcast out our IP
   sBroadCast = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sBroadCast == SOCKET_ERROR) {
      printf("Opening socket() failed: %d\n", WSAGetLastError());
      bStatus = FALSE;
      goto exit;
   }
   
   sddrFrom.sin_family = AF_INET;
   sddrFrom.sin_addr.s_addr = htonl(INADDR_ANY) ;
   sddrFrom.sin_port = htons(ADVERTISE_PORT);

   if (bind(sBroadCast, (struct sockaddr *)&sddrFrom, sizeof(sddrFrom)) == SOCKET_ERROR) {
      printf("Bind() failed: %d", WSAGetLastError());
   }
   
   listen(sBroadCast,1);
   iAddrLen = sizeof(sddrAccept);
   sRead = accept( sBroadCast,(SOCKADDR *)&sddrAccept,&iAddrLen);
   closesocket(sBroadCast);

   // receive IP.
   recv( sRead, (CHAR *)byteIP, sizeof(byteIP),0);
   sprintf(szIp,"%s", inet_ntoa(*inaddr) );
   printf("  OK\t\t\tFinished broadcasting\n");
   printf("  OK\t\t\tXBOX's IP is %s\n", szIp);
   WSACleanup();


/***********************************************************************

     DmUseSharedConnection(TRUE);
     if (FAILED(DmSetXboxName(szXboxName))){
        printf( "Could not set the Xbox Name\n");
        b = FALSE;
        goto exit;
     }
     if (SUCCEEDED(DmGetXboxName(szXboxName, &cch))) {
        ULONG ulAddr;
        BYTE *pb = (BYTE *)&ulAddr;
        if (SUCCEEDED(DmResolveXboxName(&ulAddr))){
           printf(" Xbox target system %s (%d.%d.%d.%d)\n", szXboxName,
                   pb[3], pb[2], pb[1], pb[0]);
           sprintf(szIp,"%d.%d.%d.%d",  pb[3], pb[2], pb[1], pb[0]);
           sprintf(szIp,"157.56.13.226");
        } else {
           szIp = NULL;
           b = FALSE;
        }
     }
     exit:
     DmUseSharedConnection(FALSE);
***********************************************************************/
   exit:
   return bStatus;
}



// Below is network class.
CNetWork::CNetWork()
{
   CNetWork( NULL, "wallyhox" );
}


CNetWork::CNetWork( LPSTR szIpString, LPSTR szXboxName )
{
   CNetWork( szIpString, szXboxName, COMMUNICATION_PORT );

} 


CNetWork::CNetWork( LPSTR szIpString, LPSTR szXboxName, USHORT usPort )
{
   

   WSADATA       wsd;
   char          szIp[ 20 ];
   struct sockaddr_in server;
   struct hostent*    host = NULL;


   // Get the Ip for the specified Xbox.
   if (szIpString[0] == NULL) {
      GetXboxIpFromName ( szXboxName, szIp);
      strncpy(szIpString, szIp, strlen(szIp));
   }
   
   if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
      printf("Failed to load Winsock library!\n");
      exit(1);
   }else{
     // printf("WsaStartup called!\n");
   }
   
   
   // Create the socket, and attempt to connect to the server
   sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sClient == INVALID_SOCKET) {
      printf("socket() failed: %d\n", WSAGetLastError());
      exit(1);
   }
   
   server.sin_family = AF_INET;
   server.sin_port = htons(usPort);
   server.sin_addr.s_addr = inet_addr( szIpString );
   // If the supplied server address wasn't in the form
   // "aaa.bbb.ccc.ddd" it's a hostname, so try to resolve it
   
   if (server.sin_addr.s_addr == INADDR_NONE) {
      host = gethostbyname( szIpString );
      if (host == NULL) {
         printf("Unable to resolve server: %s\n", szIpString);
         exit(1);
      } else {
         CopyMemory(&server.sin_addr, host->h_addr, host->h_length);
         printf("  OK\t\t\t Resolved server: %s %s\n", szIpString, inet_ntoa( server.sin_addr ) );
      }
   }
   if (connect(sClient, (struct sockaddr *)&server, 
               sizeof(server)) == SOCKET_ERROR) {
      printf("connect() failed: %d\n", WSAGetLastError());
      exit(1);
   }
}



CNetWork::~CNetWork()
{
   closesocket(sClient);
   WSACleanup();
}



INT 
CNetWork::
SendData( LPVOID pvData, INT iSize)
{
   
   INT ret;
   PDATA_PACKET p = (PDATA_PACKET)pvData;
   // Send the data 
   ret = send(sClient,(const char*) pvData, iSize, 0);
   if (ret == SOCKET_ERROR ) { // SOCKET_ERROR == -1
      printf("  NOT_OK\t\t SEND %s failed: %d ret %d\n", 
               p->szMessage,
               WSAGetLastError(),
               ret);
   }else
      printf("  OK\t\t\t SEND [%d bytes] MSG: [SENT]: %s\n", ret, p->szMessage);
   return ret;
}


INT 
CNetWork::
RecvData( LPVOID pvData, INT iSize)
{
   
   INT ret;
   PDATA_PACKET p = (PDATA_PACKET)pvData;

   ret = recv( sClient,(char *) pvData, iSize, 0);
   if (ret == SOCKET_ERROR) {
      printf("  NOT_OK\t\t\t RECV failed: %d\n", WSAGetLastError());
   }else{
      printf("  OK\t\t\t RECV [%d bytes] MSG: [RECV]: %s\n", ret, p->szMessage);
   }
   return ret;
}


INT 
CNetWork::
CloseSocket( VOID )
{
   
   return closesocket( sClient );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\2kId_Utils.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _2KID_UTILS_H_
#define _2KID_UTILS_H_

#include <windows.h>
#include <cryptkeys.h>
// This typdef is for xconfig.h
typedef long NTSTATUS;
// This is needed so xconfig.h will work
#include <init.h>
#include <xconfig.h>
#include <av.h>
#include <base64.h>
#include <list.h>



typedef struct 
_GENPERBOXDATA_INFO {
   
   HRESULT hr;
   BYTE byteData[175];
   DWORD GameRegion;
   DWORD AVRegion;
   BYTE MACAddress[10];
   BYTE MACAddressSmall[2];
   char XboxSerialNumber[20];
   char RecoveryKey[12];
   DWORD dwOnlineKeyVersion;
   char OnlineKeyEncryptedBase64Encoded[173];
   BYTE OnlineKeyEncrypted[129];
   BYTE OnlineKey[17];
   char OnlineKeyDataBaseInfo[129];
   DWORD ulOnlineKey;
   char HardDriveKeyBase64Encoded[25];
   DWORD dwOutBufferSize;

} GENPERBOXDATA_INFO, *LPGENPERBOXDATA_INFO;


class C2kIdUtils {
   

   public:
      VOID 
      WriteFileFromMemory( LPCSTR lpFileName, LPVOID pvFileContents, DWORD dwFileSize );
      VOID 
      FileToDrive( LPCSTR lpFileName, LPVOID pvFileContents, DWORD dwFileSize,DWORD dwWriteFlags );
      BOOL
      ByteCmp(IN LPBYTE First, 
              IN LPBYTE Second, 
              IN DWORD  dwSize);
      BOOL
      DumpBytesHex(IN LPBYTE lpbID,
                IN UINT   uiSize);
      BOOL
      DumpBytesChar(IN LPBYTE lpbID,
                    IN UINT   uiSize);

      VOID
      ResetVariables( IN LPGENPERBOXDATA_INFO x);
      
      PCHAR
      AvRegionBitTest( IN DWORD dwBitMask);

      HRESULT
      GenerateID ( LPBYTE lpbData, DWORD dwSize );
   
      HRESULT
      ReadFileIntoBuffer (IN char* szFileName, 
                          IN BYTE* bFile,
                          IN DWORD dwSizeOfBuffer);
      BOOL
      ScanInformation( IN PCHAR szDirectory, 
                       IN PCHAR inSerialNumber,
                       IN PCHAR inOnlineKey );
      BOOL
      ScanInformationXLS( IN PCHAR szDirectory, 
                          IN PCHAR inSerialNumber,
                          IN PCHAR inOnlineKey );

   C2kIdUtils(){}
   ~C2kIdUtils(){}
   private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\CCrypto.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
//===================================================================
#ifndef _CCRYPTO_H_
#define _CCRYPTO_H_

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <cryptkeys.h>
#include <sha.h>
#include <rc4.h>
#include <wincrypt.h>
#include "..\include\DataPacket.h"

  
#define DAT_ENCRYPTION_KEY "\x7a\x3b\xa8\xb7\x27\xed\x43\x7a\xd0\xba\xfb\x8f\xa4\xd8\x31\x90"
CONST DWORD DAT_ENCRYPTION_KEY_LEN = 16;

//The LPBYTE out buffer is 52  XboxEncryptedPerBoxData +
//28 bytes of RC4_SHA1_HEADER.
#define RC4_CONFOUNDER_LEN 8

typedef struct _RC4_SHA1_HEADER {
   UCHAR Checksum[A_SHA_DIGEST_LEN];
   UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;



class CCrypto {

private:
   void shaHmac(
             IN PBYTE pbKeyMaterial,
             IN ULONG cbKeyMaterial,
             IN PBYTE pbData,
             IN ULONG cbData,
             IN PBYTE pbData2,
             IN ULONG cbData2,
             OUT PBYTE HmacData); // length must be A_SHA_DIGEST_LEN 

   HCRYPTPROV m_hProv;
   HCRYPTKEY m_hPrvKey;

public:


   BOOL Decrypt ( IN OUT LPBYTE pbInputBuffer,
                  IN     DWORD dwInputBufferSize );

   BOOL rc4HmacDecrypt(
                   IN PUCHAR pbKey,
                   IN ULONG cbKey,
                   IN PUCHAR pbInput,
                   IN ULONG cbInput,
                   IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
                   );

   void rc4HmacEncrypt(
              IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
              IN PUCHAR pbKey,
              IN ULONG cbKey,
              IN PUCHAR pbInput,
              IN ULONG cbInput,
              OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
              );
   HRESULT InitializeProvider();
   HRESULT DecryptOnlineKey( IN  LPBYTE pbEncrypted_128_Data, 
                             OUT LPBYTE pbUnencrypted_16_Data,
                             IN  DWORD  dwSizeOfOutBuffer = 0);

   ~CCrypto(){ if (NULL != m_hProv) CryptReleaseContext( m_hProv, 0 ); }
   CCrypto();

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kIdMaster\CNetwork.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _CNETWORK_H_
#define _CNETWORK_H_

#include <windows.h>
#include <cryptkeys.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <XboxDbg.h>
#include "..\\include\\DataPacket.h"

typedef struct sockaddr_in SOCKADDER_IN;
typedef struct sockaddr SOCKADDR;
   
   CONST USHORT ADVERTISE_PORT = 5159;
   CONST USHORT COMMUNICATION_PORT = 5150;
   CONST USHORT COMMUNICATION_SERVICE_PORT = 5161;

BOOL
RemoteNCipherDecryptKeys( IN  LPBYTE lpbEncryptedKey,
                          OUT LPBYTE lpbDecryptedKey,
                          IN  DWORD  dwSizeDecryptedKey);


class CNetWork {
private:
   SOCKET sClient;

public:

   INT  SendData( LPVOID pvData, INT iSize);
   INT  RecvData( LPVOID pvData, INT iSize);
   INT  CloseSocket( VOID );
   BOOL GetXboxIpFromName ( IN CHAR* szXboxName, OUT CHAR* szIp);
   BOOL IpAdvertise( VOID );
   
   ~CNetWork();
   CNetWork();
   CNetWork( LPSTR szIpString, LPSTR szXboxName );
   CNetWork( LPSTR szIpString, LPSTR szXboxName, USHORT usPort );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\2kNCipherService.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <CService.h>
/*++

   Filename :  2kNCipherService.cpp

   Description: Main for 2kNCipherService.cpp
   
   Created by:  Wally Ho

   History:     Created on 13/06/2001.

   Contains these functions:

--*/

  

INT WINAPI 
WinMain (HINSTANCE hInstance,
         HINSTANCE hPrev,
         LPSTR     lpCmdLine,
         INT       nCmdShow)
{

     UNREFERENCED_PARAMETER(nCmdShow);
     UNREFERENCED_PARAMETER(hPrev);
     UNREFERENCED_PARAMETER(lpCmdLine);
     UNREFERENCED_PARAMETER(hInstance);
   
    // Create the service object
    CService* s = new CService;
    // Parse for standard arguments (install, uninstall, version etc.)
    s->ParseStandardArgs();
    delete s;
    printf("Exiting...\n");
    // When we get here, the service has been stopped
    //return MyService.m_Status.dwWin32ExitCode;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\CCrypto.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "CCrypto.h"
#include "stdio.h"

BOOL
CCrypto::
DumpBytes(IN LPBYTE lpbID,
          IN UINT   uiSize)
{
   for ( UINT i = 0; i < uiSize; i++ ) {
      printf("%02X", lpbID[i]);
   }
   printf("\n");
   return TRUE;
}


void
CCrypto::
shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{


#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


BOOL
CCrypto::
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
              IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
              )
{

   PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
   RC4_SHA1_HEADER TempHeader;
   BYTE LocalKey[A_SHA_DIGEST_LEN];
   RC4_KEYSTRUCT Rc4KeyStruct;

   RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

   //
   // HMAC the checksum into the key
   //
   shaHmac( pbKey, cbKey,
            CryptHeader->Checksum, A_SHA_DIGEST_LEN,
            NULL, 0,
            LocalKey );
   //
   // Use the generated key as the RC4 encryption key
   //
   rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

   //
   // Decrypt confounder and data
   //
   rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
   rc4( &Rc4KeyStruct, cbInput, pbInput );


   //
   // Now verify the checksum.
   //
   shaHmac( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

   //
   // Decrypt is successful only if checksum matches
   //
   return( RtlEqualMemory(
                         TempHeader.Checksum,
                         CryptHeader->Checksum,
                         A_SHA_DIGEST_LEN) );
}


BOOL 
CCrypto::
Decrypt ( IN OUT LPBYTE pbInputBuffer,
          IN DWORD dwInputBufferSize )
{
   
   return rc4HmacDecrypt( (LPBYTE)FACTORY_RAND_KEY, 
                           FACTORY_RAND_KEY_LEN,
                           pbInputBuffer + sizeof(RC4_SHA1_HEADER),
                           dwInputBufferSize,
                           pbInputBuffer );
                           
}

CCrypto::CCrypto()
{ 

}


VOID
CCrypto::
InitCrypto( VOID )
{ 
   m_hProv   = 0; 
   m_hPrvKey = 0; 
   HRESULT   hr;
   BOOL bResult;
   #define PROVIDER "nCipher Enhanced Cryptographic Provider"

   CryptAcquireContext( &m_hProv,
                                  "XboxOnlineKeyV1",
                                  PROVIDER,
                                  PROV_RSA_FULL,
                                  CRYPT_DELETEKEYSET);
   // open crypto context with the private key
   bResult = CryptAcquireContext(&m_hProv,
                                 "XboxOnlineKeyV1",
                                 PROVIDER,
                                 PROV_RSA_FULL,
                                 CRYPT_MACHINE_KEYSET);
   if (!bResult) {
      hr = GetLastError();
      printf("CryptAcquireContext create MachineKeySet failed with %x\n", hr);
      m_hProv = 0;
      //exit(1);
   }

   bResult = CryptGetUserKey( m_hProv, AT_KEYEXCHANGE, &m_hPrvKey );
   if (!bResult) {
      hr = GetLastError();
      printf("CryptGetUserKey failed with %x\n", hr);
      //exit(1);
   }

}


HRESULT
CCrypto::
DecryptOnlineKey( IN  LPBYTE pbEncrypted_128_Data, 
                  OUT LPBYTE pbUnencrypted_16_Data )
{

   BOOL bResult;
   HRESULT hr;
   DWORD dwDataLen;

   // Decrypt the online key with the private key.
   BYTE buffer[ONLINE_KEY_PKENC_SIZE];

   RtlCopyMemory( buffer, pbEncrypted_128_Data, ONLINE_KEY_PKENC_SIZE );
   
   dwDataLen = ONLINE_KEY_PKENC_SIZE;
   
   bResult = CryptDecrypt( m_hPrvKey, NULL, TRUE, 0, buffer, &dwDataLen );
   if (!bResult) {
      hr = GetLastError();
      printf("Error %x during CryptDecrypt! Bytes output:%lu\n", hr, dwDataLen);
      goto error;
   }

   // Reverse the bytes for now.
   BYTE *s,*e, t;
   s = &buffer[0];
   e = &buffer[dwDataLen - 1];

   while (s < e) {
      t = *s;
      *s++ = *e;
      *e-- = t;
   }

   ZeroMemory (pbUnencrypted_16_Data, ONLINE_KEY_PKENC_SIZE );
   RtlCopyMemory( pbUnencrypted_16_Data, buffer, ONLINE_KEY_PKENC_SIZE );
   
   printf("\nENCRYPTED::\n");
   DumpBytes(pbEncrypted_128_Data, 128);
   printf("\nUNENCRYPTED:: \n");
   DumpBytes(pbUnencrypted_16_Data, 16);

   hr = S_OK;
   
error:
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\CCrypto.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <cryptkeys.h>
#include <sha.h>
#include <rc4.h>
#include <wincrypt.h>



//The LPBYTE out buffer is 52  XboxEncryptedPerBoxData +
//28 bytes of RC4_SHA1_HEADER.
#define RC4_CONFOUNDER_LEN 8
typedef struct _RC4_SHA1_HEADER {
   UCHAR Checksum[A_SHA_DIGEST_LEN];
   UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;
 
class CCrypto {
   
private:
   void shaHmac(
             IN PBYTE pbKeyMaterial,
             IN ULONG cbKeyMaterial,
             IN PBYTE pbData,
             IN ULONG cbData,
             IN PBYTE pbData2,
             IN ULONG cbData2,
             OUT PBYTE HmacData); // length must be A_SHA_DIGEST_LEN 

   HCRYPTPROV m_hProv;
   HCRYPTKEY m_hPrvKey;

public:
   
   BOOL DumpBytes(IN LPBYTE lpbID,
                  IN UINT   uiSize);


   BOOL Decrypt ( IN OUT LPBYTE pbInputBuffer,
                  IN     DWORD dwInputBufferSize );

   BOOL rc4HmacDecrypt(
                   IN PUCHAR pbKey,
                   IN ULONG cbKey,
                   IN PUCHAR pbInput,
                   IN ULONG cbInput,
                   IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
                   );

   void rc4HmacEncrypt(
              IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
              IN PUCHAR pbKey,
              IN ULONG cbKey,
              IN PUCHAR pbInput,
              IN ULONG cbInput,
              OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
              );
   
   HRESULT InitializeProvider();
   HRESULT DecryptOnlineKey( IN  LPBYTE pbEncrypted_128_Data, 
                             OUT LPBYTE pbUnencrypted_16_Data );

   ~CCrypto(){ CryptReleaseContext( m_hProv, 0 ); }
   CCrypto();
   VOID InitCrypto( VOID );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\CNetWork.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <stdio.h>
#include <winsock2.h>
#include "..\\include\\datapacket.h"

typedef struct sockaddr_in SOCKADDER_IN;
typedef struct sockaddr SOCKADDR;


CONST USHORT COMMUNICATION_SERVICE_PORT = 5161;

class CNetWorkConnection{
public:

   INT SendData( LPVOID pvData, INT iSize);
   INT RecvData( LPVOID pvData, INT iSize);
   
   VOID SetSocket( SOCKET s){ sConnection = s;}

   ~CNetWorkConnection();
   CNetWorkConnection();
   CNetWorkConnection( SOCKET s){ sConnection = s;}

private:
   SOCKET sConnection;

};



class CNetWork{

private:
   DWORD  m_dwAcceptIndex;
   SOCKET sClient;

public:

   SOCKET Accept ( struct sockaddr FAR *addr, int FAR *addrlen );
   SOCKET Accept ( VOID );
   BOOL StartThread( LPTHREAD_START_ROUTINE lpStartAddress, LPVOID Param );

   VOID InitNetWork( VOID );

   ~CNetWork();
   CNetWork();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\CService.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "CService.h"


// static variables
CService* CService::m_pCServiceThis = NULL;



DWORD WINAPI 
CService::
ServiceThread(LPDWORD param)
{

   UNREFERENCED_PARAMETER(param);
   // Since this is static , its basically a global local variable. Wallyho
   CService* p = m_pCServiceThis;
   
   
   HANDLE   hThread = 0;
   DWORD dwExitCode = 0;
   DWORD dwReturn = TRUE;
   printf(TEXT("Starting ServiceThread\n"));

   // initialize non blocking accept thread.
   hThread = CreateThread(NULL,
                          0,
                          AcceptThread,
                          (LPVOID)0,
                          0,
                          NULL);
   if (hThread == NULL) {
      printf(TEXT("CreateThread() failed: %d\n   "), GetLastError());
      dwReturn = FALSE;
      goto c0;
   }
   // The keeps the service from exiting.
   while ( p->m_bRunning ) {
     Sleep(100);
   }
   //WaitForSingleObject (p->m_hEVENT_TerminateServiceThread, INFINITE);

   // Terminate the Listening thread.
   GetExitCodeThread( hThread, &dwExitCode);
   //ExitThread(dwExitCode);
   TerminateThread(hThread, dwExitCode);
   c0:
   return dwReturn;
}



DWORD WINAPI
CService::
AcceptThread(LPVOID lpParam)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    7/6/2001

    Routine Description:
       Worker Thread.
       
    Arguments:
            
   Return Value:

--*/
{
   
   UNREFERENCED_PARAMETER(lpParam);
    CService* p = m_pCServiceThis;

   SOCKET sAccept;
   for (;;){
      if ( INVALID_SOCKET == (sAccept = p->Accept())) {
         printf(TEXT("INVALID_SOCKET on calling accept....\n"));
      } else
         p->StartThread( ClientThread,(LPVOID)sAccept);
   }
}




DWORD WINAPI
CService::
ClientThread(LPVOID lpParam)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    6/25/2001

    Routine Description:
       Worker Thread.
       
    Arguments:
        A variable void pointer holding a socket.
    Return Value:

--*/

{

   SOCKET sAccept = (SOCKET)lpParam;

   CNetWorkConnection* c= new CNetWorkConnection( sAccept );
   CService* p = m_pCServiceThis;
   

   DATA_PACKET InBuffer;
   DATA_PACKET OutBuffer;
   ZeroMemory(&InBuffer, sizeof(InBuffer));
   if ( SOCKET_ERROR == c->RecvData(&InBuffer, sizeof(InBuffer)))
      goto cleanup;
   
   ZeroMemory(&OutBuffer, sizeof(OutBuffer));
   p->DecryptOnlineKey(InBuffer.byteData, OutBuffer.byteData);
   
   sprintf(OutBuffer.szMessage, "Decrypted Online Key Only" );
   if ( SOCKET_ERROR == c->SendData(&OutBuffer, sizeof(OutBuffer)))
      goto cleanup;

   cleanup:
   delete c;
   printf("DONE Sending.\n Waiting for next connection\n" );
   return 0;
}




BOOL
CService::
InitService()
// Initializes the service by starting its thread
{

   LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_INSTALLED,"Initializing CSP Service","","");

    // Start the service's thread
    m_hThread = CreateThread(NULL,
                             0,
                             (LPTHREAD_START_ROUTINE)ServiceThread,
                             (LPVOID)0,
                             0,
                             NULL);
    if (m_hThread==0)
        return FALSE;
    else {
        m_bRunning = TRUE;
        return TRUE;
    }
}





BOOL
CService::
SendStatusToSCM ( DWORD dwCurrentState,
                  DWORD dwWin32ExitCode,
                  DWORD dwServiceSpecificExitCode,
                  DWORD dwCheckPoint,
                  DWORD dwWaitHint)
/*
   This function consolidates the activities of
   updating the service status with
   SetServiceStatus
*/

{
   BOOL success;
   SERVICE_STATUS serviceStatus;

   ZeroMemory (&serviceStatus, sizeof(serviceStatus));


   // Fill in all of the SERVICE_STATUS fields
   serviceStatus.dwServiceType  = SERVICE_WIN32_OWN_PROCESS;
   serviceStatus.dwCurrentState = dwCurrentState;
   
   // If in the process of something, then accept
   // no control events, else accept anything
   if (dwCurrentState == SERVICE_START_PENDING)
      serviceStatus.dwControlsAccepted = 0;
   else
      serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                         SERVICE_ACCEPT_PAUSE_CONTINUE |
                                         SERVICE_ACCEPT_SHUTDOWN;

   // if a specific exit code is defines, set up
   // the win32 exit code properly
   if (dwServiceSpecificExitCode == 0)
      serviceStatus.dwWin32ExitCode = dwWin32ExitCode;
   else
      serviceStatus.dwWin32ExitCode =  ERROR_SERVICE_SPECIFIC_ERROR;

   
   serviceStatus.dwServiceSpecificExitCode = dwServiceSpecificExitCode;
   serviceStatus.dwCheckPoint = dwCheckPoint;
   serviceStatus.dwWaitHint   = dwWaitHint;

   
   // Pass the status record to the SCM
   success = SetServiceStatus ( m_ServiceStatusHandle,&serviceStatus);
   if (!success)
      StopService();
   return success;
}



VOID
CService::
ServiceCtrlHandler (DWORD controlCode)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    7/31/2000

   Routine Description:
       This handles events received from the service control manager.
   Arguments:
       Standard control codes for a service of:
         SERVICE_CONTROL_STOP;
         SERVICE_CONTROL_PAUSE;
         SERVICE_CONTROL_CONTINUE;
         SERVICE_CONTROL_INTERROGATE;
         SERVICE_CONTROL_SHUTDOWN;
         
   Return Value:
       NONE
--*/
{

    DWORD  currentState = 0;
    BOOL success;

    CService* p = m_pCServiceThis;

    switch (controlCode) {
       // Stop the service
       case SERVICE_CONTROL_STOP:
           currentState = SERVICE_STOP_PENDING;
           success = p->SendStatusToSCM( SERVICE_STOP_PENDING, NO_ERROR, 0, 1, 1000);
           p->Terminate( NO_ERROR  );
           return ;
      
           // Pause the service
       case SERVICE_CONTROL_PAUSE:
           if (p->m_bRunning && 
               (p->m_bPause == TRUE)) {
               success = p->SendStatusToSCM(SERVICE_PAUSE_PENDING,NO_ERROR, 0, 1, 1000);
               p->PauseService();
               currentState = SERVICE_PAUSED;
           }
           break;
           // Resume from a pause
       case SERVICE_CONTROL_CONTINUE:
           if (p->m_bRunning && p->m_bPause) {
      
               success = p->SendStatusToSCM( SERVICE_CONTINUE_PENDING,NO_ERROR, 0, 1, 1000);
               p->ResumeService();
               currentState = SERVICE_RUNNING;
           }
           break;
           // Update current status
       case SERVICE_CONTROL_INTERROGATE:
           break;
      
       case SERVICE_CONTROL_SHUTDOWN:
           // Do nothing on shutdown
           return ;
       default:
           break;
    }
    
    p->SendStatusToSCM(currentState, NO_ERROR, 0, 0, 0);
}


VOID
CService::
Terminate(DWORD error)
/*++
   
   Handle an error from ServiceMain by cleaning up
   and telling SCM that the service didn't start.

--*/ 

{
   
   // if terminateEvent has been created, close it.
   if (m_hEVENT_TerminateServiceMain)
      CloseHandle(m_hEVENT_TerminateServiceMain);
   
   if (m_hEVENT_TerminateServiceThread)
      CloseHandle(m_hEVENT_TerminateServiceThread);
    
   // Send a message to the scm to tell about stoppage
   if (m_ServiceStatusHandle)
      SendStatusToSCM(SERVICE_STOPPED, error,0, 0, 0);

   // If the thread has started kill it off
   if (m_hThread)
      CloseHandle(m_hThread);
   // Do not need to close serviceStatusHandle
   
}



BOOL 
CService::
ParseStandardArgs( VOID )
{


   if (FALSE != _tcsstr(GetCommandLine(), TEXT("-install")  )) {

      // if -install specified then we'll register the service.
      TCHAR szServiceExe[ MAX_PATH ];
      GetModuleFileName( NULL, szServiceExe, sizeof(szServiceExe)/sizeof(szServiceExe[0]));         
      /*
      LPTSTR p;
      p = _tcsrchr(szServiceExe,TEXT('\\'));
      if (NULL == p) {
        return FALSE;
      }
      *p = TEXT('\0');
      _tcscat( szServiceExe, TEXT("\\s.exe"));
      */
      InstallService(m_szServiceName , m_szSCMDisplayName, szServiceExe);
      return TRUE;
   } else if (FALSE !=_tcsstr(GetCommandLine(), TEXT("-remove")  )) {
      
      RemoveService( m_szServiceName );
      
      return TRUE;
   } else if (FALSE !=_tcsstr(GetCommandLine(), TEXT("-removeall")  )) {
      
      for (INT o = 1; o < 10; o++) {
         char sz[100];
         _stprintf(sz,TEXT("2kNCipher%d_Service"), o);
         RemoveService( sz );
      }
      return TRUE;
   
   } else if (FALSE !=_tcsstr(GetCommandLine(), TEXT("-console")  )) {
      InitNetWork();
      InitCrypto();
      TEST();
      return TRUE;
   } 
   else {
      // default is to start as a service.
      SERVICE_TABLE_ENTRY st[] ={
         { m_szServiceName , ServiceMain},
         { NULL, NULL}
      };
      
      InitNetWork();
      InitCrypto();
      StartServiceCtrlDispatcher(st);
   }
   return FALSE;
}




// static member function (callback)

VOID
CService::
ServiceMain(DWORD argc, LPTSTR *argv)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    8/2/2000

   Routine Description:
         ServiceMain is called when the SCM wants to start the service. 
         When it returns, the service has stopped. It therefore waits 
         on an event just before the end of the function, and that event
         gets set when it is time to stop. It also returns on any error 
         because the service cannot start if there is an error.
 
   Arguments:
       Normal arguments like Main would have.
   Return Value:
       NONE
--*/
{

   UNREFERENCED_PARAMETER(argc);
   UNREFERENCED_PARAMETER(argv);
   // Get a pointer to the C++ object
   // Since this is static , its basically a global local variable. Wallyho
   CService* p = m_pCServiceThis;
   
   BOOL success;
   // Call Registration function
   p->m_ServiceStatusHandle = 
   RegisterServiceCtrlHandler( m_szSCMDisplayName, ServiceCtrlHandler);

   if (!p->m_ServiceStatusHandle) 
      return;

   // Notify SCM of progress
   success = p->SendStatusToSCM( SERVICE_START_PENDING, NO_ERROR, 0, 1, 5000);
   if (!success)
      return;

   // create the Service Main Termination event
   p->m_hEVENT_TerminateServiceMain = CreateEvent (NULL, TRUE, FALSE, NULL);
   if (!p->m_hEVENT_TerminateServiceMain)
      return;


   // create the Service Thread Termination event
   p->m_hEVENT_TerminateServiceThread = CreateEvent (NULL, TRUE, FALSE, NULL);
   if (!p->m_hEVENT_TerminateServiceThread)
      return;

   // Notify SCM of progress
   success = p->SendStatusToSCM( SERVICE_START_PENDING, NO_ERROR, 0, 3, 5000);
   if (!success)
      return;

   // Start the service itself
   success = p->InitService();
   if (!success)
      return;

   // The service is now running. Notify SCM of progress
   success = p->SendStatusToSCM(SERVICE_RUNNING,NO_ERROR, 0, 0, 0);
   if (!success)
      return;

   
   // Wait for stop signal, and then terminate
   WaitForSingleObject (p->m_hEVENT_TerminateServiceMain, INFINITE);
   SetLastError(0);
}



BOOL
CService::
InstallService( LPTSTR szServiceNameSCM,
                LPTSTR szServiceLabel,
                LPTSTR szExeFullPath)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    6/15/2001

    Routine Description:
        This installs a service 
    Arguments:
       szServiceNameSCM is the name used internally by the SCM\n";
       szServiceLabel is the name that appears in the Services applet\n";
       szExeFullPath ie. eg "c:\winnt\xxx.exe"
    Return Value:
       NONE
--*/
{

   BOOL b = TRUE;
   DWORD dwData;
   SC_HANDLE newScm;
   char szKey[256];
   HKEY hKey = NULL;

   printf(TEXT("Installing a new service\n"));
   // open a connection to the SCM
   SC_HANDLE scm = OpenSCManager(0, 0, SC_MANAGER_CREATE_SERVICE);

   if (!scm)
      printf(TEXT("In OpenScManager: Error %lu\n"),GetLastError());

   newScm = CreateService( scm,
                           szServiceNameSCM,
                           szServiceLabel,
                           SERVICE_ALL_ACCESS,
                           SERVICE_WIN32_OWN_PROCESS,
                           SERVICE_AUTO_START,
                           SERVICE_ERROR_NORMAL,
                           szExeFullPath,
                           NULL,
                           NULL, 
                           NULL, 
                           NULL, 
                           NULL);
   if (!newScm){
      printf(TEXT("Problem installing Service: Error %lu.\n"),GetLastError());
      b = FALSE;
      goto c0;
   }
   else
      printf(TEXT("Finished installing a new service.\n"));




   // make registry entries to support logging messages
   // Add the source name as a subkey under the Application
   // key in the EventLog service portion of the registry.
   strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
   strcat(szKey, szServiceNameSCM);
   if (RegCreateKey(HKEY_LOCAL_MACHINE, szKey, &hKey) != ERROR_SUCCESS) {
      b = FALSE;
      goto c1;
   }

   // Add the Event ID message-file name to the 'EventMessageFile' subkey.
   RegSetValueEx(hKey,
                   "EventMessageFile",
                   0,
                   REG_EXPAND_SZ, 
                   (CONST BYTE*)szExeFullPath,
                   strlen(szExeFullPath) + 1);     
   

   // Set the supported types flags.
   dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
   ::RegSetValueEx(hKey,
                   "TypesSupported",
                   0,
                   REG_DWORD,
                   (CONST BYTE*)&dwData,
                    sizeof(DWORD));
   ::RegCloseKey(hKey);

   //LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_INSTALLED, m_szServiceName);

   // clean up
  c1:
   CloseServiceHandle(newScm);
  c0: 
   CloseServiceHandle(scm);
   return b;
}


BOOL
CService::
RemoveService( IN LPTSTR szServiceNameSCM)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    7/27/2000

   Routine Description:
       This function removes the specified service from the machine.
       
   Arguments:
       The service to remove's internal name.

   Return Value:
       TRUE on success
       FALSE on failure
--*/

{
   
   
   SC_HANDLE service, scm;
   BOOL success;
   SERVICE_STATUS status;
   BOOL b = TRUE;
   char szKey[256];



   printf(TEXT("Removing the %s service.\n"), szServiceNameSCM);
   // open a connection to the SCM
   scm = OpenSCManager(NULL, 
                       NULL,
                       SC_MANAGER_ALL_ACCESS);
   if (!scm) {
      printf(TEXT("In OpenScManager: Error %lu\n"),GetLastError());
      b= FALSE;
      goto c0;
   }

   // Get the service's handle
   service = OpenService(scm,
                         szServiceNameSCM,
                         SERVICE_ALL_ACCESS);
   
   if (!service) {
      printf(TEXT("In OpenService: Error %lu\n"),GetLastError());
      b= FALSE;
      goto c1;
   }

   // Stop the service if necessary
   success = QueryServiceStatus(service, &status);
   if (!success) {
      printf(TEXT("In QueryServiceStatus: Error %lu\n"),GetLastError());
      b= FALSE;
      goto c1;
   }

   if (status.dwCurrentState != SERVICE_STOPPED) {
      printf(TEXT("Stopping Service...\n"));
      success = ControlService(service,
                               SERVICE_CONTROL_STOP,
                               &status);
      if (!success) {
         printf(TEXT("In ControlService: Error %lu\n"),GetLastError());
         b= FALSE;
         goto c1;
      }
      Sleep(500);
   }

   // Remove the service
   success = DeleteService(service);
   if (success)
      printf(TEXT("Finished Deleting Service.\n"));
   else {
      printf(TEXT("Problem Deleting Service: Error %lu.\n"),GetLastError());
      if ( ERROR_SERVICE_MARKED_FOR_DELETE == GetLastError()) {
         printf(TEXT(" This service is already marked for delete.\n"));
      }
      b= FALSE;
      goto c1;
   }


   // remove registry entries to support logging messages
   // The source name as a subkey under the Application
   // key in the EventLog service portion of the registry.
   
   strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
   strcat(szKey, szServiceNameSCM);
   if (RegDeleteKey(HKEY_LOCAL_MACHINE, szKey) != ERROR_SUCCESS) {
      b = FALSE;
      goto c1;
   }

   // EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
   //LogEvent(EVENTLOG_INFORMATION_TYPE, 1, m_szServiceName);

   // clean up
  c1:
   CloseServiceHandle(service);
  c0: 
   CloseServiceHandle(scm);
   return b;
}


void 
CService::
LogEvent( WORD wType, DWORD dwID,
         const char* pszS1,
         const char* pszS2,
         const char* pszS3)
{
    const char* ps[3];
    ps[0] = pszS1;
    ps[1] = pszS2;
    ps[2] = pszS3;

    WORD iStr = 0;
    for (int i = 0; i < 3; i++) {
        if (ps[i] != NULL) 
            iStr++;
    }
        
    // Check the event source has been registered and if
    // not then register it now
    if (!m_hEventSource) {
        m_hEventSource = RegisterEventSource(NULL, // local machine
                                             m_szServiceName); // source name
    }
    if (m_hEventSource) {
        ::ReportEvent(m_hEventSource,
                      wType,
                      0,
                      dwID,
                      NULL, // sid
                      iStr,
                      0,
                      ps,
                      NULL);
    }
}

VOID
CService::
StopService(){ 
   
   m_bRunning = FALSE;
   SetEvent(m_hEVENT_TerminateServiceThread); 
   SetEvent(m_hEVENT_TerminateServiceMain); 
}


/********************************************************

 BOOL
 CService::
 SetIcon(HICON hicon, LPCSTR lpTip)
 {

    UINT msg;
    m_nid.uFlags = 0;
    // Set the icon
    if (hicon) {
       // Add or replace icon in system tray
       msg = m_nid.hIcon ? NIM_MODIFY : NIM_ADD;
       m_nid.hIcon = hicon;
       m_nid.uFlags |= NIF_ICON;
    } else { // remove icon from tray
       if (m_nid.hIcon==NULL)
          return TRUE;  // already deleted
       msg = NIM_DELETE;
    }


    // Use the tip, if any
    if (lpTip)
       strncpy(m_nid.szTip, lpTip, sizeof(m_nid.szTip));
    if (m_nid.szTip[0])
       m_nid.uFlags |= NIF_TIP;
    // Use callback if any
    if (m_nid.uCallbackMessage && m_nid.hWnd)
       m_nid.uFlags |= NIF_MESSAGE;
    // Do it
    BOOL bRet = Shell_NotifyIcon(msg, &m_nid);
    if (msg==NIM_DELETE || !bRet)
       m_nid.hIcon = NULL; // failed
    return bRet;
 }

********************************************************/


/***********************************************************************************************


 // NTService.cpp
 //
 // Implementation of CNTService

 #include <windows.h>
 #include <stdio.h>
 #include "NTService.h"



 // static variables
 CNTService* CNTService::m_pThis = NULL;

 CNTService::CNTService(const char* szServiceName)
 {
     // copy the address of the current object so we can access it from
     // the static member callback functions.
     // WARNING: This limits the application to only one CNTService object.
     m_pThis = this;

     // Set the default service name and version
     strncpy(m_szServiceName, szServiceName, sizeof(m_szServiceName)-1);
     m_iMajorVersion = 1;
     m_iMinorVersion = 0;
     m_hEventSource = NULL;

     // set up the initial service status
     m_hServiceStatus = NULL;
     m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
     m_Status.dwCurrentState = SERVICE_STOPPED;
     m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
     m_Status.dwWin32ExitCode = 0;
     m_Status.dwServiceSpecificExitCode = 0;
     m_Status.dwCheckPoint = 0;
     m_Status.dwWaitHint = 0;
     m_bIsRunning = FALSE;
 }

 CNTService::~CNTService()
 {
     DebugMsg("CNTService::~CNTService()");
     if (m_hEventSource) {
         ::DeregisterEventSource(m_hEventSource);
     }
 }

 ////////////////////////////////////////////////////////////////////////////////////////
 // Default command line argument parsing

 // Returns TRUE if it found an arg it recognised, FALSE if not
 // Note: processing some arguments causes output to stdout to be generated.
 BOOL CNTService::ParseStandardArgs(int argc, char* argv[])
 {
     // See if we have any command line args we recognise
     if (argc <= 1) return FALSE;

     if (_stricmp(argv[1], "-v") == 0) {

         // Spit out version info
         printf("%s Version %d.%d\n",
                m_szServiceName, m_iMajorVersion, m_iMinorVersion);
         printf("The service is %s installed\n",
                IsInstalled() ? "currently" : "not");
         return TRUE; // say we processed the argument

     } else if (_stricmp(argv[1], "-i") == 0) {

         // Request to install.
         if (IsInstalled()) {
             printf("%s is already installed\n", m_szServiceName);
         } else {
             // Try and install the copy that's running
             if (Install()) {
                 printf("%s installed\n", m_szServiceName);
             } else {
                 printf("%s failed to install. Error %d\n", m_szServiceName, GetLastError());
             }
         }
         return TRUE; // say we processed the argument

     } else if (_stricmp(argv[1], "-u") == 0) {

         // Request to uninstall.
         if (!IsInstalled()) {
             printf("%s is not installed\n", m_szServiceName);
         } else {
             // Try and remove the copy that's installed
             if (Uninstall()) {
                 // Get the executable file path
                 char szFilePath[_MAX_PATH];
                 ::GetModuleFileName(NULL, szFilePath, sizeof(szFilePath));
                 printf("%s removed. (You must delete the file (%s) yourself.)\n",
                        m_szServiceName, szFilePath);
             } else {
                 printf("Could not remove %s. Error %d\n", m_szServiceName, GetLastError());
             }
         }
         return TRUE; // say we processed the argument

     }

     // Don't recognise the args
     return FALSE;
 }

 ////////////////////////////////////////////////////////////////////////////////////////
 // Install/uninstall routines

 // Test if the service is currently installed
 BOOL CNTService::IsInstalled()
 {
     BOOL bResult = FALSE;

     // Open the Service Control Manager
     SC_HANDLE hSCM = ::OpenSCManager(NULL, // local machine
                                      NULL, // ServicesActive database
                                      SC_MANAGER_ALL_ACCESS); // full access
     if (hSCM) {

         // Try to open the service
         SC_HANDLE hService = ::OpenService(hSCM,
                                            m_szServiceName,
                                            SERVICE_QUERY_CONFIG);
         if (hService) {
             bResult = TRUE;
             ::CloseServiceHandle(hService);
         }

         ::CloseServiceHandle(hSCM);
     }

     return bResult;
 }

 BOOL CNTService::Install()
 {
     // Open the Service Control Manager
     SC_HANDLE hSCM = ::OpenSCManager(NULL, // local machine
                                      NULL, // ServicesActive database
                                      SC_MANAGER_ALL_ACCESS); // full access
     if (!hSCM) return FALSE;

     // Get the executable file path
     char szFilePath[_MAX_PATH];
     ::GetModuleFileName(NULL, szFilePath, sizeof(szFilePath));

     // Create the service
     SC_HANDLE hService = ::CreateService(hSCM,
                                          m_szServiceName,
                                          m_szServiceName,
                                          SERVICE_ALL_ACCESS,
                                          SERVICE_WIN32_OWN_PROCESS,
                                          SERVICE_DEMAND_START,        // start condition
                                          SERVICE_ERROR_NORMAL,
                                          szFilePath,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL);
     if (!hService) {
         ::CloseServiceHandle(hSCM);
         return FALSE;
     }

     // make registry entries to support logging messages
     // Add the source name as a subkey under the Application
     // key in the EventLog service portion of the registry.
     char szKey[256];
     HKEY hKey = NULL;
     strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
     strcat(szKey, m_szServiceName);
     if (::RegCreateKey(HKEY_LOCAL_MACHINE, szKey, &hKey) != ERROR_SUCCESS) {
         ::CloseServiceHandle(hService);
         ::CloseServiceHandle(hSCM);
         return FALSE;
     }

     // Add the Event ID message-file name to the 'EventMessageFile' subkey.
     ::RegSetValueEx(hKey,
                     "EventMessageFile",
                     0,
                     REG_EXPAND_SZ,
                     (CONST BYTE*)szFilePath,
                     strlen(szFilePath) + 1);

     // Set the supported types flags.
     DWORD dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
     ::RegSetValueEx(hKey,
                     "TypesSupported",
                     0,
                     REG_DWORD,
                     (CONST BYTE*)&dwData,
                      sizeof(DWORD));
     ::RegCloseKey(hKey);

     LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_INSTALLED, m_szServiceName);

     // tidy up
     ::CloseServiceHandle(hService);
     ::CloseServiceHandle(hSCM);
     return TRUE;
 }

 BOOL CNTService::Uninstall()
 {
     // Open the Service Control Manager
     SC_HANDLE hSCM = ::OpenSCManager(NULL, // local machine
                                      NULL, // ServicesActive database
                                      SC_MANAGER_ALL_ACCESS); // full access
     if (!hSCM) return FALSE;

     BOOL bResult = FALSE;
     SC_HANDLE hService = ::OpenService(hSCM,
                                        m_szServiceName,
                                        DELETE);
     if (hService) {
         if (::DeleteService(hService)) {
             LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_REMOVED, m_szServiceName);
             bResult = TRUE;
         } else {
             LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_NOTREMOVED, m_szServiceName);
         }
         ::CloseServiceHandle(hService);
     }

     ::CloseServiceHandle(hSCM);
     return bResult;
 }

 ///////////////////////////////////////////////////////////////////////////////////////
 // Logging functions

 // This function makes an entry into the application event log
 void CNTService::LogEvent(WORD wType, DWORD dwID,
                           const char* pszS1,
                           const char* pszS2,
                           const char* pszS3)
 {
     const char* ps[3];
     ps[0] = pszS1;
     ps[1] = pszS2;
     ps[2] = pszS3;

     int iStr = 0;
     for (int i = 0; i < 3; i++) {
         if (ps[i] != NULL) iStr++;
     }

     // Check the event source has been registered and if
     // not then register it now
     if (!m_hEventSource) {
         m_hEventSource = ::RegisterEventSource(NULL,  // local machine
                                                m_szServiceName); // source name
     }

     if (m_hEventSource) {
         ::ReportEvent(m_hEventSource,
                       wType,
                       0,
                       dwID,
                       NULL, // sid
                       iStr,
                       0,
                       ps,
                       NULL);
     }
 }

 //////////////////////////////////////////////////////////////////////////////////////////////
 // Service startup and registration

 BOOL CNTService::StartService()
 {
     SERVICE_TABLE_ENTRY st[] = {
         {m_szServiceName, ServiceMain},
         {NULL, NULL}
     };

     DebugMsg("Calling StartServiceCtrlDispatcher()");
     BOOL b = ::StartServiceCtrlDispatcher(st);
     DebugMsg("Returned from StartServiceCtrlDispatcher()");
     return b;
 }

 // static member function (callback)
 void CNTService::ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
 {
     // Get a pointer to the C++ object
     CNTService* pService = m_pThis;

     pService->DebugMsg("Entering CNTService::ServiceMain()");
     // Register the control request handler
     pService->m_Status.dwCurrentState = SERVICE_START_PENDING;
     pService->m_hServiceStatus = RegisterServiceCtrlHandler(pService->m_szServiceName,
                                                            Handler);
     if (pService->m_hServiceStatus == NULL) {
         pService->LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_CTRLHANDLERNOTINSTALLED);
         return;
     }

     // Start the initialisation
     if (pService->Initialize()) {

         // Do the real work.
         // When the Run function returns, the service has stopped.
         pService->m_bIsRunning = TRUE;
         pService->m_Status.dwWin32ExitCode = 0;
         pService->m_Status.dwCheckPoint = 0;
         pService->m_Status.dwWaitHint = 0;
         pService->Run();
     }

     // Tell the service manager we are stopped
     pService->SetStatus(SERVICE_STOPPED);
     pService->DebugMsg("Leaving CNTService::ServiceMain()");
 }


 void CNTService::
 SetStatus(DWORD dwState)
 // status functions
 {
     DebugMsg("CNTService::SetStatus(%lu, %lu)", m_hServiceStatus, dwState);
     m_Status.dwCurrentState = dwState;
     ::SetServiceStatus(m_hServiceStatus, &m_Status);
 }


 BOOL CNTService::
 Initialize()
 // Service initialization
 {
     DebugMsg("Entering CNTService::Initialize()");

     // Start the initialization
     SetStatus(SERVICE_START_PENDING);

     // Perform the actual initialization
     BOOL bResult = OnInit();

     // Set final state
     m_Status.dwWin32ExitCode = GetLastError();
     m_Status.dwCheckPoint = 0;
     m_Status.dwWaitHint = 0;
     if (!bResult) {
         LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_FAILEDINIT);
         SetStatus(SERVICE_STOPPED);
         return FALSE;
     }

     LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_STARTED);
     SetStatus(SERVICE_RUNNING);

     DebugMsg("Leaving CNTService::Initialize()");
     return TRUE;
 }


 void CNTService::
 Run()
 // main function to do the real work of the service

 // This function performs the main work of the service.
 // When this function returns the service has stopped.
 {
     DebugMsg("Entering CNTService::Run()");

     while (m_bIsRunning) {
         DebugMsg("Sleeping...");
         Sleep(5000);
     }

     // nothing more to do
     DebugMsg("Leaving CNTService::Run()");
 }

 //////////////////////////////////////////////////////////////////////////////////////
 // Control request handlers

 // static member function (callback) to handle commands from the
 // service control manager
 void CNTService::
 Handler(DWORD dwOpcode)
 {
     // Get a pointer to the object
     CNTService* pService = m_pThis;

     pService->DebugMsg("CNTService::Handler(%lu)", dwOpcode);
     switch (dwOpcode) {
     case SERVICE_CONTROL_STOP: // 1
         pService->SetStatus(SERVICE_STOP_PENDING);
         pService->OnStop();
         pService->m_bIsRunning = FALSE;
         pService->LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_STOPPED);
         break;

     case SERVICE_CONTROL_PAUSE: // 2
         pService->OnPause();
         break;

     case SERVICE_CONTROL_CONTINUE: // 3
         pService->OnContinue();
         break;

     case SERVICE_CONTROL_INTERROGATE: // 4
         pService->OnInterrogate();
         break;

     case SERVICE_CONTROL_SHUTDOWN: // 5
         pService->OnShutdown();
         break;

     default:
         if (dwOpcode >= SERVICE_CONTROL_USER) {
             if (!pService->OnUserControl(dwOpcode)) {
                 pService->LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_BADREQUEST);
             }
         } else {
             pService->LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_BADREQUEST);
         }
         break;
     }

     // Report current status
     pService->DebugMsg("Updating status (%lu, %lu)",
                        pService->m_hServiceStatus,
                        pService->m_Status.dwCurrentState);
     ::SetServiceStatus(pService->m_hServiceStatus, &pService->m_Status);
 }

 // Called when the service is first initialized
 BOOL CNTService::OnInit()
 {
     DebugMsg("CNTService::OnInit()");
     return TRUE;
 }

 void CNTService::
 OnStop()
 // Called when the service control manager wants to stop the service
 {
     DebugMsg("CNTService::OnStop()");
 }

 void CNTService::
 OnInterrogate()
 // called when the service is interrogated
 {
     DebugMsg("CNTService::OnInterrogate()");
 }

 // called when the service is paused
 void CNTService::
 OnPause()
 {
     DebugMsg("CNTService::OnPause()");
 }

 // called when the service is continued
 void CNTService::
 OnContinue()
 {
     DebugMsg("CNTService::OnContinue()");
 }

 // called when the service is shut down
 void CNTService::
 OnShutdown()
 {
     DebugMsg("CNTService::OnShutdown()");
 }

 // called when the service gets a user control message
 BOOL CNTService::
 OnUserControl(DWORD dwOpcode)
 {
     DebugMsg("CNTService::OnUserControl(%8.8lXH)", dwOpcode);
     return FALSE; // say not handled
 }



 void CNTService::
 DebugMsg(const char* pszFormat, ...)
 {
     char buf[1024];
     sprintf(buf, "[%s](%lu): ", m_szServiceName, GetCurrentThreadId());
     va_list arglist;
     va_start(arglist, pszFormat);
     vsprintf(&buf[strlen(buf)], pszFormat, arglist);
     va_end(arglist);
     strcat(buf, "\n");
     OutputDebugString(buf);
 }

***********************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\CNetWork.cpp ===
#include "CNetWork.h"


CNetWork::
CNetWork()
{                                                  
}

VOID
CNetWork::
InitNetWork( VOID)
{
   WSADATA       wsa;
   SOCKADDER_IN local;
   
   m_dwAcceptIndex = 0;
   if ( -1 == WSAStartup( MAKEWORD(2,2), &wsa) ) {
     printf(TEXT("WSAStartup  failed: %d"), WSAGetLastError());
   }
   
   // Create our listening socket
   sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sClient == SOCKET_ERROR) {
       printf(TEXT("socket() failed: %d"), WSAGetLastError());
   }
   local.sin_addr.s_addr = htonl(INADDR_ANY);
   local.sin_family = AF_INET;
   local.sin_port = htons( COMMUNICATION_SERVICE_PORT );

   if (bind(sClient, (struct sockaddr *)&local, sizeof(local)) == SOCKET_ERROR) {
      printf(TEXT("bind() failed: %d"), WSAGetLastError());
   }
   printf(TEXT("Calling Listen.\n"));
   listen(sClient, 10);
}




CNetWork::~CNetWork()
{
   closesocket(sClient);
   WSACleanup();
}



SOCKET 
CNetWork::
Accept (struct sockaddr FAR *addr,
        int FAR *addrlen )
{
   return accept(sClient,addr, addrlen);
}



SOCKET 
CNetWork::
Accept ( VOID )
{
   
   SOCKET         AcceptReturned;
   struct         sockaddr_in  client;
   int            iAddrSize;
   iAddrSize      = sizeof(client);
   AcceptReturned = accept( sClient,(struct sockaddr *)&client, &iAddrSize);
   

   if (AcceptReturned == INVALID_SOCKET) {
      printf(TEXT("ACCEPT() failed: %d\n"), WSAGetLastError());
   } else {
      printf(TEXT("ACCEPT() succeeded. Session[%lu] Client:%S:%d\n"), 
             m_dwAcceptIndex, 
             inet_ntoa(client.sin_addr), 
             ntohs(client.sin_port) );
      ++m_dwAcceptIndex;
   }
   return AcceptReturned;
}


BOOL
CNetWork::
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
        This routine creates a thread.
    Arguments:
        The Thread Function address.
        The Paremer to the function.
    Return Value:

--*/

{
   HANDLE   hThread;
   hThread = CreateThread(NULL,
                          0,
                          lpStartAddress,
                          (LPVOID)Param,
                          0,
                          NULL);
   if (hThread == NULL) {
      printf(TEXT("CreateThread() failed: %d\n   "), GetLastError());
      return FALSE;
   }
   CloseHandle(hThread);
   return TRUE;
}



CNetWorkConnection::
~CNetWorkConnection() {
   
   closesocket(sConnection);

}

INT 
CNetWorkConnection::
SendData( LPVOID pvData, INT iSize)
{

   INT ret;
   PDATA_PACKET p =(PDATA_PACKET)pvData;
   // Send the data 
   ret = send(sConnection,(const char*) pvData, iSize, 0);
   if (ret == SOCKET_ERROR) {
      printf(TEXT("  SEND failed: %d\n"), WSAGetLastError());
   }else{
      printf(TEXT("  SEND [%d bytes]\n"), ret);
      printf(TEXT("  SEND MSG: [SENT]: %s\n"), p->szMessage);
   }
   return ret;
}


INT 
CNetWorkConnection::
RecvData( LPVOID pvData, INT iSize)
{
   
   INT ret;
   PDATA_PACKET p = (PDATA_PACKET)pvData;
   ret = recv( sConnection,(char*)pvData, iSize, 0);

   if (ret == SOCKET_ERROR) {
      printf(TEXT("  RECV failed: %d\n"), WSAGetLastError());
   }else{
      printf(TEXT("  RECV [%d bytes]\n"), ret );
      printf(TEXT("  RECV MSG: [RECEIVED]: %s\n"), p->szMessage);
   }
   return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\2kNCipherService\CService.h ===
/*++
Copyright (c) 2000  Microsoft Corporation

Filename:
      Serivce.h       
Abstract:
      This the class for the service.
Author:

       Wally Ho (wallyho) 6/15/2001

Revision History:
   6/15/2001         Created

--*/



#ifndef SERVICE_H
#define SERVICE_H
#include <windows.h>
#include "CNetWork.h"
#include "CCrypto.h"


    CONST LPTSTR m_szSCMDisplayName = TEXT("2kNCipher Service");
    CONST LPTSTR m_szServiceName    = TEXT("2kNCipher_Service");
 

class CService: public CNetWork, public CCrypto{
   
private:
   
   HANDLE m_hThread;
   BOOL m_bPause;
   BOOL m_bRunning;
   HANDLE m_hEVENT_TerminateServiceMain;
   HANDLE m_hEVENT_TerminateServiceThread;
   
   HANDLE m_hEventSource;
   SERVICE_STATUS  m_ServiceStatus;
   SERVICE_STATUS_HANDLE m_ServiceStatusHandle;


public:


   BOOL RemoveService(LPTSTR szServiceNameSCM);
   BOOL InstallService(LPTSTR szServiceNameSCM,
                       LPTSTR szServiceLabel,
                       LPTSTR szExeFullPath);
   static void WINAPI  ServiceMain(DWORD argc, LPTSTR *argv);
   static void WINAPI  ServiceCtrlHandler (DWORD controlCode);
   static DWORD WINAPI ServiceThread (LPDWORD param);
   static DWORD WINAPI ClientThread (LPVOID lpParam);
   static DWORD WINAPI AcceptThread(LPVOID lpParam);

   VOID TEST(){
      ServiceThread(0);
   }

   BOOL InitService();
   VOID ResumeService() { m_bPause = FALSE;   ResumeThread(m_hThread); }
   VOID PauseService()  { m_bPause = TRUE;    SuspendThread(m_hThread); }
   VOID StopService();

   BOOL SendStatusToSCM ( DWORD dwCurrentState,
                          DWORD dwWin32ExitCode, 
                          DWORD dwServiceSpecificExitCode,
                          DWORD dwCheckPoint,
                          DWORD dwWaitHint);
   VOID Terminate(DWORD error);
   BOOL ParseStandardArgs( VOID );

   void  LogEvent(WORD wType, DWORD dwID,
               const char* pszS1,
               const char* pszS2,
               const char* pszS3);

   static CService* m_pCServiceThis;

   ~CService(){}
   CService(){
       
       m_hThread = NULL;
       m_bPause   = FALSE;
       m_bRunning = TRUE;
       m_hEVENT_TerminateServiceMain = NULL;
       m_hEVENT_TerminateServiceThread = NULL;
       m_hEventSource = NULL;
       m_pCServiceThis = this;
   }
};



//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EVMSG_INSTALLED
//
// MessageText:
//
//  The %1 service was installed.
//
#define EVMSG_INSTALLED                  0x00000064L

//
// MessageId: EVMSG_REMOVED
//
// MessageText:
//
//  The %1 service was removed.
//
#define EVMSG_REMOVED                    0x00000065L

//
// MessageId: EVMSG_NOTREMOVED
//
// MessageText:
//
//  The %1 service could not be removed.
//
#define EVMSG_NOTREMOVED                 0x00000066L

//
// MessageId: EVMSG_CTRLHANDLERNOTINSTALLED
//
// MessageText:
//
//  The control handler could not be installed.
//
#define EVMSG_CTRLHANDLERNOTINSTALLED    0x00000067L

//
// MessageId: EVMSG_FAILEDINIT
//
// MessageText:
//
//  The initialization process failed.
//
#define EVMSG_FAILEDINIT                 0x00000068L

//
// MessageId: EVMSG_STARTED
//
// MessageText:
//
//  The service was started.
//
#define EVMSG_STARTED                    0x00000069L

//
// MessageId: EVMSG_BADREQUEST
//
// MessageText:
//
//  The service received an unsupported request.
//
#define EVMSG_BADREQUEST                 0x0000006AL

//
// MessageId: EVMSG_DEBUG
//
// MessageText:
//
//  Debug: %1
//
#define EVMSG_DEBUG                      0x0000006BL

//
// MessageId: EVMSG_STOPPED
//
// MessageText:
//
//  The service was stopped.
//
#define EVMSG_STOPPED                    0x0000006CL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\ErrorWritePerBox\writeperboxdata.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <ntos.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#include "PerBoxData.h"
#include "cryptkeys.h"

// #define WRITE_EEPROM_IMAGE_TO_FILE 1

// #define DOUBLE_CHECK_EEPROM_KEY 1

// #define TEMP_CODE_FOR_TESTING 1

#define EEPROM_TAIL_PRESERVE_BYTES 2

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}


VOID WriteFileFromMemory(
    LPCSTR lpFileName,
    LPVOID pvFileContents,
    DWORD dwFileSize
    )
{
    HANDLE hFile;
    DWORD dwBytesWrote;

    hFile = CreateFile(lpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "WritePerBoxData: unable to open %s\n", lpFileName);
        return;
    }

    if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) ||
        (dwBytesWrote != dwFileSize)) {
        fprintf(stderr, "WritePerBoxData: cannot write to %s\n", lpFileName);
        return;
    }

    CloseHandle(hFile);
}


VOID ReadFileFromMemory(
    LPCSTR lpFileName,
    LPVOID pvFileContents,
    DWORD* pdwBytesRead
    )
{
    HANDLE hFile;

    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "WritePerBoxData: unable to open %s\n", lpFileName);
        return;
    }

    if (!ReadFile(hFile, pvFileContents, *pdwBytesRead, pdwBytesRead, NULL))
    {
        fprintf(stderr, "WritePerBoxData: cannot read to %s\n", lpFileName);
        return;
    }

    CloseHandle(hFile);
}

HRESULT VerifyEEPROMData();



HRESULT WritePerBoxData(
    IN LPBYTE pbInputBuffer,
    IN DWORD dwInputBufferSize
    )
{

    BOOL bResult;
    HRESULT hr;
    PXBOX_ENCRYPTED_PER_BOX_DATA pData;
    char RecoveryKey[8];
    BYTE inputBuffer[sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) + sizeof(RC4_SHA1_HEADER)];
    
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    BYTE buf2[XBOX_KEY_LENGTH];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    int i;

    /*
    return NTE_BAD_LEN;
    return NTE_BAD_DATA;
    return E_FAIL;
    return NTE_NO_KEY;        
    return E_FAIL;

    hr = VerifyEEPROMData();
    if (FAILED(hr))
    {
        return hr;
    }
    */
    return S_OK;
}


HRESULT VerifyEEPROMData()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // check checksums
    //
    if (XConfigChecksum(factorySettings, sizeof(*factorySettings)) != 0xffffffff ||
        XConfigChecksum(userSettings, sizeof(*userSettings)) != 0xffffffff)
    {
        return NTE_BAD_DATA;
    }

    //
    // Use the EEPROM-KEY to decrypt the EEPROM and verify the checksum
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
#ifdef DOUBLE_CHECK_EEPROM_KEY
        //
        // Double check that a random EEPROM key has really been generated
        //
        ASSERT( XBOX_KEY_LENGTH == TEMP_RAND_KEY_LEN );
        if (RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ) ||
            RtlEqualMemory( TEMP_RAND_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ))
        {
            ASSERT(!"The EEPROM Key has not been randomly generated");
            return NTE_NO_KEY;        
        }
#endif

        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return NTE_BAD_DATA;
        }
    }
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}


BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}


HRESULT VerifyPerBoxData()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    
    //
    // Verify the EEPROM data first
    //
    hr = VerifyEEPROMData();
    if (FAILED(hr))
    {
        return hr;
    }

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
#ifdef DOUBLE_CHECK_EEPROM_KEY
        //
        // Double check that a random EEPROM key has really been generated
        //
        ASSERT( XBOX_KEY_LENGTH == TEMP_RAND_KEY_LEN );
        if (RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ) ||
            RtlEqualMemory( TEMP_RAND_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ))
        {
            ASSERT(!"The EEPROM Key has not been randomly generated");
            return NTE_NO_KEY;        
        }
#endif

        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return NTE_BAD_DATA;
        }
    }

    //
    // Clear the manufacturing region flag
    //
    pEncryptedEEPROMData->GameRegion &= ~XC_GAME_REGION_MANUFACTURING;

    //
    // Double check the hard drive key
    //
    ASSERT( HARD_DRIVE_KEY_LEN == XBOX_KEY_LENGTH );
    if (!RtlEqualMemory( pEncryptedEEPROMData->HardDriveKey, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"HardDriveKey does not match");
        return NTE_BAD_KEY;        
    }
    
    //
    // Encrypt the encrypted part back again
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        //
        // Only Encrypt if it is not a dev kit
        //
        rc4HmacEncrypt(
            (LPBYTE)(&(pEncryptedEEPROMData->EncHeader) + XC_SERVICE_DIGEST_SIZE), // Use original confounder
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    }

    //
    // Save EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    //
    // Check that devkits have zero key
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        ASSERT( RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) );
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
    }
    
    //
    // Compute Key to use to lock hard drive and lock it
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
                         
    HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );    
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}


BOOL HDDisablePassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_DISABLE_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDDisablePassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDDisablePassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}

HRESULT UnlockXboxHardDrive (
    IN LPBYTE pbHardDriveKey,
    IN DWORD dwHardDriveKeySize
    )
{
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    if ( pbHardDriveKey == NULL )
    {
        //
        // Use the key the ROM read from the EEPROM
        //
        pbHardDriveKey = (LPBYTE)(*XboxHDKey);
        dwHardDriveKeySize = XBOX_KEY_LENGTH;
    }
    else
    {
        ASSERT( XBOX_KEY_LENGTH == dwHardDriveKeySize );
        if ( dwHardDriveKeySize != XBOX_KEY_LENGTH )
        {
            return NTE_BAD_LEN;
        }
    }
    
    //
    // Compute Key to use and unlock hard drive
    //
    XcHMAC( pbHardDriveKey, dwHardDriveKeySize,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
                         
    HDDisablePassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );

    return S_OK;
}



HRESULT DecryptDevKitEEPROM()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        return S_OK;
    }

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // if encrypted then decrypt the EEPROM
    //
    if ( !RtlEqualMemory( ZERO_KEY, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH ) )
    {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return NTE_BAD_DATA;
        }

        //
        // Check that Hard drive key is the zero key
        //
        ASSERT( RtlEqualMemory( ZERO_KEY, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH ) );
        ASSERT( RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) );
        RtlZeroMemory( pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH );
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
        
        //
        // Save EEPROM Data into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\include\CXboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/
#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_
//#include <xapip.h>
#include <xtl.h>
#define XFONT_TRUETYPE 1 // Turn TrueType Fonts on before calling xfont.h
#include <xfont.h>
#include <tchar.h>


 // Font info
#define FONT_DEFAULT_HEIGHT                     10
#define FONT_DEFAULT_WIDTH                      4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FONT_ALIAS_LEVEL                        4

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_GRAY
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

#define SCREEN_WIDTH     640
#define SCREEN_HEIGHT    480
#define FILE_DATA_DEFAULT_FONT_FILENAME         TEXT("t:\\media\\tahoma.ttf")

// Macros
//#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) continue; } while (0);
#define NUM_VB_VERTS            100


// XBox configuration
class CXBoxVideo
{

private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;
    TCHAR m_szDirectoryAndFont[ MAX_PATH ];
    INT m_iFontHeight;
    // Private Methods

public:
    // TextBlock Array.
    CHAR szTextBlock[40][100];
    int iTextBlockIndex;

    // Constructors and Destructors
    CXBoxVideo( void );
    CXBoxVideo( IN LPTSTR szFontDirectory );
    ~CXBoxVideo( void );


    static DWORD WINAPI DrawScreenThread(LPVOID lpParam);
    BOOL StartScreenThread( VOID );



    // Public Methods
    void SetFontHeight( IN int iFont ){m_iFontHeight =iFont; }
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const PCHAR format,
                  ... );
    int DrawText( const PCHAR format, ... );
    BOOL DrawTextBlock( VOID );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader


    HRESULT  BeginScene( VOID );
    HRESULT  EndScene( VOID );
};



class Key
{
public:
	int xorigin, yorigin;		// x,y coordinate of the key's upper left pixel
	int width, height;			// width and height of the key
	DWORD selectColor;			// color to hilight the key with upon selection
	WCHAR* resultChar;			// value attached to the key
	bool render;				// should the key be rendered?

	// Constructors and Destructors
	Key();
	~Key();

	void define(int x, int y, int w, int h, DWORD color);
	void defineText(WCHAR* result);
	void setRender(bool value);
	bool getRender(void);
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\ErrorGeneratePerBox\GenPerBoxData.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include "PerBoxData.h"


HRESULT GeneratePerBoxData (
    IN DWORD GameRegion,
    IN DWORD AVRegion,
    IN LPBYTE pbMACAddress, // ETHERNET_MAC_ADDR_LEN bytes
    IN char* pcXboxSerialNumber, // XBOX_SERIAL_NUMBER_LEN bytes
    OUT char* pcHardDriveKey, // HARD_DRIVE_KEY_LEN bytes
    OUT char* pcRecoveryKey, // RECOVERY_KEY_LEN bytes
    OUT DWORD* pdwOnlineKeyVersion,
    OUT char* pcOnlineKey, // ONLINE_KEY_PKENC_SIZE bytes
    OUT LPBYTE pbOutputBuffer,
    IN OUT DWORD* pdwOutputBufferSize
    )
{

/*

        return S_OK;
        return E_INVALIDARG;
            return E_INVALIDARG;
    hr = getProviderAndKey();
    if ( FAILED( hr) )
    {
        goto error;
    }

        hr = GetLastError();
        printf("CryptGenRandom failed with %x\n", hr);
        goto error;

        hr = GetLastError();
        printf("CryptGenRandom failed with %x\n", hr);
        goto error;

        hr = GetLastError();
        printf("CryptGenRandom failed with %x\n", hr);
        goto error;
    hr = EncryptOnlineKey( output.XboxSerialNumber,
                           output.OnlineKey, output.HardDriveKey,
                           output.MACAddress, output.GameRegion, output.AVRegion,
                           pdwOnlineKeyVersion, pbOnlineKey );
    if ( FAILED( hr) )
    {
        goto error;
    }

    hr = S_OK;
    
error:

    return hr;

*/
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\include\FileFormat.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>

CONST DWORD APPEND_FILE = 0;
CONST DWORD NEW_FILE    = 1;


typedef 
struct _FILE_FORMAT
{

} FILE_FORMAT, *PFILE_FORMAT;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\include\DataPacket.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _DATAPACKET_H_
#define _DATAPACKET_H_

#include <windows.h>

CONST INT PACKET_DATA_SIZE = 300;
CONST INT PACKET_MSG_SIZE = 200;

// Command Constants.
CONST DWORD DO_VERIFY_WRITEPERBOXDATA  = 0x00000001;
CONST DWORD DO_VERIFY_VERIFYPERBOXDATA = 0x00000002;
CONST DWORD DO_VERIFY_DATA_PASS        = 0x00000004;
CONST DWORD DO_VERIFY_CHECKSUM         = 0x00000008;
CONST DWORD DO_SENDBACK_EEPROM         = 0x00000010;
CONST DWORD DO_LOCK_HARDDRIVE          = 0x00000020;
CONST DWORD DO_UNLOCK_HARDDRIVE        = 0x00000040;
CONST DWORD DO_VERIFY_RETAILSYSTEM     = 0x00000080;


typedef struct 
_DATA_PACKET
{
         
   CHAR  szMessage[PACKET_MSG_SIZE];
   DWORD dwCommand;
   BYTE  byteData[PACKET_DATA_SIZE];
   ULONG ulDataSize;
   BOOL  bDevKit;
   BYTE  byteDataBackup[PACKET_DATA_SIZE];

} DATA_PACKET, *PDATA_PACKET;


// used in XeepromDump.
typedef struct 
_CRITICAL_KEY_PAIR {
   BYTE HardDriveKey[16];
   BYTE OnlineKey[16];
}CRITICAL_KEY_PAIR, *PCRITICAL_KEY_PAIR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\X2kIdServer\CNetWork.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <xtl.h>
#include <winsockx.h>
#include <tchar.h>
#include <stdio.h>
#include "CNetWork.h"
#include "..\include\CXboxVideo.h"

extern CXBoxVideo g_xv;
CNetWork::CNetWork()
{                                                  

   WSADATA       wsa;
   SOCKADDER_IN local;
   // According to Dinarte this will set the first 2 params.
   // The rest is zeroed. That Dinarte knows a lot of cool stuff. :-)
   // Mental note to talk to him more!! :-)
   XNetStartupParams xnsp = {sizeof(XNetStartupParams ),
                             XNET_STARTUP_BYPASS_SECURITY};    
   // Must call to get the net stack working.
   XNetStartup(&xnsp);
   // Start the IpAdvertise thread.
   StartThread( IpAdvertise, (LPVOID)this);

   
   m_dwAcceptIndex = 0;
   if ( -1 == WSAStartup( MAKEWORD(2,2), &wsa) ) {
      g_xv.DrawText("WSAStartup  failed: %d", WSAGetLastError());
   }else
      g_xv.DrawText("Network Initialized");


   // Create our listening socket
   sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sClient == SOCKET_ERROR) {
      g_xv.DrawText("socket() failed: %d", WSAGetLastError());
   }
   local.sin_addr.s_addr = htonl(INADDR_ANY);
   local.sin_family = AF_INET;
   local.sin_port = htons( COMMUNICATION_PORT );


   if (bind(sClient, (struct sockaddr *)&local, sizeof(local)) == SOCKET_ERROR) {
      g_xv.DrawText("bind() failed: %d", WSAGetLastError());
   }
   listen(sClient, 10);
}



CNetWork::~CNetWork()
{

   closesocket(sClient);
   WSACleanup();
   XNetCleanup();
}




SOCKET 
CNetWork::
Accept (struct sockaddr FAR *addr,
        int FAR *addrlen )
{
   return accept(sClient,addr, addrlen);
}


SOCKET 
CNetWork::
Accept ( VOID )
{
   SOCKET AcceptReturned;
   CHAR    szIpString[18]= "";

   struct sockaddr_in  client;
   int           iAddrSize;

   iAddrSize = sizeof(client);
   AcceptReturned = accept(sClient,(struct sockaddr *)&client, &iAddrSize);
   
   if (AcceptReturned == INVALID_SOCKET) {
      g_xv.DrawText("ACCEPT() failed: %d", WSAGetLastError());
   } else {
      XNetInAddrToString(client.sin_addr,szIpString,sizeof(szIpString)/sizeof(CHAR));
      g_xv.DrawText("ACCEPT() succeeded. Session[%lu] Client:%S:%d", 
                    m_dwAcceptIndex, 
                    szIpString, 
                    ntohs(client.sin_port) );
      ++m_dwAcceptIndex;
   }
   return AcceptReturned;
}

BOOL
CNetWork::
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
        This routine creates a thread.
    Arguments:
        The Thread Function address.
        The Paremer to the function.
    Return Value:

--*/

{
   HANDLE   hThread;
   hThread = CreateThread(NULL,
                          0,
                          lpStartAddress,
                          (LPVOID)Param,
                          0,
                          NULL);
   if (hThread == NULL) {
      g_xv.DrawText("CreateThread() failed: %d", GetLastError());
      return FALSE;
   }
   CloseHandle(hThread);
   return TRUE;
}





DWORD WINAPI
CNetWork::
IpAdvertise( LPVOID lpParam )
{
   
   SOCKET sBroadCast;
   BOOL   bBroadCast = TRUE;
   SOCKADDER_IN sddrFrom;
   char szInBuffer[20] = "";  // This zeroes the entire buffer if you didn't know this trick.
   XNADDR  xna = {sizeof(XNADDR)};
   INT  iFromLen;
   INT  iRet;
   WSADATA       wsd;
   BOOL bStatus = TRUE;
   BYTE    byteIP[15] = "";
   CHAR    szIpString[18]= "";


   g_xv.DrawText("Waiting for broadcast to send IP" );
   if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
      g_xv.DrawText("Failed to load Winsock library!");
      bStatus = FALSE;
      goto c1;
   }

restart:
   while (1) {
      // Do a recvfrom so we then broadcast out our IP
      sBroadCast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
      if (sBroadCast == SOCKET_ERROR) {
         g_xv.DrawText("IP Advertise broadcast socket() failed: %d", WSAGetLastError());
         bStatus = FALSE;
         goto restart;
      }

      // Set this to a broadcast socket.
      setsockopt(sBroadCast,SOL_SOCKET, SO_BROADCAST,(char *)&bBroadCast, sizeof(bBroadCast));
      sddrFrom.sin_family = AF_INET;
      sddrFrom.sin_addr.s_addr = htonl(INADDR_ANY) ;
      sddrFrom.sin_port = htons(ADVERTISE_PORT);

      if ( SOCKET_ERROR == bind(sBroadCast, (SOCKADDR *)&sddrFrom, sizeof(sddrFrom))) {
         g_xv.DrawText("IP Advertise bind() failed: %d\n", WSAGetLastError());
         bStatus = FALSE;
         closesocket( sBroadCast);
         goto restart;
      }


      iFromLen =  sizeof(sddrFrom);
      recvfrom( sBroadCast,
                szInBuffer,
                20,
                0,
                (SOCKADDR *)&sddrFrom,
                &iFromLen);
      // inet_ntoa should use XNetInAddrToString
      XNetInAddrToString(sddrFrom.sin_addr,szIpString,sizeof(szIpString)/sizeof(CHAR));
      g_xv.DrawText("Address where broadcast came from %s",  szIpString );
      closesocket( sBroadCast);

      // Do a send of our IP.
      sBroadCast = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      RtlZeroMemory( &sddrFrom, sizeof(sddrFrom));
      if (sBroadCast == SOCKET_ERROR) {
         g_xv.DrawText("IP Advertise  Opening socket() failed: %d", WSAGetLastError());
         bStatus = FALSE;
         goto restart;
      }

      // Sleep 1 second so we have time on the other end
      // To setup a receive.
      Sleep(2000);
      sddrFrom.sin_family      = AF_INET;
      sddrFrom.sin_addr.s_addr = inet_addr( szIpString );
      sddrFrom.sin_port        = htons(ADVERTISE_PORT);

      if (connect(sBroadCast, (struct sockaddr *)&sddrFrom, 
                  sizeof(sddrFrom)) == SOCKET_ERROR) {
         g_xv.DrawText("IP Advertise Connect() failed: %d", WSAGetLastError());
         closesocket( sBroadCast);
         goto restart;
      }
      XNetGetTitleXnAddr( &xna );
      RtlCopyMemory(byteIP, (BYTE*) &xna.ina, sizeof(xna.ina));
      XNetInAddrToString(xna.ina, szIpString,sizeof(szIpString)/sizeof(CHAR));
      g_xv.DrawText("Title IP is %s", szIpString);
      iRet = send(sBroadCast,(CHAR*)byteIP,sizeof(byteIP)/sizeof(CHAR), 0);
      closesocket( sBroadCast);
   }
   WSACleanup();
   c1:
   return TRUE;
}


CNetWorkConnection::
~CNetWorkConnection() {
   if (0 != sConnection )
      closesocket(sConnection);
}

INT 
CNetWorkConnection::
SendData( LPVOID pvData, INT iSize)
{

   INT ret;
   PDATA_PACKET p =(PDATA_PACKET)pvData;
   // Send the data 
   ret = send(sConnection,(const char*) pvData, iSize, 0);
   if (ret == SOCKET_ERROR) {
      g_xv.DrawText("  SEND failed: %d", WSAGetLastError());
   }else{
      g_xv.DrawText("  SEND [%d bytes]", ret);
      g_xv.DrawText("  SEND MSG: [SENT]: %s", p->szMessage);
   }
   return ret;
}


INT 
CNetWorkConnection::
RecvData( LPVOID pvData, INT iSize)
{
   
   INT ret;
   PDATA_PACKET p = (PDATA_PACKET)pvData;
   ret = recv( sConnection,(char*)pvData, iSize, 0);

   if (ret == SOCKET_ERROR) {
      g_xv.DrawText("  RECV failed: %d", WSAGetLastError());
   }else{
      g_xv.DrawText("  RECV [%d bytes]", ret );
      g_xv.DrawText("  RECV MSG: [RECEIVED]: %s", p->szMessage);
   }
   return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\X2kIdServer\X2kIdServer.h ===
#include <ntos.h>  //ntos has to come before xtl.h
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <tchar.h>
#include <cryptkeys.h>

#include "PerBoxData.h"
#include "CNetWork.h"
#include "CXboxVideo.h"
#include "..\\include\\fileformat.h"


#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Globals
CXBoxVideo g_xv;

// Prototypes

DWORD WINAPI 
ClientThread(LPVOID lpParam);

DWORD WINAPI 
DrawScreenThread(LPVOID lpParam);
BOOL
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param );
BOOL
WriteEEPROM ( IN PDATA_PACKET dpData );

HRESULT
ReadEEPROM ( IN PDATA_PACKET dpData );

VOID 
FileToDrive( LPCSTR lpFileName,
             LPVOID pvFileContents,
             DWORD dwFileSize,
             DWORD dwWriteFlags );

VOID DebugOut (PCHAR szMessage,...);


HRESULT
TestWritePerBoxData(IN SOCKET s);

HRESULT
TestVerifyPerBoxData(IN SOCKET s);
 
HRESULT
SendBackEEPROMContents(IN SOCKET s);

HRESULT
LockHardDrive(IN SOCKET s, 
              IN BOOL   bLock);

HRESULT
TestRetailSystem ( IN SOCKET RecvSocket );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\X2kIdServer\CNetWork.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <xtl.h>
#include "..\\include\\datapacket.h"


typedef struct sockaddr_in SOCKADDER_IN;
typedef struct sockaddr SOCKADDR;

   CONST USHORT ADVERTISE_PORT = 5159;
   CONST USHORT COMMUNICATION_PORT = 5150;



class CNetWorkConnection{
public:

   INT SendData( LPVOID pvData, INT iSize);
   INT RecvData( LPVOID pvData, INT iSize);
   VOID SetConnection(SOCKET s){ sConnection = s; }

   ~CNetWorkConnection();
   CNetWorkConnection();
   CNetWorkConnection( SOCKET s){ sConnection = s;}

private:

   SOCKET sConnection;
};



class CNetWork {

private:
   DWORD  m_dwAcceptIndex;
   SOCKET sClient;

public:

   
   SOCKET Accept ( struct sockaddr FAR *addr, int FAR *addrlen );
   SOCKET Accept ( VOID );
   static DWORD WINAPI IpAdvertise( LPVOID lpParam );
   BOOL StartThread( LPTHREAD_START_ROUTINE lpStartAddress, LPVOID Param );

   ~CNetWork();
   CNetWork();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\XEEPROMDump\CXCrypto.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "CXCrypto.h"

HRESULT 
CXCrypto::
EncryptCriticalKeyPair (
    IN  LPBYTE pbOnlineKey,
    IN  LPBYTE pbHarDriveKey,
    IN  LPBYTE bConfounder,
    OUT LPBYTE pbEncBlob )
{
    
   HRESULT hr = S_OK;
   CRITICAL_KEY_PAIR ckp;
   
   RtlZeroMemory( &ckp, sizeof(ckp) );
   RtlCopyMemory( ckp.OnlineKey,    pbOnlineKey, 16 );
   RtlCopyMemory( ckp.HardDriveKey, pbHarDriveKey, 16 );
   
   
   RtlCopyMemory( pbEncBlob + sizeof(RC4_SHA1_HEADER), &ckp, sizeof(CRITICAL_KEY_PAIR) );
   rc4HmacEncrypt( bConfounder, // use as confounder
                   (LPBYTE)DAT_ENCRYPTION_KEY , DAT_ENCRYPTION_KEY_LEN,
                   (LPBYTE)pbEncBlob + sizeof(RC4_SHA1_HEADER), sizeof(CRITICAL_KEY_PAIR),
                   pbEncBlob );
   return hr;
}



void 
CXCrypto::
rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


BOOL 
CXCrypto::
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\Xcommon\CXboxvideo.cpp ===
/*
   CXboxvideo.cpp

   CPP file for our xboxvideo class.  This class   
   will initial D3D graphics, and allow the user to
   draw text or graphics to the screen.
*/

#include "..\include\CXboxvideo.h"
#include <stdio.h>
#include <tchar.h>



CONST PCHAR APP_TITLE_NAME_A = "CXboxVideo";

DWORD WINAPI 
CXBoxVideo::
DrawScreenThread(LPVOID lpParam)
{

   CXBoxVideo* p = (CXBoxVideo*)lpParam;
   p->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
   while (1) {
      // draw the number we are building on screen
      p->ClearScreen( SCREEN_DEFAULT_BACKGROUND_COLOR );
      p->DrawTextBlock();
      p->ShowScreen();
      Sleep(100);
   }
   p->DeInitialize();

}


BOOL
CXBoxVideo::
StartScreenThread( VOID )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
        This routine creates a thread.
    Arguments:
    Return Value:

--*/

{
   HANDLE   hThread;
   hThread = CreateThread(NULL,
                          0,
                          DrawScreenThread,
                          (LPVOID)this,
                          0,
                          NULL);
   if (hThread == NULL) {
      DrawText("CreateThread() failed: %d", GetLastError());
      return FALSE;
   }
   CloseHandle(hThread);
   return TRUE;
}



// Constructor
CXBoxVideo::
CXBoxVideo( void )
{

   m_Device       = NULL;
   m_BackBuffer   = NULL;
   m_VertexBuffer = NULL;
   // Font properties
   m_Font = NULL;
   m_FontWidth   = FONT_DEFAULT_WIDTH;
   m_FontHeight  = FONT_DEFAULT_HEIGHT;
   m_FontColor   = SCREEN_DEFAULT_TEXT_FG_COLOR;
   m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

   m_ScreenWidth  = SCREEN_WIDTH;      // Default the screen width to 640
   m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480

   // FontSize
   m_iFontHeight = FONT_DEFAULT_HEIGHT;
   iTextBlockIndex = 0;

   ZeroMemory( szTextBlock, (sizeof(CHAR)* 40) * 100 );
   sprintf( szTextBlock[0], "%s", "Initialize Graphics" );
   _tcscpy(m_szDirectoryAndFont, FILE_DATA_DEFAULT_FONT_FILENAME);
}

// Constructor
CXBoxVideo::
CXBoxVideo(IN LPTSTR szFontDirectory)
{
    
   m_Device       = NULL;
   m_BackBuffer   = NULL;
   m_VertexBuffer = NULL;
   // Font properties
   m_Font = NULL;
   m_FontWidth   = FONT_DEFAULT_WIDTH;
   m_FontHeight  = FONT_DEFAULT_HEIGHT;
   m_FontColor   = SCREEN_DEFAULT_TEXT_FG_COLOR;
   m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

   m_ScreenWidth  = SCREEN_WIDTH;      // Default the screen width to 640
   m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480

   // FontSize
   m_iFontHeight = FONT_DEFAULT_HEIGHT;
   iTextBlockIndex = 0;

   ZeroMemory( szTextBlock, (sizeof(CHAR)* 40) * 100 );
   sprintf( szTextBlock[0], "%s", "Initialize Graphics" );
   _tcscpy( m_szDirectoryAndFont,szFontDirectory);
}



// Destructor
CXBoxVideo::
~CXBoxVideo( void )
{
//    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

   if ( m_Device ) {
      m_Device->Release();
      m_Device = NULL;
   }

   if ( m_BackBuffer ) {
      m_BackBuffer->Release();
      m_BackBuffer = NULL;
   }

   if ( m_VertexBuffer ) {
      m_VertexBuffer->Release();
      m_VertexBuffer = NULL;
   }
}



// Clear the screen
void CXBoxVideo::
ClearScreen( DWORD color )
{
   if ( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) ) {
      
  //    XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
   
   }
}

void 
CXBoxVideo::
DrawBitBlt( float fx, 
                        float fy, 
                        ULONG ulWidth, 
                        ULONG ulHeight, 
                        const DWORD* pData )
/*++
 Copyright (c) 2000, Microsoft.

    Date:    7/9/2001

    Routine Description:
         Draw the inputed bit array to the screen
    Arguments:
         fx - the upper left x coordinate on screen
         fy - the upper left y coordinate on screen
         ulWidth - the width of the bitmap
         ulHeight - the height of the bitmap
         pData - a pointer to the array of pixel values
    Return Value:
      NONE
--*/

{
   // Check to make sure we received a valid pointer
   if ( !pData ) {
      //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

      return;
   }

   // Draw the bitmap on the screen, pixel by pixel
   for ( ULONG y = 0; y < ulHeight; y++ ) {
      for ( ULONG x = 0; x < ulWidth; x++ ) {
         if ( 0 != pData[y * ulWidth + x] ) {
            DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
         }
      }
   }
}


// Draw a box on the screen
void 
CXBoxVideo::DrawBox( float x1, 
                     float y1, 
                     float x2, 
                     float y2, 
                     DWORD color )

{
   MYVERTEX* pb;
   float maxx, minx;
   float maxy, miny;

   CHECK( m_Device->BeginScene() );
   CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );

   if ( IsBadWritePtr( pb, 128 ) ) {
    //  XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

      return;
   }

   if ( x1 < x2 ) {
      minx = x1;
      maxx = x2;
   } else {
      minx = x2;
      maxx = x1;
   }

   if ( y1 < y2 ) {
      miny = y1;
      maxy = y2;
   } else {
      miny = y2;
      maxy = y1;
   }

   if ( x1 == x2 ) {
      maxx++;
   }

   pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
   pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
   pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
   pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

   m_VertexBuffer->Unlock();
   m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
   m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

      m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
   }
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
   HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
   MYVERTEX* pb;   // Vertex information

   // Set the line width
   if ( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
   }

   // Before any rendering can be done, this must be called
   if ( FAILED( hr = m_Device->BeginScene() ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
   }

   // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
   if ( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
   }

   pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
   pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

   // Unlock the vertext data
   if ( FAILED( hr = m_VertexBuffer->Unlock() ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

      return hr;
   }

   // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
   if ( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
   }

   // Once rendering is complete, this must be called
   // We should try this, even on a failure, in case BeginScene() was successful
   // We'll report it to the debugger, but will not return the fail/success code to the
   // caller
   if ( FAILED( m_Device->EndScene() ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
   }

   return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::
DrawOutline( float x1, 
             float y1, 
             float x2, 
             float y2, 
             float fLineWidth, 
             DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{

    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::
DrawText( float x1, 
          float y1, 
          DWORD fgcolor, 
          DWORD bgcolor, 
          const PCHAR format, ... )
{

   if ( !m_Font ) {
      //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
      return -1;
   }

   int i;                  // Return Value
   HRESULT hr;             // Return Value for XFONT
   va_list v;              // Argument List
   CHAR  str[260];        // 6Honkin Buffer
   WCHAR wstr[260];        // Honkin Buffer
//   DWORD currentFGColor;   // Current FG Color
//   DWORD currentBGColor;   // Current FG Color

   // Set our FONT colors if the user wishes to
   if ( fgcolor || bgcolor ) {
      // Set the foreground color if the user wants to
      if ( fgcolor ) {
         XFONT_SetTextColor(m_Font, fgcolor );
      }

      // Set the background color if the user wants to
      if ( bgcolor ) {
         XFONT_SetBkColor( m_Font, bgcolor );
      }
   }

   va_start( v, format );
   i = vsprintf( str, format, v );
   wprintf(wstr,L"%S",str);
   // Print the Text to the backbuffer
   hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );
   // If we have a valid font object, check the HRESULT
   if ( FAILED( hr ) ) {
      //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
   }
   va_end( v );
   return i;
}




int CXBoxVideo::
DrawText( const PCHAR format, ... )
// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
{

   va_list v;
   va_start( v, format );
   vsprintf( szTextBlock[iTextBlockIndex], format, v );
   va_end( v );
   
   if (iTextBlockIndex == (SCREEN_HEIGHT - 80) / m_iFontHeight) {
      iTextBlockIndex = (SCREEN_HEIGHT - 80) / m_iFontHeight;
      
      for (INT i = 0 ; i < 40; i++) {
         // Clear out the prev buffer
         ZeroMemory( szTextBlock[i],100);
         sprintf (szTextBlock[i], "%s" ,szTextBlock[i + 1] );
      }
      // Clear out the next buffer
      ZeroMemory( szTextBlock[40 -1],100);

   }else{
      ++iTextBlockIndex;
   }
   return 1;
}



BOOL CXBoxVideo::
DrawTextBlock( VOID )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/4/2001

    Routine Description:
        This routines draws out the entire buffer for the screen.
        This allows for a virtual rolling lines.
    Arguments:
        n/a
    Return Value:

--*/

{

   HRESULT hr = S_OK; // Return Value for XFONT
   // Set the foreground color if the user wants to
   XFONT_SetTextColor(m_Font,  SCREEN_DEFAULT_TEXT_FG_COLOR );
   // Set the background color if the user wants to
   XFONT_SetBkColor( m_Font, COLOR_LIME_GREEN );
   
   // Print the TextBlock to the backbuffer
   for (INT i = 0; i < (SCREEN_HEIGHT - 80) / m_iFontHeight; i++) {
      
      WCHAR wStr[260];
      ZeroMemory(wStr,260);
      wsprintf(wStr,L"%2d: %S", i,szTextBlock[i]);
      hr = XFONT_TextOut(m_Font, 
                         m_BackBuffer,
                         wStr, 
                         -1, 
                         (long)100, // X cord 
                         (long) 40 + (i * m_iFontHeight) ); // y cord
   }
   // If we have a valid font object, check the HRESULT
   if ( FAILED( hr ) ) {
      return FALSE;
   }
   return TRUE;
}



// Get the size of the current font
void CXBoxVideo::
GetFontSize( unsigned int* pheight, 
             unsigned int* pdecent )
{
   // Make sure we have loaded a font
   if ( !m_Font ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );
      return;
   }

   // Verify the parameters that were passed in are corred
   if ( ( !pheight ) || ( !pdecent ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

      return;
   }
   XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}


// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::
GetStringPixelWidth( IN LPCWSTR string, 
                     IN int length /*=-1*/ ) 
{
   // Make sure we have loaded a font
   if ( !m_Font ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

      return -1;
   }

   if ( !string ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

      return -1;
   }

   unsigned int outlen = 0;        // Return value

   XFONT_GetTextExtent( m_Font, string, length, &outlen );

   return outlen;
}

// Get the width of the char*
int CXBoxVideo::
GetStringPixelWidth( IN char* string, 
                     IN int length /*=-1*/ ) 
{
    if( !string )
    {
        // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT 
CXBoxVideo::
GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}



// Initialize D3D for this screen
void CXBoxVideo::
Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
   
   IDirect3D8* pD3D = NULL;
   m_ScreenWidth    = width;
   m_ScreenHeight   = height;

   if ( m_Device == NULL ) {

      // Create D3D 8.
      if ( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) {
        // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
         return;
      }

      // Set the screen mode.
      D3DPRESENT_PARAMETERS d3dpp;
      ZeroMemory( &d3dpp, sizeof( d3dpp ) );

      d3dpp.BackBufferWidth                 = width;
      d3dpp.BackBufferHeight                = height;
      d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
      d3dpp.BackBufferCount                 = 1;

      d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
      d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
      d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
      d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
      d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
      d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

      // Create the m_Device.
      if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                        D3DDEVTYPE_HAL,
                                        NULL,      // Ignored on Xbox
                                        D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                        &d3dpp,
                                        &m_Device ) ) ) {
         //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
         pD3D->Release();
         return;
      }

      // Now we no longer need the D3D interface so let's free it.
      pD3D->Release();
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
   }

   // Create our vertex buffer
   if ( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) ) {
      // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
   }

   // Set the stream source
   m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

   // Set our initial vertex shader that is compatible with our 2D scene
   if ( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) ) {
      // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
   }
   
   // Setup matricies
   // Setup our identity matrix
   D3DMATRIX mat;
   mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
   mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
   mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
   mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

   // World Matrix
   // The world matrix controls the position and orientation 
   // of the polygons in world space. We'll use it later to 
   // spin the triangle.
   D3DMATRIX WorldMatrix = mat;

   // Set the transforms for our 3D world
   if ( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) ) {
      // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
   }

   // View Matrix
   // The view matrix defines the position and orientation of 
   // the camera. Here, we are just moving it back along the z-
   // axis by 10 units.
   D3DMATRIX ViewMatrix = mat;
   ViewMatrix._43 = 10.0f;

   if ( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) ) {
      // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
   }

   // Projection Matrix
   // The projection matrix defines how the 3-D scene is "projected" 
   // onto the 2-D render target surface. 

   // Set up a very simple projection that scales x and y 
   // by 2, and translates z by -1.0.
   D3DXMATRIX ProjectionMatrix; //  = mat;
   D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

   if ( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
   }

   // Viewport
   D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

   D3DViewport.X      = 0;
   D3DViewport.Y      = 0;
   D3DViewport.Width  = width;  // rect.right - rect.left;
   D3DViewport.Height = height; // rect.bottom - rect.top;
   D3DViewport.MinZ   = 0.0f;
   D3DViewport.MaxZ   = 1.0f;

   // Set our Viewport
   if ( FAILED( m_Device->SetViewport( &D3DViewport ) ) ) {
      // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
   }
   // This is the loaded font... wallyho
   XFONT_OpenTrueTypeFont( m_szDirectoryAndFont, 4096, &m_Font );
   //XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );
   

   if ( m_Font ) {
      if ( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) ) {
         // XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
      }

      //XFONT_SelectFont( m_Font );
      //XFONT_SetDrawingSurface( m_BackBuffer );
      XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
      XFONT_SetBkColor(m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
      XFONT_SetTextHeight(m_Font, m_iFontHeight );
      XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
      XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
   }
}



// Set a D3D Transform
HRESULT 
CXBoxVideo::BeginScene( VOID )
{
    
   return m_Device->BeginScene();

};

HRESULT 
CXBoxVideo::EndScene( VOID )
{
    
   return m_Device->EndScene();

};



// Set a D3D Transform
HRESULT 
CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, 
                          CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};


// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
   if ( m_Device ) {
      m_Device->Present( NULL, NULL, NULL, NULL );
   }
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::
TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
   if ( ( !pString ) || ( 0 > ( x2 - x1 ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

      return E_INVALIDARG;
   }

   float maxLen = x2 - x1;

   // If the string is to long, let's knock off characters
   while ( GetStringPixelWidth( pString, -1 ) >= maxLen ) {
      pString[wcslen( pString ) - 1] = L'\0';

      // Ensure we don't end up in an endless loop
      if ( L'\0' == pString[0] ) {
         break;
      }
   }

   return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::
TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
   if ( ( !pString ) || ( 0 > ( x2 - x1 ) ) ) {
      // XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

      return E_INVALIDARG;
   }

   float maxLen = x2 - x1;

   // If the string is to long, let's knock off characters
   while ( GetStringPixelWidth( pString, -1 ) >= maxLen ) {
      pString[strlen( pString ) - 1] = '\0';

      // Ensure we don't end up in an endless loop
      if ( '\0' == pString[0] ) {
         break;
      }
   }

   return S_OK;
}




// Key Class by Victor Blanco
Key::Key()
{
   xorigin = 0;
   yorigin = 0;
   width = 0;
   height = 0;     
   selectColor = 0x00000000; //COLOR_WHITE;//
   render = true;
   resultChar = NULL;
}

Key::~Key()
{
   if ( resultChar ) {
      delete[] resultChar;
      resultChar = NULL;
   }
}

void Key::define(int x, int y, int w, int h, DWORD color)
{
   xorigin = x;
   yorigin = y;
   width = w;
   height = h;     
   selectColor = color;    
}

void Key::
defineText(WCHAR* result)
{
   int length = wcslen(result);
   resultChar = new WCHAR[length + 1];
   wcscpy(resultChar, result);
}

void Key::
setRender(bool value) {
   render = value;
}

bool Key::
getRender(void) {
   return render;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\XEEPROMDump\CXCrypto.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
//===================================================================
#ifndef _CXCRYPTO_H_
#define _CXCRYPTO_H_

#include <xtl.h>
#include <init.h>
#include <xboxp.h>
#include <av.h>

#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>

#include <wincrypt.h>
#include <cryptkeys.h>
#include <sha.h>
#include <rc4.h>
#include "..\include\DataPacket.h"
  
#define DAT_ENCRYPTION_KEY "\x7a\x3b\xa8\xb7\x27\xed\x43\x7a\xd0\xba\xfb\x8f\xa4\xd8\x31\x90"
CONST DWORD DAT_ENCRYPTION_KEY_LEN = 16;


//The LPBYTE out buffer is 52  XboxEncryptedPerBoxData +
//28 bytes of RC4_SHA1_HEADER.
#define RC4_CONFOUNDER_LEN 8
//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;


class CXCrypto {
private:
   
public:

   BOOL  rc4HmacDecrypt( IN PUCHAR pbKey,
                         IN ULONG cbKey,
                         IN PUCHAR pbInput,
                         IN ULONG cbInput,
                         IN PUCHAR pbHeader); // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes 
   void 
      rc4HmacEncrypt(
                   IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
                   IN PUCHAR pbKey,
                   IN ULONG cbKey,
                   IN PUCHAR pbInput,
                   IN ULONG cbInput,
                   OUT PUCHAR pbHeader); // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes

BOOL Decrypt ( IN OUT LPBYTE pbInputBuffer,
               IN     DWORD dwInputBufferSize );
   HRESULT 
   EncryptCriticalKeyPair ( IN  LPBYTE pbOnlineKey,
                            IN  LPBYTE pbHarDriveKey,
                            IN  LPBYTE bConfounder,
                            OUT LPBYTE pbEncBlob);

~CXCrypto(){}
   CXCrypto() {}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\X2kIdServer\X2kIdServer.cpp ===
#include "X2kIdServer.h"



int 
__cdecl main()
{
   CNetWork cn;
   SOCKET   sAccept;
   
   // Start the screen processing thread
   g_xv.StartScreenThread();
   g_xv.SetFontHeight(13);

   // In a continous loop, wait for incoming clients. Once one 
   // is detected, create a thread and pass the handle off to it.
   g_xv.DrawText("Listening....");
   
   while (1) {
      // Accept will block then thread will start.
      if ( INVALID_SOCKET == (sAccept= cn.Accept())){
         g_xv.DrawText("INVALID_SOCKET on calling accept....");
      } else
         StartThread( ClientThread,(LPVOID)sAccept);
   }
   WSACleanup();
   return 0;
}




DWORD WINAPI 
ClientThread(LPVOID lpParam)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/25/2001

    Routine Description:
        This is the thread function that will Do the receving work.
        it handles a given client connection.  The parameter passed 
        in is the socket handle returned from an accept() call.  
        This function reads data from the client and writes it back.

    Arguments:
        A Variable void pointer.
    Return Value:

--*/

{
   
   HRESULT hr;
   SOCKET        RecvSocket = (SOCKET)lpParam;
   CNetWorkConnection cnc( (SOCKET)lpParam );
   DATA_PACKET InBuffer;
   DATA_PACKET dpEEPROM;
   g_xv.DrawText("[----------- INITIATING SESSION ----------]");

   // Read Command Buffer.
   ZeroMemory(&InBuffer, sizeof(InBuffer));
   if ( SOCKET_ERROR == cnc.RecvData(&InBuffer, sizeof(InBuffer)))
      goto cleanup;
   g_xv.DrawText("Command %lu",InBuffer.dwCommand );

   if (InBuffer.dwCommand & DO_VERIFY_WRITEPERBOXDATA ) {
      TestWritePerBoxData( RecvSocket );  
   }
   else if(InBuffer.dwCommand & DO_VERIFY_RETAILSYSTEM ){
      // Make it a retail kit override the DevKitFlag.
      ((XBOX_HARDWARE_INFO*)XboxHardwareInfo)->Flags = 0;
      TestRetailSystem ( RecvSocket );  
   }
   else if(InBuffer.dwCommand & DO_VERIFY_VERIFYPERBOXDATA ){
      TestVerifyPerBoxData( RecvSocket );  
   } 
   else if(InBuffer.dwCommand & DO_SENDBACK_EEPROM ){
      SendBackEEPROMContents( RecvSocket );  
   } 
   else if(InBuffer.dwCommand & DO_LOCK_HARDDRIVE ){
      LockHardDrive( RecvSocket, TRUE );  
   } 
   else if(InBuffer.dwCommand & DO_UNLOCK_HARDDRIVE ){
      LockHardDrive( RecvSocket, FALSE );  
   } 
   cleanup:
   g_xv.DrawText("[----------- TERMINATING SESSION ---------]");
   g_xv.DrawText(" ");
   return 0;
}


HRESULT
TestWritePerBoxData(IN SOCKET s)
{
   HRESULT hr = S_OK;
   CNetWorkConnection* c= new CNetWorkConnection( s );

   DATA_PACKET InBuffer;
   DATA_PACKET dpEEPROM;
   char buffer[256];


   ZeroMemory(&InBuffer, sizeof(InBuffer));
   if ( SOCKET_ERROR == c->RecvData(&InBuffer, sizeof(InBuffer))) {
      hr = E_FAIL;
      goto c0;
   }
   // Do the WritePerBoxData
   //extern XBOX_HARDWARE_INFO* XboxHardwareInfo;
   
   hr = WritePerBoxData( InBuffer.byteData , InBuffer.ulDataSize );
   if ( FAILED( hr ) ) {

      //sprintf(buffer, "FAILED WritePerBoxData returned %x", hr);
      //AppendFile( SZDATAFILE, buffer,strlen( buffer ));
      g_xv.DrawText("FAILED WritePerBoxData returned %x", hr );
      hr = E_FAIL;
      goto c0;
   } else
      g_xv.DrawText("SUCCEEDED WritePerBoxData");


   // Read out the EEPROM and send what we have
   sprintf(dpEEPROM.szMessage, "EEPROM DATA" );
   /*
      The flag XboxHardwareInfo is defined in init.h under.
      ntos\inc. This controls if the machine is a devkit 
      or if it is a retail box. We'll used the same thing 
      to tell our test program that the devkit has a
      Zero Hard Drive Key.
             
      #if !defined(_NTSYSTEM_)
      extern const XBOX_HARDWARE_INFO* XboxHardwareInfo;
      #else
      extern XBOX_HARDWARE_INFO XboxHardwareInfo;
      #endif
      
      //
      //  Define XboxHardwareFlags - a list of 
      //  flags indicating hardware differences
      //  the title libraries must know about.
      //
      #define XBOX_HW_FLAG_INTERNAL_USB_HUB   0x00000001
      #define XBOX_HW_FLAG_DEVKIT_KERNEL      0x00000002
   */
   if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
   {
      dpEEPROM.bDevKit = TRUE;
   }else {
      dpEEPROM.bDevKit = FALSE;
   }

   hr = ReadEEPROM ( &dpEEPROM );
   if ( FAILED( hr ) ) {
      g_xv.DrawText("FAILED ReadEEPROM, returned %x", hr );
      hr = E_FAIL;
      goto c0;
   } else
      g_xv.DrawText("SUCCEEDED ReadEEPROM");

   if ( SOCKET_ERROR == c->SendData(&dpEEPROM, sizeof(dpEEPROM))){
      hr = E_FAIL;
      goto c0;
   }

// Send the STATUS back
   // Make sure we write all the data
   sprintf(InBuffer.szMessage, "Decrypted buffer Data");
   if ( SOCKET_ERROR == c->SendData  (&InBuffer, sizeof(InBuffer))){
      hr = E_FAIL;
      goto c0;
   }

   UnlockXboxHardDrive( NULL, 0 );
   c0:
   // Should close the socket
   delete c;
   return hr;
}



HRESULT
TestRetailSystem(IN SOCKET s)
{
   HRESULT hr = S_OK;
   CNetWorkConnection cnc( s );
   DATA_PACKET InBuffer;
   DATA_PACKET dpEEPROM;
   char buffer[256];

   ZeroMemory(&InBuffer, sizeof(InBuffer));
   if ( SOCKET_ERROR == cnc.RecvData(&InBuffer, sizeof(InBuffer))) {
      hr = E_FAIL;
      goto c0;

   }
   // Do the WritePerBoxData
   hr = WritePerBoxData( InBuffer.byteData , InBuffer.ulDataSize );
   if ( FAILED( hr ) ) {

      //sprintf(buffer, "FAILED WritePerBoxData returned %x", hr);
      //AppendFile( SZDATAFILE, buffer,strlen( buffer ));
      g_xv.DrawText("FAILED WritePerBoxData returned %x", hr );
      hr = E_FAIL;
      goto c0;
   } else
      g_xv.DrawText("SUCCEEDED WritePerBoxData");


   // Read out the EEPROM and send what we have
   sprintf(dpEEPROM.szMessage, "EEPROM DATA" );
   
   /*
   
      The flag XboxHardwareInfo is defined in init.h under.
      ntos\inc. This controls if the machine is a devkit 
      or if it is a retail box. We'll used the same thing 
      to tell our test program that the devkit has a
      Zero Hard Drive Key.
             
      #if !defined(_NTSYSTEM_)
      extern const XBOX_HARDWARE_INFO* XboxHardwareInfo;
      #else
      extern XBOX_HARDWARE_INFO XboxHardwareInfo;
      #endif
      
      //
      //  Define XboxHardwareFlags - a list of 
      //  flags indicating hardware differences
      //  the title libraries must know about.
      //
      #define XBOX_HW_FLAG_INTERNAL_USB_HUB   0x00000001
      #define XBOX_HW_FLAG_DEVKIT_KERNEL      0x00000002
   */
   if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
   {
      dpEEPROM.bDevKit = TRUE;
   }else {
      dpEEPROM.bDevKit = FALSE;
   }


   hr = ReadEEPROM ( &dpEEPROM );
   if ( FAILED( hr ) ) {
      g_xv.DrawText("FAILED ReadEEPROM, returned %x", hr );
      hr = E_FAIL;
      goto c0;
   } else
      g_xv.DrawText("SUCCEEDED ReadEEPROM");


   if ( SOCKET_ERROR == cnc.SendData(&dpEEPROM, sizeof(dpEEPROM))){
      hr = E_FAIL;
      goto c0;
   }

// Send the STATUS back
   // Make sure we write all the data
   sprintf(InBuffer.szMessage, "Decrypted buffer Data");
   if ( SOCKET_ERROR == cnc.SendData  (&InBuffer, sizeof(InBuffer))){
      hr = E_FAIL;
      goto c0;
   }

   //Unlock it with the key we sent over.
   PXBOX_ENCRYPTED_PER_BOX_DATA p = (PXBOX_ENCRYPTED_PER_BOX_DATA)InBuffer.byteData;
   UnlockXboxHardDrive( p->HardDriveKey , XBOX_KEY_LENGTH );
   c0:
   if (0!= s )
      closesocket(s);
   return hr;
}


HRESULT
TestVerifyPerBoxData(IN SOCKET s)
{
   DATA_PACKET dp;
   EEPROM_LAYOUT* eeprom = (EEPROM_LAYOUT*) dp.byteData;
   XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
   XBOX_USER_SETTINGS* userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

/*
   WriteEEPROM( &dp);
   switch(VerifyPerBoxData()){
   case NTE_BAD_DATA:
   }
  */ 
   return S_OK;
}

HRESULT
SendBackEEPROMContents(IN SOCKET s)
{
   
   CONST PCHAR SZDATAFILE = "t:\\EEPROMContents.dat";
   HRESULT   hr = S_OK;
   CNetWorkConnection cnc( s );
   DATA_PACKET InBuffer;
   DATA_PACKET dpEEPROM;
   char buffer[256];


   // Read out the EEPROM and send what we have
   sprintf(dpEEPROM.szMessage, "EEPROM DATA" );
   /*
      The flag XboxHardwareInfo is defined in init.h under.
      ntos\inc. This controls if the machine is a devkit 
      or if it is a retail box. We'll used the same thing 
      to tell our test program that the devkit has a
      Zero Hard Drive Key.
             
      #if !defined(_NTSYSTEM_)
      extern const XBOX_HARDWARE_INFO* XboxHardwareInfo;
      #else
      extern XBOX_HARDWARE_INFO XboxHardwareInfo;
      #endif
      
      //
      //  Define XboxHardwareFlags - a list of 
      //  flags indicating hardware differences
      //  the title libraries must know about.
      //
      #define XBOX_HW_FLAG_INTERNAL_USB_HUB   0x00000001
      #define XBOX_HW_FLAG_DEVKIT_KERNEL      0x00000002
   */
   
   g_xv.DrawText("FLAGS  %lu", XboxHardwareInfo->Flags );
   g_xv.DrawText("Kernel %lu", XBOX_HW_FLAG_DEVKIT_KERNEL );

   if ( !(XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL)) {
      // retail 
      dpEEPROM.bDevKit = FALSE;
   } else {
      dpEEPROM.bDevKit = TRUE;
   }


   hr = ReadEEPROM ( &dpEEPROM );
   if ( FAILED( hr ) ) {
      g_xv.DrawText("FAILED to read EEPROM, returned %x", hr );
      hr = E_FAIL;
      goto c0;
   } else
      g_xv.DrawText("SUCCEEDED in reading EEPROM");

   FileToDrive(SZDATAFILE, dpEEPROM.byteData, sizeof(dpEEPROM.byteData), APPEND_FILE );
   sprintf(buffer,"\n-----------------------------------------------------\n");
   FileToDrive( SZDATAFILE, buffer,strlen( buffer ), APPEND_FILE);


   // Send the EEPROM over.
   if ( SOCKET_ERROR == cnc.SendData(&dpEEPROM, sizeof(dpEEPROM))) {
      hr = E_FAIL;
      goto c0;
   }
   c0:
   if (0 != s ) {
      closesocket(s);
      s = 0;
   }

   return hr;
}



HRESULT
LockHardDrive(IN SOCKET s, 
              IN BOOL bLock)
{

   CNetWorkConnection cnc( s );
   DATA_PACKET dpOut= {0};
   char buffer[256];
   HRESULT hr = S_OK;

   if (TRUE == bLock) {
      g_xv.DrawText("Locking Harddrive.");
      VerifyPerBoxData();
      // Send the operation over.
      sprintf(dpOut.szMessage,"%s","Locking Hardrive");
      if ( SOCKET_ERROR == cnc.SendData(&dpOut, sizeof(dpOut))) {
         hr = E_FAIL;
         goto c0;
      }

   } else if ( FALSE == bLock) {
      g_xv.DrawText("UnLocking Harddrive.");
      UnlockXboxHardDrive( NULL, 0 );
      // Send the operation over.
      sprintf(dpOut.szMessage,"%s","UnLocking Hardrive");
      if ( SOCKET_ERROR == cnc.SendData(&dpOut, sizeof(dpOut))) {
         hr = E_FAIL;
         goto c0;
      }
   } else {
      g_xv.DrawText("Nothing.");
   }

   c0:
   if (0 != s ){
      closesocket(s);
      s = 0;
   }
   return S_OK;
}


BOOL
ReadFileIntoBuffer (IN char* szFileName, 
                    IN BYTE* bFile,
                    IN DWORD dwSizeOfBuffer)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/27/2001

    Routine Description:
        This routine will read the contents of a file into bFile
    Arguments:
        The name of the file to read and a buffer to put it in.
        Size of buffer to writeinto.
    Return Value:
      True for success; False for failure.
--*/
{

   HANDLE h;

   DWORD dwNumberOfBytesToRead = dwSizeOfBuffer;
   DWORD dwNumberOfBytesRead;
   h = CreateFile ( szFileName, 
                    GENERIC_READ,
                    FILE_SHARE_WRITE,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
   ReadFile( h, 
             bFile,
             dwNumberOfBytesToRead,
             &dwNumberOfBytesRead, 
             NULL );
   CloseHandle(h);

   return TRUE;
}

BOOL
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
        This routine creates a thread.
    Arguments:
        The Thread Function address.
        The Paremer to the function.
    Return Value:

--*/

{
   HANDLE   hThread;
   hThread = CreateThread(NULL,
                          0,
                          lpStartAddress,
                          (LPVOID)Param,
                          0,
                          NULL);
   if (hThread == NULL) {
      g_xv.DrawText("CreateThread() failed: %d", GetLastError());
      return FALSE;
   }
   CloseHandle(hThread);
   return TRUE;
}






BOOL
WriteEEPROM ( IN PDATA_PACKET dpData )
{

   BYTE bSaveEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   BYTE bQueryEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT* eeprom;
   XBOX_FACTORY_SETTINGS* factorySettings;
   XBOX_USER_SETTINGS* userSettings;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
   NTSTATUS status;
   DWORD type, size;
   BOOL bResult;
   // Copy the databuffer to the EEPROM structure.
   RtlCopyMemory(bSaveEEPROMMemory, dpData->byteData, EEPROM_TOTAL_MEMORY_SIZE );

   eeprom = (EEPROM_LAYOUT*) bSaveEEPROMMemory;
   factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
   userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
   pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

   
   // write EEPROM Data
   status = ExSaveNonVolatileSetting( XC_MAX_ALL, REG_BINARY, bSaveEEPROMMemory, EEPROM_TOTAL_MEMORY_SIZE);
   if (!NT_SUCCESS(status)) {
      g_xv.DrawText("ExSaveNonVolatileSetting FAILED");
      return E_FAIL;
   }
   
   // read EEPROM Data, this will ensure that what we write is the same as what we have in 
   // the EEPROM.
   RtlZeroMemory(bQueryEEPROMMemory,EEPROM_TOTAL_MEMORY_SIZE);
   status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, bQueryEEPROMMemory, PACKET_DATA_SIZE, &size);
   if (!NT_SUCCESS(status)) {
      g_xv.DrawText("ExQueryNonVolatileSetting FAILED");
      return E_FAIL;
   }
   dpData->ulDataSize = size;

   if( TRUE == RtlEqualMemory(bQueryEEPROMMemory,bSaveEEPROMMemory,EEPROM_TOTAL_MEMORY_SIZE)){
      return S_OK;
   }else
      return S_OK;
}



HRESULT
ReadEEPROM ( IN PDATA_PACKET dpData )
{

   BYTE bEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT* eeprom;
   XBOX_FACTORY_SETTINGS* factorySettings;
   XBOX_USER_SETTINGS* userSettings;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
   NTSTATUS status;
   DWORD type, size;
   BOOL bResult;

   eeprom               = (EEPROM_LAYOUT*) bEEPROMMemory;
   factorySettings      = (XBOX_FACTORY_SETTINGS*)    &eeprom->FactorySection;
   userSettings         = (XBOX_USER_SETTINGS*)       &eeprom->UserConfigSection;
   pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA)  &eeprom->EncryptedSection;
   
   // read EEPROM Data
   status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, bEEPROMMemory, EEPROM_TOTAL_MEMORY_SIZE, &size);
   if (!NT_SUCCESS(status)) {
      g_xv.DrawText("ExQueryNonVolatileSetting FAILED");
      dpData->ulDataSize = 0;
      return E_FAIL;
   }
    
   CONST PCHAR SZDATAFILE = "t:\\WhatWasSent.log";
   // DeMorph the OnlineKey before returning it.
   // Simply put, we call morph a second time.
   // TODO: For now, the hardDrivekey is still not encrypted so we can pass it as such.
   MorphKeyByHardDriveKey( factorySettings->OnlineKey,sizeof( factorySettings->OnlineKey));
   // Copy the EEPROM over to the databuffer.
   RtlCopyMemory(dpData->byteData, eeprom, sizeof(bEEPROMMemory));
   return S_OK;
}


VOID
DebugOut (PCHAR szMessage,...)
/*++

Routine Description:
   It behaves much like printf but sends to the debugOut.

Arguments:
   same as printf.

Return Value:
   NONE

Author: Wally Ho (wallyho) April 25th, 2001   

--*/
{
   va_list vaArgs;
   char szBuffer[ MAX_PATH];

   //  Write the formatted string to the log.
   va_start( vaArgs, szMessage );
   vsprintf( szBuffer, szMessage, vaArgs );

   OutputDebugStringA( szBuffer );
   va_end  ( vaArgs );
   return;
}






VOID 
FileToDrive( LPCSTR lpFileName,
             LPVOID pvFileContents,
             DWORD dwFileSize,
             DWORD dwWriteFlags )
{

   HANDLE hFile;
   DWORD dwBytesWrote;
   DWORD dwPos;
   DWORD dwFileStyle;
   CHAR  szOperation[30];
   DWORD dwFilePosition;

   switch(dwWriteFlags)
   {
   case APPEND_FILE:
      dwFileStyle = OPEN_ALWAYS;
      sprintf(szOperation,"%s","Appending File");
      dwFilePosition = FILE_END;
         break;
   case NEW_FILE:
       dwFileStyle = CREATE_ALWAYS;
       sprintf(szOperation,"%s","New File");
       dwFilePosition = FILE_BEGIN;
         break;
      default:
      break; 
   }
   hFile = CreateFile(lpFileName, 
                      GENERIC_WRITE, 
                      FILE_SHARE_READ, 
                      NULL,
                      dwFileStyle, 
                      FILE_ATTRIBUTE_NORMAL, 
                      NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      g_xv.DrawText("%s:unable to open %s, error %X\n", szOperation,lpFileName, GetLastError());
      return;
   }

   dwPos = SetFilePointer( hFile, 0, NULL, dwFilePosition );
   if ( dwPos == INVALID_SET_FILE_POINTER ) {
      g_xv.DrawText("%s: unable to seek %s, error %X\n", szOperation, lpFileName, GetLastError());
      return;        
   }

   if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) || (dwBytesWrote != dwFileSize)) {
     g_xv.DrawText("%s: cannot write to %s, error %X\n", szOperation, lpFileName, GetLastError() );
      return;
   }
   CloseHandle(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\XEEPROMDump\XEEPROMDump.cpp ===
#include "XEEPROMDump.h"

#define DUMP_SIZE (EEPROM_TOTAL_MEMORY_SIZE + sizeof(RC4_SHA1_HEADER) + XBOX_KEY_LENGTH)

int 
__cdecl main()
{
   // Dump EEPROM Contents.
   //CXEEPROMDUMP* m = new CXEEPROMDUMP(TEXT("t:\\media\\tahoma.ttf"));
   CXEEPROMDUMP* m = new CXEEPROMDUMP(TEXT("d:\\tahoma.ttf"));
   
   CHAR szSerialNumber[ 13 ] = "";
   CHAR szFileName[ 40 ] = "";
   DATA_PACKET Data;
   WCHAR wszMUName[40];

   // Output Setup
   m->SetFontHeight(15);
   m->StartScreenThread();
   m->DrawText("Starting EEPROM Dump");

   EEPROM_LAYOUT* pel= (EEPROM_LAYOUT*)&Data.byteData;
   XBOX_FACTORY_SETTINGS* pxfs = (XBOX_FACTORY_SETTINGS*)&pel->FactorySection;
   
   
   // Read the EEPROM and dump it.
   m->ReadEEPROM(&Data );
   strncpy( szSerialNumber, (const char*)pxfs->SerialNumber,12);

   DWORD dwDeviceBitMask;
   DWORD dwReturn;
   DWORD dwReturnVal;
   CHAR sz;
   DWORD dwInsertions;                  
   DWORD dwRemovals;
   DWORD dwReturnMask;
   
   m->DrawText("Initializing MU's");
   XDEVICE_PREALLOC_TYPE xdpt = {XDEVICE_TYPE_MEMORY_UNIT, 8};
   XInitDevices( 1, &xdpt);
   dwDeviceBitMask = XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );

   for (;;) {
      // Some removal or insertion happened
      if (TRUE == XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, 
                                     &dwInsertions, &dwRemovals )) {
         if ( !dwRemovals ) {
           dwReturnMask=m->DetermineBitMask(dwInsertions); 
 
            dwReturnVal = XMountMU(dwReturnMask,
                                   HIWORD(dwInsertions)? XDEVICE_BOTTOM_SLOT : XDEVICE_TOP_SLOT, 
                                   &sz  );
            if ( ERROR_SUCCESS != dwReturnVal ) {
               m->DrawText("XMountMU error %lu", dwReturnVal);
               if ( ERROR_UNRECOGNIZED_VOLUME == dwReturnVal )
                  m->DrawText("MU unformmated");
            }

            m->DrawText("Insert:: MU Plug %lu and %s Driveletter is %c", 
                         dwReturnMask, 
                         HIWORD(dwInsertions)? "BOTTOM":"TOP", 
                         sz );
            strncpy( szSerialNumber, (const char*)pxfs->SerialNumber,12);
            sprintf( szFileName,"%c:\\%s-%s.dat",sz,"EEPROM",szSerialNumber);
            XMUNameFromDriveLetter( sz, wszMUName, sizeof( wszMUName ));
            m->DrawText("Writing %s to %S",szFileName,wszMUName);
            m->FileToDrive( szFileName, 
                            (LPVOID)&Data.byteData,
                            DUMP_SIZE,
                            NEW_FILE );
            
            //Enumerate the MU
            //m->EnumDirectory( sz );
            XUnmountMU( dwReturnMask,
                        HIWORD(dwInsertions)? XDEVICE_BOTTOM_SLOT : XDEVICE_TOP_SLOT );
         }
         else
         if ( !dwInsertions ) {
            dwReturnMask=m->DetermineBitMask(dwRemovals); 
            m->DrawText("Removed:: MU Plug %lu and %s Driveletter is %c",
                        dwReturnMask, 
                        HIWORD(dwRemovals)? "BOTTOM":"TOP", 
                        sz );
          }
      }
   }
   delete m;
}

BOOL
CXEEPROMDUMP::
EnumDirectory( IN CHAR szDrive )
{
   
   //Read in the file.
   WIN32_FIND_DATA   ffd;
   HANDLE            hFind;
   CHAR  szFindFiles[ MAX_PATH ];
   DATA_PACKET MemData;

   BYTE bEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT*  eeprom                 = (EEPROM_LAYOUT*)bEEPROMMemory;
   XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*)    &eeprom->FactorySection;
   XBOX_USER_SETTINGS* userSettings       = (XBOX_USER_SETTINGS*)       &eeprom->UserConfigSection;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA)&eeprom->EncryptedSection;



   EEPROM_LAYOUT* pel1= (EEPROM_LAYOUT*)&MemData.byteData;
   XBOX_FACTORY_SETTINGS* pxfs2 = (XBOX_FACTORY_SETTINGS*)&pel1->FactorySection;

   sprintf(szFindFiles,"%c:\\EEPROM*.dat",szDrive );
   DrawText("Looking in %s", szFindFiles );
   hFind = FindFirstFile( szFindFiles, &ffd);

   if (INVALID_HANDLE_VALUE == hFind) {
      DrawText("Could not find any files in %c:\\ Error %lu", szDrive, GetLastError() );
      return FALSE;
   }
   // else found files.
   do {
      //if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
         
         sprintf( szFindFiles,"%c:\\%s",szDrive,ffd.cFileName);
         DrawText("We found %s ", szFindFiles ); 

         ZeroMemory(&MemData,sizeof(MemData));
         ReadFileIntoBuffer ( szFindFiles, 
                             MemData.byteData,
                             sizeof(MemData.byteData));
         /*
         _tprintf(TEXT("%s\\%s\n"),szDirectory,ffd.cFileName);
         // Perform task.
         _stprintf(szFindFiles,TEXT("%s\\%s"),szDirectory,ffd.cFileName);
         ZeroMemory( eeprom, EEPROM_TOTAL_MEMORY_SIZE);
         
         ReadFileIntoBuffer( szFindFiles, (BYTE*)eeprom,  EEPROM_TOTAL_MEMORY_SIZE);

         _tprintf( "This is the HardDriveKey ");
         DumpBytesHex( pEncryptedEEPROMData->HardDriveKey, 16 );
         pEncryptedEEPROMData->GameRegion ^= XC_GAME_REGION_MANUFACTURING;
         _tprintf( "This is the GameRegion %lu\n",pEncryptedEEPROMData->GameRegion);
         
         _tprintf( "This is the SerialNumber ");
         DumpBytesChar( factorySettings->SerialNumber, 12);
         
         _tprintf( "This is the EthernetAddress ");
         DumpBytesHex( factorySettings->EthernetAddr, 6);

         _tprintf( "This is the Online Key ");
         DumpBytesHex( factorySettings->OnlineKey, 16);
         
         _tprintf( "This is the AVRegion %lu\n",factorySettings->AVRegion);
         _tprintf( "This is the Language %lu\n",userSettings->Language );
      */
      //}

   }while( FindNextFile(hFind, &ffd));
   FindClose(hFind);
   return TRUE;
}



DWORD
CXEEPROMDUMP::
DetermineBitMask(IN DWORD dwBitMask)
{


   DWORD dwReturnMask;

   if ( dwBitMask & XDEVICE_PORT0_TOP_MASK ) {
      dwReturnMask = XDEVICE_PORT0;
   } else
      if ( dwBitMask & XDEVICE_PORT0_BOTTOM_MASK  ) {
      // Port 1 Bottom
      dwReturnMask = XDEVICE_PORT0;

   } else
      if ( dwBitMask & XDEVICE_PORT1_TOP_MASK   ) {
      // Port 2 Bottom
      dwReturnMask = XDEVICE_PORT1;//MAKELONG(TOP,1);
   } else
      if ( dwBitMask &  XDEVICE_PORT1_BOTTOM_MASK ) {
      // Port 2 Bottom
      dwReturnMask = XDEVICE_PORT1;//MAKELONG(BOTTOM ,1);
   } else
      if ( dwBitMask & XDEVICE_PORT2_TOP_MASK   ) {
      // Port 3 Bottom
      dwReturnMask = XDEVICE_PORT2;//MAKELONG(TOP ,2);
   } else
      if ( dwBitMask & XDEVICE_PORT2_BOTTOM_MASK  ) {
      // Port 3 Bottom
      dwReturnMask = XDEVICE_PORT2;//MAKELONG(BOTTOM ,2);
   } else
      if ( dwBitMask & XDEVICE_PORT3_TOP_MASK  ) {
      // Port 4 Bottom
      dwReturnMask = XDEVICE_PORT3;//MAKELONG(TOP ,3);
   } else
      if ( dwBitMask & XDEVICE_PORT3_BOTTOM_MASK  ) {
      // Port 4 Bottom
      dwReturnMask = XDEVICE_PORT3;//MAKELONG(BOTTOM , 3 );
   }
   return dwReturnMask;

}

HRESULT
CXEEPROMDUMP::
ReadFileIntoBuffer (IN char* szFileName, 
                    IN BYTE* bFile,
                    IN DWORD dwSizeOfBuffer)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/27/2001

    Routine Description:
        This routine will read the contents of a file into bFile
    Arguments:
        The name of the file to read and a buffer to put it in.
        Size of buffer to writeinto.
    Return Value:
      True for success; False for failure.
--*/
{

   HANDLE h;

   DWORD dwNumberOfBytesToRead = dwSizeOfBuffer;
   DWORD dwNumberOfBytesRead;
   h = CreateFile ( szFileName, 
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,// | FILE_FLAG_NO_BUFFERING,
                    NULL);

   if ( h == INVALID_HANDLE_VALUE ) {
      DrawText("CreatFile Failed");
      return FALSE;
   }
   
   ReadFile( h, 
             bFile,
             dwNumberOfBytesToRead,
             &dwNumberOfBytesRead, 
             NULL );
   CloseHandle(h);

   return TRUE;
}






HRESULT
CXEEPROMDUMP::
ReadEEPROM ( IN PDATA_PACKET dpData )
{

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
   BOOL bResult; 
   NTSTATUS status;
   DWORD type, size;
   BYTE bEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT* eeprom                  = (EEPROM_LAYOUT*)bEEPROMMemory;
   XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*)&eeprom->FactorySection;
   XBOX_USER_SETTINGS* userSettings       = (XBOX_USER_SETTINGS*)   &eeprom->UserConfigSection;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA)&eeprom->EncryptedSection;

   BYTE bEncryptedTail[sizeof(RC4_SHA1_HEADER) + XBOX_KEY_LENGTH];

   // read EEPROM Data
   status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, bEEPROMMemory, EEPROM_TOTAL_MEMORY_SIZE, &size);
   if (!NT_SUCCESS(status)) {
      DebugOut("ExQueryNonVolatileSetting FAILED");
      dpData->ulDataSize = 0;
      return E_FAIL;
   }

   //
   // Decrypt the Encrypted part of the EEPROM if it is encrypted.
   //
   if (!RtlEqualMemory(pEncryptedEEPROMData->HardDriveKey,ZERO_KEY,XBOX_KEY_LENGTH))
   {
      // Only Encrypt if it is not a dev kit
      //
      bResult = rc4HmacDecrypt(
                              (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
                              pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
                              (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
      if ( !bResult ) {
         DrawText("Decrypting HardriveKey and GameRegion Failed");
      }
   }

   // DeMorph the OnlineKey before returning it.
   // Simply put, we call morph a second time.
   // TODO: For now, the hardDrivekey is still not encrypted so we can pass it as such.
   MorphKeyByHardDriveKey( factorySettings->OnlineKey,sizeof( factorySettings->OnlineKey));

   //
   // Create Encrypted Tail Section
   //
   ASSERT( sizeof(pEncryptedEEPROMData->HardDriveKey) == XBOX_KEY_LENGTH );
   RtlCopyMemory( bEncryptedTail+sizeof(RC4_SHA1_HEADER), pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH );
   rc4HmacEncrypt(
       pEncryptedEEPROMData->EncHeader, // use as confounder
       factorySettings->OnlineKey, sizeof( factorySettings->OnlineKey),
       bEncryptedTail+sizeof(RC4_SHA1_HEADER), XBOX_KEY_LENGTH,
       (LPBYTE)bEncryptedTail );

   //
   // Zero out critical memory
   //
   RtlZeroMemory( pEncryptedEEPROMData->EncHeader, sizeof(pEncryptedEEPROMData->EncHeader) );
   RtlZeroMemory( factorySettings->OnlineKey, sizeof( factorySettings->OnlineKey) );
   RtlZeroMemory( pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) );
   
   // Copy the EEPROM over to the databuffer.
   ASSERT( sizeof(bEEPROMMemory) + sizeof(bEncryptedTail) == DUMP_SIZE );
   ASSERT( DUMP_SIZE <= sizeof(dpData->byteData) );
   RtlCopyMemory(dpData->byteData, eeprom, sizeof(bEEPROMMemory));
   RtlCopyMemory(dpData->byteData+sizeof(bEEPROMMemory), bEncryptedTail, sizeof(bEncryptedTail));
   
   return S_OK;
}


VOID
CXEEPROMDUMP::
DebugOut (PCHAR szMessage,...)
/*++

Routine Description:
   It behaves much like printf but sends to the debugOut.

Arguments:
   same as printf.

Return Value:
   NONE

Author: Wally Ho (wallyho) April 25th, 2001   

--*/
{
   va_list vaArgs;
   char szBuffer[ MAX_PATH];

   //  Write the formatted string to the log.
   va_start( vaArgs, szMessage );
   vsprintf( szBuffer, szMessage, vaArgs );

   OutputDebugStringA( szBuffer );
   va_end  ( vaArgs );
   return;
}



VOID
CXEEPROMDUMP::
FileToDrive( LPCSTR lpFileName,
             LPVOID pvFileContents,
             DWORD dwFileSize,
             DWORD dwWriteFlags )
{

   HANDLE hFile;
   DWORD dwBytesWrote;
   DWORD dwPos;
   DWORD dwFileStyle;
   CHAR  szOperation[30];
   DWORD dwFilePosition;

   switch (dwWriteFlags) {
   case APPEND_FILE:
      dwFileStyle = OPEN_ALWAYS;
      sprintf(szOperation,"%s","Appending File");
      dwFilePosition = FILE_END;
      break;
   case NEW_FILE:
      dwFileStyle = CREATE_ALWAYS;
      sprintf(szOperation,"%s","New File");
      dwFilePosition = FILE_BEGIN;
      break;
   default:
      break; 
   }
   
   hFile = CreateFile(lpFileName, 
                      GENERIC_WRITE, 
                      FILE_SHARE_READ | FILE_SHARE_WRITE, 
                      NULL,
                      dwFileStyle, 
                      FILE_ATTRIBUTE_NORMAL, 
                      NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      DebugOut("%s:unable to open %s, error %X\n", szOperation,lpFileName, GetLastError());
      return;
   }

   dwPos = SetFilePointer( hFile, 0, NULL, dwFilePosition );
   if ( dwPos == INVALID_SET_FILE_POINTER ) {
      DebugOut("%s: unable to seek %s, error %X\n", szOperation, lpFileName, GetLastError());
      return;        
   }

   if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) || (dwBytesWrote != dwFileSize)) {
      DebugOut("%s: cannot write to %s, error %X\n", szOperation, lpFileName, GetLastError() );
      return;
   }
   CloseHandle(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\PerBoxID\XEEPROMDump\XEEPROMDump.h ===
#include <ntos.h>  //ntos has to come before xtl.h
#include <xtl.h>
#include <xboxp.h>

//typedef long NTSTATUS;
//#include <init.h>
#include <xconfig.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#define ASSERT( exp )
#include <cryptkeys.h>
#include "..\\include\\fileformat.h"
#include "..\\include\\DataPacket.h"
#include "..\include\CXboxVideo.h"
#include "CXCrypto.h"

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
// Prototypes


CONST WORD TOP   = 1;
CONST WORD BOTTOM= 0;
  

class CXEEPROMDUMP: public CXBoxVideo, public CXCrypto {


   public:

      CXEEPROMDUMP(IN LPTSTR szFontDirectory): CXBoxVideo(szFontDirectory){}
      
      CXEEPROMDUMP( VOID ){}
      ~CXEEPROMDUMP( VOID ){}

      DWORD
      DetermineBitMask(IN DWORD dwBitMask);
      
      HRESULT
      ReadEEPROM ( IN PDATA_PACKET dpData );
      
      BOOL
      EnumDirectory( IN CHAR szDrive );

      HRESULT
      ReadFileIntoBuffer (IN char* szFileName, 
                          IN BYTE* bFile,
                          IN DWORD dwSizeOfBuffer);

      VOID 
      FileToDrive( LPCSTR lpFileName,
                   LPVOID pvFileContents,
                   DWORD dwFileSize,
                   DWORD dwWriteFlags );
   
      VOID DebugOut (PCHAR szMessage,...);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perf\dvdperftest\dvdperftest.cpp ===
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>


// Globals
HANDLE gLogHandle;
DISK_GEOMETRY gDiskGeometry;
LARGE_INTEGER gFrequency;
UCHAR *gcBuf;
ULONG gErrorLBA; // most recent Error LBA
USHORT gSecurityChunk = 4608;
USHORT gMaxErrors = 3;

struct ErrorLBA {
	ULONG LBA;
	USHORT NumErrors;
	ErrorLBA* Next;
};

// List of Bad LBAs
ErrorLBA* LBAList = NULL;


// List functions
VOID ListInsert(ErrorLBA*& LBAList, ULONG LBA) {
	ErrorLBA* NewLBA = new ErrorLBA;
	NewLBA->LBA = LBA;
	NewLBA->NumErrors = 1;
	NewLBA->Next = LBAList;
	LBAList = NewLBA;
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Added LBA = %u to bad list", LBA);
}


ErrorLBA* ListSearch(ErrorLBA*& LBAList, ULONG LBA) {
	ErrorLBA* CurrLBA;

	for(CurrLBA = LBAList; CurrLBA != NULL; CurrLBA = CurrLBA->Next) {
		
		if(CurrLBA->LBA == LBA) {
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Found LBA = %u, NumErrors = %u", CurrLBA->LBA, CurrLBA->NumErrors);
			return CurrLBA;
		}
	}
	// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Didn't find LBA = %u", LBA);
	return NULL;
}


VOID
GetDriveID(char* device, char* model, char* serial, char* firmware) {
    unsigned i;
    DWORD returned;
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;


    RtlInitObjectString(&VolumeString, device);
    InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    status = NtCreateFile(&fileHandle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(strstr(device, "CdRom") != NULL) atapt->IdeReg.bCommandReg = 0xa1;
    else atapt->IdeReg.bCommandReg = 0xec;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             FALSE);
    NtClose(fileHandle);

    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 ) {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
    }
    model[i] = 0;
    //DebugPrint("Model Number: %s\n", model);

    for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 ) {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
    }
    serial[i] = 0;
    //DebugPrint("Serial Number: %s\n", serial);

    for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 ) {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    firmware[i] = 0;
    //DebugPrint("Firmware Revision: %s\n", firmware);

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Model Number: %s", model);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Serial Number: %s", serial);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Firmware Revision: %s", firmware);

}


VOID
LogSenseData(SENSE_DATA SenseData) {
	// Log SenseData
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData ErrorCode:  0x%.2x", SenseData.ErrorCode);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Valid:  0x%.2x", SenseData.Valid);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SegmentNumber:  0x%.2x", SenseData.SegmentNumber);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKey:  0x%.2x", SenseData.SenseKey);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Reserved:  0x%.2x", SenseData.Reserved);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData IncorrectLength:  0x%.2x", SenseData.IncorrectLength);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData EndOfMedia:  0x%.2x", SenseData.EndOfMedia);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData FileMark:  0x%.2x", SenseData.FileMark);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[0]:  0x%.2x", SenseData.Information[0]);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[1]:  0x%.2x", SenseData.Information[1]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[2]:  0x%.2x", SenseData.Information[2]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[3]:  0x%.2x", SenseData.Information[3]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData AdditionalSenseLength:  0x%.2x", SenseData.AdditionalSenseLength);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[0]:  0x%.2x", SenseData.CommandSpecificInformation[0]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[1]:  0x%.2x", SenseData.CommandSpecificInformation[1]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[2]:  0x%.2x", SenseData.CommandSpecificInformation[2]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[3]:  0x%.2x", SenseData.CommandSpecificInformation[3]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData AdditionalSenseCode:  0x%.2x", SenseData.AdditionalSenseCode);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData AdditionalSenseCodeQualifier:  0x%.2x", SenseData.AdditionalSenseCodeQualifier);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData FieldReplaceableUnitCode:  0x%.2x", SenseData.FieldReplaceableUnitCode);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[0]:  0x%.2x", SenseData.SenseKeySpecific[0]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[1]:  0x%.2x", SenseData.SenseKeySpecific[1]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[2]:  0x%.2x", SenseData.SenseKeySpecific[2]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[3]:  0x%.2x", SenseData.SenseKeySpecific[3]);	
}


LARGE_INTEGER
ReadLBA(HANDLE hDevice, ULONG LBA, USHORT Sectors) {
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	SENSE_DATA SenseData;
	DWORD cbBytesReturned;
	PCDB Cdb;
	LARGE_INTEGER StartTime, EndTime, ReturnValue;
	BOOL bReturn;

    RtlZeroMemory(&PassThrough, sizeof(PassThrough));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = gcBuf;
    PassThrough.DataTransferLength = Sectors*gDiskGeometry.BytesPerSector;

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB10.OperationCode = SCSIOP_READ;
	Cdb->CDB10.ForceUnitAccess = 1;
	Cdb->CDB10.LogicalBlock = RtlUlongByteSwap(LBA);
	Cdb->CDB10.TransferBlocks = RtlUshortByteSwap(Sectors);

	// Start timer
	QueryPerformanceCounter(&StartTime);

    bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	// Stop timer
	QueryPerformanceCounter(&EndTime);

	if((!bReturn) || (cbBytesReturned > 0)) {

		ReturnValue.QuadPart = -1;
		if(!bReturn) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, Sectors = %u, LastError = %d", LBA, Sectors, GetLastError());
			//ReturnValue.QuadPart = -1;
		}

		if(cbBytesReturned > 0) {

			// If got a command error, set ReturnValue to indicate result
			if(SenseData.SenseKey == 0x05 && SenseData.AdditionalSenseCode == 0x81) {
				gErrorLBA = LBA;
				ReturnValue.QuadPart = 0;
			}

			// If got a read, cache fill, insufficient time or hardware error, keep track of error LBA and set ReturnValue to indicate result
			else if( (SenseData.SenseKey == 0x03 && SenseData.AdditionalSenseCode == 0x80) ||
					 (SenseData.SenseKey == 0x01 && SenseData.AdditionalSenseCode == 0x80) ||
					 (SenseData.SenseKey == 0x06 && SenseData.AdditionalSenseCode == 0x2e) ||
					 (SenseData.SenseKey == 0x04 && SenseData.AdditionalSenseCode == 0x00) ) {
				gErrorLBA = LBA;
				ReturnValue.QuadPart = -2;
				
				// Is this LBA already on the bad list?
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Looking for LBA = %u on bad list", LBA);
				ErrorLBA* ThisLBA = ListSearch(LBAList, LBA);

				
				// If LBA was found, increment its number of errors
				if(ThisLBA != NULL) {
					xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Incrementing LBA = %u's NumErrors from %u to %u", ThisLBA->LBA, ThisLBA->NumErrors, (ThisLBA->NumErrors)+1);
					++(ThisLBA->NumErrors);
				}

				// If LBA was not found, add it
				else {
					xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Adding LBA = %u to bad list", LBA);
					ListInsert(LBAList, LBA);
				}
			}

			else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, cbBytesReturned > 0", LBA);
				LogSenseData(SenseData);
			}
		}
	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SCSIOP_READ LBA = %u, Sectors = %u, %f ms", LBA, Sectors, 1000.0*(EndTime.QuadPart - StartTime.QuadPart)/gFrequency.QuadPart);
		ReturnValue.QuadPart = EndTime.QuadPart - StartTime.QuadPart;
	}
	
	return ReturnValue;
}


DOUBLE
AccessTime(HANDLE hDevice, ULONG Start, ULONG End, ULONG Reps) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG LBA;

	// Initialize
	TotalTime.QuadPart = 0;
	ReturnVal = 1.0/(DOUBLE)Reps;
	/*
	// Goto End
	ReturnTime = ReadLBA(hDevice, End,1);
	if(ReturnTime.QuadPart == -1) {
			return -1;
	} 
	*/
	// LBA = Start;

	LBA = End;
	while(Reps > 0) {

		// Is Start LBA on the bad list?
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Looking for LBA = %u on bad list before attempting to read", i*MaxSectors + Start);
		ErrorLBA* StartLBA = ListSearch(LBAList, Start);

		// If Start LBA is on list with 3 errors, skip it
		if(StartLBA != NULL && StartLBA->NumErrors == 3) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "More than 3 Read/Cache Fill/Insufficient Time/Hardware Errors encountered at LBA = %u. Terminating test...", StartLBA->LBA);
			return -1;
		}

		// Is End LBA on the bad list?
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Looking for LBA = %u on bad list before attempting to read", i*MaxSectors + Start);
		ErrorLBA* EndLBA = ListSearch(LBAList, End);

		// If End LBA is on list with 3 errors, skip it
		if(EndLBA != NULL && EndLBA->NumErrors == 3) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "More than 3 Read/Cache Fill/Insufficient Time/Hardware Errors encountered at LBA = %u. Terminating test...", EndLBA->LBA);
			return -1;
		}

		// Access the LBA
		ReturnTime = ReadLBA(hDevice, LBA, 1);
		if(ReturnTime.QuadPart == -1) {
			return -1;
		} 
		else if(ReturnTime.QuadPart == 0) { // if got a command error, in security chunk so can't complete test
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Command Error encountered at LBA = %u. Terminating test...", gErrorLBA);
			return -1;
		} 
		
		else if(ReturnTime.QuadPart == -2) { // if got a read, cache fill, insufficient time or hardware error, try again
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Retrying read...", gErrorLBA);
		} 
		else { // if last read was successful, swap LBA between Start and End and go on to next rep
			TotalTime.QuadPart += ReturnTime.QuadPart;
			if(LBA == Start) {
				LBA = End;
			} 
			else {
				LBA = Start;
			}
			--Reps;
		}
	}

	// return average access time in ms (already initialized to 1/Reps)
	ReturnVal *= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= (DOUBLE)gFrequency.QuadPart;
	ReturnVal *= 1000.0;	// convert to ms
	return ReturnVal;
}


DOUBLE
StreamTime(HANDLE hDevice, ULONG Start, ULONG End, USHORT MaxSectors) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG i, Reps, SectorsRead = 0;
	// ULONG TotalSectors = End - Start + 1;
	USHORT RemainSectors, Retry;

	// Init Totaltime
	TotalTime.QuadPart = 0;

	// Compute Reps based on Sectors and 64 sector limit per read
	Reps = (End - Start + 1)/MaxSectors;
	RemainSectors = (USHORT)((End - Start + 1)%MaxSectors);

	/*
	// Is Start LBA on the bad list?
	// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Looking for LBA = %u on bad list before attempting to read", i*MaxSectors + Start);
	ErrorLBA* StartLBA = ListSearch(LBAList, Start);

	// If Start LBA is on list with 3 errors, skip it
	if(StartLBA != NULL && StartLBA->NumErrors == 3) {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "More than 3 Read/Cache Fill/Insufficient Time/Hardware Errors encountered at LBA = %u. Skipping...", ThisLBA->LBA);
		continue;
	}

	ReturnTime = ReadLBA(hDevice, Start, 1);
	if(ReturnTime.QuadPart == -1) {
		return -1;
	}
	*/
	for(i=0; i<Reps; ++i) {
 
		// Is this LBA on the bad list?
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Looking for LBA = %u on bad list before attempting to read", i*MaxSectors + Start);
		ErrorLBA* ThisLBA = ListSearch(LBAList, i*MaxSectors + Start);

		// If LBA is on list with 3 errors, skip it
		if(ThisLBA != NULL && ThisLBA->NumErrors == 3) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "More than 3 Read/Cache Fill/Insufficient Time/Hardware Errors encountered at LBA = %u. Skipping...", ThisLBA->LBA);
			continue;
		}
				
		ReturnTime = ReadLBA(hDevice, i*MaxSectors + Start, MaxSectors);
		
		if(ReturnTime.QuadPart == -1) {
			return -1;
		} 
		
		else if(ReturnTime.QuadPart == 0) { // if got a command error, jump ahead 8.5 megs to get out of security chunk
			i += (gSecurityChunk/MaxSectors - 1);
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Command Error encountered at LBA = %u. Jumping out of security area...", gErrorLBA);
		} 
		
		else if(ReturnTime.QuadPart == -2) { // if got a read, cache fill, insufficient time or hardware error, check when it occurred
			
			if(i<Reps/4) { // got error early in test, so start over
				return 0;
			} 
			
			else { // got error late in test, so try again
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Retrying read...", gErrorLBA);
			}
		} 
		
		else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			SectorsRead += MaxSectors;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	if(RemainSectors > 0) {
		do {
			// Is this LBA on the bad list?
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Looking for LBA = %u on bad list before attempting to read", i*MaxSectors + Start);
			ErrorLBA* ThisLBA = ListSearch(LBAList, Reps*MaxSectors + Start);

			// If LBA is on list with 3 errors, skip it
			if(ThisLBA != NULL && ThisLBA->NumErrors == 3) {
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "More than 3 Read/Cache Fill/Insufficient Time/Hardware Errors encountered at LBA = %u. Skipping...", ThisLBA->LBA);
				break;
			}

			Retry = 0;
			ReturnTime = ReadLBA(hDevice, Reps*MaxSectors + Start, RemainSectors);
		
			if(ReturnTime.QuadPart == -1) {
				return -1;
			} 
		
			else if(ReturnTime.QuadPart == 0) { // if got a command error, can't read remaining sectors
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Command Error encountered at LBA = %u. Jumping out of security area...", gErrorLBA);
			} 
		
			else if(ReturnTime.QuadPart == -2) { // if got a read error, try again
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Retrying read...", gErrorLBA);
				Retry = 1;
			} 
		
			else {
				TotalTime.QuadPart += ReturnTime.QuadPart;
				SectorsRead += RemainSectors;
				// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
			}
		} while(Retry);
	}

	// return elapsed time in mbits/s
	ReturnVal = (DOUBLE)SectorsRead;
	ReturnVal *= (DOUBLE)gDiskGeometry.BytesPerSector;
	ReturnVal *= (DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= 131072.0;	// convert to mbits
	return ReturnVal;
}


VOID
WINAPI
DVDPerfStartTest(HANDLE LogHandle) {
	HANDLE hDevice;
	BOOL bReturn, bDoAuth;
    DWORD cbBytesReturned;
	SENSE_DATA SenseData;
	DOUBLE dTime;
	
	USHORT MaxSectors;
	char cdModel[64], cdSerial[64], cdFirmware[64];
	LARGE_INTEGER NumSectors;
	ULONG StartLBA = 0, NumReps = 200;

	// Set global log handle
	gLogHandle = LogHandle;

	// Get timer frequency (ticks/sec)
	QueryPerformanceFrequency(&gFrequency);

    xSetOwnerAlias(gLogHandle, "t-msanto");
	xSetComponent(gLogHandle, "Perf", "DVDPerfTest");
    xSetFunctionName(gLogHandle, "DriveInfo");

	// open device
	hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,NULL);

	if(hDevice == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "CreateFile FAILED LastError = %d", GetLastError());
		return;
	}

	xStartVariation( gbConsoleOut, gLogHandle, "DVD Drive Info" );

	// Get DVD drive info
	GetDriveID("\\Device\\CdRom0", cdModel, cdSerial, cdFirmware);
	
	// Get authentication parameter from ini
	bDoAuth = (BOOL)GetProfileInt(TEXT("dvdperftest"), TEXT("DoAuth"), 0);
	// Authenticate a Xbox DVD 
	// If the media is not a Xbox DVD, then don't care if this fails
	if(bDoAuth) {
		bReturn = DeviceIoControl(hDevice, IOCTL_CDROM_AUTHENTICATION_SEQUENCE, 
									NULL, 0, 
									&SenseData, sizeof(SenseData),
									&cbBytesReturned, NULL);

		if((!bReturn) || (cbBytesReturned > 0)) {
			if(!bReturn) {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE FAILED LastError = %d", GetLastError());
			}

			if(cbBytesReturned > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE cbBytesReturned > 0");
				LogSenseData(SenseData);
			}
		} else {
			xLog(gbConsoleOut, gLogHandle, XLL_PASS, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE Succeeded");
		}
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE Not performed");
	}
	
	// get geometry
	bReturn = DeviceIoControl(hDevice, IOCTL_CDROM_GET_DRIVE_GEOMETRY, 
								NULL, 0, 
								&gDiskGeometry, sizeof(gDiskGeometry), 
								&cbBytesReturned, 
								NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_CDROM_GET_DRIVE_GEOMETRY FAILED LastError = %d", GetLastError());
		CloseHandle(hDevice);
		return;
	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %08x:%08x", gDiskGeometry.Cylinders.HighPart, gDiskGeometry.Cylinders.LowPart);
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u", gDiskGeometry.Cylinders.LowPart);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u", gDiskGeometry.Cylinders.QuadPart);
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "MediaType = %s", gDiskGeometry.MediaType);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "TracksPerCylinder = %u", gDiskGeometry.TracksPerCylinder);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SectorsPerTrack = %u", gDiskGeometry.SectorsPerTrack);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "BytesPerSector = %u", gDiskGeometry.BytesPerSector);
	}

	// get number of sectors
	NumSectors.QuadPart = gDiskGeometry.Cylinders.QuadPart * gDiskGeometry.TracksPerCylinder * gDiskGeometry.SectorsPerTrack;
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "NumberOfSectors = %u", NumSectors.QuadPart);

	// allocate gcBuf
	gcBuf = (UCHAR *)VirtualAlloc(NULL, 64*gDiskGeometry.BytesPerSector, MEM_COMMIT, PAGE_READWRITE);
	if(gcBuf == NULL) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "VirtualAlloc (%u bytes) FAILED LastError = %d", 
				64*gDiskGeometry.BytesPerSector, GetLastError());
		CloseHandle(hDevice);
		return;
	}
	
	xSetFunctionName(gLogHandle, "AccessPerf");

	// Measure average access times
	xStartVariation( gbConsoleOut, gLogHandle, "Both Layers" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Both Layers) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Both Layers) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0) FAILED");
	}

	xStartVariation( gbConsoleOut, gLogHandle, "1 Layer w/ Transition" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart/2)+1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart/2)+1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (1 Layer w/ Transition) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (1 Layer w/ Transition) FAILED");
	}

	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart/2, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart/2, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Inner 1/2" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart/4)-1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart/4)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0, Inner 1/2) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0, Inner 1/2) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "1/2 Layer w/ Transition" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart*3/4)+1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart*3/4)+1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (1/2 Layer w/ Transition) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (1/2 Layer w/ Transition) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Outer 1/2" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart/4, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart/4, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0, Outer 1/2) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0, Outer 1/2) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Outer 1/2" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*3/4)-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*3/4)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1, Outer 1/2) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1, Outer 1/2) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Inner 1/2" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart*3/4, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart*3/4, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1, Inner 1/2) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1, Inner 1/2) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Inner 1/3" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart/6)-1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart/6)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0, Inner 1/3) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0, Inner 1/3) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "1/3 Layer w/ Transition" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart*5/6)+1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart*5/6)+1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (1/3 Layer w/ Transition) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (1/3 Layer w/ Transition) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Outer 1/3" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart/3, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart/3, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0, Outer 1/3) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0, Outer 1/3) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Outer 1/3" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*2/3)-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*2/3)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1, Outer 1/3) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1, Outer 1/3) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Inner 1/3" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart*5/6, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart*5/6, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1, Inner 1/3) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1, Inner 1/3) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Inner 1/4" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart/8)-1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart/8)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0, Inner 1/4) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0, Inner 1/4) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "1/4 Layer w/ Transition" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", StartLBA, ((ULONG)NumSectors.QuadPart*7/8)+1, NumReps);
	
	dTime = AccessTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart*7/8)+1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (1/4 Layer w/ Transition) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (1/4 Layer w/ Transition) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Outer 1/4" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart*3/8, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart*3/8, ((ULONG)NumSectors.QuadPart/2)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 0, Outer 1/4) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 0, Outer 1/4) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Outer 1/4" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*5/8)-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*5/8)-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1, Outer 1/4) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1, Outer 1/4) FAILED");
	}
	// xEndVariation(gLogHandle);

	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Inner 1/4" );
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, NumReps = %u", (ULONG)NumSectors.QuadPart*7/8, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	dTime = AccessTime(hDevice, (ULONG)NumSectors.QuadPart*7/8, (ULONG)NumSectors.QuadPart-1, NumReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Access Time (Layer 1, Inner 1/4) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Access Time (Layer 1, Inner 1/4) FAILED");
	}
	// xEndVariation(gLogHandle);


	xSetFunctionName(gLogHandle, "StreamPerf");
	
	// Measure data stream rates
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Quarter 1");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", StartLBA, ((ULONG)NumSectors.QuadPart/8)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, StartLBA, ((ULONG)NumSectors.QuadPart/8)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 0, Q1, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 0, Q1, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Quarter 2");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart/8, ((ULONG)NumSectors.QuadPart/4)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart/8, ((ULONG)NumSectors.QuadPart/4)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 0, Q2, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 0, Q2, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Quarter 3");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart/4, ((ULONG)NumSectors.QuadPart*3/8)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart/4, ((ULONG)NumSectors.QuadPart*3/8)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 0, Q3, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 0, Q3, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 0, Quarter 4");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart*3/8, ((ULONG)NumSectors.QuadPart/2)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart*3/8, ((ULONG)NumSectors.QuadPart/2)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 0, Q4, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 0, Q4, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer Transition");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart*7/16, ((ULONG)NumSectors.QuadPart*9/16)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart*7/16, ((ULONG)NumSectors.QuadPart*9/16)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer Trans, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer Trans, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Quarter 1");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*5/8)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart/2, ((ULONG)NumSectors.QuadPart*5/8)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 1, Q1, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 1, Q1, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Quarter 2");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart*5/8, ((ULONG)NumSectors.QuadPart*3/4)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart*5/8, ((ULONG)NumSectors.QuadPart*3/4)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 1, Q2, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 1, Q2, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Quarter 3");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart*3/4, ((ULONG)NumSectors.QuadPart*7/8)-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart*3/4, ((ULONG)NumSectors.QuadPart*7/8)-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 1, Q3, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered  at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 1, Q3, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	xStartVariation( gbConsoleOut, gLogHandle, "Layer 1, Quarter 4");
	for(USHORT i = 0; i <=6; ++i) {
		MaxSectors = 1<<i;

		//if(MaxSectors != 8 && MaxSectors != 32 ) {
			xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", (ULONG)NumSectors.QuadPart*7/8, (ULONG)NumSectors.QuadPart-1, MaxSectors);
		
			dTime = StreamTime(hDevice, (ULONG)NumSectors.QuadPart*7/8, (ULONG)NumSectors.QuadPart-1, MaxSectors);
		
			if(dTime > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Avg Sustained Data Rate (Layer 1, Q4, MS = %u) = %f Mbits/s", MaxSectors, dTime);
			} else if(dTime == 0) {
				--i;
				xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Read/Cache Fill/Insufficient Time/Hardware Error encountered at LBA = %u.  Restarting test...", gErrorLBA);
			} else {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Avg Sustained Data Rate (Layer 1, Q4, MS = %u) FAILED", MaxSectors);
			}
		//}
	}
	
	// free gcBuf
	if(!VirtualFree(gcBuf, 0, MEM_RELEASE)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "VirtualFree FAILED LastError = %d", GetLastError());
	}

	// close device
	if(!CloseHandle(hDevice)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "CloseHandle FAILED LastError = %d", GetLastError());
	}
}


VOID WINAPI
DVDPerfEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\dvdperftest.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("DVDPerfTest: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		xDebugStringA("DVDPerfTest: End - Waiting for reboot...\n");
		Sleep(INFINITE);
    }
	
	gbConsoleOut = TRUE;

	// Start Test
	DVDPerfStartTest(LogHandle);

	// End Test
	DVDPerfEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("DVDPerfTest: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	// xlog
	xCloseLog(LogHandle);
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dvdperftest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dvdperftest )
    EXPORT_TABLE_ENTRY( "StartTest", DVDPerfStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DVDPerfEndTest )
END_EXPORT_TABLE( dvdperftest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\win2k\perfbvt_server.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    perfbvt_server.cpp

Abstract:

    Perf BVT test server program (runs on win2k)

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock2.h>

//
// Debug spews
//
#define ASSERT(cond) do { if (!(cond)) DoAssert(__FILE__, __LINE__, #cond); } while(0)
inline VOID DoAssert(CHAR* filename, INT linenum, CHAR* msg) {
    fprintf(stderr, "!!! ASSERTION FAILED: %s(%d) - %d\n", filename, linenum, GetLastError());
    fprintf(stderr, "    %s\n", msg);
    exit(-1);
}

CHAR* programname;
struct sockaddr_in clientaddr;
HANDLE startevent;
HANDLE tcptestthread, udptestthread;

//
// Various port numbers
//
#define SERVER_PORT     6001
#define TCP_TEST_PORT   6002
#define UDP_TEST_PORT   6003
#define MIN_UDP_DGRAM   4
#define MAX_UDP_DGRAM   128
#define UDP_DGRAM_COUNT (64*1024)
#define MIN_TCP_SEND    1
#define MAX_TCP_SEND    4096
#define TCP_BYTE_COUNT  (32*1024*1024)

// Create a socket of the specified type and bind it to a particular port
SOCKET CreateSocket(INT type, USHORT port)
{
    SOCKET s = socket(AF_INET, type, 0);

    if (s != INVALID_SOCKET) {
        struct sockaddr_in sockname;
        INT err;

        memset(&sockname, 0, sizeof(sockname));
        sockname.sin_family = AF_INET;
        sockname.sin_port = htons(port);
        err = bind(s, (struct sockaddr*) &sockname, sizeof(sockname));
        if (err != NO_ERROR) {
            closesocket(s);
            s = INVALID_SOCKET;
        }
    }
    return s;
}


//
// Park and Miller pseudo-random number generator
//  x = 48271 * x % 2147483647
//  range: [1..2147483646]
//
ULONG _randseed = 1;
inline VOID Srand(ULONG seed) {
    _randseed = seed;
}

#pragma warning(disable:4035)
inline ULONG Rand() {
    __asm {
        mov eax, 48271
        mul _randseed
        mov ebx, 2147483647
        div ebx
        mov _randseed, edx
        mov eax, edx
    }
}
#pragma warning(default:4035)


//
// TCP test thread
//
DWORD WINAPI TcpTestThread(VOID* param)
{
    SOCKET tcpsock = CreateSocket(SOCK_STREAM, TCP_TEST_PORT);
    ASSERT(tcpsock != INVALID_SOCKET);
    
    INT err = listen(tcpsock, 1);
    ASSERT(err == NO_ERROR);

    SOCKET s = accept(tcpsock, NULL, NULL);
    ASSERT(s != INVALID_SOCKET);

    // Fix random number sequence
    Srand('TCPS');

    // Receive 32MB sent in 4KB blocks
    CHAR buf[MAX_TCP_SEND];
    INT total = TCP_BYTE_COUNT;
    INT count;
    while (total) {
        count = recv(s, buf, MAX_TCP_SEND, 0);
        ASSERT(count > 0);
        total -= count;
    }

    // Send 32MB in 4KB blocks
    total = TCP_BYTE_COUNT;
    while (total) {
        count = min(total, MAX_TCP_SEND);
        count = send(s, buf, count, 0);
        ASSERT(count != SOCKET_ERROR);
        total -= count;
    }

    // Receive 32MB sent in variable size blocks
    total = TCP_BYTE_COUNT;
    while (total) {
        count = recv(s, buf, MAX_TCP_SEND, 0);
        ASSERT(count > 0);
        total -= count;
    }

    // Send 32MB in variable size blocks
    total = TCP_BYTE_COUNT;
    while (total) {
        count = MIN_TCP_SEND + Rand() % (MAX_TCP_SEND-MIN_TCP_SEND+1);
        count = min(count, total);
        count = send(s, buf, count, 0);
        ASSERT(count != SOCKET_ERROR);
        total -= count;
    }

    closesocket(s);
    closesocket(tcpsock);
    return 0;
}


//
// UDP test thread
//
DWORD WINAPI UdpTestThread(VOID* param)
{
    SOCKET udpsock = CreateSocket(SOCK_DGRAM, UDP_TEST_PORT);
    ASSERT(udpsock != INVALID_SOCKET);

    // Wait for the test to start
    WaitForSingleObject(startevent, INFINITE);

    struct sockaddr_in sockname;
    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(UDP_TEST_PORT);
    sockname.sin_addr = clientaddr.sin_addr;

    INT err = connect(udpsock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    CHAR buf[MAX_UDP_DGRAM];
    memset(buf, 0, sizeof(buf));

    fd_set fdset1;
    fd_set fdset2;
    fd_set* readfds;
    fd_set* writefds;

    UINT sendseq = 0;
    UINT recvseq = 0;

    while (TRUE) {
        if (recvseq < UDP_DGRAM_COUNT-2) {
            FD_ZERO(&fdset1);
            FD_SET(udpsock, &fdset1);
            readfds = &fdset1;
        } else {
            readfds = NULL;
        }

        if (sendseq < UDP_DGRAM_COUNT && recvseq != 0) {
            FD_ZERO(&fdset2);
            FD_SET(udpsock, &fdset2);
            writefds = &fdset2;
        } else {
            writefds = NULL;
        }

        if (!readfds && !writefds) break;
        INT count = select(0, readfds, writefds, NULL, NULL);
        ASSERT(count > 0);

        if (readfds && FD_ISSET(udpsock, readfds)) {
            // Fix random number sequence
            if (recvseq == 0) {
                Srand('UDPS');
            }
            count = recv(udpsock, buf, sizeof(buf), 0);
            if (count >= MIN_UDP_DGRAM) {
                // Assme the other end has already close the socket
                recvseq = UDP_DGRAM_COUNT;
            } else {
                recvseq = *((UINT*) buf);
            }
        }

        if (writefds && FD_ISSET(udpsock, writefds)) {
            count = MIN_UDP_DGRAM + Rand() % (MAX_UDP_DGRAM-MIN_UDP_DGRAM+1);
            *((UINT*) buf) = ++sendseq;
            err = send(udpsock, buf, count, 0);
            ASSERT(err == count);
        }
    }

    Sleep(100);
    closesocket(udpsock);
    return 0;
}


//
// Test selections
//
#define MAX_TEST_OPTION_LINELEN 512
#define MAX_TEST_OPTIONS 16
CHAR* testoptionfile;
CHAR* testoptions[MAX_TEST_OPTIONS];
INT numtestoptions;

inline VOID sendstr(SOCKET s, CHAR* buf)
{
    INT len = strlen(buf) + 1;
    while (len) {
        INT count = send(s, buf, len, 0);
        ASSERT(count != SOCKET_ERROR);
        buf += count;
        len -= count;
    }
}

VOID SendTestSelections(SOCKET s)
{
    for (INT i=0; i < numtestoptions; i++) {
        sendstr(s, testoptions[i]);
    }

    if (testoptionfile) {
        FILE* fin = fopen(testoptionfile, "r");
        ASSERT(fin != NULL);

        CHAR buf[MAX_TEST_OPTION_LINELEN];
        CHAR* p;
        while (fgets(buf, sizeof(buf), fin)) {
            // strip newline and inline comments
            p = buf;
            while (*p && *p != '#' && *p != '\r' && *p != '\n') p++;
            *p = '\0';

            // strip trailing spaces
            p--;
            while (p >= buf && isspace(*p)) *p-- = '\0';

            // strip leading spaces
            p = buf;
            while (*p && isspace(*p)) p++;

            if (*p) { sendstr(s, p); }
        }

        fclose(fin);
    }

    // Send an empty line to indicate the end of selections
    sendstr(s, "");
}


// Print out program usage information and exit
VOID usage()
{
    fprintf(stderr, "usage: %s [options]\n", programname);
    fprintf(stderr,
        "-o output-file\n"
        "   save the test log to the specified file\n"
        "-t test-selection\n"
        "   specify a test selection in the following format:\n"
        "     test-name[,repeat-count[,test-param]]\n"
        "   test-name is the name of the test function\n"
        "   repeat-count specifies how many times the test is run\n"
        "   test-param is a string that'll be passed to the test\n"
        "-i test-selection-file\n"
        "   read test selections from the specified file\n"
        "If there are no -t or -i options, all test functions are run once by default\n");

    exit(1);
}

//
// Main program
//
INT __cdecl main(INT argc, CHAR** argv)
{
    programname = *argv++;
    argc--;

    // Parse command line options
    FILE* fout = NULL;
    while (argc) {
        CHAR* opt = *argv;
        if (*opt != '-' && *opt != '/' || argc < 2) usage();

        switch (opt[1]) {
        case 'o':
            if (fout) usage();
            fout = fopen(argv[1], "wb");
            ASSERT(fout != NULL);
            break;

        case 'i':
            if (testoptionfile) usage();
            testoptionfile = argv[1];
            break;

        case 't':
            if (numtestoptions >= MAX_TEST_OPTIONS) usage();
            testoptions[numtestoptions++] = argv[1];
            break;

        default:
            usage();
        }

        argc -= 2;
        argv += 2;
    }

    // Run all tests by default
    if (!numtestoptions && !testoptionfile)
        testoptions[numtestoptions++] = "ALL";

    // Default output is the console
    if (!fout) fout = stdout;

    // Initialize winsock
    WSADATA wsadata;
    INT err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    // Create separate threads for handling TCP and UDP tests
    startevent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ASSERT(startevent != NULL);

    DWORD tid;
    tcptestthread = CreateThread(NULL, 0, TcpTestThread, NULL, 0, &tid);
    ASSERT(tcptestthread != NULL);

    udptestthread = CreateThread(NULL, 0, UdpTestThread, NULL, 0, &tid);
    ASSERT(udptestthread != NULL);

    // Create the server socket 
    // which is used for logging test results.
    SOCKET listensock = CreateSocket(SOCK_STREAM, SERVER_PORT);
    ASSERT(listensock != INVALID_SOCKET);

    fprintf(stderr, "Listening for connection...\n");
    err = listen(listensock, 1);
    ASSERT(err == NO_ERROR);

    INT addrlen = sizeof(clientaddr);
    SOCKET serversock = accept(listensock, (struct sockaddr*) &clientaddr, &addrlen);
    ASSERT(serversock != INVALID_SOCKET);

    fprintf(fout, "Established connection with %s...\n", inet_ntoa(clientaddr.sin_addr));
    SetEvent(startevent);

    // Send test selections to the target machine
    SendTestSelections(serversock);

    while (TRUE) {
        CHAR buf[1024];
        INT count = recv(serversock, buf, sizeof(buf), 0);
        ASSERT(count != SOCKET_ERROR);
        if (count == 0) break;
        fwrite(buf, 1, count, fout);
    }

    SuspendThread(tcptestthread);
    CloseHandle(tcptestthread);
    SuspendThread(udptestthread);
    CloseHandle(udptestthread);
    fprintf(stderr, "Test completed.\n");

    closesocket(serversock);
    closesocket(listensock);
    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\d3dperf.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    d3dperf.cpp

Abstract:

    D3D related perf BVT tests

--*/

#include "precomp.h"

DECLARE_TEST_FUNCTION(TriCTest)
{
    static const struct {
        FLOAT x,y,z,w;
        DWORD color;
    } vertices[] = {
        {320.0f,  50.0f, 0.5f, 1.0f, 0xffff0000, },
        {620.0f, 430.0f, 0.5f, 1.0f, 0xff00ff00, },
        { 20.0f, 430.0f, 0.5f, 1.0f, 0xff0000ff, },
    };

    UINT count = testparam ? atoi(testparam) : 2000;
    ULONG time = ReadTimestamp();
    HRESULT hr = S_OK;

    while (count--) {
        hr |= d3ddev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00404040, 1.0, 0);
        hr |= d3ddev->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
        hr |= d3ddev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
        hr |= d3ddev->DrawVerticesUP(D3DPT_TRIANGLELIST, 3, vertices, sizeof(vertices[0]));
        hr |= d3ddev->Present(NULL, NULL, NULL, NULL);
    }

    ASSERT(SUCCEEDED(hr));
    return ReadTimestamp() - time;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\diskperf.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    diskperf.cpp

Abstract:

    Disk related perf BVT tests

--*/

#include "precomp.h"

//
// This is a hidden test function to set file cache size
//
DECLARE_TEST_FUNCTION(SetFileCacheSize)
{
    UINT fileCacheSize = testparam ? atoi(testparam) : 256;
    if (fileCacheSize && XSetFileCacheSize(fileCacheSize*1024)) {
        Print("File cache size set to %dKB...\n", fileCacheSize);
    }

    return 0;
}


//
// Calculate disk read/write speed (in 0.001 MB/s unit)
//
inline DWORD CalcRWSpeed(DWORD bytecount, DWORD msecs) {
    return (DWORD) ((((ULONGLONG) bytecount) * 1000 * 1000) /
                    (((ULONGLONG) msecs) * 1024 * 1024));
}


#define TESTFILENAME    "z:\\perftest.dat"
#define TESTFILESIZE    (32*1024*1024)
#define FILEBUFSIZE     (32*1024)
#define READBUFSIZE     (32*1024)
#define WRITEBUFSIZE    (8*1024)

#define DISK_FUNCTION_COMMON_PROLOG(mode, flags) \
        ULONG time; \
        HANDLE file; \
        DWORD total=0, count, cb; \
        BOOL ok; \
        VOID* buf = valloc(FILEBUFSIZE); \
        ASSERT(buf != NULL); \
        memset(buf, 0xff, FILEBUFSIZE); \
        time = ReadTimestamp(); \
        file = CreateFile( \
                    testparam ? testparam : TESTFILENAME, \
                    mode, \
                    0, \
                    NULL, \
                    (mode == GENERIC_WRITE) ? CREATE_ALWAYS : OPEN_EXISTING, \
                    FILE_ATTRIBUTE_NORMAL|flags, \
                    NULL); \
        ASSERT(file != INVALID_HANDLE_VALUE)

#define DISK_FUNCTION_COMMON_EPILOG() \
        time = ReadTimestamp() - time; \
        CloseHandle(file); \
        vfree(buf); \
        LogEntry(curtestname, CalcRWSpeed(total, time), "MB/s"); \
        return 0

//
// Write disk file sequentially, in variable size blocks
//
DECLARE_TEST_FUNCTION(DiskWriteVariable)
{
    // Fix the random number sequence
    Srand('DSKW');

    DISK_FUNCTION_COMMON_PROLOG(GENERIC_WRITE, FILE_FLAG_SEQUENTIAL_SCAN);

    do {
        count = Rand() % WRITEBUFSIZE + 1;
        ok = WriteFile(file, buf, count, &cb, NULL) && (cb == count);
        ASSERT(ok);
        total += count;
    } while (total < TESTFILESIZE);

    DISK_FUNCTION_COMMON_EPILOG();
}


//
// Write a 32MB disk file seqentially, and in 8KB blocks
//
DECLARE_TEST_FUNCTION(DiskWrite8KBlock)
{
    DISK_FUNCTION_COMMON_PROLOG(
        GENERIC_WRITE,
        FILE_FLAG_SEQUENTIAL_SCAN|FILE_FLAG_WRITE_THROUGH|FILE_FLAG_NO_BUFFERING);

    // Set file size first
    //  This reduces disk access to update the FAT directory

    DWORD pos1 = SetFilePointer(file, TESTFILESIZE, NULL, FILE_BEGIN);
    ok = SetEndOfFile(file);
    DWORD pos0 = SetFilePointer(file, 0, NULL, FILE_BEGIN);
    ASSERT(pos1 != 0xffffffff && ok && pos0 != 0xffffffff);

    do {
        count = WRITEBUFSIZE;
        ok = WriteFile(file, buf, count, &cb, NULL) && (cb == count);
        ASSERT(ok);
        total += count;
    } while (total < TESTFILESIZE);

    DISK_FUNCTION_COMMON_EPILOG();
}


//
// Read a 32MB file sequentially, in 32KB blocks
//
DECLARE_TEST_FUNCTION(DiskReadSeq32KBlock)
{
    DISK_FUNCTION_COMMON_PROLOG(
        GENERIC_READ,
        FILE_FLAG_SEQUENTIAL_SCAN|FILE_FLAG_NO_BUFFERING);

    do {
        count = READBUFSIZE;
        ok = ReadFile(file, buf, count, &cb, NULL) && (cb == count);
        ASSERT(ok);
        total += count;
    } while (total < TESTFILESIZE);

    DISK_FUNCTION_COMMON_EPILOG();
}


//
// Read a 32MB file sequentially, in variable size blocks
//
DECLARE_TEST_FUNCTION(DiskReadSeqVariable)
{
    DISK_FUNCTION_COMMON_PROLOG(GENERIC_READ, FILE_FLAG_SEQUENTIAL_SCAN);

    do {
        count = Rand() % READBUFSIZE + 1;
        if (count > TESTFILESIZE-total)
            count = TESTFILESIZE-total;
        ok = ReadFile(file, buf, count, &cb, NULL) && (cb == count);
        ASSERT(ok);
        total += count;
    } while (total < TESTFILESIZE);

    DISK_FUNCTION_COMMON_EPILOG();
}


//
// Read a file using random access, in variable size blocks
//
DECLARE_TEST_FUNCTION(DiskReadRandomAccess)
{
    DISK_FUNCTION_COMMON_PROLOG(GENERIC_READ, 0);

    do {
        DWORD pos = Rand() % TESTFILESIZE;
        pos = SetFilePointer(file, pos, NULL, FILE_BEGIN);
        ASSERT(pos != 0xffffffff);

        count = Rand() % READBUFSIZE + 1;
        if (count > TESTFILESIZE-pos)
            count = TESTFILESIZE-pos;
        ok = ReadFile(file, buf, count, &cb, NULL) && (cb == count);
        ASSERT(ok);
        total += count;
    } while (total < TESTFILESIZE);

    DISK_FUNCTION_COMMON_EPILOG();
}


//
// File allocation test
//  win2k-1: < 0.1s
//  win2k-2: 76+s
//  xbox: 0.2 - 1.3s (depending on what's on the drive)
//
#define MIN_FILEALLOC_SIZE (128*1024*1024)
#define MAX_FILEALLOC_SIZE (384*1024*1024)

DECLARE_TEST_FUNCTION(FileAllocation)
{
    Srand('FATA');
    ULONG starttime = ReadTimestamp();

    CHAR* testfilename = testparam ? testparam : TESTFILENAME;
    UINT loopcnt = 5;
    while (loopcnt--) {
        HANDLE file = CreateFile(
                        testfilename,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH,
                        NULL);
        ASSERT(file != INVALID_HANDLE_VALUE);

        DWORD fileoffset;
        DWORD filesize = MIN_FILEALLOC_SIZE +
                         Rand() % (MAX_FILEALLOC_SIZE-MIN_FILEALLOC_SIZE+1);

        fileoffset = SetFilePointer(file, filesize, NULL, FILE_BEGIN);
        ASSERT(fileoffset == filesize);

        BOOL seteofok = SetEndOfFile(file);
        ASSERT(seteofok);

        CloseHandle(file);
    }

    DeleteFile(testfilename);
    return ReadTimestamp() - starttime;
}


//
// Directory and file enumeration tests
//
#define DEFAULT_TESTDIR "z:\\perftest.dir"
#define NUM_TESTFILES 2048

VOID GenTestFilename(CHAR* buf, UINT index) {
    static const CHAR hexdigits[] = "0123456789abcdef";
    for (INT digit=0; digit < 8; digit++) {
        *buf++ = hexdigits[index&0xf];
        index = index >> 4;
    }
    *buf++ = '\0';
}

#define DIRECTORY_FUNCTION_COMMON_PROLOG() \
        CHAR* testdir = testparam ? testparam : DEFAULT_TESTDIR; \
        INT testdirlen = strlen(testdir); \
        ASSERT(testdirlen < MAX_PATH-10); \
        CHAR testfilename[MAX_PATH]; \
        CHAR* p = testfilename; \
        strcpy(p, testdir); \
        p += testdirlen; \
        *p++ = '\\'; \
        BOOL ok; \
        UINT i; \
        HANDLE file; \
        DWORD filesize, cb; \
        VOID* buf = valloc(FILEBUFSIZE); \
        ASSERT(buf != NULL); \
        ULONG starttime = ReadTimestamp()

#define DIRECTORY_FUNCTION_COMMON_EPILOG() \
        ULONG stoptime = ReadTimestamp(); \
        vfree(buf); \
        return (stoptime - starttime)

//
// Create the test directory
// and then create 4096 files of sizes between 0 and 4KB
//
//  win2k-1: 18+s
//  win2k-2: 27+s
//  xbox: 280+s (with default file cache size 64KB)
//      ~11s (with file cache size set to 512KB)
//
DECLARE_TEST_FUNCTION(CreateDirAndFiles)
{
    Srand('DIRS');

    DIRECTORY_FUNCTION_COMMON_PROLOG();

    ok = CreateDirectory(testdir, NULL);
    ASSERT(ok);

    for (i=0; i < NUM_TESTFILES; i++) {
        GenTestFilename(p, i);
        file = CreateFile(
                    testfilename,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH,
                    NULL);
        ASSERT(file != INVALID_HANDLE_VALUE);

        filesize = Rand() % (WRITEBUFSIZE+1);
        ok = WriteFile(file, buf, filesize, &cb, NULL);
        ASSERT(ok && cb == filesize);

        CloseHandle(file);
    }

    DIRECTORY_FUNCTION_COMMON_EPILOG();
}

//
// Enumerate the test directory and open/read each file
//  win2k-1: 37+s (after fresh reboot)
//  win2k-2: 5.5 - 7+s (after fresh reboot)
//  xbox: ~8s
//
DECLARE_TEST_FUNCTION(EnumDirAndReadFiles)
{
    DIRECTORY_FUNCTION_COMMON_PROLOG();

    HANDLE findhandle;
    WIN32_FIND_DATA finddata;

    strcpy(p, "*");
    findhandle = FindFirstFile(testfilename, &finddata);
    ASSERT(findhandle != INVALID_HANDLE_VALUE);

    i = 0;
    do {
        if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) continue;
        strcpy(p, finddata.cFileName);
        file = CreateFile(
                    testfilename,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
        ASSERT(file != INVALID_HANDLE_VALUE);

        filesize = GetFileSize(file, NULL);
        ASSERT(filesize <= WRITEBUFSIZE);

        ok = ReadFile(file, buf, filesize, &cb, NULL);
        ASSERT(ok && cb == filesize);

        CloseHandle(file);
        i++;
    } while (FindNextFile(findhandle, &finddata));
    ASSERT(i == NUM_TESTFILES);

    FindClose(findhandle);
    DIRECTORY_FUNCTION_COMMON_EPILOG();
}
    
//
// Remove the test directory and all files underneath it
//  win2k-1: ~2.6s
//  win2k-2: ~1s
//  xbox: ~2.4s
//
DECLARE_TEST_FUNCTION(DeleteDirAndFiles)
{
    DIRECTORY_FUNCTION_COMMON_PROLOG();

    HANDLE findhandle;
    WIN32_FIND_DATA finddata;

    strcpy(p, "*");
    findhandle = FindFirstFile(testfilename, &finddata);
    ASSERT(findhandle != INVALID_HANDLE_VALUE);

    i = 0;
    do {
        if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) continue;
        strcpy(p, finddata.cFileName);
        ok = DeleteFile(testfilename);
        ASSERT(ok);
    } while (FindNextFile(findhandle, &finddata));
    FindClose(findhandle);

    ok = RemoveDirectory(testdir);
    ASSERT(ok);

    DIRECTORY_FUNCTION_COMMON_EPILOG();
}

//
// Streaming files off DVD disk
//
#define BLOCK_SIZE      (2*1024)
#define SAMPLE_INTERVAL (256*1024*1024)
#define SAMPLE_PERIOD   (8*1024*1024)

BOOL DvdStreamFile(CHAR* filename, VOID* buf, UINT bufsize)
{
    ASSERT(bufsize % BLOCK_SIZE == 0);
    ASSERT(SAMPLE_INTERVAL % bufsize == 0);
    ASSERT(SAMPLE_PERIOD % bufsize == 0);

    HANDLE file = CreateFile(
                    filename,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL|
                        FILE_FLAG_NO_BUFFERING|
                        FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    if (file == INVALID_HANDLE_VALUE)
        return FALSE;

    LogEntry(filename, 0, "");

    BOOL done = FALSE;
    DWORD block = 0;

    while (TRUE) {
        // Seek to the beginning of the current block and
        // read a little data first to take the seek time out of consideration.
        LARGE_INTEGER pos;
        pos.QuadPart = (LONGLONG) block * bufsize;
        pos.LowPart = SetFilePointer(file, pos.LowPart, &pos.HighPart, FILE_BEGIN);
        if (pos.LowPart == 0xffffffff &&
            GetLastError() != NO_ERROR)
            break;

        DWORD cb;
        ReadFile(file, buf, bufsize, &cb, NULL);

        DWORD time = ReadTimestamp();
        DWORD count = SAMPLE_PERIOD / bufsize;
        while (count--) {
            if (!ReadFile(file, buf, bufsize, &cb, NULL) || cb != bufsize) {
                done = TRUE;
                break;
            }
        }
        if (done) break;

        time = ReadTimestamp() - time;

        CHAR msg[16];
        sprintf(msg, "%d", block * (bufsize / BLOCK_SIZE));

        LogEntry(msg, CalcRWSpeed(SAMPLE_PERIOD, time), "MB/s");
        block += SAMPLE_INTERVAL / bufsize;
    }

    CloseHandle(file);
    return TRUE;
}

DECLARE_TEST_FUNCTION(DvdStreamingTest)
{
    UINT bufsize = 16;
    LogEntry("DvdStreamingTest", bufsize*1000, "KB");
    bufsize *= 1024;

    VOID* buf = valloc(bufsize);
    ASSERT(buf != NULL);

    if (testparam) {
        // Stream files off DVD
        INT fileno = 1;
        CHAR filename[32];
        do {
            sprintf(filename, "a:\\video_ts\\vts_01_%d.vob", fileno++);
        } while (DvdStreamFile(filename, buf, bufsize));
    } else {
        // Raw disk access
        DvdStreamFile("cdrom0:", buf, bufsize);
    }

    vfree(buf);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\memtests.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    memtests.cpp

Abstract:

    Memory throughput tests

--*/

#include "precomp.h"

#define KB          1024
#define MB          (1024*1024)
#define PAGESIZE    (4*KB)
#define MAXBUFSIZE  (4096*PAGESIZE)
#define MEMTESTSIZE (16*MAXBUFSIZE)

//
// Memory read/write access functions using SSE instructions
//  We assume all buffers are 256-byte aligned and
//  buffer size is also a multiple of 256.
//
#ifndef USE_SSE
#define ZeroMem(buf, bufsize) memset(buf, 0, bufsize)
#define CopyMem memcpy
#else // USE_SSE
VOID ZeroMem(VOID* buf, ULONG bufsize)
{
    __asm {
        xorps   xmm0, xmm0
        mov     ecx, buf
        mov     edx, bufsize
        shr     edx, 7
    L1: movdqa  [ecx+0*16], xmm0
        movdqa  [ecx+1*16], xmm0
        movdqa  [ecx+2*16], xmm0
        movdqa  [ecx+3*16], xmm0
        movdqa  [ecx+4*16], xmm0
        movdqa  [ecx+5*16], xmm0
        movdqa  [ecx+6*16], xmm0
        movdqa  [ecx+7*16], xmm0
        add     ecx, 8*16
        dec     edx
        jnz     L1
    }
}

VOID CopyMem(VOID* dstbuf, const VOID* srcbuf, ULONG bufsize)
{
    __asm {
        mov     ecx, srcbuf
        mov     ebx, dstbuf
        mov     edx, bufsize
        shr     edx, 7
    L1: movdqa  xmm0, [ecx+0*16]
        movdqa  xmm1, [ecx+1*16]
        movdqa  xmm2, [ecx+2*16]
        movdqa  xmm3, [ecx+3*16]
        movdqa  xmm4, [ecx+4*16]
        movdqa  xmm5, [ecx+5*16]
        movdqa  xmm6, [ecx+6*16]
        movdqa  xmm7, [ecx+7*16]
        movdqa  [ebx+0*16], xmm0
        movdqa  [ebx+1*16], xmm1
        movdqa  [ebx+2*16], xmm2
        movdqa  [ebx+3*16], xmm3
        movdqa  [ebx+4*16], xmm4
        movdqa  [ebx+5*16], xmm5
        movdqa  [ebx+6*16], xmm6
        movdqa  [ebx+7*16], xmm7
        add     ecx, 8*16
        add     ebx, 8*16
        dec     edx
        jnz     L1
    }
}
#endif // USE_SSE

VOID ReadMem(const VOID* buf, ULONG bufsize)
{
    __asm {
        mov     ecx, buf
        mov     edx, bufsize
        shr     edx, 7
    L1:
        movdqa  xmm0, [ecx+0*16]
        movdqa  xmm1, [ecx+1*16]
        movdqa  xmm2, [ecx+2*16]
        movdqa  xmm3, [ecx+3*16]
        movdqa  xmm4, [ecx+4*16]
        movdqa  xmm5, [ecx+5*16]
        movdqa  xmm6, [ecx+6*16]
        movdqa  xmm7, [ecx+7*16]
        add     ecx, 8*16
        dec     edx
        jnz     L1
    }
}

inline VOID LogMemoryThroughput(CHAR* testname, ULONG time, ULONG size=MEMTESTSIZE/MB) {
    ULONG result = (size * 1000000) / time;
    LogEntry(testname, result, "MB/s");
}

DECLARE_TEST_FUNCTION(MemoryTests)
{
    DWORD protect = 0;
    DWORD ormask = 0;
    if (testparam) {
        if (strcmp(testparam, "WC") == 0) {
            // write-combined memory
            protect = PAGE_WRITECOMBINE;
        } else if (strcmp(testparam, "NC") == 0) {
            // uncached memory
            protect = PAGE_NOCACHE;
        } else if (strcmp(testparam, "AGP") == 0) {
            // write-combined memory accessed through AGP aperture
            protect = PAGE_WRITECOMBINE;
            ormask = 0xf0000000;
        }
    }

    #ifdef USE_SSE
    DbgPrint("MemoryTests: use SSE functions...\n");
    #endif

    Srand('MEMX');
    VOID* membuf = (BYTE*) XPhysicalAlloc(MAXBUFSIZE, MAXULONG_PTR, 0, PAGE_READWRITE|protect);
    ASSERT(membuf != NULL);

    BYTE* buf = (BYTE*) ((DWORD) membuf | ormask);

    // Read 4KB memory buffer
    ULONG time = ReadTimestamp();
    INT count = MEMTESTSIZE / PAGESIZE;
    while (count--) {
        ReadMem(buf, PAGESIZE);
    }
    LogMemoryThroughput("MemRead4K", ReadTimestamp() - time);

    // Read 16MB memory buffer
    time = ReadTimestamp();
    count = MEMTESTSIZE / MAXBUFSIZE;
    while (count--) {
        ReadMem(buf, MAXBUFSIZE);
    }
    LogMemoryThroughput("MemRead16M", ReadTimestamp() - time);

    // Fill 4KB memory buffer
    time = ReadTimestamp();
    count = MEMTESTSIZE / PAGESIZE;
    while (count--) {
        ZeroMem(buf, PAGESIZE);
    }
    LogMemoryThroughput("MemFill4K", ReadTimestamp() - time);

    // Fill 16MB memory buffer
    time = ReadTimestamp();
    count = MEMTESTSIZE / MAXBUFSIZE;
    while (count--) {
        ZeroMem(buf, MAXBUFSIZE);
    }
    LogMemoryThroughput("MemFill16M", ReadTimestamp() - time);

    // Copy 4KB memory buffer
    time = ReadTimestamp();
    count = MEMTESTSIZE / PAGESIZE;
    while (count--) {
        CopyMem(buf, buf + PAGESIZE, PAGESIZE);
    }
    LogMemoryThroughput("MemCopy4K", ReadTimestamp() - time);

    // Copy 8MB memory buffer
    #define COPYMEMSIZE (MAXBUFSIZE/2)
    time = ReadTimestamp();
    count = MEMTESTSIZE / COPYMEMSIZE;
    while (count--) {
        CopyMem(buf, buf+COPYMEMSIZE, COPYMEMSIZE);
    }
    LogMemoryThroughput("MemCopy8M", ReadTimestamp() - time);

    // Random reads
    #define RANDRWCOUNT (MAXBUFSIZE/sizeof(ULONG))
    ULONG x, *p;
    ULONG* end = (ULONG*) (buf + MAXBUFSIZE);
    time = ReadTimestamp();
    count = 0;
    do {
        x = Rand();
        p = (ULONG*) buf + (x & (MAXBUFSIZE/sizeof(ULONG)-1));
        x &= 31;
        if (p+x > end) x = end-p;
        count += x;

        while (x--) {
            *((volatile ULONG*) p);
            p++;
        }
    } while (count < RANDRWCOUNT);
    LogMemoryThroughput("MemReadRandom", ReadTimestamp() - time, count*sizeof(ULONG)/MB);

    // Random writes
    time = ReadTimestamp();
    count = 0;
    do {
        x = Rand();
        p = (ULONG*) buf + (x & (MAXBUFSIZE/sizeof(ULONG)-1));
        x &= 31;
        if (p+x > end) x = end-p;
        count += x;
        while (x--) *p++ = 0;
    } while (count < RANDRWCOUNT);
    LogMemoryThroughput("MemWriteRandom", ReadTimestamp() - time, count*sizeof(ULONG)/MB);

    XPhysicalFree(membuf);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\perfbvt.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    perfbvt.cpp

Abstract:

    Perf BVT tests - main program

--*/

#include "precomp.h"

//
// Table of available tests
//
struct TestSelection {
    CHAR* testname;
    TESTPROC testproc;
    INT testcount;
    CHAR* testparam;
};


DECLARE_TEST_FUNCTION(MemoryTests);
DECLARE_TEST_FUNCTION(SetFileCacheSize);
DECLARE_TEST_FUNCTION(DiskWriteVariable);
DECLARE_TEST_FUNCTION(DiskWrite8KBlock);
DECLARE_TEST_FUNCTION(DiskReadSeq32KBlock);
DECLARE_TEST_FUNCTION(DiskReadSeqVariable);
DECLARE_TEST_FUNCTION(DiskReadRandomAccess);
DECLARE_TEST_FUNCTION(FileAllocation);
DECLARE_TEST_FUNCTION(CreateDirAndFiles);
DECLARE_TEST_FUNCTION(EnumDirAndReadFiles);
DECLARE_TEST_FUNCTION(DeleteDirAndFiles);
DECLARE_TEST_FUNCTION(DvdStreamingTest);

DECLARE_TEST_FUNCTION(TcpSendReceive);
DECLARE_TEST_FUNCTION(UdpSendReceive);

DECLARE_TEST_FUNCTION(TriCTest);

#define NUMTESTS (sizeof(alltests) / sizeof(alltests[0]))
#define DEFINE_TEST_ENTRY(name) { #name, name, },
TestSelection alltests[] = {
    DEFINE_TEST_ENTRY(MemoryTests)
    DEFINE_TEST_ENTRY(SetFileCacheSize)
    DEFINE_TEST_ENTRY(DiskWriteVariable)
    DEFINE_TEST_ENTRY(DiskWrite8KBlock)
    DEFINE_TEST_ENTRY(DiskReadSeq32KBlock)
    DEFINE_TEST_ENTRY(DiskReadSeqVariable)
    DEFINE_TEST_ENTRY(DiskReadRandomAccess)
    DEFINE_TEST_ENTRY(FileAllocation)
    DEFINE_TEST_ENTRY(CreateDirAndFiles)
    DEFINE_TEST_ENTRY(EnumDirAndReadFiles)
    DEFINE_TEST_ENTRY(DeleteDirAndFiles)
    DEFINE_TEST_ENTRY(DvdStreamingTest)

    #ifdef PERFBVT_SERVER
    DEFINE_TEST_ENTRY(TcpSendReceive)
    DEFINE_TEST_ENTRY(UdpSendReceive)
    #endif

    DEFINE_TEST_ENTRY(TriCTest)
};


ULONG _randseed = 1;        // Pseudo-random number seed
INT _perfCounterFreq;       // performance counter frequency
CHAR* curtestname;

SOCKET serversock;


//
// Select a specified test function
//
VOID SelectTest(CHAR* testname, INT testcount, CHAR* testparam)
{
    // Special case
    BOOL selectall = (strcmp(testname, "ALL") == 0);

    TestSelection* cur = alltests;
    TestSelection* end = cur + NUMTESTS;
    do {
        if (selectall || strcmp(testname, cur->testname) == 0) {
            cur->testcount = testcount;
            cur->testparam = testparam;
            if (!selectall) break;
        }
    } while (++cur < end);
}


//
// Receive test selections from the server
//
#define MAX_TEST_OPTION_LINELEN 512

VOID ReadTestSelections()
{
    CHAR buf[MAX_TEST_OPTION_LINELEN];
    CHAR* cur = buf;
    CHAR* end = cur + MAX_TEST_OPTION_LINELEN;

    while (TRUE) {
        INT count = end - cur;
        count = recv(serversock, cur, count, 0);
        ASSERT(count > 0);

        // Find the last nul-terminator in the buffer
        cur += count;
        CHAR* q = cur;
        while (q != buf && q[-1]) q--;

        if (q == buf) {
            // No nul-terminator is found.
            // The line buffer must not be full yet.
            ASSERT(cur < end);
            continue;
        }

        CHAR* testname = buf;
        CHAR* testcount;
        CHAR* testparam;

        while (testname != q) {
            // Empty line is the terminating condition
            if (*testname == '\0') return;

            CHAR* p = testname + strlen(testname) + 1;
            testparam = NULL;
            testcount = strchr(testname, ',');
            if (testcount) {
                *testcount++ = '\0';
                testparam = strchr(testcount, ',');
                if (testparam) *testparam++ = '\0';
            }

            INT n = testcount ? atoi(testcount) : 1;
            DbgPrint("Test selected: %s %d %s\n",
                testname,
                n,
                testparam ? testparam : "<null>");

            // Make a copy of the testparam string
            if (testparam) {
                testparam = _strdup(testparam);
                ASSERT(testparam != NULL);
            }

            SelectTest(testname, n, testparam);
            testname = p;
        }
        
        // Move the partial line leftover to the beginning of the buffer
        INT leftover = cur-q;
        if (leftover) {
            memmove(buf, q, leftover);
        }
        cur = &buf[leftover];
    }
}


//
// Connect to the server host
//
VOID ConnectToServer()
{
    #ifdef PERFBVT_SERVER

    DbgPrint("Initializing the network stack...\n");

    XNetStartupParams xnetparams = { sizeof(xnetparams), XNET_STARTUP_BYPASS_SECURITY };
    INT err = XNetStartup(&xnetparams);
    ASSERT(err == NO_ERROR);

    WSADATA wsadata;
    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    struct sockaddr_in sockname;
    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(SERVER_PORT);
    sockname.sin_addr.s_addr = inet_addr(PERFBVT_SERVER);

    CHAR buf[32];
    err = XNetInAddrToString(sockname.sin_addr, buf, sizeof(buf));
    ASSERT(err == NO_ERROR);
    DbgPrint("Connecting to server %s:%d...\n", buf, SERVER_PORT);

    serversock = socket(AF_INET, SOCK_STREAM, 0);
    ASSERT(serversock != INVALID_SOCKET);

    // Keep trying to connect to the server until successful
    do {
        err = connect(serversock, (struct sockaddr*) &sockname, sizeof(sockname));
        if (err != NO_ERROR) {
            DbgPrint("Failed to connect to the server, error %d\n", WSAGetLastError());
            Sleep(5000);
        }
    } while (err != NO_ERROR);

    SetSocketTimeouts(serversock);

    // Read test selection data from the server
    ReadTestSelections();

    #else // !PERFBVT_SERVER

    // When there is no server involved, just run
    // all tests once with the default parameters.
    SelectTest("ALL", 1, NULL);

    #endif // !PERFBVT_SERVER
}


//
// Disconnect from the server
//
VOID DisconnectFromServer()
{
    #ifdef PERFBVT_SERVER
    closesocket(serversock);
    WSACleanup();
    XNetCleanup();
    #endif
}

//
// Spew out a message in the log
//
VOID Print(CHAR* format, ...)
{
    static CHAR outbuf[1024];

    va_list args;
    va_start(args, format);
    vsprintf(outbuf, format, args);
    va_end(args);

    DbgPrint("%s", outbuf);

    #ifdef PERFBVT_SERVER

    INT len = strlen(outbuf);
    CHAR* p = outbuf;
    while (len) {
        INT n = send(serversock, p, len, 0);
        ASSERT(n != SOCKET_ERROR);
        p += n;
        len -= n;
    }

    #endif // PERFBVT_SERVER
}


//
// One-time D3D initialization and cleanup
//
IDirect3DDevice8* d3ddev;

VOID D3DInitialize()
{
    ULONG time = ReadTimestamp();

    IDirect3D8* d3d = Direct3DCreate8(D3D_SDK_VERSION);
    ASSERT(d3d != NULL);

    D3DPRESENT_PARAMETERS d3dpp;
    HRESULT hr;

    memset(&d3dpp, 0, sizeof(d3dpp));
    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    CHECKHR(d3d->CreateDevice(
                D3DADAPTER_DEFAULT,
                D3DDEVTYPE_HAL,
                NULL,
                D3DCREATE_HARDWARE_VERTEXPROCESSING,
                &d3dpp,
                &d3ddev));

    d3d->Release();

    CHECKHR(d3ddev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000080, 1.0, 0));
    CHECKHR(d3ddev->Present(NULL, NULL, NULL, NULL));
    d3ddev->BlockUntilIdle();

    time = ReadTimestamp() - time;
    LogEntry("D3DInitialize", time);
}


//
// Main entrypoint
//
VOID __cdecl main()
{
    LARGE_INTEGER freq;
    BOOL ok = QueryPerformanceFrequency(&freq);
    _perfCounterFreq = freq.LowPart;
    ASSERT(ok && freq.HighPart == 0 && _perfCounterFreq > 0);

    // Remember the startup time.
    // This gives us an idea of how long the boot process took.
    ULONG startup_time = ReadTimestamp();
    DbgPrint("Starting perf BVT tests...\n");

    // Establish connect to the server host
    ConnectToServer();

    LogEntry("Start-up time", startup_time);

    // D3D initialization
    D3DInitialize();

    // Run various tests
    TestSelection* cur = alltests;
    TestSelection* end = cur + NUMTESTS;
    while (cur < end) {
        INT count = cur->testcount;
        while (count--) {
            curtestname = cur->testname;
            ULONG result = (*cur->testproc)(cur->testparam);
            if (result) {
                LogEntry(curtestname, result);
            }
        }
        cur++;
    }

    // Disconnect from the server
    DisconnectFromServer();

    DbgPrint("Perf BVT tests completed...\n");
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\netperf.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netperf.cpp

Abstract:

    Network related perf BVT tests

--*/

#include "precomp.h"

#ifdef PERFBVT_SERVER

//
// TCP perf tests
//
DECLARE_TEST_FUNCTION(TcpSendReceive)
{
    // Fix random number sequence
    Srand('TCPC');

    DbgPrint("TCP send / recv tests...\n");
    ULONG time1 = ReadTimestamp();

    static CHAR buf[MAX_TCP_SEND];
    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);
    ASSERT(s != INVALID_SOCKET);

    // Set socket send/recv timeouts
    SetSocketTimeouts(s);

    struct sockaddr_in sockname;
    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TCP_TEST_PORT);
    sockname.sin_addr.s_addr = inet_addr(PERFBVT_SERVER);

    INT err = connect(s, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    //
    // Send 32MB in 4K blocks
    //
    // Initial results:
    //  win2k: 800Mhz P3, Intel EEPRO100B
    //  Xbox: 733Mhz P3, Intel EEPRO100B
    //
    //  win2k: ~3.3s
    //  xbox: ~2.8s
    //
    INT total = TCP_BYTE_COUNT;
    INT count;
    while (total) {
        count = min(total, MAX_TCP_SEND);
        count = send(s, buf, count, 0);
        ASSERT(count != SOCKET_ERROR);
        total -= count;
    }

    ULONG time2 = ReadTimestamp();

    //
    // Receive 32MB that was sent in 4K blocks
    //  win2k: ~4.1s
    //  xbox: ~2.8s
    //
    total = TCP_BYTE_COUNT;
    while (total) {
        count = recv(s, buf, MAX_TCP_SEND, 0);
        ASSERT(count > 0);
        total -= count;
    }

    ULONG time3 = ReadTimestamp();

    //
    // Send 32MB in variable size blocks
    //  win2k: ~3.5s
    //  xbox: ~2.9s
    //
    total = TCP_BYTE_COUNT;
    while (total) {
        count = MIN_TCP_SEND + Rand() % (MAX_TCP_SEND-MIN_TCP_SEND+1);
        count = min(count, total);
        count = send(s, buf, count, 0);
        ASSERT(count != SOCKET_ERROR);
        total -= count;
    }

    ULONG time4 = ReadTimestamp();

    //
    // Receive 32MB that was sent in variable size blocks
    //  win2k: ~3.8s
    //  xbox: ~2.9s
    //
    total = TCP_BYTE_COUNT;
    while (total) {
        count = recv(s, buf, MAX_TCP_SEND, 0);
        ASSERT(count > 0);
        total -= count;
    }

    closesocket(s);
    ULONG time5 = ReadTimestamp();

    LogEntry("TcpSend4KBlock", time2-time1);
    LogEntry("TcpRecv4KBlock", time3-time2);
    LogEntry("TcpSendVariable", time4-time3);
    LogEntry("TcpRecvVariable", time5-time4);

    return 0;
}


//
// UDP perf tests
//  win2k: 6.9 - 7.1s
//  xbox: 5.8s
//
DECLARE_TEST_FUNCTION(UdpSendReceive)
{
    // Fix random number sequence
    Srand('UDPC');

    DbgPrint("UDP send/recv test...\n", MIN_UDP_DGRAM, MAX_UDP_DGRAM);
    ULONG starttime = ReadTimestamp();

    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(s != INVALID_SOCKET);

    struct sockaddr_in sockname;
    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(UDP_TEST_PORT);

    INT err = bind(s, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    sockname.sin_addr.s_addr = inet_addr(PERFBVT_SERVER);
    err = connect(s, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    UINT sendseq = 0;
    UINT recvseq = 0;
    UINT totalsendbytes, totalsenddgrams;
    UINT totalrecvbytes, totalrecvdgrams;

    totalsendbytes = totalsenddgrams = 
    totalrecvbytes = totalrecvdgrams = 0;

    fd_set fdset1;
    fd_set fdset2;
    fd_set* readfds;
    fd_set* writefds;
    static CHAR buf[MAX_UDP_DGRAM];

    while (TRUE) {
        if (sendseq < UDP_DGRAM_COUNT) {
            FD_ZERO(&fdset2);
            FD_SET(s, &fdset2);
            writefds = &fdset2;
        } else {
            writefds = NULL;
        }

        if (recvseq < UDP_DGRAM_COUNT-2) {
            FD_ZERO(&fdset1);
            FD_SET(s, &fdset1);
            readfds = &fdset1;
        } else {
            readfds = NULL;
        }

        if (!readfds && !writefds) break;
        INT count = select(0, readfds, writefds, NULL, NULL);
        ASSERT(count > 0);

        if (writefds && FD_ISSET(s, writefds)) {
            count = MIN_UDP_DGRAM + Rand() % (MAX_UDP_DGRAM-MIN_UDP_DGRAM+1);
            *((UINT*) buf) = ++sendseq;
            err = send(s, buf, count, 0);
            ASSERT(err == count);
            totalsendbytes += count;
            totalsenddgrams++;
        }

        if (readfds && FD_ISSET(s, readfds)) {
            count = recv(s, buf, sizeof(buf), 0);
            ASSERT(count >= MIN_UDP_DGRAM);
            recvseq = *((UINT*) buf);
            totalrecvbytes += count;
            totalrecvdgrams++;
        }
    }

    ULONG stoptime = ReadTimestamp();
    Sleep(100);
    closesocket(s);

    DbgPrint("  send: %d datagrams, %d bytes\n", totalsenddgrams, totalsendbytes);
    DbgPrint("  recv: %d datagrams, %d bytes\n", totalrecvdgrams, totalrecvbytes);
    return stoptime-starttime;
}

#endif // PERFBVT_SERVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\testdll\testdd.cpp ===
#define NOD3D
#define NODSOUND
#include <xtl.h>
#undef  NOD3D
#undef  NODSOUND

#include <wingdi.h>
#include <ddraw.h>
#include "testdd.h"

void TestDirectDraw(void)
{
	HRESULT hr;
	LPDIRECTDRAW7 pDD;
    LPDIRECTDRAWSURFACE7 psurf = NULL, pback = NULL;
    DDSURFACEDESC2 ddsd;

    _asm int 3;
    hr = DirectDrawCreateEx(NULL, (VOID**)&pDD, IID_IDirectDraw7, NULL);
    if (pDD) {
        ZeroMemory(&ddsd, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd); 
        ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; 
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_VIDEOMEMORY |
                              DDSCAPS_FLIP | DDSCAPS_COMPLEX; 
        ddsd.dwBackBufferCount = 1;
        pDD->CreateSurface(&ddsd, &psurf, NULL);
        if (psurf) {
            DDSCAPS2 ddscaps;

            _asm int 3;
            ZeroMemory(&ddscaps, sizeof(ddscaps));
            ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
            hr = psurf->GetAttachedSurface(&ddscaps, &pback);

            if (pback) {
                pback->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);

                DWORD *lpdw;

                lpdw = (DWORD*)ddsd.lpSurface;
                lpdw += 640 * 5;

                for (int i = 0; i < 50; i++)
                    *lpdw++ = -1;

                pback->Unlock(NULL);

                _asm int 3;
                for (i = 0; i < 10; i++) {
                    psurf->Flip(NULL, DDFLIP_WAIT);
                    Sleep(5000);
                }
                pback->Release();
            }
            psurf->Release();
        }
        pDD->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\testdll\testdd.h ===
#ifdef __cplusplus
extern "C" {
#endif

void TestDirectDraw(void);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\precomp.h ===
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>

// Not sure why such convoluted macro magic is needed.
// But I can't get #pragma message() to work directly.

#ifndef PERFBVT_SERVER
#define QUOTE0(a) #a
#define QUOTE1(a) QUOTE0(a)
#define MESSAGE(a) message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define PERFBVT(s) MESSAGE("PERFBVT: " s)
#pragma PERFBVT("No server address defined. Skip network logging and tests.")
#pragma PERFBVT("To set server address, type this in your razzle build window:")
#pragma PERFBVT("   set PERFBVT_SERVER=aaa.bbb.ccc.ddd")
#endif

#include "perfbvt.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\perfbvt\xbox\perfbvt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    perfbvt.h

Abstract:

    Perf BVT tests - common declarations

--*/

#ifndef _PERFBVT_H
#define _PERFBVT_H

//
// Read the processor timestamp counter in msec
//
extern INT _perfCounterFreq;
inline ULONG ReadTimestamp() {
    LARGE_INTEGER perfCount;
    QueryPerformanceCounter(&perfCount);
    return (ULONG) (perfCount.QuadPart * 1000 / _perfCounterFreq);
}

//
// Park and Miller pseudo-random number generator
//  x = 48271 * x % 2147483647
//  range: [1..2147483646]
//
extern ULONG _randseed;
inline VOID Srand(ULONG seed) {
    _randseed = seed;
}

inline ULONG Rand() {
    __asm {
        mov eax, 48271
        mul _randseed
        mov ebx, 2147483647
        div ebx
        mov _randseed, edx
        mov eax, edx
    }
}

//
// Logging functions
//
VOID ConnectToServer();
VOID DisconnectFromServer();
VOID Print(CHAR*, ...);

inline VOID LogEntry(CHAR* entryname, ULONG result, CHAR* unit=NULL) {
    Print("%30s: %6u.%03u %s\n",
        entryname,
        result / 1000,
        result % 1000,
        unit ? unit : "(seconds)");
}

//
// Debug spew macro
//
extern "C" ULONG _cdecl DbgPrint(CHAR*, ...);
inline VOID DoAssert(CHAR* filename, INT linenum, CHAR* msg) {
    DbgPrint("!!! ASSERTION FAILED: %s(%d) - %d\n", filename, linenum, GetLastError());
    DbgPrint("    %s\n", msg);
    DebugBreak();
}

#define ASSERT(cond) do { if (!(cond)) DoAssert(__FILE__, __LINE__, #cond); } while(0)
#define CHECKHR(expr) do { hr = (expr); ASSERT(SUCCEEDED(hr)); } while (0)

//
// Server IP address and port numbers
//
#define SERVER_PORT     6001
#define TCP_TEST_PORT   6002
#define UDP_TEST_PORT   6003
#define MIN_UDP_DGRAM   4
#define MAX_UDP_DGRAM   128
#define UDP_DGRAM_COUNT (64*1024)
#define MIN_TCP_SEND    1
#define MAX_TCP_SEND    4096
#define TCP_BYTE_COUNT  (32*1024*1024)

//
// Set send/recv timeout to be 10sec
//
inline VOID SetSocketTimeouts(SOCKET s)
{
    UINT timeout = 10000;
    setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
    setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, (CHAR*) &timeout, sizeof(timeout));
}

//
// Allocate and free virtual memory pages
//
inline VOID* valloc(UINT size) {
    return VirtualAlloc(NULL, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
}

inline VOID vfree(VOID* ptr) {
    if (ptr) { VirtualFree(ptr, 0, MEM_RELEASE); }
}


//
// Declare test function prototype
//
typedef ULONG (*TESTPROC)(CHAR*);
#define DECLARE_TEST_FUNCTION(name) ULONG name(CHAR* testparam)

//
// Current test name
//
extern CHAR* curtestname;

//
// D3D device
//
extern IDirect3DDevice8* d3ddev;

#endif // !_PERFBVT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\testdll\testdll.c ===
#include <xtl.h>

// Hack! DbgPrint is much nicer than OutputDebugString so I exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
ULONG
DebugPrint(
    PCHAR Format,
    ...
    );

BOOL
WINAPI
DllEntryPoint(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    DebugPrint("testdll: DLLEntryPoint reason=%d\n", fdwReason);

    return TRUE;
}


#define MAX_BLOCKS 10
#define MAX_THREADS 10


DWORD
WINAPI
TestThreadStart(
    LPVOID lp
    );

VOID
WINAPI
IRandSeed(
    ULONG ulSeed
    );

ULONG
WINAPI
IRand( VOID );

VOID
CallMe( VOID )
{
    DWORD thid;
    int i;
    LPVOID pMem[MAX_BLOCKS];
    HLOCAL hStatus;
    LPVOID lpT;
    int nSize;
    HANDLE hThreads[MAX_THREADS];
    DWORD dwWaitStatus;
    DWORD dwExitCode;
    DWORD dwThreadId;


    OutputDebugString(L"TestDLL!CallMe entered\n");

    // Add the date and time in here, this would be way better than GetTickCount because
    // GetTickCount restarts at boot, so we probably get the same seed almost every time!
    IRandSeed(GetTickCount());

#if 0
    TestDirectDraw();
#endif

    // Allocate some memory blocks in varying sizes
    for (i = 0 ; i < MAX_BLOCKS ; i++)
    {
        nSize = IRand() % 5000;
        pMem[i] = (LPVOID)LocalAlloc(LPTR, nSize);
        DebugPrint("#%d: Allocated %d bytes as %08x\n", i, nSize, pMem[i]);
    }

    // Reallocate some memory blocks to random sizes
    for (i = 0 ; i < MAX_BLOCKS ; i++)
    {
        nSize = IRand() % 5000;
        lpT = pMem[i];
        pMem[i] = (LPVOID)LocalReAlloc((HLOCAL)lpT, nSize, LMEM_MOVEABLE);
        DebugPrint("#%d: ReAllocated pointer %08x as %08x as %d bytes\n", i, lpT, pMem[i], nSize);
    }
    
    // Free the blocks
    for (i = 0 ; i < MAX_BLOCKS ; i++)
    {
        hStatus = LocalFree((HLOCAL)pMem[i]);
        
        DebugPrint("#%d: %08x freed %s\n", i, pMem[i],
            hStatus == NULL ? "successfully" : "unsucessfully");
    }

    // Create some threads that will occasionally fault
    for (i = 0 ; i < MAX_THREADS ; i++)
    {
        hThreads[i] = CreateThread(
                                    NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)TestThreadStart,
                                    (LPVOID)i,
                                    0,
                                    &dwThreadId
                                   );
    }

    // Wait until all the threads exit
    dwWaitStatus = WaitForMultipleObjects(
                                            MAX_THREADS,
                                            hThreads,
                                            TRUE,
                                            60 * 1000
                                         );
    if (dwWaitStatus == WAIT_TIMEOUT)
        DebugPrint("Timed out waiting for threads to exit (one minute)\n");
    else
        DebugPrint("All threads exited\n");

    // Now display all the exit codes
    for (i = 0 ; i < MAX_THREADS ; i++)
    {
        GetExitCodeThread(hThreads[i], &dwExitCode);
        DebugPrint("Thread #%d, exit code was %d\n", i, dwExitCode);
        CloseHandle(hThreads[i]);
    }
    
    OutputDebugString(L"TestDLL!CallMe exiting\n");
}

// Thread startup routine

DWORD
WINAPI
MyFilter(
    DWORD dwException
    )
{
    DebugPrint("Exception filter caught exception %08x\n", dwException);
    return EXCEPTION_EXECUTE_HANDLER;
//    return EXCEPTION_CONTINUE_SEARCH;
//    return EXCEPTION_CONTINUE_EXECUTION;
}
         

DWORD
WINAPI
TestThreadStart(
    LPVOID lp
    )
{
    int nThread = (int)lp;
    int nExitCode = IRand() % 100;
    int nSleepTime = IRand() % 10000;

    try
    {
        DebugPrint("Thread #%d sleeping %d milliseconds\n", nThread, nSleepTime);

        Sleep(nSleepTime);
        
        if (IRand() % 10 == 7) // lucky 7
        {
            DebugPrint("Thread #%d is going to fault\n", nThread);
            
//            RaiseException(0, /* EXCEPTION_NONCONTINUABLE */ 0, 0, NULL);

//            DebugPrint("We continued after the exception! Woo hoo!\n");

            _asm mov ecx, 0x30000000    // page fault
            _asm mov [ecx], eax
        }
    }
    except(MyFilter(GetExceptionCode()))
    {
        DebugPrint("We faulted in thread #%d\n", nThread);
        ExitThread(0);
    }

    DebugPrint("Thread #%d exiting with exit code of %d\n", nThread, nExitCode);
    return nExitCode;
}


// Quick and dirty random number generator

    ULONG g_ulSeed;

VOID
WINAPI
IRandSeed(
    ULONG ulSeed
    )
{
    g_ulSeed = ulSeed;
}

ULONG
WINAPI
IRand( VOID )
{
    g_ulSeed =  1664525 * g_ulSeed + 1013904223;

    return g_ulSeed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\testexe\testexe.c ===
#include <xtl.h>

void __cdecl main()
{
    OutputDebugString(L"TestExe sleeping. Note that nothing useful\r\n"
        L"will happen after this, you might as well break in and reboot\r\n");
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\apicln.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    apicln.c

Abstract:

    This module contains functions for cleaning up whatever resources were
    created by an API which was tested.

Author:

    John Miller (johnmil) 19-Mar-1992

Environment:

    XBox

Revision History:

    11-Apr-2000     schanbai

        Added more clean up routines

--*/

#include <windows.h>
#include <stdio.h>
#include <xlog.h>

VOID
ErrorPrint(
    HANDLE hLog,
    char *Module,
    int CaseNo,
    char *Message
    );

INT
APrintf(
    char *Format,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\biglettr.h ===
/***************************************************************************
MODULE: BigLettr.h
AUTHOR: JohnMil
DATE:	2-25-92

Copyright (c) 1992 Microsoft Corporation

This module contains basic character definitions for large characters,
represented as arrays of the letters. BigDash contains a 5x5 dash,
BigLower contains 5x3 lowercase letters, BigUpper contains 5x5 upper case
characters, and BigDigit contains 5x5 numbers.
***************************************************************************/



char BigDash[5][6] =
{"     ",
 "     ",
 "     ",
 "     ",
 "_____"};

	    // Lowercase letters

char BigLower[26][5][4]={
{"   ",
 "   ",
 " aa",
 "a a",
 " aa"},
{"b  ",
 "b  ",
 "bb ",
 "b b",
 "bb "},
{"   ",
 "   ",
 " cc",
 "c  ",
 " cc"},
{"  d",
 "  d",
 " dd",
 "d d",
 " dd"},
{"   ",
 " e ",
 "eee",
 "e  ",
 " ee"},
{" ff",
 "f  ",
 "ff ",
 "f  ",
 "f  "},
{" gg",
 "g g",
 " gg",
 "  g",
 "gg "},
{"h  ",
 "h  ",
 "hh ",
 "h h",
 "h h"},
{" i ",
 "   ",
 "ii ",
 " i ",
 "iii"},
{" j ",
 "   ",
 " j ",
 " j ",
 "jj "},
{"k  ",
 "k  ",
 "k k",
 "kk ",
 "k k"},
{" l ",
 " l ",
 " l ",
 " l ",
 " l "},
{"   ",
 "   ",
 "m m",
 "mmm",
 "mmm"},
{"   ",
 "   ",
 "nn ",
 "n n",
 "n n"},
{"   ",
 "   ",
 " o ",
 "o o",
 " o "},
{"pp ",
 "p p",
 "pp ",
 "p  ",
 "p  "},
{" qq",
 "q q",
 " qq",
 "  q",
 "  q"},
{"   ",
 "   ",
 "rrr",
 "r  ",
 "r  "},
{"   ",
 "   ",
 " ss",
 " s ",
 "ss "},
{"   ",
 "   ",
 "ttt",
 " t ",
 " t "},
{"   ",
 "   ",
 "u u",
 "u u",
 "uuu"},
{"   ",
 "   ",
 "v v",
 "v v",
 " v "},
{"   ",
 "   ",
 "w w",
 "www",
 "w w"},
{"   ",
 "   ",
 "x x",
 " x ",
 "x x"},
{"   ",
 "y y",
 " yy",
 "  y",
 " yy"},
{"   ",
 "   ",
 "zz ",
 " z ",
 " zz"}};


		// Uppercase letters

char BigUpper[26][5][6]={
{"  A  ",
 " A A ",
 "AAAAA",
 "A   A",
 "A   A"},
{"BBBB ",
 "B   B",
 "BBBB ",
 "B   B",
 "BBBB "},
{" CCC ",
 "C   C",
 "C    ",
 "C   C",
 " CCC "},
{"DDD  ",
 "D  D ",
 "D   D",
 "D   D",
 "DDDD "},
{"EEEEE",
 "E    ",
 "EEEE ",
 "E    ",
 "EEEEE"},
{"FFFFF",
 "F    ",
 "FFFF ",
 "F    ",
 "F    "},
{" GGGG",
 "G    ",
 "G  GG",
 "G   G",
 " GGG "},
{"H   H",
 "H   H",
 "HHHHH",
 "H   H",
 "H   H"},
{"IIIII",
 "  I  ",
 "  I  ",
 "  I  ",
 "IIIII"},
{"JJJJJ",
 "   J ",
 "   J ",
 "J  J ",
 " JJ  "},
{"K   K",
 "K  K ",
 "KKK  ",
 "K  K ",
 "K   K"},
{"L    ",
 "L    ",
 "L    ",
 "L    ",
 "LLLLL"},
{"M   M",
 "MM MM",
 "M M M",
 "M   M",
 "M   M"},
{"N   N",
 "NN  N",
 "N N N",
 "N  NN",
 "N   N"},
{" OOO ",
 "O   O",
 "O   O",
 "O   O",
 " OOO "},
{"PPPP ",
 "P   P",
 "PPPP ",
 "P    ",
 "P    "},
{" QQQ ",
 "Q   Q",
 "Q   Q",
 "Q  Q ",
 " QQ Q"},
{"RRRR ",
 "R   R",
 "RRRR ",
 "R  R ",
 "R   R"},
{" SSSS",
 "S    ",
 " SSS ",
 "    S",
 "SSSS "},
{"TTTTT",
 "  T  ",
 "  T  ",
 "  T  ",
 "  T  "},
{"U   U",
 "U   U",
 "U   U",
 "U   U",
 " UUU "},
{"V   V",
 "V   V",
 "V   V",
 " V V ",
 "  V  "},
{"W   W",
 "W   W",
 "W W W",
 "WW WW",
 "W   W"},
{"X   X",
 " X X ",
 "  X  ",
 " X X ",
 "X   X"},
{"Y   Y",
 " Y Y ",
 "  Y  ",
 "  Y  ",
 "  Y  "},
{"ZZZZZ",
 "   Z ",
 "  Z  ",
 " Z   ",
 "ZZZZZ"}};

		// The digits 0 through 9.

char BigDigit[10][5][6]={
{" 000 ",
 "0  00",
 "0 0 0",
 "00  0",
 " 000 "},
{" 11  ",
 "  1  ",
 "  1  ",
 "  1  ",
 "11111"},
{" 222 ",
 "2   2",
 "   2 ",
 " 22  ",
 "22222"},
{" 333 ",
 "3   3",
 "  33 ",
 "3   3",
 " 333 "},
{"4  4 ",
 "4  4 ",
 "44444",
 "   4 ",
 "   4 "},
{"55555",
 "5    ",
 "5555 ",
 "    5",
 "5555 "},
{" 666 ",
 "6    ",
 "6666 ",
 "6   6",
 " 666 "},
{"77777",
 "   7 ",
 "  7  ",
 " 7   ",
 "7    "},
{" 888 ",
 "8   8",
 " 888 ",
 "8   8",
 " 888 "},
{" 9999",
 "9   9",
 " 9999",
 "    9",
 "    9"}};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\filutil.h ===
#ifndef FILUTIL_INC

#define FILUTIL_INC

#include <xtl.h>
#include <winerror.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

  //
  // error values
  //

enum fFileSystem {

  FIO_NO_ERR = 0,
  FIO_NO_MORE_CASES,
  FIO_NO_MORE_TYPES,
  FIO_ERR_ALLOC_MEM,
  FIO_ERR_GETVOLINFO,
  FIO_ERR_GET_CUR_DIR,
  FIO_ERR_BUFF_TOO_SMALL,
  FIO_ERR_CREATING_DIR,
  FIO_ERR_UNKNOWN_FILE_SYSTEM,
  FIO_ERR_UNKNOWN_BADF_TYPE
};

  //
  // types of bad filenames to pass to fGetBadFileName
  //
  // all of the FIO_BADFNAME_* constants are fully qualified filenames (off
  // current drive), each case differs only in which component of the full
  // path name contains the bogusness
  //
  // all of the FIO_BADDIRNAME_* constants are fully qualified pathnames
  // (again, qualified off the current drive)
  //

enum fBadNameTypes {

  FIO_BADFNAME_UNPRINT_CHARS_ROOT = 0,
  FIO_BADFNAME_UNPRINT_CHARS_SUBDIR,
  FIO_BADFNAME_UNPRINT_CHARS_DIRNAME,

  FIO_BADFNAME_PRINT_CHARS_ROOT,
  FIO_BADFNAME_PRINT_CHARS_SUBDIR,
  FIO_BADFNAME_PRINT_CHARS_DIRNAME,

  FIO_BADFNAME_INVALID_DRIVE_NAME,

  FIO_BADFNAME_ILL_FORMED,

  FIO_BADFNAME_NAME_TOO_LONG,

  FIO_BADDIRNAME_UNPRINT_CHARS,
  FIO_BADDIRNAME_PRINT_CHARS,
  FIO_BADDIRNAME_ILL_FORMED,
  FIO_BADDIRNAME_INVALID_DRIVE_NAME,

  FIO_BADF_NUM_TYPES
};

  //
  // file system types
  //

enum fFileSystems {

  FIO_FS_FAT = 0,
  FIO_FS_HPFS,
  FIO_FS_NTFS,
  FIO_FS_CDFS
};

  //
  // prototypes
  //

DWORD fGetNextBadFileName(LPSTR *lpFileName, int iType, int cCaseNum);
DWORD fGetNextBadFileNameW(LPWSTR *lpFileName, int iType, int cCaseNum);

DWORD fGetCurDriveName(LPSTR lpBuff, DWORD dwBuffLen);

DWORD fGetFileSystem(LPINT lpFsType);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\badman.h ===
/*
 * MODULE:  BadMan.h
 * AUTHOR:  JohnMil
 * DATE:    2-5-92
 *
 * Copyright (c) 1992-5 Microsoft Corporation
 *
 * This module contains Typedefs and macros uses throughout BadMan. No
 * function prototypes should be put into this file.
 */


#ifndef _BADMANH
#define _BADMANH


#include    <windows.h>
#include    <string.h>
#include    <stdlib.h>
#include    <stdio.h>


/*
 * An absolute value function
 */

#define ABS(x)          ((x) < 0 ? -(x) : (x))


/*
 * Maximum # of parameters in an API call. If this number is changed, the
 * number of parms used in the call in GenParm() must be changed by hand.
 */

#define MAXNOPARMS      20


/*
 * Hashing tables are used for storing types of data for which there are a
 * large number.
 */

/*
 * # of buckets in the Definitions Hash Table
 */
#define HASH_SIZE       199


/*
 * # of buckets in the Macros Hash Table
 */

#define MACRO_HASH_SIZE     19


/*
 * # of buckets in the Data Type Hash Table
 */

#define DATA_HASH_SIZE      19


/*
 * An arbitrary number that represents the value of a define which was not
 * found. This number MUST NOT MATCH any of the defines.
 */

#define BAD_DEFINE      9194716


/*
 * Different types of return values specified in a script entry for use in
 * ReturnType.Type.
 */

#define RET_ISEQUAL     0x0
#define RET_VALUE       0x1
#define RET_PARM        0x2
#define RET_NONE        0x4
#define RET_NOTEQUAL        0x8


/*
 * CL = Command Line options. info passed in by the user and defaults
 *
 * Flags                CLOPT_xxx flags are set in this int
 * MinPerfIterations    Minimum performance iterations
 * MaxPerfIterations    maximum performance iterations
 * RunFile[256]         Name of the script file
 * LogFile[256]         LogFile Name
 * APIName[256]         Name of a selected API, if any
 * VarNum               Variation number to run, if picked
 */

typedef struct  _s_CLType   {
    int         Flags;  
    int         MinPerfIterations,
                MaxPerfIterations;
    char        RunFile[256],
                //LogFile[256],
                APIName[256];
    int         VarNum;
} CLType;


/*
 * SeenType is used to help with knowing what parameter sets to keep or
 * destroy.
 * S            True/false for if a parm name has been seen yet
 * next         pointer to the next in the list
 */

typedef struct  _s_SeenType {
    BOOL            S[MAXNOPARMS];
    struct _s_SeenType  *next;
} SeenType;

        // Data structure for hashed defines.
typedef struct _sDefin      {
    char            *Symbol,    // Name of the define
                *Comment;   // Comment for the define
    int         Case;       // Actual value for the define
    struct _sDefin      *next;
}  DefineType;


/*
 * StringTypes are linked lists of strings. This is used primarily for Data
 * Types.
 */

typedef struct _s_String    {
    char            *Name;
    struct _s_String    *next;
} StringType;


/*
 * This is for a linked list of Good Cases for a Parameter.
 */

typedef struct _s_GoodVal {
        // V is a direct pointer to the define for a given case
    DefineType      *V;
    struct _s_GoodVal   *next;
} GoodValType;


        // BadVal is a linked list of bad cases for a parm.
typedef struct _s_BadVal {
    DefineType      *V, // Pointer to the bad variation define
                *L; // Pointer to a definition for GetLastError, if any
    int         LastError;  // BAD_DEFINE, else the value expected from GetLastError
    struct _s_BadVal    *next;
} BadValType;


/*
 * Macro's can be of either good or bad cases. Since Good are a subset of bad,
 * it's natural to use bad.
 */

typedef BadValType MacroValType;


/*
 * Macro of multiple cases
 */

typedef struct _s_Macro {
    char            *Name;  // Name of the macro
    MacroValType        M;  // Head of linked list of cases
    struct _s_Macro     *next;
} MacroType;


/*
 * Data structure for a parameter and its current set of Good and Bad cases.
 */

typedef struct _s_Parms {
    StringType      *Type;  // Pointer directly to the datatype
    char            *Name;  // Name of the parameter
    BOOL            bIsEndCase; // Whether this Parm signals the end of a case.
    BOOL            NoPush; // Don't put this param on stack
    GoodValType     Good;   // head of good cases linked list
    BadValType      Bad;    // head of bad cases linked list
    struct _s_Parms     *Depend, // Dependency lists are more parameter entries.
                *next;  // Depend->next is the first entry.
} S_PARMS;


/*
 * ParmDep is a linked list of lists of parms.  it's used for processing
 * dependency lists.
 */

typedef struct _s_ParmDep {
    S_PARMS         *P; // Parameter list for this ParmDep
    struct _s_ParmDep   *next;
} ParmDepType;


/*
 * Type of return argument to compare against API return
 */

typedef struct _s_ReturnType {
    DWORD           Type;
    int         Value;  // Int if return is a value, else parm # if parm.
} ReturnType;


/*
 * APIType contains an entire entry for an API.
 */

typedef struct _s_APIType {
    StringType      *Type;  // Direct pointer to a datatype
    char            *Name;  // Name of the API
    S_PARMS         Parms;  // ParmList head
    ReturnType      RValue; // Return value to compare
} APIType;


/*
 * Information for dynamically loaded libraries.
 */

typedef struct _s_ModType {
    char            *Name;  // Name of the library
    HANDLE          h;  // Handle to it.
} ModType;


typedef DWORD (FAR *FARFNSETUP)(int CaseNo, LPVOID *SCInfo, HANDLE hLog,
    HANDLE hConOut);

typedef void (FAR *FARFNCLEANUP)(int CaseNo, LPVOID *SCInfo, HANDLE hLog,
    HANDLE hConOut);

typedef void (FAR *FARFNVALIDATE)(DefineType VarInfo[], DWORD dwParms[],
    int ParmGoodBad[], DWORD dwRetVal,
    HANDLE hLog, HANDLE hConOut);

typedef VOID (FAR *FARFNAPICLN)(DWORD dwRet, DWORD *dwParms,
    HANDLE hConOut, HANDLE hLog);

typedef DWORD (FAR WINAPI *FARDPROC)();



#define malloc(x)   calloc(1, x)


#endif // _BADMANH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\filever.h ===
//---------------------------------------------------------------------------
//
// MODULE: filever.h
// AUTHOR: Steveko
// DATE:        03-27-92
//        
// Copyright (c) 1992 Microsoft Corporation
//        
// Header file for fileio and versioning badman testing.
//
//---------------------------------------------------------------------------

#define FIO_DEFAULT_FILE_NAME           "z:\\abcdefg.hij"
#define FIO_DEFAULT_FILE_NAME_W        L"z:\\abcdefg.hij"

#define FIO_DEFAULT_FILE_TO_CREATE      "z:\\abcdefg.abc"
#define FIO_DEFAULT_FILE_TO_CREATE_W   L"z:\\abcdefg.abc"

#define FIO_DEFAULT_SRC_FILE_NAME       "z:\\abcdefg.123"
#define FIO_DEFAULT_SRC_FILE_NAME_W    L"z:\\abcdefg.123"

#define FIO_DEFAULT_DEST_FILE_NAME      "z:\\abcdefg.234"
#define FIO_DEFAULT_DEST_FILE_NAME_W   L"z:\\abcdefg.234"

        /* Buffer lengths. */

#define FIO_READWRITE_BUFFER_SIZE              1025
#define FIO_LOGICAL_DRIVE_STRING_BUFFER_LENGTH 1025
#define FIO_VOLUME_NAME_BUFFER_LENGTH          1025
#define FIO_FILE_SYSTEM_NAME_BUFFER_LENGTH     1025

        /* Prototypes. */

HANDLE FIOHandleSetup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut);
DWORD  FIODwordSetup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut);
LPSTR  FIOLpstrSetup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut);
LPWSTR FIOLpstrSetupW(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut);

VOID FIOHandleCleanup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut);
VOID FIOLpstrCleanup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut);

        /* Useful constants for manipulating DOS dates/times. */

#define DOS_DATE_MASK_DAY    0x001f     // low  5 bits (1-31)
#define DOS_DATE_MASK_MONTH  0x01e0     // mid  4 bits (1-12)
#define DOS_DATE_MASK_YEAR   0xfe00     // high 7 bits (0-119, offset from 1980)

#define DOS_DATE_SHIFT_DAY   0
#define DOS_DATE_SHIFT_MONTH 5
#define DOS_DATE_SHIFT_YEAR  9

#define DOS_TIME_MASK_SECONDS 0x001f    // low  5 bits (0-29, 2 sec granular)
#define DOS_TIME_MASK_MINUTES 0x07e0    // mid  6 bits (0-59)
#define DOS_TIME_MASK_HOURS   0xf800    // high 5 bits (0-23)

#define DOS_TIME_SHIFT_SECONDS  0
#define DOS_TIME_SHIFT_MINUTES  5
#define DOS_TIME_SHIFT_HOURS   11

        /* Specify the year as an offset from 1980 */

#define MAKE_DOS_DATE(month, day, year) \
                     (year  << DOS_DATE_SHIFT_YEAR  | \
                      month << DOS_DATE_SHIFT_MONTH | \
                      day   << DOS_DATE_SHIFT_DAY )

        /* Specify seconds 0-30 (corresponds to DOS 2 second granularity) */

#define MAKE_DOS_TIME(hour, min, sec) \
                     (hour << DOS_TIME_SHIFT_HOURS   | \
                      min  << DOS_TIME_SHIFT_MINUTES | \
                      sec  << DOS_TIME_SHIFT_SECONDS )

#define VER_DEFAULT_SRC_FILE         "z:\\xyzver.src"
#define VER_DEFAULT_SRC_FILE_W      L"z:\\xyzver.src"

#define VER_DEFAULT_DEST_FILE        "z:\\xyzver.dst"
#define VER_DEFAULT_DEST_FILE_W     L"z:\\xyzver.dst"

#define VER_DEFAULT_SRC_DIR          "z:\\"
#define VER_DEFAULT_SRC_DIR_W       L"z:\\"

#define VER_DEFAULT_DEST_DIR         "z:\\xyzver.dst"
#define VER_DEFAULT_DEST_DIR_W      L"z:\\xyzver.dst"

#define VER_DEFAULT_APP_DIR          "z:\\xyzver.app"
#define VER_DEFAULT_APP_DIR_W       L"z:\\xyzver.app"

#define VER_DEFAULT_DIR_NOT_EXISTS       "z:\\notexist"
#define VER_DEFAULT_DIR_NOT_EXISTS_W    L"z:\\notexist"

#define VER_DEFAULT_FILE_WITH_VER_INFO       "verinf.exe"
#define VER_DEFAULT_FILE_WITH_VER_INFO_W    L"verinf.exe"

#define VER_SIZE_LANGUAGE_BUFFER 255
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\memmgt.h ===
/*****************************************************************************
*
*  MODULE: memmgt.H
*  AUTHOR: JohnMil
*  DATE:   2-4-92
*
*  Copyright (c) 1991,1992 Microsoft Corporation
*
*  Header file for Memmgt.C that houses the setup and cleanup functions for
*  the Win32 Memory Management component.
*
*  History:
*
*	Nov 1, 1991	JohnMil	Initial Version
*	Feb 29, 1992	JohnMil renamed, modified for BadMan 2.0
*   April 2, 1992	TomMcG revisions for new/changed flags
*
****************************************************************************/

// All possible flags for GlobalAlloc()
#define MM_GPFLAGS 	( GMEM_FIXED 	   | GMEM_MOVEABLE   | GMEM_NOCOMPACT |	\
					  GMEM_NODISCARD   | GMEM_ZEROINIT   | 					\
					  GMEM_DISCARDABLE | GMEM_NOT_BANKED | GMEM_DDESHARE  |	\
					  GMEM_SHARE	   | GMEM_NOTIFY     | GMEM_LOWER )

// All possible flags for GlobalReAlloc()
#define MM_GRFLAGS	( GMEM_DISCARDABLE | GMEM_MODIFY   | GMEM_MOVEABLE |	\
					  GMEM_NODISCARD   | GMEM_ZEROINIT )

// All possible flags for LocalAlloc()
#define MM_LPFLAGS 	( LMEM_FIXED 	 | LMEM_MOVEABLE | LMEM_NOCOMPACT   |	\
					  LMEM_NODISCARD | LMEM_ZEROINIT | LMEM_DISCARDABLE )

// All possible flags for LocalReAlloc()
#define MM_LRFLAGS	( LMEM_DISCARDABLE | LMEM_MODIFY | LMEM_MOVEABLE |		\
					  LMEM_ZEROINIT )

#define GMEM_DEF_FLAGS (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define LMEM_DEF_FLAGS (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define MM_GLOBAL 1
#define MM_LOCAL 0


/*********************** Function Prototypes ******************************/

HANDLE	LMemHandleCreate(HANDLE hLog, HANDLE hConOut, int CaseNo);
HANDLE	GMemHandleCreate(HANDLE hLog, HANDLE hConOut, int CaseNo);
HANDLE	HeapHandleCreate(HANDLE hLog, HANDLE hConOut, int CaseNo);
LPSTR LMemPointerCreate(HANDLE hLog, HANDLE hConOut, int CaseNo,LPVOID *SCInfo);
LPSTR GMemPointerCreate(HANDLE hLog, HANDLE hConOut, int CaseNo,LPVOID *SCInfo);
LPSTR HeapPointerCreate(HANDLE hLog, HANDLE hConOut, int CaseNo,LPVOID *SCInfo);
LPVOID VirtAddrCreate(HANDLE hLog, HANDLE hConOut, int CaseNo,LPVOID *SCInfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\parsedef.h ===
/*
 * MODULE:  ParseDef.h
 * AUTHOR:  JohnMil
 * DATE:  1-14-92
 *
 * Copyright (c) 1992-6 Microsoft Corporation
 *
 * This module contains the defines used in the parser and Engine for BadMan
 */

#include <badman.h>
//#include <ntlog.h>


#define CALL_DELETE 1
#define CALL_MODIFY 2

/*
 * Command Line options are set as flags
 */

#define CLOPT_DOCUMENT          0x0001  // Generate a document of test coverage
#define CLOPT_TEST              0x0002  // Test the API (def)
#define CLOPT_GOOD              0x0004  // Go through Good Parm variations
#define CLOPT_BAD               0x0008  // Go through Bad Parm variations (def)
#define CLOPT_PARSEONLY         0x0010  // Parse the file, don't test or doc.
#define CLOPT_PERMUTE           0x0020  // Do permutations rather than linear
#define CLOPT_API               0x0040  // API to test specified
#define CLOPT_VARIATION         0x0080  // Variation to test specified
#define CLOPT_VALIDATE          0x0100  // Perform validation on return value
#define CLOPT_PERFORMANCE       0x0200  // Generate Performance data
#define CLOPT_NTLOG             0x0400  // Generate NTLog output
#define CLOPT_NOEXCEPT          0x0800  // Don't log exceptions
#define CLOPT_DBGBREAK          0x1000  // Break before API Calls
#define CLOPT_PRINT_ALL_CALLS   0x2000  // print successful calls too
#define CLOPT_DEFAULT           (CLOPT_TEST | CLOPT_BAD)


#define MAX_TIMING_ITERATIONS   2000
#define MIN_TIMING_ITERATIONS   3

/*
 * These are states for our state machine (script parser)
 */

typedef enum    _parser_state   {
    STATE_ERROR = 0,
    STATE_API_TYPE,
    STATE_API_NAME,
    STATE_API_NEXT_PARAM,
    STATE_API_PARAM_TYPE,
    STATE_API_PARAM_NAME,
    STATE_API_PARAM_DONE,
    STATE_API_RETURN_ASSIGN,
    STATE_API_RETURN_DONE,
    STATE_PARAM_IDENTIFIED,
    STATE_PARAM_GOOD_LIST,
    STATE_PARAM_BAD_LIST,
    STATE_PARAM_OMIT_LIST,
    STATE_PARAM_DEPEND,
    STATE_PARAM_ENDDEPEND,
    STATE_LOOP_THROUGH_API,
    STATE_BEGIN,
    STATE_API_NEXT_PARAM_WITH_COMMA,
    STATE_PARAM_BAD_READ,
    STATE_PARAM_LASTERROR,
    STATE_MODULE_ID,
    STATE_MODULE_NAME
} PARSER_STATE;


/*
 * This is the number of DLL's we dynamically link to to to get API's. Actual
 * names are declared in the Modules[] array in badman\src\engine\BadMan.c
 */

typedef enum    _BADMAN_MODULE_IDS  {
    BADMAN_MODULE_NUM_APICLN = 0,
    BADMAN_MODULE_NUM_SETCLN,
    BADMAN_MODULE_NUM_VALIDATE,
    BADMAN_MODULE_COUNT
} BADMAN_MODULE_IDS;


#define MAX_OTHER_MODULES       10


/*
 * Function Prototypes
 */

void
DestroyParmDep(
    ParmDepType             *PD
);


S_PARMS
*DestroyParm(
    S_PARMS                 *P
);


void
DumpDefines(
    DefineType              Hash[HASH_SIZE]
);


void
DumpFullParm(
    S_PARMS                 *P
);


void
DumpMacros(
    MacroType               MacroHash[]
);


void
DumpParms(
    S_PARMS                 *P
);


void
DumpStrings(
    StringType              Hash[],
    int                     HashSize
);


BOOL
ExistingParmName(
    char                    *Name,
    S_PARMS                 *PList
);


DefineType
*FindDefine(
    char                    *token,
    DefineType              *DList
);


MacroType
*FindMacro(
    char                    *token,
    MacroType               *MacroHash
);


StringType
*FindString(
    char                    *token,
    StringType              SList[],
    int                     HashSize
);


int
GenParm(
    S_PARMS                 ParmList[MAXNOPARMS],
    int                     ParmNo,
    int                     NumParms,
    FARFNSETUP              pfnSetup[MAXNOPARMS],
    FARFNCLEANUP            pfnCleanup[MAXNOPARMS],
    FARDPROC                pfnAPI,
    FARFNVALIDATE           pfnValidate,
    FARFNAPICLN             pfnAPICln,
    int                     GoodBad,
    int                     *Variation,
    CLType                  *CLOptions,
    DefineType              VarInfo[MAXNOPARMS],
    APIType                 *API,
    int                     MadeParm,
    int                     ParmGoodBad[MAXNOPARMS],
    HANDLE                  hLog,
    HANDLE                  hConOut
);


int
HashVal(
    char                    *ToHash,
    int                     HashSize
);


BOOL
ModifyParms(
    int                     CallType,
    S_PARMS                 *ParmList,
    ParmDepType             *PD
);


BadValType
*NewBadVal(
    DefineType              *Def,
    DefineType              *LDef,
    int                     LastError,
    BadValType              *next
);


char
*NewCharString(
    char                    *Text
);


DefineType
*NewDefine(
    char                    *Name,
    char                    *Comment,
    int                     Val,
    DefineType              *Next
);


GoodValType
*NewGoodVal(
    DefineType              *Def,
    GoodValType             *next
);


MacroType
*NewMacro(
    char                    *Name,
    MacroValType            *M,
    MacroType               *next
);


MacroValType
*NewMacroVal(
    DefineType              *Def,
    DefineType              *LDef,
    int                     LastError,
    MacroValType            *next
);


S_PARMS                 *
NewParm(
    StringType              *Type,
    char                    *Name,
    BOOL                    bIsEndCase,
    BOOL                    NoPush,
    GoodValType             *Good,
    BadValType              *Bad,
    S_PARMS                 *Depend,
    S_PARMS                 *next
);


ParmDepType
*NewParmDep(
    S_PARMS                 *P,
    ParmDepType             *next
);


SeenType
*NewSeen(
    SeenType                *next
);


StringType
*NewString(
    char                    *token,
    StringType              *next
);



int
Parse(
    DefineType              Hash[HASH_SIZE],
    MacroType               MacroHash[MACRO_HASH_SIZE],
    StringType              DataTypes[DATA_HASH_SIZE],
    CLType                  *CLOptions,
    ModType                 *BadmanModules,
    ModType                 *OtherModules,
    HANDLE                  hLog
);


void
PrintAPICall(
    HANDLE                  hLog,
    APIType                 *API,
    S_PARMS                 *ParmList,
    DefineType              *VarInfo,
    DWORD                   *dwParms,
    DWORD                   dwRetVal,
    int                     Variation,
    int                     NumParms,
    int                     *GoodBadParm,
    BOOL                    GLPass,
    BOOL                    VarPass,
    BOOL                    VarExcept,
    DWORD                   LastError
);


int
ProcessAPI(
    APIType                 *API,
    DefineType              *Hash,
    StringType              *DataTypes,
    CLType                  *CLOptions,
    ModType                 *BadmanModules,
    ModType                 *OtherModules,
    HANDLE                  hLog,
    HANDLE                  hConOut
);


BOOL
ProcessCLILogFlags(
    CLType                  *CLOptions,
    char                    *Flags
);


BOOL
ReadCommandLine(
    int                     argc,
    char                    **argv,
    CLType                  *CLOptions
);


void
ReadDefines(
    char                    *FileName,
    DefineType              Hash[HASH_SIZE],
    MacroType               MacroHash[MACRO_HASH_SIZE]
);


void
ReadStringHash(
    char                    *FileName,
    StringType              Hash[],
    int                     HashSize
);


int
TranslateDefine(
    char                    *DefineName,
    DefineType              Hash[HASH_SIZE]
);


BOOL
ValidParmName(
    char                    *Name
);


HANDLE
LMemHandleCreate(
    int                     CaseNo
);


HANDLE
GMemHandleCreate(
    int                     CaseNo
);


LPSTR
LMemPointerCreate(
    int                     CaseNo,
    LPVOID                  *SCInfo
);


LPSTR
GMemPointerCreate(
    int                     CaseNo,
    LPVOID                  *SCInfo
);


VOID
FreeDefineType(
    DefineType * ptr
    );


VOID
FreeStringType(
    StringType * ptr
    );


VOID
FreeValType(
    MacroValType * ptr
    );


VOID
FreeMacroType(
    MacroType * ptr
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\validate.h ===
/*******************************************************************
MODULE: Validate.h
AUTHOR: JohnMil
DATE:	2-5-92

Copyright (c) 1992 Microsoft Corporation


This is a general-purpose header file for all validation routines.

*******************************************************************/

#include <windows.h>
#include <stdio.h>

void	    ErrorPrint(HANDLE hConOut,HANDLE hLog,char *Module,int CaseNo, char *Message);
int	    ValPrintf(HANDLE hConOut,char *Format, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\inc\setcln.h ===
/*****************************************************************
MODULE: SetCln.h
AUTHOR: JohnMil
DATE:   1-20-92

Copyright (c) 1992 Microsoft Corporation

This contains definitions required for the xxxxSetup and xxxxCleanup
functions.
*****************************************************************/


#include	<stdlib.h>
#include	<stdio.h>

#include	<nt.h>
#include	<ntrtl.h>
#include	<nturtl.h>

#include	<xtl.h>


/*
 * Used with bad pointer stuff, and GetNativeBuffer.  I want something that's
 * too small for a DWORD.
 */

#define SMALL_NATIVE_BUFFER_SIZE    2


/*
 * This is a convienient structure to use when you have to make multiple
 * allocations for a setup.  Just put what you need into the list and at
 * cleanup time walk the list.
 */

typedef struct  _se_cleanup_info {
    struct _se_cleanup_info *se_Next;
    DWORD           se_AllocType;
    DWORD           se_AllocSize;
    VOID            *se_Address;
} SE_CLEANUP_INFO;


#define CLEANUP_LINK(x, y)  ((x) -> se_Next = Temp)
#define GET_REQUIRED_SIZE   (-1)


void
ErrorPrint(
    HANDLE          hConOut,
    HANDLE          hLog,
    LPSTR           Module,
    int             CaseNo,
    LPSTR           Message
);


int
SCPrintf(
    HANDLE          hConOut,
    LPSTR           Format,
    ...
);


VOID
InfThread(
    VOID
);


PVOID
GetNativeBuffer(
    DWORD                   NumberOfBytes
);


VOID
FreeNativeBuffer(
    PVOID                   Pointer,
    DWORD                   NumberOfBytes
);


// this stuff goes into the pointer support

typedef enum    _pointer_type {
    NULL_POINTER,
    INVALID_POINTER,
    VALIDRANGE_POINTER,
    MALALIGNED_POINTER_1,
    CLEANUP
} POINTER_TYPE;


BOOL
MakeBadPointer(
    PVOID                   *Pointer,
    SE_CLEANUP_INFO         **CleanupInfo,
    POINTER_TYPE            PointerType,
    DWORD                   PointerSize,
    HANDLE                  hConOut,
    HANDLE                  hLog
);


BOOL WINAPI
DLLEntry(
    HANDLE hInst,
    DWORD  dwReason,
    LPVOID lpv );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\bmkdx\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This module is kernel debugger extension for badman. It contains useful
    commands for debugging badman engine

Author:

    Sakphong Chanbai (schanbai) 15-Apr-2000

Environment:

    XBox

Revision History:

--*/



#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning( disable : 4214 )
#include <wdbgexts.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\bmkdx\bmkdx.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bmkdx.c

Abstract:

    This module is kernel debugger extension for badman. It contains useful
    commands for debugging badman engine

Author:

    Sakphong Chanbai (schanbai) 15-Apr-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include <xboxverp.h>
#include <badman.h>
#include <parsedef.h>


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };


USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


BOOL
GetData(
    LPVOID ptr,
    PVOID dwAddress,
    ULONG size,
    PCSTR type
    )

/*++

Routine Description:

    Get 'size' bytes from the debuggee program at 'dwAddress' and place it
    in our address space at 'ptr'.  Use 'type' in an error printout if necessary

Arguments:

Return Value:

--*/

{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;
    ULONG_PTR dwAddr = (ULONG_PTR)dwAddress;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory(dwAddr, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddr += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}


BOOL
GetString(
    IN  LPSTR dwAddress,
    OUT LPSTR buf,
    IN  ULONG MaxChars
    )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( (--MaxChars) != 0 && *buf++ != '\0' );

    return TRUE;
}


BOOL
GetStringFromLPSTR(
    LPVOID dwAddress,
    LPSTR buf,
    ULONG MaxChars
    )
{
    LPSTR lpAddress;
    *buf = 0;

    if ( !GetData( &lpAddress, dwAddress, sizeof(LPVOID), "LPVOID" ) ) {
        return FALSE;
    }

    return GetString( lpAddress, buf, MaxChars );
}


DECLARE_API( help )
{
    dprintf( "BADMAN kernel debugger extensions:\n" );
    dprintf( "  genparm    <ChildEBP>\n" );
}


DECLARE_API( genparm )
{
    S_PARMS * ParmList;
    APIType * API;
    DefineType * VarInfo;
    ULONG ChildEBP, NumParms, i;
    int * ParmGoodBad;
    char APIName[128];

    if ( !args || !*args || (ChildEBP = GetExpression( args )) == 0 ) {
        dprintf( "genparm  <ChildEBP>, example: genparm 0xdeadbeef\n" );
        return;
    }

    ChildEBP += 4;

    if ( !GetData( &ParmList, (PVOID)(ChildEBP+(1*4)), sizeof(S_PARMS *), "S_PARMS" ) ||
         !GetData( &NumParms, (PVOID)(ChildEBP+(3*4)), sizeof(ULONG), "NumParms" ) ||
         !GetData( &API, (PVOID)(ChildEBP+(13*4)), sizeof(APIType *), "APIType" ) ||
         !GetData( &VarInfo, (PVOID)(ChildEBP+(12*4)), sizeof(DefineType *), "DefineType" ) ||
         !GetData( &ParmGoodBad, (PVOID)(ChildEBP+(15*4)), sizeof(int *), "ParmGoodBad" ) ||
         !GetStringFromLPSTR( &API->Name, APIName, sizeof(APIName) )
       ) {
        return;
    }

    dprintf( "Parameters list (S_PARMS) = %p\n", ParmList );
    dprintf( "Number of parameters      = %d\n", NumParms );
    dprintf( "API type (APIType)        = %p\n", API );
    dprintf( "Define type (DefineType)  = %p\n", VarInfo );
    dprintf( "\n" );
    dprintf("%s(\n", APIName );

    for ( i=0; i<NumParms; i++) {

        int GoodBad;
        char ParmListName[256];
        char VarInfoSymbol[256];
        char VarInfoComment[512];
        DefineType DefStruct;
        S_PARMS ParmStruct;


        if ( !GetData( &GoodBad, &ParmGoodBad[i], sizeof(GoodBad), "int" ) ||
             !GetData( &ParmStruct, &ParmList[i], sizeof(ParmStruct), "S_PARMS" ) ||
             !GetData( &DefStruct, &VarInfo[i], sizeof(DefStruct), "DefineType" ) ||
             !GetStringFromLPSTR( &ParmStruct.next->Name, ParmListName, sizeof(ParmListName) ) ||
             !GetStringFromLPSTR( &DefStruct.next->Symbol, VarInfoSymbol, sizeof(VarInfoSymbol) ) ||
             !GetStringFromLPSTR( &DefStruct.next->Comment, VarInfoComment, sizeof(VarInfoComment) )
           ) {
            break;
        }

        //
        // +'s around good parms, -'s around bad parms
        //

        if (GoodBad & CLOPT_BAD) {
            dprintf( "    -%-25s %s -->%s", ParmListName, VarInfoSymbol, VarInfoComment );
        } else {
            dprintf( "    +%-25s %s -->%s", ParmListName, VarInfoSymbol, VarInfoComment );
        }
    }

    dprintf( "    );\n\n" );
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}


DECLARE_API( version )
{
#if DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s BADMAN extension dll for build %d debugging %s kernel for build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "checked" : "free",
        SavedMinorVersion
    );
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\apiclean\apicln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    apicln.c

Abstract:

    This module contains functions for cleaning up whatever resources were created
    by an API which was tested.

Author:

    John Miller (johnmil) 19-Mar-1992

Environment:

    XBox

Revision History:

    11-Apr-2000     schanbai

        Added more clean up routines

--*/


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

#include <apicln.h>
#include <stdarg.h>
#include <filever.h>


VOID
GlobalAllocAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE hRet, h;
    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( hConOut );

    if ( NULL == (h = (HANDLE)dwRet) ) {
        return;
    }

    hRet = GlobalFree( h );
    
    if ( hRet != NULL ) {
        ErrorPrint(
            hLog,
            "GlobalAllocAPICleanup",
            0,
            "Unable to free GlobalAlloc() results"
            );
    }
}


VOID
HeapCreateAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE h = (HANDLE)dwRet;
    BOOL bDestroyed;
    
    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( hConOut );

    if ( h != NULL ) {
        
        bDestroyed = HeapDestroy( h );
        if ( !bDestroyed ) {
            ErrorPrint(
                hLog,
                "HeapCreateAPICleanup",
                0,
                "Unable to free HeapCreate() results"
                );
        }

    }
}


VOID
LocalAllocAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE hRet;

    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( hConOut );
    
    if ( dwRet ) {
        hRet = LocalFree( (HANDLE)dwRet );
        if ( hRet != NULL ) {
            ErrorPrint(
                hLog,
                "LocalAllocAPICleanup",
                0,
                "Unable to free LocalAlloc() results"
                );
        }
    }
}


VOID
VirtualAllocAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    LPBYTE p = (LPBYTE)dwRet;

    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( hConOut );
    
    if ( dwRet && !VirtualFree( p, 0, MEM_RELEASE ) ) {
        ErrorPrint(
            hLog,
            "VirtualAllocAPICleanup",
            0,
            "Unable to free VirtualAlloc() results"
            );
    }
}


VOID
CreateFileWAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE hFile = (HANDLE)dwRet;

    UNREFERENCED_PARAMETER( hConOut );

    // Nothing to do if not opened
    if ( hFile == INVALID_HANDLE_VALUE ) {
        return;
    }

    // Close handle 
    if ( !CloseHandle(hFile) ) {
        ErrorPrint(
            hLog,
            "CreateFileWAPICleanup",
            0,
            "Error closing file"
            );
        return;
    }

    if ( SetFileAttributesW( (LPCWSTR)dwParms[0] , FILE_ATTRIBUTE_NORMAL ) &&
         !DeleteFileW((LPCWSTR)dwParms[0]) ) {
        ErrorPrint(
            hLog,
            "CreateFileWAPICleanup",
            0,
            "Unable to delete file"
            );
    }
}


VOID
CreateFileAAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE hFile = (HANDLE)dwRet;

    UNREFERENCED_PARAMETER( hConOut );

    // Nothing to do if not opened
    if ( hFile == INVALID_HANDLE_VALUE ) {
        return;
    }

    // Close handle 
    if ( !CloseHandle(hFile) ) {
        ErrorPrint(
            hLog,
            "CreateFileAAPICleanup",
            0,
            "Error closing file"
            );
        return;
    }

    // Change attributes to normal, so can be deleted
    SetFileAttributesA( (LPCSTR)dwParms[0], FILE_ATTRIBUTE_NORMAL );

    if ( !DeleteFileA((LPCSTR)dwParms[0]) ) {
        ErrorPrint(
            hLog,
            "CreateFileAAPICleanup",
            0,
            "Unable to delete file"
            );
    }
}


VOID
GenericHandleCleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE h;

    UNREFERENCED_PARAMETER( hConOut );
    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( hLog );

    h = (HANDLE)dwRet;

    if ( h != INVALID_HANDLE_VALUE ) {
        CloseHandle( h );
    }
}


VOID
CreateThreadAPICleanup(
    DWORD dwRet,
    DWORD *dwParms,
    HANDLE hConOut,
    HANDLE hLog
    )
{
    HANDLE ThreadHandle = (HANDLE)dwRet;

    UNREFERENCED_PARAMETER( hConOut );
    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( hLog );

    if ( NULL != ThreadHandle ) {
        //BUGBUG no TerminateThread under Xbox
        //if ( !TerminateThread( ThreadHandle, 0xdeadbeef ) ) {
            ResumeThread( ThreadHandle );
            QueueUserAPC((PAPCFUNC)ExitThread, ThreadHandle, 0xdeadbeef);
        //}
        CloseHandle( ThreadHandle );
    }
}


INT
APrintf(
    char *Format,
    ...
    )
{
    char buff[512];
    va_list vaList;
    DWORD i;

    va_start( vaList, Format );
    i = vsprintf( buff, Format, vaList );
    OutputDebugStringA( buff );
    return i;
}


VOID
ErrorPrint(
    HANDLE hLog,
    char *Module,
    int CaseNo,
    char *Desc
    )
{
    UNREFERENCED_PARAMETER( CaseNo );

    APrintf( "APICLN: %s -- %s\n", Module, Desc);
    
    if ( hLog != INVALID_HANDLE_VALUE ) {
        xLog( hLog, XLL_WARN, "APICLN-%s -- %s", Module, Desc );
    }
}


BOOL
WINAPI
ApiclnDllEntry(
    HINSTANCE hInstance,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( fdwReason );
    UNREFERENCED_PARAMETER( lpvReserved );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\engine\parser.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    parser.c

Abstract:

    This module contains helper functions for the Parser for BADMAN

Author:

    John Miller (johnmil) 20-Jan-1992

Environment:

    XBox

Revision History:

    31-Mar-1995     TimF

        Made it readable

    01-Apr-2000     schanbai

        Ported to XBox and made the code more readable

--*/


#include "precomp.h"
#include <ctype.h>
#include <parsedef.h>


int
Parse(
    DefineType  Hash[HASH_SIZE],
    MacroType   MacroHash[MACRO_HASH_SIZE],
    StringType  DataTypes[DATA_HASH_SIZE],
    CLType      *CLOptions,
    ModType     *BadmanModules,
    ModType     *OtherModules,
    HANDLE      hLog

/*++

Routine Description:

    Parse will parse a command script, given the file name and a hash table
    with DEFINE's in it, and call the test procedure after parsing each full
    entry.  An entry looks something like (this is a sample

     HANDLE
     GlobalAlloc(
         DWORD            dwFlags,
         DWORD            dwSize
     )= 0
         dwFlags:
             Good: DWORD_GOODGLOBALFLAG
             Bad: DWORD_BADGLOBALFLAG
         dwSize:
             Good: DWORD_GOODSIZE
             Bad:  DWORD_BADSIZE
         dwFlags:
             Good: DWORD_SPECIALGOODFLAG
             Bad: DWORD_SPECIALBADFLAG
                 Depend:
                     dwSize:
                         Good: DWORD_SPECIALGOODSIZE
                         Bad:  DWORD_SPECIALBADSIZE
                 EndDepend:

    Parse is essentially a state machine. As each token (string)is read in, it
    is treated according to what the state variable is set to. It may be
    sometimes that we are reading in white space, since white space is one of
    the terminators for the SCANF.  In this case, we don't process it.
    Otherwise, the Scanf will read in a string, terminating on special symbols
    and spaces.  The terminator is then read in and put into the TERM variable.
    This is because BAD with a colon as a terminator is perfectly legal, but
    BAD with a '(' as a terminator is not.

Arguments:

Return Value:

--*/

)
{
    APIType       API = {0};        // Stores one record
    BadValType    *BTrav = NULL;    // Traversing pointer to 'bad case' list
    BadValType    *BHold;           // Temporary variable to hold Bad list elements.
    BOOL          NoPush = FALSE;   
    BOOL          bInComment;       // An open-comment was read
    BOOL          space;            // Boolean: is terminator white space?
    BOOL          Found;            
    char          token[1024];      // The current token (word) being parsed
    char          term;             // The current terminator of the current token
    char          *TypeName;        // Name of a datatype
    char          *tTrav;
    char          buff[128];
    char          *NextAPIType = 0; // API type signals end of valid record. But we have to save it for the NEXT record.
    DefineType    *DTrav;           // Temp pointer to a place in the defines list
    FILE          *inFPtr;          // Pointer to the script file being parsed
    GoodValType   *GTrav = NULL;    // Traversing pointer to 'Good case' list
    HANDLE        hConOut;          // Handle to STDOut for DLL output
    PARSER_STATE  state;            // State # the state machine is in
    int           i=0, j, k;        // Counting vars
    int           LineCount;        // Line number being read in the script
    int           NumVar;           // Number of variations documented/run
    MacroType     *MTrav;           // Traversing pointer Used for Parsing macros
    MacroValType  *MVTrav;          // Traversing pointer for Macro case lists
    S_PARMS       *PTrav = NULL;    // Parm traversing pointers
    S_PARMS       *PTrav2;          // Parm traversing pointers
    WCHAR         wbuffer[MAX_PATH];

    //
    // PD contains the current parameter list level.  PD.next is the current
    // level, PD.next->next the next most current, and so on.
    //
    ParmDepType   *PDTrav, PD = { 0 };

    NumVar = 0;
    LineCount = 0;
    state = STATE_BEGIN;

    //
    // Set a handle to INVALID_HANDLE_VALUE. We don't have standard output in XBox
    //

    hConOut = INVALID_HANDLE_VALUE;

    //
    // Open the input file.
    //

    if ( NULL == (inFPtr = fopen( CLOptions->RunFile, "r" )) ) {   
        DbgPrint( "BADMAN: Parse: Unable to open %s for input\n", CLOptions->RunFile );
        ExitThread( EXIT_FAILURE );
    }

    bInComment = FALSE;

    //
    // We're going to loop through the entire file.  a string is terminated by
    // any of \ \t \n, ()= or :  This loop continues until the file is
    // completely read.
    //

    while ( fscanf( inFPtr, "%[^ \t\n,()=:]", token ) != EOF ) {

        ASSERT( strlen(token) < sizeof(token) );

        //
        // The terminator differentiates between different commands.
        //

        //
        // fgetc returns an int, term is a char...  It is possible that the
        // fgetc will return EOF, but it doesn't look like it matters.  TimF
        //

        term = (char)fgetc(inFPtr);

        if ( term == '\n' ) {
            LineCount++;
        }

        //
        // space indicates that the token currently being read was terminated
        // by space space.
        //

        if ( isspace(term) ) {
            space = TRUE;
        } else {
            space = FALSE;
        }

        j = strlen(token) - 1;

        //
        // if we're in a comment, check for an end comment.
        //

        if ( bInComment ) {
            for ( i=0; i<j; i++ ) {
                if ((token[i] == '*') && (token[i + 1] == '/')) {
                    for (k = i + 2; k < j; k++) {
                        token[k - (i + 2)] = token[k];
                    }

                    token[k - (i + 2)] = '\0';

                    bInComment = FALSE;

                    break;
                }
            }
        }

        //
        // If comment wasn't ended, skip processing the token...
        //

        if (bInComment) {
            continue;
        }

        //
        // If we encounter the start of a comment, gotta process...
        //

        if ( !bInComment ) {
            for ( i=0; i<j; i++ ) {
                if ( token[i] == '/' && token[i + 1] == '*' ) {
                    token[i] = '\0';
                    bInComment = TRUE;

                    for ( k=i+2; k<j; k++ ) {
                        if ( token[k] == '*' && token[k+1] == '/') {
                            bInComment = FALSE;
                        }
                    }

                    break;
                }
            }
        }

        //
        // If we have anything except a blank space for our current token, run
        // it through the state machine.  In general, while in a case, we
        // assume the token read will cause an error until we prove it won't:
        // this cuts down on the code path length.
        //

        if ( (token[0] != '\0') || !space ) {
            //DbgPrint( "\nState %d: [%s]<%c>", state, token, term );

            switch ( state ) {

            case STATE_ERROR:
            case STATE_BEGIN:

                //
                // Unless we find the data type for an API, we're going to
                // stay in either STATE_ERROR or STATE_BEGIN.
                //

                if ( space ) {
                    if ( !_stricmp(token, "module") ) {
                        state = STATE_MODULE_ID;
                    } else {
                        API.Type = FindString(token, DataTypes, DATA_HASH_SIZE);

                        if (API.Type != NULL) {
                            state = STATE_API_TYPE;
                        } else {
                            DbgPrint(
                                "BADMAN: script Error[%d]: '%s' is not a valid API Type.\n",
                                LineCount,
                                token
                                );

                            xLog(
                                hLog,
                                XLL_WARN,
                                "Script error[%d]: '%s' is not a valid API Type",
                                LineCount,
                                token
                                );
                        }
                    }

                }

                break;

            case STATE_MODULE_ID:

                //
                // ':' is a 'term' not a token, but that's what we expect, if
                // we don't get one treat this as a type-def'n.
                //

                if (term == ':') {
                    state = STATE_MODULE_NAME;
                } else {
                    API.Type = FindString(token, DataTypes, DATA_HASH_SIZE);

                    if (API.Type != NULL) {
                        state = STATE_API_TYPE;
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: '%s' is not a valid API Type.\n",
                            LineCount,
                            token
                            );

                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: '%s' is not a valid API type",
                            LineCount,
                            token
                            );
                    }
                }

                break;

            case STATE_MODULE_NAME: {

                //
                // We expect that the current token is a module name.
                //
                // Find the first free slot in the modules list.
                //

                int i;

                for ( i=0; i<MAX_OTHER_MODULES; i++) {
                    if ( !OtherModules[i].h ) {
                        break;
                    }
                }

                if ( i == MAX_OTHER_MODULES ) {
                    DbgPrint("BADMAN: Too many modules defined (max = %d)\n", MAX_OTHER_MODULES);
                } else {
                    //
                    // Attempt to load the specified module.
                    //

                    // BUGBUG: Is the name used other than to load the module ?
                    OtherModules[i].Name = malloc(MAX_PATH);

                    strcpy( OtherModules[i].Name, token );
                    
                    xSetComponent( hLog, "Badman", token );

                    if ( !strchr(OtherModules[i].Name, '.') ) {
                        strcat( OtherModules[i].Name, ".dll" );
                    }

                    swprintf( wbuffer, L"%S", OtherModules[i].Name );
                    OtherModules[i].h = XLoadModule( wbuffer );

                    if ( OtherModules[i].h == NULL ) {
                        //
                        // Attempt to load the specified module failed, die.
                        //

                        DbgPrint(
                            "BADMAN: parser unable to load library %s, LastError = %d (%s)\n",
                            OtherModules[i].Name,
                            GetLastError(),
                            WinErrorSymbolicName(GetLastError())
                            );

                        xLog(
                            hLog,
                            XLL_BLOCK,
                            "Parser unable to load library %s, LastError = %d (%s)",
                            OtherModules[i].Name,
                            GetLastError(),
                            WinErrorSymbolicName(GetLastError())
                            );

                        ExitThread( EXIT_FAILURE );
                    }

                    state = STATE_BEGIN;
                }

                break;
            }

            case STATE_API_TYPE:

                //
                // The type of the api has been successfully read in.
                //

                API.Name = "";
                API.RValue.Type = 0;    // no flags set
                API.Parms.next = NULL;

                //DestroyParmDep(&PD);

                PD.next = NULL;

                PTrav = &API.Parms;

                //
                // This is important: PDTrav->P->next will have the first
                // entry in it, not PDTrav->P!  Note also that the way we'll
                // insert the default Parm values, PD will be pointing at the
                // last parm in the list, whose->next will be the First
                // NON-DEFAULT parm.  Since PTrav->next is the last of the
                // default parms that's what we use, not PTrav.
                //

                PD.next = NewParmDep(PTrav, NULL);

                API.Name = NewCharString(token);

                state = STATE_API_NAME;

                if (!space) {
                    if (term == '(') {
                        state = STATE_API_NEXT_PARAM;
                    } else {
                        state = STATE_ERROR;

                        DbgPrint(
                            "BADMAN: Script Error[%d]: Expected ' ' or '(' after %s, read %c\n",
                            LineCount,
                            token,
                            term
                            );

                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: expected ' ' or '(' after %s, read %c\n",
                            LineCount,
                            token,
                            term
                            );
                    }
                }

                break;

            case STATE_API_NAME:

                //
                // The name of the api has been successfully read in, and the
                // next terminator which is not a space MUST be a '('.
                // Further, if something BESIDES a space was read between the
                // API name and '(', there was an error.
                //

                state = STATE_ERROR;

                if ((token[0] == '\0') && (term == '(')) {
                    state = STATE_API_NEXT_PARAM;
                } else {
                    DbgPrint(
                        "BADMAN: Script Error[%d]: Expected '(', read '%s%c'\n",
                        LineCount,
                        token,
                        term
                        );
                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: expected '(', read '%s%c'\n",
                        LineCount,
                        token,
                        term
                        );
                }

                break;

            case STATE_API_NEXT_PARAM_WITH_COMMA:

                //
                // The opening paren for the arg list has been read else we're
                // checking for a new arg list entry First we're going to find
                // and verify validity of all the parm names and types.  We'll
                // make empty parameter structures for them, which will be
                // filled with default values (the first read in for each
                // parm).
                //

                if (!space) {
                    state = STATE_ERROR;

                    DbgPrint(
                        "BADMAN: Script Error[%d]: Unexpected delimeter '%c'\n",
                        LineCount,
                        term
                        );

                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: unexpected delimeter '%c'\n",
                        LineCount,
                        term
                        );

                    break;
                }

                /* FALL-THROUGH */

            case STATE_API_NEXT_PARAM:

                state = STATE_ERROR;

                //
                // Either we're finished, and see the ')'
                //

                if (token[0] == '\0') {
                    if (term == ')') {
                        state = STATE_API_PARAM_DONE;
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: expected Parm Type or ')', read '%c'\n",
                            LineCount,
                            term
                            );

                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: expected Parm Type or ')', read '%c'\n",
                            LineCount,
                            term
                            );
                    }
                } else {
                    //
                    // or we're seeing a valid data type for a parm
                    // declaration, and will need a parm name.
                    //

                    if (space) {
                        //
                        // if token is a valid data type, new param.  We're
                        // making the new parameter by inserting it at front,
                        // so the list will go [head]->P5->P4->P3->P2
                        //->P1->NULL
                        //

                        if (!_stricmp(token, "NOPUSH")) {
                            /*
                             * We allow a "NOPUSH" directive here.
                             *
                             * NOPUSH is used to tell badman that a parameter
                             * should not be pushed onto the stack, even
                             * though we call appropriate setup and cleanup
                             * functions for it.
                             */

                            NoPush = TRUE;

                            state = STATE_API_NEXT_PARAM;
                        } else if ( FindString(token, DataTypes, DATA_HASH_SIZE) != NULL ) {

                            PTrav->next = NewParm(
                                                FindString(token, DataTypes, DATA_HASH_SIZE),
                                                "",
                                                FALSE,
                                                NoPush,
                                                NULL,
                                                NULL,
                                                NULL,
                                                PTrav->next
                                                );

                            PTrav = PTrav->next;

                            state = STATE_API_PARAM_TYPE;
                            NoPush = FALSE;
                        } else {
                            DbgPrint(
                                "BADMAN: Script Error[%d]: Invalid Parameter TYPE '%s'\n",
                                LineCount,
                                token
                                );
                            xLog(
                                hLog,
                                XLL_WARN,
                                "Script error[%d]: invalid parameter TYPE '%s'\n",
                                LineCount,
                                token
                                );
                        }
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Unexpected delimeter '%c'\n",
                            LineCount,
                            term
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: unexpected delimeter '%c'\n",
                            LineCount,
                            term
                            );
                    }
                }

                break;

            case STATE_API_PARAM_TYPE:

                //
                // A type has been read in, and we need a parameter name to
                // match it.  This routine is ONLY valid while we're actually
                // reading the parameter list between the parenthesis.
                //

                state = STATE_ERROR;
                tTrav = token;
                i = 0;

                while ((*tTrav != '\0') && (*tTrav == '*')) {
                    i++;
                    tTrav++;
                }

                if (ValidParmName(tTrav) && (!ExistingParmName(tTrav, &API.Parms))) {

                    if (i) {
                        for(j = 0; j < i; j++) {
                            strcpy(&buff[2 * j], "P_");
                        }

                        strcpy(&buff[2 * j], PTrav->Type->Name);

                        PTrav->Type = FindString(buff, DataTypes, DATA_HASH_SIZE);

                        if (PTrav->Type == NULL) {
                            DbgPrint(
                                "BADMAN: Script Error[%d]: Type '%s' not implemented\n",
                                LineCount,
                                buff
                                );
                            xLog(
                                hLog,
                                XLL_WARN,
                                "Script error[%d]: type '%s' not implemented\n",
                                LineCount,
                                buff
                                );
                            break;
                        }
                    }

                    PTrav->Name = NewCharString(tTrav);

                    if (term == ')') {
                        state = STATE_API_PARAM_DONE;
                    } else if (space) {
                        state = STATE_API_PARAM_NAME;
                    } else if (term == ',') {
                        state = STATE_API_NEXT_PARAM_WITH_COMMA;
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Unexpected delimeter after parm name, '%c'\n",
                            LineCount,
                            term
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: unexpected delimeter after parm name, '%c'\n",
                            LineCount,
                            term
                            );
                    }
                } else {
                    DbgPrint(
                        "BADMAN: Script Error[%d]: Invalid or repeated parm name, '%s'\n",
                        LineCount,
                        token
                        );
                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: invalid or repeated parm name, '%s'\n",
                        LineCount,
                        token
                        );
                }

                break;

            case STATE_API_PARAM_NAME:

                //
                // The name for a parameter was read in, but it was followed
                // by white space, so we don't know whether to read in more
                // params or terminate.
                //

                state = STATE_ERROR;

                if (token[0] == '\0') {
                    if (term == ')') {
                        state = STATE_API_PARAM_DONE;
                    } else if (term == ',') {
                        state = STATE_API_NEXT_PARAM_WITH_COMMA;
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Expected ')' or ',' after Parm Name, not '%c'\n",
                            LineCount,
                            term
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script Error[%d]: expected ')' or ',' after parm name, not '%c'\n",
                            LineCount,
                            term
                            );
                    }
                } else {
                    DbgPrint(
                        "BADMAN: Script Error[%d]: Missing delimeter after Parm Name\n",
                        LineCount
                        );
                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: missing delimeter after parm name\n",
                        LineCount
                        );
                }

                break;

            case STATE_PARAM_LASTERROR:

                //
                // We've seen an '=' in a Bad list, so we know it's for a
                // GetLastError info statement.
                //

                state = STATE_PARAM_BAD_LIST;

                if (space || (term == ',')) {
                    if (isdigit(token[0])) {
                        sscanf(token, "%d", &BTrav->LastError);
                    } else {
                        BTrav->L = FindDefine(token, Hash);

                        if (BTrav->L == NULL) {
                            state = STATE_ERROR;

                            DbgPrint(
                                "BADMAN: Script Error[%d]: Unknown GetLastError define '%s'\n",
                                LineCount,
                                token
                                );
                            xLog(
                                hLog,
                                XLL_WARN,
                                "Script error[%d]: unknown GetLastError define '%s'\n",
                                LineCount,
                                token
                                );
                        } else {
                            BTrav->LastError = TranslateDefine(token, Hash);
                        }
                    }
                } else {
                    state = STATE_ERROR;

                    DbgPrint(
                        "BADMAN: Script Error[%d]: Unexpected delimiter '%c'\n",
                        LineCount,
                        term
                        );
                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: unexpected delimiter '%c'\n",
                        LineCount,
                        term
                        );
                }

                break;

            case STATE_PARAM_BAD_READ:

                //
                // After we've read a bad value, we could possibly see the
                // GetLastError coming next, signaled by an '='.
                //

                if ((term == '=') && (token[0] == '\0')) {
                    state = STATE_PARAM_LASTERROR;
                    break;
                }

                state = STATE_PARAM_BAD_LIST;

                /* FALL-THROUGH */

            case STATE_API_PARAM_DONE:

                //
                // the parameter list is finished. we either get the return
                // value of the API, or the first parm info.  We'll fall
                // through in that case to the general list processing.
                //
                // Assume no return value specified, change if it turns out
                // one is.
                //

                if (state == STATE_API_PARAM_DONE) {
                    API.RValue.Type = RET_NONE;

                    if ((state == STATE_API_PARAM_DONE) && (term == '=')) {
                        if (token[0] == '\0') {
                            API.RValue.Type = RET_ISEQUAL;
                            state = STATE_API_RETURN_ASSIGN;
                            break;
                        }

                        if ((token[0] == '!') && (token[1] == '\0')) {
                            API.RValue.Type = RET_NOTEQUAL;
                            state = STATE_API_RETURN_ASSIGN;
                            break;
                        }
                    }
                }

                /* FALL-THROUGH */

            case STATE_API_RETURN_DONE:
            case STATE_PARAM_BAD_LIST:
            case STATE_PARAM_OMIT_LIST:

                //
                // The API return value was set, and now we need to start
                // reading in the good and bad parameters
                //

                if (token[0] != '\0') {
                    if (term == ':') {
                        //
                        // if a keyword has been seen
                        //

                        if (!_stricmp("DEPEND", token)) {

                            //
                            // when we go into a dependency list, all params
                            // until we see an enddepend should go under PTrav
                            // ->Depend...  Since the next thing we SHOULD
                            // read after this is a parm name, PTrav will be
                            // set to PTrav->Depend, and PTrav->next, the
                            // new parm, will be in the appropriate place.
                            //

                            state = STATE_API_RETURN_DONE;

                            PD.next = NewParmDep(PTrav->Depend, PD.next);
                        }

                        //
                        // if token's not DEPEND, it's ENDDEPEND or a parm.
                        //

                        if ( !_stricmp("enddepend", token)) {

                            if (PD.next->next != NULL) {
                                //
                                // Mark it as an end of case
                                //

                                PTrav = PD.next->P;

                                while (PTrav->next != NULL) {
                                    PTrav = PTrav->next;
                                }

                                PTrav->bIsEndCase = TRUE;

                                //
                                // delete the obsolete PD entry.
                                //

                                PDTrav = PD.next;
                                PD.next = PD.next->next;

                                free(PDTrav);

                                state = STATE_API_RETURN_DONE;
                                break;
                            } else {
                                state = STATE_ERROR;
                                DbgPrint(
                                    "BADMAN: Script Error[%d]: ENDDEPEND without matching DEPEND\n",
                                    LineCount
                                    );
                                xLog(
                                    hLog,
                                    XLL_WARN,
                                    "Script error[%d]: ENDDEPEND without matching DEPEND\n",
                                    LineCount
                                    );
                            }
                        }

                        //
                        // If an ENDCASE keyword is found, we need to note it.
                        //

                        if (!_stricmp("endcase", token)) {

                            PTrav = PD.next->P;

                            while (PTrav->next != NULL) {
                                PTrav = PTrav->next;
                            }

                            PTrav->bIsEndCase = TRUE;
                        }

                        //
                        // The token must be a param if not the previous two
                        // Make sure it's a valid parameter name
                        //

                        if (ExistingParmName(token, &API.Parms)) {

                            //
                            // PTrav will either find that parameter with an
                            // empty slot at this level of Dependency, or the
                            // end of the list.
                            //

                            PTrav = PD.next->P;

                            while (PTrav->next != NULL) {
                                PTrav = PTrav->next;

                                if (!strcmp(PTrav->Name, token)) {
                                    break;
                                }
                            }

                            //
                            // If the parm was found but already filled, go to
                            // end of the parm list for this dependency level.
                            //

                            if (PTrav != PD.next->P) {
                                if ( !strcmp(PTrav->Name, token) &&
                                     PTrav->Good.next != NULL &&
                                     PTrav->Bad.next != NULL ) {

                                    while (PTrav->next != NULL) {
                                        PTrav = PTrav->next;
                                    }
                                }
                            }

                            //
                            // If the existing entry for the parm is already
                            // full, or there wasn't one, we're at the end of
                            // the parm list and need to append a new entry
                            // with this name and type.
                            //

                            if ( PTrav == PD.next->P ||
                                 strcmp(PTrav->Name, token) ||
                                 PTrav->Good.next != NULL ||
                                 PTrav->Bad.next != NULL ) {

                                //
                                // The original parm list has all the types,
                                // so we'll steal the parm type from there.
                                //

                                PTrav2 = &API.Parms;

                                while (PTrav2->next != NULL) {
                                    PTrav2 = PTrav2->next;

                                    if (!strcmp(PTrav2->Name, token)) {
                                        break;
                                    }
                                }

                                PTrav->next = NewParm(
                                                PTrav2->Type,
                                                token,
                                                FALSE,
                                                FALSE,
                                                NULL,
                                                NULL,
                                                NULL,
                                                PTrav->next
                                                );

                                PTrav = PTrav->next;
                            }

                            state = STATE_PARAM_IDENTIFIED;
                        } else {
                            //
                            // If none of these cases was satisfied, we have an error
                            //

                            if ( _stricmp("DEPEND", token) &&
                                 _stricmp("ENDDEPEND", token) &&
                                 _stricmp("ENDCASE", token) ) {

                                state = STATE_ERROR;

                                DbgPrint(
                                    "BADMAN: Script Error[%d]: Keyword '%s' out of context.\n",
                                    LineCount,
                                    token
                                    );
                                xLog(
                                    hLog,
                                    XLL_WARN,
                                    "Script error[%d]: keyword '%s' out of context.\n",
                                    LineCount,
                                    token
                                    );
                            }
                        }
                    }

                    //
                    // It is valid for us to be out of parms and ready to
                    // start on the new API.
                    //

                    if (space || (term == ',') || (term == '=')) {
                        if ((FindString(token, DataTypes, DATA_HASH_SIZE) != NULL) && space) {
                            NextAPIType = NewCharString(token);
                            state = STATE_LOOP_THROUGH_API;
                        } else {
                            //
                            // The other possibility is that we're processing
                            // bad & omit lists.
                            //

                            switch (state) {

                            case STATE_PARAM_BAD_LIST:

                                //
                                // Processing a 'bad case' list
                                //
                                // Expand the current token if it's a macro
                                //

                                if ((MTrav = FindMacro(token, MacroHash)) != NULL) {

                                    MVTrav = &MTrav->M;

                                    while (MVTrav->next != NULL) {
                                        MVTrav = MVTrav->next;

                                        BTrav->next = NewBadVal(
                                                        MVTrav->V,
                                                        MVTrav->L,
                                                        MVTrav->LastError,
                                                        NULL
                                                        );

                                        BTrav = BTrav->next;
                                    }

                                    state = STATE_PARAM_BAD_LIST;
                                } else {
                                    //
                                    // Or check to see if it's a case.  if so,
                                    // add it to the list
                                    //

                                    if ((DTrav = FindDefine(token, Hash)) != NULL) {

                                        BTrav->next = NewBadVal(DTrav, NULL, BAD_DEFINE, NULL);
                                        BTrav = BTrav->next;

                                        if (term == '=') {
                                            state = STATE_PARAM_LASTERROR;
                                        } else {
                                            state = STATE_PARAM_BAD_READ;
                                        }
                                    } else {
                                        //
                                        // if not a macro & not a case, error
                                        //

                                        DbgPrint(
                                            "BADMAN: Script Error[%d]: Unable to translate define '%s'\n",
                                            LineCount,
                                            token
                                            );
                                        xLog(
                                            hLog,
                                            XLL_WARN,
                                            "Script error[%d]: unable to translate define '%s'\n",
                                            LineCount,
                                            token
                                            );

                                        state = STATE_ERROR;
                                    }
                                }

                                break;

                            case STATE_PARAM_OMIT_LIST:

                                //
                                // Processing an 'omit list' to remove non-bad cases.
                                //

                                if (term == '=') {
                                    state = STATE_ERROR;

                                    DbgPrint(
                                        "BADMAN: Script Error[%d]: Unexpected delimiter '%c'\n",
                                        LineCount,
                                        term
                                        );
                                    xLog(
                                        hLog,
                                        XLL_WARN,
                                        "Script error[%d]: unexpected delimiter '%c'\n",
                                        LineCount,
                                        term
                                        );
                                }

                                BTrav = &PTrav->Bad;

                                //
                                // We need to delete this token from the list
                                // of 'bad cases', since this is what Omit is
                                // for.
                                //
                                // Since there COULD be multiple cases with
                                // the same name, we'll zeke all of them.
                                //

                                Found = FALSE;

                                //
                                // Expand a macro, if found.
                                //

                                if ((MTrav = FindMacro(token, MacroHash)) != NULL) {

                                    MVTrav = &MTrav->M;

                                    while (MVTrav->next != NULL) {

                                        MVTrav = MVTrav->next;

                                        while (BTrav->next != NULL) {
                                            if (!strcmp(BTrav->next->V->Symbol, MVTrav->V->Symbol)) {
                                                BHold = BTrav->next;
                                                BTrav->next = BTrav->next->next;
                                                free(BHold);
                                                Found = TRUE;
                                            } else {
                                                BTrav = BTrav->next;
                                            }
                                        }
                                    }
                                } else {
                                    //
                                    // Otherwise see if it's a valid case
                                    //

                                    while (BTrav->next != NULL) {
                                        if (!strcmp(BTrav->next->V->Symbol, token)) {
                                            BHold = BTrav->next;
                                            BTrav->next = BTrav->next->next;
                                            free(BHold);
                                            Found = TRUE;
                                        } else {
                                            BTrav = BTrav->next;
                                        }
                                    }
                                }

                                //
                                // if we didn't find any cases for the tokens,
                                // fall through to an error.
                                //

                                if (Found) {
                                    break;
                                }

                                /* FALL-THROUGH */

                            default:

                                if (state == STATE_PARAM_OMIT_LIST) {
                                    DbgPrint(
                                        "BADMAN: Script Error[%d]: Unable to translate define '%s'\n",
                                        LineCount,
                                        token
                                        );
                                    xLog(
                                        hLog,
                                        XLL_WARN,
                                        "Script error[%d]: unable to translate define '%s'\n",
                                        LineCount,
                                        token
                                        );
                                } else {
                                    DbgPrint(
                                        "BADMAN: Script Error[%d]: Token out of context, '%s'\n",
                                        LineCount,
                                        token
                                        );
                                    xLog(
                                        hLog,
                                        XLL_WARN,
                                        "Script error[%d]: token out of context, '%s'\n",
                                        LineCount,
                                        token
                                        );
                                }

                                state = STATE_ERROR;
                                break;
                            }
                        }
                    } else if (term != ':') {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Unexpected delimeter '%c'\n",
                            LineCount,
                            term
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: unexpected delimeter '%c'\n",
                            LineCount,
                            term
                            );

                        state = STATE_ERROR;
                    }
                }

                break;

            case STATE_API_RETURN_ASSIGN:

                //
                // In this case we've read the '=' sign for the API return
                // value assignment, and need either a value or a valid
                // parameter name for the return value.
                //

                if (space) {
                    if (ExistingParmName(token, &API.Parms)) {

                        API.RValue.Type |= RET_PARM;
                        API.RValue.Value = 0;
                        PTrav = API.Parms.next;

                        while (strcmp(PTrav->Name, token)) {
                            PTrav = PTrav->next;
                            API.RValue.Value++;
                        }

                        state = STATE_API_RETURN_DONE;
                    } else {
                        API.RValue.Type |= RET_VALUE;
                        API.RValue.Value = atoi(token);
                        state = STATE_API_RETURN_DONE;
                    }
                } else {
                    DbgPrint(
                        "BADMAN: Script Error[%d]: Unexpected delimeter '%c'\n",
                        LineCount,
                        term
                        );
                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: unexpected delimeter '%c'\n",
                        LineCount,
                        term
                        );

                    state = STATE_ERROR;
                }

                break;

            case STATE_PARAM_IDENTIFIED:

                //
                // A parameter has been identified for us to get good, bad,
                // unknown, or dependant information on.
                //

                state = STATE_ERROR;

                if (term == ':') {
                    if (!_stricmp("GOOD", token)) {
                        state = STATE_PARAM_GOOD_LIST;
                        GTrav = &PTrav->Good;
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Expected keyword 'Good', not token '%s'\n",
                            LineCount,
                            token
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: expected keyword 'Good', not token '%s'\n",
                            LineCount,
                            token
                            );
                    }
                } else {
                    DbgPrint(
                        "BADMAN: Script Error[%d]: Expected keyword w/ delim ':', actual delim '%c'\n",
                        LineCount,
                        term
                        );
                    xLog(
                        hLog,
                        XLL_WARN,
                        "Script error[%d]: expected keyword w/ delim ':', actual delim '%c'\n",
                        LineCount,
                        term
                        );
                }

                break;

            case STATE_PARAM_GOOD_LIST:

                //
                // We are on the good list for a given parameter, start out by
                // assuming the worst.
                //

                state = STATE_ERROR;

                //
                // On a colon, we need either "Bad" or "omit"
                //

                if (term == ':') {
                    //
                    // if the token is bad, make bad list one by one
                    //

                    if (!_stricmp("BAD", token)) {
                        state = STATE_PARAM_BAD_LIST;
                        BTrav = &PTrav->Bad;
                    } else if (!_stricmp("OMIT", token)) {
                        //
                        // if Omit, all except under Omit which are of the
                        // same type as the parm are bad.
                        //

                        state = STATE_PARAM_OMIT_LIST;
                        BTrav = &PTrav->Bad;

                        //
                        // Insert all relevent defines, then we'll yank out
                        // the ones we don't need.  First, we need the TYPE of
                        // the current parm.
                        //

                        TypeName = PTrav->Type->Name;
                        j = strlen(TypeName);

                        //
                        // Now, we loop through the hash table of defines
                        //

                        for (i = 0; i < HASH_SIZE; i++) {
                            DTrav = &Hash[i];

                            //
                            // And check the list for each bucket
                            //

                            while (DTrav->next != NULL) {
                                DTrav = DTrav->next;

                                if (!strncmp(TypeName, DTrav->Symbol, j)) {

                                    //
                                    // take out all the good ones!
                                    //

                                    GTrav = &PTrav->Good;
                                    Found = FALSE;

                                    while (GTrav->next != NULL) {
                                        GTrav = GTrav->next;

                                        if (!strcmp(GTrav->V->Symbol, DTrav->Symbol)) {
                                            Found = TRUE;
                                            break;            // while
                                        }
                                    }

                                    if (!Found) {
                                        BTrav->next = NewBadVal(
                                                        DTrav,
                                                        NULL,
                                                        BAD_DEFINE,
                                                        BTrav->next
                                                        );

                                        BTrav = BTrav->next;
                                    }
                                }
                            }
                        }
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Expected keyword 'Bad:' or 'Omit:', not '%s:'\n",
                            LineCount,
                            token
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: expected keyword 'Bad:' or 'Omit:', not '%s:'\n",
                            LineCount,
                            token
                            );
                    }
                } else {
                    //
                    // If terminatior is NOT ':'
                    //

                    if (space || (term == ',')) {
                        if ((MTrav = FindMacro(token, MacroHash)) != NULL) {

                            MVTrav = &MTrav->M;

                            while (MVTrav->next != NULL) {
                                MVTrav = MVTrav->next;
                                GTrav->next = NewGoodVal(MVTrav->V, NULL);
                                GTrav = GTrav->next;
                            }

                            state = STATE_PARAM_GOOD_LIST;
                        } else {
                            GTrav->next = NewGoodVal(FindDefine(token, Hash), NULL);
                            GTrav = GTrav->next;

                            if (GTrav->V != NULL) {
                                state = STATE_PARAM_GOOD_LIST;
                            } else {
                                DbgPrint(
                                    "BADMAN: Script Error[%d]: Unknown symbol '%s'\n",
                                    LineCount,
                                    token
                                    );
                                xLog(
                                    hLog,
                                    XLL_WARN,
                                    "Script error[%d]: unknown symbol '%s'\n",
                                    LineCount,
                                    token
                                    );
                            }
                        }
                    } else {
                        DbgPrint(
                            "BADMAN: Script Error[%d]: Unexpected delimeter '%c'\n",
                            LineCount,
                            term
                            );
                        xLog(
                            hLog,
                            XLL_WARN,
                            "Script error[%d]: unexpected delimeter '%c'\n",
                            LineCount,
                            term
                            );
                    }
                }

                break;
            }

            if (state == STATE_LOOP_THROUGH_API) {

                if (!(CLOptions->Flags & CLOPT_PARSEONLY)) {

                    if ( (!(CLOptions->Flags & CLOPT_API)) ||
                         (!strcmp(CLOptions->APIName, API.Name)) ) {

                        if (CLOptions->Flags & CLOPT_DOCUMENT) {
                            PrintAPICall(
                                hLog, &API,
                                NULL, NULL, NULL,
                                0, i, 0, NULL,
                                TRUE, TRUE, FALSE,
                                0
                                );
                        }

                        NumVar += ProcessAPI(
                                    &API,
                                    Hash,
                                    DataTypes,
                                    CLOptions,
                                    BadmanModules,
                                    OtherModules,
                                    hLog,
                                    hConOut
                                    );
                    }
                }

                //
                // We SHOULD have the next API type in NextAPIType.
                //

                state = STATE_BEGIN;

                API.Type = FindString(
                                NextAPIType,
                                DataTypes,
                                DATA_HASH_SIZE
                                );

                if (API.Type != NULL) {
                    state = STATE_API_TYPE;
                }
            }

        }

        token[0] = '\0';
    }

    fclose( inFPtr );

    //
    // After parsing the file, we have to do the last API.
    //

    if ( (!(CLOptions->Flags & CLOPT_PARSEONLY)) && (API.Type != NULL) ) {

        if ( (!(CLOptions->Flags & CLOPT_API)) ||
             (!strcmp(CLOptions->APIName, API.Name)) ) {

            if (CLOptions->Flags & CLOPT_DOCUMENT) {
                PrintAPICall(
                    hLog, &API,
                    NULL, NULL, NULL,
                    0, i, 0,
                    NULL,
                    TRUE, TRUE, FALSE,
                    0
                    );
            }

            NumVar += ProcessAPI(
                        &API,
                        Hash,
                        DataTypes,
                        CLOptions,
                        BadmanModules,
                        OtherModules,
                        hLog,
                        hConOut
                        );
        }
    }

    return NumVar;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\engine\dllmain.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    DLL entry point for DLL version of Badman. This module will read all
    parameter settings from .ini file and pass to main in original badman.
    By doing this, we can minimize changes to original badman and minimize
    any regression bugs that might cause by our modification

Author:

    Sakphong Chanbai (schanbai) 07-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include <stdio.h>
#include "xtestlib.h"
#include "profilep.h"


typedef struct _BADMAN_STARTER_PARAMS {
    HANDLE LogHandle;
    INT    Argc;
    LPSTR* Argv;
} BADMAN_STARTER_PARAMS, *PBADMAN_STARTER_PARAMS;


HANDLE HeapHandle;


VOID
_cdecl
badman_main(
    int Argc,
    char * Argv[],
    HANDLE LogHandle
    );

BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    UNREFERENCED_PARAMETER( lpvReserved );

    if ( DLL_PROCESS_ATTACH == fdwReason ) {
        DisableThreadLibraryCalls( hInstance );
        HeapHandle = HeapCreate( 0, 0, 0 );
    } else if ( DLL_PROCESS_DETACH == fdwReason ) {
        HeapDestroy( HeapHandle );
    }

    return HeapHandle != NULL;
}


DWORD
WINAPI
BadmanThreadProc(
    PBADMAN_STARTER_PARAMS p
    )
{
    badman_main( p->Argc, p->Argv, p->LogHandle );
    return 0;
}


VOID
WINAPI
StartTest(
    IN HANDLE LogHandle
    )
{
    HANDLE ThreadHandle;
    BADMAN_STARTER_PARAMS bsp;
    char CmdLine[256];
    char KeyName[32];
    int i;


    ASSERT( LogHandle != INVALID_HANDLE_VALUE );
    bsp.LogHandle = LogHandle;

    for ( i=0; i<50; i++ ) {
        sprintf( KeyName, "CommandLine%u", i);
        GetProfileStringA( "badman", KeyName, "", CmdLine, sizeof(CmdLine) );

        if ( !CmdLine[0] ) {
            break;
        }

        bsp.Argv = CommandLineToArgvA( CmdLine, &bsp.Argc );

        //
        // We have to run badman in separate thread because badman uses a lot of
        // 'exit' C run-time library and we want to change 'exit' to ExitThread.
        //
        // Do not call ExitThread unless you create thread for it. This is
        // important for the harness
        //

        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)BadmanThreadProc,
                            (LPVOID)&bsp,
                            0,
                            NULL
                            );

            if ( !ThreadHandle ) {
                DbgPrint( "BADMAN: Unable to create thread (%d)\n", GetLastError() );
            }


        if ( ThreadHandle ) {
            WaitForSingleObject( ThreadHandle, INFINITE );
            CloseHandle( ThreadHandle );
        }

        if ( bsp.Argv ) {
            GlobalFree( bsp.Argv );
        }
    }
}


VOID
WINAPI
EndTest(
    VOID
    )
{
    KdPrint(( "BADMAN: EndTest is called\n" ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\engine\badman.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This is the main entrypoint for BadMan. for documentation of how the
    program is called, see the ReadCommandLine function in this file.

Author:

    John Miller (johnmil) 20-Jan-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and made the code more readable

--*/

#include "precomp.h"
#include <parsedef.h>
#include <teststat.h>


UINT DefaultErrorMode = 0;
char BMRoot[MAX_PATH];


void
__cdecl
badman_main(
    int    argc,
    char   **argv,
    HANDLE LogHandle
    )
{
    HANDLE hFile, hLog;
    int BMLen, i, NumVar;
    char buff[MAX_PATH];
    WCHAR wbuffer[MAX_PATH];
    CLType CLOptions;                               // Command Line Options as entered on the command line
    DefineType Hash[HASH_SIZE] = { 0 };             // List of definitions for cases
    MacroType MacroHash[MACRO_HASH_SIZE] = { 0 };   // List of Macros for cases
    StringType DataTypes[DATA_HASH_SIZE] = { 0 };   // Valid data types for API's parameters
    WIN32_FIND_DATA FDHold;

    ModType BadmanModules[BADMAN_MODULE_COUNT] = {  // Names of libraries to look-up API's and functions from
        { "apicln.dll",   NULL },
        { "setcln.dll",   NULL },
        { "validate.dll", NULL }
    };
    
    ModType OtherModules[MAX_OTHER_MODULES] = { 0 };

    hLog = LogHandle;
    ASSERT( hLog != INVALID_HANDLE_VALUE && hLog != NULL );

    BMRoot[0] = XTestLibGetTestNameSpace();
    BMRoot[1] = ':';
    BMRoot[2] = 0;
    
    //
    // ReadCommandLine returns FALSE if bad options specified
    //
    
    if ( !ReadCommandLine( argc, argv, &CLOptions ) ) {
        DbgPrint( "BADMAN: Bad option(s) in command line, check your testini.ini\n" );
        ExitThread( EXIT_FAILURE );
    }
    
    //
    // Initialize statistics
    //
    if ( CLOptions.Flags & CLOPT_PERFORMANCE ) {
        
        if ( TestStatOpen(
                (USHORT)CLOptions.MinPerfIterations,
                (USHORT)CLOptions.MaxPerfIterations ) ) {

            DbgPrint( "BADMAN: Unable to initialize Statistics, exiting...\n" );
            ExitThread( EXIT_FAILURE );
        }
    }
    
    strcpy( buff, BMRoot );
    BMLen = strlen(BMRoot);
    
    //
    // Read in the data types into the data hash table. This will be all files
    // in \inc named "*.bmd"
    //
    
    strcpy( &buff[BMLen], "\\inc\\*.bmd" );
    hFile = FindFirstFile( buff, &FDHold );
    
    if ( hFile != INVALID_HANDLE_VALUE ) {
        do {
            strcpy( &buff[ BMLen + sizeof("\\inc\\")-1 ], FDHold.cFileName );
            ReadStringHash( buff, DataTypes, DATA_HASH_SIZE );
        } while ( FindNextFile( hFile, &FDHold) );
    }
    
    FindClose(hFile);
    
    //
    // Now we need to read in all the case names and defines from the cases
    // files. This will read in all files named *.bmh in \inc
    //
    
    strcpy( &buff[BMLen], "\\inc\\*.bmh" );
    hFile = FindFirstFile( buff, &FDHold );

    if ( hFile != INVALID_HANDLE_VALUE) {
        do {
            strcpy( &buff[BMLen + strlen("\\inc\\")], FDHold.cFileName );
            ReadDefines( buff, Hash, MacroHash );
        } while ( FindNextFile( hFile, &FDHold ) );
    }

    FindClose(hFile);

    //
    // Get the handles to the libraries
    //

    for ( i=0; i<BADMAN_MODULE_COUNT; i++ ) {

        swprintf( wbuffer, L"%S", BadmanModules[i].Name );
        BadmanModules[i].h = XLoadModule( wbuffer );
        
        if ( BadmanModules[i].h == NULL ) {
            
            DbgPrint(
                "BADMAN: Unable to load library %s, LastError = %d (%s)\n",
                buff,
                GetLastError(),
                WinErrorSymbolicName(GetLastError())
                );
            
            ExitThread( EXIT_FAILURE );
        }
    }

    //
    // Parse the test script and execute tests as parsed
    //

    NumVar = Parse(
        Hash,
        MacroHash,
        DataTypes,
        &CLOptions,
        BadmanModules,
        OtherModules,
        hLog
        );
    
    //
    // Make sure we kick those nasty libraries out of memory
    //
    
    for ( i=0; i<BADMAN_MODULE_COUNT; i++ ) {
        if ( BadmanModules[i].h ) {
            XFreeModule( BadmanModules[i].h );
        }
    }
    
    for ( i=0; i<MAX_OTHER_MODULES; i++ ) {
        if ( OtherModules[i].h ) {
            XFreeModule( OtherModules[i].h );
        }
        if ( OtherModules[i].Name ) {
            free( OtherModules[i].Name );
        }
    }

    for ( i=0; i<HASH_SIZE; i++ ) {
        FreeDefineType( &Hash[i] );
    }

    for ( i=0; i<DATA_HASH_SIZE; i++ ) {
        FreeStringType( &DataTypes[i] );
    }

    for ( i=0; i<MACRO_HASH_SIZE; i++ ) {
        FreeMacroType( &MacroHash[i] );
    }

    //
    // Get rid of the test stats stuff
    //
    
    if ( CLOptions.Flags & CLOPT_PERFORMANCE ) {
        TestStatClose();
    }
}


BOOL
ReadCommandLine(
    int    argc,
    char   **argv,
    CLType *CLOptions
    )

/*++

Routine Description:

    Parse the command line with which BadMan was invoked.  If there are any
    errors, the value FALSE will be returned, and BadMan will probably exit
    without ever bothering to go any further.

Arguments:

Return Value:

--*/

{
    BOOL bRet;
    int  i, j;
    
    //
    // Establish the defaults for the CL options.
    //
    
    CLOptions->Flags = CLOPT_DEFAULT | CLOPT_NTLOG;
    CLOptions->APIName[0] = '\0';
    CLOptions->VarNum = -1;
    CLOptions->MinPerfIterations = 10;
    CLOptions->MaxPerfIterations = 100;
    
    strcpy(CLOptions->RunFile, BMRoot);
    strcat(CLOptions->RunFile, "\\scripts\\test.bms");
    
    bRet = TRUE;
    
    //
    // If there is a param with no other params, it's the script
    // Note: it gets set here, not in the for loop.
    //
    if ( (argc > 1) && (argv[1][0] != '-') ) {
        i = 2;
        if ( (argv[1][0] && argv[1][1] != ':') || argv[1][0] != '\\' ) {
            strcpy( CLOptions->RunFile, BMRoot );
            strcat( CLOptions->RunFile, "\\scripts\\" );
        }
        strcat( CLOptions->RunFile, argv[1]);
    } else {
        i = 1;
    }
    
    //
    // Loop through and process each token in the CL i was initialized above.
    //
    for ( ; bRet && (i < argc); i++) {
        
        if ( (argv[i][0] != '-') || (argv[i][2] != '\0') ) {
            bRet = FALSE;
        } else {
            switch ( argv[i][1] ) {

            case 'a': // Specify a particular API to test
            case 'A':
                CLOptions->Flags |= CLOPT_API;
                
                if ( i+1 == argc ) {
                    bRet = FALSE;
                } else {
                    strcpy( CLOptions->APIName, argv[++i] );
                }
                
                break;

            case 'b': // Specify bad parameter testing
            case 'B':
                CLOptions->Flags |= CLOPT_BAD;
                break;
                
            case 'c': // Specify we should only parse the script for correctness
            case 'C':
                CLOptions->Flags |= CLOPT_PARSEONLY;
                break;

            case 'd': // Execute DebugBreak() before API Test calls
            case 'D':
                CLOptions->Flags |= CLOPT_DBGBREAK;
                break;
                
            case 'e': // Cases generating exceptions are to be treated as successes
            case 'E':
                CLOptions->Flags |= CLOPT_NOEXCEPT;
                break;

            case 'f': // Generate performance data
            case 'F':
                CLOptions->Flags |= CLOPT_PERFORMANCE;
                
                if ( (argc > i + 2) && !_strnicmp( argv[i + 1], "-min", 4) ) {

                    j = atoi( argv[i + 2] );

                    if ( j < MIN_TIMING_ITERATIONS ) {
                        DbgPrint("BADMAN: Parameter error: -f -min must be >= %d\n", MIN_TIMING_ITERATIONS );
                        bRet = FALSE;
                    } else {
                        CLOptions->MinPerfIterations = j;
                    }

                    i += 2;
                }
                
                if ( (argc > i + 2) && !_strnicmp(argv[i + 1], "-max", 4) ) {

                    j = atoi( argv[i + 2] );

                    if ( j > MAX_TIMING_ITERATIONS) {
                        DbgPrint("BADMAN: Parameter error: -f -max must be <= %d\n", MAX_TIMING_ITERATIONS );
                        bRet = FALSE;
                    } else {
                        CLOptions->MaxPerfIterations = j;
                    }

                    i += 2;
                }

                break;

            case 'g': // Specify good parameter testing, shut off DEFAULT bad parameter testing
            case 'G':
                CLOptions->Flags |= CLOPT_GOOD;
                CLOptions->Flags &= ~CLOPT_BAD;

                //
                // If bad is explicitly requested, turn it back on.
                //

                for ( j = 1; j < argc; j++ ) {
                    
                    if ( argv[j][0] == '-' &&  argv[j][2] == '\0' &&
                         (argv[j][1] == 'b' || argv[j][1] == 'B') ) { 

                        CLOptions->Flags |= CLOPT_BAD;
                    }
                }

                break;

            case 'p': // Perform permutatively rather than linearly
            case 'P':
                CLOptions->Flags |= CLOPT_PERMUTE;
                break;

            case 's': // Specify the script file explicitly
            case 'S':
                if ( (i + 1) == argc ) {
                    bRet = FALSE;
                } else {
                    strcpy( CLOptions->RunFile, argv[++i] );
                }
                break;

            case 't':
            case 'T':
                CLOptions->Flags |= CLOPT_TEST;
                break;

            case 'v': // Specify a variation number to test
            case 'V':
                CLOptions->Flags |= CLOPT_VARIATION;
                
                if ( (i + 1) == argc ) {
                    bRet = FALSE;
                } else {
                    CLOptions->VarNum = atoi(argv[++i]);
                }
                break;

            case 'x': // Set documentation flag, turn off default testing flag
            case 'X':
                CLOptions->Flags |= CLOPT_DOCUMENT;
                CLOptions->Flags &= ~CLOPT_TEST;

                //
                // If testing is explicitly requested, turn it back on.
                //
                for (j = 1; j < argc; j++) {
                    if ( argv[j][0] == '-' && argv[j][2] == '\0' &&
                         (argv[j][1] == 't' || argv[j][1] == 'T') ) {

                        CLOptions -> Flags |= CLOPT_TEST;
                    }
                }

                break;

            case 'y': // Perform Verification testing if available
            case 'Y':
                CLOptions->Flags |= CLOPT_VALIDATE;
                break;

            case 'z': // Print out the api params/results for success as well as bad cases
            case 'Z':
                CLOptions->Flags |= CLOPT_PRINT_ALL_CALLS;
                break;
                
            default:
                bRet = FALSE;
                break;
            }
        }
    }
    
    //
    // If there was an error (or -?, which creates an error), print a
    // description of how BadMan works.
    //
    
    if ( !bRet ) {

        DbgPrint("BADMAN: ================================================================\n");
        DbgPrint("BADMAN: A program to perform bad parameter testing\n");
        DbgPrint("BADMAN: Usage: BadMan [<ScriptName>] {flags}\n");
        DbgPrint("BADMAN: Valid Flags:\n");
        DbgPrint("BADMAN:     -?             See this message\n");
        DbgPrint("BADMAN:     -a <API>       Test only script entries for <API>\n");
        DbgPrint("BADMAN:     -b             Perform Bad parameter testing\n");
        DbgPrint("BADMAN:     -c             Parse file ONLY for correctness\n");
        DbgPrint("BADMAN:     -d             DebugBreak() before API test call\n");
        DbgPrint("BADMAN:     -e             Treat exceptions as successes\n");
        DbgPrint("BADMAN:     -f [-min <int>] [-max <int>]\n");
        DbgPrint("BADMAN:                    Generate perFormance Data\n");
        DbgPrint("BADMAN:                        -min = specify minimum # of iterations\n");
        DbgPrint("BADMAN:                        -max = specify maximum # of iterations\n");
        DbgPrint("BADMAN:     -g             Perform Good parameter testing\n");
        DbgPrint("BADMAN:                        (-g cancels default -b)\n");
        DbgPrint("BADMAN:     -p             Test permutations rather than linear combos\n");
        DbgPrint("BADMAN:     -s <FName>     Specify Script File\n");
        DbgPrint("BADMAN:     -t             Perform testing\n");
        DbgPrint("BADMAN:     -v <VNum>      Run variation # <VNum> for selected entries\n");
        DbgPrint("BADMAN:     -x             Print documentation of coverage\n");
        DbgPrint("BADMAN:                        (-x cancels default -t)\n");
        DbgPrint("BADMAN:     -y             verifY result of API call if available\n");
        DbgPrint("BADMAN:     -z             Print params for good cases as well as bad\n");
        DbgPrint("BADMAN: Defaults: Test.bms -b -t\n");
        DbgPrint("BADMAN: ================================================================\n");
        
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\engine\parsefun.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    parsefun.c

Abstract:

    This module contains helper functions for the Parser for BADMAN

Author:

    John Miller (johnmil) 14-Jan-1992

Environment:

    XBox

Revision History:

    31-Mar-1995     TimF

        Made it readable

    01-Apr-2000     schanbai

        Ported to XBox and made the code more readable

--*/


#include    "precomp.h"
#include    <parsedef.h>
#include    <ctype.h>


void
DestroyParmDep(
    ParmDepType *PD
    )
{
    ParmDepType *PDHold;

    if ( PD != NULL ) {
        PD = PD->next;
    }

    while ( PD != NULL ) {

        PDHold = PD;
        PD = PD->next;
        free( PDHold );
    }
}


int
HashVal(
    char *ToHash,
    int  HashSize
    )

/*++

Routine Description:

    HashVal will take a string as its only parameter, and return a number from
    0 to HASH_SIZE that reflects the value of the hashing function when used on
    the string.  This multiplies the ascii for the entire symbol, modulo HASH_SIZE.

Arguments:

Return Value:

--*/

{
    int hold;
    char *trav;

    hold = 1;
    for ( trav=ToHash; *trav != '\0'; trav++ ) {
        hold = (hold + *trav) % HashSize;
    }

    return hold;
}


DefineType *
NewDefine(
    char *Name,
    char *Comment,
    int  Val,
    DefineType *Next
    )

/*++

Routine Description:

    NewDefine creates a new DefineType variable

Arguments:

Return Value:

--*/

{
    DefineType *Temp;

    Temp = (DefineType *)malloc( sizeof(DefineType) );

    if ( Temp == NULL ) {
        DbgPrint("BADMAN: NewDefine: Insufficient Memory to create structure.\n");
        ExitThread( EXIT_FAILURE );
    }

    Temp->Symbol = NewCharString(Name);
    Temp->Comment = NewCharString(Comment);
    Temp->Case = Val;
    Temp->next = Next;

    return Temp;
}


void
ReadDefines(
    char       *FileName,
    DefineType Hash[HASH_SIZE],
    MacroType  MacroHash[MACRO_HASH_SIZE]
    )

/*++

Routine Description:

    Reads in all of the defines in a file.  Note that this set of defines
    should ONLY be integer defines, under the current constrains of the
    system.  Note that it assumes the hash table has been allocated and
    initialized to have all entries pointing to NULL for their next.  For now,
    it is only able to read integral defines, IE a single number.  Defines are
    inserted into the front of the proper hash bucket list without bothering to
    search to see if an identical name already exists.  Since any use of this
    list will involve a search through the entries in the bucket until the
    required define is found, and will quit after finding the first entry, this
    would be redundant.

Arguments:

Return Value:

--*/

{
    char buff[1024];
    char Comment[1024];
    char DefString[256];
    char junk[256];
    char MacroName[256];
    char name[256];
    DefineType *DTrav, *DTrav2, *hTrav;
    FILE *inFPtr;
    int  CPos, DefValue, HashEntry, LineCount;
    MacroType *MTrav, *MTrav2;
    MacroValType *MVTrav, *MVTrav2;
    unsigned int i;
    
    //
    // Open the requested data file.
    //
    inFPtr = fopen( FileName, "r" );
    
    if ( inFPtr == NULL ) {
        DbgPrint("BADMAN: ReadDefines: Unable to open %s\n", FileName);
        ExitThread( EXIT_FAILURE );
    }

    LineCount = 1;
    Comment[0] = '\0';
    CPos = 0;

    while ( fgets(buff, sizeof(buff), inFPtr) != NULL ) {
        
        //
        // Find all records with #define in them in the file
        //
        if ( !strncmp( buff, "#define", sizeof("#define")-1 ) ) {

            //
            // Read them, then insert them into the correct place.
            //
            Comment[CPos] = '\0';
            CPos = 0;
            
            sscanf( buff, "%s %s %s", junk, name, DefString);
            
            //
            // Decide whether define value is a # or a name.
            //
            
            if ( isdigit(DefString[0]) ) {
                
                //
                // If a number, read it in.
                //
                sscanf( DefString, "%d", &DefValue );

            } else {

                //
                // If a name, attempt to translate it
                //
                DefValue = TranslateDefine( DefString, Hash );
                
                if ( DefValue == BAD_DEFINE ) {
                    
                    DbgPrint(
                        "BADMAN: [%s:line %d] %s is not defined, Definition for %s ignored\n",
                        FileName,
                        LineCount,
                        DefString,
                        name
                        );
                }
            }

            if ( DefValue != BAD_DEFINE ) {
                HashEntry = HashVal( name, HASH_SIZE );
                hTrav = &Hash[HashEntry];

                //
                // Defines are inserted at the front of the bucket
                //
                hTrav->next = NewDefine( name, Comment, DefValue, hTrav->next );
            }
        } else {
            if ( !_strnicmp( buff, "MACRO:", strlen("MACRO:")) ) {

                sscanf( &buff[sizeof("MACRO:")-1], "%s", MacroName );
                HashEntry = HashVal( MacroName, MACRO_HASH_SIZE );

                MTrav = &MacroHash[HashEntry];
                MTrav->next = NewMacro( MacroName, NULL, MTrav->next );
                MTrav = MTrav->next;

                MVTrav = &MTrav->M;

                while ( fgets( buff, sizeof(buff), inFPtr) != NULL &&
                        _strnicmp( buff, "ENDMACRO:", sizeof("ENDMACRO:")-1 ) ) {

                    sscanf( buff, "%s", name );
                    MTrav2 = FindMacro( name, MacroHash );

                    //
                    // If the name is ANOTHER macro, expand it in
                    //
                    if ( MTrav2 != NULL ) {

                        MVTrav2 = &MTrav2->M;

                        while ( MVTrav2->next != NULL ) {

                            MVTrav2 = MVTrav2->next;
                            MVTrav -> next = NewMacroVal(
                                                MVTrav2->V, MVTrav2 -> L,
                                                MVTrav2->LastError,
                                                NULL
                                                );

                            MVTrav = MVTrav->next;
                        }
                    } else {
                        DTrav = FindDefine( name, Hash );

                        if ( DTrav == NULL ) {
                            DbgPrint(
                                "BADMAN: [%s:line %d] %s is not defined, %s excluded from macro %s\n",
                                FileName,
                                LineCount,
                                name,
                                name,
                                MTrav->Name
                                );
                        } else {
                            for ( i=0; i<strlen(buff); i++) {
                                if ( buff[i] == '=') {
                                    break;
                                }
                            }
                            
                            DTrav2 = NULL;
                            DefValue = BAD_DEFINE;

                            if ( buff[i] == '=' ) {
                                sscanf( &buff[i + 1], "%s", DefString );

                                if ( isdigit(DefString[0]) ) {
                                    
                                    //
                                    // If a number, read it in.
                                    //
                                    sscanf( DefString, "%d", &DefValue );
                                } else {
                                    
                                    //
                                    // If a name, attempt to translate it
                                    //
                                    DefValue = TranslateDefine( DefString, Hash );

                                    if ( DefValue == BAD_DEFINE ) {
                                        
                                        DbgPrint(
                                            "BADMAN: [%s:line %d] %s is not defined, %s excluded from macro %s\n",
                                            FileName,
                                            LineCount,
                                            DefString,
                                            name,
                                            MTrav->Name
                                            );
                                    } else {
                                        DTrav2 = FindDefine( DefString, Hash );
                                    }
                                }
                            }

                            MVTrav->next = NewMacroVal( DTrav, DTrav2, DefValue, MVTrav->next );
                            MVTrav = MVTrav->next;
                        }
                    }

                    LineCount++;
                }
            } else {
                i = 0;

                while ( buff[i] != '\0' ) {

                    if ( buff[i] == '/' && buff[i + 1] == '/' ) {
                        i += 2;
                        break;
                    }

                    i++;
                }
                
                if ( buff[i] == '\0' ) {
                    CPos = 0;
                }

                while ( buff[i] != '\0' ) {
                    Comment[CPos++] = buff[i++];
                }
            }
        }

        LineCount++;
    }

    fclose( inFPtr );
}


int
TranslateDefine(
    char *DefineName,
    DefineType Hash[HASH_SIZE]
    )

/*++

Routine Description:

    Translate the define named by DefineName into its corresponding integer
    ("case number").  If there are multiple Defines of the same number in the
    hash table, only the first will be returned.  If the define name is not in
    the hash table, then BAD_DEFINE is returned.

Arguments:

Return Value:

--*/

{
    DefineType *hTrav;
    int RetVal;

    RetVal = BAD_DEFINE;
    hTrav = &Hash[HashVal( DefineName, HASH_SIZE )];

    while ( hTrav->next != NULL ) {
        hTrav = hTrav->next;

        if ( !strcmp( DefineName, hTrav->Symbol ) ) {
            RetVal = hTrav->Case;
            break;
        }
    }

    return RetVal;
}


DefineType *
FindDefine(
    char *token,
    DefineType Hash[HASH_SIZE]
    )

/*++

Routine Description:

    Looks for a define with a given name, then returns a pointer to the data
    structure entry for it in the hash table.

Arguments:

Return Value:

--*/

{
    DefineType *hTrav;

    hTrav = &Hash[ HashVal(token, HASH_SIZE) ];
    
    while ( hTrav->next != NULL ) {
        hTrav = hTrav->next;
        if ( !strcmp(token, hTrav -> Symbol) ) {
            return hTrav;
        }
    }

    return (DefineType *)NULL;
}


MacroType *
FindMacro(
    char      *token,
    MacroType MacroHash[MACRO_HASH_SIZE]
    )

/*++

Routine Description:

    Looks for a macro with the name supplied by token, then returns a pointer
    to it, else NULL if it wasn't found.

Arguments:

Return Value:

--*/

{
    MacroType *MTrav;

    MTrav = &MacroHash[ HashVal(token, MACRO_HASH_SIZE) ];

    while ( MTrav->next != NULL ) {
        MTrav = MTrav->next;

        if ( !strcmp(token, MTrav->Name) ) {
            return MTrav;
        }
    }

    return (MacroType *)NULL;
}


StringType *
FindString(
    char *token,
    StringType *SList,
    int HashSize
    )

/*++

Routine Description:

    Try to find the token in its list of Strings, SList.  If the string is
    found, a pointer is returned to that entry.  Otherwise, NULL is returned.
    Note that SList is actually a hash table, so the hashing function must be
    called on the token.

Arguments:

Return Value:

--*/

{
    StringType *STrav;

    STrav = &SList[ HashVal(token, HashSize) ];

    while ( STrav -> next != NULL ) {
        STrav = STrav->next;

        if ( !strcmp( STrav->Name, token) ) {
            return STrav;
        }
    }

    return (StringType *)NULL;
}


char *
NewCharString(
    char *Text
    )

/*++

Routine Description:

    Take the given text argument, and copies into a freshly allocated block,
    whose pointer is returned.

Arguments:

Return Value:

--*/

{
    char *Hold;
    
    Hold = malloc( sizeof(char) * (strlen(Text) + 1) );
    
    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewCharString: Unable to allocate %d bytes.\n",
            sizeof(char) * (strlen(Text) + 1)
            );
    } else {
        strcpy( Hold, Text );
    }

    return Hold;
}


ParmDepType *
NewParmDep(
    S_PARMS     *P,
    ParmDepType *next
    )

/*++

Routine Description:

    Allocate a new Parameter Dependency entry, then returns a pointer to the
    initialized structure.

Arguments:

Return Value:

--*/

{
    ParmDepType *Hold;

    Hold = malloc( sizeof(ParmDepType) );
    
    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewParmDep: Unable to allocate %d bytes.\n",
            sizeof(ParmDepType)
            );
    } else {
        Hold->P = P;
        Hold->next = next;
    }

    return Hold;
}


S_PARMS *
NewParm(
    StringType  *Type,
    char        *Name,
    BOOL        bIsEndCase,
    BOOL        NoPush,
    GoodValType *G,
    BadValType  *B,
    S_PARMS     *Depend,
    S_PARMS     *next
    )

/*++

Routine Description:

    Allocate a new Parameter entry, then returns a pointer to the initialized
    structure.

Arguments:

Return Value:

--*/

{
    S_PARMS *Hold;

    UNREFERENCED_PARAMETER( bIsEndCase );

    Hold = malloc( sizeof(S_PARMS) );
    
    if (Hold == NULL) {
        DbgPrint( "BADMAN: NewParm: Unable to allocate %d bytes.\n", sizeof(S_PARMS) );
    } else {
        Hold->Type = Type;
        Hold->Name = NewCharString(Name);
        Hold->bIsEndCase = TRUE;
        Hold->NoPush = NoPush;
        Hold->Good.next = G;
        Hold->Bad.next = B;
        Hold->Depend = malloc( sizeof(S_PARMS) );
        
        if ( Hold->Depend == NULL ) {
            DbgPrint( "BADMAN: NewParm: Unable to allocate %d bytes.\n", sizeof(S_PARMS) );
            return NULL;
        } else {
            Hold->Depend->next = Depend;
        }
        
        Hold->next = next;
    }

    return Hold;
}


BOOL
ValidParmName(
    char *Name
    )

/*++

Routine Description:

    Check to make sure that the name given is a valid variable name.  As far as
    I know, this means the first character must be alphabetic or an underscore,
    and following characters must be alphanumeric or the underscore.

Arguments:

Return Value:

--*/

{
    BOOL Hold;

    Hold = TRUE;

    if ( *Name == '_' || isalpha(*Name) ) {
        Name++;

        while ( *Name != '\0' ) {
            if ( !( *Name == '_' || isalnum(*Name) ) ) {
                Hold = FALSE;
            }

            Name++;
        }
    } else {
        Hold = FALSE;
    }

    return Hold;
}


GoodValType *
NewGoodVal(
    DefineType  *Def,
    GoodValType *next
    )

/*++

Routine Description:

    Create a GoodValType variable, and fill it with the appropriate information.

Arguments:

Return Value:

--*/

{
    GoodValType *Hold;

    Hold = malloc(sizeof (GoodValType));

    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewGoodVal: Unable to allocate %d bytes.\n",
            sizeof(GoodValType)
            );
    } else {
        Hold->V = Def;
        Hold->next = next;
    }

    return Hold;
}


BadValType *
NewBadVal(
    DefineType *Def,
    DefineType *LDef,
    int        LastError,
    BadValType *next
    )

/*++

Routine Description:

    Create a BadValType variable, and fills it with the appropriate information

Arguments:

Return Value:

--*/

{
    BadValType *Hold;

    Hold = malloc( sizeof(BadValType) );
    
    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewBadVal: Unable to allocate %d bytes.\n",
            sizeof(BadValType)
            );
    } else {
        Hold->V = Def;
        Hold->L = LDef;
        Hold->LastError = LastError;
        Hold->next = next;
    }

    return Hold;
}


MacroValType *
NewMacroVal(
    DefineType   *Def,
    DefineType   *LDef,
    int          LastError,
    MacroValType *next
    )

/*++

Routine Description:

    Create a MacroValType variable, and fills it with the appropriate information

Arguments:

Return Value:

--*/

{
    MacroValType *Hold;

    Hold = malloc( sizeof(MacroValType) );

    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewMacroVal: Unable to allocate %d bytes.\n",
            sizeof(MacroValType)
            );
    } else {
        Hold->V = Def;
        Hold->L = LDef;
        Hold->LastError = LastError;
        Hold->next = next;
    }

    return Hold;
}


MacroType *
NewMacro(
    char          *Name,
    MacroValType  *M,
    MacroType     *next
    )

/*++

Routine Description:

    Create a new macro type, and initializes it.  Note that it only makes a
    copy of the M parm.

Arguments:

Return Value:

--*/

{
    MacroType     *Hold;
    MacroValType  *MVTrav, *MVTrav2;

    Hold = malloc( sizeof(MacroType) );

    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewMacro: Unable to allocate %d bytes.\n",
            sizeof(MacroType)
            );
    } else {
        Hold->Name = NewCharString(Name);
        Hold->next = next;

        //
        // Make a copy of the M parm.
        //
        Hold->M.next = NULL;

        if ( M != NULL ) {
            MVTrav = &Hold->M;
            MVTrav2 = M;

            while ( MVTrav2->next != NULL ) {
                MVTrav2 = MVTrav2->next;
                
                // BUGBUG:  No cleanup if this fails...
                MVTrav->next = NewMacroVal(
                                    MVTrav2->V,
                                    MVTrav2->L,
                                    MVTrav2->LastError,
                                    NULL
                                    );

                MVTrav = MVTrav->next;
            }
        }
    }

    return Hold;
}


BOOL
ExistingParmName(
    char     *Name,
    S_PARMS  *PList
    )

/*++

Routine Description:

    Indicate whether or not the parameter name in question has already been
    entered. This lets us determine if entries are correct. Note that this
    test is case sensitive.

Arguments:

Return Value:

--*/

{
    S_PARMS  *PTrav;

    PTrav = PList;

    while ( PTrav->next != NULL ) {
        PTrav = PTrav->next;

        if ( !strcmp( PTrav->Name, Name ) ) {
            return TRUE;
        }
    }

    return FALSE;
}


void
ReadStringHash(
    char        *FileName,
    StringType  Hash[],
    int         HashSize
    )

/*++

Routine Description:

    Read in the entries in FileName token by token, hashing them into Hash.

Arguments:

Return Value:

--*/

{
    FILE  *inFPtr;
    char  Buff[1024];
    StringType  *STrav;

    if ( NULL == (inFPtr = fopen( FileName, "r" )) ) {
        DbgPrint( "BADMAN: ReadStringHash: Unable to open %s\n", FileName );
        ExitThread( EXIT_FAILURE );
    }

    while ( fscanf( inFPtr, "%s", Buff) != EOF ) {
        ASSERT( strlen(Buff) < sizeof(Buff) );
        STrav = &Hash[ HashVal(Buff, HashSize) ];
        STrav->next = NewString( Buff, STrav->next );
    }

    fclose( inFPtr );
}


StringType
*NewString(
    char        *token,
    StringType  *next
    )

/*++

Routine Description:

    Allocate and fill a new string

Arguments:

Return Value:

--*/

{
    StringType  *Hold;

    Hold = malloc( sizeof(StringType) );
    
    if ( Hold == NULL ) {
        DbgPrint( "BADMAN: NewString: Unable to allocate %d bytes.\n", sizeof(StringType) );
    } else {
        Hold->Name = NewCharString(token);
        Hold->next = next;
    }

    return Hold;
}


void
DumpDefines(
    DefineType Hash[HASH_SIZE]
    )

/*++

Routine Description:

    Print out a list of the defines by bucket.

Arguments:

Return Value:

--*/

{
    int i;
    DefineType *DTrav;
    
    DbgPrint("BADMAN: ------- Defines -------\n");
    
    for ( i=0; i<HASH_SIZE; i++) {
        if ( Hash[i].next != NULL ) {
            DTrav = Hash[i].next;

            while ( DTrav != NULL ) {
                DbgPrint("BADMAN: %s [%s = %d]\n",
                    DTrav -> Comment,
                    DTrav -> Symbol,
                    DTrav -> Case
                    );

                DTrav = DTrav->next;
            }
        }
    }
}


void
DumpStrings(
    StringType  Hash[],
    int         HashSize
    )

/*++

Routine Description:

    Print out a list of strings by bucket

Arguments:

Return Value:

--*/

{
    int  i;
    StringType  *DTrav;
    
    DbgPrint("BADMAN: ------- Strings -------\n");
    
    for ( i=0; i<HashSize; i++) {
        if ( Hash[i].next != NULL ) {
            DTrav = Hash[i].next;
            while ( DTrav != NULL ) {
                DbgPrint("BADMAN: [%s]", DTrav->Name);
                DTrav = DTrav->next;
            }
        }
    }
}


void
DumpParms(
    S_PARMS  *P
    )

/*++

Routine Description:

    Print out the names of parms and their dependencies.

Arguments:

Return Value:

--*/

{
    S_PARMS  *PTrav;

    if (!P) {
        return;
    }

    PTrav = P;
    
    while (PTrav != NULL) {
        DbgPrint("BADMAN: (%s ", PTrav->Name);
        DumpParms(PTrav->Depend->next);
        PTrav = PTrav->next;
    }

    DbgPrint(")\n");
}


S_PARMS
*DestroyParm(
    S_PARMS  *P
    )

/*++

Routine Description:

    Delete a S_PARMS  data structure and returns its NEXT field

Arguments:

Return Value:

--*/

{
    S_PARMS  *PHold, *PHold2, *PTrav;
    GoodValType  *GTrav, *GHold;
    BadValType  *BTrav, *BHold;
    
    PHold = P->next;
    free(P->Name);

    GTrav = P->Good.next;

    while ( GTrav != NULL ) {
        GHold = GTrav;
        GTrav = GTrav->next;
        free( GHold );
    }

    BTrav = P -> Bad.next;

    while ( BTrav != NULL ) {
        BHold = BTrav;
        BTrav = BTrav->next;
        free( BHold );
    }

    PTrav = P->Depend;

    if ( PTrav != NULL ) {
        PTrav = PTrav->next;

        while ( PTrav != NULL ) {
            PHold2 = PTrav;
            PTrav = PTrav->next;
            DestroyParm( PHold2 );
        }
    }

    free( P->Depend );

    free( P );

    return PHold;
}


SeenType *
NewSeen(
    SeenType  *next
    )

/*++

Routine Description:

    Create and initialize a structure of type SeenType.

Arguments:

Return Value:

--*/

{
    SeenType  *Hold;
    int  i;

    Hold = malloc( sizeof(SeenType) );

    if ( Hold == NULL ) {
        DbgPrint(
            "BADMAN: NewSeenType: Unable to allocate %d bytes\n",
            sizeof(SeenType)
            );
    } else {
        for ( i=0; i<MAXNOPARMS; i++ ) {
            Hold->S[i] = FALSE;
        }

        Hold->next = next;
    }

    return Hold;
}


void
DumpFullParm(
    S_PARMS *P
    )

/*++

Routine Description:

    Print the type, name, and good and bad value lists for the parameter data
    structure passed in

Arguments:

Return Value:

--*/

{
    GoodValType *GTrav;
    BadValType  *BTrav;

    DbgPrint( "BADMAN: %s %s\n", P->Type->Name, P->Name );
    DbgPrint( "BADMAN: Good:\n");

    GTrav = P->Good.next;

    while ( GTrav != NULL ) {
        DbgPrint("BADMAN: %s\n", GTrav->V->Symbol );
        GTrav = GTrav->next;
    }

    DbgPrint("BADMAN: Bad:\n");
    BTrav = P->Bad.next;

    while ( BTrav != NULL ) {
        DbgPrint("BADMAN: %s\n", BTrav->V->Symbol );

        if ( BTrav->L != NULL ) {
            DbgPrint( "BADMAN: = %s", BTrav->L->Symbol );
        }

        BTrav = BTrav->next;
    }
}


void
DumpMacros(
    MacroType  *MacroHash
    )

/*++

Routine Description:

    Print out all the macros which have been read in.

Arguments:

Return Value:

--*/

{
    MacroType     *MTrav;
    MacroValType  *MVTrav;
    int  i;
    
    DbgPrint( "BADMAN: ------ Macros ------\n" );
    
    for ( i=0; i<MACRO_HASH_SIZE; i++ ) {
        MTrav = &MacroHash[i];

        while ( MTrav->next != NULL ) {
            MTrav = MTrav->next;
            DbgPrint( "BADMAN: %s\n", MTrav->Name );

            MVTrav = &MTrav->M;

            while ( MVTrav->next != NULL ) {
                MVTrav = MVTrav->next;

                DbgPrint( "BADMAN: %s\n", MVTrav->V->Symbol );
                
                if ( MVTrav->LastError != BAD_DEFINE ) {
                    DbgPrint("BADMAN: = \n");
                    if ( MVTrav->L != NULL ) {
                        DbgPrint( "BADMAN: %s\n", MVTrav->L->Symbol );
                    } else {
                        DbgPrint("BADMAN: %x\n", MVTrav->LastError );
                    }
                }
            }
        }
    }
}


VOID
FreeDefineType(
    DefineType * ptr
    )
{
    while ( ptr->next ) {
        DefineType * p = ptr->next;
        ptr->next = p->next;
        free( p->Symbol );
        free( p->Comment );
        free( p );
    }
}


VOID
FreeStringType(
    StringType * ptr
    )
{
    while ( ptr->next ) {
        StringType * p = ptr->next;
        ptr->next = p->next;
        free( p->Name );
        free( p );
    }
}


VOID
FreeValType(
    MacroValType * ptr
    )
{
    while ( ptr->next ) {
        MacroValType * p = ptr->next;
        ptr->next = p->next;
        FreeDefineType( p->V );
        FreeDefineType( p->L );
        free( p );
    }
}


VOID
FreeMacroType(
    MacroType * ptr
    )
{
    while ( ptr->next ) {
        MacroType * p = ptr->next;
        ptr->next = p->next;
        free( p->Name );
        FreeValType( &p->M );
        free( p );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\engine\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

Author:

    Sakphong Chanbai (schanbai) 07-Mar-2000

Environment:

    XBox

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

#include <xtl.h>
#include "xlog.h"
#include "xtestlib.h"
#include "xbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\e_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    e_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'E'. It also contains setup and cleanup
    funtions beginning with 'LPE'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <e_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\b_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    b_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'B'. It also contains setup and cleanup
    funtions beginning with 'LPB'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <B_Cases.bmh>


/************************
BBBB   OOO   OOO  L
B   B O   O O   O L
BBBB  O   O O   O L
B   B O   O O   O L
BBBB   OOO   OOO  LLLLL
************************/

BOOL BOOLSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    BOOL Ret;

    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hConOut );
    UNREFERENCED_PARAMETER( hLog );
    
    switch(CaseNo) {
    case BOOL_TRUE:
        Ret = TRUE;
        break;
    case BOOL_FALSE:
        Ret = FALSE;
        break;
    default:
        ErrorPrint(hConOut,hLog,"BOOLSetup",CaseNo,"Unknown Case");
        Ret = (BOOL) NULL;
        break;
    }
    
    return(Ret);
}


void BOOLCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}



/************************
BBBB  Y   Y TTTTT EEEEE
B   B  Y Y    T   E
BBBB    Y     T   EEEE
B   B   Y     T   E
BBBB    Y     T   EEEEE
************************/

BYTE BYTESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    BYTE Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );

    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"BYTESetup",CaseNo,"Unknown Case");
        Ret = (BYTE)0;
        break;
    }
    
    return(Ret);
}


void BYTECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}



/************************************************
L     PPPP  BBBB  IIIII TTTTT M   M   A   PPPP
L     P   P B   B   I     T   MM MM  A A  P   P
L     PPPP  BBBB    I     T   M M M AAAAA PPPP
L     P     B   B   I     T   M   M A   A P
LLLLL P     BBBB  IIIII   T   M   M A   A P
************************************************/

PVOID LPBITMAPSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPBITMAP Ret;
    
    switch(CaseNo) {
    case LPBITMAP_NULL:
        Ret     = NULL;
        *SCInfo = ( LPVOID ) Ret;
        break;
        
    case LPBITMAP_VALID:
        if ( NULL != (Ret = LocalAlloc(LPTR,sizeof(BITMAP))) ) {
            Ret->bmType       = 0;
            Ret->bmWidth      = 32;
            Ret->bmHeight     = Ret->bmWidth;
            Ret->bmWidthBytes = Ret->bmWidth / 8;
            Ret->bmPlanes     = 1;
            Ret->bmBitsPixel  = 1;
            Ret->bmBits       = NULL;
        }  //  if ( Ret = LocalAlloc(LPTR,sizeof(BITMAP)) )
        
        *SCInfo = ( LPVOID ) Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPBITMAPSetup",CaseNo,"Unknown Case");
        Ret = (LPBITMAP) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}


void LPBITMAPCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
    case LPBITMAP_NULL:
        break;
        
    case LPBITMAP_VALID:
        LocalFree ( (HGLOBAL) *SCInfo );
        break;
    default:
        break;
    }
}



/************************************************************************
L     PPPP  BBBB  IIIII TTTTT M   M   A   PPPP  IIIII N   N FFFFF  OOO
L     P   P B   B   I     T   MM MM  A A  P   P   I   NN  N F     O   O
L     PPPP  BBBB    I     T   M M M AAAAA PPPP    I   N N N FFFF  O   O
L     P     B   B   I     T   M   M A   A P       I   N  NN F     O   O
LLLLL P     BBBB  IIIII   T   M   M A   A P     IIIII N   N F      OOO
************************************************************************/

PVOID LPBITMAPINFOSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPBITMAPINFO Ret;
    
    switch(CaseNo) {
        
    case LPBITMAPINFO_NULL:
        Ret = (LPBITMAPINFO) NULL;
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPBITMAPINFO_MINUS_ONE:
        Ret = (LPBITMAPINFO) -1;
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPBITMAPINFO_VALID:
        Ret = (LPBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFO));
        if(!Ret) {
            ErrorPrint(hConOut,hLog,"LPBITMAPINFOSetup",CaseNo, "Insufficient Memory");
            Ret = (LPBITMAPINFO)NULL;
        }
        
        *SCInfo = (LPVOID) Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPBITMAPINFOSetup",CaseNo,"Unknown Case");
        Ret = (LPBITMAPINFO) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}


void LPBITMAPINFOCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
        
    case LPBITMAPINFO_VALID:
        if(*SCInfo)
            LocalFree(*SCInfo);
        break;
        
    default:
        break;
    }
}



/******************************************************************************
L     PPPP  BBBB  IIIII TTTTT M   M   A   PPPP  IIIII N   N FFFFF  OOO  H   H
L     P   P B   B   I     T   MM MM  A A  P   P   I   NN  N F     O   O H   H
L     PPPP  BBBB    I     T   M M M AAAAA PPPP    I   N N N FFFF  O   O HHHHH
L     P     B   B   I     T   M   M A   A P       I   N  NN F     O   O H   H
LLLLL P     BBBB  IIIII   T   M   M A   A P     IIIII N   N F      OOO  H   H
******************************************************************************/

PVOID LPBITMAPINFOHEADERSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPBITMAPINFOHEADER Ret;
    
    switch(CaseNo) {
        
    case LPBITMAPINFOHEADER_NULL:
        Ret = (LPBITMAPINFOHEADER) NULL;
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPBITMAPINFOHEADER_MINUS_ONE:
        Ret = (LPBITMAPINFOHEADER) -1;
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPBITMAPINFOHEADER_VALID:
        Ret = (LPBITMAPINFOHEADER) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER));
        if(!Ret) {
            ErrorPrint(hConOut,hLog,"LPBITMAPINFOHEADERSetup",CaseNo, "Insufficient Memory");
            Ret = (LPBITMAPINFOHEADER)NULL;
        }
        
        *SCInfo = (LPVOID) Ret;
        break;
        
        
    default:
        ErrorPrint(hConOut,hLog,"LPBITMAPINFOHEADERSetup",CaseNo,"Unknown Case");
        Ret = (LPBITMAPINFOHEADER) NULL;
        *SCInfo = (LPVOID) Ret;
        break;
    }
    
    return(Ret);
#endif

    return 0;
}


void LPBITMAPINFOHEADERCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
        
    case LPBITMAPINFOHEADER_VALID:
        if(*SCInfo)
            LocalFree(*SCInfo);
        break;
        
    default:
        break;
    }
}



/************************************
L     PPPP  BBBB   OOO   OOO  L
L     P   P B   B O   O O   O L
L     PPPP  BBBB  O   O O   O L
L     P     B   B O   O O   O L
LLLLL P     BBBB   OOO   OOO  LLLLL
************************************/

LPBOOL LPBOOLSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPBOOL Ret;
    BOOL *bPresent;
    
    switch(CaseNo) {
        
    case LPBOOL_VALID_BUFFER:
        bPresent = (BOOL *) LocalAlloc(LPTR, sizeof(BOOL));
        if(!bPresent) {
            ErrorPrint(hConOut,hLog,"LPBOOLSetup",CaseNo, "Insufficient Memory");
            Ret = (BOOL)NULL;
        }
        else {
            *SCInfo = bPresent;
            Ret = bPresent;
        }
        break;
    case LPBOOL_NULL:
        Ret = (LPBOOL)NULL;
        break;
        
    case LPBOOL_INVALID: {
        SE_CLEANUP_INFO		*CleanupInfo = NULL;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            INVALID_POINTER,
            0,
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPBOOLSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                         }
        
    case LPBOOL_MALALIGNED: {
        SE_CLEANUP_INFO		*CleanupInfo = NULL;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            MALALIGNED_POINTER_1,
            sizeof (BOOL),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPBOOLSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                            }
        
    default:
        ErrorPrint(hConOut,hLog,"LPBOOLSetup",CaseNo,"Unknown Case");
        Ret = (LPBOOL) NULL;
        break;
    }
    
    return(Ret);
}


void LPBOOLCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPBOOL_VALID_BUFFER:
        if(*SCInfo)
            LocalFree(*SCInfo);
        break;
        
    case LPBOOL_INVALID:
    case LPBOOL_MALALIGNED: {
        SE_CLEANUP_INFO		*CleanupInfo = NULL;
        
        MakeBadPointer(NULL,
            (SE_CLEANUP_INFO **)SCInfo,
            CLEANUP,
            0,
            hConOut,
            hLog);
        
        if (*SCInfo) {
            ErrorPrint(hConOut, hLog, "LPBOOLCleanup", CaseNo,
                "Cleanup failed.");
        }
        
        break;
                            }
        
    default:
        break;
    }
}


/************************************
L     PPPP  BBBB  Y   Y TTTTT EEEEE
L     P   P B   B  Y Y    T   E
L     PPPP  BBBB    Y     T   EEEE
L     P     B   B   Y     T   E
LLLLL P     BBBB    Y     T   EEEEE
************************************/

LPBYTE LPBYTESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPBYTE Ret,lpbTemp;
    int i;
    
    switch(CaseNo) {
    case LPBYTE_13_PTS:
        
        Ret = (LPBYTE)GlobalAlloc(GPTR, 13 * sizeof (BYTE));
        if (Ret){
            lpbTemp= Ret;
            for (i = 0; i < 13; i++)
                *lpbTemp++ = 0x02;
        } else {
            ErrorPrint(hConOut,hLog,"LPBYTESetup",CaseNo,"allocation failed");
        }  
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPBYTE_BAD_13_PTS:
        
        // alloc 13 bytes set to 0 (not PT_*)      
        Ret = (LPBYTE)GlobalAlloc(GPTR, 13 * sizeof (BYTE));
        if (!Ret){
            ErrorPrint(hConOut,hLog,"LPBYTESetup",CaseNo,"allocation failed");
        }  
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPBYTE_NULL:
        Ret = (LPBYTE)NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPBYTESetup",CaseNo,"Unknown Case");
        Ret = (LPBYTE) NULL;
        break;
    }
    
    return(Ret);
}


void LPBYTECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPBYTE_13_PTS:
    case LPBYTE_BAD_13_PTS:
        if (SCInfo != NULL) 
            if (GlobalFree((HANDLE)*SCInfo) != NULL) 
                ErrorPrint(hConOut,hLog,"LPBYTECleanup",CaseNo,"Couldn't free");
            break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\d_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    d_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'D'. It also contains setup and cleanup
    funtions beginning with 'LPD'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <malloc.h>
#include <stdlib.h>
#include <time.h>
#include <setcln.h>
#include <filever.h>
// #include <d3d.h>
#include <D_Cases.bmh>
#include <S_Cases.bmh>
#include <memmgt.h>
// #include <ddeml.h>


int TranslateCase(int CaseNo);

/******************************
DDD   W   W  OOO  RRRR  DDD
D  D  W   W O   O R   R D  D
D   D W W W O   O RRRR  D   D
D   D WW WW O   O R  R  D   D
DDDD  W   W  OOO  R   R DDDD
******************************/

// defs for memmgt alloc flags:

#define GA_VALID  (DWORD)( GMEM_DISCARDABLE | GMEM_FIXED     | GMEM_LOWER     |   \
    GMEM_MOVEABLE      | GMEM_NOCOMPACT | GMEM_NODISCARD | \
    GMEM_NOT_BANKED  | GMEM_NOTIFY    | GMEM_SHARE     |   \
    GMEM_ZEROINIT    | GMEM_DDESHARE )

#define GR_VALID  (DWORD)( GMEM_DISCARDABLE | GMEM_MOVEABLE  | GMEM_MODIFY    |   \
    GMEM_NODISCARD   | GMEM_ZEROINIT )

#define LA_VALID  (DWORD)( LMEM_DISCARDABLE | LMEM_FIXED     | LMEM_MOVEABLE    | \
    LMEM_NOCOMPACT   | LMEM_NODISCARD | LMEM_ZEROINIT )

#define LR_VALID  (DWORD)( LMEM_DISCARDABLE | LMEM_MOVEABLE  | LMEM_MODIFY    |   \
    LMEM_ZEROINIT )

#define GA_INVALID   (DWORD)( ~ GA_VALID )
#define GR_INVALID   (DWORD)( ~ GR_VALID )
#define LA_INVALID   (DWORD)( ~ LA_VALID )
#define LR_INVALID   (DWORD)( ~ LR_VALID )



// extern HDDEDATA CALLBACK DdeCallback(UINT uType, UINT uFmt, HCONV hconv, HSZ hsz1,       
//                                      HSZ hsz2, HDDEDATA hdata, DWORD dwData1, DWORD dwData2);



DWORD DWORDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    DWORD dwRet = 0;
    
    switch (CaseNo) {
    case DWORD_VALID_LOCALALLOC_FLAGS:
        dwRet = LMEM_MOVEABLE | LMEM_DISCARDABLE;
        break;
    case DWORD_VALID_AND_SPURIOUS_LOCALALLOC_FLAGS:
        dwRet = LA_INVALID | LMEM_MOVEABLE;
        break;
    case DWORD_SPURIOUS_LOCALALLOC_FLAGS:
        dwRet = LA_INVALID;
        break;
    case DWORD_VALID_GLOBALALLOC_FLAGS:
        dwRet = GMEM_MOVEABLE;
        break;
    case DWORD_VALID_AND_SPURIOUS_GLOBALALLOC_FLAGS:
        dwRet = GA_INVALID | GMEM_MOVEABLE | GMEM_DISCARDABLE;
        break;
    case DWORD_SPURIOUS_GLOBALALLOC_FLAGS:
        dwRet = GA_INVALID;
        break;
    case DWORD_VALID_LOCALREALLOC_FLAGS:
        dwRet = LMEM_MOVEABLE;
        break;
    case DWORD_INVALID_LOCALREALLOC_FLAGS:
        dwRet = LMEM_DISCARDABLE;
        break;
    case DWORD_VALID_AND_SPURIOUS_LOCALREALLOC_FLAGS:
        dwRet = LR_INVALID | LMEM_MODIFY | LMEM_DISCARDABLE;
        break;          
    case DWORD_SPURIOUS_LOCALREALLOC_FLAGS:
        dwRet = LR_INVALID;
        break;
    case DWORD_VALID_GLOBALREALLOC_FLAGS:
        dwRet = GMEM_MOVEABLE;
        break;
    case DWORD_INVALID_GLOBALREALLOC_FLAGS:
        dwRet = GMEM_DISCARDABLE;
        break;
    case DWORD_VALID_AND_SPURIOUS_GLOBALREALLOC_FLAGS:
        dwRet = GR_INVALID | GMEM_MODIFY;
        break;
    case DWORD_SPURIOUS_GLOBALREALLOC_FLAGS:
        dwRet = GR_INVALID;
        break;
    case DWORD_ONE:
        dwRet = 1;
        break;
    case DWORD_ZERO:
        dwRet = 0;
        break;
    case DWORD_ONE_K:
        dwRet = 1024;
        break;
    case DWORD_ONE_MEG:
        dwRet = 1024*1024;
        break;
    case DWORD_MINUS_ONE:
        dwRet = (DWORD)-1;
        break;
    case DWORD_32MB:
        dwRet = 32*1024*1024;
        break;
    case DWORD_THREE_GIG:
        dwRet = 1024U*1024U*1024U*3U;
        break;
    case DWORD_ACCESSMASK_GENALL:
        dwRet = GENERIC_ALL;
        break;
    case DWORD_ACCESSMASK_GENREAD:
        dwRet = GENERIC_READ;
        break;
    case DWORD_ACCESSMASK_GRANTED:
        dwRet = STANDARD_RIGHTS_READ | TOKEN_QUERY | TOKEN_ADJUST_GROUPS;
        break;
    case DWORD_ACCESSMASK_DESIRED:
        dwRet = STANDARD_RIGHTS_READ | TOKEN_QUERY;
        break;
    case DWORD_VMEM_COMMIT_FLAG:
        dwRet = MEM_COMMIT;
        break;
    case DWORD_VMEM_RESERVE_FLAG:
        dwRet = MEM_RESERVE;
        break;
    case DWORD_VMEM_READWRITE_FLAG:
        dwRet = PAGE_READWRITE;
        break;
    case DWORD_INVALID_VMEM_PROT:
        dwRet = (DWORD)~(PAGE_NOACCESS|PAGE_READONLY|PAGE_READWRITE);
        break;
    case DWORD_VMEM_DECOMMIT_FLAG:
        dwRet = MEM_DECOMMIT;
        break;
    case DWORD_VMEM_RELEASE_FLAG:
        dwRet = MEM_RELEASE;
        break;
    case DWORD_VMEM_INVAL_FREETYPE:
        dwRet = (DWORD)~(MEM_DECOMMIT|MEM_RELEASE);
        break;
    case DWORD_VMEM_INFOSIZE:
        dwRet = sizeof(MEMORY_BASIC_INFORMATION);
        break;
    case DWORD_HEAP_SERIALIZE_FLAG:
        dwRet = HEAP_NO_SERIALIZE;
        break;
    case DWORD_HEAP_BADSERFLAG:
        dwRet = (DWORD)~HEAP_NO_SERIALIZE;
        break;
    case DWORD_VMEM_BADALLOCFLAG:
        dwRet = (DWORD)~(MEM_COMMIT | MEM_RESERVE);
        break;
        
    case DWORD_PROCESS_ALL_ACCESS:
        dwRet = PROCESS_ALL_ACCESS;
        break;
    case DWORD_PROCESS_DUP_HANDLE:
        dwRet = PROCESS_DUP_HANDLE;
        break;
    case DWORD_PROCESS_QUERY_INFORMATION:
        dwRet = PROCESS_QUERY_INFORMATION;
        break;
    case DWORD_PROCESS_SET_INFORMATION:
        dwRet = PROCESS_SET_INFORMATION;
        break;
    case DWORD_PROCESS_SYNCHRONIZE:
    case DWORD_THREAD_SYNCHRONIZE:
        dwRet = SYNCHRONIZE;
        break;
    case DWORD_PROCESS_VM_READ:
        dwRet = PROCESS_VM_READ;
        break;
    case DWORD_PROCESS_VM_WRITE:
        dwRet = PROCESS_VM_WRITE;
        break;
    case DWORD_PROCESS_BAD_ACCESS:
        dwRet = ~(PROCESS_ALL_ACCESS|SYNCHRONIZE|ACCESS_SYSTEM_SECURITY|
            GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE|GENERIC_ALL|
            MAXIMUM_ALLOWED);
        break;
    case DWORD_THREAD_ALL_ACCESS:
        dwRet = THREAD_ALL_ACCESS;
        break;
    case DWORD_THREAD_GET_CONTEXT:
        dwRet = THREAD_GET_CONTEXT;
        break;
    case DWORD_THREAD_QUERY_INFORMATION:
        dwRet = THREAD_QUERY_INFORMATION;
        break;
    case DWORD_THREAD_SET_INFORMATION:
        dwRet = THREAD_SET_INFORMATION;
        break;
    case DWORD_THREAD_SET_CONTEXT:
        dwRet = THREAD_SET_CONTEXT;
        break;
    case DWORD_THREAD_SUSPEND_RESUME:
        dwRet = THREAD_SUSPEND_RESUME;
        break;
    case DWORD_THREAD_BAD_ACCESS:
        dwRet = ~(THREAD_ALL_ACCESS|SYNCHRONIZE|ACCESS_SYSTEM_SECURITY|
            GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE|GENERIC_ALL|
            MAXIMUM_ALLOWED);
        break;
    case DWORD_TOKEN_PRIV_LENGTH:
        dwRet = sizeof(TOKEN_PRIVILEGES);
        break;
    case DWORD_TOKEN_GROUPS_LENGTH:
        dwRet = sizeof(TOKEN_GROUPS);
        break;
    case DWORD_GMEM_MODIFY_FLAG:
        dwRet = GMEM_MODIFY;
        break;
    case DWORD_LMEM_MODIFY_FLAG:
        dwRet = LMEM_MODIFY;
        break;
    case DWORD_NORMAL_PRIORITY_CLASS:
        dwRet = 0x20;
        break;
    case DWORD_IDLE_PRIORITY_CLASS:
        dwRet = 0x40;
        break;
    case DWORD_HIGH_PRIORITY_CLASS:
        dwRet = 0x80;
        break;
    case DWORD_CREATE_SUSPENDED:
        dwRet = CREATE_SUSPENDED;
        break;
    case DWORD_CREATE_NEW_CONSOLE:
        dwRet = 0x10;
        break;
    case DWORD_CREATE_DETACHED_PROCESS:
        dwRet = 0x8;
        break;
    case DWORD_CREATE_DETACHED_AND_NEW_CONSOLE:
        dwRet = 0x18;
        break;
    case DWORD_CREATE_MULTIPLE_PRIORITY_CLASSES:
        dwRet = 0xe0;
        break;
    case DWORD_CURRENT_PROCESS_ID:
        dwRet = 8;
        break;
    case DWORD_NORMAL_THREAD_FLAGS:
        dwRet = 0;
        break;
    case DWORD_THREAD_CREATE_SUSPENDED:
        dwRet = CREATE_SUSPENDED;
        break;
    case DWORD_VALID_TLS_SLOT:
        dwRet = TlsAlloc();
        if (dwRet==(-1L))
            ErrorPrint(hConOut,hLog,"DWORDSetup",CaseNo,"TlsAlloc failed" );
        *SCInfo = (LPVOID) dwRet;
        break;
    case DWORD_FREED_TLS_SLOT:
        dwRet = TlsAlloc();
        if (dwRet==(-1L))
            ErrorPrint(hConOut,hLog,"DWORDSetup",CaseNo,"TlsAlloc failed" );
        if (!TlsFree(dwRet))
            ErrorPrint(hConOut,hLog,"DWORDSetup",CaseNo,"TlsFree failed" );
        break;
    case DWORD_GENERIC_READ_AND_WRITE:
    case DWORD_GENERIC_INVALID_VALUE:
    case DWORD_FILE_SHARE_READ_AND_WRITE:
    case DWORD_FILE_SHARE_READ_WRITE_DELETE:
    case DWORD_FILE_SHARE_INVALID_VALUE:
    case DWORD_DISPOSITION_CREATE_FILE_ALWAYS:
    case DWORD_DISPOSITION_INVALID_VALUE:
    case DWORD_FILE_FLAGS_NORMAL:
    case DWORD_FILE_FLAGS_INVALID_VALUE:
    case DWORD_READWRITE_VALID_BUFFER_SIZE:
    case DWORD_READWRITE_INVALID_BUFFER_SIZE:
    case DWORD_VOLUME_NAME_BUFFER_LENGTH:
    case DWORD_FILE_SYSTEM_NAME_BUFFER_LENGTH:
    case DWORD_NORMAL_FILE_ATTRIBUTES:
    case DWORD_INVALID_FILE_ATTRIBUTES:
    case DWORD_VER_INVALID_FIND_FLAGS:
    case DWORD_VER_INVALID_INST_FLAGS:
    case DWORD_VER_VALID_INFO_LENGTH:
    case DWORD_VER_LANG_US_ENGLISH:
    case DWORD_VER_LANG_UNDEFINED:
    case DWORD_VER_LANGUAGE_BUFFER_SIZE:
        dwRet = FIODwordSetup(CaseNo, SCInfo, hLog, hConOut);
        break;
    case DWORD_VALID_PATH_BUFFER_LENGTH:
        dwRet = MAX_PATH;
        break;
    case DWORD_MOVE_METHOD_FILE_BEGIN:
        dwRet = FILE_BEGIN;
        break;
    case DWORD_MOVE_METHOD_INVALID_VALUE:
        dwRet = (DWORD)~( FILE_BEGIN | FILE_CURRENT | FILE_END );
        break;
    case DWORD_LOGICAL_DRIVE_STRING_BUFFER_LENGTH:
        dwRet = FIO_LOGICAL_DRIVE_STRING_BUFFER_LENGTH;
        break;
    case DWORD_MAX:
        dwRet = 0xffffffff;
        break;
    case DWORD_VALID_CHANGE_NOTIFY_FILTER:
        dwRet = FILE_NOTIFY_CHANGE_FILE_NAME;
        break;
    case DWORD_INVALID_CHANGE_NOTIFY_FILTER:
        dwRet = (DWORD)~ ( FILE_NOTIFY_CHANGE_FILE_NAME  |
            FILE_NOTIFY_CHANGE_DIR_NAME   |
            FILE_NOTIFY_CHANGE_ATTRIBUTES |
            FILE_NOTIFY_CHANGE_SIZE       |
            FILE_NOTIFY_CHANGE_LAST_WRITE |
            FILE_NOTIFY_CHANGE_SECURITY );
        break;
        
    case DWORD_12:
        dwRet = 12;
        break;
    case DWORD_13:
        dwRet = 13;
        break;
    case DWORD_16:
        dwRet = 16;
        break;
    case DWORD_50:
        dwRet = 50;
        break;
    case DWORD_64K:
        dwRet = 65535;
        break;
    case DWORD_65537:
        dwRet = 65537;
        break;
    case DWORD_EIGHT:
        dwRet = 8;
        break;
    case DWORD_FOUR:
        dwRet = 4;
        break;
    case DWORD_GENERIC_ALL:
        dwRet = GENERIC_ALL;
        break;
    case DWORD_GENERIC_EXECUTE:
        dwRet = GENERIC_EXECUTE;
        break;
    case DWORD_GENERIC_READ:
        dwRet = GENERIC_READ;
        break;
    case DWORD_GENERIC_WRITE:
        dwRet = GENERIC_WRITE;
        break;
    case DWORD_MIN_SD_LENGTH:
        dwRet = SECURITY_DESCRIPTOR_MIN_LENGTH;
        break;
    case DWORD_RANDOM:
        //
        // rand_max is 0x7FFF or 32k, so add two of them together and shift
        // them high, then add two more to cover the low end.  This should
        // provide a range of nearly every possible 32 bit number (DWORD).
        //
        dwRet = ((rand() + rand()) << 16) | (rand() + rand());
        break;
    case DWORD_READ_CONTROL:
        dwRet = READ_CONTROL;
        break;
    case DWORD_SYNCHRONIZE:
        dwRet = SYNCHRONIZE;
        break;
    case DWORD_TWO:
        dwRet = 2;
        break;

#if 0
    case DWORD_D3DEXECUTE_CLIPPED:
        dwRet = D3DEXECUTE_CLIPPED;
        break;
    case DWORD_D3DEXECUTE_UNCLIPPED:
        dwRet = D3DEXECUTE_UNCLIPPED;
        break;
    case DWORD_D3DEXECUTE_BOTH:
        dwRet = (D3DEXECUTE_CLIPPED | D3DEXECUTE_UNCLIPPED);
        break;
#endif 0

    case DWORD_D3DEXECUTE_NONE:
        dwRet = 0;
        break;
        
    case DWORD_THREADID:
        dwRet = GetCurrentThreadId();
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"DWORDSetup",CaseNo,"Unknown Case");
        dwRet = 0;
        break;
    }
  
    return dwRet;
}

void DWORDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case DWORD_VALID_TLS_SLOT:
        if (!TlsFree((DWORD)(*SCInfo)))
            ErrorPrint(hConOut,hLog,"DWORDCleanup",CaseNo,"TlsFree failed" );
        break;
    default:
        break;
    }
}



/******************************
L     PPPP  DDD    CCC  BBBB
L     P   P D  D  C   C B   B
L     PPPP  D   D C     BBBB
L     P     D   D C   C B   B
LLLLL P     DDDD   CCC  BBBB
******************************/

PVOID LPDCBSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPDCB Ret;

    UNREFERENCED_PARAMETER( SCInfo );

    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"LPDCBSetup",CaseNo,"Unknown Case");
        Ret = (LPDCB) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}


void LPDCBCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}



/******************************************************************************
L     PPPP  DDD   EEEEE BBBB  U   U  GGGG       EEEEE V   V EEEEE N   N TTTTT
L     P   P D  D  E     B   B U   U G           E     V   V E     NN  N   T
L     PPPP  D   D EEEE  BBBB  U   U G  GG       EEEE  V   V EEEE  N N N   T
L     P     D   D E     B   B U   U G   G       E      V V  E     N  NN   T
LLLLL P     DDDD  EEEEE BBBB   UUU   GGG  _____ EEEEE   V   EEEEE N   N   T
******************************************************************************/

PVOID LPDEBUG_EVENTSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPDEBUG_EVENT Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"LPDEBUG_EVENTSetup",CaseNo,"Unknown Case");
        Ret = (LPDEBUG_EVENT) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}


void LPDEBUG_EVENTCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}

/******************************************
L     PPPP  DDD   W   W  OOO  RRRR  DDD
L     P   P D  D  W   W O   O R   R D  D
L     PPPP  D   D W W W O   O RRRR  D   D
L     P     D   D WW WW O   O R  R  D   D
LLLLL P     DDDD  W   W  OOO  R   R DDDD
******************************************/

LPDWORD LPDWORDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPDWORD Ret, lpPtr;
    DWORD dwBlank;
    
    switch(CaseNo) {
    case LPDWORD_BUFFER:
        Ret = (LPDWORD) LocalAlloc(LPTR, sizeof(DWORD));
        if(!Ret) {
            ErrorPrint(hConOut,hLog,"LPDWORDSetup",CaseNo,
                "insufficient memory");
            break;
        }
        *SCInfo = Ret;
        break;
        
    case LPDWORD_NULL:
        Ret = (LPDWORD)NULL;
        break;
    case LPDWORD_MINUS_ONE:
        Ret = (LPDWORD)(-1L);
        break;
    case LPDWORD_RANDOM_POINTER:
        Ret = (LPDWORD)rand();
        break;
    case LPDWORD_DWORD_SIZED_BLOCK:
        Ret = &dwBlank;
        break;
    case LPDWORD_VALID_ADDRESS:
        if ( (Ret = malloc(sizeof(DWORD))) == NULL )
            ErrorPrint(hConOut,hLog,"LPDWORDSetup",CaseNo,
            "Error allocating memory");
        *SCInfo = (LPVOID) Ret;
        break;
        
    case LPDWORD_454:
        Ret = (LPDWORD) LocalAlloc(LPTR, 3*sizeof(DWORD));
        if(!Ret) {
            ErrorPrint(hConOut,hLog,"LPDWORDSetup",CaseNo,
                "LocalAlloc Failed");
            break;
        } else {
            lpPtr = Ret;
            *lpPtr++ = 4;
            *lpPtr++ = 5;
            *lpPtr++ = 4;
        }
        *SCInfo = Ret;
        break;
        
    case LPDWORD_64K:
    /*
    * points to 65536...almost
    *
    * I just arbitrarly decided this should be 64k; but because of a bug
    * reduced it to 64k-2
        */
        
        if (NULL != (Ret = (LPDWORD)GlobalAlloc(GPTR, sizeof(DWORD)))) {
            ErrorPrint(hConOut, hLog, "LPDWORDSetup", CaseNo,
                "GlobalAlloc failed");
        } else {
            *Ret = 65534;
            *SCInfo = Ret;
        }
        
        break;
        
    case LPDWORD_TWO:
    /*
    * points to some value > 0, and < min(number of butes needed to hold
    * the shortest privilege name, shortest ASCII privilege display name)
        */
        
        if (NULL != (Ret = (LPDWORD)GlobalAlloc(GPTR, sizeof(DWORD)))) {
            ErrorPrint(hConOut, hLog, "LPDWORDSetup", CaseNo,
                "GlobalAlloc failed");
        } else {
            *Ret = 2;
            *SCInfo = Ret;
        }
        
        break;
        
    case LPDWORD_ZERO:
    /*
    * points to a 0
        */
        
        if (NULL != (Ret = (LPDWORD)GlobalAlloc(GPTR, sizeof(DWORD)))) {
            ErrorPrint(hConOut, hLog, "LPDWORDSetup", CaseNo,
                "GlobalAlloc failed");
        } else {
            *Ret = 0;
            *SCInfo = Ret;
        }
        
        break;
        
        /*
        * Several of these cases allocate memory only in this pass, and then in
        * second pass set the value at the memory location...  Watch
        * carefully...
        */
        
    case LPDWORD_INVALID: {
    /*
    * an invalid pointer
        */
        
        SE_CLEANUP_INFO      *CleanupInfo = NULL;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            INVALID_POINTER,
            0,
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPDWORDSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                          }
        
    case LPDWORD_10:
    case LPDWORD_50:
    case LPDWORD_65537:
    case LPDWORD_FOUR: {
        SE_CLEANUP_INFO      *CleanupInfo = NULL;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            sizeof (DWORD),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPDWORDSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                                          }
        
    case LPDWORD_MALALIGNED: {
        SE_CLEANUP_INFO      *CleanupInfo = NULL;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            MALALIGNED_POINTER_1,
            sizeof(DWORD),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPDWORDSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                             }
        
    default:
        ErrorPrint(hConOut,hLog,"LPDWORDSetup",CaseNo,"Unknown Case");
        Ret = (LPDWORD)NULL;
        break;
    }
    
    /*
    * some of these take a second part:
    */
    
    try {
        switch (CaseNo) {
        case LPDWORD_10:
            
            *Ret = 10;
            
            break;
            
        case LPDWORD_50:
            
            *Ret = 50;
            
            break;
            
        case LPDWORD_65537:
            
            *Ret = 65537;
            
            break;
            
        case LPDWORD_FOUR:
            
            *Ret = 4;
            
            break;
            
        default:
            
        /*
        * Nothing happens here, whatever may reach here was completely set up
        * in the first part.
            */
            
            break;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    /*
    * just go silently along
        */
    }
    
    return(Ret);
}


void LPDWORDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPDWORD_64K:
    case LPDWORD_TWO:
    case LPDWORD_ZERO:
        if(*SCInfo) {
            LocalFree(*SCInfo);
        }
        break;
        
    case LPDWORD_VALID_ADDRESS:
        if ( *SCInfo != NULL )
            free(*SCInfo);
        break;
        
    case LPDWORD_INVALID:
    case LPDWORD_10:
    case LPDWORD_50:
    case LPDWORD_65537:
    case LPDWORD_FOUR:
    case LPDWORD_MALALIGNED:
        if (*SCInfo) {
        /*
        * Make the cleanup call
            */
            
            MakeBadPointer(NULL,
                (SE_CLEANUP_INFO **)SCInfo,
                CLEANUP,
                0,
                hConOut,
                hLog);
            
            if (*SCInfo) {
                ErrorPrint(hConOut, hLog, "LPDWORDCleanup", CaseNo,
                    "Cleanup failed.");
            }
        }
        
        break;
        
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\engine\procapi.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    procapi.c

Abstract:

    This module contains information related to processing an API, including
    locating calls to parameter setup and cleanup, and locating the API to be
    called.

Author:

    John Miller (johnmil) 16-Jan-1992

Environment:

    XBox

Revision History:

    10-Apr-1992     JohnMil

        Cganhed comment to indented comments

    31-Mar-1995     TimF

        Made it readable

    01-Apr-2000     schanbai

        Ported to XBox and made the code more readable

--*/


#include "precomp.h"
#include "parsedef.h"
#include "Timing.h"
#include "teststat.h"


DWORD
CallAPI(
    int             iNumParms,
    FARDPROC        pfnAPI,
    DWORD           *dwParms
);


int
ProcessAPI(
    APIType         *API,
    DefineType      Hash[HASH_SIZE],
    StringType      DataTypes[DATA_HASH_SIZE],
    CLType          *CLOptions,
    ModType         BadmanModules[BADMAN_MODULE_COUNT],
    ModType         OtherModules[MAX_OTHER_MODULES],
    HANDLE          hLog,
    HANDLE          hConOut
)
{
    // ParmList the list of parameters to pass on.
    S_PARMS         ParmList[MAXNOPARMS] = {0},
                    *PTrav,
                    *PTrav2;
    ParmDepType     *PDHold,
                    ParmDep;
    FARFNSETUP      pfnSetup[MAXNOPARMS];
    FARFNCLEANUP    pfnCleanup[MAXNOPARMS];
    FARFNVALIDATE   pfnValidate = NULL;
    FARFNAPICLN     pfnAPICln;
    FARDPROC        pfnAPI = NULL;
    int             i,
                    ParmGoodBad[MAXNOPARMS],
                    NumParms = 0,
                    NumVar = 0,
                    Variation = 0;
    char            FunName[132];
    BOOL            DoPerm,
                    Found = FALSE;
    DefineType      VarInfo[MAXNOPARMS];
    SeenType        Seen,
                    *SHold;

    DoPerm = CLOptions->Flags & CLOPT_PERMUTE;

    //
    // First, we need to determine the base set of parms. This is all the
    // parms, in order, until one in the list is repeated.  Note that these
    // are the defaults for each param, and when dependencies and whatnot are
    // inserted, they'll be put before the default in the bucket for that parm#
    //

    PTrav = &API->Parms;

    while ((PTrav->next != NULL) && !Found) {
        PTrav = PTrav->next;
        PTrav2 = &API->Parms;

        while (PTrav2->next != PTrav) {
            PTrav2 = PTrav2->next;

            if (!strcmp(PTrav->Name, PTrav2->Name)) {
                Found = TRUE;
            }
        }

        if (!Found) {
            //
            // The default will always be the last entry in the list for each
            // parameter #.
            //

            ParmList[NumParms++].next = NewParm(
                                            PTrav->Type,
                                            PTrav->Name,
                                            PTrav->bIsEndCase,
                                            PTrav->NoPush,
                                            PTrav->Good.next,
                                            PTrav->Bad.next,
                                            PTrav->Depend,
                                            NULL
                                            );
        }
    }

    //
    // PD will be used to keep us in line insofar as dependency lists goes: as
    // each dependency list is entered, PD.next will point to that list. As it
    // is exited, PDep.next will be destroyed, and the previous PD.next will
    // move into position.
    //
    // The defaults have been entered. Now we need to find the address of the
    // API, and of each parameters setup and cleanup functions.
    //
    // First, search through the modules for The API's address
    //

    for (i = 0; i < MAX_OTHER_MODULES; i++) {
        if (OtherModules[i].h) {
            if ((pfnAPI = (FARDPROC)GetProcAddress(OtherModules[i].h, API->Name)) != NULL) {
                break;
            }
        } else {
            break;
        }
    }

    if (pfnAPI ==  NULL) {
        xSetFunctionName( hLog, API->Name ); 
        xStartVariation( hLog, API->Name );
        xLog( hLog, XLL_BLOCK, "%s was not found as an API", API->Name );
        xEndVariation( hLog );
        return 0;
    }

    if (CLOptions->Flags & CLOPT_VALIDATE) {
        sprintf(FunName, "%sValidate", API->Name);
        pfnValidate = (FARFNVALIDATE) \
            GetProcAddress(
                BadmanModules[BADMAN_MODULE_NUM_VALIDATE].h,
                FunName
                );
    }

    if (CLOptions->Flags & CLOPT_VALIDATE) {
        if (!pfnValidate) {
            KdPrint(("BADMAN: Validation function not found, %s\n", FunName));
        }
    }

    //
    // Get API Cleanup routine address
    //

    sprintf(FunName, "%sAPICleanup", API->Name);

    pfnAPICln = (FARFNAPICLN) \
        GetProcAddress(BadmanModules[BADMAN_MODULE_NUM_APICLN].h, FunName);

    //
    // Next, find each of the setup and cleanup functions for the Parameters.
    //

    for (i=0; i < NumParms; i++) {
        sprintf(FunName, "%sSetup", ParmList[i].next->Type->Name);

        pfnSetup[i] = (FARFNSETUP) \
            GetProcAddress(BadmanModules[BADMAN_MODULE_NUM_SETCLN].h, FunName);

        if ( !pfnSetup[i] ) {

            KdPrint((
                "BADMAN: setup function was missing for %s (%s)\n",
                ParmList[i].next->Type->Name, 
                FunName
                ));

            xSetFunctionName( hLog, API->Name ); 
            xStartVariation( hLog, API->Name );
            xLog(
                hLog,
                XLL_BLOCK,
                "Setup function was missing for %s",
                ParmList[i].next->Type->Name
                );
            xEndVariation( hLog );

            ExitThread( EXIT_FAILURE );
        }

        sprintf(FunName, "%sCleanup", ParmList[i].next->Type->Name);

        pfnCleanup[i] = (FARFNCLEANUP) \
            GetProcAddress(BadmanModules[BADMAN_MODULE_NUM_SETCLN].h, FunName);

        if ( !pfnCleanup[i] ) {

            KdPrint((
                "BADMAN: cleanup function was missing for %s (%s)\n",
                ParmList[i].next->Type->Name, 
                FunName
                ));

            xSetFunctionName( hLog, API->Name ); 
            xStartVariation( hLog, API->Name );
            xLog(
                hLog,
                XLL_BLOCK,
                "Cleanup function was missing for %s",
                ParmList[i].next->Type->Name
                );
            xEndVariation( hLog );

            ExitThread( EXIT_FAILURE );
        }
    }

    //
    // Now that we have all the setup and cleanup functions, we can begin
    // processing.
    //

    i = CLOPT_GOOD;

    do {
        NumVar += GenParm(
                    ParmList, 0,
                    NumParms,
                    pfnSetup,
                    pfnCleanup,
                    pfnAPI,
                    pfnValidate,
                    pfnAPICln,
                    DoPerm ? (CLOptions->Flags & (CLOPT_GOOD | CLOPT_BAD)) : i,
                    &Variation,
                    CLOptions,
                    VarInfo,
                    API,
                    0,
                    ParmGoodBad,
                    hLog,
                    hConOut
                    );

        i += (CLOPT_BAD - CLOPT_GOOD);

    } while ((i == CLOPT_BAD) && !DoPerm);

    //
    // We want to loop through all the different dependencies and variations.
    // For an explanation, consult the dox. This is COMPLICATED.
    //

    Seen.next = NewSeen(NULL);
    ParmDep.next = NewParmDep(PTrav, NULL);

    if (Found) {
        do {
            PTrav = ParmDep.next->P;

            //
            // If we're at the end of a dependency level
            //

            if (PTrav == NULL) {
                for (i = 0; i < MAXNOPARMS; i++) {
                    if (Seen.next->S[i] == TRUE) {
                        ParmList[i].next = DestroyParm(ParmList[i].next);
                    }
                }

                SHold = Seen.next;
                Seen.next = SHold->next;
                free(SHold);

                PDHold = ParmDep.next;
                ParmDep.next = PDHold->next;
                free(PDHold);

                //
                // However, since the Dependency indicated the end of a case,
                // we need to clear out the claptrap.
                //

                for (i = 0; (i < MAXNOPARMS) && (Seen.next != NULL); i++) {
                    if (Seen.next->S[i]) {
                        ParmList[i].next = DestroyParm(ParmList[i].next);
                        Seen.next->S[i] = FALSE;
                    }
                }
            } else {
                //
                // Else we're NOT at the end of a dependency level.
                //
                // Find the entry, or a previous parameter seen
                //

                for (i = 0; strcmp(ParmList[i].next->Name, PTrav->Name) && (i < MAXNOPARMS); i++) {
                    if (Seen.next->S[i]) {
                        break;
                    }
                }

                //
                // if it hasn't been seen, insert it.
                //

                if (!Seen.next->S[i]) {
                    ParmList[i].next = NewParm(
                                            PTrav->Type,
                                            PTrav->Name,
                                            PTrav->bIsEndCase,
                                            PTrav->NoPush,
                                            PTrav->Good.next,
                                            PTrav->Bad.next,
                                            NULL,
                                            ParmList[i].next
                                            );

                    Seen.next->S[i] = TRUE;

                    //
                    // If we're at the end of a dependency list, test API
                    //

                    if ((PTrav->next == NULL) && (PTrav->Depend->next == NULL)) {

                        i = CLOPT_GOOD;

                        do {
                            NumVar += GenParm(
                                        ParmList,
                                        0,
                                        NumParms,
                                        pfnSetup,
                                        pfnCleanup,
                                        pfnAPI,
                                        pfnValidate,
                                        pfnAPICln,
                                        DoPerm ? (CLOptions->Flags & (CLOPT_GOOD | CLOPT_BAD)) : i,
                                        &Variation,
                                        CLOptions,
                                        VarInfo,
                                        API,
                                        0,
                                        ParmGoodBad,
                                        hLog,
                                        hConOut
                                        );

                            i += (CLOPT_BAD - CLOPT_GOOD);

                        } while ((i == CLOPT_BAD) && !DoPerm);
                    }

                    ParmDep.next->P = ParmDep.next->P->next;

                    if (PTrav->Depend->next != NULL) {
                        Seen.next = NewSeen(Seen.next);
                        ParmDep.next = NewParmDep(PTrav->Depend->next, ParmDep.next);
                    }
                } else {
                    //
                    // Parameter has already been seen, so time to call test
                    //

                    i = CLOPT_GOOD;

                    do {
                        NumVar += GenParm(
                                    ParmList,
                                    0,
                                    NumParms,
                                    pfnSetup,
                                    pfnCleanup,
                                    pfnAPI,
                                    pfnValidate,
                                    pfnAPICln,
                                    DoPerm ? (CLOptions->Flags & (CLOPT_GOOD | CLOPT_BAD)) : i,
                                    &Variation,
                                    CLOptions,
                                    VarInfo,
                                    API,
                                    0,
                                    ParmGoodBad,
                                    hLog,
                                    hConOut
                                    );

                        i += (CLOPT_BAD - CLOPT_GOOD);

                    } while ((i == CLOPT_BAD) && !DoPerm);

                    for ( i=0; i<MAXNOPARMS; i++ ) {
                        if (Seen.next->S[i]) {
                            ParmList[i].next = DestroyParm(ParmList[i].next);
                            Seen.next->S[i] = FALSE;
                        }
                    }
                }
            }
        } while ( ParmDep.next != NULL );
    }

    DestroyParmDep( &ParmDep );

    while ( Seen.next ) {
        PVOID p = Seen.next;
        Seen.next = Seen.next->next;
        free( p );
    }

    for (i = 0; i < MAXNOPARMS; i++) {
        while (ParmList[i].next) {
            ParmList[i].next = DestroyParm(ParmList[i].next);
        }
    }

    DataTypes;    // -W3 warning elimination
    Hash;         // -W3 warning elimination

    return NumVar;
}


int
GenParm(
    S_PARMS        ParmList[MAXNOPARMS],
    int            ParmNo,
    int            NumParms,
    FARFNSETUP     pfnSetup[MAXNOPARMS],
    FARFNCLEANUP   pfnCleanup[MAXNOPARMS],
    FARDPROC       pfnAPI,
    FARFNVALIDATE  pfnValidate,
    FARFNAPICLN    pfnAPICln,
    int            GoodBad,
    int            *Variation,
    CLType         *CLOptions,
    DefineType     VarInfo[MAXNOPARMS],
    APIType        *API,
    int            MadeParm,
    int            ParmGoodBad[MAXNOPARMS],
    HANDLE         hLog,
    HANDLE         hConOut
    )

/*++

Routine Description:

    GenParm is a recursive routine, which will step through all combinations of
    the values for each parameter in ParmList. If GoodBad is set to CLOPT_GOOD,
    then only valid combinations are tested. If GoodBad is set to CLOPT_BAD,
    then only invalid combinations are tested. For testing, each Good or Bad
    value (depending upon which we're testing)is tried once for each
    parameter, with the rest of the parameters fixed to their first good value.
    So suppose we have 3 parameters, P1 P2 and P3, with Gx meaning a good value
    for that parm, and Bx meaning a bad value.

       P1 = G1 G2 B1 B2 B3
       P2 = G1 G2 G3 B1 B2 B3
       P3 = G1 G2 G3 B1 B2

    Then if we want to generate the Good combinations, our variations would be:

       P1    P2  P3
       --------------
       G1    G1  G1
       G1    G1  G2
       G1    G1  G3
       G1    G2  G1
       G1    G3  G1
       G2    G1  G1

    and if we wanted to generate the Bad combinations:

       P1    P2  P3
       --------------
       G1    G1  B1
       G1    G1  B2
       G1    B1  G1
       G1    B2  G1
       G1    B3  G1
       B1    G1  G1
       B2    G1  G1
       B3    G1  G1

    After the last parameter is determined for each variation, documentation
    and/or testing is called.

Arguments:

Return Value:

--*/

{
    BadValType          *BTrav;
    BOOL                GLPass,
                        VarPass,
                        Converge,
                        DoTime,
                        DoLog,
                        DoExcept,
                        CallExcepted,
                        IsGoodCall;
    char                TimeBuff[132];
    char                VariationBuffer[256];
    DWORD               dwRetVal=0,
                        dwExpRetVal,
                        dwParms[MAXNOPARMS];
    GoodValType         *GTrav;
    int                 CurPass=0,
                        i,
                        j,
                        GLVal=0,
                        NumPasses = 0,
                        NumVar = 0,
                        TimeSum = 0;
    LPVOID              lpvSCInfo[MAXNOPARMS];
    PULONG              pulData=NULL;     // Used for performance
    SHORT               hTimer=0;
    USHORT              usElementsInArray,
                        usDiscardedElements;

    //DbgPrint("\n--------\nParmNo %d\nNumParms %d\n----------", ParmNo, NumParms);

    //
    // If we've figured out the parm combination, we need to generate the
    // parms and test.
    //

    if (ParmNo == NumParms) {
        (*Variation)++;

        if ( (!(CLOptions->Flags & CLOPT_VARIATION)) || (CLOptions->VarNum == *Variation) ) {

            //
            // If we're supposed to document, print it out.
            //

            if ( (CLOptions->Flags & CLOPT_DOCUMENT) &&
                 (CLOptions->Flags & GoodBad) ) {

                KdPrint(("BADMAN: Variation %d:\n", *Variation));

                //
                // Print each of the parm define names
                //

                for ( i=0; i<NumParms; i++) {
                    //
                    // +'s around good parms, -'s around bad parms
                    //

                    if (ParmGoodBad[i] & CLOPT_BAD) {
                        KdPrint((
                            "BADMAN:  -%s-: %s - %s",
                            ParmList[i].next->Name,
                            VarInfo[i].next->Symbol,
                            VarInfo[i].next->Comment
                            ));
                    } else {
                        KdPrint((
                            "BADMAN:  +%s+: %s - %s",
                            ParmList[i].next->Name,
                            VarInfo[i].next->Symbol,
                            VarInfo[i].next->Comment
                            ));
                    }
                }
            }

            if (CLOptions->Flags & GoodBad) {
                NumVar++;
            }

            //
            // If we're supposed to test this api, then do so.  Use
            // try-excepts around all possible problem areas
            //

            if ((CLOptions->Flags & CLOPT_TEST) && (CLOptions->Flags & GoodBad)) {

                //
                // **** This is the API CALL Section ****
                //

                DoLog = CLOptions->Flags & CLOPT_NTLOG;
                DoTime = CLOptions->Flags & CLOPT_PERFORMANCE;
                DoExcept = CLOptions->Flags & CLOPT_NOEXCEPT;

                if (DoLog) {
                    xSetFunctionName( hLog, API->Name );

                    for ( i=0; i<NumParms; i++ ) {
                        if ( ParmGoodBad[i] & CLOPT_BAD ) {
                            sprintf( VariationBuffer, "p%d=%s", i, VarInfo[i].next->Symbol );
                        }
                    }

                    xStartVariation( hLog, VariationBuffer );
                }

                Converge = FALSE;
                CallExcepted = FALSE;

                if (DoTime) {
                    TimerOpen(&hTimer, MICROSECONDS);

                    TimeSum = NumPasses = 0;

                    TestStatInit();

                    pulData = calloc(CLOptions->MaxPerfIterations, sizeof (ULONG));

                    if (pulData == NULL) {
                        DbgPrint("BADMAN: Insufficient memory for performance. aborting.\n");
                        xLog( hLog, XLL_BLOCK, "Insufficient memory for performance. aborting." );
                        ExitThread( EXIT_FAILURE );
                    }
                }

                do {
                    //
                    // Set up the parms.  We'd really rather not do this here,
                    // but inside the "if (SiftAgain)" region, except that
                    // doing so makes parameter setup subject to sifting as
                    // well, which we don't want.
                    //

                    ULONG NoPushParms = 0;

                    for ( i=0; i<NumParms; i++) {

                        // zero-init SCInfo each time.
                        lpvSCInfo[i] = NULL;

                        try {
                            dwParms[i] = (DWORD)pfnSetup[i](
                                                    VarInfo[i].next->Case,
                                                    &lpvSCInfo[i],
                                                    hLog,
                                                    hConOut
                                                    );
                        } except( EXCEPTION_EXECUTE_HANDLER ) {
                            DbgPrint(
                                "BADMAN: Exception generated in setup for param %2d, %s, case name: %s\n",
                                i,
                                ParmList[i].next->Name,
                                VarInfo[i].next->Symbol
                                );
                        }

                        // BUGBUG: This is dangerous, because it requires that NOPUSH parameters 
                        //         come after pushable ones, and we don't enforce that.

                        NoPushParms += ParmList[i].next->NoPush ? 1 : 0;
                    }

                    //
                    // Call the actual test
                    //

                    if (CLOptions->Flags & CLOPT_DBGBREAK) {
                        DebugBreak();
                    }

                    try {
                        if (DoTime) {
                            TimerInit(hTimer);
                        }

                        //
                        // Technically we shouldn't call SetLastError inside
                        // the timed region, but it's the only way we can be
                        // certain that the timer-init code won't screw it...
                        //
                        // If your wondering how much it affects timing, on a
                        // xbox it's a few simple instruction:
                        //
                        // xapi!SetLastError:
                        // bfe6650c 55               push    ebp
                        // bfe6650d 8bec             mov     ebp,esp
                        // bfe6650f 64a124010000     mov     eax,fs:[00000124]
                        // bfe66515 8b80c0010000     mov     eax,[eax+0x1c0]
                        // bfe6651b 8b4d08           mov     ecx,[ebp+0x8]
                        // bfe6651e 8908             mov     [eax],ecx
                        // bfe66520 5d               pop     ebp
                        // bfe66521 c20400           ret     0x4
                        //

                        SetLastError(ERROR_SUCCESS);
                        //XapiGetCurrentThread()->LastError = ERROR_SUCCESS;

                        dwRetVal = CallAPI(NumParms - NoPushParms, pfnAPI, dwParms);

                        if (DoTime) {
                            CurPass = TimerRead(hTimer);
                        }

                        GLVal = GetLastError();
                        //GLVal = XapiGetCurrentThread()->LastError;

                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                        if (DoTime) {
                            CurPass = pulData[NumPasses] = TimerRead(hTimer);
                        }

                        CallExcepted = TRUE;
                    }

                    try {
                        //
                        // Call to Validation routine.
                        //
                        if (pfnValidate != NULL) {
                            pfnValidate(VarInfo, dwParms, ParmGoodBad, dwRetVal, hLog, hConOut);
                        }
                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                        DbgPrint(
                            "BADMAN: Exception generated in %sValidate, variation %d\n",
                            API->Name,
                            *Variation
                            );
                    }

                    try {
                        //
                        // Call to API Cleanup, if it exists.
                        //

                        if (pfnAPICln != NULL) {
                            pfnAPICln(dwRetVal, dwParms, hConOut, hLog);
                        }
                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                        DbgPrint(
                            "BADMAN: Exception generated in %sAPICln, variation %d\n",
                            API->Name,
                            *Variation
                            );
                    }

                    //
                    // Destroy "clean up" the parms
                    //

                    for ( i=0; i<NumParms; i++ ) {
                        try {

                            pfnCleanup[i](VarInfo[i].next->Case, &lpvSCInfo[i], hLog, hConOut);

                        } except( EXCEPTION_EXECUTE_HANDLER ) {

                            DbgPrint(
                                "BADMAN: Exception generated in CleanUp for parm %d, %s, case name: %s\n",
                                i,
                                ParmList[i].next->Name,
                                VarInfo[i].next->Symbol
                                );
                        }
                    }

                    //
                    // Check for convergence for timing operations
                    //

                    if (DoTime) {
                        Converge = TestStatConverge(CurPass);

                        if (!(NumPasses % 7)) {
                            DbgPrint("\n");
                        }

                        NumPasses++;

                        DbgPrint(" %9d", CurPass);

                        TimeSum += CurPass;

                        if (NumPasses > CLOptions->MaxPerfIterations) {
                            DbgPrint("\n[Max Timing Iterations reached]");

                            if (DoLog) {
                                xLog(
                                    hLog,
                                    XLL_WARN,
                                    "%s Var %d -- MaxTiming Iterations reached",
                                    API->Name,
                                    *Variation
                                    );
                            }

                            break;
                        }
                    } else {
                        Converge = TRUE;
                    }
                } while (!Converge);

                if (DoTime) {
                    usElementsInArray = (USHORT)NumPasses;
                    usDiscardedElements = 0;

                    TestStatValues(
                        TimeBuff,
                        (USHORT)0,
                        &pulData,
                        &usElementsInArray,
                        &usDiscardedElements
                        );

                    DbgPrint("\nMode       Mean    Minimum    Maximum    #iter  pr.    st. dev. #out  oc");
                    DbgPrint("\n%s", TimeBuff);

                    if (DoLog) {
                        xLog(
                            hLog,
                            XLL_INFO,
                            "\nMode       Mean    Minimum    Maximum    #iter  pr.    st. dev. #out  oc"
                            );

                        xLog(hLog, XLL_INFO, "%s", TimeBuff);
                    }

                    TimerClose(hTimer);
                    free(pulData);
                }

                //
                // **** End of the API CALL Section ****
                //

                //
                // Evaluate GetLastError results
                //

                GLPass = FALSE;

                //
                // If any bad parms have return values specified, we will have
                // to investigate further. Otherwise GetLastError "passes".
                // We'll use j to detect if any parms are bad
                //

                for (i = 0, j = 1; i < NumParms; i++) {
                    if (ParmGoodBad[i] & CLOPT_BAD) {
                        //
                        // We need to find the current value in the bad list
                        //

                        j = 0;
                        BTrav = ParmList[i].next->Bad.next;

                        while(BTrav->next != NULL) {
                            BTrav = BTrav->next;

                            if (BTrav->V == VarInfo[i].next) {
                                break;
                            }
                        }

                        //
                        // If there's a GetLastError value, we need to check
                        // it.  Note that in the case of multiple bad
                        // parameters, ANY bad parameter missing a
                        // GetLastError will pass the variation!
                        //

                        if (BTrav->LastError == BAD_DEFINE) {
                            GLPass = TRUE;
                        } else if (GLVal == BTrav->LastError) {
                            GLPass = TRUE;
                        }
                    }
                }

                //
                // If there were only good parms, we don't worry about the
                // return value of GetLastError for now.
                //

                if (j) {
                    GLPass = TRUE;
                }

                //
                // Verify that the case passed.
                //

                dwExpRetVal = (API->RValue.Type & RET_PARM) ? dwParms[API->RValue.Value] : API->RValue.Value;

                if (API->RValue.Type & RET_NONE) {
                    VarPass = TRUE;
                } else {
                    VarPass = ((!j) == (dwRetVal == dwExpRetVal));

                    if (API->RValue.Type & RET_NOTEQUAL) {
                        VarPass = !VarPass;
                    }
                }

                VarPass = VarPass && GLPass;
                IsGoodCall = TRUE;

                for (i = 0; i < NumParms; i++) {
                    if (ParmGoodBad[i] & CLOPT_BAD) {
                        IsGoodCall = FALSE;
                        break;
                    }
                }

                if (CallExcepted) {
                    //
                    // if we're ignoring exceptions, count as a pass
                    //

                    if (DoExcept && !IsGoodCall) {
                        VarPass = TRUE;
                    } else {
                        //
                        // otherwise, an exception is a failure.
                        //

                        VarPass = FALSE;

                        //if (hLog != NULL) {
                            //xLog( hLog, XLL_FAIL, "The API call generated an exception." );
                        //}
                    }
                }

                if (VarPass) {
                    if (CLOptions->Flags & CLOPT_PRINT_ALL_CALLS) {
                        PrintAPICall(
                            hLog,
                            API, 
                            ParmList,
                            VarInfo,
                            dwParms,
                            dwRetVal,
                            *Variation,
                            NumParms,
                            ParmGoodBad,
                            GLPass,
                            VarPass,
                            CallExcepted,
                            GLVal
                            );
                    } else {
                        //DbgPrint(".");
                    }
                } else {
                    PrintAPICall(
                        hLog,
                        API,
                        ParmList,
                        VarInfo,
                        dwParms,
                        dwRetVal,
                        *Variation,
                        NumParms,
                        ParmGoodBad,
                        GLPass,
                        VarPass,
                        CallExcepted,
                        GLVal
                        );
                }

                if (DoLog) {

                    if (VarPass) {
                        xLog( hLog, XLL_PASS, "pass" );
                    }
                    //else {
                        //xLog(hLog, XLL_FAIL, "Variation Fails");
                    //}

                    //xLog( hLog, XLL_INFO, "%s Var %d", API->Name, *Variation );
                    xEndVariation( hLog );
                }
            }
        }
    } else {
        //
        // If we are NOT done generating all the parms, we need to.  Made parm
        // indicates whether or not we've reached the parm to loop through
        // (the rest fixed)
        //

        if (CLOptions->Flags & CLOPT_PERMUTE) {
            //
            // If we're going to do permutations, loop through permutation
            // values for this parameter, first through all good, then through
            // all bad (as applic.)
            //

            if (GoodBad & CLOPT_GOOD) {
                GTrav = &ParmList[ParmNo].next->Good;

                ParmGoodBad[ParmNo] = CLOPT_GOOD;

                while (GTrav->next != NULL) {
                    GTrav = GTrav->next;

                    VarInfo[ParmNo].next = GTrav->V;

                    NumVar += GenParm(
                                ParmList,
                                ParmNo + 1,
                                NumParms,
                                pfnSetup,
                                pfnCleanup,
                                pfnAPI,
                                pfnValidate,
                                pfnAPICln,
                                GoodBad,
                                Variation,
                                CLOptions,
                                VarInfo,
                                API,
                                MadeParm,
                                ParmGoodBad,
                                hLog,
                                hConOut
                                );
                }
            }

            if (GoodBad & CLOPT_BAD) {
                BTrav = &ParmList[ParmNo].next->Bad;
                ParmGoodBad[ParmNo] = CLOPT_BAD;

                while (BTrav->next != NULL) {
                    BTrav = BTrav->next;
                    VarInfo[ParmNo].next = BTrav->V;

                    NumVar += GenParm(
                                ParmList,
                                ParmNo + 1,
                                NumParms,
                                pfnSetup,
                                pfnCleanup,
                                pfnAPI,
                                pfnValidate,
                                pfnAPICln,
                                GoodBad,
                                Variation,
                                CLOptions,
                                VarInfo,
                                API,
                                MadeParm,
                                ParmGoodBad,
                                hLog,
                                hConOut
                                );
                }
            }
        } else {
            if (!MadeParm) {
                if (ParmNo != (NumParms - 1)) {
                    ParmGoodBad[ParmNo] = CLOPT_GOOD;

                    if (ParmList[ParmNo].next->Good.next != NULL) {

                        VarInfo[ParmNo].next = ParmList[ParmNo].next->Good.next->V;

                        NumVar += GenParm(
                                    ParmList,
                                    ParmNo + 1,
                                    NumParms,
                                    pfnSetup,
                                    pfnCleanup,
                                    pfnAPI,
                                    pfnValidate,
                                    pfnAPICln,
                                    GoodBad,
                                    Variation,
                                    CLOptions,
                                    VarInfo,
                                    API,
                                    MadeParm,
                                    ParmGoodBad,
                                    hLog,
                                    hConOut
                                    );
                    }
                }

                MadeParm = ParmNo + 1;

                if (GoodBad & CLOPT_GOOD) {
                    ParmGoodBad[ParmNo] = CLOPT_GOOD;
                    GTrav = &ParmList[ParmNo].next->Good;

                    if (ParmNo != (NumParms - 1)) {
                        GTrav = GTrav->next;
                    }

                    while ((GTrav != NULL) && (GTrav->next != NULL)) {
                        GTrav = GTrav->next;
                        VarInfo[ParmNo].next = GTrav->V;

                        NumVar += GenParm(
                                    ParmList,
                                    ParmNo + 1,
                                    NumParms,
                                    pfnSetup,
                                    pfnCleanup,
                                    pfnAPI,
                                    pfnValidate,
                                    pfnAPICln,
                                    GoodBad,
                                    Variation,
                                    CLOptions,
                                    VarInfo,
                                    API,
                                    MadeParm,
                                    ParmGoodBad,
                                    hLog,
                                    hConOut
                                    );
                    }
                }

                if (GoodBad & CLOPT_BAD ) {

                    BTrav = &ParmList[ParmNo].next->Bad;
                    ParmGoodBad[ParmNo] = CLOPT_BAD;

                    while ((BTrav != NULL) && (BTrav->next != NULL)) {

                        BTrav = BTrav->next;
                        VarInfo[ParmNo].next = BTrav->V;

                        NumVar += GenParm(
                                    ParmList,
                                    ParmNo + 1,
                                    NumParms,
                                    pfnSetup,
                                    pfnCleanup,
                                    pfnAPI,
                                    pfnValidate,
                                    pfnAPICln,
                                    GoodBad,
                                    Variation,
                                    CLOptions,
                                    VarInfo,
                                    API,
                                    MadeParm,
                                    ParmGoodBad,
                                    hLog,
                                    hConOut
                                    );
                    }
                }
            } else {
                ParmGoodBad[ParmNo] = CLOPT_GOOD;

                if (ParmList[ParmNo].next->Good.next != NULL) {

                    VarInfo[ParmNo].next = ParmList[ParmNo].next->Good.next->V;

                    NumVar += GenParm(
                                ParmList,
                                ParmNo + 1,
                                NumParms,
                                pfnSetup,
                                pfnCleanup,
                                pfnAPI,
                                pfnValidate,
                                pfnAPICln,
                                GoodBad,
                                Variation,
                                CLOptions,
                                VarInfo,
                                API,
                                MadeParm,
                                ParmGoodBad,
                                hLog,
                                hConOut
                                );
                }
            }
        }
    }

    return NumVar;
}


void
PrintAPICall(
    HANDLE       hLog,
    APIType      *API,
    S_PARMS      *ParmList,
    DefineType   *VarInfo,
    DWORD        *dwParms,
    DWORD        dwRetVal,
    int          Variation,
    int          NumParms,
    int          *ParmGoodBad,
    BOOL         GLPass,
    BOOL         VarPass,
    BOOL         VarExcept,
    DWORD        LastError
    )

/*++

Routine Description:

    Print a pretty version of the API call with its parameter names and
    expected return value. If ParmList is not null, then it will additionally
    print information pertaining to the value of each parameter, and the actual
    return value of the call.

Arguments:

Return Value:

--*/

{
    int i;
    char ApiParamsBuffer[1024];
    char TextBuffer[1024+256];

    UNREFERENCED_PARAMETER( dwParms );
    UNREFERENCED_PARAMETER( ParmList );
    UNREFERENCED_PARAMETER( Variation );

    ApiParamsBuffer[0] = '(';
    ApiParamsBuffer[1] = 0;

    for ( i=0; i<NumParms; i++) {

        if ( i != 0 ) {
            strcat( ApiParamsBuffer, ";" );
        }

        if ( ParmGoodBad[i] & CLOPT_BAD ) {
            sprintf( TextBuffer, "%s", VarInfo[i].next->Symbol );
        } else {
            sprintf( TextBuffer, "p%d", VarInfo[i].next->Case );
        }

        strcat( ApiParamsBuffer, TextBuffer );
    }

    strcat( ApiParamsBuffer, ")" );

    ASSERT( strlen( ApiParamsBuffer ) < sizeof( ApiParamsBuffer ) );

    if ( VarExcept ) {

        sprintf(
            TextBuffer,
            "Exception in %s%s",
            API->Name,
            ApiParamsBuffer
            );

        xLog( hLog, XLL_EXCEPTION, TextBuffer );

    } else {
        if ( !VarPass ) {

            sprintf(
                TextBuffer,
                "Bad return from %s%s,expected=0x%x,returned=0x%x",
                API->Name,
                ApiParamsBuffer,
                API->RValue.Value,
                dwRetVal
                );

            xLog( hLog, XLL_FAIL, TextBuffer );

        }
    }

    //KdPrint(( "BADMAN: %s\n", TextBuffer ));

    if ( !GLPass ) {
        sprintf(TextBuffer, "Incorrect last error 0x%x (%d)", LastError, LastError );
        //KdPrint(( "BADMAN: %s\n", TextBuffer ));
        xLog( hLog, XLL_FAIL, TextBuffer );
    }

    /* 
    
    **** Keep old code for a while, just for ref only ****
    
    sprintf(RetStr, ")");

    if (API->RValue.Type & RET_NOTEQUAL) {
        cBang = '!';
    } else {
        cBang = ' ';
    }

    if (API->RValue.Type & RET_VALUE) {
        sprintf(&RetStr[1], " %c= %d", cBang, API->RValue.Value);
    }

    if (API->RValue.Type & RET_PARM) {
        PTrav = API->Parms.next;

        for (i = API->RValue.Value; i > 0; i--) {
            PTrav = PTrav->next;
        }

        sprintf(&RetStr[1], " %c= %s", cBang, PTrav->Name);
    }

    RetLen = strlen(RetStr);

    sl[0] = el[0] = '\0';
    PTrav = &API->Parms;
    Found = FALSE;
    i = 0;

    ANLen = strlen(API->Name);

    if (ANLen > 19) {
        ANLen = 20;
    }

    NumCols = 79 - ANLen - RetLen;

    //
    // ParmList is NULL for calls for documentation which aren't the
    // result of an actual test call.
    //

    if (ParmList != NULL) {
        if (VarExcept) {
            DbgPrint("badman: +--------------EXCEPTION GENERATED IN API CALL---------------------------+\n");
        } else {
            if (!VarPass) {
                DbgPrint("badman: +-------------------Incorrect Return Value-------------------------------+\n");
                // why not log here ??
            } else {
                DbgPrint("badman: +---------------------------Success--------------------------------------+\n");
            }
        }

        strcpy(sl, "| ");
        strcpy(el, " |");
        NumCols -= 4;
    }

    DbgPrint("badman: %s%s(", sl, API->Name);
    sprintf(logbuff, "%s(", API->Name);
    lbPos = strlen(logbuff);

    if (ANLen == 20) {
        DbgPrint("\n                    ");
    }

    col = ANLen;

    while ((PTrav->next != NULL) && !Found) {
        PTrav = PTrav->next;
        PTrav2 = &API->Parms;
        while (PTrav2->next != PTrav) {
            PTrav2 = PTrav2->next;
            if (!strcmp(PTrav->Name, PTrav2->Name)) {
                Found = TRUE;
            }
        }

        if (!Found) {
            if (i) {
#define SEPARATOR   ", "
                DbgPrint(SEPARATOR);
                sprintf(&logbuff[lbPos], SEPARATOR);
                lbPos += sizeof SEPARATOR;
#undef  SEPARATOR
            }

            i++;
            col++;
            j = strlen(PTrav->Name);

            if ((col + j)>= NumCols) {
                if (ParmList != NULL) {
                    for (k = col + j; k < 76; k++) {
                        DbgPrint(" ");
                    }

                    DbgPrint("%s", el);
                }

                DbgPrint("\nbadman: %s", sl);
                col = ANLen + 1;

                for (k = 0; k < ANLen; k++) {
                    DbgPrint(" ");
                }
            }

            col += j;

            DbgPrint("%s", PTrav->Name);

            if (dwParms != NULL) {
                sprintf(
                    &logbuff[lbPos],
                    "%s 0x%lx",
                    PTrav->Type->Name,
                    dwParms[i - 1]
                    );

                lbPos = strlen(logbuff);
            }
        }
    }

    DbgPrint("%s", RetStr);

    sprintf(&logbuff[lbPos], ")= 0x%lx", dwRetVal);

    if (hLog != NULL) {
        xLog(hLog, XLL_WARN, "%s", logbuff);
        KdPrint(( "badman: %s\n", logbuff ));
    }

    col += RetLen;

    if (ParmList != NULL) {
        for (k = col; k < 70; k++) {
            DbgPrint(" ");
        }

        DbgPrint(" |");
        IsGoodCall = TRUE;

        for (i = 0; i < NumParms; i++) {
            if (ParmGoodBad[i] & CLOPT_BAD) {
                IsGoodCall = FALSE;
            }
        }

        DbgPrint(
            "\nbadman: |                  %4salid Parameters>                                  |",
            IsGoodCall ? "<V" : "<Inv"
            );

        DbgPrint(
            "\nbadman: |                 Variation #:  %-5d                                    |",
            Variation
            );

        if (!GLPass) {
            DbgPrint("\nbadman: |                 GetLastError()was incorrect                           |");

            if (hLog != NULL) {
                xLog(hLog, XLL_WARN, "GetLastError() was incorrect.");
                KdPrint(( "badman: GetLastError() was incorrect\n" ));
            }
        }

        if (IsGoodCall) {
            cBang = (char)((cBang == ' ') ? '!' : ' ');
        }

        DbgPrint(
            "\nbadman: |       Expected return value: %c0x%-10lX                             |",
            cBang,
            (API->RValue.Type & RET_VALUE) ?
            API->RValue.Value : dwParms[API->RValue.Value]
            );

        if (VarExcept) {
            DbgPrint("\nbadman: |         Actual return value:  <exception>                          |");
        } else {
            DbgPrint("\nbadman: |         Actual return value:  0x%-10lX                             |", dwRetVal);
        }

        //
        // ParamList is NULL if this is a documentation call... thus, don't
        // spew LastError.
        //

        if ((ParmList != NULL) && !VarPass) {
            DbgPrint("\nbadman: |\tLastError = %-10u                                           |", LastError);
        }

        if (hLog != NULL) {
            xLog(
                hLog,
                XLL_WARN,
                "Expected return value: %c0x%-10lx",
                cBang,
                API->RValue.Value
                );
            KdPrint(( "badman: Expected return value: %c0x%-10lx\n", cBang, API->RValue.Value ));

            if (!VarPass) {
                xLog(hLog, XLL_INFO, "LastError = %d", LastError);
                KdPrint(( "badman: LastError = %d\n", LastError ));
            }
        }

        DbgPrint("\nbadman: |         --------Parameters--------                                     |");

        for (i = 0; i < NumParms; i++) {
            if (ParmGoodBad[i] & CLOPT_GOOD) {
                sprintf(buff, "+%s+", ParmList[i].next->Name);
            } else {
                sprintf(buff, "-%s-", ParmList[i].next->Name);
            }

            sprintf(buff2, "(%s)", VarInfo[i].next->Symbol);

            DbgPrint(
                "\nbadman: |   %15s :  0x%-10lX %-36s |",
                buff,
                dwParms[i],
                buff2
                );
        }
    }*/
}


DWORD
CallAPI(
    int        iNumParms,
    FARDPROC   pfnAPI,
    DWORD      *dwParms
)

/*++

Routine Description:

    CallAPI is a rather disgusting way around quirky calling conventions where
    the caller cleans up the stack...

Arguments:

Return Value:

--*/

{
    DWORD  dwRet;

    switch (iNumParms) {

    case 0:
        dwRet = pfnAPI();
        break;
        
    case 1:
        dwRet = pfnAPI(dwParms[0]);
        break;
        
    case 2:    
        dwRet = pfnAPI(dwParms[0], dwParms[1]);
        break;
        
    case 3:
        dwRet = pfnAPI(dwParms[0], dwParms[1], dwParms[2]);
        break;
        
    case 4:
        dwRet = pfnAPI(dwParms[0], dwParms[1], dwParms[2], dwParms[3]);
        
        break;
        
    case 5:
        dwRet = pfnAPI(dwParms[0], dwParms[1], dwParms[2], dwParms[3], dwParms[4]);
        break;
        
    case 6:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5]
                    );
        break;
        
    case 7:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6]
                    );
        break;
        
    case 8:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7]
                    );
        break;
        
    case 9:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8]
                    );
        break;
        
    case 10:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9]
                    );
        break;
        
    case 11:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10]
                    );
        break;
        
    case 12:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11]
                    );
        break;
        
    case 13:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12]
                    );
        break;
        
    case 14:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13]
                    );
        break;
        
    case 15:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13],
                    dwParms[14]
                    );
        break;
        
    case 16:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13],
                    dwParms[14],
                    dwParms[15]
                    );
        break;
        
    case 17:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13],
                    dwParms[14],
                    dwParms[15],
                    dwParms[16]
                    );        
        break;
        
    case 18:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13],
                    dwParms[14],
                    dwParms[15],
                    dwParms[16],
                    dwParms[17]
                    );
        break;
        
    case 19:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13],
                    dwParms[14],
                    dwParms[15],
                    dwParms[16],
                    dwParms[17],
                    dwParms[18]
                    );
        break;
        
    case 20:
        dwRet = pfnAPI(
                    dwParms[0],
                    dwParms[1],
                    dwParms[2],
                    dwParms[3],
                    dwParms[4],
                    dwParms[5],
                    dwParms[6],
                    dwParms[7],
                    dwParms[8],
                    dwParms[9],
                    dwParms[10],
                    dwParms[11],
                    dwParms[12],
                    dwParms[13],
                    dwParms[14],
                    dwParms[15],
                    dwParms[16],
                    dwParms[17],
                    dwParms[18],
                    dwParms[19]
                    );
        break;

    default:
        dwRet = 0;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\filever.c ===
//---------------------------------------------------------------------------
//
//  MODULE: filever.c
//  AUTHOR: Steveko
//  DATE:  03-27-92
//
//  Copyright (c) 1992 Microsoft Corporation
//
//  This module contains the fileio and versioning functions to make and
//  destroy parameters for BadMan.
//
//---------------------------------------------------------------------------

#include <setcln.h>
#include <d_cases.bmh>
#include <h_cases.bmh>
#include <s_cases.bmh>
#include <w_cases.bmh>

#include <filever.h>
#include <winver.h>
#include <filutil.h>

#ifdef DEBUG
#define FIODebugPrint  SCPrintf
#else
#define FIODebugPrint
#endif

static HANDLE FIOMakeFile(int     CaseNo,
                          LPVOID *SCInfo,
                          HANDLE  hLog,
                          HANDLE  hConOut,
                          LPSTR   lpFileName,
                          DWORD   dwFileAttribs);

static HANDLE FIOMakeFileW(int     CaseNo,
                           LPVOID *SCInfo,
                           HANDLE  hLog,
                           HANDLE  hConOut,
                           LPWSTR  lpFileName,
                           DWORD   dwFileAttribs);

static BOOL FIOCloseDeleteFile(int     CaseNo,
                               LPVOID *SCInfo,
                               HANDLE  hLog,
                               HANDLE  hConOut,
                               HANDLE  hFile,
                               LPSTR   lpFileName,
                               BOOL    bSilent);

static BOOL FIOCloseDeleteFileW(int     CaseNo,
                                LPVOID *SCInfo,
                                HANDLE  hLog,
                                HANDLE  hConOut,
                                HANDLE  hFile,
                                LPWSTR  lpFileName,
                                BOOL    bSilent);

//---------------------------------------------------------------------------
//
//  Function for support HANDLESetup cases for fileio and versioning.
//
//  Returns INVALID_HANDLE_VALUE if any errors.
//
//---------------------------------------------------------------------------

HANDLE FIOHandleSetup(int     CaseNo,
                      LPVOID *SCInfo,
                      HANDLE  hLog,
                      HANDLE  hConOut)
{
  HANDLE          hRet;
  WIN32_FIND_DATA wfd;

  hRet = INVALID_HANDLE_VALUE;

  FIODebugPrint(hConOut, "\nFIOHandleSetup: case %d\n", CaseNo);

  switch (CaseNo) {

    case HANDLE_NORMAL_FILE:

      // make the file with normal attribs.

      hRet = FIOMakeFile(CaseNo,
                         SCInfo,
                         hLog,
                         hConOut,
                         FIO_DEFAULT_FILE_NAME,
                         FILE_ATTRIBUTE_NORMAL);

      if ( hRet == INVALID_HANDLE_VALUE )
        break;

      // open the file

      hRet = CreateFile(FIO_DEFAULT_FILE_NAME,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);

      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Could not open normal file");
        break;
      }

      break;

    case HANDLE_READONLY_FILE:

      // make the file with normal attribs.

      hRet = FIOMakeFile(CaseNo,
                         SCInfo,
                         hLog,
                         hConOut,
                         FIO_DEFAULT_FILE_NAME,
                         FILE_ATTRIBUTE_NORMAL);

      if ( hRet == INVALID_HANDLE_VALUE )
        break;

      // open the file

      hRet = CreateFile(FIO_DEFAULT_FILE_NAME,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);

      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Could not open normal file");
        break;
      }

      break;

    case HANDLE_CLOSED_FILE:

      // make the file with normal attribs.

      hRet = FIOMakeFile(CaseNo,
                         SCInfo,
                         hLog,
                         hConOut,
                         FIO_DEFAULT_FILE_NAME,
                         FILE_ATTRIBUTE_NORMAL);

      if ( hRet == INVALID_HANDLE_VALUE )
        break;

      // open the file

      hRet = CreateFile(FIO_DEFAULT_FILE_NAME,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);


      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Could not open file");
        break;
      }

      // close the file

      if ( ! CloseHandle(hRet) ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Error closing file");
        break;
      }

      break;

    case HANDLE_FINDFILE:

      // get handle

      hRet = FindFirstFile("t:\\*.*", &(wfd));

      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Error getting file search handle for *.*");
        break;
      }

      break;

    case HANDLE_CLOSED_FINDFILE:

      // get handle

      hRet = FindFirstFile("t:\\*.*", &(wfd));

      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Error getting file search handle for *.*");
        break;
      }

      // close handle

      if ( ! FindClose(hRet) ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Error closing file search handle");
        break;
      }

      break;

    case HANDLE_NORMAL_ASYNC_FILE:

      // make a normal file

      hRet = FIOMakeFile(CaseNo,
                         SCInfo,
                         hLog,
                         hConOut,
                         FIO_DEFAULT_FILE_NAME,
                         FILE_ATTRIBUTE_NORMAL);

      if ( hRet == INVALID_HANDLE_VALUE )
        break;

      // open the file overlapped

      hRet = CreateFile(FIO_DEFAULT_FILE_NAME,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OVERLAPPED,
                        (HANDLE) NULL);

      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Could not open normal async file");
        break;
      }

      break;

    case HANDLE_READONLY_ASYNC_FILE:

      // make a readonly file

      hRet = FIOMakeFile(CaseNo,
                         SCInfo,
                         hLog,
                         hConOut,
                         FIO_DEFAULT_FILE_NAME,
                         FILE_ATTRIBUTE_READONLY);

      if ( hRet == INVALID_HANDLE_VALUE )
        break;

      // open the file overlapped

      hRet = CreateFile(FIO_DEFAULT_FILE_NAME,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OVERLAPPED,
                        (HANDLE) NULL);

      if ( hRet == INVALID_HANDLE_VALUE ) {

        ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
             "Could not open readonly async file");
        break;
      }

      break;

    default:
      ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
                 "unknown case");
      break;
  }

  *SCInfo = (LPVOID) hRet;

  return(hRet);
}

//---------------------------------------------------------------------------
//
//  Function for support HANDLECleanup cases for fileio and versioning.
//
//  Returns INVALID_HANDLE_VALUE if any errors.
//
//---------------------------------------------------------------------------

VOID FIOHandleCleanup(int     CaseNo,
                      LPVOID *SCInfo,
                      HANDLE  hLog,
                      HANDLE  hConOut)
{
  BOOL bval;

  FIODebugPrint(hConOut, "\nFIOHandleCleanup: case %d\n", CaseNo);

  switch ( CaseNo ) {

    case HANDLE_NORMAL_FILE:
    case HANDLE_READONLY_FILE:
    case HANDLE_NORMAL_ASYNC_FILE:
    case HANDLE_READONLY_ASYNC_FILE:

      bval = FIOCloseDeleteFile(CaseNo,
                                SCInfo,
                                hLog,
                                hConOut,
                                (HANDLE) *SCInfo,
                                FIO_DEFAULT_FILE_NAME,
                                FALSE);
      break;

    case HANDLE_FINDFILE:

      if ( (HANDLE) *SCInfo != INVALID_HANDLE_VALUE )
        if ( ! FindClose((HANDLE) *SCInfo) )
          ErrorPrint(hConOut, hLog, "FIOHandleCleanup", CaseNo,
                     "Error closing file search handle");
      break;

    case HANDLE_CLOSED_FINDFILE:
      break;

    default:
      break;
  }
}

//---------------------------------------------------------------------------
//
//  Function for support DWORDSetup cases for fileio and versioning.
//
//---------------------------------------------------------------------------

DWORD FIODwordSetup(int     CaseNo,
                    LPVOID *SCInfo,
                    HANDLE  hLog,
                    HANDLE  hConOut)
{
  DWORD dwRet = 0;

  switch ( CaseNo ) {

    /* CreateFile generic flags. */

    case DWORD_GENERIC_READ_AND_WRITE:

      dwRet = DWORD_GENERIC_READ_AND_WRITE;
      break;

    case DWORD_GENERIC_INVALID_VALUE:

      dwRet = ~ ( GENERIC_READ | GENERIC_WRITE );
      break;

    /* CreateFile sharing modes. */

    case DWORD_FILE_SHARE_READ_AND_WRITE:

      dwRet = FILE_SHARE_READ | FILE_SHARE_WRITE;
      break;

    case DWORD_FILE_SHARE_READ_WRITE_DELETE:
      dwRet = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
      break;

    case DWORD_FILE_SHARE_INVALID_VALUE:

      dwRet = (DWORD)~ (FILE_SHARE_READ | FILE_SHARE_WRITE);
      break;

    /* CreateFile creation dispositions. */

    case DWORD_DISPOSITION_CREATE_FILE_ALWAYS:

      dwRet = CREATE_ALWAYS;
      break;

    case DWORD_DISPOSITION_INVALID_VALUE:

      dwRet = (DWORD)~ ( CREATE_NEW    |
                  CREATE_ALWAYS |
                  OPEN_EXISTING |
                  OPEN_ALWAYS   |
                  TRUNCATE_EXISTING );
      break;

    case DWORD_FILE_FLAGS_NORMAL:

      dwRet = FILE_ATTRIBUTE_NORMAL;
      break;

    case DWORD_FILE_FLAGS_INVALID_VALUE:

      dwRet = ~ ( FILE_ATTRIBUTE_NORMAL   |
                  FILE_ATTRIBUTE_ARCHIVE  |
                  FILE_ATTRIBUTE_READONLY |
                  FILE_ATTRIBUTE_HIDDEN   |
                  FILE_ATTRIBUTE_SYSTEM   |
                  FILE_FLAG_WRITE_THROUGH |
                  FILE_FLAG_OVERLAPPED    |
                  FILE_FLAG_NO_BUFFERING  |
                  FILE_FLAG_RANDOM_ACCESS |
                  FILE_FLAG_SEQUENTIAL_SCAN );
      break;

    case DWORD_READWRITE_VALID_BUFFER_SIZE:

      dwRet = FIO_READWRITE_BUFFER_SIZE;
      break;

    case DWORD_READWRITE_INVALID_BUFFER_SIZE:

      dwRet = 0xffffffff;
      break;

    case DWORD_VOLUME_NAME_BUFFER_LENGTH:

      dwRet = FIO_VOLUME_NAME_BUFFER_LENGTH;
      break;

    case DWORD_FILE_SYSTEM_NAME_BUFFER_LENGTH:

      dwRet = FIO_FILE_SYSTEM_NAME_BUFFER_LENGTH;
      break;

    case DWORD_NORMAL_FILE_ATTRIBUTES:

      dwRet = FILE_ATTRIBUTE_NORMAL;
      break;

    case DWORD_INVALID_FILE_ATTRIBUTES:

      dwRet = (DWORD)~ ( FILE_ATTRIBUTE_NORMAL   |
                  FILE_ATTRIBUTE_ARCHIVE  |
                  FILE_ATTRIBUTE_READONLY |
                  FILE_ATTRIBUTE_HIDDEN   |
                  FILE_ATTRIBUTE_SYSTEM );
      break;

    case DWORD_VER_INVALID_FIND_FLAGS:

      dwRet = (DWORD)~ ( VFFF_ISSHAREDFILE );
      break;

    case DWORD_VER_INVALID_INST_FLAGS:

      dwRet = (DWORD)~ ( VIFF_FORCEINSTALL |
                  VIFF_DONTDELETEOLD );
      break;

    case DWORD_VER_VALID_INFO_LENGTH:

#ifdef IT_EVER_MAKES_IT_TO_A_BUILD

      // get the ver info size from the file

      dwRet = GetVersionInfoSize(VER_DEFAULT_FILE_WITH_VER_INFO,
                                  &dwBogusHandle);
      if ( dwRet == 0 ) {
        ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                   "error getting size of version info\n");
        break;
      }
#endif
      dwRet = 0;
      break;

    case DWORD_VER_LANG_US_ENGLISH:

      dwRet = 0x409;
      break;

    case DWORD_VER_LANG_UNDEFINED:

      dwRet = 0xffffffff;
      break;

    case DWORD_VER_LANGUAGE_BUFFER_SIZE:

      dwRet = VER_SIZE_LANGUAGE_BUFFER;
      break;

    default:
      ErrorPrint(hConOut, hLog, "FIODwordSetup", CaseNo, "unknown case");
      break;
  }

  return(dwRet);

  *SCInfo;   // shut-up compiler
}

//---------------------------------------------------------------------------
//
//  Function for fileio LPSTRSetup cases for fileio and versioning
//
//---------------------------------------------------------------------------

LPSTR FIOLpstrSetup(int     CaseNo,
                    LPVOID *SCInfo,
                    HANDLE  hLog,
                    HANDLE  hConOut)
{
    LPSTR lpString = NULL;
    BOOL  bRet;
    DWORD dwRet;
    
    switch ( CaseNo ) {
        
    case LPSTR_FILENAME_VALID:  // used only by create and open
        
        lpString = FIO_DEFAULT_FILE_TO_CREATE;
        
        FIOCloseDeleteFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE);
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID1:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_UNPRINT_CHARS_ROOT, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName1");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID2:
        
        dwRet=fGetNextBadFileName(&lpString,
            FIO_BADFNAME_UNPRINT_CHARS_SUBDIR, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName2");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID3:
        
        dwRet=fGetNextBadFileName(&lpString,
            FIO_BADFNAME_UNPRINT_CHARS_DIRNAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName3");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID4:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_PRINT_CHARS_ROOT, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName4");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID5:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_PRINT_CHARS_SUBDIR, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName5");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID6:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_PRINT_CHARS_DIRNAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName6");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID7:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_INVALID_DRIVE_NAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName7");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID8:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_ILL_FORMED, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName8");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILENAME_INVALID9:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADFNAME_NAME_TOO_LONG, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad fileName9");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_DIRNAME_INVALID1:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADDIRNAME_UNPRINT_CHARS, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad DirName1");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_DIRNAME_INVALID2:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADDIRNAME_PRINT_CHARS, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad DirName2");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_DIRNAME_INVALID3:
        
        dwRet=fGetNextBadFileName(&lpString,
            FIO_BADDIRNAME_INVALID_DRIVE_NAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad DirName3");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_DIRNAME_INVALID4:
        
        dwRet=fGetNextBadFileName(&lpString, FIO_BADDIRNAME_ILL_FORMED, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad DirName4");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_SRC_FILE_EXISTS:
        
        lpString = FIO_DEFAULT_SRC_FILE_NAME;
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL);
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_SRC_FILE_NOT_EXISTS:
        
        lpString = FIO_DEFAULT_SRC_FILE_NAME;
        
        FIOCloseDeleteFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE);
        *SCInfo = lpString;
        break;
        
    case LPSTR_DEST_FILE_EXISTS:
        
        lpString = FIO_DEFAULT_DEST_FILE_NAME;
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL);
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_DEST_FILE_NOT_EXISTS:
        
        lpString = FIO_DEFAULT_DEST_FILE_NAME;
        
        FIOCloseDeleteFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE);
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILE_EXISTS:
        
        lpString = FIO_DEFAULT_FILE_NAME;
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL);
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILE_NOT_EXISTS:
        
        lpString = FIO_DEFAULT_FILE_NAME;
        
        FIOCloseDeleteFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE);
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILE_READONLY:
        
        lpString = FIO_DEFAULT_FILE_NAME;
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_READONLY);
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_DIRNAME_VALID:
        
        lpString = "t:\\";
        break;
        
    case LPSTR_PATH_EXISTS:
        
        lpString = "z:\\xyzabc.tst";
        
        bRet = CreateDirectory(lpString, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS )
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
            "Error creating directory\n");
        
        break;
        
    case LPSTR_PATH_NOT_EXISTS:
        
        lpString = "xyz123.abc";  // not likely
        break;
        
    case LPSTR_PREFIX_VALID:
        
        lpString = "ppp";
        break;
        
    case LPSTR_PREFIX_TOO_LONG:
        
        lpString = "ppppppppppppppp";
        break;
        
    case LPSTR_VALID_PATH_BUFFER:
        
        if ( (lpString = (LPSTR) LocalAlloc(LPTR, MAX_PATH)) == NULL )
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
            "Error allocating memory");
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_VALID_ROOT_PATHNAME:
        
        lpString = "t:\\";
        break;
        
    case LPSTR_INVALID_ROOT_PATHNAME:
        
        lpString = "c:\\tmp";
        break;
        
    case LPSTR_VOLUME_NAME_BUFFER:
        
        if((lpString = (LPSTR) LocalAlloc(LPTR, FIO_VOLUME_NAME_BUFFER_LENGTH))
            == NULL){
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error allocating memory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_FILE_SYSTEM_NAME_BUFFER:
        
        if((lpString = (LPSTR) LocalAlloc(LPTR,
            FIO_FILE_SYSTEM_NAME_BUFFER_LENGTH)) == NULL){
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error allocating memory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_VER_SRC_FILE_EXISTS:
        
        bRet = CreateDirectory(VER_DEFAULT_SRC_DIR, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        lpString = *SCInfo = VER_DEFAULT_SRC_FILE;
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL);
        break;
        
    case LPSTR_VER_SRC_FILE_NOT_EXISTS:
        
        bRet = CreateDirectory(VER_DEFAULT_SRC_DIR, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = NULL;
            *SCInfo  = NULL;
            break;
        }
        
        lpString = *SCInfo = VER_DEFAULT_SRC_FILE;
        
        FIOCloseDeleteFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE);
        break;
        
    case LPSTR_VER_SRC_DIR_EXISTS:
        
        lpString = *SCInfo = VER_DEFAULT_SRC_DIR;
        
        bRet = CreateDirectory(lpString, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        break;
        
    case LPSTR_VER_SRC_DIR_NOT_EXISTS:
        
        lpString = *SCInfo = VER_DEFAULT_DIR_NOT_EXISTS;
        break;
        
    case LPSTR_VER_DEST_FILE_EXISTS:
        
        bRet = CreateDirectory(VER_DEFAULT_DEST_DIR, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        lpString = *SCInfo = VER_DEFAULT_DEST_FILE;
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL);
        
        *SCInfo = lpString;
        break;
        
    case LPSTR_VER_DEST_FILE_NOT_EXISTS:
        
        bRet = CreateDirectory(VER_DEFAULT_DEST_DIR, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        lpString = *SCInfo = VER_DEFAULT_DEST_FILE;
        
        FIOCloseDeleteFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE);
        break;
        
    case LPSTR_VER_DEST_DIR_EXISTS:
        
        lpString = *SCInfo = VER_DEFAULT_DEST_DIR;
        
        bRet = CreateDirectory(lpString, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        break;
        
    case LPSTR_VER_DEST_DIR_NOT_EXISTS:
        
        lpString = *SCInfo = VER_DEFAULT_DIR_NOT_EXISTS;
        break;
        
    case LPSTR_NULL_STRING:
        
        lpString = *SCInfo = "";
        break;
        
        /*case LPSTR_WINDOWS_DIR:
        
          if ( (lpString = (LPSTR) LocalAlloc(LPTR, MAX_PATH)) == NULL ) {
          ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
          "Error allocating memory");
          *SCInfo = NULL;
          break;
          }
          
            if ( GetWindowsDirectory(lpString, MAX_PATH) == 0 ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
            "Error getting windows directory");
            *SCInfo = NULL;
            break;
            }
            
              *SCInfo = lpString;
        break;*/
        
    case LPSTR_VER_APP_DIR:
        
        lpString = *SCInfo = VER_DEFAULT_APP_DIR;
        
        bRet = CreateDirectory(lpString, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "Error creating directory");
            lpString = NULL;
            break;
        }
        
        break;
        
    case LPSTR_VER_VALID_LANGUAGE_BUFFER:
        
        if ( (lpString = *SCInfo = malloc(VER_SIZE_LANGUAGE_BUFFER)) == NULL )
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
            "Error allocating memory\n");
        break;
        
    case LPSTR_VER_SUB_BLOCK_EXISTS:
        
        lpString = *SCInfo = "\\StringFileInfo";
        break;
        
    case LPSTR_VER_SUB_BLOCK_NOT_EXISTS:
        
        lpString = *SCInfo = "\\notexists";
        break;
        
    case LPSTR_SEARCH_PATH_ILL_FORMED:
        
        lpString = *SCInfo = "::+t:\\nt\\windows--";
        break;
        
    case LPSTR_SEARCH_PATH_BAD_CHARS:
        
        lpString = *SCInfo = "t:\\xyz\x0f\xfe";
        break;
        
    case LPSTR_FILE_IN_CURR_DIR_NO_EXT:
        
        lpString = "good";
        *SCInfo  = "good.txt";
        
        FIOMakeFile(CaseNo,
            SCInfo,
            hLog,
            hConOut,
            (LPSTR) *SCInfo,
            FILE_ATTRIBUTE_NORMAL);
        break;
        
    case LPSTR_EXT_FILE_IN_CURR_DIR:
        
        lpString = *SCInfo = ".txt";
        break;
        
    case LPSTR_EXT_ILL_FORMED:
        
        lpString = *SCInfo = "txt";
        break;
        
    case LPSTR_EXT_BAD_CHARS:
        
        lpString = *SCInfo = ".\xfe\x0f";
        break;
        
    case LPSTR_FILE_NOT_EXISTS_ON_PATH:
        
        lpString = *SCInfo = "t:\\noton.pth";  // hope root not on path or curr
        // dir
        break;
        
    default:
        ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "unknown case");
        break;
  }
  
  return(lpString);
}


LPWSTR
FIOLpstrSetupW(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    LPWSTR lpString = NULL;
    BOOL  bRet;
    DWORD dwRet;
    
    switch ( CaseNo ) {
        
    case LPWSTR_FILENAME_VALID:  // used only by create and open
        lpString = (LPWSTR)FIO_DEFAULT_FILE_TO_CREATE_W;

        FIOCloseDeleteFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE
            );

        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID1:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_UNPRINT_CHARS_ROOT, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName1");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID2:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_UNPRINT_CHARS_SUBDIR, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName2");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID3:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_UNPRINT_CHARS_DIRNAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName3");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID4:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_PRINT_CHARS_ROOT, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName4");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID5:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_PRINT_CHARS_SUBDIR, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName5");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID6:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_PRINT_CHARS_DIRNAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName6");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID7:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_INVALID_DRIVE_NAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName7");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID8:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_ILL_FORMED, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName8");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILENAME_INVALID9:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADFNAME_NAME_TOO_LONG, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad fileName9");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_DIRNAME_INVALID1:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADDIRNAME_UNPRINT_CHARS, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad DirName1");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_DIRNAME_INVALID2:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADDIRNAME_PRINT_CHARS, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad DirName2");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_DIRNAME_INVALID3:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADDIRNAME_INVALID_DRIVE_NAME, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo, "Error getting bad DirName3");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_DIRNAME_INVALID4:
        dwRet = fGetNextBadFileNameW(&lpString, FIO_BADDIRNAME_ILL_FORMED, 0);
        
        if ( dwRet != FIO_NO_ERR ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error getting bad DirName4");
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_SRC_FILE_EXISTS:
        lpString = (LPWSTR)FIO_DEFAULT_SRC_FILE_NAME_W;
        
        FIOMakeFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL
            );
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_SRC_FILE_NOT_EXISTS:
        lpString = (LPWSTR)FIO_DEFAULT_SRC_FILE_NAME_W;
        
        FIOCloseDeleteFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE
            );

        *SCInfo = lpString;
        break;
        
    case LPWSTR_DEST_FILE_EXISTS:
        lpString = (LPWSTR)FIO_DEFAULT_DEST_FILE_NAME_W;
        
        FIOMakeFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL
            );
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_DEST_FILE_NOT_EXISTS:
        lpString = (LPWSTR)FIO_DEFAULT_DEST_FILE_NAME_W;
        
        FIOCloseDeleteFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE
            );

        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILE_EXISTS:
        lpString = (LPWSTR)FIO_DEFAULT_FILE_NAME_W;
        
        FIOMakeFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_NORMAL
            );
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILE_NOT_EXISTS:
        lpString = (LPWSTR)FIO_DEFAULT_FILE_NAME_W;
        
        FIOCloseDeleteFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            INVALID_HANDLE_VALUE,
            lpString,
            TRUE
            );

        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILE_READONLY:
        lpString = (LPWSTR)FIO_DEFAULT_FILE_NAME_W;
        
        FIOMakeFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            lpString,
            FILE_ATTRIBUTE_READONLY
            );
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_DIRNAME_VALID:
        lpString = (LPWSTR)L"t:\\";
        break;
        
    case LPWSTR_PATH_EXISTS:
        lpString = (LPWSTR)L"z:\\xyzabc.tst";
        bRet = CreateDirectoryW(lpString, NULL);
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS )
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error creating directory\n");
        break;
        
    case LPWSTR_PATH_NOT_EXISTS:
        lpString = (LPWSTR)L"xyz123.abc";  // not likely
        break;
        
    case LPWSTR_PREFIX_VALID:
        lpString = (LPWSTR)L"ppp";
        break;
        
    case LPWSTR_PREFIX_TOO_LONG:
        lpString = (LPWSTR)L"ppppppppppppppp";
        break;
        
    case LPWSTR_VALID_PATH_BUFFER:
        if ( (lpString = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*MAX_PATH)) == NULL ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error allocating memory");
        }
        *SCInfo = lpString;
        break;
        
    case LPWSTR_VALID_ROOT_PATHNAME:
        lpString = (LPWSTR)L"t\\";
        break;
        
    case LPWSTR_INVALID_ROOT_PATHNAME:
        lpString = (LPWSTR)L"c:\\tmp";
        break;
        
    case LPWSTR_VOLUME_NAME_BUFFER:
        if ((lpString = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*FIO_VOLUME_NAME_BUFFER_LENGTH)) == NULL) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error allocating memory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_FILE_SYSTEM_NAME_BUFFER:
        if((lpString = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*FIO_FILE_SYSTEM_NAME_BUFFER_LENGTH)) == NULL) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "Error allocating memory");
            lpString = *SCInfo = NULL;
            break;
        }
        
        *SCInfo = lpString;
        break;
        
    case LPWSTR_SEARCH_PATH_ILL_FORMED:
        lpString = *SCInfo = L"::+t:\\nt\\windows--";
        break;
        
    case LPWSTR_SEARCH_PATH_BAD_CHARS:
        lpString = *SCInfo = L"z:\\xyz\x0f\xfe";
        break;
        
    case LPWSTR_FILE_IN_CURR_DIR_NO_EXT:
        lpString = (LPWSTR)L"good";
        *SCInfo  = L"good.txt";
        
        FIOMakeFileW(
            CaseNo,
            SCInfo,
            hLog,
            hConOut,
            (LPWSTR)*SCInfo,
            FILE_ATTRIBUTE_NORMAL
            );
        break;
        
    case LPWSTR_EXT_FILE_IN_CURR_DIR:
        lpString = *SCInfo = L".txt";
        break;
        
    case LPWSTR_EXT_ILL_FORMED:
        lpString = *SCInfo = L"txt";
        break;
        
    case LPWSTR_EXT_BAD_CHARS:
        lpString = *SCInfo = L".\xfe\x0f";
        break;
        
    case LPWSTR_FILE_NOT_EXISTS_ON_PATH:
        lpString = *SCInfo = L"t:\\noton.pth";  // hope root not on path or curr dir
        break;
        
    default:
        ErrorPrint(hConOut, hLog, "FIOLpstrSetupW", CaseNo, "unknown case");
        break;
  }
  
  return lpString;
}


//---------------------------------------------------------------------------
//
//  Cleanup function for Fileio LPSTR's
//
//---------------------------------------------------------------------------

VOID FIOLpstrCleanup(int     CaseNo,
                     LPVOID *SCInfo,
                     HANDLE  hLog,
                     HANDLE  hConOut)
{
  switch ( CaseNo ) {

    case LPSTR_FILENAME_VALID:
    case LPSTR_SRC_FILE_EXISTS:
    case LPSTR_SRC_FILE_NOT_EXISTS:
    case LPSTR_DEST_FILE_EXISTS:
    case LPSTR_DEST_FILE_NOT_EXISTS:
    case LPSTR_FILE_EXISTS:
    case LPSTR_FILE_READONLY:
    case LPSTR_FILE_IN_CURR_DIR_NO_EXT:

      FIOCloseDeleteFile(CaseNo,
                         SCInfo,
                         hLog,
                         hConOut,
                         INVALID_HANDLE_VALUE,
                         (LPSTR) *SCInfo,
                         FALSE);
      break;

    case LPSTR_VALID_PATH_BUFFER:
    case LPSTR_VOLUME_NAME_BUFFER:
    case LPSTR_FILE_SYSTEM_NAME_BUFFER:
    case LPSTR_VER_VALID_LANGUAGE_BUFFER:
    case LPSTR_FILENAME_INVALID1:
    case LPSTR_FILENAME_INVALID2:
    case LPSTR_FILENAME_INVALID3:
    case LPSTR_FILENAME_INVALID4:
    case LPSTR_FILENAME_INVALID5:
    case LPSTR_FILENAME_INVALID6:
    case LPSTR_FILENAME_INVALID7:
    case LPSTR_FILENAME_INVALID8:
    case LPSTR_FILENAME_INVALID9:
    case LPSTR_DIRNAME_INVALID1:
    case LPSTR_DIRNAME_INVALID2:
    case LPSTR_DIRNAME_INVALID3:
    case LPSTR_DIRNAME_INVALID4:

      if ( *SCInfo != NULL )
        LocalFree((HANDLE) *SCInfo);
      break;

    default:
      break;
  }
}

//---------------------------------------------------------------------------
//
//  Function to make the given file with the given attributes.
//
//  INVALID_HANDLE_VALUE will be returned if errors, and a message
//  will be printed.
//
//---------------------------------------------------------------------------

static HANDLE FIOMakeFile(int     CaseNo,
                          LPVOID *SCInfo,
                          HANDLE  hLog,
                          HANDLE  hConOut,
                          LPSTR   lpFileName,
                          DWORD   dwFileAttribs)
{
    HANDLE hRet;
    
    FIODebugPrint(hConOut, "\nMaking file %s, attribs = %x\n",
        lpFileName, dwFileAttribs);
    
    // create the file
    
    hRet = CreateFile(
        lpFileName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        (LPSECURITY_ATTRIBUTES) NULL,
        CREATE_ALWAYS,
        dwFileAttribs,
        (HANDLE) NULL
        );
    
    if ( hRet == INVALID_HANDLE_VALUE ) {
        
        KdPrint(( "SETCLN: couldn't create file %s\n", lpFileName ));
            
            ErrorPrint(hConOut, hLog, "FIOMakeFile", CaseNo,
            "Could not create file");
        
        FIODebugPrint(hConOut, "\nFIOMakeFile: Error = %d\n",
            GetLastError());
        
        return(INVALID_HANDLE_VALUE);
    }
    
    // close handle
    
    if ( ! CloseHandle(hRet) ) {
        
        ErrorPrint(hConOut, hLog, "FIOMakeFile", CaseNo,
            "Error closing created file");
        
        return(INVALID_HANDLE_VALUE);
    }
    
    return(hRet);
    
    SCInfo;   // shut-up compiler
}

static HANDLE FIOMakeFileW(int     CaseNo,
                           LPVOID *SCInfo,
                           HANDLE  hLog,
                           HANDLE  hConOut,
                           LPWSTR  lpFileName,
                           DWORD   dwFileAttribs
                           )
{
    HANDLE hRet;
    
    FIODebugPrint(hConOut, "\nMaking file %ws, attribs = %x\n", lpFileName, dwFileAttribs);
    
    // create the file
    
    hRet = CreateFileW(
                lpFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                (LPSECURITY_ATTRIBUTES) NULL,
                CREATE_ALWAYS,
                dwFileAttribs,
                (HANDLE) NULL
                );
    
    if ( hRet == INVALID_HANDLE_VALUE ) {
        KdPrint(( "SETCLN: couldn't create file %ws\n", lpFileName ));
        ErrorPrint(hConOut, hLog, "FIOMakeFileW", CaseNo, "Could not create file");
        FIODebugPrint(hConOut, "\nFIOMakeFile: Error = %d\n", GetLastError());
        return INVALID_HANDLE_VALUE;
    }
    
    // close handle
    
    if ( !CloseHandle(hRet) ) {
        
        ErrorPrint(hConOut, hLog, "FIOMakeFile", CaseNo, "Error closing created file");
        return INVALID_HANDLE_VALUE;
    }
    
    return hRet;
    
    SCInfo;   // shut-up compiler
}

//---------------------------------------------------------------------------
//
//  Function to close and delete the given file.  Pass -1 for hFile
//  if you don't know it, or its already closed.  Pass TRUE for bSilent
//  if calling as part of a setup (trying to ensure that the given file
//  doesn't already exist), and it won't gripe that the file does not exist.
//
//  Returns false if fails, true otherwise.
//
//---------------------------------------------------------------------------

static BOOL FIOCloseDeleteFile(int     CaseNo,
                               LPVOID *SCInfo,
                               HANDLE  hLog,
                               HANDLE  hConOut,
                               HANDLE  hFile,
                               LPSTR   lpFileName,
                               BOOL    bSilent)
{
  HANDLE hTemp;

  FIODebugPrint(hConOut, "\nClosing/deleting file %s\n", lpFileName);

  // close handle if specified

  if ( hFile != INVALID_HANDLE_VALUE ) {

    if ( ! CloseHandle(hFile) ) {

      if ( ! bSilent )
        ErrorPrint(hConOut, hLog, "FIOCloseDeleteFile", CaseNo,
                   "Error closing file");
        return(0);
      }
  }

  // if file does not exist, never mind

  if ( (hTemp = CreateFile(lpFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           (HANDLE) NULL)) == INVALID_HANDLE_VALUE ) {
      return(0);
  }

  CloseHandle(hTemp);

  // change to normal file, so can be deleted

  if ( ! SetFileAttributes(lpFileName, FILE_ATTRIBUTE_NORMAL) ) {

      if ( ! bSilent )
          ErrorPrint(hConOut, hLog, "FIOCloseDeleteFile", CaseNo,
                     "Error setting attributes of file trying to delete");
      return(0);
  }

  // delete file

  if ( ! DeleteFile(lpFileName) ) {

      if ( ! bSilent )
          ErrorPrint(hConOut, hLog, "FIOCloseDeleteFile", CaseNo,
                     "Error trying to delete file");
      return(0);
  }

  return(1);

  SCInfo;   // shut-up compiler
}


static
BOOL
FIOCloseDeleteFileW(
    int     CaseNo,
    LPVOID *SCInfo,
    HANDLE  hLog,
    HANDLE  hConOut,
    HANDLE  hFile,
    LPWSTR  lpFileName,
    BOOL    bSilent
    )
{
    HANDLE hTemp;
    
    FIODebugPrint(hConOut, "\nClosing/deleting file %ws\n", lpFileName);
    
    // Close handle if specified
    
    if ( hFile != INVALID_HANDLE_VALUE ) {
        
        if ( ! CloseHandle(hFile) ) {
            
            if ( ! bSilent )
                ErrorPrint(hConOut, hLog, "FIOCloseDeleteFileW", CaseNo, "Error closing file");
            return(0);
        }
    }
    
    // if file does not exist, never mind
    
    if ( (hTemp = CreateFileW(lpFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    (LPSECURITY_ATTRIBUTES) NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    (HANDLE) NULL)) == INVALID_HANDLE_VALUE ) {
        return(0);
    }
    
    CloseHandle(hTemp);
    
    // change to normal file, so can be deleted
    
    if ( !SetFileAttributesW(lpFileName, FILE_ATTRIBUTE_NORMAL) ) {
        
        if ( ! bSilent ) {
            ErrorPrint(
                hConOut, 
                hLog, 
                "FIOCloseDeleteFile", 
                CaseNo, 
                "Error setting attributes of file trying to delete"
                );
        }

        return(0);
    }
    
    // delete file
    
    if ( !DeleteFileW( lpFileName ) ) {
        
        if ( !bSilent ) {
            ErrorPrint(
                hConOut, 
                hLog, 
                "FIOCloseDeleteFile", 
                CaseNo,
                "Error trying to delete file"
                );
        }

        return(0);
    }
    
    return(1);
    
    SCInfo;   // shut-up compiler
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\a_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    a_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'A'. It also contains setup and cleanup
    funtions beginning with 'LPA'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <a_cases.bmh>


PVOID LPABCSetup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPABC Ret;
    
    switch (CaseNo) {

    case LPABC_VALID:
        Ret = (LPABC)LocalAlloc(LPTR, 65 * sizeof(ABC));
        if (Ret == NULL) {
            ErrorPrint(hConOut, hLog, "LPABCSetup", CaseNo, "LocalAlloc failed!");
        }
        *SCInfo = (LPVOID)Ret;
        break ;

    case LPABC_NULL:
        Ret = NULL;
        break;

    default:
        ErrorPrint(hConOut, hLog, "LPABCSetup", CaseNo, "Unknown Case");
        Ret = NULL;
    }
    
    return Ret;
#endif
    return 0;
}


void LPABCCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    switch(CaseNo) {
    case LPABC_VALID:
        if ((*SCInfo)!=NULL) {
            if (LocalFree((HANDLE)(*SCInfo))!=NULL)
                ErrorPrint(hConOut,hLog,"LPABCCleanup",CaseNo,"LocalFree failed!");
        }
    case LPABC_NULL:
    default:
        break;
    }
}


PVOID LPABCFLOATSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
#if 0
    LPABCFLOAT Ret;
    
    switch(CaseNo) {
    case LPABCFLOAT_VALID:
        Ret = (LPABCFLOAT) LocalAlloc (LPTR, sizeof(ABCFLOAT)*65);
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPABCSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break ;
    case LPABCFLOAT_NULL:
        Ret = NULL;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPABCFLOATSetup",CaseNo,"Unknown Case");
        Ret = (LPABCFLOAT ) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}



void LPABCFLOATCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    switch(CaseNo) {
    case LPABCFLOAT_VALID:
        if ((*SCInfo)!=NULL) {
            if (LocalFree((HANDLE)(*SCInfo))!=NULL)
                ErrorPrint(hConOut,hLog,"LPABCFLOATBCleanup",CaseNo,"LocalFree failed!");
        }
    case LPABCFLOAT_NULL:
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\c_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    c_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'C'. It also contains setup and cleanup
    funtions beginning with 'LPC'. For more information, please refer
    to badman.doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    17-Apr-2000     schanbai

        Ported to XBox and made the code more readable

--*/


#include <stdlib.h>
#include <setcln.h>
#include <c_cases.bmh>


//
// CHAR type
//

CHAR
CHARSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    CHAR Ret;

    UNREFERENCED_PARAMETER( SCInfo );

    switch ( CaseNo ) {
    case CHAR_A:
        Ret = 'A';
        break;

    default:
        ErrorPrint( hConOut, hLog, "CHARSetup", CaseNo, "Unknown Case" );
        Ret = 0;
    }

    return Ret;
}


void
CHARCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


//
// char type
//

char
charSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    char Ret;

    switch ( CaseNo ) {
        
    default:
        ErrorPrint( hConOut, hLog, "charSetup", CaseNo, "Unknown Case" );
        Ret = (char)0;
    }

    return Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );
}


void
charCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


//
// COLORREF type
//

COLORREF
COLORREFSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    COLORREF Ret;

    switch (CaseNo) {

    case COLORREF_BLUE:
        Ret=0x00ff0000;
        break;

    case COLORREF_RED:
        Ret=0x000000ff;
        break;

    case COLORREF_GREEN:
        Ret=0x0000ff00;
        break;

    case COLORREF_BAD_TOP:
        Ret=0xff000000;
        break;

    case COLORREF_BLACK:
        Ret=0x00ffffff;
        break;

    case COLORREF_WHITE:
        Ret=0x00000000;
        break;

    default:
        ErrorPrint( hConOut, hLog, "COLORREFSetup", CaseNo, "Unknown Case" );
        Ret = (COLORREF)0;
    }

    return Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );
}


void
COLORREFCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


PVOID
COORDSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
#if 0
    COORD Ret = { 0 };
    
    switch (CaseNo) {

    default:
        ErrorPrint( hConOut, hLog, "COORDSetup", CaseNo, "Unknown Case" );
    }

    return Ret;

    UNREFERENCED_PARAMETER( SCInfo );
#endif
    return 0;
}


void
COORDCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


PVOID
LPCOMMTIMEOUTSSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
#if 0
    LPCOMMTIMEOUTS Ret;

    switch (CaseNo) {

    default:
        ErrorPrint( hConOut, hLog, "LPCOMMTIMEOUTSSetup", CaseNo, "Unknown Case" );
        Ret = (LPCOMMTIMEOUTS)NULL;
    }

    return Ret;

    UNREFERENCED_PARAMETER( SCInfo );
#endif
    return 0;
}


void
LPCOMMTIMEOUTSCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


PVOID
LPCOMSTATSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
#if 0
    LPCOMSTAT Ret;

    switch (CaseNo) {
        
    default:
        ErrorPrint( hConOut, hLog, "LPCOMSTATSetup", CaseNo, "Unknown Case" );
        Ret = (LPCOMSTAT)NULL;
    }

    return Ret;

    UNREFERENCED_PARAMETER( SCInfo );
#endif
    return 0;
}


void
LPCOMSTATCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


LPCONTEXT
LPCONTEXTSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    LPCONTEXT Ret;
    
    switch (CaseNo) {
    case LPCONTEXT_VALID_STRUCTURE:
        Ret = (LPCONTEXT)LocalAlloc( LPTR, sizeof(CONTEXT) );

        if ( Ret == NULL ) {
            ErrorPrint( hConOut, hLog, "LPCONTEXTSetup", CaseNo, "Valid Structure => LocalAlloc failed!" );
        }
        else {
            Ret->ContextFlags = CONTEXT_FULL;
        }
        *SCInfo = (LPVOID)Ret;
        break;

    case LPCONTEXT_RANDOM_POINTER:
        Ret = (LPCONTEXT)rand();
        break;

    case LPCONTEXT_NULL_POINTER:
        Ret = (LPCONTEXT)NULL;
        break;

    case LPCONTEXT_BLOCK_TOO_SMALL:
        // BUGBUG: this will definitely corrupt the heap
        Ret = (LPCONTEXT)LocalAlloc( LPTR, sizeof(CONTEXT)/2 );
        if ( Ret == NULL ) {
            ErrorPrint( hConOut, hLog, "LPCONTEXTSetup", CaseNo, "Block Too Small => LocalAlloc failed!" );
        }
        *SCInfo = (LPVOID)Ret;
        break;

    case LPCONTEXT_INVALID_FLAGS:
        Ret = (LPCONTEXT)LocalAlloc( LPTR, sizeof(CONTEXT) );
        if ( Ret == NULL ) {
            ErrorPrint( hConOut, hLog, "LPCONTEXTSetup", CaseNo, "Valid Structure => LocalAlloc failed!" );
        }
        else {
            Ret->ContextFlags = 0;
        }
        *SCInfo = (LPVOID)Ret;
        break;

    default:
        ErrorPrint( hConOut, hLog, "LPCONTEXTSetup", CaseNo, "Unknown Case" );
        Ret = (LPCONTEXT)NULL;
    }

    return Ret;
}


void
LPCONTEXTCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    switch (CaseNo) {
    case LPCONTEXT_VALID_STRUCTURE:
    case LPCONTEXT_BLOCK_TOO_SMALL:
    case LPCONTEXT_INVALID_FLAGS:
        if ( LocalFree( (HANDLE)(*SCInfo) ) != NULL ) {
            ErrorPrint( hConOut, hLog, "LPCONTEXTCleanup", CaseNo, "LocalFree failed!" );
        }
        break;
    }
}


LPCRITICAL_SECTION
LPCRITICAL_SECTIONSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    LPCRITICAL_SECTION Ret;
    
    switch (CaseNo) {

    case LPCRITICAL_SECTION_NULL:
        Ret = (LPCRITICAL_SECTION)NULL;
        break;

    case LPCRITICAL_SECTION_INITIALIZED:
        Ret = LocalAlloc( LPTR, sizeof(CRITICAL_SECTION) );
        if ( Ret ) {
            InitializeCriticalSection( Ret );
        }
        break;

    case LPCRITICAL_SECTION_UNINITIALIZED:
        Ret = LocalAlloc( LPTR, sizeof(CRITICAL_SECTION) );
        break;

    case LPCRITICAL_SECTION_MINUS_ONE:
        Ret = (LPCRITICAL_SECTION)-1;
        break;

    default:
        ErrorPrint( hConOut, hLog, "LPCRITICAL_SECTIONSetup", CaseNo, "Unknown Case" );
        Ret = (LPCRITICAL_SECTION)NULL;
    }

    *SCInfo = (LPVOID)Ret;
    return Ret;
}


void
LPCRITICAL_SECTIONCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    LPCRITICAL_SECTION Ret = (LPCRITICAL_SECTION)*SCInfo;
    
    switch (CaseNo) {

    case LPCRITICAL_SECTION_NULL:
    case LPCRITICAL_SECTION_MINUS_ONE:
        break;

    case LPCRITICAL_SECTION_INITIALIZED:
        if ( Ret ) {
            DeleteCriticalSection( Ret );
        }
        // Fall thru
    case LPCRITICAL_SECTION_UNINITIALIZED:
        if ( NULL != LocalFree( Ret ) ) {
            ErrorPrint( hConOut, hLog, "LPCRITICAL_SECTIONCleanup", CaseNo, "Unable to free memory" );
        }
        break;

    default:
        ErrorPrint( hConOut, hLog, "LPCRITICAL_SECTIONSetup", CaseNo, "Unknown Case" );
        Ret = (LPCRITICAL_SECTION)NULL;
    }
}


LPCOLORREF
LPCOLORREFSetup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    COLORREF* Ret;

    switch (CaseNo) {
    case LPCOLORREF_NULL:
        Ret = (COLORREF *)NULL;
        break;

    case LPCOLORREF_MINUS_ONE:
        Ret = (COLORREF *)-1;
        break;

    case LPCOLORREF_VALID:
        if ((Ret = (COLORREF *)GlobalAlloc(GPTR, sizeof(COLORREF))) == NULL) {
            ErrorPrint(hConOut,hLog,"LPCOLORREFSetup",CaseNo,"alloc failed" );
        }
        *Ret=0x00F0F0F0; 
        *SCInfo = Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPCOLORREFSetup",CaseNo,"Unknown Case");
        Ret = (COLORREF *)NULL;
    }
    
    return Ret;
}


void
LPCOLORREFCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    switch (CaseNo) {
    case LPCOLORREF_VALID:
        if (GlobalFree( (HANDLE)(*SCInfo) ) != NULL) {
            ErrorPrint(hConOut,hLog,"LPCOLORREFSetup",CaseNo,"GlobalFree failed!" );
        }
        break;
        
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\filutil.c ===
//---------------------------------------------------------------------------
//
//  filutil.c - fileio utilities
//  ----------------------------
//
//  these are in a separate file and coded as such in hopes that they will
//  be used by more than just badman code (if and when they find a home).
//  in all cases they return error codes defined in the header file and
//  never print error messages.
//  
//  entry points:
//  -------------
//
//    fGetNextBadFileName - allows looping over many bad file names.  file
//                          system specific details are handled by this
//                          routine.
//
//    fGetCurrDriveName   - gets the name of the current drive and handles
//                          details of UNC names
//
//    fGetFileSystem      - gets the file system of the current drive and
//                          converts it to one of the enumerated constants
//                          defined in the header file
//
//  History:
//  --------
//  4-15-92 steveko - wrote
//
//---------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "filutil.h"

#define MAX_CHAR_VAL 255

#define MAX_BUFF     1024

  //
  // Ill-formed FAT file names
  //

char *IllFormedFatNames[] = {
  "",
  "xyz.",
  ".xyz",
  "xyz .a",
  "xyzabcdef.ghi",
  "xyzabcde.fghi",
  "xyz.abc.lmn"

};

#define NUM_ILL_FORMED_FAT_FILE_NAMES (sizeof(IllFormedFatNames) / \
                                       sizeof(IllFormedFatNames[0]))

  //
  // Ill-formed HPFS file names
  //

char *IllFormedHPFSNames[] = {
  "",
  "xyz.",
  "xyz ",
};

#define NUM_ILL_FORMED_HPFS_FILE_NAMES (sizeof(IllFormedHPFSNames) / \
                                        sizeof(IllFormedHPFSNames[0]))

  //
  // Ill-formed NTFS file names
  //

char *IllFormedNTFSNames[] = {  // more to be added later when know more
  "",
  "abc:",
  "abc::::",
  "ab:ab:ab"
};

#define NUM_ILL_FORMED_NTFS_FILE_NAMES (sizeof(IllFormedNTFSNames) / \
                                        sizeof(IllFormedNTFSNames[0]))

  //
  // Ill-formed CDFS file names
  //

char *IllFormedCDFSNames[] = {
  "",
  "abcdefghijklmnop.qrstuvwxyz12345",  // 1 char too long
  "abc.ab;1;2",
  "abc.xyz;40000"
};

#define NUM_ILL_FORMED_CDFS_FILE_NAMES (sizeof(IllFormedCDFSNames) / \
                                        sizeof(IllFormedCDFSNames[0]))

  //
  // printable illegal chars
  //

#define ILLEGAL_FAT_CHARS  "//:<>?|*+,;=[]"

#define ILLEGAL_HPFS_CHARS "//:<>?|*"

#define ILLEGAL_NTFS_CHARS "//<>?|*"

//---------------------------------------------------------------------------
//
//  function to get the next bad file name of the given type
//
//  Example:
//
//   for ( iType = 0, lpFileName=NULL; iType <= FIO_BADF_NUM_TYPES; iType++ )
//
//     for ( cCaseNum = 0; ; cCaseNum++ )
//
//       dwRet = fGetNextBadFileName(&lpFileName, iType, cCaseNum);
//
//       if ( dwRet == FIO_NO_MORE_CASES )
//         break
//
//       if ( dwRet != FIO_NO_ERR )
//         problem
//
//  since the max amount of memory required is 64k + 10 bytes, this function
//  will allocate and free the memory needed for the bad file names.
//
//  be sure that the value of the pointer given for lplpFileName is NULL
//  when no memory is allocated (i.e. first time called)
//
//  the memory allocated by this routine will only be freed when passed
//  an iType out of range, hence the inclusive iType (0, FIO_BADF_NUM_TYPES)
//  loop.  another example in case you don't want to loop over all types
//
//   for ( cCaseNum = 0, lpFileName=NULL; ; cCaseNum++ )
//
//     dwRet = fGetNextBadFileName(&lpFileName,
//                                 FIO_BADFNAME_UNPRINT_CHARS_ROOT, cCaseNum);
//
//     if ( dwRet == FIO_NO_MORE_CASES )
//       break
//
//     if ( dwRet != FIO_NO_ERR )
//       problem
//
//   fGetNextBadFileName(&lpFileName, -1 /* i.e. out of range */ , 0);
//
//---------------------------------------------------------------------------

DWORD fGetNextBadFileName(LPSTR *lplpFileName,
                          int    iType,
                          int    cCaseNum)
{
    char   lpCurDrive[MAX_PATH];
    char   lpUnprintIllegalStr[MAX_BUFF];
    char   lpPrintIllegalStr[MAX_BUFF];
    char   lpBuffer[MAX_PATH];
    char   *p;
    LPSTR  *lpIllFormedList;
    int    iFSType;
    int    cIllFormedCount, cMaxLength, i, iMemNeeded;
    DWORD  dwRet;
    BOOL   bRet;

    //
    // If type is out of range, free any memory allocated and return
    //
    
    if ( iType < 0 || iType >= FIO_BADF_NUM_TYPES ) {
        
        if ( *lplpFileName != NULL )
            LocalFree((HANDLE)(HANDLE) *lplpFileName);
        
        *lplpFileName = NULL;
        
        return(FIO_NO_MORE_TYPES);
    }
    
    //
    // get current drive
    //
    
    if ( (dwRet = fGetCurDriveName(lpCurDrive, MAX_PATH)) != 0 )
        return(dwRet);
    
    //
    // get file system
    //
    
    if ( (dwRet = fGetFileSystem(&iFSType)) != 0 )
        return(dwRet);
    
    //
    // set vars for below based on file system
    //
    
    switch ( iFSType ) {
        
    case FIO_FS_FAT:
        
        for ( i = 0x1f, p=lpUnprintIllegalStr; i >= 0; i-- )
            *p++ = (char) i;
        
        strcpy(lpPrintIllegalStr, ILLEGAL_FAT_CHARS);
        
        lpIllFormedList = IllFormedFatNames;
        cIllFormedCount = NUM_ILL_FORMED_FAT_FILE_NAMES;
        
        cMaxLength = 8;  // note the 8.3 type cases are handled by the
        // ill-formed test cases
        break;
        
    case FIO_FS_HPFS:
        
        for ( i = 0x1f, p=lpUnprintIllegalStr; i >= 0; i-- )
            *p++ = (char) i;
        
        strcpy(lpPrintIllegalStr, ILLEGAL_HPFS_CHARS);
        
        lpIllFormedList = IllFormedHPFSNames;
        cIllFormedCount = NUM_ILL_FORMED_HPFS_FILE_NAMES;
        
        cMaxLength = 255;
        
        break;
        
    case FIO_FS_NTFS:
        
        for ( i = 0x1f, p=lpUnprintIllegalStr; i >= 0; i-- )
            *p++ = (char) i;
        
        strcpy(lpPrintIllegalStr, ILLEGAL_NTFS_CHARS);
        
        lpIllFormedList = IllFormedNTFSNames;
        cIllFormedCount = NUM_ILL_FORMED_NTFS_FILE_NAMES;
        
        cMaxLength = 65536;
        
        break;
        
        //    case FIO_FS_CDFS: // legal chars . ; 0-9 A-F _ a-z 
        //
        //      p  = lpPrintIllegalStr;
        //      p2 = lpUnprintIllegalStr;
        //
        //      for ( i = MAX_CHAR_VAL; i >= 0; i-- ) {
        //        if ( (i == '.') ||
        //             (i == '_') ||
        //             (i == ';') ||
        //             (i >= '0' && i <= '9') ||
        //             (i >= 'A' && i <= 'F') ||
        //             (i >= 'a' && i <= 'z') )
        //          continue;
        //        if (isprint(i))
        //          *p++  = (char) i;
        //        else
        //          *p2++ = (char) i;
        //      }
        //
        //      lpIllFormedList = IllFormedCDFSNames;
        //      cIllFormedCount = NUM_ILL_FORMED_CDFS_FILE_NAMES;
        //
        //      cMaxLength = 0;
        //
        //      break;
        
    default:
        return(FIO_ERR_UNKNOWN_FILE_SYSTEM);
    }
    
    //
    // Get enough memory to hold the string, which is MAX_PATH except in the
    // special cases handled below
    //
    
    iMemNeeded = MAX_PATH;
    
    if ( iType == FIO_BADFNAME_NAME_TOO_LONG )
        iMemNeeded = cMaxLength + 10;
    
    if ( *lplpFileName == NULL )
        
        *lplpFileName = (LPSTR) LocalAlloc(LPTR, iMemNeeded);
    
    else if ( LocalSize((HANDLE) *lplpFileName) != (unsigned int) iMemNeeded ) {
        
        LocalFree((HANDLE) *lplpFileName);
        
        *lplpFileName = (LPSTR) LocalAlloc(LPTR, iMemNeeded);
    }
    
    //
    // build the next bad file name
    //
    
    switch ( iType ) {
        
    case FIO_BADFNAME_UNPRINT_CHARS_ROOT: // valid drive, illegal chars in
        // filename off root
        
        if ( cCaseNum >= (int) strlen(lpUnprintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(*lplpFileName, "%s\\xyz%ca", lpCurDrive,
            lpUnprintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADFNAME_UNPRINT_CHARS_SUBDIR: // valid drive, valid &
        // existing subdir, illegal
        // chars in filename
        
        if ( cCaseNum >= (int) strlen(lpUnprintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(lpBuffer, "%s\\xyzabc.tst", lpCurDrive);
        
        bRet = CreateDirectory(lpBuffer, NULL);  // create dir to ensure that
        // its not a bad file name
        // because of that
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS )
            return(FIO_ERR_CREATING_DIR);
        
        sprintf(*lplpFileName, "%s\\xyz%ca", lpBuffer,
            lpUnprintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADFNAME_UNPRINT_CHARS_DIRNAME: // valid drive, illegal chars in
        // subdir, good file name
        
        if ( cCaseNum >= (int) strlen(lpUnprintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(*lplpFileName, "%s\\xyz%ca\\xyz.abc", lpCurDrive,
            lpUnprintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADFNAME_PRINT_CHARS_ROOT: // valid drive, illegal chars in
        // filename off root
        
        if ( cCaseNum >= (int) strlen(lpPrintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(*lplpFileName, "%s\\xyz%ca", lpCurDrive,
            lpPrintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADFNAME_PRINT_CHARS_SUBDIR: // valid drive, valid &
        // existing subdir, illegal
        // chars in filename
        
        if ( cCaseNum >= (int) strlen(lpPrintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(lpBuffer, "%s\\xyzabc.tst", lpCurDrive);
        
        bRet = CreateDirectory(lpBuffer, NULL);  // create dir to ensure that
        // its not a bad file name
        // because of that
        
        if ( ! bRet && GetLastError() != ERROR_ALREADY_EXISTS )
            return(FIO_ERR_CREATING_DIR);
        
        sprintf(*lplpFileName, "%s\\xyz%ca", lpBuffer,
            lpPrintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADFNAME_PRINT_CHARS_DIRNAME: // valid drive, illegal chars in
        // subdir, good file name
        
        if ( cCaseNum >= (int) strlen(lpPrintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(*lplpFileName, "%s\\xyz%ca\\xyz.abc", lpCurDrive,
            lpPrintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADFNAME_INVALID_DRIVE_NAME:
        
        if ( cCaseNum > 0 )
            return(FIO_NO_MORE_CASES);
        
        strcpy(*lplpFileName, "cx:\\xyz.abc");
        break;
        
    case FIO_BADDIRNAME_ILL_FORMED:
    case FIO_BADFNAME_ILL_FORMED:
        
        if ( cCaseNum >= cIllFormedCount )
            return(FIO_NO_MORE_CASES);
        
        strcpy(*lplpFileName, lpIllFormedList[cCaseNum]);
        
        break;
        
    case FIO_BADFNAME_NAME_TOO_LONG:
        
        if ( cCaseNum > 0 )
            return(FIO_NO_MORE_CASES);
        
        for ( i = 0; i < cMaxLength + 10; i++ )
            (*lplpFileName)[i] = 'A';
        
        break;
        
    case FIO_BADDIRNAME_UNPRINT_CHARS: // valid drive, illegal chars in
        // filename off root
        
        if ( cCaseNum >= (int) strlen(lpUnprintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(*lplpFileName, "%s\\xyz%ca", lpCurDrive,
            lpUnprintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADDIRNAME_PRINT_CHARS: // valid drive, illegal chars in
        // filename off root
        
        if ( cCaseNum >= (int) strlen(lpUnprintIllegalStr) )
            return(FIO_NO_MORE_CASES);
        
        sprintf(*lplpFileName, "%s\\xyz%ca", lpCurDrive,
            lpPrintIllegalStr[cCaseNum]);
        break;
        
    case FIO_BADDIRNAME_INVALID_DRIVE_NAME:
        
        if ( cCaseNum > 0 )
            return(FIO_NO_MORE_CASES);
        
        strcpy(*lplpFileName, "cx:\\xyz.abc");
        break;
  }
  
  return(FIO_NO_ERR);
}

DWORD fGetNextBadFileNameW(
    LPWSTR *lplpFileName,
    int    iType,
    int    cCaseNum)
{
    LPSTR lpFileName = NULL;
    DWORD ReturnStatus;
    NTSTATUS Status;

    ReturnStatus = fGetNextBadFileName(&lpFileName, iType, cCaseNum);

    if ( FIO_NO_ERR == ReturnStatus ) {
        ANSI_STRING Ansi;
        UNICODE_STRING Unicode;

        ASSERT( lpFileName );

        RtlInitAnsiString( &Ansi, lpFileName );
        Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, TRUE );
        LocalFree( lpFileName );

        if ( NT_SUCCESS(Status) ) {
            *lplpFileName = Unicode.Buffer;
        } else {
            KdPrint(( "FILEUTIL: RtlAnsiStringToUnicodeString failed, status = 0x%x\n", Status ));
            *lplpFileName = NULL;
        }
    } else {
        KdPrint(( "FILEUTIL: fGetNextBadFileName failed (%d)\n", ReturnStatus ));
    }

    return ReturnStatus;
}

//---------------------------------------------------------------------------
//
// Function to get the current drive name
//
//---------------------------------------------------------------------------

DWORD fGetCurDriveName(LPSTR lpBuff, DWORD dwBuffLen)
{
  char lpCurDir[MAX_PATH];
  int i, cNumSlash;

  strcpy( lpCurDir, "z:\\" );

  //
  // if first char a \, then a UNC name
  //

  if ( lpCurDir[0] == '\\' ) {

    for ( i = 0, cNumSlash = 0; lpCurDir[i] && cNumSlash < 4; i++ )
      if ( lpCurDir[i] == '\\' )
        cNumSlash++;

    if ( (unsigned int) i > dwBuffLen )
      return(FIO_ERR_BUFF_TOO_SMALL);

    strncpy(lpBuff, lpCurDir, i);
    lpBuff[i] = '\0';
  }

  //
  // else first two chars are logical drive
  //

  else {

    if ( dwBuffLen < 3 )
      return(FIO_ERR_BUFF_TOO_SMALL);

    strncpy(lpBuff, lpCurDir, 2);
    lpBuff[2] = '\0';
  }

  return(FIO_NO_ERR);
}

//---------------------------------------------------------------------------
//
//  function to get the file system (one of the fFileSystems enum'd values)
//
//  passing NULL for lpRootPathName will get the file system type for the
//  current drive
//
//---------------------------------------------------------------------------

DWORD fGetFileSystem(LPINT lpFsType)
{
  // BUGBUG: Always return FAT for now
  *lpFsType = FIO_FS_FAT;
  return FIO_NO_ERR;

  /*char lpFSName[MAX_BUFF];

  if ( ! GetVolumeInformation(NULL, NULL, 0, NULL, NULL, NULL,
                              lpFSName, MAX_BUFF) ) {
      return(FIO_ERR_GETVOLINFO);
  }

  if ( strcmp(lpFSName, "FAT") == 0 )
      *lpFsType = FIO_FS_FAT;
  else if ( strcmp(lpFSName, "HPFS") == 0 )
      *lpFsType = FIO_FS_HPFS;
  else if ( strcmp(lpFSName, "NTFS") == 0 )
      *lpFsType = FIO_FS_NTFS;
  else if ( strcmp(lpFSName, "CDFS") == 0 )
      *lpFsType = FIO_FS_CDFS;
  else
      return(FIO_ERR_UNKNOWN_FILE_SYSTEM);

  return(FIO_NO_ERR);*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\i_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    i_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'I'. It also contains setup and cleanup
    funtions beginning with 'LPI'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <i_cases.bmh>
#include "limits.h"


int intSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    int Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );
    
    switch(CaseNo) {
    case int_THREAD_PRIORITY_LOWEST:
        Ret = THREAD_PRIORITY_LOWEST;
        break;
    case int_THREAD_PRIORITY_BELOW_NORMAL:
        Ret = THREAD_PRIORITY_BELOW_NORMAL;
        break;
    case int_THREAD_PRIORITY_NORMAL:
        Ret = THREAD_PRIORITY_NORMAL;
        break;
    case int_THREAD_PRIORITY_ABOVE_NORMAL:
        Ret = THREAD_PRIORITY_ABOVE_NORMAL;
        break;
    case int_THREAD_PRIORITY_HIGHEST:
        Ret = THREAD_PRIORITY_HIGHEST;
        break;
    case int_BAD_THREAD_PRIORITY:
        Ret = 256;
        break;
    case int_THIRTEEN:
        Ret = 13;
        break;
    case int_ZERO:
        Ret = 0;
        break;
    case int_MAXINT:
        Ret = INT_MAX;
        break;
    case int_MININT:
        Ret = INT_MIN;
        break;
    case int_MINUS_ONE:
        Ret = -1;
        break;
    case int_46:
        Ret = 46;
        break;
    case int_ONE:
        Ret = 1;
        break;
    case int_2:
        Ret = 2;
        break;
    case int_THREE:
        Ret = 3;
        break;
    case int_100:
        Ret = 100;
        break;
    case int_TIMER:
        Ret=int_TIMER;
        break;
        
    case int_HOTKEY:
        Ret=0xBFFF;
        break;
        
    case int_MAX_POSSIBLE_STRING:
        Ret = 1024;  // get the correct value from Bodin.
        break;
        
    case int_SYSRGN:
        Ret = 4;
        break;
        
    case int_BIGGER_THAN_MAX_POSSIBLE:
        Ret = 1025;  // get the correct value from Bodin.
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"intSetup",CaseNo,"Unknown Case");
        Ret = (int) NULL;
        break;
    }
    
    return(Ret);
}


void intCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


LPINT LPINTSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPINT  Ret, ipPtr;
    int       count;
    
    switch(CaseNo) {
    case LPINT_MIN_INT:
        Ret   = (LPINT)LocalAlloc( LPTR, (6 * sizeof(UINT)));
        if (Ret != NULL) {
            ipPtr = (LPINT)Ret;
            
            for (count = 0; count < 6; count++)
                *ipPtr++ = INT_MIN;
            
        } else
            ErrorPrint(hConOut,hLog,"LPINTSetup",CaseNo,"LocalAlloc failed!");
        (*SCInfo) = (LPVOID)Ret;
        break;
        
    case LPINT_MAX_INT:
        Ret   = (LPINT)LocalAlloc( LPTR, (6 * sizeof(UINT)));
        if (Ret != NULL) {
            
            ipPtr = (LPINT)Ret;
            
            for (count = 0; count < 6; count++)
                *ipPtr++ = INT_MAX;
            
        } else
            ErrorPrint(hConOut,hLog,"LPINTSetup",CaseNo,"LocalAlloc failed!");
        (*SCInfo) = (LPVOID)Ret;
        break;
        
    case LPINT_454:
        Ret   = (LPINT)LocalAlloc( LPTR, (3 * sizeof(UINT)));
        
        if (Ret != NULL) {
            ipPtr = (LPINT)Ret;
            *ipPtr++ = 4;
            *ipPtr++ = 5;
            *ipPtr   = 4;
            
        } else
            ErrorPrint(hConOut,hLog,"LPINTSetup",CaseNo,"LocalAlloc failed!");
        (*SCInfo) = (LPVOID)Ret;
        break;
        
    case LPINT_VALID:
        Ret   = (LPINT)LocalAlloc( LPTR, (6 * sizeof(UINT)));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPINTSetup",CaseNo,"LocalAlloc failed!");
        (*SCInfo) = (LPVOID)Ret;
        break;
        
    case LPINT_65:
        Ret   = (LPINT)LocalAlloc( LPTR, (65 * sizeof(UINT)));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPINTSetup",CaseNo,"LocalAlloc failed!");
        (*SCInfo) = (LPVOID)Ret;
        break;
        
        
        //don't use this one to hard to debug
    case LPINT_RANDOM:
        Ret =  (LPINT) rand();
        break;
        
    case LPINT_MINUS_ONE:
        Ret = (LPINT) -1;
        break;
        
    case LPINT_NULL:
        Ret = (LPINT) NULL;
        break;

    default:
        ErrorPrint(hConOut,hLog,"LPINTSetup",CaseNo,"Unknown Case");
        Ret = (LPINT) NULL;
        break;
    }
    
    return(Ret);
}


void LPINTCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPINT_MIN_INT:
    case LPINT_MAX_INT:
    case LPINT_VALID:
    case LPINT_65:
    case LPINT_454:
    case LPINT_SYSCOLOR:
        
        if (*SCInfo!=NULL){
            if (LocalFree( (HANDLE)(*SCInfo) ) != NULL)
                ErrorPrint(hConOut,hLog,"LPINTCleanup",CaseNo,"LocalFree failed!");
        }
        break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\g_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    g_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'G'. It also contains setup and cleanup
    funtions beginning with 'LPG'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <g_cases.bmh>


PGENERIC_MAPPING
PGENERIC_MAPPINGSetup( int     CaseNo,
                       LPVOID  *SCInfo,
                       HANDLE  hLog,
                       HANDLE  hConOut
                     )
{
    DWORD  PointerSize, PointerType;
    PGENERIC_MAPPING    GenM;
    SE_CLEANUP_INFO     *CleanupInfo = NULL;
    
    /*
    * If *SCInfo is NULL on entry we need to allocate space, otherwise
    * we'll try to put the SID at the location specified by *SCInfo.
    * This is so that more complex structures can be created with our
    * strange sets of data in them.
    */
    
    if (*SCInfo && (DWORD)*SCInfo != GET_REQUIRED_SIZE) {
        GenM = (PGENERIC_MAPPING)*SCInfo;
    } else {
    /*
    * Determine size, type of pointer and generate it.
        */
        
        PointerType = VALIDRANGE_POINTER;
        PointerSize = sizeof (GENERIC_MAPPING);
        
        switch (CaseNo) {
            
        case PGENERIC_MAPPING_VALID:
        /*
        * Defaults are correct
            */
            
            break;
            
        case PGENERIC_MAPPING_MALALIGNED:
        /*
        * pointer aligned on a byte boundary
            */
            
            PointerType = MALALIGNED_POINTER_1;
            
            break;
            
        case PGENERIC_MAPPING_INVALID:
        /*
        * An invalid pointer.
            */
            
            PointerType = INVALID_POINTER;
            PointerSize = 0;
            
            break;
            
        case PGENERIC_MAPPING_INVALID_1:
        /*
        * Only first DWORD of the generic mapping is valid.
            */
            
            PointerSize = 1 * sizeof (DWORD);
            
            break;
            
        case PGENERIC_MAPPING_INVALID_2:
        /*
        * frist & second DWORD of generic mapping valid
            */
            
            PointerSize = 2 * sizeof (DWORD);
            
            break;
            
        case PGENERIC_MAPPING_INVALID_3:
        /*
        * all but last DWORD of generic mapping valid
            */
            
            PointerSize = 2 * sizeof (DWORD);
            
            break;
            
        case PGENERIC_MAPPING_NULL:
            PointerType = NULL_POINTER;
            PointerSize = 0;
            
            break;
            
        default:
            ErrorPrint(hConOut, hLog, "PSIDSetup", CaseNo,
                "Unknown Case");
            
            break;
        }
        
        if ((DWORD)*SCInfo == GET_REQUIRED_SIZE) {
            *SCInfo = (VOID *)PointerSize;
            
            return NULL;
        } else {
            if (!MakeBadPointer((PVOID *)&GenM,
                &CleanupInfo,
                PointerType,
                PointerSize,
                hConOut,
                hLog)) {
                ErrorPrint(hConOut, hLog,
                    "PGENERIC_MAPPINGSetup", CaseNo,
                    "MakeBadPointer failed");
            }
        }
    }
    
    /*
    * part 2 builds the LUID
    */
    
    try {
        switch (CaseNo) {
        case PGENERIC_MAPPING_NULL:
        case PGENERIC_MAPPING_INVALID:
        /*
        * no valid bytes, don't waste the cycles to pop the
        * try
            */
            
            break;
            
        case PGENERIC_MAPPING_VALID:
        case PGENERIC_MAPPING_INVALID_1:
        case PGENERIC_MAPPING_INVALID_2:
        case PGENERIC_MAPPING_INVALID_3:
        case PGENERIC_MAPPING_MALALIGNED:
            // I don't think the un-aligned case is any
            // different for us, though it might be...
            
            /*
            * stuff stuff (stuff order is important)
            */
            
            GenM -> GenericRead = STANDARD_RIGHTS_READ |
                TOKEN_QUERY;
            
            GenM -> GenericWrite = STANDARD_RIGHTS_WRITE |
                TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS |
                TOKEN_ADJUST_DEFAULT;
            
            GenM -> GenericExecute = STANDARD_RIGHTS_EXECUTE |
                TOKEN_IMPERSONATE;
            
            GenM -> GenericAll = TOKEN_ALL_ACCESS;
            
            break;
            
        default:
            ErrorPrint(hConOut, hLog, "PGENERIC_MAPPINGSetup",
                CaseNo, "CANT HAPPEN");
            
            break;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    /*
    * This isn't a problem since we expect that we might be
    * trying to put data in a bogus location.
        */
        
        // we almost anyway... I want to know if I trap setting
        // unaligned stuff...
        
        if (CaseNo == PGENERIC_MAPPING_MALALIGNED) {
            
            ErrorPrint(hConOut, hLog, "PGENERIC_MAPPINGSetup",
                CaseNo, "MALALIGNED TRAPPED");
        }
    }
    
    /*
    * If *SCInfo had useful data initially, don't clobber it, otherwise
    * set it to the CleanupInfo that we generated.
    */
    
    if (!*SCInfo) {
        *SCInfo = CleanupInfo;
    }
    
    return GenM;
}


void
PGENERIC_MAPPINGCleanup(
                        int         CaseNo,
                        LPVOID          *SCInfo,
                        HANDLE          hLog,
                        HANDLE          hConOut
                        )
{
    switch(CaseNo) {
    case PGENERIC_MAPPING_NULL:
    case PGENERIC_MAPPING_INVALID:
    case PGENERIC_MAPPING_VALID:
    case PGENERIC_MAPPING_INVALID_1:
    case PGENERIC_MAPPING_INVALID_2:
    case PGENERIC_MAPPING_INVALID_3:
    case PGENERIC_MAPPING_MALALIGNED:
    /*
    * Mop time.
        */
        
        MakeBadPointer(NULL,
            (SE_CLEANUP_INFO **)SCInfo,
            CLEANUP,
            0,
            hConOut,
            hLog);
        
        if (*SCInfo) {
            ErrorPrint(hConOut, hLog, "PGENERIC_MAPPINGCleanup",
                CaseNo, "Cleanup failed.");
        }
        
        break;
        
    default:
        /* look, no mess! */
        
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\h_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    h_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'H'. It also contains setup and cleanup
    funtions beginning with 'LPH'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <h_Cases.bmh>
#include <i_Cases.bmh>
#include <memmgt.h>
#include <stdlib.h>
#include <time.h>
#include <filever.h>
#include "limits.h"
#include <psapi.h>
#include <tchar.h>


HANDLE HANDLESetup(int CaseNo, LPVOID *SCInfo, HANDLE hLog, HANDLE hConOut)
{
    //
    // INVALID_HANDLE_VALUE isn't always invalid...  It just so happens that
    // INVALID_HANDLE_VALUE == GetCurrentProcess()...
    //
    
    HANDLE  hRet = (HANDLE)0xDEADBEEF;
    DWORD   id;
    
    switch (CaseNo) {
        
    case HANDLE_RANDOM:
        // you know that 'random' handles are neither always valid, nor
        // always invalid, don't you?
        srand( (unsigned) clock() );      // added 4/3/92 tommcg
        hRet = (HANDLE) rand();
        break;
        
    case HANDLE_NULL:
        hRet = (HANDLE) NULL;
        break;

    case HANDLE_INVALID:
        hRet = INVALID_HANDLE_VALUE;
        break;
        
    case HANDLE_UNLOCKED_LMEM_BLOCK:
    case HANDLE_LOCKED_LMEM_BLOCK:
    case HANDLE_NONDISCARDABLE_LMEM_BLOCK:
        //  case HANDLE_DISCARDED_LMEM_BLOCK:
    case HANDLE_FREED_LMEM_BLOCK:
        hRet = LMemHandleCreate(hLog,hConOut,CaseNo);
        *SCInfo = (LPVOID) hRet;
        break;
        
    case HANDLE_UNLOCKED_GMEM_BLOCK:
    case HANDLE_LOCKED_GMEM_BLOCK:
    case HANDLE_NONDISCARDABLE_GMEM_BLOCK:
    case HANDLE_DISCARDED_GMEM_BLOCK:
    case HANDLE_FREED_GMEM_BLOCK:
        hRet = GMemHandleCreate(hLog,hConOut,CaseNo);
        *SCInfo = (LPVOID) hRet;
        break;

    case HANDLE_PROCESS_HEAP:
        hRet = GetProcessHeap();
        *SCInfo = hRet;
        break;
        
    case HANDLE_GROWABLE_HEAP:
    case HANDLE_32K_HEAP:
    case HANDLE_UNGROWABLE_FILLED_HEAP:
    case HANDLE_DESTROYED_32K_HEAP:
        hRet = HeapHandleCreate(hLog,hConOut,CaseNo);
        *SCInfo = (LPVOID) hRet;
        break;
        
    case HANDLE_THREAD:
        
        hRet = CreateThread(NULL,
                    0L,
                    (LPTHREAD_START_ROUTINE)InfThread,
                    0L,
                    0L,
                    &id);
        
        *SCInfo = (LPVOID)hRet;
        
        break;
        
    case HANDLE_CURRENT_THREAD:
        
        hRet = GetCurrentThread();
        
        break;
        
    case HANDLE_SUSPENDED_THREAD:
        hRet = CreateThread( NULL, 0L, (LPTHREAD_START_ROUTINE)InfThread, 0L, CREATE_SUSPENDED, &id );
        *SCInfo = (LPVOID)hRet;
        break;
        
    case HANDLE_NORMAL_FILE:
    case HANDLE_READONLY_FILE:
    case HANDLE_CLOSED_FILE:
    case HANDLE_FINDFILE:
    case HANDLE_CLOSED_FINDFILE:
    case HANDLE_NORMAL_ASYNC_FILE:
    case HANDLE_READONLY_ASYNC_FILE:
        hRet = FIOHandleSetup(CaseNo, SCInfo, hLog, hConOut);
        break;
        
    case HANDLE_GOOD_CHANGE_NOTIFY:
        //hRet = FindFirstChangeNotification("c:\\", TRUE, FILE_NOTIFY_CHANGE_FILE_NAME);
        if ( hRet == INVALID_HANDLE_VALUE ) {
            
            ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
                "Could not open change notification handle");
            *SCInfo = NULL;
            break;
        }
        *SCInfo = (LPVOID)hRet;
        break;
        
    case HANDLE_CLOSED_CHANGE_NOTIFY:
        //hRet = FindFirstChangeNotification("c:\\", TRUE, FILE_NOTIFY_CHANGE_FILE_NAME);
        if ( hRet == INVALID_HANDLE_VALUE ) {
            
            ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo,
                "Could not open change notification handle");
            *SCInfo = NULL;
            break;
        }
        /*if ( 0 ) {
            ErrorPrint(hConOut, hLog, "FIOHandleSetup", CaseNo, "error closing change notification handle");
            break;
        }*/
        break;
        
    case HANDLE_LOCAL_FILE:
        // handle to a local file
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_LOCAL_FILE) not implemented");
        break;
        
    case HANDLE_MAILSLOT:
        // handle to a mailslot
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_MAILSLOT) not implemented");
        break;
        
    case HANDLE_NAMED_EVENT:
        hRet = CreateEventW( NULL, FALSE, TRUE, (LPCWSTR)L"BADMAN Named Event" );
        *SCInfo = hRet;
        
        if (!hRet) {
            ErrorPrint(
                hConOut,
                hLog,
                "HANDLESetup",
                CaseNo,
                "CreateEvent failed"
                );
        }
        
        break;
        
    case HANDLE_NAMED_MUTANT:
        // handle to a named mutant
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_NAMED_MUTANT) not implemented");
        break;
        
    case HANDLE_NAMED_SECTION:
        // handle to a named section
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_NAMED_SECTION) not implemented");
        break;
        
    case HANDLE_NAMED_SEMAPHORE:
        hRet = CreateSemaphoreW(NULL, 0, 10, (LPCWSTR)L"BADMAN Named Semaphore");
        *SCInfo = hRet;
        break;
        
    case HANDLE_NAMEDPIPE:
        // handle to a named pipe
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_NAMEDPIPE) not implemented");
        break;
        
    case HANDLE_REMOTE_FILE:
        // handle to a remote file
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_REMOTE_FILE) not implemented");
        break;
        
    case HANDLE_UNNAMED_EVENT:
        // handle to an unnamed event
        *SCInfo = hRet = CreateEventW(NULL, FALSE, TRUE, NULL);
        break;
        
    case HANDLE_UNNAMED_SECTION:
        // handle to an unnamed section
        //ErrorPrint(hConOut, hLog, "HANDLESetup", CaseNo, "(HANDLE_UNNAMED_SECTION) not implemented");
        break;
        
    case HANDLE_UNNAMED_SEMAPHORE:
        *SCInfo = hRet = CreateSemaphoreW(NULL, 0, 10, NULL);
        break;
        
    case HANDLE_NAMED_WAITABLE_TIMER:
        hRet = CreateWaitableTimerW( 0, TRUE, (LPCWSTR)L"Badman Waitable Timer" );
        *SCInfo = (LPVOID)hRet;
        break;
        
    case HANDLE_UNNAMED_WAITABLE_TIMER:
        hRet = CreateWaitableTimerW( 0, TRUE, NULL );
        *SCInfo = (LPVOID)hRet;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"HANDLESetup",CaseNo,"Unknown Case");
        hRet = (HANDLE)0;
        break;
    }
    
    return hRet;
}

void HANDLECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    char                  szError[50];  //debug ouput string
    UINT                  uFlags;    //stores *Flags information

    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
    
    switch(CaseNo) {
        
    case HANDLE_LOCKED_LMEM_BLOCK:
    case HANDLE_UNLOCKED_LMEM_BLOCK:
    case HANDLE_NONDISCARDABLE_LMEM_BLOCK:
        if (LocalFree((HANDLE) *SCInfo) != NULL){
            uFlags = 0;
            sprintf(szError, "LocalFree Failed-LocalFlags = %u", uFlags);
            ErrorPrint( hConOut, hLog, "HANDLECleanup", CaseNo, szError );
        }
        break;
        
    case HANDLE_LOCKED_GMEM_BLOCK:
    case HANDLE_UNLOCKED_GMEM_BLOCK:
    case HANDLE_NONDISCARDABLE_GMEM_BLOCK:
        if (GlobalFree((HANDLE) *SCInfo) != NULL){
            uFlags = 0;
            sprintf(szError, "GlobalFree Failed-GlobalFlags = %u", uFlags);
            ErrorPrint( hConOut, hLog, "HANDLECleanup", CaseNo, szError );
        }
        break;
        
    case HANDLE_GROWABLE_HEAP:
    case HANDLE_32K_HEAP:
    case HANDLE_UNGROWABLE_FILLED_HEAP:
        HeapDestroy((HANDLE) *SCInfo);
        break;
        
    case HANDLE_THREAD:
    case HANDLE_SUSPENDED_THREAD:
        if (*SCInfo) {
            ULONG PreviousSuspendCount;
            NTSTATUS Status;

            do {
                Status = NtResumeThread( (HANDLE)*SCInfo, &PreviousSuspendCount );
            } while ( NT_SUCCESS(Status) && PreviousSuspendCount );

            SetThreadPriority( (HANDLE)*SCInfo, THREAD_PRIORITY_HIGHEST );
            QueueUserAPC((PAPCFUNC)ExitThread, (HANDLE)*SCInfo, 0xdeadbeef);
            NtAlertThreadEx( (HANDLE)*SCInfo, UserMode );
            NtYieldExecution();

            while ( WaitForSingleObject((HANDLE)*SCInfo, 5000) == WAIT_TIMEOUT ) {
                KdPrint(( "SETCLN: timeout while waiting for thread to be terminated\n" ));
            }
            
            if (!CloseHandle( (HANDLE)(*SCInfo) ))
                ErrorPrint(hConOut,hLog,"HANDLECleanup",CaseNo,"CloseHandle(hThread) failed");
        }
        break;
        
    case HANDLE_NORMAL_FILE:
    case HANDLE_READONLY_FILE:
    case HANDLE_CLOSED_FILE:
    case HANDLE_FINDFILE:
    case HANDLE_CLOSED_FINDFILE:
    case HANDLE_NORMAL_ASYNC_FILE:
    case HANDLE_READONLY_ASYNC_FILE:
        FIOHandleCleanup(CaseNo, SCInfo, hLog, hConOut);
        break;
        
    case HANDLE_GOOD_CHANGE_NOTIFY:
        if ( *SCInfo != NULL ) {
            //if ( 0 ) {
                //ErrorPrint(hConOut, hLog, "FIOHandleCleanup", CaseNo,
                    //"error closing change notification handle");
                //break;
            //}
        }
        break;
        
    case HANDLE_LOCAL_FILE:
    case HANDLE_MAILSLOT:
    case HANDLE_NAMED_EVENT:
    case HANDLE_NAMED_MUTANT:
    case HANDLE_NAMED_SECTION:
    case HANDLE_NAMED_SEMAPHORE:
    case HANDLE_NAMEDPIPE:
    case HANDLE_REMOTE_FILE:
    case HANDLE_UNNAMED_EVENT:
    case HANDLE_UNNAMED_SECTION:
    case HANDLE_UNNAMED_SEMAPHORE:
    case HANDLE_NAMED_WAITABLE_TIMER:
    case HANDLE_UNNAMED_WAITABLE_TIMER:
        if (*SCInfo) {
            if (!CloseHandle((HANDLE)*SCInfo)) {
                ErrorPrint(hConOut,
                    hLog,
                    "HandleCleanup",
                    CaseNo,
                    "error closing handle");
            }
        }
        
        break;
        
    default:
        break;
    }
}


LPHANDLE
LPHANDLESetup(
              int         CaseNo,
              LPVOID          *SCInfo,
              HANDLE          hLog,
              HANDLE          hConOut
              )
{
    LPHANDLE        Ret = (LPHANDLE)NULL;
    SE_CLEANUP_INFO     *CleanupInfo = NULL;
    
    switch (CaseNo) {
    case LPHANDLE_NULL:
    /*
    * no action, default is correct.
        */
        
        break;
        
    case LPHANDLE_INVALID:
    /*
    * an invalid pointer
        */
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            INVALID_POINTER,
            0,
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPHANDLESetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
        
    case LPHANDLE_VALID:
    /*
    * pointer to a handle sized region
        */
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            sizeof (HANDLE),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPHANDLESetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
        
    default:
        ErrorPrint(hConOut, hLog, "LPHANDLESetup", CaseNo,
            "Unknown Case");
        
        break;
    }
    
    return Ret;
}


void
LPHANDLECleanup(
                int         CaseNo,
                LPVOID          *SCInfo,
                HANDLE          hLog,
                HANDLE          hConOut
                )
{
    switch(CaseNo) {
    case LPHANDLE_INVALID:
    case LPHANDLE_VALID:
    /*
    * MakeBadPointer was used in setup, so clean up the mess that
    * way too.
        */
        
        MakeBadPointer(NULL,
            (SE_CLEANUP_INFO **)SCInfo,
            CLEANUP,
            0,
            hConOut,
            hLog);
        
        if (*SCInfo) {
            ErrorPrint(hConOut, hLog, "LPHANDLECleanup", CaseNo,
                "Cleanup failed.");
        }
        
        break;
        
    default:
    /*
    * no action
        */
        
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\k_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    k_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'K'. It also contains setup and cleanup
    funtions beginning with 'LPK'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <k_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\j_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    j_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'J'. It also contains setup and cleanup
    funtions beginning with 'LPJ'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <j_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\f_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    f_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'F'. It also contains setup and cleanup
    funtions beginning with 'LPF'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <f_cases.bmh>
#include "float.h"

#pragma warning( disable : 4054 )

FARPROC FARPROCSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    FARPROC Ret;
    
    switch(CaseNo) {
        
    case FARPROC_NULL:
        Ret = (FARPROC)NULL;
        *SCInfo = (LPVOID)Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"FARPROCSetup",CaseNo,"Unknown Case");
        Ret = (FARPROC)NULL;
    }
    
    return Ret;
}


void FARPROCCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


FLOAT FLOATSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    FLOAT Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );

    switch(CaseNo) {
    case FLOAT_ONE:
        Ret = 1.0f;
        break;
    case FLOAT_ZERO:
        Ret = 0.0f;
        break;
    default:
        ErrorPrint(hConOut,hLog,"FLOATSetup",CaseNo,"Unknown Case");
        Ret = 0.0f;
        break;
    }
    
    return(Ret);
}


void FLOATCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}


LPFILETIME LPFILETIMESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPFILETIME Ret;
    
    switch(CaseNo) {
        
    case LPFILETIME_VALID_ADDRESS:
    case LPFILETIME_VALID_DATA:
        if ( (Ret = malloc(sizeof(FILETIME))) == NULL )
            ErrorPrint(hConOut,hLog,"LPFILETIMESetup",CaseNo,
            "Error allocating memory");
        *SCInfo = Ret;
        break;
    case LPFILETIME_NULL:
        Ret = NULL;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPFILETIMESetup",CaseNo,"Unknown Case");
        Ret = (LPFILETIME) NULL;
        break;
    }
    
    return(Ret);
}


void LPFILETIMECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
    case LPFILETIME_VALID_ADDRESS:
    case LPFILETIME_VALID_DATA:
        if ( *SCInfo != NULL )
            free(*SCInfo);
    default:
        break;
    }
}


PFLOAT PFLOATSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    PFLOAT    Ret,
        pfPtr;
    int       count;
    
    switch(CaseNo) {
    case PFLOAT_NULL:
        Ret = (PFLOAT) NULL;
        break;
        
    case PFLOAT_RANDOM:
        Ret = (PFLOAT) rand();
        break;
        
    case PFLOAT_MINUS_ONE:
        Ret = (PFLOAT) -1;
        break;
        
    case PFLOAT_MAX_FLOAT:
        Ret = (PFLOAT) LocalAlloc (LPTR, 5*sizeof(FLOAT));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"PFLOATSetup",CaseNo,"LocalAlloc failed!");
        pfPtr = Ret;
        for (count = 0; count < 5; count++)
            *pfPtr++ = FLT_MAX;
        *SCInfo = Ret;
        break ;
        
    case PFLOAT_MIN_FLOAT:
        Ret = (PFLOAT) LocalAlloc (LPTR, 5*sizeof(FLOAT));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"PFLOATSetup",CaseNo,"LocalAlloc failed!");
        
        pfPtr = Ret;
        for (count = 0; count < 5; count++)
            *pfPtr++ = FLT_MIN;
        *SCInfo = Ret;
        break ;
        
    case PFLOAT_65:
        Ret = (PFLOAT) LocalAlloc (LPTR, 65*sizeof(FLOAT));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"PFLOATSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break ;
        
    default:
        ErrorPrint(hConOut,hLog,"PFLOATSetup",CaseNo,"Unknown Case");
        Ret = (PFLOAT ) NULL;
        break;
    }
    
    return(Ret);
}


void PFLOATCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    switch(CaseNo) {
    case PFLOAT_MIN_FLOAT:
    case PFLOAT_MAX_FLOAT:
    case PFLOAT_65:
        if (*SCInfo!=NULL)
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPFLOATCleanup",CaseNo,"LocalFree failed!");
            break;
    case PFLOAT_NULL:
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\l_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    l_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'L'. It also contains setup and cleanup
    funtions beginning with 'LPL'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <setcln.h>
#include <l_cases.bmh>


LONG LONGSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LONG      Ret = 0;
    LPSTR     lpstrPtr;
    LPWSTR    lpwstrPtr;
    
    switch(CaseNo) {
        
    case LONG_ONE_K:
        Ret = 1024;
        break;
    case LONG_MINUS_ONE:
        Ret = -1;
        break;
        
    case LONG_VALID_STRINGA:
        lpstrPtr = (LPSTR)GlobalAlloc(GPTR, strlen("Test String"));
        if (lpstrPtr){
            strcpy(lpstrPtr, "Test String");
            Ret = (LONG)lpstrPtr;
        } else {
            ErrorPrint(hConOut,hLog,"LONGSetup",CaseNo,"GlobalAlloc failed");
        }
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LONG_VALID_STRINGW:
        lpwstrPtr = (LPWSTR)GlobalAlloc(GPTR,
            lstrlenW((LPCWSTR)TEXT("Test String"))*sizeof(WCHAR));
        if (lpwstrPtr){
            lstrcpyW(lpwstrPtr, (LPCWSTR)TEXT("Test String"));
            Ret = (LONG)lpwstrPtr;
        } else {
            ErrorPrint(hConOut,hLog,"LONGSetup",CaseNo,"GlobalAlloc failed");
        }
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LONG_ZERO:
        Ret=0;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LONGSetup",CaseNo,"Unknown Case");
        Ret = (LONG) NULL;
        break;
    }
    
    return(Ret);
}


void LONGCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LONG_VALID_STRINGA:
    case LONG_VALID_STRINGW:
        if (*SCInfo!=NULL)
            if (GlobalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LONGCleanup",CaseNo,"GlobalFree failed!");
            break;
    default:
        break;
    }
}


PVOID LPLOGPALETTESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPLOGPALETTE   Ret;
    LPPALETTEENTRY lpPtr;
    
    switch(CaseNo) {
    case LPLOGPALETTE_NULL:
        Ret = (LPLOGPALETTE)NULL;
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPLOGPALETTE_VALID:
        Ret = (LPLOGPALETTE) GlobalAlloc(GPTR, sizeof(LOGPALETTE));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPLOGPALETTESetup",CaseNo,"Alloc failed!");
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPLOGPALETTE_ONE:
        Ret = (LPLOGPALETTE) GlobalAlloc(GPTR, sizeof(LOGPALETTE));
        if (Ret == NULL){
            ErrorPrint(hConOut,hLog,"LPLOGPALETTESetup",CaseNo,"Alloc failed!");
        } else {
            Ret->palVersion     = 0x300;
            Ret->palNumEntries  = 1;
            lpPtr = Ret->palPalEntry;
            if ( NULL != (lpPtr = (LPPALETTEENTRY)GlobalAlloc(GPTR, sizeof(PALETTEENTRY))) ) {
                lpPtr->peRed   = 1;
                lpPtr->peGreen = 2;
                lpPtr->peBlue  = 3;
                lpPtr->peFlags = (BYTE)0;
            } else {
                ErrorPrint(hConOut,hLog,"LPLOGPALETTESetup",CaseNo,"Alloc failed!");
            }
        }
        *SCInfo = (LPVOID)Ret;
        break ;
        
    default:
        ErrorPrint(hConOut,hLog,"LPLOGPALETTESetup",CaseNo,"Unknown Case");
        Ret = (LPLOGPALETTE) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}


void LPLOGPALETTECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPLOGPALETTE lpPtr = NULL;
    
    switch(CaseNo) {
    case LPLOGPALETTE_VALID:
        if (*SCInfo!=NULL)
            if (GlobalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPLOGPALETTECleanup",CaseNo,"Free failed!");
            break;
    case LPLOGPALETTE_ONE:
        if (*SCInfo!=NULL)
            lpPtr = (LPLOGPALETTE)(*SCInfo);
        if (GlobalFree( (HANDLE)(lpPtr->palPalEntry))!=NULL)
            ErrorPrint(hConOut,hLog,"LPLOGPALETTECleanup",CaseNo,"Free PalEntry failed!");
        if (GlobalFree( (HANDLE)(*SCInfo) )!=NULL)
            ErrorPrint(hConOut,hLog,"LPLOGPALETTECleanup",CaseNo,"Free failed!");
    default:
        break;
    }
#endif
}


LPLONG LPLONGSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPLONG Ret;

    UNREFERENCED_PARAMETER( SCInfo );
    
    switch(CaseNo) {
        
    case LPLONG_NULL:
        Ret = NULL;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPLONGSetup",CaseNo,"Unknown Case");
        Ret = (LPLONG) NULL;
        break;
    }
    
    return(Ret);
}


void LPLONGCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\q_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    q_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'Q'. It also contains setup and cleanup
    funtions beginning with 'LPQ'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/

#include <setcln.h>
#include <q_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\o_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    o_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'O'. It also contains setup and cleanup
    funtions beginning with 'LPO'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <o_cases.bmh>


LPOVERLAPPED LPOVERLAPPEDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPOVERLAPPED Ret;
    
    switch(CaseNo) {
        
    case LPOVERLAPPED_NULL:
        Ret = NULL;
        break;
    case LPOVERLAPPED_VALID:
        if ( (Ret = malloc(sizeof(OVERLAPPED))) == NULL )
            ErrorPrint(hConOut,hLog,"LPOVERLAPPEDSetup",CaseNo,
            "Error allocating memory");
        *SCInfo = Ret;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPOVERLAPPEDSetup",CaseNo,"Unknown Case");
        Ret = (LPOVERLAPPED) NULL;
        break;
    }
    
    return(Ret);
}


void LPOVERLAPPEDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
    case LPOVERLAPPED_VALID:
        if ( *SCInfo != NULL )
            free(*SCInfo);
        break;
    default:
        break;
    }
}


VOID CompletionRoutine(DWORD dwErrCode, DWORD dwNbytes, LPOVERLAPPED lpOver)
{
    dwErrCode; dwNbytes; lpOver;
}

LPOVERLAPPED_COMPLETION_ROUTINE LPOVERLAPPED_COMPLETION_ROUTINESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    LPOVERLAPPED_COMPLETION_ROUTINE Ret;
    
    UNREFERENCED_PARAMETER( SCInfo );

    switch(CaseNo) {
        
    case LPOVERLAPPED_COMPLETION_ROUTINE_VALID:
        Ret = CompletionRoutine;
        break;
        
    case LPOVERLAPPED_COMPLETION_ROUTINE_NULL:
        Ret = NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPOVERLAPPED_COMPLETION_ROUTINESetup",CaseNo,
            "Unknown Case");
        Ret = (LPOVERLAPPED_COMPLETION_ROUTINE ) NULL;
        break;
    }
    
    return(Ret);
}



void LPOVERLAPPED_COMPLETION_ROUTINECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\r_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    r_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'R'. It also contains setup and cleanup
    funtions beginning with 'LPR'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <r_cases.bmh>
#include <wtypes.h>
#include "limits.h"


#define SetRect( rc, l, t, r, b ) \
            (rc)->left   = l; \
            (rc)->top    = t; \
            (rc)->right  = r; \
            (rc)->bottom = b


LPRECT LPRECTSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPRECT		Ret = NULL;
    HANDLE		hMem;
    
    switch(CaseNo)
    {
    case LPRECT_NULL:
        //Ret = (LPRECT) NULL; 
        //don't need to do anything
        break;
        
    case LPRECT_RANDOM:
        //don't use this one for regressions
        Ret = (LPRECT)rand();
        break;
        
    case LPRECT_MINUS_ONE:
        Ret = (LPRECT)-1;
        break;
        
    default:
        if ((hMem = LocalAlloc( LPTR, sizeof(RECT))) != NULL)
        {
            if ((Ret = (LPRECT)LocalLock( hMem )) != NULL)
            {
                switch(CaseNo)
                {
                case LPRECT_0_0_100_100:
                    SetRect( Ret, 0, 0, 100, 100 ) ;
                    break;
                    
                case LPRECT_100_50_150_100:
                    SetRect( Ret, 100, 50, 150, 100 ) ;
                    break;
                    
                case LPRECT_20_20_40_40:
                    SetRect( Ret, 20, 20, 40, 40 ) ;
                    break;
                    
                case LPRECT_MAX:
                    SetRect( Ret,INT_MIN, INT_MIN, INT_MAX, INT_MAX ) ;
                    break;
                    
                case LPRECT_MAXRGN:
                    SetRect( Ret,0xf8000000,0xf8000000,0x08000000, 0x08000000);
                    break;
                    
                case LPRECT_NOT_WELL_ORDERED:
                    SetRect( Ret, 100, 0, 0, 100 ) ;
                    break;
                    
                case LPRECT_EMPTY:
                    SetRect( Ret, 200, 200, 200, 200 ) ;
                    break;
                    
                default:
                    ErrorPrint(hConOut,hLog,"LPRECTSetup",CaseNo,"Unknown Case");
                    break;
                }
            } else {
                ErrorPrint(hConOut,hLog,"LPRECTSetup",CaseNo,"LocalLock Failed");
                LocalFree(hMem);
                return NULL;
            }
        } else {
            ErrorPrint(hConOut,hLog,"LPRECTSetup",CaseNo,"LocalAlloc Failed");
            return NULL;
        }
        break;
    }
    
    //assign the return val to the storage pointer
    *SCInfo = (LPVOID)Ret;
    
    return(Ret);
}


void LPRECTCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo)
    {
    case LPRECT_NULL:
    case LPRECT_RANDOM:
    case LPRECT_MINUS_ONE:
        break ;
        
    case LPRECT_0_0_100_100:
    case LPRECT_100_50_150_100:
    case LPRECT_20_20_40_40:
    case LPRECT_NOT_WELL_ORDERED:
    case LPRECT_EMPTY:
    case LPRECT_MAX:
    case LPRECT_MAXRGN:
        if (*SCInfo!=NULL)
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPRECTCleanup",CaseNo,"LocalFree failed!");
            break ;
            
    default:
        ErrorPrint(hConOut,hLog,"LPRECTCleanup",CaseNo,"Unknown Case");
        break;
    }
}


PVOID LPRGBQUADSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
#if 0
    LPRGBQUAD Ret, lpPtr;
    int       i;
    
    switch(CaseNo) {
    case LPRGBQUAD_NULL:
        Ret = (LPRGBQUAD)NULL;
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPRGBQUAD_RANDOM:
        Ret = (LPRGBQUAD)rand();
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPRGBQUAD_MINUS_ONE:
        Ret = (LPRGBQUAD)-1;
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPRGBQUAD_VALID:
        Ret = (LPRGBQUAD)GlobalAlloc(GPTR, sizeof(RGBQUAD));
        if (!Ret)
            ErrorPrint(hConOut,hLog,"LPRGBQUADSetup",CaseNo,"Alloc failed!");
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPRGBQUAD_SIMPLE:  // this actually generates a complete rgndata structure
        Ret = (LPRGBQUAD)GlobalAlloc(GPTR, 300 * sizeof(RGBQUAD));
        if (!Ret){
            ErrorPrint(hConOut,hLog,"LPRGBQUADSetup",CaseNo,"Alloc failed!");
        } else {
            lpPtr = Ret;
            for (i=0; i<4; i++) {
                lpPtr->rgbBlue   = 0xA;
                lpPtr->rgbRed    = 0x2;
                lpPtr->rgbGreen  = 0xC;
                lpPtr++;
            }
        }
        *SCInfo = (LPVOID)Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPRGBQUADSetup",CaseNo,"Unknown Case");
        Ret = (LPRGBQUAD ) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}



void LPRGBQUADCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    switch(CaseNo) {
    case LPRGBQUAD_SIMPLE:
    case LPRGBQUAD_VALID:
        if (*SCInfo!=NULL)
            if (GlobalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPRGBQUADCleanup",CaseNo,"GlobalFree failed!");
            break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\memmgt.c ===
/****************************************************************************
MODULE: MemMgt.c
AUTHOR: JohnMil
DATE:	1-19-91

  Copyright (c) 1992 Microsoft Corporation
  
    This module contains functions to make and destroy parameters for BadMan.
    Instead of repeating similar code in the case statements in SetCln.c,
    we hide the nasty details here.
****************************************************************************/

#include <setcln.h>
#include <d_cases.bmh>
#include <h_cases.bmh>
#include <p_cases.bmh>
#include <s_cases.bmh>
#include <v_cases.bmh>
#include <memmgt.h>



/*****************************************************************************
LMemHandleCreate will make a Local Memory handle for HANDLESetup
*****************************************************************************/

HANDLE LMemHandleCreate(HANDLE hLog, HANDLE hConOut, int CaseNo)
{
    HANDLE hRet,hMem;
    LPSTR lpMem;
    DWORD dwFlags = LPTR;
    
    // First, establish flags.
    switch (CaseNo) {
        
    case HANDLE_UNLOCKED_LMEM_BLOCK:
    case HANDLE_LOCKED_LMEM_BLOCK:
        //case HANDLE_DISCARDED_LMEM_BLOCK:
    case HANDLE_NONDISCARDABLE_LMEM_BLOCK:
    case HANDLE_FREED_LMEM_BLOCK:
        // REVIEW: LMEM_MOVEABLE, LMEM_DISCARDABLE is not implemented in xbox
        //dwFlags = LMEM_MOVEABLE | LMEM_DISCARDABLE;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LMemHandleCreate",CaseNo,"Unknown Case");
    }
    
    // Next, allocate the basic block;
    hRet = LocalAlloc(dwFlags,0x400);
    if (hRet == NULL) {
        ErrorPrint(hConOut,hLog,"LMemHandleCreate",CaseNo,"Unable to allocate Local Block");
    }
    // Perform additional actions if required
    
    switch (CaseNo) {
        
        //  case HANDLE_DISCARDED_LMEM_BLOCK:
        //    hMem = LocalDiscard(hRet);
        //    if (hMem == NULL)
        //	      ErrorPrint(hConOut,hLog,"LMemHandleCreate",CaseNo,"Unable to discard Local Block");
        //    break;
        
    case HANDLE_LOCKED_LMEM_BLOCK:
        lpMem = LocalLock(hRet);
        if (lpMem == NULL) {
            ErrorPrint(hConOut,hLog,"LMemHandleCreate",CaseNo,"Unable to Lock Local Block");
        }
        break;
        
    case HANDLE_FREED_LMEM_BLOCK:
        hMem = LocalFree(hRet);
        if (hMem != NULL) {
            ErrorPrint(hConOut,hLog,"LMemHandleCreate",CaseNo,"Unable to Free Local Block");
        }
        break;
        
    default:
        break;
    }
    
    return hRet;
}




/*****************************************************************************
GMemHandleCreate will make a Global Memory handle for HANDLESetup
*****************************************************************************/

HANDLE GMemHandleCreate(HANDLE hLog, HANDLE hConOut, int CaseNo)
{
    HANDLE hRet,hMem;
    LPSTR lpMem;
    DWORD dwFlags = GPTR;
    
    // First, establish flags.
    switch (CaseNo) {
        
    case HANDLE_UNLOCKED_GMEM_BLOCK:
    case HANDLE_LOCKED_GMEM_BLOCK:
    case HANDLE_DISCARDED_GMEM_BLOCK:
    case HANDLE_FREED_GMEM_BLOCK:
        // REVIEW: GMEM_MOVEABLE is not implemented in xbox
        // dwFlags = GMEM_MOVEABLE | GMEM_DISCARDABLE;
        break;
        
    case HANDLE_NONDISCARDABLE_GMEM_BLOCK:
        // REVIEW: GMEM_MOVEABLE is not implemented in xbox
        // dwFlags = GMEM_MOVEABLE;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"GMemHandleCreate",CaseNo,"Unknown Case");
    }
    
    // Next, allocate the basic block;
    hRet = GlobalAlloc( dwFlags, 0x400 );
    
    if ( hRet == NULL ) {
        ErrorPrint( hConOut, hLog, "GMemHandleCreate", CaseNo, "Unable to allocate Global Block" );
    }
    
    // Perform additional actions if required
    switch (CaseNo) {
        
    case HANDLE_DISCARDED_GMEM_BLOCK:
        // REVIEW: GMEM_MOVEABLE and GMEM_DISCARDABLE is not implemented in xbox
        //hMem = GlobalDiscard( hRet );
        //if ( hMem == NULL ) {
        //ErrorPrint( hConOut, hLog, "GMemHandleCreate", CaseNo, "Unable to discard Global Block" );
        //}
        break;
        
    case HANDLE_LOCKED_GMEM_BLOCK:
        lpMem = GlobalLock( hRet );
        if ( lpMem == NULL ) {
            ErrorPrint( hConOut, hLog, "GMemHandleCreate", CaseNo, "Unable to Lock Global Block" );
        }
        break;
        
    case HANDLE_FREED_GMEM_BLOCK:
        hMem = GlobalFree( hRet );
        if ( hMem != NULL ) {
            ErrorPrint( hConOut, hLog, "GMemHandleCreate", CaseNo, "Unable to Free Global Block" );
        }
        break;
        
    default:
        break;
    }
    
    return hRet;
}


/*****************************************************************************
HeapHandleCreate makes handles to Heaps.
*****************************************************************************/

HANDLE HeapHandleCreate(HANDLE hLog,HANDLE hConOut,int CaseNo)
{
    HANDLE hRet;
    DWORD dwInitSize;
    DWORD dwGrowSize;
    
    // Grow size and initial size are 32k by default.
    dwInitSize = dwGrowSize = 32*1024;
    if (CaseNo == HANDLE_GROWABLE_HEAP) {
        dwGrowSize = 0;
    }
    // Allocate the heap
    hRet = HeapCreate(HEAP_NO_SERIALIZE,dwInitSize,dwGrowSize);
    if (hRet == NULL) {
        ErrorPrint(hConOut,hLog,"HeapHandleCreate",CaseNo,"Unable to create heap");
        return(hRet);
    }
    // Fill the heap if necessary
    if (CaseNo == HANDLE_UNGROWABLE_FILLED_HEAP) {
        while(HeapAlloc(hRet, 0, 1) != NULL) {
            ; // allocate all space in heap
        }
    }
    
    if (CaseNo == HANDLE_DESTROYED_32K_HEAP) {
        if( !HeapDestroy(hRet) ) {
            ErrorPrint( hConOut, hLog, "HeapHandleCreate", CaseNo, "Unable to destroy heap ()" );
        }
    }
    
    return(hRet);
}



/*****************************************************************************
LMemPointerCreate makes an LPSTR for memory management blocks for
LPSTRSetup.
*****************************************************************************/

LPSTR LMemPointerCreate(HANDLE hLog, HANDLE hConOut,int CaseNo, LPVOID *SCInfo)
{
    LPSTR lpRet;
    HANDLE hMem = NULL;
    
    // First, we need to allocate a block and
    // get a pointer to its base.
    switch(CaseNo) {
    case LPSTR_BASE_VALID_LMEM_BLOCK:
    case LPSTR_INSIDE_VALID_LMEM_BLOCK:
    case LPSTR_INSIDE_FREED_LMEM_BLOCK:
        //  case LPSTR_INSIDE_DISCARDED_LMEM_BLOCK:
        hMem = LocalAlloc(LMEM_FIXED,0x400);
        *SCInfo = (LPVOID) hMem;
        lpRet = LocalLock(hMem);
        if (lpRet == NULL) {
            ErrorPrint(hConOut,hLog,"LMemPointerCreate",CaseNo,"Unable to create memory block");
        }
        else {
            if (CaseNo != LPSTR_BASE_VALID_LMEM_BLOCK) {
                lpRet += 0x100;
            }
        }
        break;
    default:
        ErrorPrint(hConOut,hLog,"LMemPointerCreate",CaseNo,"Unknown Case");
        lpRet = NULL;
        break;
    }
    // Now, free the block or whatever.
    switch(CaseNo) {
    case LPSTR_INSIDE_FREED_LMEM_BLOCK:
        hMem = LocalFree(hMem);
        if (hMem != NULL) {
            ErrorPrint(hConOut,hLog,"LMemPointerCreate",CaseNo,"Unable to Free memory block");
        };
        break;
        //  case LPSTR_INSIDE_DISCARDED_LMEM_BLOCK:
        //    hMem = LocalDiscard(hMem);
        //    if (hMem == NULL)
        //		  ErrorPrint(hConOut,hLog,"LMemPointerCreate",CaseNo,"Unable to Discard memory block");
        //    break;
    default:
        break;
    }
    
    return(lpRet);
}




/*****************************************************************************
GMemPointerCreate makes an LPSTR for memory management blocks for
LPSTRSetup.
*****************************************************************************/

LPSTR GMemPointerCreate(HANDLE hLog, HANDLE hConOut,int CaseNo, LPVOID *SCInfo)
{
    LPSTR lpRet;
    HANDLE hMem = NULL;
    
    // First, we need to allocate a block and
    // get a pointer to its base.
    switch(CaseNo) {
    case LPSTR_BASE_VALID_GMEM_BLOCK:
    case LPSTR_INSIDE_VALID_GMEM_BLOCK:
    case LPSTR_INSIDE_FREED_GMEM_BLOCK:
    case LPSTR_INSIDE_DISCARDED_GMEM_BLOCK:
        hMem = GlobalAlloc(GMEM_FIXED,0x400);
        *SCInfo = (LPVOID) hMem;
        lpRet = GlobalLock(hMem);
        if (lpRet == NULL) {
            ErrorPrint(hConOut,hLog,"GMemPointerCreate",CaseNo,"Unable to create memory block");
        }
        else {
            if (CaseNo != LPSTR_BASE_VALID_GMEM_BLOCK) {
                lpRet += 0x100;
            }
        }
        break;
    default:
        ErrorPrint(hConOut,hLog,"GMemPointerCreate",CaseNo,"Unknown Case");
        lpRet = NULL;
        break;
    }
    // Now, free the block or whatever.
    switch(CaseNo) {
    case LPSTR_INSIDE_FREED_GMEM_BLOCK:
        GlobalUnlock(hMem);
        hMem = GlobalFree(hMem);
        if (hMem != NULL) {
            ErrorPrint(hConOut,hLog,"GMemPointerCreate",CaseNo,"Unable to Free memory block");
        };
        break;
    case LPSTR_INSIDE_DISCARDED_GMEM_BLOCK:
        GlobalUnlock(hMem);
        //      hMem = GlobalDiscard(hMem);
        if (hMem == NULL) {
            ErrorPrint(hConOut,hLog,"GMemPointerCreate",CaseNo,"Unable to Discard memory block");
        };
        break;
    default:
        break;
    }
    
    return(lpRet);
}


/***************************************************************************
HeapPointerCreate will make Pointers to memory locations inside of a heap
***************************************************************************/

LPSTR HeapPointerCreate(HANDLE hLog, HANDLE hConOut,int CaseNo, LPVOID *SCInfo)
{
    LPSTR lpRet;
    HANDLE hHeap;
    
    // Allocate the Heap
    
    hHeap = HeapHandleCreate(hLog,hConOut,HANDLE_GROWABLE_HEAP);
    *SCInfo = (LPVOID) hHeap;
    
    // Set up the pointer.
    
    lpRet = HeapAlloc(hHeap, 0, 100);
    if (lpRet == NULL) {
        ErrorPrint(hConOut,hLog,"HeapPointerCreate",CaseNo,
            "Unable to Allocate from Heap");
    }
    
    switch(CaseNo) {
    case LPSTR_DESTROYED_HEAP_BLOCK:
        if(!HeapDestroy(hHeap)) {
            ErrorPrint(hConOut,hLog,"HeapPointerCreate",CaseNo,
                "Unable to destroy heap");
        }
        break;
    case LPSTR_FREED_HEAP_BLOCK:
        if (! HeapFree(hHeap, 0, lpRet)) {
            ErrorPrint(hConOut,hLog,"HeapPointerCreate",CaseNo,
                "Unable to free memory block");
        }
        break;
    }
    
    return(lpRet);
}



/*****************************************************************************
VirtAddrCreate returns the address to a certain kind of virtual memory.
*****************************************************************************/

LPVOID VirtAddrCreate(HANDLE hLog, HANDLE hConOut,int CaseNo, LPVOID *SCInfo)
{
    LPVOID lpRet = NULL;
    DWORD dwOffset,dwAllocType,dwProtect;
    
    dwOffset = 0;
    
    if (CaseNo == LPVOID_RES_UNCOMMIT_V_ADDR) {
        dwAllocType = MEM_RESERVE;
        dwProtect = PAGE_NOACCESS;
    }
    else {
        dwAllocType = MEM_RESERVE | MEM_COMMIT;
        dwProtect = PAGE_READWRITE;
    }
    
    switch(CaseNo) {
    case LPVOID_NONALIGNED_V_ADDR:
    case LPVOID_LOCKED_V_ADDR:
    case LPVOID_UNLOCKED_V_ADDR:
        dwOffset = 3100;
    case LPVOID_RES_UNCOMMIT_V_ADDR:
    case LPVOID_ALIGNED_V_ADDR:
    case LPVOID_REGION_BEG_V_ADDR:
        *SCInfo = VirtualAlloc(NULL,64*1024,dwAllocType,dwProtect);
        lpRet = (LPVOID) ((DWORD) *SCInfo + dwOffset);
    }
    
    if (*SCInfo == NULL) {
        ErrorPrint(hConOut,hLog,"VirtAddrCreate",CaseNo,
            "Unable to allocate virtual memory");
    }
    
    return(lpRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\n_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    n_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'N'. It also contains setup and cleanup
    funtions beginning with 'LPN'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <n_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    setcln.c

Abstract:

    This file contains miscellaneous files for the use of the setup and
    clean up functions.

Author:

    John Miller (johnmil) 10-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and made the code more readable

--*/


#include <setcln.h>
#include <stdarg.h>
#include "xlog.h"


int
SCPrintf(
    HANDLE hConOut,
    LPSTR Format,
    ...
    )

/*++

Routine Description:

    SCPrintf is a substitute for printf which will print to the debugger

Arguments:

Return Value:

--*/

{
    char    buff[512];
    va_list vaList;
    DWORD   i;

    UNREFERENCED_PARAMETER( hConOut );

    va_start( vaList, Format );
    i = vsprintf( buff, Format, vaList );
    va_end( vaList );
    OutputDebugStringA( buff );
    return i;
}


void
ErrorPrint(
    HANDLE hConOut,
    HANDLE hLog,
    LPSTR Module,
    int CaseNo,
    LPSTR Desc
    )

/*++

Routine Description:

    ErrorPrint is a standard format error printer which will print to the
    debugger and to the log file, if appropriate.

Arguments:

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( hConOut );
    
    DbgPrint( "SETCLN: %s [Case %d] -- %s\n", Module, CaseNo, Desc );
    
    if ( INVALID_HANDLE_VALUE != hLog ) {
        xLog( hLog, XLL_WARN, "ERROR: %s [Case %d] -- %s", Module, CaseNo, Desc );
    }
}

/***************************************************************************

    InfThread( LPVOID lpv)

    Code to implement a "responsible" infinite loop thread to be used
    with tasking variations.

    Added: 03-21-92 RickTu

 ***************************************************************************/


VOID
InfThread(
    VOID
    )
{
    for (;;) {
        SleepEx( 1000, TRUE );
    }
}


/****************************************************************************

   DLLEntry( HANDLE hInst, DWORD dwReason, LPVOID lpv )


   Get an Instance handle for use in MakeProcInstance calls (FARPROCSetup)

   MarkRi Mar 23, 1992

****************************************************************************/

HANDLE hInstance ;


BOOL WINAPI DllMain( HANDLE hInst, DWORD dwReason, LPVOID lpv )
{
    if ( dwReason == DLL_PROCESS_ATTACH ) {
        DisableThreadLibraryCalls( hInst );
    }

    return TRUE ;
    lpv; // -W3 warning elimination
}


/*DebugPrint(LPSTR a, ...)
{
    char    c[256];
    va_list vaList;

    va_start(vaList, a);
    vsprintf(c, a, vaList);
    va_end(vaList);

    OutputDebugStringA(c);
}
*/

/*
 * GetNativeBuffer
 *
 * Part of the support for invalid pointer testing.  Allocate a buffer of at
 * least NumberOfBytes bytes in size, and make sure that the tail end of the
 * buffer is invalid memory.  This depends on a side effect of
 * NtAllocateVirtualMemory:  Allocations are 64k aligned, but only enough
 * pages in that 64k region are mapped to satisfy the memory request.  This
 * routine is thus not likely to work if the request size is between 64k, and
 * 64-4k since 4k is the smallest mappable unit.  Beware.
 *
 * Returns a pointer to the first byte in the region offset such that
 * pointer+NumberOfBytes == invalid memory.
 */

DWORD           PageSize;

PVOID
GetNativeBuffer(
    DWORD           NumberOfBytes
)
{
    static BOOL         Init = FALSE;

    DWORD           RegionSize;
    PCHAR           PoolAddress = NULL;

    if (!Init) {
        //SYSTEM_INFO       SysInfo;

        Init = TRUE;

        //GetSystemInfo(&SysInfo);

        PageSize = 0x1000; //SysInfo.dwPageSize;
    }


// BUGBUG:  May need it a multiple of 8 on 64 bit aligned platforms.

    /*
     * We need to return a DWORD aligned address, round "NumberOfBytes" up
     * to a multiple of 4.
     */

#define ALIGNMENT   (sizeof (DWORD))

    NumberOfBytes += (ALIGNMENT - 1);
    NumberOfBytes &= ~(ALIGNMENT - 1);

    RegionSize = NumberOfBytes;

    PoolAddress = VirtualAlloc(NULL,
        RegionSize,
        MEM_COMMIT,
        PAGE_READWRITE);

    if (!PoolAddress) {
        printf("VirtualAlloc failed, LastError = %d\n",
            GetLastError());

        return NULL;
    } else {
        /*
         * RegionSize is rounded to the next page boundary
         */

        RegionSize += PageSize - 1;
        RegionSize &= ~(PageSize - 1);

        /*
         * This pretty much guarantees that we'll trap if we try to
         * write more than NumberOfBytes + 3 bytes.
         */

//      printf("0x%lx = GetNativeBuffer(0x%lx)\n",
//          PoolAddress,
//          NumberOfBytes);

//printf("(Pa = 0x%lx, Rs = 0x%lx, Nb = 0x$lx\n",
//  PoolAddress, RegionSize, NumberOfBytes);

        return PoolAddress + (RegionSize - NumberOfBytes);
    }
}


/* FreeNativeBuffer
 *
 * Free the buffer allocated by GetNativeBuffer.  You have to pass me the
 * pointer I passed you (Pointer), and the size of allocation you made
 * (NumberOfBytes) because I'm too lazy to store it for you, and besides if
 * you pass it to me again, you can't accidently trash the place where *I*
 * store it.  (Though you are free to trash the place *you* store it...
 */

VOID
FreeNativeBuffer(
    PVOID           Pointer,
    DWORD           NumberOfBytes
)
{
    UNREFERENCED_PARAMETER( NumberOfBytes );

    /*
     * Assuming that GetNativeBuffer will allocate the minimum number of
     * pages to satisfy a request, it is sufficient to simply round down
     * to the nearest page.  If the assumption doesn't hold, there's no
     * way to determine what will bring us to our original address because
     * the region-size is not returned by w32 (though it is from the
     * kernel).
     */

    Pointer = (PVOID)((ULONG_PTR)Pointer & ~(PageSize - 1));

    /*
     * and round "NumberOfBytes" up to a multiple of 4...
     */

//  printf("FreeNativeBuffer(0x%lx, 0x%lx)\n",
//      Pointer,
//      NumberOfBytes);

    (VOID)VirtualFree(Pointer,
        0,
        MEM_RELEASE);
}


BOOL
MakeBadPointer(
    PVOID           *Pointer,
    SE_CLEANUP_INFO **CleanupInfo,
    POINTER_TYPE    PointerType,
    DWORD           PointerSize,
    HANDLE          hConOut,
    HANDLE          hLog
)
{
    BOOL  Result = FALSE;

    UNREFERENCED_PARAMETER( hConOut );
    UNREFERENCED_PARAMETER( hLog );

    switch (PointerType) {
    case NULL_POINTER:
        *Pointer = NULL;

        // should we do this or link into the list as necessary here?
        *CleanupInfo = NULL;

        Result = TRUE;

        break;

    case INVALID_POINTER:
        /*
         * hard-code for now, should fix someday...
         */

        *Pointer = (PVOID)0x80060004;

        // should we do this or link into the list as necessary here?
        *CleanupInfo = NULL;

        Result = TRUE;

        break;

    case VALIDRANGE_POINTER:
        *Pointer = GetNativeBuffer(PointerSize);

        Result = *Pointer ? TRUE : FALSE;

        *CleanupInfo = (SE_CLEANUP_INFO *)GlobalAlloc(GPTR,
            sizeof(SE_CLEANUP_INFO));

        if (!*CleanupInfo) {
            Result = FALSE;

            FreeNativeBuffer(*Pointer, PointerSize);

//          DebugPrint("MakeBadPointer, Type = 0x%x, "
//              "GlobalAlloc for cleanup failed VALIDRANGE\n",
//              PointerType);
        } else {
            if ((DWORD)(*CleanupInfo) & 3) {
//              DebugPrint("GlobalAlloc not aligned!!! VALID\n");
            }

            (*CleanupInfo) -> se_Next = NULL;
            (*CleanupInfo) -> se_AllocType = PointerType;
            (*CleanupInfo) -> se_AllocSize = PointerSize;
            (*CleanupInfo) -> se_Address = *Pointer;
        }

        break;

    case MALALIGNED_POINTER_1:
        *Pointer = GetNativeBuffer((DWORD)PointerSize + sizeof (DWORD));

        Result = *Pointer ? TRUE : FALSE;

        /*
         * Force the returned pointer to be aligned on odd-byte.
         */

        *Pointer = (PVOID *)((DWORD)*Pointer | 1);

        *CleanupInfo = (SE_CLEANUP_INFO *)GlobalAlloc(GPTR,
            sizeof(SE_CLEANUP_INFO));

        if (!*CleanupInfo) {
            Result =FALSE;

            FreeNativeBuffer(*Pointer, PointerSize + 1);

//          DebugPrint("MakeBadPointer GlobalAlloc for cleanup "
//              "failed MALALIGNED_1");
        } else {
            if ((DWORD)(*CleanupInfo) & 3) {
//              DebugPrint("GlobalAlloc not aligned!!! MAL_1\n");
            }

            (*CleanupInfo) -> se_Next = NULL;
            (*CleanupInfo) -> se_AllocType = PointerType;
            (*CleanupInfo) -> se_AllocSize = PointerSize + 1;
            (*CleanupInfo) -> se_Address = *Pointer;
        }

        break;

    case CLEANUP:
        while (*CleanupInfo) {
            FreeNativeBuffer((*CleanupInfo) -> se_Address,
                (*CleanupInfo) -> se_AllocSize);

            (*CleanupInfo) = (*CleanupInfo) -> se_Next;
        }

        break;
    default:
//      DebugPrint("MakeBadPointer:  Bogus case = 0x%lx\n",
//          PointerType);
        ;
    }

    return Result;
}


#ifdef  TIMF_DEBUG
/*
 * 'ware recursive soup if malloc/free changes to Global* calls...
 * MakeBadPointer uses them...
 */

DWORD           MallocCount = 0;
SE_CLEANUP_INFO     *MallocCleanupInfo = NULL;

void  * __cdecl
malloc(
    size_t      size
)
{
    DWORD           *Result = NULL;

    size |= 3;
    ++size;

    /*
     * size is now DWORD aligned, add a DWORD for a place to store the
     * size, and alloc it.
     */

    size += sizeof(DWORD);

    Result = (DWORD *)GetNativeBuffer(size);

    /*
     * store the size and return a pointer to the next DWORD.
     */

    *Result = size;

    return (void *)(&(Result[1]));
}


void    __cdecl
free(
    void            *a
)
{
    DWORD           addr = (DWORD)a,
                Size;

    /*
     * pick out the size of the allocation
     */

    Size = *(DWORD *)(addr - sizeof (DWORD));

    /*
     * round down to the nearest page, then free the region.
     */

    FreeNativeBuffer((PVOID)addr,
        Size);
}

#endif  /* TIMF_DEBUG */


VOID
NothingToCleanup(
    int CaseNo,
    LPVOID *SCInfo,
    HANDLE hLog,
    HANDLE hConOut
    )
{
    UNREFERENCED_PARAMETER( CaseNo );
    UNREFERENCED_PARAMETER( SCInfo );
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\m_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    m_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'M'. It also contains setup and cleanup
    funtions beginning with 'LPM'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <m_cases.bmh>
#include <memmgt.h>


LPMEMORYSTATUS LPMEMORYSTATUSSetup(int CaseNo, LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    HANDLE hMem;
    LPMEMORYSTATUS lpmsMem;
    DWORD dwSize;
    
    
    dwSize = sizeof(MEMORYSTATUS);
    
    switch(CaseNo) {
    case LPMEMORYSTATUS_NULL:
        lpmsMem = (LPMEMORYSTATUS) NULL;
        break;
    case LPMEMORYSTATUS_BUFFER_TOO_SMALL:
        dwSize = sizeof(DWORD);
    case LPMEMORYSTATUS_GOOD:
        hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE, dwSize);
        *SCInfo = (LPVOID) hMem;
        lpmsMem = (LPMEMORYSTATUS) GlobalLock(hMem);
        if (lpmsMem == NULL) {
            ErrorPrint(hConOut,hLog,"LPMEMORYSTATUSSetup",CaseNo,"Unable to allocate buffer");
        }
        lpmsMem->dwLength = sizeof(MEMORYSTATUS);
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPMEMORYSTATUSSetup",CaseNo,"Unknown Case");
        lpmsMem = NULL;
        break;
    }
    
    return(lpmsMem);
}


void LPMEMORYSTATUSCleanup(int CaseNo, LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UNREFERENCED_PARAMETER( hLog );
    UNREFERENCED_PARAMETER( hConOut );

    switch(CaseNo) {
    case LPMEMORYSTATUS_BUFFER_TOO_SMALL:
    case LPMEMORYSTATUS_GOOD:
        GlobalFree((HANDLE) *SCInfo);
        break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\p_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    p_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'P'. It also contains setup and cleanup
    funtions beginning with 'LPP'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <a_Cases.bmh>
#include <p_Cases.bmh>
#include "limits.h"


LPPOINT LPPOINTSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPPOINT Ret, lpptTemp;
    int i;
    
    switch(CaseNo) {
    case LPPOINT_13_POINTS:
        Ret = (LPPOINT)GlobalAlloc(GPTR, 13 * sizeof(POINT));
        if (Ret != 0) {
            lpptTemp = Ret;
            for (i = 0; i < 13; i++){
                lpptTemp->x = (int)rand();
                lpptTemp->y = (int)rand();
                lpptTemp++;
            }
        } else {
            ErrorPrint(hConOut,hLog,"LPPPOINTSetup",CaseNo,"GlobalAlloc failed!" );
        }
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPPOINT_NULL:
        Ret = (LPPOINT)NULL;
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPPOINT_RANDOM:
        Ret = (LPPOINT)rand();
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPPOINT_MINUS_ONE:
        Ret = (LPPOINT)-1;
        *SCInfo = (LPVOID)Ret;
        break;
        
    case LPPOINT_VALID:
        Ret = (LPPOINT)GlobalAlloc(GPTR, sizeof(POINT));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPPPOINTSetup",CaseNo,"GlobalAlloc failed!" );
        *SCInfo = (LPVOID)Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPPOINTSetup",CaseNo,"Unknown Case");
        Ret = (LPPOINT) NULL;
        break;
    }
    
    return(Ret);
    
}


void LPPOINTCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPPOINT_VALID:
    case LPPOINT_13_POINTS:
        if (SCInfo != NULL) {
            if (GlobalFree ((HANDLE)*SCInfo) != NULL) {
                ErrorPrint(hConOut,hLog,"LPPOINTCleanup",CaseNo,"GlobalFree() failed!");
            }
        }
        break;
        
    default:
        break;
    }
}


/******************************************************************************
L     PPPP  PPPP  RRRR   OOO   CCC  EEEEE  SSSS  SSSS       IIIII N   N FFFFF
L     P   P P   P R   R O   O C   C E     S     S             I   NN  N F
L     PPPP  PPPP  RRRR  O   O C     EEEE   SSS   SSS          I   N N N FFFF
L     P     P     R  R  O   O C   C E         S     S         I   N  NN F
LLLLL P     P     R   R  OOO   CCC  EEEEE SSSS  SSSS  _____ IIIII N   N F
******************************************************************************/

PVOID LPPROCESS_INFORMATIONSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPPROCESS_INFORMATION lpRet;
    
    switch(CaseNo) {
        
    case LPPROCESS_INFORMATION_VALID_STRUCTURE:
        lpRet = (LPPROCESS_INFORMATION)LocalAlloc( LPTR, sizeof(PROCESS_INFORMATION) );
        if (lpRet==NULL)
            ErrorPrint(hConOut,hLog,"ProcInfoSetup",CaseNo,"LocalAlloc for ProcInfo strucutre failed" );
        *SCInfo = (LPVOID)lpRet;
        break;
        
    case LPPROCESS_INFORMATION_NULL:
        lpRet = (LPPROCESS_INFORMATION) NULL;
        break;
        
    case LPPROCESS_INFORMATION_TOO_SMALL:
        lpRet = (LPPROCESS_INFORMATION)LocalAlloc( LPTR, (sizeof(PROCESS_INFORMATION)-4) );
        if (lpRet==NULL)
            ErrorPrint(hConOut,hLog,"ProcInfoSetup",CaseNo,"LocalAlloc for too small ProcInfo structure failed" );
        *SCInfo = (LPVOID)lpRet;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"ProcInfoSetup",CaseNo,"Unknown Case");
        lpRet = (LPPROCESS_INFORMATION) NULL;
        break;
    }
    
    return(lpRet);
#endif
    return 0;
}


void LPPROCESS_INFORMATIONCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0    
    LPPROCESS_INFORMATION lppi;
    
    switch(CaseNo) {
    case LPPROCESS_INFORMATION_VALID_STRUCTURE:
        lppi = (LPPROCESS_INFORMATION)(*SCInfo);
        if (lppi!=NULL) {
            
            if (lppi->hThread!=NULL)
                if (!CloseHandle( lppi->hThread ))
                    ErrorPrint(hConOut,hLog,"ProcInfoCleanup",CaseNo,"Unable to close thread handle");
                
                if (lppi->hProcess!=NULL)
                    if (lppi->hProcess!=NULL)
                        if (!CloseHandle( lppi->hProcess ))
                            ErrorPrint(hConOut,hLog,"ProcInfoCleanup",CaseNo,"Unable to close process handle");
                        
                        if (LocalFree( (HANDLE)lppi )!=NULL)
                            ErrorPrint(hConOut,hLog,"ProcInfoCleanup",CaseNo,"LocalFree failed");
                        
        }
        break;
        
    case LPPROCESS_INFORMATION_TOO_SMALL:
        if (SCInfo!=NULL){
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"ProcInfoCleanup",CaseNo,"LocalFree Failed!");
        }
        break;
        
    default:
        break;
    }
#endif
}




/******************************
PPPP  BBBB  Y   Y TTTTT EEEEE
P   P B   B  Y Y    T   E
PPPP  BBBB    Y     T   EEEE
P     B   B   Y     T   E
P     BBBB    Y     T   EEEEE
******************************/

PBYTE PBYTESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PBYTE Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PBYTESetup",CaseNo,"Unknown Case");
        Ret = (PBYTE) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
}


void PBYTECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/************************************************************
PPPP   CCC  H   H   A   RRRR        IIIII N   N FFFFF  OOO
P   P C   C H   H  A A  R   R         I   NN  N F     O   O
PPPP  C     HHHHH AAAAA RRRR          I   N N N FFFF  O   O
P     C   C H   H A   A R  R          I   N  NN F     O   O
P      CCC  H   H A   A R   R _____ IIIII N   N F      OOO
************************************************************/

PVOID PCHAR_INFOSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    PCHAR_INFO Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PCHAR_INFOSetup",CaseNo,"Unknown Case");
        Ret = (PCHAR_INFO) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
#endif
    return 0;
}


void PCHAR_INFOCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/******************************************************************************
PPPP   CCC   OOO  N   N  SSSS  OOO  L     EEEEE        CCC  U   U RRRR   SSSS
P   P C   C O   O NN  N S     O   O L     E           C   C U   U R   R S
PPPP  C     O   O N N N  SSS  O   O L     EEEE        C     U   U RRRR   SSS
P     C   C O   O N  NN     S O   O L     E           C   C U   U R  R      S
P      CCC   OOO  N   N SSSS   OOO  LLLLL EEEEE _____  CCC   UUU  R   R SSSS
******************************************************************************/

PVOID PCONSOLE_CURSOR_INFOSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    PCONSOLE_CURSOR_INFO Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PCONSOLE_CURSOR_INFOSetup",CaseNo,"Unknown Case");
        Ret = (PCONSOLE_CURSOR_INFO) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
#endif
    return 0;
}


void PCONSOLE_CURSOR_INFOCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}




/******************************************************************************
PPPP   CCC   OOO  N   N  SSSS  OOO  L     EEEEE        SSSS  CCC  RRRR  EEEEE
P   P C   C O   O NN  N S     O   O L     E           S     C   C R   R E
PPPP  C     O   O N N N  SSS  O   O L     EEEE         SSS  C     RRRR  EEEE
P     C   C O   O N  NN     S O   O L     E               S C   C R  R  E
P      CCC   OOO  N   N SSSS   OOO  LLLLL EEEEE _____ SSSS   CCC  R   R EEEEE
******************************************************************************/

PVOID PCONSOLE_SCREEN_BUFFER_INFOSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    PCONSOLE_SCREEN_BUFFER_INFO Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PCONSOLE_SCREEN_BUFFER_INFOSetup",CaseNo,"Unknown Case");
        Ret = (PCONSOLE_SCREEN_BUFFER_INFO) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
#endif
    return 0;
}


void PCONSOLE_SCREEN_BUFFER_INFOCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/************************************
PPPP  DDD   W   W  OOO  RRRR  DDD
P   P D  D  W   W O   O R   R D  D
PPPP  D   D W W W O   O RRRR  D   D
P     D   D WW WW O   O R  R  D   D
P     DDDD  W   W  OOO  R   R DDDD
************************************/

PDWORD PDWORDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PDWORD pdRet;
    
    *SCInfo = (PDWORD)NULL;
    
    switch(CaseNo) {
    case PDWORD_VALID_0:
        pdRet = (PDWORD) LocalAlloc(LPTR,sizeof(DWORD));
        if (pdRet == NULL) {
            ErrorPrint(hConOut,hLog,"PDWORDSetup",CaseNo,
                "Unable to allocate DWORD");
        }
        else {
            *pdRet = 0;
        }
        *SCInfo = pdRet;
        break;
        
    case PDWORD_BUFFER:
        pdRet = (PDWORD) LocalAlloc(LPTR,sizeof(DWORD));
        if (pdRet == NULL) {
            ErrorPrint(hConOut,hLog,"PDWORDSetup",CaseNo,
                "Unable to allocate DWORD");
            break;
        }
        *SCInfo = pdRet;
        break;
        
    case PDWORD_ACCESSMASK_GENREAD:
        pdRet = (PDWORD) LocalAlloc(LPTR,sizeof(DWORD));
        if (pdRet == NULL) {
            ErrorPrint(hConOut,hLog,"PDWORDSetup",CaseNo,
                "Unable to allocate DWORD");
        }
        else {
            *pdRet = GENERIC_READ;
        }
        *SCInfo = pdRet;
        break;
        
    case PDWORD_ACCESSMASK_GENALL:
        pdRet = (PDWORD) LocalAlloc(LPTR,sizeof(DWORD));
        if (pdRet == NULL) {
            ErrorPrint(hConOut,hLog,"PDWORDSetup",CaseNo,
                "Unable to allocate DWORD");
        }
        else {
            *pdRet = GENERIC_ALL;
        }
        *SCInfo = pdRet;
        break;
        
    case PDWORD_NULL:
        pdRet = (PDWORD) NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"PDWORDSetup",CaseNo,"Unknown Case");
        pdRet = (PDWORD) NULL;
        break;
    }
    
    return(pdRet);
}


void PDWORDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case PDWORD_VALID_0:
    case PDWORD_BUFFER:
    case PDWORD_ACCESSMASK_GENREAD:
    case PDWORD_ACCESSMASK_GENALL:
        LocalFree(*SCInfo);
        break;
    default:
        break;
    }
    
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/****************************************************
PPPP  FFFFF IIIII L     EEEEE TTTTT IIIII M   M EEEEE
P   P F       I   L     E       T     I   MM MM E
PPPP  FFFF    I   L     EEEE    T     I   M M M EEEE
P     F       I   L     E       T     I   M   M E
P     F     IIIII LLLLL EEEEE   T   IIIII M   M EEEEE
****************************************************/

PFILETIME PFILETIMESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PFILETIME Ret;
    
    switch(CaseNo) {
    case PFILETIME_NULL:
        Ret = NULL;
        break;
        
    case PFILETIME_VALID_BUFFER:
        Ret = malloc (sizeof (FILETIME));
        *SCInfo = Ret;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"PFILETIMESetup",CaseNo,"Unknown Case");
        Ret = NULL;
        break;
    }
    
    return(Ret);
}


void PFILETIMECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case PFILETIME_VALID_BUFFER:
        free (*SCInfo);
        break;
        
    default:
        break;
    }
    
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/******************************************
PPPP  H   H   A   N   N DDD   L     EEEEE
P   P H   H  A A  NN  N D  D  L     E
PPPP  HHHHH AAAAA N N N D   D L     EEEE
P     H   H A   A N  NN D   D L     E
P     H   H A   A N   N DDDD  LLLLL EEEEE
******************************************/

PHANDLE
PHANDLESetup(
             int         CaseNo,
             LPVOID          *SCInfo,
             HANDLE          hLog,
             HANDLE          hConOut
             )
{
/*
* Technically, we should never see "PHANDLE" in the win32 stuff; it
* should be replaced with LPHANDLE.  If that happens this code should
* be added to the LPHANDLE setup and munged as necessary to fit.
* TimF 10-Jun-92
    */
    
    PHANDLE pRet = NULL;
    
    switch (CaseNo) {
    case PHANDLE_VALID_TOKEN:
        pRet = (PHANDLE)LocalAlloc(LPTR, sizeof(HANDLE));
        
        if (!pRet) {
            ErrorPrint(hConOut,hLog, "PHANDLESetup",
                CaseNo, "insufficient memory");
        }
        
        break;
        
    case PHANDLE_NULL:
    /*
    * ignore, pRet was set to NULL at entry
        */
        
        break;
        
    case PHANDLE_INVALID:
    /*
    * Until there is decent invalid pointer generation,
    * we will use a hard-coded magic number:  evil
    * incarnate.
        */
        
        pRet = (PHANDLE)0x666;
        
        break;
        
    default:
        ErrorPrint(hConOut, hLog, "PHANDLESetup", CaseNo,
            "Unknown Case");
        
        break;
    }
    
    *SCInfo = pRet;
    
    return pRet;
}


void
PHANDLECleanup(
               int         CaseNo,
               LPVOID          *SCInfo,
               HANDLE          hLog,
               HANDLE          hConOut
               )
{
    switch (CaseNo) {
    case PHANDLE_VALID_TOKEN:
        if (*SCInfo)
            LocalFree(*SCInfo);
        
        break;
        
    case PHANDLE_NULL:
    case PHANDLE_INVALID:
    /*
    * ignore, unless there is bad-pointer stuff to clean
    * up.
        */
        
        break;
        
    default:
        ErrorPrint(hConOut, hLog, "PHANDLECleanup", CaseNo,
            "Unknown Case");
        
        break;
    }
}


/******************************************************************************
PPPP  H   H   A   N   N DDD   L     EEEEE RRRR        RRRR   OOO  U   U TTTTT
P   P H   H  A A  NN  N D  D  L     E     R   R       R   R O   O U   U   T
PPPP  HHHHH AAAAA N N N D   D L     EEEE  RRRR        RRRR  O   O U   U   T
P     H   H A   A N  NN D   D L     E     R  R        R  R  O   O U   U   T
P     H   H A   A N   N DDDD  LLLLL EEEEE R   R _____ R   R  OOO   UUU    T
******************************************************************************/

PVOID PHANDLER_ROUTINESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    PHANDLER_ROUTINE Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PHANDLER_ROUTINESetup",CaseNo,"Unknown Case");
        Ret = (PHANDLER_ROUTINE) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
#endif
    return 0;
}


void PHANDLER_ROUTINECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/******************************************************
PPPP  IIIII  CCC   OOO  N   N IIIII N   N FFFFF  OOO
P   P   I   C   C O   O NN  N   I   NN  N F     O   O
PPPP    I   C     O   O N N N   I   N N N FFFF  O   O
P       I   C   C O   O N  NN   I   N  NN F     O   O
P     IIIII  CCC   OOO  N   N IIIII N   N F      OOO
******************************************************/

PVOID PICONINFOSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    PICONINFO Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PICONINFOSetup",CaseNo,"Unknown Case");
        Ret = (PICONINFO) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
#endif
    return 0;
}


void PICONINFOCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/******************************************************************************
PPPP  IIIII N   N PPPP  U   U TTTTT       RRRR  EEEEE  CCC   OOO  RRRR  DDD
P   P   I   NN  N P   P U   U   T         R   R E     C   C O   O R   R D  D
PPPP    I   N N N PPPP  U   U   T         RRRR  EEEE  C     O   O RRRR  D   D
P       I   N  NN P     U   U   T         R  R  E     C   C O   O R  R  D   D
P     IIIII N   N P      UUU    T   _____ R   R EEEEE  CCC   OOO  R   R DDDD
******************************************************************************/

PVOID PINPUT_RECORDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    PINPUT_RECORD Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PINPUT_RECORDSetup",CaseNo,"Unknown Case");
        Ret = (PINPUT_RECORD) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
#endif
    return 0;
}


void PINPUT_RECORDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}


PLONG PLONGSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PLONG Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PLONGSetup",CaseNo,"Unknown Case");
        Ret = (PLONG) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
}


void PLONGCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/******************************************************************************
PPPP  M   M EEEEE M   M  OOO  RRRR  Y   Y       BBBB    A    SSSS IIIII  CCC
P   P MM MM E     MM MM O   O R   R  Y Y        B   B  A A  S       I   C   C
PPPP  M M M EEEE  M M M O   O RRRR    Y         BBBB  AAAAA  SSS    I   C
P     M   M E     M   M O   O R  R    Y         B   B A   A     S   I   C   C
P     M   M EEEEE M   M  OOO  R   R   Y   _____ BBBB  A   A SSSS  IIIII  CCC
******************************************************************************/

PMEMORY_BASIC_INFORMATION
PMEMORY_BASIC_INFORMATIONSetup(
                               int CaseNo,
                               LPVOID *SCInfo,
                               HANDLE hLog,
                               HANDLE hConOut
                               )
{
    PMEMORY_BASIC_INFORMATION pRet;
    
    switch ( CaseNo ) {
        
    case PMEMORY_BASIC_INFORMATION_INVAL_BUFFER:
        pRet = (PMEMORY_BASIC_INFORMATION)NULL;
        break;
        
    case PMEMORY_BASIC_INFORMATION_2SMALL_BUFFER:
        pRet = VirtualAlloc( 0, 0x2000, MEM_RESERVE, PAGE_READWRITE );
        pRet = VirtualAlloc( pRet, 0x1000, MEM_COMMIT, PAGE_READWRITE );
        if (pRet == NULL) {
            ErrorPrint(hConOut, hLog, "PMEMORY_BASIC_INFORMATIONSetup", CaseNo, "Unable to allocate buffer");
        } else {
            *(PBYTE)pRet = 0;
            pRet = (PMEMORY_BASIC_INFORMATION) \
                ( (PBYTE)pRet + (0x1000 - (sizeof(MEMORY_BASIC_INFORMATION)/2)) );
        }
        *SCInfo = (LPVOID)pRet;
        break;
        
    case PMEMORY_BASIC_INFORMATION_BUFFER:
        pRet = VirtualAlloc( 0, sizeof(MEMORY_BASIC_INFORMATION), MEM_COMMIT, PAGE_READWRITE );
        if (pRet == NULL) {
            ErrorPrint(hConOut, hLog, "PMEMORY_BASIC_INFORMATIONSetup", CaseNo, "Unable to allocate buffer");
        } else {
            *(PBYTE)pRet = 0;
        }
        *SCInfo = (LPVOID)pRet;
        break;
        
    default:
        ErrorPrint(hConOut, hLog, "PMEMORY_BASIC_INFORMATIONSetup", CaseNo, "Unknown Case");
        pRet = (PMEMORY_BASIC_INFORMATION)NULL;
        break;
    }
    
    return pRet;
}


void
PMEMORY_BASIC_INFORMATIONCleanup(
                                 int CaseNo,
                                 LPVOID *SCInfo,
                                 HANDLE hLog,
                                 HANDLE hConOut
                                 )
{
    switch ( CaseNo ) {
        
    case PMEMORY_BASIC_INFORMATION_2SMALL_BUFFER:
    case PMEMORY_BASIC_INFORMATION_BUFFER:
        if ( *SCInfo ) {
            VirtualFree( *SCInfo, 0, MEM_RELEASE );
        }
        break;
        
    default:
        break;
    }
    
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/******************************
PPPP   OOO  IIIII N   N TTTTT
P   P O   O   I   NN  N   T
PPPP  O   O   I   N N N   T
P     O   O   I   N  NN   T
P      OOO  IIIII N   N   T
******************************/

POINT POINTSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    POINT Ret = {0};
    
    switch(CaseNo) {
        
    case POINT_ZERO:
        Ret.x = 0;
        Ret.y = 0;
        break;
        
    case POINT_100:
        Ret.x = 100;
        Ret.y = 100;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"POINTSetup",CaseNo,"Unknown Case");
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
}


void POINTCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}



/************************
PPPP  RRRR   OOO   CCC
P   P R   R O   O C   C
PPPP  RRRR  O   O C
P     R  R  O   O C   C
P     R   R  OOO   CCC
************************/

PROC PROCSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PROC Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PROCSetup",CaseNo,"Unknown Case");
        Ret = (PROC) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
}


void PROCCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}


/******************************************************************************
PPPP   SSSS EEEEE  CCC  U   U RRRR  IIIII TTTTT Y   Y        CCC   OOO  N   N
P   P S     E     C   C U   U R   R   I     T    Y Y        C   C O   O NN  N
PPPP   SSS  EEEE  C     U   U RRRR    I     T     Y         C     O   O N N N
P         S E     C   C U   U R  R    I     T     Y         C   C O   O N  NN
P     SSSS  EEEEE  CCC   UUU  R   R IIIII   T     Y   _____  CCC   OOO  N   N
******************************************************************************/

PSECURITY_DESCRIPTOR_CONTROL PSECURITY_DESCRIPTOR_CONTROLSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PSECURITY_DESCRIPTOR_CONTROL pRet;
    
    *SCInfo = (PSECURITY_DESCRIPTOR_CONTROL)NULL;
    
    switch(CaseNo) {
        
    case PSECURITY_DESCRIPTOR_CONTROL_VALID:
        pRet = (PSECURITY_DESCRIPTOR_CONTROL)
            LocalAlloc(LPTR, sizeof(SECURITY_DESCRIPTOR_CONTROL));
        
        if(!pRet) {
            ErrorPrint(hConOut,hLog, "PSECURITY_DESCRIPTOR_CONTROLSetup", CaseNo,
                "Insufficient memory");
            break;
        }
        *SCInfo = pRet;
        break;
        
    case PSECURITY_DESCRIPTOR_CONTROL_NULL:
        pRet = (PSECURITY_DESCRIPTOR_CONTROL)NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"PSECURITY_DESCRIPTOR_CONTROLSetup",CaseNo,
            "Unknown Case");
        pRet = (PSECURITY_DESCRIPTOR_CONTROL) NULL;
        break;
    }
    
    return(pRet);
}


void PSECURITY_DESCRIPTOR_CONTROLCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case PSECURITY_DESCRIPTOR_CONTROL_VALID:
        if(*SCInfo)
            LocalFree(*SCInfo);
        break;
    default:
        break;
    }
    
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}

/******************************************************************************
PPPP   SSSS EEEEE  CCC  U   U RRRR  IIIII TTTTT Y   Y       IIIII N   N FFFFF
P   P S     E     C   C U   U R   R   I     T    Y Y          I   NN  N F
PPPP   SSS  EEEE  C     U   U RRRR    I     T     Y           I   N N N FFFF
P         S E     C   C U   U R  R    I     T     Y           I   N  NN F
P     SSSS  EEEEE  CCC   UUU  R   R IIIII   T     Y   _____ IIIII N   N F
******************************************************************************/

PSECURITY_INFORMATION PSECURITY_INFORMATIONSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PSECURITY_INFORMATION Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"PSECURITY_INFORMATIONSetup",CaseNo,"Unknown Case");
        Ret = (PSECURITY_INFORMATION) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
}


void PSECURITY_INFORMATIONCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elmination
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}


PVOID PVOIDSetup(
                 int                     CaseNo,
                 LPVOID                  *SCInfo,
                 HANDLE                  hLog,
                 HANDLE                  hConOut
                 )
{
    PVOID                   Ret;
    
    *SCInfo = (PVOID)NULL;
    
    switch(CaseNo) {
    case PVOID_INVALID: // pick an arb addr (which will probably be invalid
        
        Ret = (PVOID)0x12345678;
        
        break;
        
    case PVOID_NULL:
        
        Ret = (PVOID)NULL;
        
        break;
        
    case PVOID_VALID:
        
        Ret = (PVOID) LocalAlloc(LPTR, sizeof(WCHAR)*50);
        *SCInfo = (PVOID) Ret;
        break;
        
    default:
        
        ErrorPrint(hConOut,
            hLog,
            "PVOIDSetup",
            CaseNo,
            "Unknown Case");
        
        Ret = (PVOID)NULL;
        
        break;
    }
    
    *SCInfo = Ret;
    
    return Ret;
}


void PVOIDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case PVOID_VALID:
        if(*SCInfo)
            LocalFree(*SCInfo);
        break;
        
    default:
        break;
        
    }
    
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}

/***********************************
PPPP   PPPP  V   V  OOO  IIIII DDD
P   p  P   P V   V O   O   I   D  D
PPPP   PPPP  V   V O   O   I   D   D
P      P      V V  O   O   I   D   D
P    - P       V    OOO  IIIII DDDD
***********************************/


PVOID *P_PVOIDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    PVOID       *Ret;
    
    *SCInfo = (PVOID)NULL;
    
    switch(CaseNo) {
        
        
    case P_PVOID_NULL:
        Ret = (PVOID)NULL;
        break;
        
    case P_PVOID_VALID_NULL:
        if ( NULL != (Ret = (PVOID *)LocalAlloc(LPTR, sizeof(DWORD))) ) {
            *Ret = NULL;
        } else {
            ErrorPrint(hConOut, hLog, "P_PVOID_SETUP",
                CaseNo, "alloc failed\n");
        }
        *SCInfo = Ret;
        break;
        
    case P_PVOID_5K:
        if ((Ret = (PVOID *)LocalAlloc(LPTR, 5*1024)) == NULL) {
            ErrorPrint(hConOut, hLog, "P_PVOID_SETUP",
                CaseNo, "alloc failed\n");
        }
        *SCInfo = Ret;
        break;
        
    case P_PVOID_VALID_ADDRESS:
        
        Ret = (PVOID)LocalAlloc(LPTR, sizeof(DWORD));
        if(!Ret) {
            ErrorPrint(hConOut, hLog, "PVOID_VALID_ADDRESS",
                CaseNo, "Insufficient memory\n");
        }
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"PVOIDSetup",CaseNo,"Unknown Case");
        Ret = (PVOID) NULL;
        break;
    }
    
    *SCInfo = Ret;
    
    return(Ret);
}


void P_PVOIDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case P_PVOID_VALID_NULL:
    case P_PVOID_5K:
        if(*SCInfo)
            LocalFree(*SCInfo);
        break;
        
    default:
        break;
    }
    
    hLog;     // -W3 warning elmination
    hConOut;  // -W3 warning elmination
}


LPSTR *P_LPSTRSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    LPSTR *Ret;
    
    switch(CaseNo) {
        
    case P_LPSTR_VALID_ADDRESS:
        Ret = *SCInfo = (LPSTR *) LocalAlloc(LPTR, sizeof(LPSTR));
        if ( Ret == NULL )
            ErrorPrint(hConOut,hLog,"P_LPSTRSetup",CaseNo,"out of memory\n");
        break;
    case P_LPSTR_NULL:
        Ret = NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"P_LPSTRSetup",CaseNo,"Unknown Case");
        Ret = NULL;
        break;
    }
    
    return(Ret);
}



void P_LPSTRCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    switch(CaseNo) {
    case P_LPSTR_VALID_ADDRESS:
        if ( *SCInfo != NULL )
            LocalFree((HANDLE)*SCInfo);
        break;
    default:
        break;
    }
    
    hConOut;
    hLog;
}


LPWSTR *P_LPWSTRSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    LPWSTR *Ret;
    
    switch(CaseNo) {
        
    case P_LPWSTR_VALID_ADDRESS:
        Ret = *SCInfo = (LPWSTR *) LocalAlloc(LPTR, sizeof(LPWSTR));
        if ( Ret == NULL )
            ErrorPrint(hConOut,hLog,"P_LPWSTRSetup",CaseNo,"out of memory\n");
        break;
    case P_LPWSTR_NULL:
        Ret = NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"P_LPWSTRSetup",CaseNo,"Unknown Case");
        Ret = NULL;
        break;
    }
    
    return(Ret);
}



void P_LPWSTRCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog,HANDLE hConOut)
{
    switch(CaseNo) {
    case P_LPWSTR_VALID_ADDRESS:
        if ( *SCInfo != NULL )
            LocalFree((HANDLE)*SCInfo);
        break;
    default:
        break;
    }
    
    hConOut;
    hLog;
}

PVOID LPPIXELFORMATDESCRIPTORSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPPIXELFORMATDESCRIPTOR Ret;
    
    switch(CaseNo) {
        
    case LPPIXELFORMATDESCRIPTOR_NULL:
        Ret = (LPPIXELFORMATDESCRIPTOR) NULL;
        *SCInfo = Ret;
        break;
        
    case LPPIXELFORMATDESCRIPTOR_VALID:
        if ( (Ret = LocalAlloc(LPTR, sizeof(PIXELFORMATDESCRIPTOR))) == NULL )
            ErrorPrint(hConOut,hLog,"LPPIXELFORMATDESCRIPTORSetup",CaseNo,
            "Error allocating memory");
        
        Ret->nSize = sizeof(PIXELFORMATDESCRIPTOR);
        Ret->nVersion = 1;
        Ret->dwFlags = PFD_DRAW_TO_WINDOW;
        
        *SCInfo = Ret;
        break;
        
    case LPPIXELFORMATDESCRIPTOR_MINUS_ONE:
        Ret = (LPPIXELFORMATDESCRIPTOR) -1;
        *SCInfo = Ret;
        break;
        
        
        
    default:
        ErrorPrint(hConOut,hLog,"LPPIXELFORMATDESCRIPTORSetup",CaseNo,"Unknown Case");
        Ret = (LPPIXELFORMATDESCRIPTOR) NULL;
        break;
    }
    
    return(Ret);
#endif
    return 0;
}


void LPPIXELFORMATDESCRIPTORCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPPIXELFORMATDESCRIPTOR_VALID:
        if ( *SCInfo != NULL )
            LocalFree(*SCInfo);
        break;
        
    default:
        break;
    }
    
    hConOut;
    hLog;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\x_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    x_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'X'. It also contains setup and cleanup
    funtions beginning with 'LPX'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/

#include <setcln.h>
#include <x_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\t_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    t_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'T'. It also contains setup and cleanup
    funtions beginning with 'LPT'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <t_cases.bmh>


DWORD WINAPI DoNothingThreadProc()
{
    SleepEx( 100, TRUE );
    return 0xdeadbeef;
}


LPTHREAD_START_ROUTINE LPTHREAD_START_ROUTINESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPTHREAD_START_ROUTINE Ret;
    
    switch(CaseNo) {
    case LPTHREAD_START_ROUTINE_VALID_THREAD_ADDRESS:
        Ret = (LPTHREAD_START_ROUTINE)DoNothingThreadProc;
        break;
        
    case LPTHREAD_START_ROUTINE_NULL:
        Ret = (LPTHREAD_START_ROUTINE) NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPTHREAD_START_ROUTINESetup",CaseNo,"Unknown Case");
        Ret = (LPTHREAD_START_ROUTINE) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;   // -W3 warning elimination
}


void LPTHREAD_START_ROUTINECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;   // -W3 warning elimination
    hLog;     // -W3 warning elimination
    hConOut;  // -W3 warning elimination
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\u_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    t_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'T'. It also contains setup and cleanup
    funtions beginning with 'LPT'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <u_cases.bmh>
#include "limits.h"


UINT UINTSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    UINT Ret;
    
    switch(CaseNo) {
        
    case UINT_VALID_PATH_BUFFER_LENGTH:
        Ret = (UINT) MAX_PATH;
        break;
    case UINT_UNIQUE_VALID:
        Ret = 5;
        break;
    case UINT_UNIQUE_INVALID:
        Ret = 0xffffffff;
        break;
    case UINT_MAXIMUM:
        Ret = UINT_MAX;
        break;
    case UINT_ZERO:
        Ret = 0;
        break;
    case UINT_A_VALUE:
        Ret = 65;
        break;
    case UINT_ONE:
        Ret = (UINT)1;
        break;
    case UINT_16:
        Ret = (UINT)16;
        break;
    case UINT_13:
        Ret = (UINT)13;
        break;
    case UINT_2:
        Ret = (UINT)2;
        break;
    case UINT_3:
        Ret = (UINT)3;
        break;
    case UINT_4:
        Ret = (UINT)4;
        break;
    case UINT_70:
        Ret = (UINT)70;
        break;
    default:
        ErrorPrint(hConOut,hLog,"UINTSetup",CaseNo,"Unknown Case");
        Ret = (UINT) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;
}


void UINTCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    CaseNo;
    SCInfo;
    hLog;
    hConOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\v_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    v_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'V'. It also contains setup and cleanup
    funtions beginning with 'LPV'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <v_cases.bmh>
#include <filever.h>
#include <memmgt.h>


LPVOID LPVOIDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPVOID lpRet = NULL;
    DWORD  dwSize;
    
    switch(CaseNo) {
        // Cases created by JohnMil, 2/28
    case LPVOID_NONALIGNED_V_ADDR:
    case LPVOID_ALIGNED_V_ADDR:
    case LPVOID_RES_UNCOMMIT_V_ADDR:
    case LPVOID_REGION_BEG_V_ADDR:
    case LPVOID_LOCKED_V_ADDR:
    case LPVOID_UNLOCKED_V_ADDR:
        lpRet = VirtAddrCreate(hLog,hConOut,CaseNo,SCInfo);   // Memmgt.c
        break;
    case LPVOID_NULL:
        lpRet = (LPVOID) NULL;
        break;
    case LPVOID_READWRITE_VALID_BUFFER:
        if ( (lpRet = malloc(FIO_READWRITE_BUFFER_SIZE)) == NULL )
            ErrorPrint(hConOut,hLog,"LPVOIDSetup",CaseNo,
            "Error allocating space for read/write buffer");
        *SCInfo = lpRet;
        break;
        
    case LPVOID_VER_VALID_INFO_BUFFER:
    case LPVOID_VER_VALID_INFO_BLOCK:
        
        *SCInfo = NULL;
        
        // get the ver info size from the file
        
        dwSize = 1;//GetVersionInfoSize(VER_DEFAULT_FILE_WITH_VER_INFO, &dwBogusHandle);
        
        if ( dwSize == 0 ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "error getting size of version info\n");
            break;
        }
        
        // alloc buffer and return it
        
        if ( (lpRet = malloc(dwSize)) == NULL ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "error allocing memory for version info\n");
            break;
        }
        
        *SCInfo = lpRet;
        break;
        
    case LPVOID_VER_INVALID_INFO_BLOCK:
        
#ifdef IT_EVER_MAKES_IT_TO_A_BUILD
        *SCInfo = NULL;
        
        // get the ver info size from the file
        
        dwSize = GetVersionInfoSize(VER_DEFAULT_FILE_WITH_VER_INFO,
            &dwBogusHandle);
        
        if ( dwSize == 0 ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "error getting size of version info\n");
            break;
        }
        
        // alloc buffer
        
        if ( (lpRet = malloc(dwSize)) == NULL ) {
            ErrorPrint(hConOut, hLog, "FIOLpstrSetup", CaseNo,
                "error allocing memory for version info\n");
            break;
        }
        
        // make pointer point 20 bytes past start
        
        lpRet = (int) lpRet + 20;
        *SCInfo = lpRet;
#endif
        lpRet = *SCInfo = NULL;
        
        break;
        
    case LPVOID_INVALID: {
        SE_CLEANUP_INFO		*CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&lpRet,
            &CleanupInfo,
            INVALID_POINTER,
            0,
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPVOIDSetup", CaseNo,
                "MakeBadPointer failed.");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                         }
        
    case LPVOID_MALALIGNED: {
    /*
    * Make a randomly large and return an un-aligned pointer to it, in
    * hopes that alignment checking will cause a trap, not reaching an
    * invalid section.
        */
        
        SE_CLEANUP_INFO		*CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&lpRet,
            &CleanupInfo,
            MALALIGNED_POINTER_1,
            65535,			// randomly large
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPVOIDSetup", CaseNo,
                "MakeBadPointer failed.");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                            }
    case LPVOID_VALID:
        lpRet = (LPVOID)LocalAlloc( LPTR, 5*1024 ); // 5k block
        *SCInfo = lpRet;
        break;
        
    case LPVOID_FILE_INFO:
        
        *SCInfo = NULL;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPVOIDSetup",CaseNo,"Unknown Case");
        lpRet = (LPVOID) NULL;
        break;
    }
    
    return(lpRet);
}


void LPVOIDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
        // Cleanup by JohnMil, 2/28
    case LPVOID_LOCKED_V_ADDR:
    case LPVOID_NONALIGNED_V_ADDR:
    case LPVOID_ALIGNED_V_ADDR:
    case LPVOID_RES_UNCOMMIT_V_ADDR:
    case LPVOID_REGION_BEG_V_ADDR:
    case LPVOID_UNLOCKED_V_ADDR:
        VirtualFree(*SCInfo,0,MEM_RELEASE);   //Memmgt.c
        break;
    case LPVOID_VALID:
    case LPVOID_FILE_INFO:
        if (LocalFree( *SCInfo )!=NULL)
            ErrorPrint(hConOut,hLog,"LPVOIDCleanup",CaseNo,"LocalFree failed" );
        break;
    case LPVOID_READWRITE_VALID_BUFFER:
    case LPVOID_VER_VALID_INFO_BUFFER:
        if ( *SCInfo != NULL )
            free(*SCInfo);
        break;                                   
    case LPVOID_VER_INVALID_INFO_BLOCK:
        if ( *SCInfo != NULL )
            free((LPVOID)(((int)*SCInfo) - 20));
        break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\y_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    y_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'Y'. It also contains setup and cleanup
    funtions beginning with 'LPY'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/

#include <setcln.h>
#include <y_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\s_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    s_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'S'. It also contains setup and cleanup
    funtions beginning with 'LPS'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <stdlib.h>
#include <string.h>
#include <setcln.h>
#include <a_cases.bmh>
#include <p_cases.bmh>
#include <s_cases.bmh>
#include <memmgt.h>
#include <filever.h>


UINT
WINAPI
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );


LPSECURITY_ATTRIBUTES LPSECURITY_ATTRIBUTESSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPSECURITY_ATTRIBUTES lpRet;
    
    switch(CaseNo) {
        
    case LPSECURITY_ATTRIBUTES_NULL:
        lpRet = (LPSECURITY_ATTRIBUTES) NULL;
        break;
        
    case LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS_INHERIT:
    case LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS_NO_INHERIT:
        lpRet = (LPSECURITY_ATTRIBUTES) LocalAlloc( LPTR, sizeof(SECURITY_ATTRIBUTES) );
        if (lpRet==NULL)
            ErrorPrint(hConOut,hLog,"LPSECURITY_ATTRIBUTESSetup",CaseNo,"LocalAlloc LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS failed!");
        else {
            lpRet->nLength = sizeof(SECURITY_ATTRIBUTES);
            lpRet->lpSecurityDescriptor = NULL;
            lpRet->bInheritHandle = (CaseNo==LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS_INHERIT);
        }
        *SCInfo = (LPVOID) lpRet;
        break;
        
    case LPSECURITY_ATTRIBUTES_MINUS_ONE:
        lpRet = (LPSECURITY_ATTRIBUTES) -1;
        break;
        
    case LPSECURITY_ATTRIBUTES_INVALID_LENGTH:
        lpRet = (LPSECURITY_ATTRIBUTES) LocalAlloc( LPTR, sizeof(SECURITY_ATTRIBUTES) );
        if (lpRet==NULL)
            ErrorPrint(hConOut,hLog,"LPSECURITY_ATTRIBUTESSetup",CaseNo,"LocalAlloc LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS failed!");
        else {
            lpRet->nLength = sizeof(SECURITY_ATTRIBUTES) - 4;
            lpRet->lpSecurityDescriptor = NULL;
            lpRet->bInheritHandle = TRUE;
        }
        *SCInfo = (LPVOID) lpRet;
        break;
        
    case LPSECURITY_ATTRIBUTES_INVALID_SECURITY_DESCRIPTOR:
        lpRet = (LPSECURITY_ATTRIBUTES) LocalAlloc( LPTR, sizeof(SECURITY_ATTRIBUTES) );
        if (lpRet==NULL)
            ErrorPrint(hConOut,hLog,"LPSECURITY_ATTRIBUTESSetup",CaseNo,"LocalAlloc LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS failed!");
        else {
            lpRet->nLength = sizeof(SECURITY_ATTRIBUTES);
            lpRet->lpSecurityDescriptor = (LPVOID)-1L;
            lpRet->bInheritHandle = TRUE;
        }
        *SCInfo = (LPVOID) lpRet;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPSECURITY_ATTRIBUTESSetup",CaseNo,"Unknown Case");
        lpRet = (LPSECURITY_ATTRIBUTES) NULL;
        break;
    }
    
    return(lpRet);
}


void LPSECURITY_ATTRIBUTESCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS_INHERIT:
    case LPSECURITY_ATTRIBUTES_SAME_AS_CALLING_PROCESS_NO_INHERIT:
    case LPSECURITY_ATTRIBUTES_INVALID_LENGTH:
    case LPSECURITY_ATTRIBUTES_INVALID_SECURITY_DESCRIPTOR:
        if ((*SCInfo)!=NULL) {
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPSECURITY_ATTRIBUTESCleanup",CaseNo,"LocalFree failed!");
        }
        
    default:
        break;
    }
}



/************************************
L     PPPP   SSSS IIIII ZZZZZ EEEEE
L     P   P S       I      Z  E
L     PPPP   SSS    I     Z   EEEE
L     P         S   I    Z    E
LLLLL P     SSSS  IIIII ZZZZZ EEEEE
************************************/

LPSIZE LPSIZESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPSIZE Ret;
    
    switch(CaseNo) {
    case LPSIZE_VALID:
        Ret = (LPSIZE) LocalAlloc (LPTR, sizeof(SIZE));
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPSIZESetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break ;
    case LPSIZE_NULL:
        Ret=(LPSIZE) NULL;
        break;
    case LPSIZE_RANDOM:
        Ret=(LPSIZE) rand();
        break;
    case LPSIZE_MINUS_ONE:
        Ret=(LPSIZE) -1;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPSIZESetup",CaseNo,"Unknown Case");
        Ret = (LPSIZE) NULL;
        break;
    }
    
    return(Ret);
}


void LPSIZECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPSIZE_VALID:
        if ((*SCInfo)!=NULL) {
            if (LocalFree((HANDLE)(*SCInfo))!=NULL)
                ErrorPrint(hConOut,hLog,"LPSIZECleanup",CaseNo,"LocalFree failed!");
        }
    default:
        break;
    }
}


LPSTR LPSTRSetup(int CaseNo, LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPSTR lpRet;
    
    switch(CaseNo) {
    case LPSTR_RANDOM:
        lpRet = (LPSTR) rand();
        break;
        
    case LPSTR_MINUS_ONE:
        lpRet = (LPSTR) -1;
        break;
        
    case LPSTR_NULL:
        lpRet = (LPSTR) NULL;
        break;
    case LPSTR_BASE_VALID_LMEM_BLOCK:
    case LPSTR_INSIDE_VALID_LMEM_BLOCK:
    case LPSTR_INSIDE_FREED_LMEM_BLOCK:
        //  case LPSTR_INSIDE_DISCARDED_LMEM_BLOCK:
        lpRet = LMemPointerCreate(hLog,hConOut,CaseNo,SCInfo);
        break;
    case LPSTR_BASE_VALID_GMEM_BLOCK:
    case LPSTR_INSIDE_VALID_GMEM_BLOCK:
    case LPSTR_INSIDE_FREED_GMEM_BLOCK:
    case LPSTR_INSIDE_DISCARDED_GMEM_BLOCK:
        lpRet = GMemPointerCreate(hLog,hConOut,CaseNo,SCInfo);
        break;
    case LPSTR_VALID_HEAP_BLOCK:
    case LPSTR_DESTROYED_HEAP_BLOCK:
    case LPSTR_FREED_HEAP_BLOCK:
        lpRet = HeapPointerCreate(hLog,hConOut,CaseNo,SCInfo);
        break;
        
    case LPSTR_VALID_NT_IMAGE_NAME:
        lpRet = (LPSTR) LocalAlloc( LPTR, 64 );
        if (lpRet!=NULL)
            sprintf( lpRet, "bminfprc.exe" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_NON_EXISTANT_IMAGE_NAME:
        lpRet = (LPSTR) LocalAlloc( LPTR, 64 );
        if (lpRet!=NULL)
            sprintf( lpRet, "abcdefgh.ijk" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_INVALID_FILE_NAME:
        lpRet = (LPSTR) LocalAlloc( LPTR, 64 );
        if (lpRet!=NULL)
            sprintf( lpRet, "[/]" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_NON_EXISTENT_DIRECTORY:
        lpRet = (LPSTR) LocalAlloc( LPTR, 64 );
        if (lpRet!=NULL)
            sprintf( lpRet, "\\aaa\\bbb\\ccc\\ddd\\eee\\fff\\gomer\\hhh\\iii" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_VALID_CURRENT_DIRECTORY:
        lpRet = (LPSTR) LocalAlloc( LPTR, 64 );
        if (lpRet!=NULL)
            sprintf( lpRet, "\\" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_TEMP_FILE_NAME:
        {
            HANDLE hMem ;
            LPSTR  lpMem ;
            
            hMem  = LocalAlloc( LPTR, 145 ) ;
            if( !hMem )
            {
                ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
                lpRet = NULL ;
                *SCInfo = NULL ;
            }
            else
            {
                *SCInfo = (LPVOID)hMem ;
                
                lpMem = (LPSTR)LocalLock( hMem ) ;
                if( !lpMem )
                {
                    ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
                    lpRet = NULL ;
                }
                else
                {
                    if( !GetTempFileNameA( ".", "LPSTR", 0, lpMem ) )
                    {
                        ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"GetTempFileName failed!");
                        lpRet = NULL ;
                    }
                    else
                        lpRet = lpMem ;
                }
            }
        }
        break ;
        
    case LPSTR_DOUBLE_NULL_NULL:
        lpRet = (LPSTR) LocalAlloc( LPTR, 4 );
        if (lpRet!=NULL)
            sprintf( lpRet, "\0" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_DOUBLE_NULL_STRING:
        lpRet = (LPSTR) LocalAlloc( LPTR, 64 );
        if (lpRet!=NULL)
            sprintf( lpRet, "This String has a double NULL terminator\0" );
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_FILENAME_VALID:
    case LPSTR_FILENAME_INVALID1:
    case LPSTR_FILENAME_INVALID2:
    case LPSTR_FILENAME_INVALID3:
    case LPSTR_FILENAME_INVALID4:
    case LPSTR_FILENAME_INVALID5:
    case LPSTR_FILENAME_INVALID6:
    case LPSTR_FILENAME_INVALID7:
    case LPSTR_FILENAME_INVALID8:
    case LPSTR_FILENAME_INVALID9:
    case LPSTR_DIRNAME_INVALID1:
    case LPSTR_DIRNAME_INVALID2:
    case LPSTR_DIRNAME_INVALID3:
    case LPSTR_DIRNAME_INVALID4:
    case LPSTR_SRC_FILE_EXISTS:
    case LPSTR_SRC_FILE_NOT_EXISTS:
    case LPSTR_DEST_FILE_EXISTS:
    case LPSTR_DEST_FILE_NOT_EXISTS:
    case LPSTR_DIRNAME_VALID:
    case LPSTR_PATH_EXISTS:
    case LPSTR_PATH_NOT_EXISTS:
    case LPSTR_PREFIX_VALID:
    case LPSTR_PREFIX_TOO_LONG:
    case LPSTR_VALID_PATH_BUFFER:
    case LPSTR_VALID_ROOT_PATHNAME:
    case LPSTR_INVALID_ROOT_PATHNAME:
    case LPSTR_FILE_EXISTS:
    case LPSTR_FILE_NOT_EXISTS:
    case LPSTR_FILE_READONLY:
    case LPSTR_VOLUME_NAME_BUFFER:
    case LPSTR_FILE_SYSTEM_NAME_BUFFER:
    case LPSTR_VER_SRC_FILE_EXISTS:
    case LPSTR_VER_SRC_FILE_NOT_EXISTS:
    case LPSTR_VER_SRC_DIR_EXISTS:
    case LPSTR_VER_SRC_DIR_NOT_EXISTS:
    case LPSTR_VER_DEST_FILE_EXISTS:
    case LPSTR_VER_DEST_FILE_NOT_EXISTS:
    case LPSTR_VER_DEST_DIR_EXISTS:
    case LPSTR_VER_DEST_DIR_NOT_EXISTS:
    case LPSTR_NULL_STRING:
    case LPSTR_WINDOWS_DIR:
    case LPSTR_VER_APP_DIR:
    case LPSTR_VER_SUB_BLOCK_EXISTS:
    case LPSTR_VER_SUB_BLOCK_NOT_EXISTS:
    case LPSTR_SEARCH_PATH_ILL_FORMED:
    case LPSTR_FILE_IN_CURR_DIR_NO_EXT:
    case LPSTR_EXT_FILE_IN_CURR_DIR:
    case LPSTR_EXT_ILL_FORMED:
    case LPSTR_FILE_NOT_EXISTS_ON_PATH:
        lpRet = FIOLpstrSetup(CaseNo, SCInfo, hLog, hConOut);
        break;
        
    case LPSTR_EMPTY:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            lpRet[0] = '\0';
        else
            ErrorPrint (hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_FILENAME:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            sprintf (lpRet, ".\\bminitst.ini");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_SECTION_NAME:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            sprintf (lpRet, "badman_section");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_KEYNAME:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            sprintf (lpRet, "badman_key");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_INT:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            sprintf (lpRet, "64");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_STRING:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            sprintf (lpRet, "badman_inifile_string_value");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_KEY_VALUE:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet!=NULL)
            sprintf (lpRet, "badman_key = badman_inifile_string_value\0");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_INIFILE_SECTION:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet != NULL)
        {
            sprintf (lpRet, "key1 = section1 key2 = section2 key3 = section3 ");
            //012345678901234567890123456789012345678901234567
            lpRet[15] = '\0';
            lpRet[31] = '\0';
            lpRet[47] = '\0';
        }
        else
            ErrorPrint (hConOut, hLog, "LPSTRSetup", CaseNo, "LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_BUFFER_1K:
        lpRet = (LPSTR) LocalAlloc (LPTR, 1024);
        if (lpRet == NULL)
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_BUFFER_512_BYTE:
        lpRet = (LPSTR) LocalAlloc (LPTR, 512);
        if (lpRet == NULL)
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_BUFFER_1_BYTE:
        lpRet = (LPSTR) LocalAlloc (LPTR, 1);
        if (lpRet == NULL)
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_REG_KEYNAME:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet != NULL)
            sprintf (lpRet, "Badman test key");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_REG_VALUENAME:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet != NULL)
            sprintf (lpRet, "Badman value");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
    case LPSTR_257_CHAR:
        lpRet = (LPSTR) LocalAlloc (LPTR, 258);
        if (lpRet != NULL)
        {
            int i;
            for (i=0; i<258; i++)
                lpRet[i] = (char)(i | 1);
            lpRet[258] = '\0';
        }
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break ;
        
        /*
        * a nice way to avoid duplicating code:
        */
        
#define STRDUP(targ, src)                       \
    (targ) = (LPSTR)GlobalAlloc(GPTR, sizeof (src));        \
    \
    if (!targ) {                            \
    ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,     \
    "LocalAlloc failed!");              \
    } else {                            \
    strcpy((targ), src);                  \
    \
    *SCInfo = (targ);                   \
        }
        
    case LPSTR_INVALID:
        // an invalid pointer
        
        lpRet = (LPSTR)0x666;   // invalid, as well as magic, expand when
        // bad-pointer stuff is implemnted.
        
        *SCInfo = lpRet;
        
        break;
        
    case LPSTR_64K_BUFFER:
        // pointer to a 64k buffer
        
        lpRet = (LPSTR)GlobalAlloc(GPTR, 64*1024U);
        
        *SCInfo = lpRet;
        
        if (!lpRet) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "GlobalAlloc failed!");
        }
        
        break;
        
    case LPSTR_2BYTE_BUFFER:
        // pointer to a buffer too small for the shortest cannonical
        // privilege or name/ascii verison of a display name, or username.
        
        if ( NULL == (lpRet = GetNativeBuffer(SMALL_NATIVE_BUFFER_SIZE)) ) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "LocalAlloc failed!");
        }
        
        *SCInfo = lpRet;
        
        break;
        
    case LPSTR_FAT_FILENAME:
        // valid FAT filename
        STRDUP(lpRet, "D:\\testfile.fat");
        break;
        
    case LPSTR_FILENAME_BOGUS:
    /*
    * filename with invalid chars
        */
        
        STRDUP(lpRet, "bogus:test:filename");
        
        break;
        
    case LPSTR_INVALID_1: {
    /*
    * first DWORD of WSTR valid, non-null chars
        */
        
        int         i;
        SE_CLEANUP_INFO     *CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&lpRet,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            1 * sizeof (DWORD),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        try {
            for (i = 0; i < 1 * sizeof (DWORD); i++) {
                lpRet[i] = 'c';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "Trapped too soon!");
            
            MakeBadPointer(NULL,
                &CleanupInfo,
                CLEANUP,
                0,
                hConOut,
                hLog);
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                          }
        
    case LPSTR_INVALID_N: {
    /*
    * a STR with all but last DWORD of length valid, arbitraily make it
    * 10 DWORDS long
        */
        
        int         i;
        SE_CLEANUP_INFO     *CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&lpRet,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            10 * sizeof (DWORD),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        try {
            for (i = 0; i < 10 * sizeof (DWORD); i++) {
                lpRet[i] = 'd';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "Trapped too soon!");
            
            MakeBadPointer(NULL,
                &CleanupInfo,
                CLEANUP,
                0,
                hConOut,
                hLog);
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                          }
        
    case LPSTR_NTFS_FILENAME: {
    /*
    * valid NTFS filename (includes unicode chars)
        */
        
        char            c;
        
        STRDUP(lpRet, " :\\foo");
        
        for (c = 'c'; c <= 'z'; c++) {
            lpRet[0] = c;
            
            if (CreateFile(lpRet,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_DELETE_ON_CLOSE,
                NULL)) {
                SetLastError(NO_ERROR);
                
                break;
            }
        }
        
        if (GetLastError() != NO_ERROR) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            GlobalFree(lpRet);
            
            lpRet = NULL;
        }
        
        break;
                              }
        
    case LPSTR_RELATIVE_FILENAME:
    /*
    * a relative path/filename
        */
        
        STRDUP(lpRet, "foo");
        
        if (!CreateFile(lpRet,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_FLAG_DELETE_ON_CLOSE,
            NULL)) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            GlobalFree(lpRet);
            
            lpRet = NULL;
        }
        
        break;
        
    case LPSTR_REMOTE_FILENAME:
    /*
    * a drive-relative remote filename
        */
        
        STRDUP(lpRet, "x:\\foo");
        
        if (!CreateFile(lpRet,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_FLAG_DELETE_ON_CLOSE,
            NULL)) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            GlobalFree(lpRet);
            
            lpRet = NULL;
        }
        
        break;
        
    case LPSTR_TOO_LONG:
        // a string of characters which is > 64Kb
        
        if ( NULL == (lpRet = (LPSTR)GlobalAlloc(GPTR, 66000)) ) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "GlobalAlloc failed");
        } else {
            int         i;
            
            for (i = 0; i < 66000 - 1; i++) {
                lpRet[i] = 'a';
            }
            
            lpRet[i] = '\0';
        }
        
        *SCInfo = lpRet;
        
        break;
        
    case LPSTR_UNC_FILENAME:
    /*
    * a UNC filename
        */
        
        STRDUP(lpRet, "\\\\scratch\\scratch\\foo");
        
        if (!CreateFile(lpRet,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_FLAG_DELETE_ON_CLOSE,
            NULL)) {
            ErrorPrint(hConOut, hLog, "LPSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            GlobalFree(lpRet);
            
            lpRet = NULL;
        }
        
        break;
        
    case LPSTR_46CHAR:
        lpRet = (LPSTR) LocalAlloc (LPTR, 46);
        if (lpRet != NULL)
            sprintf (lpRet, "The quick brown fox jumped over the lazy dogs");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_DISPLAY:
        lpRet = (LPSTR) LocalAlloc (LPTR, 8);
        if (lpRet != NULL)
            sprintf (lpRet, "DISPLAY");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_OPEN:
        lpRet = (LPSTR) LocalAlloc (LPTR, 5);
        if (lpRet != NULL)
            sprintf (lpRet, "OPEN");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_COMMAND_LINE:
        lpRet = (LPSTR) LocalAlloc (LPTR, 64);
        if (lpRet != NULL)
            sprintf (lpRet, "asdf jkl; qwer uiop");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_TEMP_DIR:
        lpRet = (LPSTR) LocalAlloc (LPTR, MAX_PATH);
        if (lpRet != NULL)
            // BUGBUG GetTempPathA(MAXPATH, lpRet);
            strcpy(lpRet, "d:\\winnt\\xboxtest\\");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    case LPSTR_ROOT_DIR:
        lpRet = (LPSTR) LocalAlloc (LPTR, MAX_PATH);
        if (lpRet != NULL)
            sprintf (lpRet, "t:\\");
        else
            ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = lpRet;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"Unknown Case");
        lpRet = NULL;
        break;
    }
    
    return lpRet;
}


void LPSTRCleanup(int CaseNo, LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPSTR_BASE_VALID_LMEM_BLOCK:
    case LPSTR_INSIDE_VALID_LMEM_BLOCK:
        LocalFree((HANDLE) *SCInfo);
        break;
    case LPSTR_BASE_VALID_GMEM_BLOCK:
    case LPSTR_INSIDE_VALID_GMEM_BLOCK:
        GlobalFree((HANDLE) *SCInfo);
        break;
    case LPSTR_VALID_HEAP_BLOCK:
    case LPSTR_FREED_HEAP_BLOCK:
        HeapDestroy((HANDLE) *SCInfo);
        break;
    case LPSTR_VALID_NT_IMAGE_NAME:
    case LPSTR_NON_EXISTANT_IMAGE_NAME:
    case LPSTR_INVALID_FILE_NAME:
    case LPSTR_NON_EXISTENT_DIRECTORY:
    case LPSTR_VALID_CURRENT_DIRECTORY:
    case LPSTR_DOUBLE_NULL_STRING:
    case LPSTR_DOUBLE_NULL_NULL:
    case LPSTR_EMPTY:
    case LPSTR_INIFILE_FILENAME:
    case LPSTR_INIFILE_SECTION_NAME:
    case LPSTR_INIFILE_KEYNAME:
    case LPSTR_INIFILE_INT:
    case LPSTR_INIFILE_STRING:
    case LPSTR_INIFILE_KEY_VALUE:
    case LPSTR_INIFILE_SECTION:
    case LPSTR_BUFFER_1K:
    case LPSTR_BUFFER_512_BYTE:
    case LPSTR_BUFFER_1_BYTE:
    case LPSTR_REG_KEYNAME:
    case LPSTR_REG_VALUENAME:
    case LPSTR_257_CHAR:
    case LPSTR_46CHAR:
    case LPSTR_OPEN:
    case LPSTR_COMMAND_LINE:
    case LPSTR_TEMP_DIR:
    case LPSTR_ROOT_DIR:
        if (*SCInfo!=NULL)
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPSTRCleanup",CaseNo,"LocalFree failed!");
            break;
            
    case LPSTR_TEMP_FILE_NAME:
        if( *SCInfo )
        {
            LPSTR lpMem ;
            
            LocalUnlock( (HANDLE)*SCInfo ) ;
            
            lpMem = LocalLock( (HANDLE)*SCInfo ) ;
            if( lpMem )
                DeleteFile(lpMem) ;
            else
                ErrorPrint(hConOut,hLog,"LPSTRCleanup",CaseNo,"LocalLock failed!");
            
            LocalUnlock( (HANDLE)*SCInfo ) ;
            
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPSTRCleanup",CaseNo,"LocalFree failed!");
        }
        break ;
        
    case LPSTR_FILENAME_VALID:
    case LPSTR_FILENAME_INVALID1:
    case LPSTR_FILENAME_INVALID2:
    case LPSTR_FILENAME_INVALID3:
    case LPSTR_FILENAME_INVALID4:
    case LPSTR_FILENAME_INVALID5:
    case LPSTR_FILENAME_INVALID6:
    case LPSTR_FILENAME_INVALID7:
    case LPSTR_FILENAME_INVALID8:
    case LPSTR_FILENAME_INVALID9:
    case LPSTR_DIRNAME_VALID:
    case LPSTR_DIRNAME_INVALID1:
    case LPSTR_DIRNAME_INVALID2:
    case LPSTR_DIRNAME_INVALID3:
    case LPSTR_DIRNAME_INVALID4:
    case LPSTR_SRC_FILE_EXISTS:
    case LPSTR_SRC_FILE_NOT_EXISTS:
    case LPSTR_DEST_FILE_EXISTS:
    case LPSTR_DEST_FILE_NOT_EXISTS:
        FIOLpstrCleanup(CaseNo, SCInfo, hLog, hConOut);
        break;
        
    case LPSTR_64K_BUFFER:
    case LPSTR_FAT_FILENAME:
    case LPSTR_FILENAME_BOGUS:
    case LPSTR_NTFS_FILENAME:
    case LPSTR_RELATIVE_FILENAME:
    case LPSTR_REMOTE_FILENAME:
    case LPSTR_TOO_LONG:
    case LPSTR_UNC_FILENAME:
        GlobalFree(*SCInfo);
        break;
        
    case LPSTR_2BYTE_BUFFER:
        FreeNativeBuffer(*SCInfo, SMALL_NATIVE_BUFFER_SIZE);
        
        break;
        
    case LPSTR_INVALID_1:
    case LPSTR_INVALID_N:
        MakeBadPointer(NULL,
            (SE_CLEANUP_INFO **)SCInfo,
            CLEANUP,
            0,
            hConOut,
            hLog);
        
        if (*SCInfo) {
            ErrorPrint(hConOut, hLog, "LPSTRCleanup", CaseNo,
                "Cleanup failed.");
        }
        
        break;
        
    default:
        break;
    }
}



/******************************************************************************
L     PPPP   SSSS Y   Y  SSSS TTTTT EEEEE M   M       IIIII N   N FFFFF  OOO
L     P   P S      Y Y  S       T   E     MM MM         I   NN  N F     O   O
L     PPPP   SSS    Y    SSS    T   EEEE  M M M         I   N N N FFFF  O   O
L     P         S   Y       S   T   E     M   M         I   N  NN F     O   O
LLLLL P     SSSS    Y   SSSS    T   EEEEE M   M _____ IIIII N   N F      OOO
******************************************************************************/

PVOID LPSYSTEM_INFOSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
#if 0
    LPSYSTEM_INFO Ret;
    
    switch(CaseNo) {
        
    default:
        ErrorPrint(hConOut,hLog,"LPSYSTEM_INFOSetup",CaseNo,"Unknown Case");
        Ret = (LPSYSTEM_INFO) NULL;
        break;
    }
    
    return(Ret);
    
    SCInfo;
#endif
    return 0;
}


void LPSYSTEM_INFOCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    CaseNo;
    SCInfo;
    hLog;
    hConOut;
}



/************************************************************************
L     PPPP   SSSS Y   Y  SSSS TTTTT EEEEE M   M TTTTT IIIII M   M EEEEE
L     P   P S      Y Y  S       T   E     MM MM   T     I   MM MM E
L     PPPP   SSS    Y    SSS    T   EEEE  M M M   T     I   M M M EEEE
L     P         S   Y       S   T   E     M   M   T     I   M   M E
LLLLL P     SSSS    Y   SSSS    T   EEEEE M   M   T   IIIII M   M EEEEE
************************************************************************/

LPSYSTEMTIME LPSYSTEMTIMESetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPSYSTEMTIME Ret;
    
    switch(CaseNo) {
        
    case LPSYSTEMTIME_NULL:
        Ret = NULL;
        break;
    case LPSYSTEMTIME_VALID_ADDRESS:
        if ( (Ret = malloc(sizeof(SYSTEMTIME))) == NULL )
            ErrorPrint(hConOut,hLog,"LPSYSTEMTIMESetup",CaseNo,
            "Error allocating memory");
        *SCInfo = Ret;
        break;
    case LPSYSTEMTIME_VALID_DATA:
        if ( (Ret = malloc(sizeof(SYSTEMTIME))) == NULL )
            ErrorPrint(hConOut,hLog,"LPSYSTEMTIMESetup",CaseNo,
            "Error allocating memory");
        Ret->wYear         = 1472;
        Ret->wMonth        = 3;    // march
        Ret->wDayOfWeek    = 5;    // friday
        Ret->wDay          = 20;
        Ret->wHour         = 10;
        Ret->wMinute       = 35;
        Ret->wSecond       = 40;
        Ret->wMilliseconds = 0;
        *SCInfo = Ret;
        break;
    case LPSYSTEMTIME_INVALID_DATA:
        if ( (Ret = malloc(sizeof(SYSTEMTIME))) == NULL )
            ErrorPrint(hConOut,hLog,"LPSYSTEMTIMESetup",CaseNo,
            "Error allocating memory");
        memchr(Ret, -1, sizeof(SYSTEMTIME));  // -1's should be garbage for all
        *SCInfo = Ret;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPSYSTEMTIMESetup",CaseNo,"Unknown Case");
        Ret = (LPSYSTEMTIME) NULL;
        break;
    }
    
    return(Ret);
}


void LPSYSTEMTIMECleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPSYSTEMTIME_VALID_ADDRESS:
    case LPSYSTEMTIME_VALID_DATA:
    case LPSYSTEMTIME_INVALID_DATA:
        if ( *SCInfo != NULL )
            free(*SCInfo);
    default:
        break;
    }
    
    hConOut;
    hLog;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\w_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    w_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'W'. It also contains setup and cleanup
    funtions beginning with 'LPW'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/


#include <setcln.h>
#include <W_Cases.bmh>
#include <filever.h>

UINT
WINAPI
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );



LPWIN32_FIND_DATAA LPWIN32_FIND_DATAASetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPWIN32_FIND_DATAA Ret;
    
    switch(CaseNo) {
        
    case LPWIN32_FIND_DATAA_VALID:
        if ( (Ret = malloc(sizeof(WIN32_FIND_DATAA))) == NULL )
            ErrorPrint(hConOut,hLog,"LPWIN32_FIND_DATAASetup",CaseNo,
            "Error allocating memory");
        *SCInfo = Ret;
        break;
    case LPWIN32_FIND_DATAA_NULL:
        Ret = NULL;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPWIN32_FIND_DATAASetup",CaseNo,"Unknown Case");
        Ret = (LPWIN32_FIND_DATAA) NULL;
        break;
    }
    
    return(Ret);
}


void LPWIN32_FIND_DATAACleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
        
    case LPWIN32_FIND_DATAA_VALID:
        if ( *SCInfo != NULL )
            free(*SCInfo);
        break;
    default:
        break;
    }
    
    hConOut;
    hLog;
}


LPWIN32_FIND_DATAW LPWIN32_FIND_DATAWSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPWIN32_FIND_DATAW Ret;
    
    switch(CaseNo) {
        
    case LPWIN32_FIND_DATAW_VALID:
        if ( (Ret = malloc(sizeof(WIN32_FIND_DATAW))) == NULL )
            ErrorPrint(hConOut,hLog,"LPWIN32_FIND_DATAWSetup",CaseNo,
            "Error allocating memory");
        *SCInfo = Ret;
        break;
    case LPWIN32_FIND_DATAW_NULL:
        Ret = NULL;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPWIN32_FIND_DATAWSetup",CaseNo,"Unknown Case");
        Ret = (LPWIN32_FIND_DATAW) NULL;
        break;
    }
    
    return(Ret);
}


void LPWIN32_FIND_DATAWCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPWIN32_FIND_DATAW_VALID:
        if ( *SCInfo != NULL )
            free(*SCInfo);
        break;
    default:
        break;
    }
    
    hConOut;
    hLog;
}


LPWORD LPWORDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    LPWORD Ret;
    LPWORD lpTemp;
    WORD   i;
    
    switch(CaseNo) {
        
    case LPWORD_NULL:
        Ret     = NULL;
        *SCInfo = Ret;
        break;
    case LPWORD_MINUS_ONE:
        if ( (Ret = malloc(sizeof(WORD))) == NULL )
            ErrorPrint(hConOut,hLog,"LPWORDSetup",CaseNo,
            "Error allocating memory");
        else
            *Ret = (WORD)-1;
        *SCInfo = Ret;
        break;
    case LPWORD_FREED_LOCAL:
        if ( (Ret = LocalAlloc(LPTR, sizeof(WORD))) == NULL )
            ErrorPrint(hConOut,hLog,"LPWORDSetup",CaseNo,
            "Error allocating memory");
        else
        { // bogus memory
            *SCInfo = Ret;
            LocalFree(Ret);
        }
        
        break;
    case LPWORD_65_VALID:
        if ( (Ret = LocalAlloc(LPTR, 65*sizeof(WORD))) == NULL )
            ErrorPrint(hConOut,hLog,"LPWORDSetup",CaseNo,
            "Error allocating memory");
        else
        { // 0 to 64
            lpTemp = Ret; 
            for (i=0; i< 65; i++)
            {
                *lpTemp++ = i;
            }
            *SCInfo = Ret;
        }
        
        break;
    case LPWORD_VALID_ADDRESS:
        if ( (Ret = malloc(sizeof(WORD))) == NULL )
            ErrorPrint(hConOut,hLog,"LPWORDSetup",CaseNo,
            "Error allocating memory");
        *SCInfo = Ret;
        break;
    default:
        ErrorPrint(hConOut,hLog,"LPWORDSetup",CaseNo,"Unknown Case");
        Ret = (LPWORD) NULL;
        break;
    }
    
    return(Ret);
}


void LPWORDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    case LPWORD_VALID_ADDRESS:
    case LPWORD_MINUS_ONE:
        if ( *SCInfo != NULL )
            free(*SCInfo);
        break;
    default:
        break;
    }
    
    hConOut;
    hLog;
}



/************************************
L     PPPP  W   W  SSSS TTTTT RRRR
L     P   P W   W S       T   R   R
L     PPPP  W W W  SSS    T   RRRR
L     P     WW WW     S   T   R  R
LLLLL P     W   W SSSS    T   R   R
************************************/

LPWSTR
LPWSTRSetup(
            int CaseNo,
            LPVOID *SCInfo,
            HANDLE hLog,
            HANDLE hConOut
            )
{
    LPWSTR Ret;
    
    UNREFERENCED_PARAMETER( hConOut );
    
    *SCInfo = NULL;
    switch (CaseNo) {
        
    case LPWSTR_RANDOM:
        Ret = (LPWSTR) rand();
        break;
        
    case LPWSTR_MINUS_ONE:
        Ret = (LPWSTR) -1;
        break;
        
    case LPWSTR_46CHAR:
        Ret = (LPWSTR) LocalAlloc (LPTR, (50 * sizeof(WCHAR)));
        if (Ret != NULL)
            lstrcpyW (Ret, (LPCWSTR)L"The quick brown fox jumped over the lazy dogs");
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_DISPLAY:
        Ret = (LPWSTR) LocalAlloc (LPTR, (8 * sizeof(WCHAR)));
        if (Ret != NULL)
            lstrcpyW (Ret, (LPCWSTR)L"DISPLAY");
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_OPEN:
        Ret = (LPWSTR) LocalAlloc (LPTR, 5 * sizeof(WCHAR));
        if (Ret != NULL)
            lstrcpyW (Ret, (LPCWSTR)L"OPEN");
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_FILE_NAME:
        if ((Ret = (LPWSTR) LocalAlloc(LPTR, MAX_PATH*sizeof(WCHAR))) != NULL) {
            lstrcpyW(Ret, (LPCWSTR)L"D:\\WinNT\\system32\\setup.bmp");
        } else {
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        }
        *SCInfo = Ret;
        break;
        
    case LPWSTR_COMMAND_LINE:
        Ret = (LPWSTR) LocalAlloc( LPTR, 64 );
        if (Ret!=NULL)
            lstrcpyW( Ret, (LPCWSTR)L"a b c d e f g h i j k l m" );
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_INVALID_FILE_NAME:
        Ret = (LPWSTR) LocalAlloc( LPTR, 64 );
        if (Ret!=NULL)
            lstrcpyW( Ret, (LPCWSTR)L"[/]" );
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_NON_EXISTENT_DIRECTORY:
        Ret = (LPWSTR) LocalAlloc( LPTR, 100 );
        if (Ret!=NULL)
            lstrcpyW( Ret, (LPCWSTR)L"\\aaa\\bbb\\ccc\\ddd\\eee\\fff\\gomer\\hhh\\iii" );
        break;
        
    case LPWSTR_EMPTY:
    case LPWSTR_VALID_100:
        Ret = (LPWSTR) LocalAlloc( LPTR, 100*sizeof(WCHAR) );
        if (Ret == NULL)
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_NULL:
        Ret = (LPWSTR) NULL;
        break;
        
    case LPWSTR_NULL_STRING:
        *SCInfo = Ret = (LPWSTR)malloc(sizeof L"");
        
        if (!Ret) {
            ErrorPrint(hConOut,
                hLog,
                "LPWSTRSetup",
                CaseNo,
                "GlobalAlloc failed");
            
            break;
        }
        
        *Ret = L'\0';
        
        break;
        
    case LPWSTR_2BYTE_BUFFER:
        // pointer to a buffer too small for the shortest cannonical
        // privilege or name/ascii verison of a display name, or username.
        
        if ( NULL == (Ret = GetNativeBuffer(SMALL_NATIVE_BUFFER_SIZE)) ) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "LocalAlloc failed!");
        }
        
        *SCInfo = Ret;
        
        break;
        
    case LPWSTR_INVALID: {
    /*
    * first DWORD of WSTR valid, non-null chars
        */
        
        SE_CLEANUP_INFO      *CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            INVALID_POINTER,
            0,
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                         }
        
                         /*
                         * a nice way to avoid duplicating code:
        */
        
#define  STRDUP( targ, src ) \
    (targ) = (LPWSTR)malloc( sizeof(src) ); \
    if ( !targ ) { \
    ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo, "malloc failed!" ); \
    } else { \
    lstrcpyW( targ, src ); \
    *SCInfo = (targ); \
                         }
        
    case LPWSTR_64K_BUFFER:
    /*
    * pointer to a 64k buffer
        */
        
        Ret = (LPWSTR)malloc(64*1024U);
        
        *SCInfo = Ret;
        
        if (!Ret) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "LocalAlloc failed!");
        }
        
        break;
        
        
    case LPWSTR_BUFFER_1K:
    /*
    * pointer to a 1k buffer
        */
        
        Ret = (LPWSTR)malloc(1024 * sizeof(WCHAR));
        
        *SCInfo = Ret;
        
        if (!Ret) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "LocalAlloc failed!");
        }
        
        break;
        
        
    case LPWSTR_FAT_FILENAME: {
        //
        // Valid FAT filename
        //
        WCHAR c;
        DWORD FSNameLen = 256, Drives, MaxComponentLength;
        WCHAR Path[] = L" :\\";
        LPWSTR FSName;
        
        Ret = NULL;
        
        FSName = (LPWSTR)malloc(FSNameLen);
        
        if (!FSName) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "GlobalAlloc failed.");
        }
        
        Drives = 0x03FFFFFF >> 2;   // skip 'a' and 'b'
        
        for (c = L'c'; Drives; c++, Drives >>= 1) {
            if (Drives & 1) {
                Path[0] = c;
                
                if (GetVolumeInformationW(Path,
                    NULL,         // lpVolumeNameBuffer
                    0,            // nVolumeNameSize
                    NULL,         // lpVolumeSerialNumber
                    &MaxComponentLength,
                    NULL,         // lpFileSystemFlags
                    FSName,
                    FSNameLen)) {
                    if (lstrcmpW(FSName, (LPCWSTR)L"FAT")) {
                    /*
                    * found
                        */
                        
                        break;
                    }
                } else {
                    // ChrisPi disabled 11-10-00 (GVI() can fail since we pass all possible drives to it)
                    
                    // ErrorPrint(hConOut, hLog, "LPWSTRSetup",
                    //     CaseNo,
                    //     "GetVolumeInformation failed.");
                }
            }
        }
        
        if (!Drives) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "No FAT drive found.");
        } else {
            STRDUP(Ret, (LPCWSTR)L" :\\testfile.fat");
            
            Ret[0] = c;
        }
        
        free(FSName);
        
        break;
                              }
        
    case LPWSTR_FILENAME_BOGUS:
    /*
    * filename with invalid chars
        */
        
        STRDUP(Ret, (LPCWSTR)L"bogus:test:filename");
        
        break;
        
    case LPWSTR_INVALID_1: {
    /*
    * first DWORD of WSTR valid, non-null chars
        */
        
        int         i;
        SE_CLEANUP_INFO      *CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            1 * sizeof (DWORD),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        try {
            for (i = 0; i < (1 * sizeof (DWORD)) / sizeof (WCHAR); i++) {
                Ret[i] = L'c';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "Trapped too soon!");
            
            MakeBadPointer(NULL,
                &CleanupInfo,
                CLEANUP,
                0,
                hConOut,
                hLog);
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                           }
        
    case LPWSTR_INVALID_N: {
    /*
    * a STR with all but last DWORD of length valid, arbitraily make it
    * 10 DWORDS long
        */
        
        int         i;
        SE_CLEANUP_INFO      *CleanupInfo;
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            10 * sizeof (DWORD),
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "MakeBadPointer failed");
        }
        
        try {
            for (i = 0; i < (10 * sizeof (DWORD)) / sizeof (WCHAR); i++) {
                Ret[i] = L'd';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "Trapped too soon!");
            
            MakeBadPointer(NULL,
                &CleanupInfo,
                CLEANUP,
                0,
                hConOut,
                hLog);
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                           }
        
    case LPWSTR_NTFS_FILENAME: {
    /*
    * valid NTFS filename (includes unicode chars)
        */
        
        STRDUP(Ret, (LPCWSTR)L"D:\\foo");
        
        //   for (c = L'c'; c <= L'z'; c++) {
        //      Ret[0] = c;
        
        if (CreateFileW(Ret,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_FLAG_DELETE_ON_CLOSE,
            NULL)) {
            SetLastError(NO_ERROR);
            
            break;
        }
        //   }
        
        if (GetLastError() != NO_ERROR) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            free(Ret);
            
            *SCInfo = Ret = NULL;
        }
        
        break;
                               }
        
    case LPWSTR_RELATIVE_FILENAME:
    /*
    * a relative path/filename
        */
        
        STRDUP(Ret, (LPCWSTR)L"foo");
        
        if (!CreateFileW(Ret,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_FLAG_DELETE_ON_CLOSE,
            NULL)) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            free(Ret);
            
            *SCInfo = Ret = NULL;
        }
        
        break;
        
    case LPWSTR_TOO_LONG: {
    /*
    * a string of characters which is > 64Kb
        */
        
        SE_CLEANUP_INFO      *CleanupInfo;
        
#define  TOO_LONG_STRLEN      66600
        
        if (!MakeBadPointer((PVOID *)&Ret,
            &CleanupInfo,
            VALIDRANGE_POINTER,
            TOO_LONG_STRLEN,
            hConOut,
            hLog)) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "MakeBadPointer failed");
        } else {
            int         i;
            
            /*
            * This string is 64k *bytes* long, but we're stomping
            * characters in to the array.
            */
            
            for (i = 0; i < (TOO_LONG_STRLEN - 1) / sizeof (WCHAR); i++) {
                Ret[i] = L'a';
            }
            
            Ret[i] = L'\0';
        }
        
        *SCInfo = CleanupInfo;
        
        break;
                          }
        
    case LPWSTR_UNC_FILENAME:
    /*
    * a UNC filename
        */
        
        STRDUP(Ret, (LPCWSTR)L"\\\\scratch\\scratch\\foo");
        
        if (!CreateFileW(Ret,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_FLAG_DELETE_ON_CLOSE,
            NULL)) {
            ErrorPrint(hConOut, hLog, "LPWSTRSetup", CaseNo,
                "CreateFile failed, file doesn't exist.");
            
            free(Ret);
            
            *SCInfo = Ret = NULL;
        }
        
        break;
        
    case LPWSTR_TEMP_FILE_NAME:
        {
            HANDLE hMem ;
            LPWSTR  lpMem ;
            
            hMem  = LocalAlloc( LPTR, 145 ) ;
            if( !hMem )
            {
                ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
                Ret = NULL ;
                *SCInfo = NULL ;
            }
            else
            {
                *SCInfo = (LPVOID)hMem ;
                
                lpMem = (LPWSTR)LocalLock( hMem ) ;
                if( !lpMem )
                {
                    ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"LocalAlloc failed!");
                    Ret = NULL ;
                }
                else
                {
                    if( !GetTempFileNameW( (LPCWSTR)L".", (LPCWSTR)L"LPWSTR", 0, lpMem ) )
                    {
                        ErrorPrint(hConOut,hLog,"LPSTRSetup",CaseNo,"GetTempFileName failed!");
                        Ret = NULL ;
                    }
                    else
                        Ret = lpMem ;
                }
            }
        }
        break ;
        
    case LPWSTR_TEMP_DIR:
        Ret = (LPWSTR) LocalAlloc (LPTR, (MAX_PATH * sizeof(WCHAR)));
        if (Ret != NULL)
            //GetTempPathW(MAXPATH, Ret);
            wcscpy(Ret, (LPCWSTR)L"z:\\");
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_ROOT_DIR:
        Ret = (LPWSTR) LocalAlloc (LPTR, (MAX_PATH * sizeof(WCHAR)));
        if (Ret != NULL)
            lstrcpyW (Ret, (LPCWSTR)L"t:\\");
        else
            ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo,"LocalAlloc failed!");
        *SCInfo = Ret;
        break;
        
    case LPWSTR_SRC_FILE_EXISTS:
    case LPWSTR_SRC_FILE_NOT_EXISTS:
    case LPWSTR_FILENAME_VALID:
    case LPWSTR_FILENAME_INVALID1:
    case LPWSTR_FILENAME_INVALID2:
    case LPWSTR_FILENAME_INVALID3:
    case LPWSTR_FILENAME_INVALID4:
    case LPWSTR_FILENAME_INVALID5:
    case LPWSTR_FILENAME_INVALID6:
    case LPWSTR_FILENAME_INVALID7:
    case LPWSTR_FILENAME_INVALID8:
    case LPWSTR_FILENAME_INVALID9:
    case LPWSTR_DIRNAME_INVALID1:
    case LPWSTR_DIRNAME_INVALID2:
    case LPWSTR_DIRNAME_INVALID3:
    case LPWSTR_DIRNAME_INVALID4:
    case LPWSTR_LOGICAL_DRIVE_STRING_BUFFER:
    case LPWSTR_TEMP_PATH_BUFFER:
    case LPWSTR_DEST_FILE_EXISTS:
    case LPWSTR_DEST_FILE_NOT_EXISTS:
    case LPWSTR_DIRNAME_VALID:
    case LPWSTR_PATH_EXISTS:
    case LPWSTR_PATH_NOT_EXISTS:
    case LPWSTR_PREFIX_VALID:
    case LPWSTR_PREFIX_TOO_LONG:
    case LPWSTR_VALID_PATH_BUFFER:
    case LPWSTR_VALID_ROOT_PATHNAME:
    case LPWSTR_INVALID_ROOT_PATHNAME:
    case LPWSTR_FILE_EXISTS:
    case LPWSTR_FILE_NOT_EXISTS:
    case LPWSTR_FILE_READONLY:
    case LPWSTR_VOLUME_NAME_BUFFER:
    case LPWSTR_FILE_SYSTEM_NAME_BUFFER:
    case LPWSTR_SEARCH_PATH_ILL_FORMED:
    case LPWSTR_SEARCH_PATH_BAD_CHARS:
    case LPWSTR_FILE_IN_CURR_DIR_NO_EXT:
    case LPWSTR_EXT_FILE_IN_CURR_DIR:
    case LPWSTR_EXT_ILL_FORMED:
    case LPWSTR_EXT_BAD_CHARS:
    case LPWSTR_FILE_NOT_EXISTS_ON_PATH:
        Ret = FIOLpstrSetupW(CaseNo, SCInfo, hLog, hConOut);
        break;
        
    default:
        Ret = (LPWSTR)NULL;
        ErrorPrint(hConOut,hLog,"LPWSTRSetup",CaseNo, "Unknown Case");
        break;
    }
    
    return Ret;
}


void
LPWSTRCleanup(
              int                     CaseNo,
              LPVOID                  *SCInfo,
              HANDLE                  hLog,
              HANDLE                  hConOut
              )
{
    switch(CaseNo) {
    case LPWSTR_64K_BUFFER:
    case LPWSTR_BUFFER_1K:
    case LPWSTR_FAT_FILENAME:
    case LPWSTR_FILENAME_BOGUS:
    case LPWSTR_NON_EXISTENT_DIRECTORY:
    case LPWSTR_NTFS_FILENAME:
    case LPWSTR_NULL_STRING:
    case LPWSTR_RELATIVE_FILENAME:
    case LPWSTR_UNC_FILENAME:
        
    /*
    * These allocations were made with malloc(), free()
    * them.
        */
        
        free(*SCInfo);
        
        break;
        
    case LPWSTR_46CHAR:
    case LPWSTR_DISPLAY:
    case LPWSTR_OPEN:
    case LPWSTR_INVALID_FILE_NAME:
    case LPWSTR_NON_EXISTANT_DIRECTORY:
    case LPWSTR_VALID_100:
    case LPWSTR_COMMAND_LINE:
    case LPWSTR_EMPTY:
    case LPWSTR_TEMP_DIR:
    case LPWSTR_ROOT_DIR:
    case LPWSTR_FILE_NAME:
        if ((*SCInfo)!=NULL) {
            if (LocalFree((HANDLE)(*SCInfo))!=NULL)
                ErrorPrint(hConOut,hLog,"LPWSTRCleanup",CaseNo,"LocalFree failed!");
        }
        break;
        
    case LPWSTR_TEMP_FILE_NAME:
        if( *SCInfo )
        {
            LPSTR lpMem ;
            
            LocalUnlock( (HANDLE)*SCInfo ) ;
            
            lpMem = LocalLock( (HANDLE)*SCInfo ) ;
            if( lpMem )
                DeleteFile(lpMem) ;
            else
                ErrorPrint(hConOut,hLog,"LPSTRCleanup",CaseNo,"LocalLock failed!");
            
            LocalUnlock( (HANDLE)*SCInfo ) ;
            
            if (LocalFree( (HANDLE)(*SCInfo) )!=NULL)
                ErrorPrint(hConOut,hLog,"LPSTRCleanup",CaseNo,"LocalFree failed!");
        }
        break ;
        
    case LPWSTR_2BYTE_BUFFER:
        
    /*
    * This allocation was made by calling
    * GetNativeBuffer(), FreeNativeBuffer() them.
        */
        
        FreeNativeBuffer(*SCInfo, SMALL_NATIVE_BUFFER_SIZE);
        
        break;
        
    case LPWSTR_INVALID:
    case LPWSTR_INVALID_1:
    case LPWSTR_TOO_LONG:
    case LPWSTR_INVALID_N:
        
    /*
    * These allocations were made by calling
    * MakeBadPointer(), call MakeBadPointer again telling
    * it to clean up.
        */
        
        MakeBadPointer(NULL,
            (SE_CLEANUP_INFO **)SCInfo,
            CLEANUP,
            0,
            hConOut,
            hLog);
        
        if (*SCInfo) {
            ErrorPrint(hConOut,
                hLog,
                "LPSTRCleanup",
                CaseNo,
                "Cleanup failed.");
        }
        
        break;
        
    case LPWSTR_FILENAME_INVALID1:
    case LPWSTR_FILENAME_INVALID2:
    case LPWSTR_FILENAME_INVALID3:
    case LPWSTR_FILENAME_INVALID4:
    case LPWSTR_FILENAME_INVALID5:
    case LPWSTR_FILENAME_INVALID6:
    case LPWSTR_FILENAME_INVALID7:
    case LPWSTR_FILENAME_INVALID8:
    case LPWSTR_FILENAME_INVALID9:
    case LPWSTR_DIRNAME_INVALID1:
    case LPWSTR_DIRNAME_INVALID2:
    case LPWSTR_DIRNAME_INVALID3:
    case LPWSTR_DIRNAME_INVALID4:
        if ( *SCInfo ) {
            UNICODE_STRING Unicode;
            Unicode.Buffer = *SCInfo;
            RtlFreeUnicodeString( &Unicode );
        }
        break;
        
    case LPWSTR_NULL:
    default:
        
    /*
    * There was no allocation made for these cases.
        */
        
        break;
    }
}


WCHAR WCHARSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    WCHAR Ret;
    
    switch(CaseNo) {
        
    case WCHAR_A:
        Ret = L'a';
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"WCHARSetup",CaseNo,"Unknown Case");
        Ret = (WCHAR)0;
        break;
    }
    
    return(Ret);
    
    SCInfo;
}


void WCHARCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    hConOut;
    hLog;
    SCInfo;
}


WORD WORDSetup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    WORD Ret;
    
    switch(CaseNo) {
        
    case WORD_NULL:
        Ret = (WORD)0;
        break;
    case WORD_MINUS_ONE:
        Ret = (WORD) -1;
        break;
    case WORD_RANDOM:
        Ret = (WORD) rand();
        break;
    case WORD_ONE:
        Ret = (WORD) 1;
        break;
    case WORD_VALID_DOS_DATE:
        Ret = MAKE_DOS_DATE(11, 14, 2);   // Nov 14, 1982
        break;
    case WORD_INVALID_DOS_DATE:
        Ret = MAKE_DOS_DATE(13, 32, 127); // each out of range
        break;
    case WORD_VALID_DOS_TIME:
        Ret = MAKE_DOS_TIME(22, 20, 12);  // 10:20 and 24 seconds
        break;
    case WORD_INVALID_DOS_TIME:
        Ret = MAKE_DOS_TIME(24, 60, 30);  // each out of range
        break;
    case WORD_ZERO:
        Ret=0;
        break;
        
    default:
        ErrorPrint(hConOut,hLog,"WORDSetup",CaseNo,"Unknown Case");
        Ret = (WORD)0;
        break;
    }
    
    return(Ret);
    
    SCInfo;
}


void WORDCleanup(int CaseNo,LPVOID *SCInfo,HANDLE hLog, HANDLE hConOut)
{
    switch(CaseNo) {
    default:
        break;
    }
    
    SCInfo;
    hLog;
    hConOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\setclean\z_setcln.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    z_setcln.c

Abstract:

    This module contains setup and cleanup functions for data types
    beginning with the letter 'Z'. It also contains setup and cleanup
    funtions beginning with 'LPZ'. For more information, please refer
    to BadMan.Doc.

Author:

    John Miller (johnmil) 02-Feb-1992

Environment:

    XBox

Revision History:

    01-Apr-2000     schanbai

        Ported to XBox and removed not needed cases

--*/

#include <setcln.h>
#include <z_cases.bmh>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\d_valid.c ===
/*************************************************************************
MODULE: D_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'D'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void DPtoLPValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DebugActiveProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DebugBreakValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DefDlgProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DefFrameProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DefMDIChildProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DefWindowProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeferWindowPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}



/******************************************************/

void DeleteAceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteAtomValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteCriticalSectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void DeleteColorSpaceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeleteObjectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DestroyAcceleratorTableValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DestroyCaretValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DestroyCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DestroyIconValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DestroyMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DestroyWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DeviceCapabilitiesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void DeviceCapabilitiesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void DeviceModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DialogBoxIndirectParamAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DialogBoxIndirectParamWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DialogBoxParamAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DialogBoxParamWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DisconnectNamedPipeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DispatchMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirListAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirListComboBoxAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirListComboBoxWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirListWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirSelectAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirSelectComboBoxAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirSelectComboBoxWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DlgDirSelectWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DosDateTimeToFileTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DrawFocusRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DrawIconValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DrawEscapeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DrawMenuBarValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DrawTextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DrawTextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int 